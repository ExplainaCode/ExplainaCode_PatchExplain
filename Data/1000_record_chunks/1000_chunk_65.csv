record_number,buggy_code,fixed_code,code_similarity
64001,"@Override public Blueprint getPublicBlueprint(String name,CbUser user){
  Blueprint blueprint=blueprintRepository.findByNameInAccount(name,user.getAccount(),user.getUserId());
  if (blueprint == null) {
    throw new NotFoundException(String.format(""String_Node_Str"",name));
  }
  return blueprint;
}","@Override public Blueprint getPublicBlueprint(String name,CbUser user){
  Blueprint blueprint=blueprintRepository.findOneByName(name);
  if (blueprint == null) {
    throw new NotFoundException(String.format(""String_Node_Str"",name));
  }
  return blueprint;
}",0.8980322003577818
64002,"@Override public Credential getPublicBlueprint(String name,CbUser user){
  Credential credential=credentialRepository.findByNameInAccount(name,user.getAccount(),user.getUserId());
  if (credential == null) {
    throw new NotFoundException(String.format(""String_Node_Str"",name));
  }
 else {
    return credential;
  }
}","@Override public Credential getPublicBlueprint(String name,CbUser user){
  Credential credential=credentialRepository.findOneByName(name);
  if (credential == null) {
    throw new NotFoundException(String.format(""String_Node_Str"",name));
  }
 else {
    return credential;
  }
}",0.9048414023372288
64003,"public Stack getPublicStack(String name,CbUser cbUser){
  Stack stack=stackRepository.findByNameInAccount(name,cbUser.getAccount(),cbUser.getUserId());
  if (stack == null) {
    throw new NotFoundException(String.format(""String_Node_Str"",name));
  }
  MDCBuilder.buildMdcContext(stack);
  return stack;
}","public Stack getPublicStack(String name,CbUser cbUser){
  Stack stack=stackRepository.findOneByName(name);
  if (stack == null) {
    throw new NotFoundException(String.format(""String_Node_Str"",name));
  }
  MDCBuilder.buildMdcContext(stack);
  return stack;
}",0.8920353982300885
64004,"public Template getPublicTemplate(String name,CbUser user){
  Template template=templateRepository.findByNameInAccount(name,user.getAccount(),user.getUserId());
  if (template == null) {
    throw new NotFoundException(String.format(TEMPLATE_NOT_FOUND_MSG,name));
  }
 else {
    MDCBuilder.buildMdcContext(template);
    return template;
  }
}","public Template getPublicTemplate(String name,CbUser user){
  Template template=templateRepository.findOneByName(name);
  if (template == null) {
    throw new NotFoundException(String.format(TEMPLATE_NOT_FOUND_MSG,name));
  }
 else {
    MDCBuilder.buildMdcContext(template);
    return template;
  }
}",0.9119010819165378
64005,"@Override public Credential create(CbUser user,Credential credential){
  MDCBuilder.buildMdcContext(credential);
  LOGGER.debug(""String_Node_Str"",user.getUsername(),user.getAccount());
  Credential savedCredential=null;
  credential.setOwner(user.getUserId());
  credential.setAccount(user.getAccount());
  try {
    savedCredential=credentialRepository.save(credential);
  }
 catch (  DataIntegrityViolationException ex) {
    throw new DuplicateKeyValueException(credential.getName(),ex);
  }
  createAzureCertificates(user,savedCredential);
  return savedCredential;
}","@Override public Credential create(CbUser user,Credential credential){
  MDCBuilder.buildMdcContext(credential);
  LOGGER.debug(""String_Node_Str"",user.getUsername(),user.getAccount());
  Credential savedCredential=null;
  credential.setOwner(user.getUserId());
  credential.setAccount(user.getAccount());
  try {
    savedCredential=credentialRepository.save(credential);
  }
 catch (  DataIntegrityViolationException ex) {
    throw new DuplicateKeyValueException(credential.getName(),ex);
  }
  return savedCredential;
}",0.9423604757548032
64006,"private void validateBlueprint(String blueprintText){
  try {
    ObjectMapper mapper=new ObjectMapper();
    JsonNode root=mapper.readTree(blueprintText);
    hasBlueprintInBlueprint(root);
    hasBlueprintNameInBlueprint(root);
    hasHostGroupInBlueprint(root);
    new AmbariClient().validateBlueprint(blueprintText);
  }
 catch (  InvalidBlueprintException e) {
    throw new BadRequestException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new BadRequestException(""String_Node_Str"",e);
  }
}","private void validateBlueprint(String blueprintText){
  try {
    ObjectMapper mapper=new ObjectMapper();
    JsonNode root=mapper.readTree(blueprintText);
    hasBlueprintInBlueprint(root);
    hasBlueprintNameInBlueprint(root);
    hasHostGroupInBlueprint(root);
    new AmbariClient().validateBlueprint(blueprintText);
  }
 catch (  InvalidBlueprintException e) {
    throw new BadRequestException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  IOException e) {
    throw new BadRequestException(""String_Node_Str"",e);
  }
}",0.983732057416268
64007,"private void deleteNetwork(Stack stack,Compute compute){
  for (  Resource resource : stack.getResourcesByType(ResourceType.NETWORK)) {
    try {
      gccStackUtil.removeNetwork(compute,stack,resource.getResourceName());
    }
 catch (    GoogleJsonResponseException ex) {
      gccStackUtil.exceptionHandler(ex,resource.getResourceName());
    }
catch (    IOException e) {
      throw new InternalServerException(e.getMessage());
    }
  }
}","private void deleteNetwork(Stack stack,Compute compute){
  for (  Resource resource : stack.getResourcesByType(ResourceType.FIREWALL)) {
    try {
      gccStackUtil.removeFireWall(compute,stack,resource.getResourceName());
    }
 catch (    GoogleJsonResponseException ex) {
      gccStackUtil.exceptionHandler(ex,resource.getResourceName());
    }
catch (    IOException e) {
      throw new InternalServerException(e.getMessage());
    }
  }
  for (  Resource resource : stack.getResourcesByType(ResourceType.NETWORK)) {
    try {
      gccStackUtil.removeNetwork(compute,stack,resource.getResourceName());
    }
 catch (    GoogleJsonResponseException ex) {
      gccStackUtil.exceptionHandler(ex,resource.getResourceName());
    }
catch (    IOException e) {
      throw new InternalServerException(e.getMessage());
    }
  }
}",0.6959247648902821
64008,"@Override public void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.REQUESTED);
  GccTemplate gccTemplate=(GccTemplate)stack.getTemplate();
  Set<Resource> resourceSet=new HashSet<>();
  GccCredential credential=(GccCredential)setupProperties.get(CREDENTIAL);
  Set<Resource> vms=new HashSet<>();
  try {
    Compute compute=gccStackUtil.buildCompute(credential,stack.getName());
    List<NetworkInterface> networkInterfaces=gccStackUtil.buildNetworkInterfaces(compute,credential.getProjectId(),stack.getName());
    resourceSet.add(new Resource(ResourceType.NETWORK,stack.getName(),stack));
    resourceSet.add(new Resource(ResourceType.NETWORK_INTERFACE,stack.getName(),stack));
    resourceSet.add(new Resource(ResourceType.FIREWALL,stack.getName(),stack));
    for (int i=0; i < stack.getNodeCount(); i++) {
      String forName=gccStackUtil.getVmName(stack.getName(),i);
      Disk disk=gccStackUtil.buildDisk(compute,stack,credential.getProjectId(),gccTemplate.getGccZone(),forName,SIZE);
      resourceSet.add(new Resource(ResourceType.DISK,forName,stack));
      List<AttachedDisk> attachedDisks=gccStackUtil.buildAttachedDisks(forName,disk,compute,stack);
      for (      AttachedDisk attachedDisk : attachedDisks) {
        if (!attachedDisk.getDeviceName().equals(forName)) {
          resourceSet.add(new Resource(ResourceType.ATTACHED_DISK,attachedDisk.getDeviceName(),stack));
        }
      }
      Instance instance=gccStackUtil.buildInstance(compute,stack,networkInterfaces,attachedDisks,forName,userData);
      resourceSet.add(new Resource(ResourceType.VIRTUAL_MACHINE,forName,stack));
      vms.add(new Resource(ResourceType.VIRTUAL_MACHINE,forName,stack));
    }
    if (gccTemplate.getContainerCount() > 0) {
      for (      Resource vm : vms) {
        gccStackUtil.buildRoute(compute,credential.getProjectId(),stack.getName(),stack,gccStackUtil.getVmIdByName(vm.getResourceName()),vm);
        resourceSet.add(new Resource(ResourceType.ROUTE,String.format(""String_Node_Str"",vm.getResourceName()),stack));
      }
    }
  }
 catch (  Exception e) {
    throw new BuildStackFailureException(e.getMessage(),e,resourceSet);
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.GCC,stack.getId(),resourceSet)));
}","@Override public void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.REQUESTED);
  GccTemplate gccTemplate=(GccTemplate)stack.getTemplate();
  Set<Resource> resourceSet=new HashSet<>();
  GccCredential credential=(GccCredential)setupProperties.get(CREDENTIAL);
  Set<Resource> vms=new HashSet<>();
  try {
    Compute compute=gccStackUtil.buildCompute(credential,stack.getName());
    List<NetworkInterface> networkInterfaces=gccStackUtil.buildNetworkInterfaces(compute,credential.getProjectId(),stack.getName());
    resourceSet.add(new Resource(ResourceType.NETWORK,stack.getName(),stack));
    resourceSet.add(new Resource(ResourceType.NETWORK_INTERFACE,stack.getName(),stack));
    resourceSet.add(new Resource(ResourceType.FIREWALL,stack.getName() + ""String_Node_Str"",stack));
    resourceSet.add(new Resource(ResourceType.FIREWALL,stack.getName() + ""String_Node_Str"",stack));
    for (int i=0; i < stack.getNodeCount(); i++) {
      String forName=gccStackUtil.getVmName(stack.getName(),i);
      Disk disk=gccStackUtil.buildDisk(compute,stack,credential.getProjectId(),gccTemplate.getGccZone(),forName,SIZE);
      resourceSet.add(new Resource(ResourceType.DISK,forName,stack));
      List<AttachedDisk> attachedDisks=gccStackUtil.buildAttachedDisks(forName,disk,compute,stack);
      for (      AttachedDisk attachedDisk : attachedDisks) {
        if (!attachedDisk.getDeviceName().equals(forName)) {
          resourceSet.add(new Resource(ResourceType.ATTACHED_DISK,attachedDisk.getDeviceName(),stack));
        }
      }
      Instance instance=gccStackUtil.buildInstance(compute,stack,networkInterfaces,attachedDisks,forName,userData);
      resourceSet.add(new Resource(ResourceType.VIRTUAL_MACHINE,forName,stack));
      vms.add(new Resource(ResourceType.VIRTUAL_MACHINE,forName,stack));
    }
    if (gccTemplate.getContainerCount() > 0) {
      for (      Resource vm : vms) {
        gccStackUtil.buildRoute(compute,credential.getProjectId(),stack.getName(),stack,gccStackUtil.getVmIdByName(vm.getResourceName()),vm);
        resourceSet.add(new Resource(ResourceType.ROUTE,String.format(""String_Node_Str"",vm.getResourceName()),stack));
      }
    }
  }
 catch (  Exception e) {
    throw new BuildStackFailureException(e.getMessage(),e,resourceSet);
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.GCC,stack.getId(),resourceSet)));
}",0.97626582278481
64009,"@Override public boolean checkStatus(GccRemoveReadyPollerObject gccRemoveReadyPollerObject){
  LOGGER.info(""String_Node_Str"",gccRemoveReadyPollerObject.getName(),gccRemoveReadyPollerObject.getStack().getId());
  GccTemplate gccTemplate=(GccTemplate)gccRemoveReadyPollerObject.getStack().getTemplate();
  GccCredential gccCredential=(GccCredential)gccRemoveReadyPollerObject.getStack().getCredential();
  try {
    Integer progress=gccRemoveReadyPollerObject.getCompute().globalOperations().get(gccCredential.getProjectId(),gccRemoveReadyPollerObject.getOperation().getName()).execute().getProgress();
    return (progress.intValue() != FINISHED) ? false : true;
  }
 catch (  GoogleJsonResponseException ex) {
    return exceptionHandler(ex,gccRemoveReadyPollerObject.getName());
  }
catch (  NullPointerException|IOException e) {
    return false;
  }
}","@Override public boolean checkStatus(GccRemoveReadyPollerObject gccRemoveReadyPollerObject){
  LOGGER.info(""String_Node_Str"",gccRemoveReadyPollerObject.getName(),gccRemoveReadyPollerObject.getStack().getId());
  GccTemplate gccTemplate=(GccTemplate)gccRemoveReadyPollerObject.getStack().getTemplate();
  GccCredential gccCredential=(GccCredential)gccRemoveReadyPollerObject.getStack().getCredential();
  try {
    Integer progress=gccRemoveReadyPollerObject.getCompute().zoneOperations().get(gccCredential.getProjectId(),gccTemplate.getGccZone().getValue(),gccRemoveReadyPollerObject.getOperation().getName()).execute().getProgress();
    return (progress.intValue() != FINISHED) ? false : true;
  }
 catch (  GoogleJsonResponseException ex) {
    return exceptionHandler(ex,gccRemoveReadyPollerObject);
  }
catch (  NullPointerException|IOException e) {
    return false;
  }
}",0.9676674364896074
64010,"private boolean exceptionHandler(GoogleJsonResponseException ex,String name){
  if (ex.getDetails().get(""String_Node_Str"").equals(NOT_FOUND)) {
    LOGGER.info(String.format(""String_Node_Str"",name));
    return true;
  }
 else {
    return false;
  }
}","private boolean exceptionHandler(GoogleJsonResponseException ex,GccRemoveReadyPollerObject gccRemoveReadyPollerObject){
  if (ex.getDetails().get(""String_Node_Str"").equals(NOT_FOUND)) {
    GccCredential gccCredential=(GccCredential)gccRemoveReadyPollerObject.getStack().getCredential();
    try {
      Integer progress=gccRemoveReadyPollerObject.getCompute().globalOperations().get(gccCredential.getProjectId(),gccRemoveReadyPollerObject.getOperation().getName()).execute().getProgress();
      return (progress.intValue() != FINISHED) ? false : true;
    }
 catch (    IOException e) {
      return false;
    }
  }
 else {
    return false;
  }
}",0.3481152993348115
64011,"public List<AttachedDisk> buildAttachedDisks(String name,Disk disk,Compute compute,Stack stack) throws IOException {
  GccTemplate gccTemplate=(GccTemplate)stack.getTemplate();
  GccCredential gccCredential=(GccCredential)stack.getCredential();
  List<AttachedDisk> listOfDisks=new ArrayList<>();
  AttachedDisk diskToInsert=new AttachedDisk();
  diskToInsert.setBoot(true);
  diskToInsert.setType(GccDiskType.PERSISTENT.getValue());
  diskToInsert.setMode(GccDiskMode.READ_WRITE.getValue());
  diskToInsert.setDeviceName(name);
  diskToInsert.setSource(String.format(""String_Node_Str"",gccCredential.getProjectId(),gccTemplate.getGccZone().getValue(),disk.getName(),gccTemplate.getGccZone()));
  listOfDisks.add(diskToInsert);
  for (int i=0; i < gccTemplate.getVolumeCount(); i++) {
    String value=name + i;
    Disk disk1=buildRawDisk(compute,stack,gccCredential.getProjectId(),gccTemplate.getGccZone(),value,Long.parseLong(gccTemplate.getVolumeSize().toString()));
    AttachedDisk diskToInsert1=new AttachedDisk();
    diskToInsert1.setBoot(false);
    diskToInsert1.setType(GccDiskType.PERSISTENT.getValue());
    diskToInsert1.setMode(GccDiskMode.READ_WRITE.getValue());
    diskToInsert1.setDeviceName(value);
    diskToInsert1.setSource(String.format(""String_Node_Str"",gccCredential.getProjectId(),gccTemplate.getGccZone().getValue(),disk1.getName()));
    listOfDisks.add(diskToInsert1);
  }
  return listOfDisks;
}","public List<AttachedDisk> buildAttachedDisks(String name,Disk disk,Compute compute,Stack stack) throws IOException {
  GccTemplate gccTemplate=(GccTemplate)stack.getTemplate();
  GccCredential gccCredential=(GccCredential)stack.getCredential();
  List<AttachedDisk> listOfDisks=new ArrayList<>();
  AttachedDisk diskToInsert=new AttachedDisk();
  diskToInsert.setBoot(true);
  diskToInsert.setType(GccDiskType.PERSISTENT.getValue());
  diskToInsert.setMode(GccDiskMode.READ_WRITE.getValue());
  diskToInsert.setDeviceName(name);
  diskToInsert.setSource(String.format(""String_Node_Str"",gccCredential.getProjectId(),gccTemplate.getGccZone().getValue(),disk.getName(),gccTemplate.getGccZone()));
  listOfDisks.add(diskToInsert);
  for (int i=0; i < gccTemplate.getVolumeCount(); i++) {
    String value=name + ""String_Node_Str"" + i;
    Disk disk1=buildRawDisk(compute,stack,gccCredential.getProjectId(),gccTemplate.getGccZone(),value,Long.parseLong(gccTemplate.getVolumeSize().toString()));
    AttachedDisk diskToInsert1=new AttachedDisk();
    diskToInsert1.setBoot(false);
    diskToInsert1.setType(GccDiskType.PERSISTENT.getValue());
    diskToInsert1.setMode(GccDiskMode.READ_WRITE.getValue());
    diskToInsert1.setDeviceName(value);
    diskToInsert1.setSource(String.format(""String_Node_Str"",gccCredential.getProjectId(),gccTemplate.getGccZone().getValue(),disk1.getName()));
    listOfDisks.add(diskToInsert1);
  }
  return listOfDisks;
}",0.9930362116991645
64012,"@Override public User registerUponInvitation(String inviteToken,User userInput){
  User invitedUser=userRepository.findUserByConfToken(inviteToken);
  if (invitedUser != null) {
    invitedUser.setPassword(passwordEncoder.encode(userInput.getPassword()));
    invitedUser.setFirstName(userInput.getFirstName());
    invitedUser.setLastName(userInput.getLastName());
    invitedUser.setStatus(UserStatus.ACTIVE);
    invitedUser.setRegistrationDate(Calendar.getInstance().getTime());
    invitedUser=userRepository.save(invitedUser);
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + userInput);
  }
  return invitedUser;
}","@Override public User registerUponInvitation(String inviteToken,User userInput){
  User invitedUser=userRepository.findUserByConfToken(inviteToken);
  if (invitedUser != null) {
    invitedUser.setPassword(passwordEncoder.encode(userInput.getPassword()));
    invitedUser.setFirstName(userInput.getFirstName());
    invitedUser.setLastName(userInput.getLastName());
    invitedUser.setStatus(UserStatus.ACTIVE);
    invitedUser.setConfToken(null);
    invitedUser.setRegistrationDate(Calendar.getInstance().getTime());
    invitedUser=userRepository.save(invitedUser);
  }
 else {
    throw new NotFoundException(""String_Node_Str"" + userInput);
  }
  return invitedUser;
}",0.9724770642201837
64013,"@Override public Set<InstanceMetaData> getMetaData(String hash){
  Stack stack=stackRepository.findStackByHash(hash);
  if (stack != null) {
    if (!stack.isMetadataReady()) {
      throw new MetadataIncompleteException(""String_Node_Str"");
    }
 else     if (!stack.getInstanceMetaData().isEmpty()) {
      return stack.getInstanceMetaData();
    }
  }
  throw new NotFoundException(""String_Node_Str"");
}","@Override public Set<InstanceMetaData> getMetaData(String hash){
  Stack stack=stackRepository.findStackByHash(hash);
  if (stack != null) {
    if (!Status.UPDATE_IN_PROGRESS.equals(stack.getStatus())) {
      if (!stack.isMetadataReady()) {
        throw new MetadataIncompleteException(""String_Node_Str"");
      }
 else       if (!stack.getInstanceMetaData().isEmpty()) {
        return stack.getInstanceMetaData();
      }
    }
 else {
      throw new MetadataIncompleteException(""String_Node_Str"");
    }
  }
  throw new NotFoundException(""String_Node_Str"");
}",0.7860082304526749
64014,"private void createStorageAccount(AzureClient azureClient,AzureTemplate azureTemplate,String commonName){
  try {
    azureClient.getStorageAccount(commonName);
  }
 catch (  Exception ex) {
    if (((HttpResponseException)ex).getStatusCode() == NOT_FOUND) {
      Map<String,String> props=new HashMap<>();
      props.put(NAME,commonName);
      props.put(DESCRIPTION,azureTemplate.getDescription());
      props.put(AFFINITYGROUP,commonName);
      HttpResponseDecorator storageResponse=(HttpResponseDecorator)azureClient.createStorageAccount(props);
      String requestId=(String)azureClient.getRequestId(storageResponse);
      azureClient.waitUntilComplete(requestId);
    }
 else {
      throw new InternalServerException(ex.getMessage());
    }
  }
}","private void createStorageAccount(Stack stack,AzureClient azureClient,AzureTemplate azureTemplate,String commonName){
  try {
    azureClient.getStorageAccount(commonName);
  }
 catch (  Exception ex) {
    if (((HttpResponseException)ex).getStatusCode() == NOT_FOUND) {
      Map<String,String> props=new HashMap<>();
      props.put(NAME,commonName);
      props.put(DESCRIPTION,azureTemplate.getDescription());
      props.put(AFFINITYGROUP,commonName);
      HttpResponseDecorator storageResponse=(HttpResponseDecorator)azureClient.createStorageAccount(props);
      String requestId=(String)azureClient.getRequestId(storageResponse);
      azureClient.waitUntilComplete(requestId);
    }
 else     if (ex instanceof HttpResponseException) {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),ex);
      throw new InternalServerException(((HttpResponseException)ex).getResponse().toString());
    }
 else {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),ex);
      throw new InternalServerException(ex.getMessage());
    }
  }
}",0.831140350877193
64015,"private void createAffinityGroup(AzureClient azureClient,AzureTemplate azureTemplate,String name){
  try {
    azureClient.getAffinityGroup(name);
  }
 catch (  Exception ex) {
    if (((HttpResponseException)ex).getStatusCode() == NOT_FOUND) {
      Map<String,String> props=new HashMap<>();
      props.put(NAME,name);
      props.put(LOCATION,azureTemplate.getLocation().location());
      props.put(DESCRIPTION,azureTemplate.getDescription());
      HttpResponseDecorator affinityResponse=(HttpResponseDecorator)azureClient.createAffinityGroup(props);
      String requestId=(String)azureClient.getRequestId(affinityResponse);
      azureClient.waitUntilComplete(requestId);
    }
 else {
      throw new InternalServerException(ex.getMessage());
    }
  }
}","private void createAffinityGroup(Stack stack,AzureClient azureClient,AzureTemplate azureTemplate,String name){
  try {
    azureClient.getAffinityGroup(name);
  }
 catch (  Exception ex) {
    if (((HttpResponseException)ex).getStatusCode() == NOT_FOUND) {
      Map<String,String> props=new HashMap<>();
      props.put(NAME,name);
      props.put(LOCATION,azureTemplate.getLocation().location());
      props.put(DESCRIPTION,azureTemplate.getDescription());
      HttpResponseDecorator affinityResponse=(HttpResponseDecorator)azureClient.createAffinityGroup(props);
      String requestId=(String)azureClient.getRequestId(affinityResponse);
      azureClient.waitUntilComplete(requestId);
    }
 else     if (ex instanceof HttpResponseException) {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),ex);
      throw new InternalServerException(((HttpResponseException)ex).getResponse().toString());
    }
 else {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),ex);
      throw new InternalServerException(ex.getMessage());
    }
  }
}",0.8318777292576419
64016,"@Override public void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  AzureTemplate azureTemplate=(AzureTemplate)stack.getTemplate();
  Credential credential=(Credential)setupProperties.get(CREDENTIAL);
  String emailAsFolder=(String)setupProperties.get(EMAILASFOLDER);
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  AzureClient azureClient=azureStackUtil.createAzureClient(credential,filePath);
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.CREATE_IN_PROGRESS);
  String name=stack.getName().replaceAll(""String_Node_Str"",""String_Node_Str"") + String.valueOf(new Date().getTime());
  String commonName=((AzureCredential)credential).getCommonName();
  createAffinityGroup(azureClient,azureTemplate,commonName);
  createStorageAccount(azureClient,azureTemplate,commonName);
  createVirtualNetwork(azureClient,name,commonName);
  Set<Resource> resourceSet=new HashSet<>();
  resourceSet.add(new Resource(ResourceType.AFFINITY_GROUP,commonName,stack));
  resourceSet.add(new Resource(ResourceType.STORAGE,commonName,stack));
  resourceSet.add(new Resource(ResourceType.NETWORK,name,stack));
  for (int i=0; i < stack.getNodeCount(); i++) {
    try {
      String vmName=azureStackUtil.getVmName(name,i) + String.valueOf(new Date().getTime());
      createCloudService(azureClient,azureTemplate,vmName,commonName);
      createServiceCertificate(azureClient,azureTemplate,credential,vmName,emailAsFolder);
      String internalIp=""String_Node_Str"" + (i + VALID_IP_RANGE_START);
      createVirtualMachine(azureClient,azureTemplate,credential,name,vmName,commonName,userData,internalIp);
      resourceSet.add(new Resource(ResourceType.VIRTUAL_MACHINE,vmName,stack));
      resourceSet.add(new Resource(ResourceType.CLOUD_SERVICE,vmName,stack));
      resourceSet.add(new Resource(ResourceType.BLOB,vmName,stack));
    }
 catch (    FileNotFoundException e) {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),e);
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    CertificateException e) {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),e);
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    NoSuchAlgorithmException e) {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),e);
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    Exception e) {
      LOGGER.error(String.format(""String_Node_Str"",e.getMessage(),stack.getId()),e);
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"" + e.getMessage())));
      return;
    }
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.AZURE,stack.getId(),resourceSet)));
}","@Override public void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  AzureTemplate azureTemplate=(AzureTemplate)stack.getTemplate();
  Credential credential=(Credential)setupProperties.get(CREDENTIAL);
  String emailAsFolder=(String)setupProperties.get(EMAILASFOLDER);
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  AzureClient azureClient=azureStackUtil.createAzureClient(credential,filePath);
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.CREATE_IN_PROGRESS);
  String name=stack.getName().replaceAll(""String_Node_Str"",""String_Node_Str"") + String.valueOf(new Date().getTime());
  String commonName=((AzureCredential)credential).getCommonName();
  createAffinityGroup(stack,azureClient,azureTemplate,commonName);
  createStorageAccount(stack,azureClient,azureTemplate,commonName);
  createVirtualNetwork(azureClient,name,commonName);
  Set<Resource> resourceSet=new HashSet<>();
  resourceSet.add(new Resource(ResourceType.AFFINITY_GROUP,commonName,stack));
  resourceSet.add(new Resource(ResourceType.STORAGE,commonName,stack));
  resourceSet.add(new Resource(ResourceType.NETWORK,name,stack));
  for (int i=0; i < stack.getNodeCount(); i++) {
    try {
      String vmName=azureStackUtil.getVmName(name,i) + String.valueOf(new Date().getTime());
      createCloudService(azureClient,azureTemplate,vmName,commonName);
      createServiceCertificate(azureClient,azureTemplate,credential,vmName,emailAsFolder);
      String internalIp=""String_Node_Str"" + (i + VALID_IP_RANGE_START);
      createVirtualMachine(azureClient,azureTemplate,credential,name,vmName,commonName,userData,internalIp);
      resourceSet.add(new Resource(ResourceType.VIRTUAL_MACHINE,vmName,stack));
      resourceSet.add(new Resource(ResourceType.CLOUD_SERVICE,vmName,stack));
      resourceSet.add(new Resource(ResourceType.BLOB,vmName,stack));
    }
 catch (    FileNotFoundException e) {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),e);
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    CertificateException e) {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),e);
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    NoSuchAlgorithmException e) {
      LOGGER.error(String.format(""String_Node_Str"",stack.getId()),e);
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    Exception e) {
      LOGGER.error(String.format(""String_Node_Str"",e.getMessage(),stack.getId()),e);
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"" + e.getMessage())));
      return;
    }
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.AZURE,stack.getId(),resourceSet)));
}",0.9981290926099158
64017,"@Override public void afterPropertiesSet() throws Exception {
  if (""String_Node_Str"".equals(hbm2ddlStrategy) || ""String_Node_Str"".equals(hbm2ddlStrategy)) {
    Company company=new Company();
    company.setName(""String_Node_Str"");
    company=companyRepository.save(company);
    User user2=new User();
    user2.setEmail(""String_Node_Str"");
    user2.setFirstName(""String_Node_Str"");
    user2.setLastName(""String_Node_Str"");
    user2.setPassword(passwordEncoder.encode(""String_Node_Str""));
    user2.setStatus(UserStatus.ACTIVE);
    user2.setCompany(company);
    user2.getUserRoles().add(UserRole.COMPANY_ADMIN);
    AwsCredential awsCredential=new AwsCredential();
    awsCredential.setRoleArn(""String_Node_Str"");
    awsCredential.setAwsCredentialOwner(user2);
    awsCredential.setPublicKey(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    awsCredential.setName(""String_Node_Str"");
    awsCredential.setKeyPairName(""String_Node_Str"");
    user2.getAwsCredentials().add(awsCredential);
    AwsTemplate awsTemplate=new AwsTemplate();
    awsTemplate.setName(""String_Node_Str"");
    awsTemplate.setDescription(""String_Node_Str"");
    awsTemplate.setRegion(Regions.EU_WEST_1);
    awsTemplate.setAmiId(""String_Node_Str"");
    awsTemplate.setInstanceType(InstanceType.T2Small);
    awsTemplate.setSshLocation(""String_Node_Str"");
    awsTemplate.setUser(user2);
    user2.getAwsTemplates().add(awsTemplate);
    Set<Blueprint> blueprints=defaultBlueprintLoaderService.loadBlueprints(user2);
    user2.setBlueprints(blueprints);
    userRepository.save(user2);
  }
}","@Override public void afterPropertiesSet() throws Exception {
  if (""String_Node_Str"".equals(hbm2ddlStrategy) || ""String_Node_Str"".equals(hbm2ddlStrategy)) {
    Company company=new Company();
    company.setName(defaultCompanyName);
    User user=new User();
    user.setEmail(defaultUserEmail);
    user.setFirstName(defaultUserFirstName);
    user.setLastName(defaultUserLastName);
    user.setPassword(passwordEncoder.encode(defaultUserPassword));
    user.setStatus(UserStatus.ACTIVE);
    user.setCompany(company);
    user.getUserRoles().add(UserRole.COMPANY_ADMIN);
    Set<Blueprint> blueprints=defaultBlueprintLoaderService.loadBlueprints(user);
    user.setBlueprints(blueprints);
    company.getUsers().add(user);
    companyRepository.save(company);
  }
}",0.4616023246160232
64018,"public Set<StackJson> convertAllEntityToJsonWithClause(Collection<Stack> entityList){
  Set<StackJson> stackJsons=new HashSet<>();
  for (  Stack stack : entityList) {
    if (Boolean.FALSE.equals(stack.getTerminated())) {
      stackJsons.add(convert(stack));
    }
  }
  return stackJsons;
}","public Set<StackJson> convertAllEntityToJsonWithClause(Collection<Stack> entityList){
  Set<StackJson> stackJsons=new HashSet<>();
  for (  Stack stack : entityList) {
    stackJsons.add(convert(stack));
  }
  return stackJsons;
}",0.8068833652007649
64019,"@Override public HistoryEvent getEventType(ProvisionEntity entity){
  HistoryEvent historyEvent=HistoryEvent.IGNORE;
  if (isEntitySupported(entity)) {
    Long id=null;
    if (entity instanceof Cluster) {
      id=((Cluster)entity).getId();
    }
 else     if (entity instanceof Blueprint) {
      id=((Blueprint)entity).getId();
    }
 else     if (entity instanceof Stack) {
      id=((Stack)entity).getId();
    }
 else     if (entity instanceof Template) {
      id=((Blueprint)entity).getId();
    }
 else     if (entity instanceof Credential) {
      id=((Credential)entity).getId();
    }
    historyEvent=(id != null) ? HistoryEvent.UPDATED : HistoryEvent.CREATED;
  }
  return historyEvent;
}","@Override public HistoryEvent getEventType(ProvisionEntity entity){
  HistoryEvent historyEvent=HistoryEvent.IGNORE;
  if (isEntitySupported(entity)) {
    Long id=null;
    if (entity instanceof Cluster) {
      id=((Cluster)entity).getId();
    }
 else     if (entity instanceof Blueprint) {
      id=((Blueprint)entity).getId();
    }
 else     if (entity instanceof Stack) {
      id=((Stack)entity).getId();
    }
 else     if (entity instanceof Template) {
      id=((Template)entity).getId();
    }
 else     if (entity instanceof Credential) {
      id=((Credential)entity).getId();
    }
    historyEvent=(id != null) ? HistoryEvent.UPDATED : HistoryEvent.CREATED;
  }
  return historyEvent;
}",0.98932384341637
64020,"@Override public StackHistory convert(Stack entity){
  StackHistory stackHistory=new StackHistory();
  stackHistory.setName(entity.getName());
  stackHistory.setEntityId(entity.getId());
  stackHistory.setAmbariIp(entity.getAmbariIp());
  stackHistory.setClusterId(entity.getCluster().getId());
  stackHistory.setCredentialId(entity.getCredential().getId());
  stackHistory.setHash(entity.getHash());
  stackHistory.setMetadataReady(entity.isMetadataReady());
  stackHistory.setNodeCount(entity.getNodeCount());
  stackHistory.setStackCompleted(entity.isStackCompleted());
  stackHistory.setStatus(entity.getStatus().name());
  stackHistory.setStatusReason(entity.getStatusReason());
  stackHistory.setTemplateId(entity.getTemplate().getId());
  stackHistory.setTerminated(entity.getTerminated());
  stackHistory.setVersion(entity.getVersion());
  stackHistory.setDescription(entity.getDescription());
  stackHistory.setUserId(entity.getUser().getId());
  return stackHistory;
}","@Override public StackHistory convert(Stack entity){
  StackHistory stackHistory=new StackHistory();
  stackHistory.setName(entity.getName());
  stackHistory.setEntityId(entity.getId());
  stackHistory.setAmbariIp(entity.getAmbariIp());
  stackHistory.setClusterId(entity.getCluster().getId());
  stackHistory.setCredentialId(entity.getCredential().getId());
  stackHistory.setHash(entity.getHash());
  stackHistory.setMetadataReady(entity.isMetadataReady());
  stackHistory.setNodeCount(entity.getNodeCount());
  stackHistory.setStackCompleted(entity.isStackCompleted());
  stackHistory.setStatus(entity.getStatus().name());
  stackHistory.setStatusReason(entity.getStatusReason());
  stackHistory.setTemplateId(entity.getTemplate().getId());
  stackHistory.setVersion(entity.getVersion());
  stackHistory.setDescription(entity.getDescription());
  stackHistory.setUserId(entity.getUser().getId());
  return stackHistory;
}",0.9716088328075708
64021,"@Override public Set<Stack> getAll(User user){
  Set<Stack> legacyStacks=new HashSet<>();
  Set<Stack> terminatedStacks=new HashSet<>();
  Set<Stack> userStacks=user.getStacks();
  LOGGER.debug(""String_Node_Str"",userStacks.size());
  if (user.getUserRoles().contains(UserRole.COMPANY_ADMIN)) {
    LOGGER.debug(""String_Node_Str"",user.getId());
    legacyStacks=getCompanyUserStacks(user);
  }
 else {
    LOGGER.debug(""String_Node_Str"",user.getId());
    legacyStacks=getCompanyStacks(user);
  }
  LOGGER.debug(""String_Node_Str"",legacyStacks.size(),user.getId());
  userStacks.addAll(legacyStacks);
  legacyStacks.clear();
  for (  Stack stack : userStacks) {
    if (Boolean.FALSE.equals(stack.getTerminated())) {
      terminatedStacks.add(stack);
    }
  }
  return terminatedStacks;
}","@Override public Set<Stack> getAll(User user){
  Set<Stack> legacyStacks=new HashSet<>();
  Set<Stack> terminatedStacks=new HashSet<>();
  Set<Stack> userStacks=user.getStacks();
  LOGGER.debug(""String_Node_Str"",userStacks.size());
  if (user.getUserRoles().contains(UserRole.COMPANY_ADMIN)) {
    LOGGER.debug(""String_Node_Str"",user.getId());
    legacyStacks=getCompanyUserStacks(user);
  }
 else {
    LOGGER.debug(""String_Node_Str"",user.getId());
    legacyStacks=getCompanyStacks(user);
  }
  LOGGER.debug(""String_Node_Str"",legacyStacks.size(),user.getId());
  userStacks.addAll(legacyStacks);
  return userStacks;
}",0.8545067423704755
64022,"@Override public Stack get(User user,Long id){
  Stack stack=stackRepository.findOne(id);
  if (stack == null || Boolean.TRUE.equals(stack.getTerminated())) {
    throw new NotFoundException(String.format(""String_Node_Str"",id));
  }
  return stack;
}","@Override public Stack get(User user,Long id){
  Stack stack=stackRepository.findOne(id);
  if (stack == null) {
    throw new NotFoundException(String.format(""String_Node_Str"",id));
  }
  return stack;
}",0.8986784140969163
64023,"@Override public void accept(Event<StackDeleteComplete> stackDeleteComplete){
  StackDeleteComplete data=stackDeleteComplete.getData();
  LOGGER.info(""String_Node_Str"",ReactorConfig.DELETE_COMPLETE_EVENT,data.getStackId());
  retryingStackUpdater.updateStackStatus(data.getStackId(),Status.DELETE_COMPLETED);
  Stack oneWithLists=stackRepository.findOneWithLists(data.getStackId());
  oneWithLists.setTerminated(Boolean.TRUE);
  stackRepository.save(oneWithLists);
  websocketService.sendToTopicUser(oneWithLists.getUser().getEmail(),WebsocketEndPoint.TERMINATE,new StatusMessage(oneWithLists.getId(),oneWithLists.getName(),Status.DELETE_COMPLETED.name(),String.format(""String_Node_Str"")));
}","@Override public void accept(Event<StackDeleteComplete> stackDeleteComplete){
  StackDeleteComplete data=stackDeleteComplete.getData();
  LOGGER.info(""String_Node_Str"",ReactorConfig.DELETE_COMPLETE_EVENT,data.getStackId());
  retryingStackUpdater.updateStackStatus(data.getStackId(),Status.DELETE_COMPLETED);
  Stack oneWithLists=stackRepository.findOneWithLists(data.getStackId());
  stackRepository.delete(oneWithLists);
  websocketService.sendToTopicUser(oneWithLists.getUser().getEmail(),WebsocketEndPoint.TERMINATE,new StatusMessage(oneWithLists.getId(),oneWithLists.getName(),Status.DELETE_COMPLETED.name(),String.format(""String_Node_Str"")));
}",0.9538002980625933
64024,"public static Stack createStack(User user){
  Stack stack=new Stack();
  stack.setUser(user);
  stack.getUserRoles().addAll(user.getUserRoles());
  stack.setTerminated(Boolean.FALSE);
  return stack;
}","public static Stack createStack(User user){
  Stack stack=new Stack();
  stack.setUser(user);
  stack.getUserRoles().addAll(user.getUserRoles());
  return stack;
}",0.8956043956043956
64025,"@Override public Class<? extends Annotation> annotationType(){
  return this.getClass();
}","@Override public Class<? extends Annotation> annotationType(){
  return getClass();
}",0.9714285714285714
64026,"@PostAuthorize(""String_Node_Str"") AwsCredential findOne(Long id);","@PostAuthorize(""String_Node_Str"") AwsCredential findOne(@Param(""String_Node_Str"") Long id);",0.8333333333333334
64027,"@PostAuthorize(""String_Node_Str"") AwsTemplate findOne(Long id);","@PostAuthorize(""String_Node_Str"") AwsTemplate findOne(@Param(""String_Node_Str"") Long id);",0.8289473684210527
64028,"@PostAuthorize(""String_Node_Str"") AzureCredential findOne(Long id);","@PostAuthorize(""String_Node_Str"") AzureCredential findOne(@Param(""String_Node_Str"") Long id);",0.8375
64029,"@PostAuthorize(""String_Node_Str"") AzureTemplate findOne(Long id);","@PostAuthorize(""String_Node_Str"") AzureTemplate findOne(@Param(""String_Node_Str"") Long id);",0.8333333333333334
64030,"@PostAuthorize(""String_Node_Str"") Blueprint findOne(Long id);","@PostAuthorize(""String_Node_Str"") Blueprint findOne(@Param(""String_Node_Str"") Long id);",0.8243243243243243
64031,Cluster findById(Long id);,"Cluster findById(@Param(""String_Node_Str"") Long id);",0.6666666666666666
64032,"@PostAuthorize(""String_Node_Str"") Cluster findOne(Long id);","@PostAuthorize(""String_Node_Str"") Cluster findOne(@Param(""String_Node_Str"") Long id);",0.8194444444444444
64033,"@PostAuthorize(""String_Node_Str"") Credential findOne(Long id);","@PostAuthorize(""String_Node_Str"") Credential findOne(@Param(""String_Node_Str"") Long id);",0.8266666666666667
64034,Stack findById(Long id);,"Stack findById(@Param(""String_Node_Str"") Long id);",0.6486486486486487
64035,"@PostAuthorize(""String_Node_Str"") Stack findOne(Long id);","@PostAuthorize(""String_Node_Str"") Stack findOne(@Param(""String_Node_Str"") Long id);",0.8142857142857143
64036,"@PostAuthorize(""String_Node_Str"") Template findOne(Long id);","@PostAuthorize(""String_Node_Str"") Template findOne(@Param(""String_Node_Str"") Long id);",0.821917808219178
64037,User findByEmail(String email);,"User findByEmail(@Param(""String_Node_Str"") String email);",0.7045454545454546
64038,"@Override public Set<StackJson> getAll(User user){
  Set<StackJson> result=new HashSet<>();
  for (  Stack stack : user.getStacks()) {
    CloudPlatform cp=stack.getTemplate().cloudPlatform();
    StackDescription description=provisionServices.get(cp).describeStack(user,stack,stack.getCredential());
    result.add(stackConverter.convert(stack,description));
  }
  return result;
}","@Override public Set<StackJson> getAll(User user){
  Set<StackJson> result=new HashSet<>();
  for (  Stack stack : user.getStacks()) {
    CloudPlatform cp=stack.getTemplate().cloudPlatform();
    result.add(stackConverter.convert(stack));
  }
  return result;
}",0.6987577639751553
64039,"@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  AwsTemplate awsInfra=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeStackResourcesResult resourcesResult=null;
  DescribeInstancesResult instancesResult=null;
  Resource resource=stack.getResourceByType(ResourceType.CLOUDFORMATION_STACK);
  if (resource != null) {
    try {
      AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsInfra.getRegion(),awsCredential);
      DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(resource.getResourceName());
      stackResult=client.describeStacks(stackRequest);
      DescribeStackResourcesRequest resourcesRequest=new DescribeStackResourcesRequest().withStackName(resource.getResourceName());
      resourcesResult=client.describeStackResources(resourcesRequest);
    }
 catch (    AmazonServiceException e) {
      if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",resource.getResourceName()))) {
        LOGGER.error(""String_Node_Str"",resource.getResourceName());
        stackResult=new DescribeStacksResult();
      }
 else {
        throw e;
      }
    }
    AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsInfra.getRegion(),awsCredential);
    DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(resource.getResourceName()));
    instancesResult=ec2Client.describeInstances(instancesRequest);
  }
  return new DetailedAwsStackDescription(stackResult,resourcesResult,instancesResult);
}","@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  AwsTemplate awsInfra=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeStackResourcesResult resourcesResult=null;
  DescribeInstancesResult instancesResult=null;
  Resource resource=stack.getResourceByType(ResourceType.CLOUDFORMATION_STACK);
  if (resource != null) {
    try {
      AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsInfra.getRegion(),awsCredential);
      DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(resource.getResourceName());
      stackResult=client.describeStacks(stackRequest);
      DescribeStackResourcesRequest resourcesRequest=new DescribeStackResourcesRequest().withStackName(resource.getResourceName());
      resourcesResult=client.describeStackResources(resourcesRequest);
    }
 catch (    AmazonServiceException e) {
      if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",resource.getResourceName()))) {
        LOGGER.error(""String_Node_Str"",resource.getResourceName());
        stackResult=new DescribeStacksResult();
      }
 else {
        throw e;
      }
    }
    try {
      AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsInfra.getRegion(),awsCredential);
      DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(resource.getResourceName()));
      instancesResult=ec2Client.describeInstances(instancesRequest);
    }
 catch (    Exception ex) {
      instancesResult=new DescribeInstancesResult();
    }
  }
  return new DetailedAwsStackDescription(stackResult,resourcesResult,instancesResult);
}",0.9700960219478738
64040,"@Override public void deleteStack(User user,Stack stack,Credential credential){
  LOGGER.info(""String_Node_Str"",stack.getId());
  AwsTemplate template=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  Resource resource=stack.getResourcebyType(ResourceType.CLOUDFORMATION_STACK);
  if (resource != null) {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(template.getRegion(),awsCredential);
    LOGGER.info(""String_Node_Str"",stack.getId(),resource.getResourceName());
    DeleteStackRequest deleteStackRequest=new DeleteStackRequest().withStackName(resource.getResourceName());
    client.deleteStack(deleteStackRequest);
  }
}","@Override public void deleteStack(User user,Stack stack,Credential credential){
  LOGGER.info(""String_Node_Str"",stack.getId());
  AwsTemplate template=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  Resource resource=stack.getResourceByType(ResourceType.CLOUDFORMATION_STACK);
  if (resource != null) {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(template.getRegion(),awsCredential);
    LOGGER.info(""String_Node_Str"",stack.getId(),resource.getResourceName());
    DeleteStackRequest deleteStackRequest=new DeleteStackRequest().withStackName(resource.getResourceName());
    client.deleteStack(deleteStackRequest);
  }
}",0.9985693848354792
64041,"@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  AwsTemplate awsInfra=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeStackResourcesResult resourcesResult=null;
  Resource resource=stack.getResourcebyType(ResourceType.CLOUDFORMATION_STACK);
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsInfra.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(resource.getResourceName());
    stackResult=client.describeStacks(stackRequest);
    DescribeStackResourcesRequest resourcesRequest=new DescribeStackResourcesRequest().withStackName(resource.getResourceName());
    resourcesResult=client.describeStackResources(resourcesRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",resource.getResourceName()))) {
      LOGGER.error(""String_Node_Str"",resource.getResourceName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsInfra.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(resource.getResourceName()));
  DescribeInstancesResult instancesResult=ec2Client.describeInstances(instancesRequest);
  return new DetailedAwsStackDescription(stackResult,resourcesResult,instancesResult);
}","@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  AwsTemplate awsInfra=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeStackResourcesResult resourcesResult=null;
  DescribeInstancesResult instancesResult=null;
  Resource resource=stack.getResourceByType(ResourceType.CLOUDFORMATION_STACK);
  if (resource != null) {
    try {
      AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsInfra.getRegion(),awsCredential);
      DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(resource.getResourceName());
      stackResult=client.describeStacks(stackRequest);
      DescribeStackResourcesRequest resourcesRequest=new DescribeStackResourcesRequest().withStackName(resource.getResourceName());
      resourcesResult=client.describeStackResources(resourcesRequest);
    }
 catch (    AmazonServiceException e) {
      if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",resource.getResourceName()))) {
        LOGGER.error(""String_Node_Str"",resource.getResourceName());
        stackResult=new DescribeStacksResult();
      }
 else {
        throw e;
      }
    }
    AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsInfra.getRegion(),awsCredential);
    DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(resource.getResourceName()));
    instancesResult=ec2Client.describeInstances(instancesRequest);
  }
  return new DetailedAwsStackDescription(stackResult,resourcesResult,instancesResult);
}",0.8659315147997678
64042,"@Override public StackDescription describeStack(User user,Stack stack,Credential credential){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeInstancesResult instancesResult=null;
  Resource resource=stack.getResourcebyType(ResourceType.CLOUDFORMATION_STACK);
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(resource.getResourceName());
    stackResult=client.describeStacks(stackRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",resource.getResourceName()))) {
      LOGGER.error(""String_Node_Str"",resource.getResourceName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues());
  instancesResult=ec2Client.describeInstances(instancesRequest);
  return new AwsStackDescription(stackResult,instancesResult);
}","@Override public StackDescription describeStack(User user,Stack stack,Credential credential){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeInstancesResult instancesResult=null;
  Resource resource=stack.getResourceByType(ResourceType.CLOUDFORMATION_STACK);
  if (resource != null) {
    try {
      AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
      DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(resource.getResourceName());
      stackResult=client.describeStacks(stackRequest);
    }
 catch (    AmazonServiceException e) {
      if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",resource.getResourceName()))) {
        LOGGER.error(""String_Node_Str"",resource.getResourceName());
        stackResult=new DescribeStacksResult();
      }
 else {
        throw e;
      }
    }
    AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
    DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues());
    instancesResult=ec2Client.describeInstances(instancesRequest);
  }
  return new AwsStackDescription(stackResult,instancesResult);
}",0.9775753328661528
64043,"@Override public void setupMetadata(Stack stack){
  Set<CoreInstanceMetaData> coreInstanceMetadata=new HashSet<>();
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient amazonCfClient=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  AmazonEC2Client amazonEC2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  AmazonAutoScalingClient amazonAutoScalingClient=awsStackUtil.createAutoScalingClient(awsTemplate.getRegion(),awsCredential);
  DescribeStackResourceResult result=amazonCfClient.describeStackResource(new DescribeStackResourceRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_STACK).get(0).getResourceName()).withLogicalResourceId(""String_Node_Str""));
  DescribeAutoScalingGroupsResult describeAutoScalingGroupsResult=amazonAutoScalingClient.describeAutoScalingGroups(new DescribeAutoScalingGroupsRequest().withAutoScalingGroupNames(result.getStackResourceDetail().getPhysicalResourceId()));
  describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances();
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withInstanceIds(instanceIds);
  DescribeInstancesResult instancesResult=amazonEC2Client.describeInstances(instancesRequest);
  for (  Reservation reservation : instancesResult.getReservations()) {
    for (    com.amazonaws.services.ec2.model.Instance instance : reservation.getInstances()) {
      coreInstanceMetadata.add(new CoreInstanceMetaData(instance.getInstanceId(),instance.getPrivateIpAddress(),instance.getPublicIpAddress()));
    }
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,Event.wrap(new MetadataSetupComplete(CloudPlatform.AWS,stack.getId(),coreInstanceMetadata)));
}","@Override public void setupMetadata(Stack stack){
  Set<CoreInstanceMetaData> coreInstanceMetadata=new HashSet<>();
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient amazonCfClient=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  AmazonEC2Client amazonEC2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  AmazonAutoScalingClient amazonAutoScalingClient=awsStackUtil.createAutoScalingClient(awsTemplate.getRegion(),awsCredential);
  DescribeStackResourceResult result=amazonCfClient.describeStackResource(new DescribeStackResourceRequest().withStackName(stack.getResourcesByType(ResourceType.CLOUDFORMATION_STACK).get(0).getResourceName()).withLogicalResourceId(""String_Node_Str""));
  DescribeAutoScalingGroupsResult describeAutoScalingGroupsResult=amazonAutoScalingClient.describeAutoScalingGroups(new DescribeAutoScalingGroupsRequest().withAutoScalingGroupNames(result.getStackResourceDetail().getPhysicalResourceId()));
  describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances();
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withInstanceIds(instanceIds);
  DescribeInstancesResult instancesResult=amazonEC2Client.describeInstances(instancesRequest);
  for (  Reservation reservation : instancesResult.getReservations()) {
    for (    com.amazonaws.services.ec2.model.Instance instance : reservation.getInstances()) {
      coreInstanceMetadata.add(new CoreInstanceMetaData(instance.getInstanceId(),instance.getPrivateIpAddress(),instance.getPublicIpAddress()));
    }
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,Event.wrap(new MetadataSetupComplete(CloudPlatform.AWS,stack.getId(),coreInstanceMetadata)));
}",0.999534233814625
64044,"public void disableSourceDestCheck(Stack stack){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient amazonCfClient=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  AmazonEC2Client amazonEC2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  AmazonAutoScalingClient amazonAutoScalingClient=awsStackUtil.createAutoScalingClient(awsTemplate.getRegion(),awsCredential);
  DescribeStackResourceResult result=amazonCfClient.describeStackResource(new DescribeStackResourceRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_STACK).get(0).getResourceName()).withLogicalResourceId(""String_Node_Str""));
  DescribeAutoScalingGroupsResult describeAutoScalingGroupsResult=amazonAutoScalingClient.describeAutoScalingGroups(new DescribeAutoScalingGroupsRequest().withAutoScalingGroupNames(result.getStackResourceDetail().getPhysicalResourceId()));
  describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances();
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withInstanceIds(instanceIds);
  DescribeInstancesResult instancesResult=amazonEC2Client.describeInstances(instancesRequest);
  List<String> enis=new ArrayList<>();
  for (  Reservation reservation : instancesResult.getReservations()) {
    for (    com.amazonaws.services.ec2.model.Instance instance : reservation.getInstances()) {
      for (      InstanceNetworkInterface instanceNetworkInterface : instance.getNetworkInterfaces()) {
        enis.add(instanceNetworkInterface.getNetworkInterfaceId());
      }
    }
  }
  for (  String eni : enis) {
    ModifyNetworkInterfaceAttributeRequest modifyNetworkInterfaceAttributeRequest=new ModifyNetworkInterfaceAttributeRequest().withNetworkInterfaceId(eni).withSourceDestCheck(false);
    amazonEC2Client.modifyNetworkInterfaceAttribute(modifyNetworkInterfaceAttributeRequest);
  }
  LOGGER.info(""String_Node_Str"",stack.getId(),instanceIds,enis);
}","public void disableSourceDestCheck(Stack stack){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient amazonCfClient=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  AmazonEC2Client amazonEC2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  AmazonAutoScalingClient amazonAutoScalingClient=awsStackUtil.createAutoScalingClient(awsTemplate.getRegion(),awsCredential);
  DescribeStackResourceResult result=amazonCfClient.describeStackResource(new DescribeStackResourceRequest().withStackName(stack.getResourcesByType(ResourceType.CLOUDFORMATION_STACK).get(0).getResourceName()).withLogicalResourceId(""String_Node_Str""));
  DescribeAutoScalingGroupsResult describeAutoScalingGroupsResult=amazonAutoScalingClient.describeAutoScalingGroups(new DescribeAutoScalingGroupsRequest().withAutoScalingGroupNames(result.getStackResourceDetail().getPhysicalResourceId()));
  describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances();
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withInstanceIds(instanceIds);
  DescribeInstancesResult instancesResult=amazonEC2Client.describeInstances(instancesRequest);
  List<String> enis=new ArrayList<>();
  for (  Reservation reservation : instancesResult.getReservations()) {
    for (    com.amazonaws.services.ec2.model.Instance instance : reservation.getInstances()) {
      for (      InstanceNetworkInterface instanceNetworkInterface : instance.getNetworkInterfaces()) {
        enis.add(instanceNetworkInterface.getNetworkInterfaceId());
      }
    }
  }
  for (  String eni : enis) {
    ModifyNetworkInterfaceAttributeRequest modifyNetworkInterfaceAttributeRequest=new ModifyNetworkInterfaceAttributeRequest().withNetworkInterfaceId(eni).withSourceDestCheck(false);
    amazonEC2Client.modifyNetworkInterfaceAttribute(modifyNetworkInterfaceAttributeRequest);
  }
  LOGGER.info(""String_Node_Str"",stack.getId(),instanceIds,enis);
}",0.9995617879053462
64045,"@Override public void deleteStack(User user,Stack stack,Credential credential){
  String filePath=AzureCertificateService.getUserJksFileName(credential,user.emailAsFolder());
  AzureClient azureClient=azureStackUtil.createAzureClient(credential,filePath);
  for (  Resource resource : stack.getResourcesbyType(ResourceType.VIRTUAL_MACHINE)) {
    Map<String,String> props;
    try {
      props=new HashMap<>();
      props.put(SERVICENAME,resource.getResourceName());
      props.put(NAME,resource.getResourceName());
      HttpResponseDecorator deleteVirtualMachineResult=(HttpResponseDecorator)azureClient.deleteVirtualMachine(props);
      String requestId=(String)azureClient.getRequestId(deleteVirtualMachineResult);
      azureClient.waitUntilComplete(requestId);
    }
 catch (    HttpResponseException ex) {
      httpResponseExceptionHandler(ex,resource.getResourceName(),user.getId());
    }
catch (    Exception ex) {
      throw new InternalServerException(ex.getMessage());
    }
  }
  for (  Resource resource : stack.getResourcesbyType(ResourceType.CLOUD_SERVICE)) {
    Map<String,String> props;
    try {
      props=new HashMap<>();
      props.put(SERVICENAME,((AzureCredential)credential).getName().replaceAll(""String_Node_Str"",""String_Node_Str""));
      props.put(NAME,resource.getResourceName());
      HttpResponseDecorator deleteCloudServiceResult=(HttpResponseDecorator)azureClient.deleteCloudService(props);
      String requestId=(String)azureClient.getRequestId(deleteCloudServiceResult);
      azureClient.waitUntilComplete(requestId);
    }
 catch (    HttpResponseException ex) {
      httpResponseExceptionHandler(ex,resource.getResourceName(),user.getId());
    }
catch (    Exception ex) {
      throw new InternalServerException(ex.getMessage());
    }
  }
  for (  Resource resource : stack.getResourcesbyType(ResourceType.NETWORK)) {
    Map<String,String> props;
    try {
      props=new HashMap<>();
      props.put(NAME,resource.getResourceName());
      HttpResponseDecorator deleteVirtualNetworkResult=(HttpResponseDecorator)azureClient.deleteVirtualNetwork(props);
      String requestId=(String)azureClient.getRequestId(deleteVirtualNetworkResult);
      azureClient.waitUntilComplete(requestId);
    }
 catch (    HttpResponseException ex) {
      httpResponseExceptionHandler(ex,resource.getResourceName(),user.getId());
    }
catch (    Exception ex) {
      throw new InternalServerException(ex.getMessage());
    }
  }
}","@Override public void deleteStack(User user,Stack stack,Credential credential){
  String filePath=AzureCertificateService.getUserJksFileName(credential,user.emailAsFolder());
  AzureClient azureClient=azureStackUtil.createAzureClient(credential,filePath);
  for (  Resource resource : stack.getResourcesByType(ResourceType.VIRTUAL_MACHINE)) {
    Map<String,String> props;
    try {
      props=new HashMap<>();
      props.put(SERVICENAME,resource.getResourceName());
      props.put(NAME,resource.getResourceName());
      HttpResponseDecorator deleteVirtualMachineResult=(HttpResponseDecorator)azureClient.deleteVirtualMachine(props);
      String requestId=(String)azureClient.getRequestId(deleteVirtualMachineResult);
      azureClient.waitUntilComplete(requestId);
    }
 catch (    HttpResponseException ex) {
      httpResponseExceptionHandler(ex,resource.getResourceName(),user.getId());
    }
catch (    Exception ex) {
      throw new InternalServerException(ex.getMessage());
    }
  }
  for (  Resource resource : stack.getResourcesByType(ResourceType.CLOUD_SERVICE)) {
    Map<String,String> props;
    try {
      props=new HashMap<>();
      props.put(SERVICENAME,((AzureCredential)credential).getName().replaceAll(""String_Node_Str"",""String_Node_Str""));
      props.put(NAME,resource.getResourceName());
      HttpResponseDecorator deleteCloudServiceResult=(HttpResponseDecorator)azureClient.deleteCloudService(props);
      String requestId=(String)azureClient.getRequestId(deleteCloudServiceResult);
      azureClient.waitUntilComplete(requestId);
    }
 catch (    HttpResponseException ex) {
      httpResponseExceptionHandler(ex,resource.getResourceName(),user.getId());
    }
catch (    Exception ex) {
      throw new InternalServerException(ex.getMessage());
    }
  }
  for (  Resource resource : stack.getResourcesByType(ResourceType.NETWORK)) {
    Map<String,String> props;
    try {
      props=new HashMap<>();
      props.put(NAME,resource.getResourceName());
      HttpResponseDecorator deleteVirtualNetworkResult=(HttpResponseDecorator)azureClient.deleteVirtualNetwork(props);
      String requestId=(String)azureClient.getRequestId(deleteVirtualNetworkResult);
      azureClient.waitUntilComplete(requestId);
    }
 catch (    HttpResponseException ex) {
      httpResponseExceptionHandler(ex,resource.getResourceName(),user.getId());
    }
catch (    Exception ex) {
      throw new InternalServerException(ex.getMessage());
    }
  }
}",0.998785916632942
64046,"@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  String filePath=AzureCertificateService.getUserJksFileName(credential,user.emailAsFolder());
  AzureClient azureClient=azureStackUtil.createAzureClient(credential,filePath);
  DetailedAzureStackDescription detailedAzureStackDescription=new DetailedAzureStackDescription();
  try {
    Object affinityGroup=azureClient.getAffinityGroup(stack.getResourcesbyType(ResourceType.AFFINITY_GROUP).get(0).getResourceName());
    detailedAzureStackDescription.setAffinityGroup(jsonHelper.createJsonFromString(affinityGroup.toString()));
  }
 catch (  Exception ex) {
    detailedAzureStackDescription.setAffinityGroup(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)));
  }
  try {
    Object storageAccount=azureClient.getStorageAccount(stack.getResourcesbyType(ResourceType.STORAGE).get(0).getResourceName());
    detailedAzureStackDescription.setStorageAccount(jsonHelper.createJsonFromString(storageAccount.toString()));
  }
 catch (  Exception ex) {
    detailedAzureStackDescription.setStorageAccount(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)));
  }
  for (  Resource resource : stack.getResourcesbyType(ResourceType.VIRTUAL_MACHINE)) {
    try {
      Object cloudService=azureClient.getCloudService(resource.getResourceName());
      detailedAzureStackDescription.getCloudServices().add(jsonHelper.createJsonFromString(cloudService.toString()).toString());
    }
 catch (    Exception ex) {
      detailedAzureStackDescription.getCloudServices().add(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)).toString());
    }
  }
  for (  Resource resource : stack.getResourcesbyType(ResourceType.CLOUD_SERVICE)) {
    Map<String,String> props=new HashMap<>();
    props.put(SERVICENAME,resource.getResourceName());
    props.put(NAME,resource.getResourceName());
    try {
      Object virtualMachine=azureClient.getVirtualMachine(props);
      detailedAzureStackDescription.getVirtualMachines().add(jsonHelper.createJsonFromString(virtualMachine.toString()).toString());
    }
 catch (    Exception ex) {
      detailedAzureStackDescription.getVirtualMachines().add(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)).toString());
    }
  }
  return detailedAzureStackDescription;
}","@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  String filePath=AzureCertificateService.getUserJksFileName(credential,user.emailAsFolder());
  AzureClient azureClient=azureStackUtil.createAzureClient(credential,filePath);
  DetailedAzureStackDescription detailedAzureStackDescription=new DetailedAzureStackDescription();
  try {
    Object affinityGroup=azureClient.getAffinityGroup(stack.getResourcesByType(ResourceType.AFFINITY_GROUP).get(0).getResourceName());
    detailedAzureStackDescription.setAffinityGroup(jsonHelper.createJsonFromString(affinityGroup.toString()));
  }
 catch (  Exception ex) {
    detailedAzureStackDescription.setAffinityGroup(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)));
  }
  try {
    Object storageAccount=azureClient.getStorageAccount(stack.getResourcesByType(ResourceType.STORAGE).get(0).getResourceName());
    detailedAzureStackDescription.setStorageAccount(jsonHelper.createJsonFromString(storageAccount.toString()));
  }
 catch (  Exception ex) {
    detailedAzureStackDescription.setStorageAccount(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)));
  }
  for (  Resource resource : stack.getResourcesByType(ResourceType.VIRTUAL_MACHINE)) {
    try {
      Object cloudService=azureClient.getCloudService(resource.getResourceName());
      detailedAzureStackDescription.getCloudServices().add(jsonHelper.createJsonFromString(cloudService.toString()).toString());
    }
 catch (    Exception ex) {
      detailedAzureStackDescription.getCloudServices().add(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)).toString());
    }
  }
  for (  Resource resource : stack.getResourcesByType(ResourceType.CLOUD_SERVICE)) {
    Map<String,String> props=new HashMap<>();
    props.put(SERVICENAME,resource.getResourceName());
    props.put(NAME,resource.getResourceName());
    try {
      Object virtualMachine=azureClient.getVirtualMachine(props);
      detailedAzureStackDescription.getVirtualMachines().add(jsonHelper.createJsonFromString(virtualMachine.toString()).toString());
    }
 catch (    Exception ex) {
      detailedAzureStackDescription.getVirtualMachines().add(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)).toString());
    }
  }
  return detailedAzureStackDescription;
}",0.9983172065628944
64047,"@Override public StackDescription describeStack(User user,Stack stack,Credential credential){
  String filePath=AzureCertificateService.getUserJksFileName(credential,user.emailAsFolder());
  AzureClient azureClient=azureStackUtil.createAzureClient(credential,filePath);
  AzureStackDescription azureStackDescription=new AzureStackDescription();
  for (  Resource resource : stack.getResourcesbyType(ResourceType.CLOUD_SERVICE)) {
    try {
      Object cloudService=azureClient.getCloudService(resource.getResourceName());
      azureStackDescription.getCloudServices().add(jsonHelper.createJsonFromString(cloudService.toString()).toString());
    }
 catch (    Exception ex) {
      azureStackDescription.getCloudServices().add(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)).toString());
    }
  }
  for (  Resource resource : stack.getResourcesbyType(ResourceType.VIRTUAL_MACHINE)) {
    Map<String,String> props=new HashMap<>();
    props.put(SERVICENAME,resource.getResourceName());
    props.put(NAME,resource.getResourceName());
    try {
      Object virtualMachine=azureClient.getVirtualMachine(props);
      azureStackDescription.getVirtualMachines().add(jsonHelper.createJsonFromString(virtualMachine.toString()).toString());
    }
 catch (    Exception ex) {
      azureStackDescription.getVirtualMachines().add(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)).toString());
    }
  }
  return azureStackDescription;
}","@Override public StackDescription describeStack(User user,Stack stack,Credential credential){
  String filePath=AzureCertificateService.getUserJksFileName(credential,user.emailAsFolder());
  AzureClient azureClient=azureStackUtil.createAzureClient(credential,filePath);
  AzureStackDescription azureStackDescription=new AzureStackDescription();
  for (  Resource resource : stack.getResourcesByType(ResourceType.CLOUD_SERVICE)) {
    try {
      Object cloudService=azureClient.getCloudService(resource.getResourceName());
      azureStackDescription.getCloudServices().add(jsonHelper.createJsonFromString(cloudService.toString()).toString());
    }
 catch (    Exception ex) {
      azureStackDescription.getCloudServices().add(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)).toString());
    }
  }
  for (  Resource resource : stack.getResourcesByType(ResourceType.VIRTUAL_MACHINE)) {
    Map<String,String> props=new HashMap<>();
    props.put(SERVICENAME,resource.getResourceName());
    props.put(NAME,resource.getResourceName());
    try {
      Object virtualMachine=azureClient.getVirtualMachine(props);
      azureStackDescription.getVirtualMachines().add(jsonHelper.createJsonFromString(virtualMachine.toString()).toString());
    }
 catch (    Exception ex) {
      azureStackDescription.getVirtualMachines().add(jsonHelper.createJsonFromString(String.format(""String_Node_Str"",ERROR)).toString());
    }
  }
  return azureStackDescription;
}",0.9986449864498644
64048,"private synchronized void handleCfStackCreateComplete(Map<String,String> cfMessage){
  Stack stack=stackRepository.findByCfStackId(cfMessage.get(""String_Node_Str""));
  if (stack == null) {
    LOGGER.info(""String_Node_Str"",cfMessage.get(""String_Node_Str""));
  }
 else   if (!stack.isStackCompleted()) {
    awsNetworkConfigurator.disableSourceDestCheck(stack);
    stack=stackUpdater.updateStackCreateComplete(stack.getId());
    LOGGER.info(""String_Node_Str"",stack.getId());
    LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
    Set<Resource> resourceSet=new HashSet<>();
    resourceSet.add(new Resource(ResourceType.CLOUDFORMATION_STACK,cfMessage.get(""String_Node_Str""),stack));
    reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.AWS,stack.getId(),resourceSet)));
  }
}","private synchronized void handleCfStackCreateComplete(Map<String,String> cfMessage){
  Stack stack=stackRepository.findByStackResourceName(cfMessage.get(""String_Node_Str""));
  if (stack == null) {
    LOGGER.info(""String_Node_Str"",cfMessage.get(""String_Node_Str""));
  }
 else   if (!stack.isStackCompleted()) {
    awsNetworkConfigurator.disableSourceDestCheck(stack);
    stack=stackUpdater.updateStackCreateComplete(stack.getId());
    LOGGER.info(""String_Node_Str"",stack.getId());
    LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
    Set<Resource> resourceSet=new HashSet<>();
    resourceSet.add(new Resource(ResourceType.CLOUDFORMATION_STACK,cfMessage.get(""String_Node_Str""),stack));
    reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.AWS,stack.getId(),resourceSet)));
  }
}",0.9850402761795168
64049,"private synchronized void handleCfStackCreateFailed(Map<String,String> cfMessage){
  Stack stack=stackRepository.findByCfStackId(cfMessage.get(""String_Node_Str""));
  if (stack == null) {
    LOGGER.info(""String_Node_Str"",cfMessage.get(""String_Node_Str""));
  }
 else   if (!stack.isStackCompleted() && !Status.CREATE_FAILED.equals(stack.getStatus())) {
    LOGGER.info(""String_Node_Str"",stack.getId());
    StackCreationFailure stackCreationFailure=new StackCreationFailure(stack.getId(),""String_Node_Str"" + cfMessage.get(""String_Node_Str""));
    LOGGER.info(""String_Node_Str"",ReactorConfig.STACK_CREATE_FAILED_EVENT,stack.getId());
    reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(stackCreationFailure));
  }
 else {
    LOGGER.info(""String_Node_Str"",cfMessage.get(""String_Node_Str""));
  }
}","private synchronized void handleCfStackCreateFailed(Map<String,String> cfMessage){
  Stack stack=stackRepository.findByStackResourceName(cfMessage.get(""String_Node_Str""));
  if (stack == null) {
    LOGGER.info(""String_Node_Str"",cfMessage.get(""String_Node_Str""));
  }
 else   if (!stack.isStackCompleted() && !Status.CREATE_FAILED.equals(stack.getStatus())) {
    LOGGER.info(""String_Node_Str"",stack.getId());
    StackCreationFailure stackCreationFailure=new StackCreationFailure(stack.getId(),""String_Node_Str"" + cfMessage.get(""String_Node_Str""));
    LOGGER.info(""String_Node_Str"",ReactorConfig.STACK_CREATE_FAILED_EVENT,stack.getId());
    reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(stackCreationFailure));
  }
 else {
    LOGGER.info(""String_Node_Str"",cfMessage.get(""String_Node_Str""));
  }
}",0.9840686274509804
64050,"public void setupMetadata(CloudPlatform cloudPlatform,Long stackId){
  try {
    Stack stack=stackRepository.findById(stackId);
    MetadataSetup metadataSetup=metadataSetups.get(cloudPlatform);
    metadataSetup.setupMetadata(stack);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    LOGGER.info(""String_Node_Str"",ReactorConfig.STACK_CREATE_FAILED_EVENT,stackId);
    StackCreationFailure stackCreationFailure=new StackCreationFailure(stackId,""String_Node_Str"");
    reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(stackCreationFailure));
  }
}","public void setupMetadata(CloudPlatform cloudPlatform,Long stackId){
  try {
    Stack stack=stackRepository.findOneWithLists(stackId);
    MetadataSetup metadataSetup=metadataSetups.get(cloudPlatform);
    metadataSetup.setupMetadata(stack);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    LOGGER.info(""String_Node_Str"",ReactorConfig.STACK_CREATE_FAILED_EVENT,stackId);
    StackCreationFailure stackCreationFailure=new StackCreationFailure(stackId,""String_Node_Str"");
    reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(stackCreationFailure));
  }
}",0.9864176570458404
64051,"@Test public void testHandleMessageWhenStackNotFoundShouldStackCreationFailed(){
  Map<String,String> cfMessage=createCFMessage();
  cfMessage.put(RESOURCE_STATUS,""String_Node_Str"");
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(cfMessage);
  given(stackRepository.findByCfStackId(anyString())).willReturn(null);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(0)).notify(any(ReactorConfig.class),any(Event.class));
}","@Test public void testHandleMessageWhenStackNotFoundShouldStackCreationFailed(){
  Map<String,String> cfMessage=createCFMessage();
  cfMessage.put(RESOURCE_STATUS,""String_Node_Str"");
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(cfMessage);
  given(stackRepository.findByStackResourceName(anyString())).willReturn(null);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(0)).notify(any(ReactorConfig.class),any(Event.class));
}",0.9828326180257512
64052,"@Test public void testHandleMessageCreationComplete(){
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(createCFMessage());
  given(stackRepository.findByCfStackId(anyString())).willReturn(stack);
  given(stackUpdater.updateStackCreateComplete(anyLong())).willReturn(stack);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(1)).notify(any(ReactorConfig.class),any(Event.class));
}","@Test public void testHandleMessageCreationComplete(){
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(createCFMessage());
  given(stackRepository.findByStackResourceName(anyString())).willReturn(stack);
  given(stackUpdater.updateStackCreateComplete(anyLong())).willReturn(stack);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(1)).notify(any(ReactorConfig.class),any(Event.class));
}",0.44
64053,"@Test public void testHandleMessageWhenStatusIsFailedShouldStackCreateAlreadyFailed(){
  Map<String,String> cfMessage=createCFMessage();
  cfMessage.put(RESOURCE_STATUS,""String_Node_Str"");
  stack.setStatus(Status.CREATE_FAILED);
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(cfMessage);
  given(stackRepository.findByCfStackId(anyString())).willReturn(stack);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(0)).notify(any(ReactorConfig.class),any(Event.class));
}","@Test public void testHandleMessageWhenStatusIsFailedShouldStackCreateAlreadyFailed(){
  Map<String,String> cfMessage=createCFMessage();
  cfMessage.put(RESOURCE_STATUS,""String_Node_Str"");
  stack.setStatus(Status.CREATE_FAILED);
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(cfMessage);
  given(stackRepository.findByStackResourceName(anyString())).willReturn(stack);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(0)).notify(any(ReactorConfig.class),any(Event.class));
}",0.9844357976653696
64054,"@Test public void testHandleMessageCreationCompleteNoStack(){
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(createCFMessage());
  given(stackRepository.findByCfStackId(anyString())).willReturn(null);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(0)).notify(any(ReactorConfig.class),any(Event.class));
}","@Test public void testHandleMessageCreationCompleteNoStack(){
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(createCFMessage());
  given(stackRepository.findByStackResourceName(anyString())).willReturn(null);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(0)).notify(any(ReactorConfig.class),any(Event.class));
}",0.5495750708215298
64055,"@Test public void testHandleMessageWhenStatusNotFailedAndCfNotCompletedShouldStackCreateFailed(){
  Map<String,String> cfMessage=createCFMessage();
  cfMessage.put(RESOURCE_TYPE,""String_Node_Str"");
  cfMessage.put(RESOURCE_STATUS,""String_Node_Str"");
  stack.setStatus(Status.CREATE_IN_PROGRESS);
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(cfMessage);
  given(stackRepository.findByCfStackId(anyString())).willReturn(stack);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(1)).notify(any(ReactorConfig.class),any(Event.class));
}","@Test public void testHandleMessageWhenStatusNotFailedAndCfNotCompletedShouldStackCreateFailed(){
  Map<String,String> cfMessage=createCFMessage();
  cfMessage.put(RESOURCE_TYPE,""String_Node_Str"");
  cfMessage.put(RESOURCE_STATUS,""String_Node_Str"");
  stack.setStatus(Status.CREATE_IN_PROGRESS);
  given(snsMessageParser.parseCFMessage(snsRequest.getMessage())).willReturn(cfMessage);
  given(stackRepository.findByStackResourceName(anyString())).willReturn(stack);
  underTest.handleMessage(snsRequest);
  verify(reactor,times(1)).notify(any(ReactorConfig.class),any(Event.class));
}",0.986206896551724
64056,"@Test public void testSetupMetadataWhenExceptionOccurs(){
  given(metadataSetups.get(CloudPlatform.AZURE)).willReturn(metadataSetup);
  given(stackRepository.findById(1L)).willReturn(stack);
  doThrow(new IllegalStateException()).when(metadataSetup).setupMetadata(stack);
  underTest.setupMetadata(CloudPlatform.AZURE,1L);
  verify(reactor,times(1)).notify(any(ReactorConfig.class),any(Event.class));
}","@Test public void testSetupMetadataWhenExceptionOccurs(){
  given(metadataSetups.get(CloudPlatform.AZURE)).willReturn(metadataSetup);
  given(stackRepository.findOneWithLists(1L)).willReturn(stack);
  doThrow(new IllegalStateException()).when(metadataSetup).setupMetadata(stack);
  underTest.setupMetadata(CloudPlatform.AZURE,1L);
  verify(reactor,times(1)).notify(any(ReactorConfig.class),any(Event.class));
}",0.9802955665024632
64057,"@Before public void setUp(){
  underTest=new MetadataSetupContext();
  MockitoAnnotations.initMocks(this);
  stack=new Stack();
}","@Before public void setUp(){
  underTest=new MetadataSetupContext();
  MockitoAnnotations.initMocks(this);
  stack=new Stack();
  stack.getResources().add(new Resource(ResourceType.CLOUDFORMATION_STACK,""String_Node_Str"",stack));
}",0.7186629526462396
64058,"@Test public void testSetupMetadata(){
  given(metadataSetups.get(CloudPlatform.AZURE)).willReturn(metadataSetup);
  given(stackRepository.findById(1L)).willReturn(stack);
  doNothing().when(metadataSetup).setupMetadata(stack);
  underTest.setupMetadata(CloudPlatform.AZURE,1L);
  verify(metadataSetup,times(1)).setupMetadata(stack);
  verify(reactor,times(0)).notify(any(ReactorConfig.class),any(Event.class));
}","@Test public void testSetupMetadata(){
  given(metadataSetups.get(CloudPlatform.AZURE)).willReturn(metadataSetup);
  given(stackRepository.findOneWithLists(1L)).willReturn(stack);
  doNothing().when(metadataSetup).setupMetadata(stack);
  underTest.setupMetadata(CloudPlatform.AZURE,1L);
  verify(metadataSetup,times(1)).setupMetadata(stack);
  verify(reactor,times(0)).notify(any(ReactorConfig.class),any(Event.class));
}",0.9808153477218226
64059,"@Override public void deleteStack(User user,Stack stack,Credential credential){
  LOGGER.info(""String_Node_Str"",stack.getId());
  AwsTemplate template=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  if (stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName() != null) {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(template.getRegion(),awsCredential);
    LOGGER.info(""String_Node_Str"",stack.getId(),stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName());
    DeleteStackRequest deleteStackRequest=new DeleteStackRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName());
    client.deleteStack(deleteStackRequest);
  }
}","@Override public void deleteStack(User user,Stack stack,Credential credential){
  LOGGER.info(""String_Node_Str"",stack.getId());
  AwsTemplate template=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  Resource resource=stack.getResourcebyType(ResourceType.CLOUDFORMATION_STACK);
  if (resource != null) {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(template.getRegion(),awsCredential);
    LOGGER.info(""String_Node_Str"",stack.getId(),resource.getResourceName());
    DeleteStackRequest deleteStackRequest=new DeleteStackRequest().withStackName(resource.getResourceName());
    client.deleteStack(deleteStackRequest);
  }
}",0.6310299869621904
64060,"@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  AwsTemplate awsInfra=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeStackResourcesResult resourcesResult=null;
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsInfra.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName());
    stackResult=client.describeStacks(stackRequest);
    DescribeStackResourcesRequest resourcesRequest=new DescribeStackResourcesRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName());
    resourcesResult=client.describeStackResources(resourcesRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName()))) {
      LOGGER.error(""String_Node_Str"",stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsInfra.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName()));
  DescribeInstancesResult instancesResult=ec2Client.describeInstances(instancesRequest);
  return new DetailedAwsStackDescription(stackResult,resourcesResult,instancesResult);
}","@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  AwsTemplate awsInfra=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeStackResourcesResult resourcesResult=null;
  Resource resource=stack.getResourcebyType(ResourceType.CLOUDFORMATION_STACK);
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsInfra.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(resource.getResourceName());
    stackResult=client.describeStacks(stackRequest);
    DescribeStackResourcesRequest resourcesRequest=new DescribeStackResourcesRequest().withStackName(resource.getResourceName());
    resourcesResult=client.describeStackResources(resourcesRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",resource.getResourceName()))) {
      LOGGER.error(""String_Node_Str"",resource.getResourceName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsInfra.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(resource.getResourceName()));
  DescribeInstancesResult instancesResult=ec2Client.describeInstances(instancesRequest);
  return new DetailedAwsStackDescription(stackResult,resourcesResult,instancesResult);
}",0.4492512479201331
64061,"@Override public StackDescription describeStack(User user,Stack stack,Credential credential){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeInstancesResult instancesResult=null;
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName());
    stackResult=client.describeStacks(stackRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName()))) {
      LOGGER.error(""String_Node_Str"",stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName()));
  instancesResult=ec2Client.describeInstances(instancesRequest);
  return new AwsStackDescription(stackResult,instancesResult);
}","@Override public StackDescription describeStack(User user,Stack stack,Credential credential){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeInstancesResult instancesResult=null;
  Resource resource=stack.getResourcebyType(ResourceType.CLOUDFORMATION_STACK);
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(resource.getResourceName());
    stackResult=client.describeStacks(stackRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",resource.getResourceName()))) {
      LOGGER.error(""String_Node_Str"",resource.getResourceName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues());
  instancesResult=ec2Client.describeInstances(instancesRequest);
  return new AwsStackDescription(stackResult,instancesResult);
}",0.5536309127248501
64062,"@Override public void setupMetadata(Stack stack){
  Set<CoreInstanceMetaData> coreInstanceMetadata=new HashSet<>();
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient amazonCfClient=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  AmazonEC2Client amazonEC2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  AmazonAutoScalingClient amazonAutoScalingClient=awsStackUtil.createAutoScalingClient(awsTemplate.getRegion(),awsCredential);
  DescribeStackResourceResult result=amazonCfClient.describeStackResource(new DescribeStackResourceRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName()).withLogicalResourceId(""String_Node_Str""));
  DescribeAutoScalingGroupsResult describeAutoScalingGroupsResult=amazonAutoScalingClient.describeAutoScalingGroups(new DescribeAutoScalingGroupsRequest().withAutoScalingGroupNames(result.getStackResourceDetail().getPhysicalResourceId()));
  describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances();
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withInstanceIds(instanceIds);
  DescribeInstancesResult instancesResult=amazonEC2Client.describeInstances(instancesRequest);
  for (  Reservation reservation : instancesResult.getReservations()) {
    for (    com.amazonaws.services.ec2.model.Instance instance : reservation.getInstances()) {
      coreInstanceMetadata.add(new CoreInstanceMetaData(instance.getInstanceId(),instance.getPrivateIpAddress(),instance.getPublicIpAddress()));
    }
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,Event.wrap(new MetadataSetupComplete(CloudPlatform.AWS,stack.getId(),coreInstanceMetadata)));
}","@Override public void setupMetadata(Stack stack){
  Set<CoreInstanceMetaData> coreInstanceMetadata=new HashSet<>();
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient amazonCfClient=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  AmazonEC2Client amazonEC2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  AmazonAutoScalingClient amazonAutoScalingClient=awsStackUtil.createAutoScalingClient(awsTemplate.getRegion(),awsCredential);
  DescribeStackResourceResult result=amazonCfClient.describeStackResource(new DescribeStackResourceRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_STACK).get(0).getResourceName()).withLogicalResourceId(""String_Node_Str""));
  DescribeAutoScalingGroupsResult describeAutoScalingGroupsResult=amazonAutoScalingClient.describeAutoScalingGroups(new DescribeAutoScalingGroupsRequest().withAutoScalingGroupNames(result.getStackResourceDetail().getPhysicalResourceId()));
  describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances();
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withInstanceIds(instanceIds);
  DescribeInstancesResult instancesResult=amazonEC2Client.describeInstances(instancesRequest);
  for (  Reservation reservation : instancesResult.getReservations()) {
    for (    com.amazonaws.services.ec2.model.Instance instance : reservation.getInstances()) {
      coreInstanceMetadata.add(new CoreInstanceMetaData(instance.getInstanceId(),instance.getPrivateIpAddress(),instance.getPublicIpAddress()));
    }
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,Event.wrap(new MetadataSetupComplete(CloudPlatform.AWS,stack.getId(),coreInstanceMetadata)));
}",0.99628079962808
64063,"public void disableSourceDestCheck(Stack stack){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient amazonCfClient=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  AmazonEC2Client amazonEC2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  AmazonAutoScalingClient amazonAutoScalingClient=awsStackUtil.createAutoScalingClient(awsTemplate.getRegion(),awsCredential);
  DescribeStackResourceResult result=amazonCfClient.describeStackResource(new DescribeStackResourceRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_TEMPLATE_NAME).get(0).getResourceName()).withLogicalResourceId(""String_Node_Str""));
  DescribeAutoScalingGroupsResult describeAutoScalingGroupsResult=amazonAutoScalingClient.describeAutoScalingGroups(new DescribeAutoScalingGroupsRequest().withAutoScalingGroupNames(result.getStackResourceDetail().getPhysicalResourceId()));
  describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances();
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withInstanceIds(instanceIds);
  DescribeInstancesResult instancesResult=amazonEC2Client.describeInstances(instancesRequest);
  List<String> enis=new ArrayList<>();
  for (  Reservation reservation : instancesResult.getReservations()) {
    for (    com.amazonaws.services.ec2.model.Instance instance : reservation.getInstances()) {
      for (      InstanceNetworkInterface instanceNetworkInterface : instance.getNetworkInterfaces()) {
        enis.add(instanceNetworkInterface.getNetworkInterfaceId());
      }
    }
  }
  for (  String eni : enis) {
    ModifyNetworkInterfaceAttributeRequest modifyNetworkInterfaceAttributeRequest=new ModifyNetworkInterfaceAttributeRequest().withNetworkInterfaceId(eni).withSourceDestCheck(false);
    amazonEC2Client.modifyNetworkInterfaceAttribute(modifyNetworkInterfaceAttributeRequest);
  }
  LOGGER.info(""String_Node_Str"",stack.getId(),instanceIds,enis);
}","public void disableSourceDestCheck(Stack stack){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient amazonCfClient=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  AmazonEC2Client amazonEC2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  AmazonAutoScalingClient amazonAutoScalingClient=awsStackUtil.createAutoScalingClient(awsTemplate.getRegion(),awsCredential);
  DescribeStackResourceResult result=amazonCfClient.describeStackResource(new DescribeStackResourceRequest().withStackName(stack.getResourcesbyType(ResourceType.CLOUDFORMATION_STACK).get(0).getResourceName()).withLogicalResourceId(""String_Node_Str""));
  DescribeAutoScalingGroupsResult describeAutoScalingGroupsResult=amazonAutoScalingClient.describeAutoScalingGroups(new DescribeAutoScalingGroupsRequest().withAutoScalingGroupNames(result.getStackResourceDetail().getPhysicalResourceId()));
  describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances();
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : describeAutoScalingGroupsResult.getAutoScalingGroups().get(0).getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withInstanceIds(instanceIds);
  DescribeInstancesResult instancesResult=amazonEC2Client.describeInstances(instancesRequest);
  List<String> enis=new ArrayList<>();
  for (  Reservation reservation : instancesResult.getReservations()) {
    for (    com.amazonaws.services.ec2.model.Instance instance : reservation.getInstances()) {
      for (      InstanceNetworkInterface instanceNetworkInterface : instance.getNetworkInterfaces()) {
        enis.add(instanceNetworkInterface.getNetworkInterfaceId());
      }
    }
  }
  for (  String eni : enis) {
    ModifyNetworkInterfaceAttributeRequest modifyNetworkInterfaceAttributeRequest=new ModifyNetworkInterfaceAttributeRequest().withNetworkInterfaceId(eni).withSourceDestCheck(false);
    amazonEC2Client.modifyNetworkInterfaceAttribute(modifyNetworkInterfaceAttributeRequest);
  }
  LOGGER.info(""String_Node_Str"",stack.getId(),instanceIds,enis);
}",0.9965004374453194
64064,"@Override public synchronized void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  String stackName=String.format(""String_Node_Str"",stack.getName(),stack.getId());
  CreateStackRequest createStackRequest=createStackRequest().withStackName(stackName).withTemplateBody(cfTemplate.getBody()).withNotificationARNs((String)setupProperties.get(SnsTopicManager.NOTIFICATION_TOPIC_ARN_KEY)).withParameters(new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(awsTemplate.getSshLocation()),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(userData),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(stackName),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(stack.getNodeCount().toString()),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(awsTemplate.getInstanceType().toString()),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(awsTemplate.getKeyName()),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(awsTemplate.getAmiId()));
  CreateStackResult createStackResult=client.createStack(createStackRequest);
  Set<Resource> resources=new HashSet<>();
  resources.add(new Resource(ResourceType.CLOUDFORMATION_TEMPLATE_NAME,stackName,stack));
  Stack updatedStack=stackUpdater.updateStackResources(stack.getId(),resources);
  LOGGER.info(""String_Node_Str"",stackName,updatedStack.getId());
}","@Override public synchronized void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)stack.getCredential();
  AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
  String stackName=String.format(""String_Node_Str"",stack.getName(),stack.getId());
  CreateStackRequest createStackRequest=createStackRequest().withStackName(stackName).withTemplateBody(cfTemplate.getBody()).withNotificationARNs((String)setupProperties.get(SnsTopicManager.NOTIFICATION_TOPIC_ARN_KEY)).withParameters(new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(awsTemplate.getSshLocation()),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(userData),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(stackName),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(stack.getNodeCount().toString()),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(awsTemplate.getInstanceType().toString()),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(awsTemplate.getKeyName()),new Parameter().withParameterKey(""String_Node_Str"").withParameterValue(awsTemplate.getAmiId()));
  CreateStackResult createStackResult=client.createStack(createStackRequest);
  Set<Resource> resources=new HashSet<>();
  resources.add(new Resource(ResourceType.CLOUDFORMATION_STACK,stackName,stack));
  Stack updatedStack=stackUpdater.updateStackResources(stack.getId(),resources);
  LOGGER.info(""String_Node_Str"",stackName,updatedStack.getId());
}",0.9952968841857732
64065,"private synchronized void handleCfStackCreateComplete(Map<String,String> cfMessage){
  Stack stack=stackRepository.findByCfStackId(cfMessage.get(""String_Node_Str""));
  if (stack == null) {
    LOGGER.info(""String_Node_Str"",cfMessage.get(""String_Node_Str""));
  }
 else   if (!stack.isStackCompleted()) {
    awsNetworkConfigurator.disableSourceDestCheck(stack);
    stack=stackUpdater.updateStackCreateComplete(stack.getId());
    LOGGER.info(""String_Node_Str"",stack.getId());
    LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
    Set<Resource> resourceSet=new HashSet<>();
    resourceSet.add(new Resource(ResourceType.CLOUDFORMATION_TEMPLATE_NAME,cfMessage.get(""String_Node_Str""),stack));
    reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.AWS,stack.getId(),resourceSet)));
  }
}","private synchronized void handleCfStackCreateComplete(Map<String,String> cfMessage){
  Stack stack=stackRepository.findByCfStackId(cfMessage.get(""String_Node_Str""));
  if (stack == null) {
    LOGGER.info(""String_Node_Str"",cfMessage.get(""String_Node_Str""));
  }
 else   if (!stack.isStackCompleted()) {
    awsNetworkConfigurator.disableSourceDestCheck(stack);
    stack=stackUpdater.updateStackCreateComplete(stack.getId());
    LOGGER.info(""String_Node_Str"",stack.getId());
    LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
    Set<Resource> resourceSet=new HashSet<>();
    resourceSet.add(new Resource(ResourceType.CLOUDFORMATION_STACK,cfMessage.get(""String_Node_Str""),stack));
    reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.AWS,stack.getId(),resourceSet)));
  }
}",0.8895281933256617
64066,"public Set<Resource> getDefaultResourceSet(){
  Set<Resource> resources=new HashSet<>();
  resources.add(new Resource(ResourceType.CLOUDFORMATION_TEMPLATE_NAME,ConnectorTestUtil.CF_STACK_NAME,stack));
  return resources;
}","public Set<Resource> getDefaultResourceSet(){
  Set<Resource> resources=new HashSet<>();
  resources.add(new Resource(ResourceType.CLOUDFORMATION_STACK,ConnectorTestUtil.CF_STACK_NAME,stack));
  return resources;
}",0.8348623853211009
64067,"@Before public void setUp(){
  underTest=new AwsNetworkConfigurator();
  MockitoAnnotations.initMocks(this);
  User user=AwsConnectorTestUtil.createUser();
  AwsCredential credential=AwsConnectorTestUtil.createAwsCredential();
  AwsTemplate template=AwsConnectorTestUtil.createAwsTemplate(user);
  Set<Resource> resources=new HashSet<>();
  resources.add(new Resource(ResourceType.CLOUDFORMATION_TEMPLATE_NAME,""String_Node_Str"",stack));
  stack=AwsConnectorTestUtil.createStack(user,credential,template,resources);
  dsrResult=new DescribeStackResourceResult();
  dsrResult.setStackResourceDetail(new StackResourceDetail());
  dasgResult=createAutoScaldingGroups();
  diResult=createDescribeInstanceResult();
  mockClients();
}","@Before public void setUp(){
  underTest=new AwsNetworkConfigurator();
  MockitoAnnotations.initMocks(this);
  User user=AwsConnectorTestUtil.createUser();
  AwsCredential credential=AwsConnectorTestUtil.createAwsCredential();
  AwsTemplate template=AwsConnectorTestUtil.createAwsTemplate(user);
  Set<Resource> resources=new HashSet<>();
  resources.add(new Resource(ResourceType.CLOUDFORMATION_STACK,""String_Node_Str"",stack));
  stack=AwsConnectorTestUtil.createStack(user,credential,template,resources);
  dsrResult=new DescribeStackResourceResult();
  dsrResult.setStackResourceDetail(new StackResourceDetail());
  dasgResult=createAutoScaldingGroups();
  diResult=createDescribeInstanceResult();
  mockClients();
}",0.9875518672199172
64068,"@Before public void setUp(){
  underTest=new AwsProvisioner();
  MockitoAnnotations.initMocks(this);
  user=AwsConnectorTestUtil.createUser();
  credential=AwsConnectorTestUtil.createAwsCredential();
  Set<Resource> resources=new HashSet<>();
  resources.add(new Resource(ResourceType.CLOUDFORMATION_TEMPLATE_NAME,""String_Node_Str"",stack));
  stack=AwsConnectorTestUtil.createStack(user,credential,AwsConnectorTestUtil.createAwsTemplate(user),resources);
}","@Before public void setUp(){
  underTest=new AwsProvisioner();
  MockitoAnnotations.initMocks(this);
  user=AwsConnectorTestUtil.createUser();
  credential=AwsConnectorTestUtil.createAwsCredential();
  Set<Resource> resources=new HashSet<>();
  resources.add(new Resource(ResourceType.CLOUDFORMATION_STACK,""String_Node_Str"",stack));
  stack=AwsConnectorTestUtil.createStack(user,credential,AwsConnectorTestUtil.createAwsTemplate(user),resources);
}",0.9800884955752212
64069,"@Before public void setUp(){
  underTest=new ProvisionCompleteHandler();
  MockitoAnnotations.initMocks(this);
  resourceSet=new HashSet<>();
  resourceSet.add(new Resource(ResourceType.CLOUDFORMATION_TEMPLATE_NAME,""String_Node_Str"",new Stack()));
  event=createEvent();
}","@Before public void setUp(){
  underTest=new ProvisionCompleteHandler();
  MockitoAnnotations.initMocks(this);
  resourceSet=new HashSet<>();
  resourceSet.add(new Resource(ResourceType.CLOUDFORMATION_STACK,""String_Node_Str"",new Stack()));
  event=createEvent();
}",0.9701492537313432
64070,"@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  AwsTemplate awsInfra=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeStackResourcesResult resourcesResult=null;
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsInfra.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(stack.getCfStackName());
    stackResult=client.describeStacks(stackRequest);
    DescribeStackResourcesRequest resourcesRequest=new DescribeStackResourcesRequest().withStackName(stack.getCfStackName());
    resourcesResult=client.describeStackResources(resourcesRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",stack.getCfStackName()))) {
      LOGGER.error(""String_Node_Str"",stack.getCfStackName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsInfra.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(stack.getName()));
  DescribeInstancesResult instancesResult=ec2Client.describeInstances(instancesRequest);
  return new DetailedAwsStackDescription(stackResult,resourcesResult,instancesResult);
}","@Override public StackDescription describeStackWithResources(User user,Stack stack,Credential credential){
  AwsTemplate awsInfra=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeStackResourcesResult resourcesResult=null;
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsInfra.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(stack.getCfStackName());
    stackResult=client.describeStacks(stackRequest);
    DescribeStackResourcesRequest resourcesRequest=new DescribeStackResourcesRequest().withStackName(stack.getCfStackName());
    resourcesResult=client.describeStackResources(resourcesRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",stack.getCfStackName()))) {
      LOGGER.error(""String_Node_Str"",stack.getCfStackName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsInfra.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(stack.getCfStackName()));
  DescribeInstancesResult instancesResult=ec2Client.describeInstances(instancesRequest);
  return new DetailedAwsStackDescription(stackResult,resourcesResult,instancesResult);
}",0.9977770720863768
64071,"@Override public StackDescription describeStack(User user,Stack stack,Credential credential){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeInstancesResult instancesResult=null;
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(stack.getCfStackName());
    stackResult=client.describeStacks(stackRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",stack.getCfStackName()))) {
      LOGGER.error(""String_Node_Str"",stack.getCfStackName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(stack.getName()));
  instancesResult=ec2Client.describeInstances(instancesRequest);
  return new AwsStackDescription(stackResult,instancesResult);
}","@Override public StackDescription describeStack(User user,Stack stack,Credential credential){
  AwsTemplate awsTemplate=(AwsTemplate)stack.getTemplate();
  AwsCredential awsCredential=(AwsCredential)credential;
  DescribeStacksResult stackResult=null;
  DescribeInstancesResult instancesResult=null;
  try {
    AmazonCloudFormationClient client=awsStackUtil.createCloudFormationClient(awsTemplate.getRegion(),awsCredential);
    DescribeStacksRequest stackRequest=new DescribeStacksRequest().withStackName(stack.getCfStackName());
    stackResult=client.describeStacks(stackRequest);
  }
 catch (  AmazonServiceException e) {
    if (CF_SERVICE_NAME.equals(e.getServiceName()) && e.getErrorMessage().equals(String.format(""String_Node_Str"",stack.getCfStackName()))) {
      LOGGER.error(""String_Node_Str"",stack.getCfStackName());
      stackResult=new DescribeStacksResult();
    }
 else {
      throw e;
    }
  }
  AmazonEC2Client ec2Client=awsStackUtil.createEC2Client(awsTemplate.getRegion(),awsCredential);
  DescribeInstancesRequest instancesRequest=new DescribeInstancesRequest().withFilters(new Filter().withName(""String_Node_Str"" + INSTANCE_TAG_NAME).withValues(stack.getCfStackName()));
  instancesResult=ec2Client.describeInstances(instancesRequest);
  return new AwsStackDescription(stackResult,instancesResult);
}",0.9973534971644612
64072,"@Override public void setupProvisioning(Stack stack){
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,stack.getId());
  Credential credential=stack.getCredential();
  String emailAsFolder=stack.getUser().emailAsFolder();
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  if (!azureClient.isImageAvailable(IMAGE_NAME)) {
    String baseImageUri=""String_Node_Str"";
    try {
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,VM_COMMON_NAME);
      params.put(DESCRIPTION,VM_COMMON_NAME);
      params.put(LOCATION,""String_Node_Str"");
      azureClient.createAffinityGroup(params);
    }
 catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"");
    }
    String storageName=String.format(""String_Node_Str"",VM_COMMON_NAME,stack.getId());
    try {
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,storageName);
      params.put(DESCRIPTION,VM_COMMON_NAME);
      params.put(AFFINITYGROUP,VM_COMMON_NAME);
      HttpResponseDecorator response=(HttpResponseDecorator)azureClient.createStorageAccount(params);
      azureClient.waitUntilComplete((String)azureClient.getRequestId(response));
    }
 catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"");
    }
    try {
      String targetBlobContainerUri=""String_Node_Str"" + storageName + ""String_Node_Str"";
      String targetImageUri=targetBlobContainerUri + '/' + storageName+ ""String_Node_Str"";
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,storageName);
      String keyJson=(String)azureClient.getStorageAccountKeys(params);
      JsonNode actualObj=MAPPER.readValue(keyJson,JsonNode.class);
      String storageAccountKey=actualObj.get(""String_Node_Str"").get(""String_Node_Str"").get(""String_Node_Str"").asText();
      AzureClientUtil.createBlobContainer(storageAccountKey,targetBlobContainerUri);
      AzureClientUtil.copyOsImage(storageAccountKey,baseImageUri,targetImageUri);
      AzureClientUtil.imageCopyProgress(storageAccountKey,targetImageUri);
      params=new HashMap<>();
      params.put(AzureStackUtil.NAME,IMAGE_NAME);
      params.put(OS,""String_Node_Str"");
      params.put(MEDIALINK,targetImageUri);
      azureClient.addOsImage(params);
    }
 catch (    IOException e) {
      throw new InternalServerException(""String_Node_Str"");
    }
  }
  reactor.notify(ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,Event.wrap(new ProvisionSetupComplete(getCloudPlatform(),stack.getId()).withSetupProperty(CREDENTIAL,stack.getCredential()).withSetupProperty(EMAILASFOLDER,stack.getUser().emailAsFolder())));
}","@Override public void setupProvisioning(Stack stack){
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,stack.getId());
  Credential credential=stack.getCredential();
  String emailAsFolder=stack.getUser().emailAsFolder();
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  if (!azureClient.isImageAvailable(AzureStackUtil.getOsImageName(credential))) {
    String baseImageUri=""String_Node_Str"";
    String affinityGroupName=((AzureCredential)credential).getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
    try {
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,affinityGroupName);
      params.put(DESCRIPTION,VM_COMMON_NAME);
      params.put(LOCATION,""String_Node_Str"");
      azureClient.createAffinityGroup(params);
    }
 catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"");
    }
    String storageName=String.format(""String_Node_Str"",VM_COMMON_NAME,stack.getId());
    try {
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,affinityGroupName);
      params.put(DESCRIPTION,VM_COMMON_NAME);
      params.put(AFFINITYGROUP,affinityGroupName);
      HttpResponseDecorator response=(HttpResponseDecorator)azureClient.createStorageAccount(params);
      azureClient.waitUntilComplete((String)azureClient.getRequestId(response));
    }
 catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"");
    }
    try {
      String targetBlobContainerUri=""String_Node_Str"" + affinityGroupName + ""String_Node_Str"";
      String targetImageUri=targetBlobContainerUri + '/' + storageName+ ""String_Node_Str"";
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,affinityGroupName);
      String keyJson=(String)azureClient.getStorageAccountKeys(params);
      JsonNode actualObj=MAPPER.readValue(keyJson,JsonNode.class);
      String storageAccountKey=actualObj.get(""String_Node_Str"").get(""String_Node_Str"").get(""String_Node_Str"").asText();
      AzureClientUtil.createBlobContainer(storageAccountKey,targetBlobContainerUri);
      AzureClientUtil.copyOsImage(storageAccountKey,baseImageUri,targetImageUri);
      AzureClientUtil.imageCopyProgress(storageAccountKey,targetImageUri);
      params=new HashMap<>();
      params.put(AzureStackUtil.NAME,AzureStackUtil.getOsImageName(credential));
      params.put(OS,""String_Node_Str"");
      params.put(MEDIALINK,targetImageUri);
      azureClient.addOsImage(params);
    }
 catch (    IOException e) {
      throw new InternalServerException(""String_Node_Str"");
    }
  }
  reactor.notify(ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,Event.wrap(new ProvisionSetupComplete(getCloudPlatform(),stack.getId()).withSetupProperty(CREDENTIAL,stack.getCredential()).withSetupProperty(EMAILASFOLDER,stack.getUser().emailAsFolder())));
}",0.8139377537212449
64073,"private void createVirtualMachine(AzureClient azureClient,AzureTemplate azureTemplate,String name,String vmName,String commonName,String emailAsFolder,String userData) throws FileNotFoundException, CertificateException, NoSuchAlgorithmException {
  byte[] encoded=Base64.encodeBase64(vmName.getBytes());
  String label=new String(encoded);
  Map<String,Object> props=new HashMap<>();
  List<Port> ports=new ArrayList<>();
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  props.put(NAME,vmName);
  props.put(DEPLOYMENTSLOT,PRODUCTION);
  props.put(LABEL,label);
  props.put(IMAGENAME,azureTemplate.getImageName());
  props.put(IMAGESTOREURI,String.format(""String_Node_Str"",commonName,vmName));
  props.put(HOSTNAME,vmName);
  props.put(USERNAME,DEFAULT_USER_NAME);
  if (azureTemplate.getPassword() != null && !azureTemplate.getPassword().isEmpty()) {
    props.put(PASSWORD,azureTemplate.getPassword());
  }
 else {
    X509Certificate sshCert=new X509Certificate(AzureCertificateService.getCerFile(emailAsFolder,azureTemplate.getId()));
    props.put(SSHPUBLICKEYFINGERPRINT,sshCert.getSha1Fingerprint().toUpperCase());
    props.put(SSHPUBLICKEYPATH,String.format(""String_Node_Str"",DEFAULT_USER_NAME));
  }
  props.put(SERVICENAME,vmName);
  props.put(SUBNETNAME,name);
  props.put(CUSTOMDATA,new String(Base64.encodeBase64(userData.getBytes())));
  props.put(VIRTUALNETWORKNAME,name);
  props.put(PORTS,ports);
  props.put(VMTYPE,AzureVmType.valueOf(azureTemplate.getVmType()).vmType().replaceAll(""String_Node_Str"",""String_Node_Str""));
  HttpResponseDecorator virtualMachineResponse=(HttpResponseDecorator)azureClient.createVirtualMachine(props);
  String requestId=(String)azureClient.getRequestId(virtualMachineResponse);
  azureClient.waitUntilComplete(requestId);
}","private void createVirtualMachine(AzureClient azureClient,AzureTemplate azureTemplate,Credential credential,String name,String vmName,String commonName,String userData) throws FileNotFoundException, CertificateException, NoSuchAlgorithmException {
  byte[] encoded=Base64.encodeBase64(vmName.getBytes());
  String label=new String(encoded);
  Map<String,Object> props=new HashMap<>();
  List<Port> ports=new ArrayList<>();
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  props.put(NAME,vmName);
  props.put(DEPLOYMENTSLOT,PRODUCTION);
  props.put(LABEL,label);
  props.put(IMAGENAME,azureTemplate.getImageName().equals(AzureStackUtil.IMAGE_NAME) ? AzureStackUtil.getOsImageName(credential) : azureTemplate.getImageName());
  props.put(IMAGESTOREURI,String.format(""String_Node_Str"",commonName,vmName));
  props.put(HOSTNAME,vmName);
  props.put(USERNAME,DEFAULT_USER_NAME);
  if (azureTemplate.getPassword() != null && !azureTemplate.getPassword().isEmpty()) {
    props.put(PASSWORD,azureTemplate.getPassword());
  }
 else {
    X509Certificate sshCert=new X509Certificate(AzureCertificateService.getCerFile(azureTemplate.getOwner().emailAsFolder(),azureTemplate.getId()));
    props.put(SSHPUBLICKEYFINGERPRINT,sshCert.getSha1Fingerprint().toUpperCase());
    props.put(SSHPUBLICKEYPATH,String.format(""String_Node_Str"",DEFAULT_USER_NAME));
  }
  props.put(SERVICENAME,vmName);
  props.put(SUBNETNAME,name);
  props.put(CUSTOMDATA,new String(Base64.encodeBase64(userData.getBytes())));
  props.put(VIRTUALNETWORKNAME,name);
  props.put(PORTS,ports);
  props.put(VMTYPE,AzureVmType.valueOf(azureTemplate.getVmType()).vmType().replaceAll(""String_Node_Str"",""String_Node_Str""));
  HttpResponseDecorator virtualMachineResponse=(HttpResponseDecorator)azureClient.createVirtualMachine(props);
  String requestId=(String)azureClient.getRequestId(virtualMachineResponse);
  azureClient.waitUntilComplete(requestId);
}",0.9663217309501412
64074,"@Override public void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  AzureTemplate azureTemplate=(AzureTemplate)stack.getTemplate();
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.REQUESTED);
  Credential credential=(Credential)setupProperties.get(CREDENTIAL);
  String emailAsFolder=(String)setupProperties.get(EMAILASFOLDER);
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.CREATE_IN_PROGRESS);
  String name=stack.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  String commonName=((AzureCredential)credential).getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  createAffinityGroup(azureClient,azureTemplate,commonName);
  createStorageAccount(azureClient,azureTemplate,commonName);
  createVirtualNetwork(azureClient,name,commonName);
  for (int i=0; i < stack.getNodeCount(); i++) {
    try {
      String vmName=getVmName(name,i);
      createCloudService(azureClient,azureTemplate,name,vmName,commonName);
      createServiceCertificate(azureClient,azureTemplate,vmName,emailAsFolder);
      createVirtualMachine(azureClient,azureTemplate,name,vmName,commonName,emailAsFolder,userData);
    }
 catch (    FileNotFoundException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    CertificateException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    NoSuchAlgorithmException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"" + ex.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"" + ex.getMessage())));
      return;
    }
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.AZURE,stack.getId())));
}","@Override public void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  AzureTemplate azureTemplate=(AzureTemplate)stack.getTemplate();
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.REQUESTED);
  Credential credential=(Credential)setupProperties.get(CREDENTIAL);
  String emailAsFolder=(String)setupProperties.get(EMAILASFOLDER);
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.CREATE_IN_PROGRESS);
  String name=stack.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  String commonName=((AzureCredential)credential).getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  createAffinityGroup(azureClient,azureTemplate,commonName);
  createStorageAccount(azureClient,azureTemplate,commonName);
  createVirtualNetwork(azureClient,name,commonName);
  for (int i=0; i < stack.getNodeCount(); i++) {
    try {
      String vmName=getVmName(name,i);
      createCloudService(azureClient,azureTemplate,name,vmName,commonName);
      createServiceCertificate(azureClient,azureTemplate,vmName,emailAsFolder);
      createVirtualMachine(azureClient,azureTemplate,credential,name,vmName,commonName,userData);
    }
 catch (    FileNotFoundException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    CertificateException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    NoSuchAlgorithmException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"" + ex.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"" + ex.getMessage())));
      return;
    }
  }
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.PROVISION_COMPLETE_EVENT,Event.wrap(new ProvisionComplete(CloudPlatform.AZURE,stack.getId())));
}",0.9953192286088748
64075,"@Override public void setupProvisioning(Stack stack){
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,stack.getId());
  Credential credential=stack.getCredential();
  String emailAsFolder=stack.getUser().emailAsFolder();
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  if (!azureClient.isImageAvailable(AzureStackUtil.getOsImageName(credential))) {
    String baseImageUri=""String_Node_Str"";
    String affinityGroupName=((AzureCredential)credential).getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
    try {
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,affinityGroupName);
      params.put(DESCRIPTION,VM_COMMON_NAME);
      params.put(LOCATION,""String_Node_Str"");
      azureClient.createAffinityGroup(params);
    }
 catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"");
    }
    String storageName=String.format(""String_Node_Str"",VM_COMMON_NAME,stack.getId());
    try {
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,affinityGroupName);
      params.put(DESCRIPTION,VM_COMMON_NAME);
      params.put(AFFINITYGROUP,affinityGroupName);
      HttpResponseDecorator response=(HttpResponseDecorator)azureClient.createStorageAccount(params);
      azureClient.waitUntilComplete((String)azureClient.getRequestId(response));
    }
 catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"");
    }
    try {
      String targetBlobContainerUri=""String_Node_Str"" + affinityGroupName + ""String_Node_Str"";
      String targetImageUri=targetBlobContainerUri + '/' + storageName+ ""String_Node_Str"";
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,affinityGroupName);
      String keyJson=(String)azureClient.getStorageAccountKeys(params);
      JsonNode actualObj=MAPPER.readValue(keyJson,JsonNode.class);
      String storageAccountKey=actualObj.get(""String_Node_Str"").get(""String_Node_Str"").get(""String_Node_Str"").asText();
      AzureClientUtil.createBlobContainer(storageAccountKey,targetBlobContainerUri);
      AzureClientUtil.copyOsImage(storageAccountKey,baseImageUri,targetImageUri);
      AzureClientUtil.imageCopyProgress(storageAccountKey,targetImageUri);
      params=new HashMap<>();
      params.put(AzureStackUtil.NAME,AzureStackUtil.getOsImageName(credential));
      params.put(OS,""String_Node_Str"");
      params.put(MEDIALINK,targetImageUri);
      azureClient.addOsImage(params);
    }
 catch (    IOException e) {
      throw new InternalServerException(""String_Node_Str"");
    }
  }
  reactor.notify(ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,Event.wrap(new ProvisionSetupComplete(getCloudPlatform(),stack.getId()).withSetupProperty(CREDENTIAL,stack.getCredential()).withSetupProperty(EMAILASFOLDER,stack.getUser().emailAsFolder())));
}","@Override public void setupProvisioning(Stack stack){
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,stack.getId());
  Credential credential=stack.getCredential();
  String emailAsFolder=stack.getUser().emailAsFolder();
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  if (!azureClient.isImageAvailable(AzureStackUtil.getOsImageName(credential))) {
    String affinityGroupName=((AzureCredential)credential).getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
    try {
      azureClient.getAffinityGroup(affinityGroupName);
    }
 catch (    Exception ex) {
      if (((HttpResponseException)ex).getStatusCode() == NOT_FOUND) {
        Map<String,String> params=new HashMap<>();
        params.put(AzureStackUtil.NAME,affinityGroupName);
        params.put(DESCRIPTION,VM_COMMON_NAME);
        params.put(LOCATION,""String_Node_Str"");
        azureClient.createAffinityGroup(params);
      }
 else {
        LOGGER.info(""String_Node_Str"");
        reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new ClusterCreationFailure(stack.getId(),""String_Node_Str"")));
      }
    }
    String storageName=String.format(""String_Node_Str"",VM_COMMON_NAME,stack.getId());
    try {
      azureClient.getStorageAccount(affinityGroupName);
    }
 catch (    Exception ex) {
      if (((HttpResponseException)ex).getStatusCode() == NOT_FOUND) {
        Map<String,String> params=new HashMap<>();
        params.put(AzureStackUtil.NAME,affinityGroupName);
        params.put(DESCRIPTION,VM_COMMON_NAME);
        params.put(AFFINITYGROUP,affinityGroupName);
        HttpResponseDecorator response=(HttpResponseDecorator)azureClient.createStorageAccount(params);
        azureClient.waitUntilComplete((String)azureClient.getRequestId(response));
      }
 else {
        LOGGER.info(""String_Node_Str"");
        reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new ClusterCreationFailure(stack.getId(),""String_Node_Str"")));
      }
    }
    try {
      String targetBlobContainerUri=""String_Node_Str"" + affinityGroupName + ""String_Node_Str"";
      String targetImageUri=targetBlobContainerUri + '/' + storageName+ ""String_Node_Str"";
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,affinityGroupName);
      String keyJson=(String)azureClient.getStorageAccountKeys(params);
      JsonNode actualObj=MAPPER.readValue(keyJson,JsonNode.class);
      String storageAccountKey=actualObj.get(""String_Node_Str"").get(""String_Node_Str"").get(""String_Node_Str"").asText();
      AzureClientUtil.createBlobContainer(storageAccountKey,targetBlobContainerUri);
      AzureClientUtil.copyOsImage(storageAccountKey,baseImageUri,targetImageUri);
      AzureClientUtil.imageCopyProgress(storageAccountKey,targetImageUri);
      params=new HashMap<>();
      params.put(AzureStackUtil.NAME,AzureStackUtil.getOsImageName(credential));
      params.put(OS,""String_Node_Str"");
      params.put(MEDIALINK,targetImageUri);
      azureClient.addOsImage(params);
    }
 catch (    IOException e) {
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new ClusterCreationFailure(stack.getId(),""String_Node_Str"")));
    }
  }
  reactor.notify(ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,Event.wrap(new ProvisionSetupComplete(getCloudPlatform(),stack.getId()).withSetupProperty(CREDENTIAL,stack.getCredential()).withSetupProperty(EMAILASFOLDER,stack.getUser().emailAsFolder())));
}",0.8712020157106862
64076,"@Override public void setupProvisioning(Stack stack){
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,stack.getId());
  Credential credential=stack.getCredential();
  String emailAsFolder=stack.getUser().emailAsFolder();
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  if (!azureClient.isImageAvailable(IMAGE_NAME)) {
    String baseImageUri=""String_Node_Str"";
    Map<String,String> params=new HashMap<>();
    params.put(AzureStackUtil.NAME,VM_COMMON_NAME);
    params.put(DESCRIPTION,VM_COMMON_NAME);
    params.put(LOCATION,""String_Node_Str"");
    azureClient.createAffinityGroup(params);
    params=new HashMap<>();
    params.put(AzureStackUtil.NAME,VM_COMMON_NAME);
    params.put(DESCRIPTION,VM_COMMON_NAME);
    params.put(AFFINITYGROUP,VM_COMMON_NAME);
    HttpResponseDecorator response=(HttpResponseDecorator)azureClient.createStorageAccount(params);
    azureClient.waitUntilComplete((String)azureClient.getRequestId(response));
    try {
      String targetBlobContainerUri=""String_Node_Str"" + VM_COMMON_NAME + ""String_Node_Str"";
      String targetImageUri=targetBlobContainerUri + '/' + VM_COMMON_NAME+ ""String_Node_Str"";
      params=new HashMap<>();
      params.put(AzureStackUtil.NAME,VM_COMMON_NAME);
      String keyJson=(String)azureClient.getStorageAccountKeys(params);
      JsonNode actualObj=MAPPER.readValue(keyJson,JsonNode.class);
      String storageAccountKey=actualObj.get(""String_Node_Str"").get(""String_Node_Str"").get(""String_Node_Str"").asText();
      AzureClientUtil.createBlobContainer(storageAccountKey,targetBlobContainerUri);
      AzureClientUtil.copyOsImage(storageAccountKey,baseImageUri,targetImageUri);
      AzureClientUtil.imageCopyProgress(storageAccountKey,targetImageUri);
      params=new HashMap<>();
      params.put(AzureStackUtil.NAME,IMAGE_NAME);
      params.put(OS,""String_Node_Str"");
      params.put(MEDIALINK,targetImageUri);
      azureClient.addOsImage(params);
    }
 catch (    IOException e) {
      throw new InternalServerException(""String_Node_Str"");
    }
  }
  reactor.notify(ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,Event.wrap(new ProvisionSetupComplete(getCloudPlatform(),stack.getId()).withSetupProperty(CREDENTIAL,stack.getCredential()).withSetupProperty(EMAILASFOLDER,stack.getUser().emailAsFolder())));
}","@Override public void setupProvisioning(Stack stack){
  LOGGER.info(""String_Node_Str"",ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,stack.getId());
  Credential credential=stack.getCredential();
  String emailAsFolder=stack.getUser().emailAsFolder();
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  if (!azureClient.isImageAvailable(IMAGE_NAME)) {
    String baseImageUri=""String_Node_Str"";
    try {
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,VM_COMMON_NAME);
      params.put(DESCRIPTION,VM_COMMON_NAME);
      params.put(LOCATION,""String_Node_Str"");
      azureClient.createAffinityGroup(params);
    }
 catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"");
    }
    String storageName=String.format(""String_Node_Str"",VM_COMMON_NAME,stack.getId());
    try {
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,storageName);
      params.put(DESCRIPTION,VM_COMMON_NAME);
      params.put(AFFINITYGROUP,VM_COMMON_NAME);
      HttpResponseDecorator response=(HttpResponseDecorator)azureClient.createStorageAccount(params);
      azureClient.waitUntilComplete((String)azureClient.getRequestId(response));
    }
 catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"");
    }
    try {
      String targetBlobContainerUri=""String_Node_Str"" + storageName + ""String_Node_Str"";
      String targetImageUri=targetBlobContainerUri + '/' + storageName+ ""String_Node_Str"";
      Map<String,String> params=new HashMap<>();
      params.put(AzureStackUtil.NAME,storageName);
      String keyJson=(String)azureClient.getStorageAccountKeys(params);
      JsonNode actualObj=MAPPER.readValue(keyJson,JsonNode.class);
      String storageAccountKey=actualObj.get(""String_Node_Str"").get(""String_Node_Str"").get(""String_Node_Str"").asText();
      AzureClientUtil.createBlobContainer(storageAccountKey,targetBlobContainerUri);
      AzureClientUtil.copyOsImage(storageAccountKey,baseImageUri,targetImageUri);
      AzureClientUtil.imageCopyProgress(storageAccountKey,targetImageUri);
      params=new HashMap<>();
      params.put(AzureStackUtil.NAME,IMAGE_NAME);
      params.put(OS,""String_Node_Str"");
      params.put(MEDIALINK,targetImageUri);
      azureClient.addOsImage(params);
    }
 catch (    IOException e) {
      throw new InternalServerException(""String_Node_Str"");
    }
  }
  reactor.notify(ReactorConfig.PROVISION_SETUP_COMPLETE_EVENT,Event.wrap(new ProvisionSetupComplete(getCloudPlatform(),stack.getId()).withSetupProperty(CREDENTIAL,stack.getCredential()).withSetupProperty(EMAILASFOLDER,stack.getUser().emailAsFolder())));
}",0.920711374583179
64077,"@Override public void setupMetadata(Stack stack){
  AzureCredential azureCredential=(AzureCredential)stack.getCredential();
  String filePath=AzureCertificateService.getUserJksFileName(azureCredential,stack.getUser().emailAsFolder());
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(azureCredential.getSubscriptionId(),file.getAbsolutePath(),azureCredential.getJks());
  String name=stack.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  Set<CoreInstanceMetaData> instanceMetaDatas=collectMetaData(stack,azureClient,name);
  LOGGER.info(""String_Node_Str"",ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,Event.wrap(new MetadataSetupComplete(CloudPlatform.AWS,stack.getId(),instanceMetaDatas)));
}","@Override public void setupMetadata(Stack stack){
  AzureCredential azureCredential=(AzureCredential)stack.getCredential();
  String filePath=AzureCertificateService.getUserJksFileName(azureCredential,stack.getUser().emailAsFolder());
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(azureCredential.getSubscriptionId(),file.getAbsolutePath(),azureCredential.getJks());
  String name=stack.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  Set<CoreInstanceMetaData> instanceMetaDatas=collectMetaData(stack,azureClient,name);
  LOGGER.info(""String_Node_Str"",ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,stack.getId());
  reactor.notify(ReactorConfig.METADATA_SETUP_COMPLETE_EVENT,Event.wrap(new MetadataSetupComplete(CloudPlatform.AZURE,stack.getId(),instanceMetaDatas)));
}",0.9962825278810408
64078,"@Override public void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  AzureTemplate azureTemplate=(AzureTemplate)stack.getTemplate();
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.REQUESTED);
  Credential credential=(Credential)setupProperties.get(CREDENTIAL);
  String emailAsFolder=(String)setupProperties.get(EMAILASFOLDER);
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.CREATE_IN_PROGRESS);
  String name=stack.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  String commonName=((AzureCredential)credential).getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  createAffinityGroup(azureClient,azureTemplate,commonName);
  createStorageAccount(azureClient,azureTemplate,commonName);
  createVirtualNetwork(azureClient,name,commonName);
  for (int i=0; i < stack.getNodeCount(); i++) {
    try {
      String vmName=getVmName(name,i);
      createCloudService(azureClient,azureTemplate,name,vmName,commonName);
      createServiceCertificate(azureClient,azureTemplate,vmName,emailAsFolder);
      createVirtualMachine(azureClient,azureTemplate,name,vmName,commonName,emailAsFolder,userData);
    }
 catch (    FileNotFoundException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    CertificateException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    NoSuchAlgorithmException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"" + ex.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"" + ex.getMessage())));
      return;
    }
  }
}","@Override public void buildStack(Stack stack,String userData,Map<String,Object> setupProperties){
  AzureTemplate azureTemplate=(AzureTemplate)stack.getTemplate();
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.REQUESTED);
  Credential credential=(Credential)setupProperties.get(CREDENTIAL);
  String emailAsFolder=(String)setupProperties.get(EMAILASFOLDER);
  String filePath=AzureCertificateService.getUserJksFileName(credential,emailAsFolder);
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(((AzureCredential)credential).getSubscriptionId(),file.getAbsolutePath(),((AzureCredential)credential).getJks());
  retryingStackUpdater.updateStackStatus(stack.getId(),Status.CREATE_IN_PROGRESS);
  String name=stack.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  String commonName=((AzureCredential)credential).getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  createAffinityGroup(azureClient,azureTemplate,commonName);
  createStorageAccount(azureClient,azureTemplate,commonName);
  createVirtualNetwork(azureClient,name,commonName);
  for (int i=0; i < stack.getNodeCount(); i++) {
    try {
      String vmName=getVmName(name,i);
      createCloudService(azureClient,azureTemplate,name,vmName,commonName);
      createServiceCertificate(azureClient,azureTemplate,vmName,emailAsFolder);
      createVirtualMachine(azureClient,azureTemplate,name,vmName,commonName,emailAsFolder,userData);
    }
 catch (    FileNotFoundException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    CertificateException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    NoSuchAlgorithmException e) {
      LOGGER.info(""String_Node_Str"" + e.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"")));
      return;
    }
catch (    Exception ex) {
      LOGGER.info(""String_Node_Str"" + ex.getMessage());
      reactor.notify(ReactorConfig.STACK_CREATE_FAILED_EVENT,Event.wrap(new StackCreationFailure(stack.getId(),""String_Node_Str"" + ex.getMessage())));
      return;
    }
  }
  reactor.notify(ReactorConfig.STACK_CREATE_COMPLETE_EVENT,Event.wrap(new StackCreateComplete(CloudPlatform.AZURE,stack.getId())));
}",0.973851030110935
64079,"public String build() throws IOException {
  Validate.notNull(cloudPlatform);
  Validate.notEmpty(parameters);
  String ec2userDataScript=FileReaderUtils.readFileFromClasspath(String.format(""String_Node_Str"",cloudPlatform.getValue()));
  StringBuilder stringBuilder=new StringBuilder(""String_Node_Str"");
  stringBuilder.append(""String_Node_Str"").append(""String_Node_Str"");
  for (  Entry<String,String> parameter : parameters.entrySet()) {
    stringBuilder.append(parameter.getKey()).append(""String_Node_Str"").append(parameter.getValue()).append(""String_Node_Str"");
  }
  stringBuilder.append(""String_Node_Str"").append(ec2userDataScript);
  return stringBuilder.toString();
}","public String build(CloudPlatform cloudPlatform,Map<String,String> parameters){
  String ec2userDataScript=userDataScripts.get(cloudPlatform);
  StringBuilder stringBuilder=new StringBuilder(""String_Node_Str"");
  stringBuilder.append(""String_Node_Str"").append(""String_Node_Str"");
  for (  Entry<String,String> parameter : parameters.entrySet()) {
    stringBuilder.append(parameter.getKey()).append(""String_Node_Str"").append(parameter.getValue()).append(""String_Node_Str"");
  }
  stringBuilder.append(""String_Node_Str"").append(ec2userDataScript);
  return stringBuilder.toString();
}",0.7640984908657665
64080,"private List<String> runInstancesInSubnet(Stack stack,AwsTemplate awsTemplate,DescribeStacksResult stackResult,AmazonEC2Client amazonEC2Client,String instanceArn,String email) throws IOException {
  String subnetId=null;
  String securityGroupId=null;
  List<Output> outputs=stackResult.getStacks().get(0).getOutputs();
  for (  Output output : outputs) {
    if (""String_Node_Str"".equals(output.getOutputKey())) {
      subnetId=output.getOutputValue();
    }
 else     if (""String_Node_Str"".equals(output.getOutputKey())) {
      securityGroupId=output.getOutputValue();
    }
  }
  RunInstancesRequest runInstancesRequest=new RunInstancesRequest(awsTemplate.getAmiId(),stack.getNodeCount(),stack.getNodeCount());
  runInstancesRequest.setKeyName(awsTemplate.getKeyName());
  runInstancesRequest.setInstanceType(awsTemplate.getInstanceType());
  UserDataBuilder dataBuilder=UserDataBuilder.builder().withCloudPlatform(CloudPlatform.AWS).withEnvironmentVariable(""String_Node_Str"",email);
  runInstancesRequest.setUserData(awsStackUtil.encode(dataBuilder.build()));
  IamInstanceProfileSpecification iamInstanceProfileSpecification=new IamInstanceProfileSpecification().withArn(instanceArn);
  runInstancesRequest.setIamInstanceProfile(iamInstanceProfileSpecification);
  InstanceNetworkInterfaceSpecification nwIf=new InstanceNetworkInterfaceSpecification().withDeviceIndex(0).withAssociatePublicIpAddress(true).withSubnetId(subnetId).withGroups(securityGroupId);
  runInstancesRequest.setNetworkInterfaces(Arrays.asList(nwIf));
  RunInstancesResult runInstancesResult=amazonEC2Client.runInstances(runInstancesRequest);
  LOGGER.info(""String_Node_Str"",stack.getId(),subnetId);
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : runInstancesResult.getReservation().getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  LOGGER.info(""String_Node_Str"",stack.getId(),instanceIds);
  return instanceIds;
}","private List<String> runInstancesInSubnet(Stack stack,AwsTemplate awsTemplate,DescribeStacksResult stackResult,AmazonEC2Client amazonEC2Client,String instanceArn,String email) throws IOException {
  String subnetId=null;
  String securityGroupId=null;
  List<Output> outputs=stackResult.getStacks().get(0).getOutputs();
  for (  Output output : outputs) {
    if (""String_Node_Str"".equals(output.getOutputKey())) {
      subnetId=output.getOutputValue();
    }
 else     if (""String_Node_Str"".equals(output.getOutputKey())) {
      securityGroupId=output.getOutputValue();
    }
  }
  RunInstancesRequest runInstancesRequest=new RunInstancesRequest(awsTemplate.getAmiId(),stack.getNodeCount(),stack.getNodeCount());
  runInstancesRequest.setKeyName(awsTemplate.getKeyName());
  runInstancesRequest.setInstanceType(awsTemplate.getInstanceType());
  Map<String,String> map=new HashMap<>();
  map.put(""String_Node_Str"",email);
  runInstancesRequest.setUserData(awsStackUtil.encode(userDataBuilder.build(CloudPlatform.AWS,map)));
  IamInstanceProfileSpecification iamInstanceProfileSpecification=new IamInstanceProfileSpecification().withArn(instanceArn);
  runInstancesRequest.setIamInstanceProfile(iamInstanceProfileSpecification);
  InstanceNetworkInterfaceSpecification nwIf=new InstanceNetworkInterfaceSpecification().withDeviceIndex(0).withAssociatePublicIpAddress(true).withSubnetId(subnetId).withGroups(securityGroupId);
  runInstancesRequest.setNetworkInterfaces(Arrays.asList(nwIf));
  RunInstancesResult runInstancesResult=amazonEC2Client.runInstances(runInstancesRequest);
  LOGGER.info(""String_Node_Str"",stack.getId(),subnetId);
  List<String> instanceIds=new ArrayList<>();
  for (  Instance instance : runInstancesResult.getReservation().getInstances()) {
    instanceIds.add(instance.getInstanceId());
  }
  LOGGER.info(""String_Node_Str"",stack.getId(),instanceIds);
  return instanceIds;
}",0.9203539823008848
64081,"@Test public void testBuildUserDataEc2() throws IOException {
  String expectedScript=FileReaderUtils.readFileFromClasspath(""String_Node_Str"");
  String result=UserDataBuilder.builder().withCloudPlatform(CloudPlatform.AWS).withEnvironmentVariable(""String_Node_Str"",""String_Node_Str"").withEnvironmentVariable(""String_Node_Str"",""String_Node_Str"").build();
  Assert.assertEquals(expectedScript,result);
}","@Test public void testBuildUserDataEc2() throws IOException {
  String expectedScript=FileReaderUtils.readFileFromClasspath(""String_Node_Str"");
  Map<String,String> map=new HashMap<>();
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(expectedScript,userDataBuilder.build(CloudPlatform.AWS,map));
}",0.4921875
64082,"@Test public void testBuildUserDataAzure() throws IOException {
  String expectedScript=FileReaderUtils.readFileFromClasspath(""String_Node_Str"");
  String result=UserDataBuilder.builder().withCloudPlatform(CloudPlatform.AZURE).withEnvironmentVariable(""String_Node_Str"",""String_Node_Str"").withEnvironmentVariable(""String_Node_Str"",""String_Node_Str"").build();
  Assert.assertEquals(expectedScript,result);
}","@Test public void testBuildUserDataAzure() throws IOException {
  String expectedScript=FileReaderUtils.readFileFromClasspath(""String_Node_Str"");
  Map<String,String> map=new HashMap<>();
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(expectedScript,userDataBuilder.build(CloudPlatform.AZURE,map));
}",0.4974226804123711
64083,"private void createVirtualMachine(AzureClient azureClient,AzureTemplate azureTemplate,String name,String vmName,String commonName,User user,String hash) throws FileNotFoundException, CertificateException, NoSuchAlgorithmException {
  byte[] encoded=Base64.encodeBase64(vmName.getBytes());
  String label=new String(encoded);
  Map<String,Object> props=new HashMap<>();
  List<Port> ports=new ArrayList<>();
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  props.put(NAME,vmName);
  props.put(DEPLOYMENTSLOT,PRODUCTION);
  props.put(LABEL,label);
  props.put(IMAGENAME,azureTemplate.getImageName());
  props.put(IMAGESTOREURI,String.format(""String_Node_Str"",commonName,vmName));
  props.put(HOSTNAME,vmName);
  props.put(USERNAME,DEFAULT_USER_NAME);
  if (azureTemplate.getPassword() != null && !azureTemplate.getPassword().isEmpty()) {
    props.put(PASSWORD,azureTemplate.getPassword());
  }
 else {
    X509Certificate sshCert=new X509Certificate(AzureCertificateService.getCerFile(user.emailAsFolder(),azureTemplate.getId()));
    props.put(SSHPUBLICKEYFINGERPRINT,sshCert.getSha1Fingerprint());
    props.put(SSHPUBLICKEYPATH,String.format(""String_Node_Str"",DEFAULT_USER_NAME));
  }
  props.put(SERVICENAME,vmName);
  props.put(SUBNETNAME,name);
  Map<String,String> map=new HashMap<>();
  map.put(""String_Node_Str"",hash);
  props.put(CUSTOMDATA,new String(Base64.encodeBase64(userDataBuilder.build(CloudPlatform.AZURE,map).getBytes())));
  props.put(VIRTUALNETWORKNAME,name);
  props.put(PORTS,ports);
  props.put(VMTYPE,AzureVmType.valueOf(azureTemplate.getVmType()).vmType().replaceAll(""String_Node_Str"",""String_Node_Str""));
  HttpResponseDecorator virtualMachineResponse=(HttpResponseDecorator)azureClient.createVirtualMachine(props);
  String requestId=(String)azureClient.getRequestId(virtualMachineResponse);
  azureClient.waitUntilComplete(requestId);
}","private void createVirtualMachine(AzureClient azureClient,AzureTemplate azureTemplate,String name,String vmName,String commonName,User user,String hash) throws FileNotFoundException, CertificateException, NoSuchAlgorithmException {
  byte[] encoded=Base64.encodeBase64(vmName.getBytes());
  String label=new String(encoded);
  Map<String,Object> props=new HashMap<>();
  List<Port> ports=new ArrayList<>();
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ports.add(new Port(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  props.put(NAME,vmName);
  props.put(DEPLOYMENTSLOT,PRODUCTION);
  props.put(LABEL,label);
  props.put(IMAGENAME,azureTemplate.getImageName());
  props.put(IMAGESTOREURI,String.format(""String_Node_Str"",commonName,vmName));
  props.put(HOSTNAME,vmName);
  props.put(USERNAME,DEFAULT_USER_NAME);
  if (azureTemplate.getPassword() != null && !azureTemplate.getPassword().isEmpty()) {
    props.put(PASSWORD,azureTemplate.getPassword());
  }
 else {
    X509Certificate sshCert=new X509Certificate(AzureCertificateService.getCerFile(user.emailAsFolder(),azureTemplate.getId()));
    props.put(SSHPUBLICKEYFINGERPRINT,sshCert.getSha1Fingerprint().toUpperCase());
    props.put(SSHPUBLICKEYPATH,String.format(""String_Node_Str"",DEFAULT_USER_NAME));
  }
  props.put(SERVICENAME,vmName);
  props.put(SUBNETNAME,name);
  Map<String,String> map=new HashMap<>();
  map.put(""String_Node_Str"",hash);
  props.put(CUSTOMDATA,new String(Base64.encodeBase64(userDataBuilder.build(CloudPlatform.AZURE,map).getBytes())));
  props.put(VIRTUALNETWORKNAME,name);
  props.put(PORTS,ports);
  props.put(VMTYPE,AzureVmType.valueOf(azureTemplate.getVmType()).vmType().replaceAll(""String_Node_Str"",""String_Node_Str""));
  HttpResponseDecorator virtualMachineResponse=(HttpResponseDecorator)azureClient.createVirtualMachine(props);
  String requestId=(String)azureClient.getRequestId(virtualMachineResponse);
  azureClient.waitUntilComplete(requestId);
}",0.9973968017850502
64084,"@RequestMapping(method=RequestMethod.GET,value=""String_Node_Str"") @ResponseBody public ModelAndView getJksFile(@CurrentUser User user,@PathVariable Long credentialId,HttpServletResponse response) throws Exception {
  File cerFile=azureCredentialService.getCertificateFile(credentialId,user);
  response.setContentType(""String_Node_Str"");
  response.setHeader(""String_Node_Str"",""String_Node_Str"" + user.emailAsFolder() + ""String_Node_Str"");
  FileCopyUtils.copy(Files.readAllBytes(cerFile.toPath()),response.getOutputStream());
  return null;
}","@RequestMapping(method=RequestMethod.GET,value=""String_Node_Str"") @ResponseBody public ModelAndView getJksFile(@CurrentUser User user,@PathVariable Long credentialId,HttpServletResponse response) throws Exception {
  File cerFile=azureCertificateService.getCertificateFile(credentialId,user);
  response.setContentType(""String_Node_Str"");
  response.setHeader(""String_Node_Str"",""String_Node_Str"" + user.emailAsFolder() + ""String_Node_Str"");
  FileCopyUtils.copy(Files.readAllBytes(cerFile.toPath()),response.getOutputStream());
  return null;
}",0.9825206991720332
64085,"@RequestMapping(method=RequestMethod.GET,value=""String_Node_Str"") @ResponseBody public ResponseEntity<Set<MetaDataJson>> getStack(@CurrentUser User user,@PathVariable String hash){
  Set<MetaDataJson> metaData=stackService.getMetaData(user,hash);
  return new ResponseEntity<>(metaData,HttpStatus.OK);
}","@RequestMapping(method=RequestMethod.GET,value=""String_Node_Str"") @ResponseBody public ResponseEntity<StackJson> getStack(@CurrentUser User user,@PathVariable Long stackId){
  StackJson stackJson=stackService.get(userRepository.findOne(user.getId()),stackId);
  return new ResponseEntity<>(stackJson,HttpStatus.OK);
}",0.7548387096774194
64086,"@JsonProperty(""String_Node_Str"") public Set<MetaDataJson> getMetadata(){
  return metadata;
}","@JsonProperty(""String_Node_Str"") public Set<InstanceMetaDataJson> getMetadata(){
  return metadata;
}",0.9587628865979382
64087,"@JsonIgnore public void setMetadata(Set<MetaDataJson> metadata){
  this.metadata=metadata;
}","@JsonIgnore public void setMetadata(Set<InstanceMetaDataJson> metadata){
  this.metadata=metadata;
}",0.9583333333333334
64088,"@Override public MetaData convert(MetaDataJson json){
  MetaData metaData=new MetaData();
  metaData.setPrivateIp(json.getPrivateIp());
  metaData.setPublicIp(json.getPublicIp());
  return metaData;
}","@Override public InstanceMetaData convert(InstanceMetaDataJson json){
  InstanceMetaData instanceMetaData=new InstanceMetaData();
  instanceMetaData.setPrivateIp(json.getPrivateIp());
  instanceMetaData.setPublicIp(json.getPublicIp());
  return instanceMetaData;
}",0.6724137931034483
64089,"private Stack doUpdateMetaData(Long stackId,Set<MetaData> metaData){
  Stack stack=stackRepository.findById(stackId);
  stack.setMetaData(metaData);
  stack=stackRepository.save(stack);
  LOGGER.info(""String_Node_Str"",stackId);
  return stack;
}","private Stack doUpdateMetaData(Long stackId,Set<InstanceMetaData> instanceMetaData){
  Stack stack=stackRepository.findById(stackId);
  stack.setInstanceMetaData(instanceMetaData);
  stack=stackRepository.save(stack);
  LOGGER.info(""String_Node_Str"",stackId);
  return stack;
}",0.896551724137931
64090,"public Stack updateStackMetaData(Long stackId,String hash){
  int attempt=1;
  try {
    return doUpdateStackHash(stackId,hash);
  }
 catch (  OptimisticLockException|OptimisticLockingFailureException e) {
    LOGGER.info(""String_Node_Str"",stackId,attempt++,e.getClass().getSimpleName());
    if (attempt <= MAX_RETRIES) {
      return doUpdateStackHash(stackId,hash);
    }
 else {
      throw new InternalServerException(String.format(""String_Node_Str"",stackId),e);
    }
  }
}","public Stack updateStackMetaData(Long stackId,Set<InstanceMetaData> instanceMetaData){
  int attempt=1;
  try {
    return doUpdateMetaData(stackId,instanceMetaData);
  }
 catch (  OptimisticLockException|OptimisticLockingFailureException e) {
    LOGGER.info(""String_Node_Str"",stackId,attempt++,e.getClass().getSimpleName());
    if (attempt <= MAX_RETRIES) {
      return doUpdateMetaData(stackId,instanceMetaData);
    }
 else {
      throw new InternalServerException(String.format(""String_Node_Str"",stackId),e);
    }
  }
}",0.8440913604766633
64091,"private IdJson saveAzureCredential(User user,CredentialJson credentialJson){
  AzureCredential azureCredential=azureCredentialConverter.convert(credentialJson);
  azureCredential.setAzureCredentialOwner(user);
  azureCredentialRepository.save(azureCredential);
  azureCredentialService.generateCertificate(azureCredential,user);
  websocketService.sendToTopicUser(user.getEmail(),WebsocketEndPoint.CREDENTIAL,new StatusMessage(azureCredential.getId(),azureCredential.getName(),Status.CREATE_COMPLETED.name()));
  return new IdJson(azureCredential.getId());
}","private IdJson saveAzureCredential(User user,CredentialJson credentialJson){
  AzureCredential azureCredential=azureCredentialConverter.convert(credentialJson);
  azureCredential.setAzureCredentialOwner(user);
  azureCredentialRepository.save(azureCredential);
  azureCertificateService.generateCertificate(azureCredential,user);
  websocketService.sendToTopicUser(user.getEmail(),WebsocketEndPoint.CREDENTIAL,new StatusMessage(azureCredential.getId(),azureCredential.getName(),Status.CREATE_COMPLETED.name()));
  return new IdJson(azureCredential.getId());
}",0.9829901521933752
64092,"@Override public Set<MetaDataJson> getMetaData(User one,String hash){
  Stack stack=stackRepository.findStackByHash(hash);
  if (stack != null && !stack.getMetaData().isEmpty()) {
    return metaDataConverter.convertAllEntityToJson(stack.getMetaData());
  }
  throw new NotFoundException(""String_Node_Str"");
}","@Override public Set<InstanceMetaDataJson> getMetaData(User one,String hash){
  Stack stack=stackRepository.findStackByHash(hash);
  if (stack != null && !stack.getInstanceMetaData().isEmpty()) {
    return metaDataConverter.convertAllEntityToJson(stack.getInstanceMetaData());
  }
  throw new NotFoundException(""String_Node_Str"");
}",0.9626168224299064
64093,"Set<MetaDataJson> getMetaData(User one,String hash);","Set<InstanceMetaDataJson> getMetaData(User one,String hash);",0.9285714285714286
64094,"@PostConstruct public void readUserDataScript() throws IOException {
  String ec2userDataScript=FileReaderUtils.readFileFromClasspath(""String_Node_Str"");
}","@PostConstruct public void readUserDataScript() throws IOException {
  ec2userDataScript=FileReaderUtils.readFileFromClasspath(""String_Node_Str"");
}",0.976897689768977
64095,"@Override public void afterPropertiesSet() throws Exception {
  if (""String_Node_Str"".equals(hbm2ddlStrategy) || ""String_Node_Str"".equals(hbm2ddlStrategy)) {
    User user2=new User();
    user2.setEmail(""String_Node_Str"");
    user2.setFirstName(""String_Node_Str"");
    user2.setLastName(""String_Node_Str"");
    user2.setPassword(""String_Node_Str"");
    AzureCredential azureCredential=new AzureCredential();
    azureCredential.setSubscriptionId(""String_Node_Str"");
    azureCredential.setJks(""String_Node_Str"");
    azureCredential.setAzureCredentialOwner(user2);
    AwsCredential awsCredential=new AwsCredential();
    awsCredential.setRoleArn(""String_Node_Str"");
    awsCredential.setAwsCredentialOwner(user2);
    user2.getAwsCredentials().add(awsCredential);
    user2.getAzureCredentials().add(azureCredential);
    AwsTemplate awsTemplate=new AwsTemplate();
    awsTemplate.setName(""String_Node_Str"");
    awsTemplate.setKeyName(""String_Node_Str"");
    awsTemplate.setName(""String_Node_Str"");
    awsTemplate.setRegion(Regions.EU_WEST_1);
    awsTemplate.setAmiId(""String_Node_Str"");
    awsTemplate.setInstanceType(InstanceType.M1Small);
    awsTemplate.setSshLocation(""String_Node_Str"");
    awsTemplate.setUser(user2);
    Stack awsStack=new Stack();
    awsStack.setTemplate(awsTemplate);
    awsStack.setNodeCount(NODE_COUNT);
    awsStack.setName(""String_Node_Str"");
    awsStack.setUser(user2);
    awsStack.setCredential(awsCredential);
    user2.getAwsTemplates().add(awsTemplate);
    AzureTemplate azureTemplate=new AzureTemplate();
    azureTemplate.setDeploymentSlot(""String_Node_Str"");
    azureTemplate.setDescription(""String_Node_Str"");
    azureTemplate.setImageName(""String_Node_Str"");
    azureTemplate.setLocation(""String_Node_Str"");
    azureTemplate.setName(""String_Node_Str"");
    azureTemplate.setUserName(""String_Node_Str"");
    azureTemplate.setPassword(""String_Node_Str"");
    azureTemplate.setSubnetAddressPrefix(""String_Node_Str"");
    azureTemplate.setVmType(""String_Node_Str"");
    Port port=new Port();
    port.setLocalPort(""String_Node_Str"");
    port.setName(""String_Node_Str"");
    port.setProtocol(""String_Node_Str"");
    port.setPort(""String_Node_Str"");
    port.setAzureTemplate(azureTemplate);
    azureTemplate.getPorts().add(port);
    azureTemplate.setUser(user2);
    Stack azureStack=new Stack();
    azureStack.setTemplate(azureTemplate);
    azureStack.setNodeCount(NODE_COUNT);
    azureStack.setUser(user2);
    azureStack.setCredential(azureCredential);
    azureStack.setName(""String_Node_Str"");
    Blueprint blueprint1=new Blueprint();
    blueprint1.setName(""String_Node_Str"");
    blueprint1.setBlueprintText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    blueprint1.setUser(user2);
    Blueprint blueprint2=new Blueprint();
    blueprint2.setName(""String_Node_Str"");
    blueprint2.setBlueprintText(""String_Node_Str"");
    blueprint2.setUser(user2);
    user2.getBlueprints().add(blueprint1);
    user2.getBlueprints().add(blueprint2);
    user2.getAzureTemplates().add(azureTemplate);
    user2.getStacks().add(azureStack);
    userRepository.save(user2);
  }
}","@Override public void afterPropertiesSet() throws Exception {
  if (""String_Node_Str"".equals(hbm2ddlStrategy) || ""String_Node_Str"".equals(hbm2ddlStrategy)) {
    User user2=new User();
    user2.setEmail(""String_Node_Str"");
    user2.setFirstName(""String_Node_Str"");
    user2.setLastName(""String_Node_Str"");
    user2.setPassword(""String_Node_Str"");
    AzureCredential azureCredential=new AzureCredential();
    azureCredential.setSubscriptionId(""String_Node_Str"");
    azureCredential.setJks(""String_Node_Str"");
    azureCredential.setAzureCredentialOwner(user2);
    azureCredential.setName(""String_Node_Str"");
    AwsCredential awsCredential=new AwsCredential();
    awsCredential.setRoleArn(""String_Node_Str"");
    awsCredential.setAwsCredentialOwner(user2);
    awsCredential.setName(""String_Node_Str"");
    user2.getAwsCredentials().add(awsCredential);
    user2.getAzureCredentials().add(azureCredential);
    AwsTemplate awsTemplate=new AwsTemplate();
    awsTemplate.setName(""String_Node_Str"");
    awsTemplate.setKeyName(""String_Node_Str"");
    awsTemplate.setName(""String_Node_Str"");
    awsTemplate.setRegion(Regions.EU_WEST_1);
    awsTemplate.setAmiId(""String_Node_Str"");
    awsTemplate.setInstanceType(InstanceType.M1Small);
    awsTemplate.setSshLocation(""String_Node_Str"");
    awsTemplate.setUser(user2);
    Stack awsStack=new Stack();
    awsStack.setTemplate(awsTemplate);
    awsStack.setNodeCount(NODE_COUNT);
    awsStack.setName(""String_Node_Str"");
    awsStack.setUser(user2);
    awsStack.setCredential(awsCredential);
    awsStack.setAmbariIp(""String_Node_Str"");
    awsStack.setStatus(Status.CREATE_COMPLETED);
    user2.getAwsTemplates().add(awsTemplate);
    AzureTemplate azureTemplate=new AzureTemplate();
    azureTemplate.setDeploymentSlot(""String_Node_Str"");
    azureTemplate.setDescription(""String_Node_Str"");
    azureTemplate.setImageName(""String_Node_Str"");
    azureTemplate.setLocation(""String_Node_Str"");
    azureTemplate.setName(""String_Node_Str"");
    azureTemplate.setUserName(""String_Node_Str"");
    azureTemplate.setPassword(""String_Node_Str"");
    azureTemplate.setSubnetAddressPrefix(""String_Node_Str"");
    azureTemplate.setVmType(""String_Node_Str"");
    Port port=new Port();
    port.setLocalPort(""String_Node_Str"");
    port.setName(""String_Node_Str"");
    port.setProtocol(""String_Node_Str"");
    port.setPort(""String_Node_Str"");
    port.setAzureTemplate(azureTemplate);
    azureTemplate.getPorts().add(port);
    azureTemplate.setUser(user2);
    Stack azureStack=new Stack();
    azureStack.setTemplate(azureTemplate);
    azureStack.setNodeCount(NODE_COUNT);
    azureStack.setUser(user2);
    azureStack.setCredential(azureCredential);
    azureStack.setName(""String_Node_Str"");
    awsStack.setAmbariIp(""String_Node_Str"");
    awsStack.setStatus(Status.CREATE_COMPLETED);
    Blueprint blueprint1=new Blueprint();
    blueprint1.setName(""String_Node_Str"");
    blueprint1.setBlueprintText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    blueprint1.setUser(user2);
    Blueprint blueprint2=new Blueprint();
    blueprint2.setName(""String_Node_Str"");
    blueprint2.setBlueprintText(""String_Node_Str"");
    blueprint2.setUser(user2);
    user2.getBlueprints().add(blueprint1);
    user2.getBlueprints().add(blueprint2);
    user2.getAzureTemplates().add(azureTemplate);
    user2.getStacks().add(azureStack);
    user2.getStacks().add(awsStack);
    userRepository.save(user2);
  }
}",0.952550944518816
64096,"@Override public boolean validate(Map<String,String> parameters,ConstraintValidatorContext context,List<TemplateParam> paramsList){
  boolean valid=true;
  for (  TemplateParam param : paramsList) {
    if (param.getRegex().isPresent()) {
      if (parameters.containsKey(param.getName())) {
        if (parameters.get(param.getName()).matches(param.getRegex().get())) {
          addParameterConstraintViolation(context,param.getName(),String.format(""String_Node_Str"",param.getName()));
          valid=false;
        }
      }
 else {
        valid=false;
      }
    }
  }
  return valid;
}","@Override public boolean validate(Map<String,String> parameters,ConstraintValidatorContext context,List<TemplateParam> paramsList){
  boolean valid=true;
  for (  TemplateParam param : paramsList) {
    if (param.getRegex().isPresent()) {
      if (parameters.containsKey(param.getName())) {
        if (!parameters.get(param.getName()).matches(param.getRegex().get())) {
          addParameterConstraintViolation(context,param.getName(),String.format(""String_Node_Str"",param.getName(),param.getRegex().get()));
          valid=false;
        }
      }
    }
  }
  return valid;
}",0.9190110826939472
64097,"@Override public AzureTemplate convert(TemplateJson json){
  AzureTemplate azureTemplate=new AzureTemplate();
  azureTemplate.setName(json.getClusterName());
  azureTemplate.setDeploymentSlot(json.getParameters().get(RequiredAzureTemplateParam.DEPLOYMENTSLOT.getName()));
  azureTemplate.setDescription(json.getParameters().get(RequiredAzureTemplateParam.DESCRIPTION.getName()));
  azureTemplate.setImageName(json.getParameters().get(RequiredAzureTemplateParam.IMAGENAME.getName()));
  azureTemplate.setLocation(json.getParameters().get(RequiredAzureTemplateParam.LOCATION.getName()));
  azureTemplate.setName(json.getClusterName());
  azureTemplate.setPassword(json.getParameters().get(RequiredAzureTemplateParam.PASSWORD.getName()));
  azureTemplate.setSshPublicKeyFingerprint(json.getParameters().get(RequiredAzureTemplateParam.SSH_PUBLIC_KEY_FINGERPRINT.getName()));
  azureTemplate.setSshPublicKeyPath(json.getParameters().get(RequiredAzureTemplateParam.SSH_PUBLIC_KEY_PATH.getName()));
  azureTemplate.setSubnetAddressPrefix(json.getParameters().get(RequiredAzureTemplateParam.ADDRESSPREFIX.getName()));
  azureTemplate.setUserName(json.getParameters().get(RequiredAzureTemplateParam.USERNAME.getName()));
  azureTemplate.setVmType(json.getParameters().get(RequiredAzureTemplateParam.VMTYPE.getName()));
  return azureTemplate;
}","@Override public AzureTemplate convert(TemplateJson json){
  AzureTemplate azureTemplate=new AzureTemplate();
  azureTemplate.setName(json.getClusterName());
  azureTemplate.setDeploymentSlot(json.getParameters().get(RequiredAzureTemplateParam.DEPLOYMENTSLOT.getName()));
  azureTemplate.setDescription(json.getParameters().get(RequiredAzureTemplateParam.DESCRIPTION.getName()));
  azureTemplate.setImageName(json.getParameters().get(RequiredAzureTemplateParam.IMAGENAME.getName()));
  azureTemplate.setLocation(json.getParameters().get(RequiredAzureTemplateParam.LOCATION.getName()));
  azureTemplate.setName(json.getClusterName());
  azureTemplate.setPassword(json.getParameters().get(RequiredAzureTemplateParam.PASSWORD.getName()));
  azureTemplate.setSshPublicKeyFingerprint(json.getParameters().get(RequiredAzureTemplateParam.SSH_PUBLIC_KEY_FINGERPRINT.getName()));
  azureTemplate.setSshPublicKeyPath(json.getParameters().get(RequiredAzureTemplateParam.SSH_PUBLIC_KEY_PATH.getName()));
  azureTemplate.setSubnetAddressPrefix(json.getParameters().get(RequiredAzureTemplateParam.ADDRESSPREFIX.getName()));
  azureTemplate.setUserName(json.getParameters().get(RequiredAzureTemplateParam.USERNAME.getName()));
  azureTemplate.setVmType(json.getParameters().get(RequiredAzureTemplateParam.VMTYPE.getName()));
  azureTemplate.setSubnetAddressPrefix(json.getParameters().get(RequiredAzureTemplateParam.SUBNETADDRESSPREFIX.getName()));
  return azureTemplate;
}",0.9413027916964924
64098,"@Override public StackResult createStack(User user,Stack stack){
  AzureTemplate azureTemplate=(AzureTemplate)stack.getTemplate();
  String filePath=getUserJksFileName(user.emailAsFolder());
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(user.getSubscriptionId(),file.getAbsolutePath(),user.getJks());
  Map<String,String> props=new HashMap<>();
  props.put(NAME,azureTemplate.getName());
  props.put(LOCATION,AzureLocation.valueOf(azureTemplate.getLocation()).location());
  props.put(DESCRIPTION,azureTemplate.getDescription());
  HttpResponseDecorator affinityResponse=(HttpResponseDecorator)azureClient.createAffinityGroup(props);
  String requestId=(String)azureClient.getRequestId(affinityResponse);
  azureClient.waitUntilComplete(requestId);
  props=new HashMap<>();
  props.put(NAME,azureTemplate.getName());
  props.put(DESCRIPTION,azureTemplate.getDescription());
  props.put(AFFINITYGROUP,azureTemplate.getName());
  HttpResponseDecorator storageResponse=(HttpResponseDecorator)azureClient.createStorageAccount(props);
  requestId=(String)azureClient.getRequestId(storageResponse);
  azureClient.waitUntilComplete(requestId);
  props=new HashMap<>();
  props.put(NAME,azureTemplate.getName());
  props.put(AFFINITYGROUP,azureTemplate.getName());
  props.put(SUBNETNAME,azureTemplate.getSubnetAddressPrefix());
  props.put(ADDRESSPREFIX,azureTemplate.getSubnetAddressPrefix());
  props.put(SUBNETADDRESSPREFIX,azureTemplate.getSubnetAddressPrefix());
  HttpResponseDecorator virtualNetworkResponse=(HttpResponseDecorator)azureClient.createVirtualNetwork(props);
  requestId=(String)azureClient.getRequestId(virtualNetworkResponse);
  azureClient.waitUntilComplete(requestId);
  for (int i=0; i < stack.getClusterSize(); i++) {
    String vmName=String.format(""String_Node_Str"",azureTemplate.getName());
    props=new HashMap<>();
    props.put(NAME,vmName);
    props.put(DESCRIPTION,azureTemplate.getDescription());
    props.put(AFFINITYGROUP,azureTemplate.getName());
    HttpResponseDecorator cloudServiceResponse=(HttpResponseDecorator)azureClient.createCloudService(props);
    requestId=(String)azureClient.getRequestId(cloudServiceResponse);
    azureClient.waitUntilComplete(requestId);
    byte[] encoded=Base64.encodeBase64(vmName.getBytes());
    String label=new String(encoded);
    props=new HashMap<>();
    props.put(NAME,vmName);
    props.put(DEPLOYMENTSLOT,azureTemplate.getDeploymentSlot());
    props.put(LABEL,label);
    props.put(IMAGENAME,azureTemplate.getImageName());
    props.put(IMAGESTOREURI,String.format(""String_Node_Str"",azureTemplate.getName(),vmName));
    props.put(HOSTNAME,vmName);
    props.put(USERNAME,azureTemplate.getUserName());
    if (azureTemplate.getPassword() != null) {
      props.put(PASSWORD,azureTemplate.getPassword());
    }
 else {
      props.put(SSHPUBLICKEYFINGERPRINT,azureTemplate.getSshPublicKeyFingerprint());
      props.put(SSHPUBLICKEYPATH,azureTemplate.getSshPublicKeyPath());
    }
    props.put(SUBNETNAME,azureTemplate.getName());
    props.put(VIRTUALNETWORKNAME,azureTemplate.getName());
    props.put(VMTYPE,AzureVmType.valueOf(azureTemplate.getVmType()).vmType());
    HttpResponseDecorator virtualMachineResponse=(HttpResponseDecorator)azureClient.createVirtualMachine(props);
    requestId=(String)azureClient.getRequestId(virtualMachineResponse);
    azureClient.waitUntilComplete(requestId);
  }
  return new AzureStackResult(OK_STATUS);
}","@Override @Async public StackResult createStack(User user,Stack stack){
  AzureTemplate azureTemplate=(AzureTemplate)stack.getTemplate();
  String filePath=getUserJksFileName(user.emailAsFolder());
  File file=new File(filePath);
  AzureClient azureClient=new AzureClient(user.getSubscriptionId(),file.getAbsolutePath(),user.getJks());
  Map<String,String> props=new HashMap<>();
  props.put(NAME,azureTemplate.getName());
  props.put(LOCATION,AzureLocation.valueOf(azureTemplate.getLocation()).location());
  props.put(DESCRIPTION,azureTemplate.getDescription());
  HttpResponseDecorator affinityResponse=(HttpResponseDecorator)azureClient.createAffinityGroup(props);
  String requestId=(String)azureClient.getRequestId(affinityResponse);
  azureClient.waitUntilComplete(requestId);
  props=new HashMap<>();
  props.put(NAME,azureTemplate.getName());
  props.put(DESCRIPTION,azureTemplate.getDescription());
  props.put(AFFINITYGROUP,azureTemplate.getName());
  HttpResponseDecorator storageResponse=(HttpResponseDecorator)azureClient.createStorageAccount(props);
  requestId=(String)azureClient.getRequestId(storageResponse);
  azureClient.waitUntilComplete(requestId);
  props=new HashMap<>();
  props.put(NAME,azureTemplate.getName());
  props.put(AFFINITYGROUP,azureTemplate.getName());
  props.put(SUBNETNAME,azureTemplate.getSubnetAddressPrefix());
  props.put(ADDRESSPREFIX,azureTemplate.getAddressPrefix());
  props.put(SUBNETADDRESSPREFIX,azureTemplate.getSubnetAddressPrefix());
  HttpResponseDecorator virtualNetworkResponse=(HttpResponseDecorator)azureClient.createVirtualNetwork(props);
  requestId=(String)azureClient.getRequestId(virtualNetworkResponse);
  azureClient.waitUntilComplete(requestId);
  for (int i=0; i < stack.getClusterSize(); i++) {
    String vmName=String.format(""String_Node_Str"",azureTemplate.getName());
    props=new HashMap<>();
    props.put(NAME,vmName);
    props.put(DESCRIPTION,azureTemplate.getDescription());
    props.put(AFFINITYGROUP,azureTemplate.getName());
    HttpResponseDecorator cloudServiceResponse=(HttpResponseDecorator)azureClient.createCloudService(props);
    requestId=(String)azureClient.getRequestId(cloudServiceResponse);
    azureClient.waitUntilComplete(requestId);
    byte[] encoded=Base64.encodeBase64(vmName.getBytes());
    String label=new String(encoded);
    props=new HashMap<>();
    props.put(NAME,vmName);
    props.put(DEPLOYMENTSLOT,azureTemplate.getDeploymentSlot());
    props.put(LABEL,label);
    props.put(IMAGENAME,azureTemplate.getImageName());
    props.put(IMAGESTOREURI,String.format(""String_Node_Str"",azureTemplate.getName(),vmName));
    props.put(HOSTNAME,vmName);
    props.put(USERNAME,azureTemplate.getUserName());
    if (azureTemplate.getPassword() != null) {
      props.put(PASSWORD,azureTemplate.getPassword());
    }
 else {
      props.put(SSHPUBLICKEYFINGERPRINT,azureTemplate.getSshPublicKeyFingerprint());
      props.put(SSHPUBLICKEYPATH,azureTemplate.getSshPublicKeyPath());
    }
    props.put(SUBNETNAME,azureTemplate.getName());
    props.put(VIRTUALNETWORKNAME,azureTemplate.getName());
    props.put(VMTYPE,AzureVmType.valueOf(azureTemplate.getVmType()).vmType());
    HttpResponseDecorator virtualMachineResponse=(HttpResponseDecorator)azureClient.createVirtualMachine(props);
    requestId=(String)azureClient.getRequestId(virtualMachineResponse);
    azureClient.waitUntilComplete(requestId);
  }
  return new AzureStackResult(OK_STATUS);
}",0.99812057250253
64099,"@Override public boolean validate(Map<String,String> parameters,ConstraintValidatorContext context,List<TemplateParam> paramList){
  boolean valid=true;
  for (  TemplateParam param : paramList) {
    if (parameters.containsKey(param.getName())) {
      valid=validateClass(parameters,context,param);
    }
  }
  return valid;
}","@Override public boolean validate(Map<String,String> parameters,ConstraintValidatorContext context,List<TemplateParam> paramList){
  boolean valid=true;
  for (  TemplateParam param : paramList) {
    if (parameters.containsKey(param.getName())) {
      if (!validateClass(parameters,context,param)) {
        valid=false;
      }
    }
  }
  return valid;
}",0.8425655976676385
64100,"@Override public boolean validate(Map<String,String> parameters,ConstraintValidatorContext context,List<TemplateParam> paramList){
  boolean valid=true;
  for (  TemplateParam param : paramList) {
    if (!parameters.containsKey(param.getName())) {
      addParameterConstraintViolation(context,param.getName(),String.format(""String_Node_Str"",param.getName()));
      valid=false;
    }
 else {
      valid=validateClass(parameters,context,param);
    }
  }
  return valid;
}","@Override public boolean validate(Map<String,String> parameters,ConstraintValidatorContext context,List<TemplateParam> paramList){
  boolean valid=true;
  for (  TemplateParam param : paramList) {
    if (!parameters.containsKey(param.getName())) {
      addParameterConstraintViolation(context,param.getName(),String.format(""String_Node_Str"",param.getName()));
      valid=false;
    }
 else {
      if (!validateClass(parameters,context,param)) {
        valid=false;
      }
    }
  }
  return valid;
}",0.889795918367347
64101,"@Override public void afterPropertiesSet() throws Exception {
  User user2=new User();
  user2.setEmail(""String_Node_Str"");
  user2.setFirstName(""String_Node_Str"");
  user2.setLastName(""String_Node_Str"");
  user2.setPassword(""String_Node_Str"");
  user2.setSubscriptionId(""String_Node_Str"");
  user2.setJks(""String_Node_Str"");
  AwsInfra awsInfra=new AwsInfra();
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setKeyName(""String_Node_Str"");
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setRegion(""String_Node_Str"");
  awsInfra.setUser(user2);
  user2.getAwsInfraList().add(awsInfra);
  userRepository.save(user2);
}","@Override public void afterPropertiesSet() throws Exception {
  User user2=new User();
  user2.setEmail(""String_Node_Str"");
  user2.setFirstName(""String_Node_Str"");
  user2.setLastName(""String_Node_Str"");
  user2.setPassword(""String_Node_Str"");
  user2.setSubscriptionId(""String_Node_Str"");
  user2.setJks(""String_Node_Str"");
  user2.setRoleArn(""String_Node_Str"");
  AwsInfra awsInfra=new AwsInfra();
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setKeyName(""String_Node_Str"");
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setRegion(""String_Node_Str"");
  awsInfra.setUser(user2);
  CloudInstance awsCloudInstance=new CloudInstance();
  awsCloudInstance.setInfra(awsInfra);
  awsCloudInstance.setClusterSize(CLUSTER_SIZE);
  awsCloudInstance.setUser(user2);
  user2.getAwsInfraList().add(awsInfra);
  user2.getCloudInstances().add(awsCloudInstance);
  AzureInfra azureInfra=new AzureInfra();
  azureInfra.setDeploymentSlot(""String_Node_Str"");
  azureInfra.setDescription(""String_Node_Str"");
  azureInfra.setDisableSshPasswordAuthentication(false);
  azureInfra.setImageName(""String_Node_Str"");
  azureInfra.setLocation(""String_Node_Str"");
  azureInfra.setName(""String_Node_Str"");
  azureInfra.setPassword(""String_Node_Str"");
  azureInfra.setSubnetAddressPrefix(""String_Node_Str"");
  azureInfra.setVmType(""String_Node_Str"");
  azureInfra.setUser(user2);
  CloudInstance azureCloudInstance=new CloudInstance();
  azureCloudInstance.setInfra(azureInfra);
  azureCloudInstance.setClusterSize(CLUSTER_SIZE);
  azureCloudInstance.setUser(user2);
  user2.getAzureInfraList().add(azureInfra);
  user2.getCloudInstances().add(azureCloudInstance);
  userRepository.save(user2);
}",0.5411048281861679
64102,"public Long getId(){
  return id;
}","@JsonProperty(""String_Node_Str"") public Long getId(){
  return id;
}",0.6796116504854369
64103,"@Override public void afterPropertiesSet() throws Exception {
  User user1=new User();
  user1.setEmail(""String_Node_Str"");
  user1.setFirstName(""String_Node_Str"");
  user1.setLastName(""String_Node_Str"");
  user1.setPassword(""String_Node_Str"");
  User user2=new User();
  user2.setEmail(""String_Node_Str"");
  user2.setFirstName(""String_Node_Str"");
  user2.setLastName(""String_Node_Str"");
  user2.setPassword(""String_Node_Str"");
  user2.setSubscriptionId(""String_Node_Str"");
  user2.setJks(""String_Node_Str"");
  AwsInfra awsInfra=new AwsInfra();
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setKeyName(""String_Node_Str"");
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setRegion(""String_Node_Str"");
  awsInfra.setUser(user2);
  user2.getAwsInfraList().add(awsInfra);
  userRepository.save(user1);
  userRepository.save(user2);
}","@Override public void afterPropertiesSet() throws Exception {
  User user2=new User();
  user2.setEmail(""String_Node_Str"");
  user2.setFirstName(""String_Node_Str"");
  user2.setLastName(""String_Node_Str"");
  user2.setPassword(""String_Node_Str"");
  user2.setSubscriptionId(""String_Node_Str"");
  user2.setJks(""String_Node_Str"");
  AwsInfra awsInfra=new AwsInfra();
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setKeyName(""String_Node_Str"");
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setRegion(""String_Node_Str"");
  awsInfra.setUser(user2);
  user2.getAwsInfraList().add(awsInfra);
  userRepository.save(user2);
}",0.851063829787234
64104,"@JsonIgnore public void setCloudPlatform(CloudPlatform cloudPlatform){
  this.cloudPlatform=cloudPlatform;
}","public void setCloudPlatform(CloudPlatform cloudPlatform){
  this.cloudPlatform=cloudPlatform;
}",0.9411764705882352
64105,"@JsonProperty(""String_Node_Str"") public CloudPlatform getCloudPlatform(){
  return cloudPlatform;
}","public CloudPlatform getCloudPlatform(){
  return cloudPlatform;
}",0.8
64106,"@JsonIgnore public void setCloudPlatform(CloudPlatform type){
  this.cloudPlatform=type;
}","public void setCloudPlatform(CloudPlatform type){
  this.cloudPlatform=type;
}",0.9285714285714286
64107,"@JsonProperty(""String_Node_Str"") public CloudPlatform getCloudPlatform(){
  return cloudPlatform;
}","public CloudPlatform getCloudPlatform(){
  return cloudPlatform;
}",0.8
64108,"@Override public void afterPropertiesSet() throws Exception {
  User user1=new User();
  user1.setEmail(""String_Node_Str"");
  user1.setFirstName(""String_Node_Str"");
  user1.setLastName(""String_Node_Str"");
  user1.setPassword(""String_Node_Str"");
  User user2=new User();
  user2.setEmail(""String_Node_Str"");
  user2.setFirstName(""String_Node_Str"");
  user2.setLastName(""String_Node_Str"");
  user2.setPassword(""String_Node_Str"");
  user2.setSubscriptionId(""String_Node_Str"");
  user2.setJks(""String_Node_Str"");
  AzureInfra azureInfra=new AzureInfra();
  azureInfra.setName(""String_Node_Str"");
  user2.getAzureInfraList().add(azureInfra);
  userRepository.save(user1);
  userRepository.save(user2);
}","@Override public void afterPropertiesSet() throws Exception {
  User user1=new User();
  user1.setEmail(""String_Node_Str"");
  user1.setFirstName(""String_Node_Str"");
  user1.setLastName(""String_Node_Str"");
  user1.setPassword(""String_Node_Str"");
  User user2=new User();
  user2.setEmail(""String_Node_Str"");
  user2.setFirstName(""String_Node_Str"");
  user2.setLastName(""String_Node_Str"");
  user2.setPassword(""String_Node_Str"");
  user2.setSubscriptionId(""String_Node_Str"");
  user2.setJks(""String_Node_Str"");
  AwsInfra awsInfra=new AwsInfra();
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setKeyName(""String_Node_Str"");
  awsInfra.setName(""String_Node_Str"");
  awsInfra.setRegion(""String_Node_Str"");
  user2.getAwsInfraList().add(awsInfra);
  userRepository.save(user1);
  userRepository.save(user2);
}",0.8698539176626826
64109,"@Override public AwsCloudInstance convert(CloudInstanceRequest json){
  AwsCloudInstance awsCloudInstance=new AwsCloudInstance();
  awsCloudInstance.setClusterSize(json.getClusterSize());
  awsCloudInstance.setAwsInfra(awsInfraRepository.findOne(Long.valueOf(json.getInfraId())));
  return new AwsCloudInstance();
}","@Override public AwsCloudInstance convert(CloudInstanceRequest json){
  AwsCloudInstance awsCloudInstance=new AwsCloudInstance();
  awsCloudInstance.setClusterSize(json.getClusterSize());
  awsCloudInstance.setAwsInfra(awsInfraRepository.findOne(Long.valueOf(json.getInfraId())));
  return awsCloudInstance;
}",0.939102564102564
64110,"public CloudInstanceRequest get(Long id){
  AwsCloudInstance awsInstance=awsCloudInstanceRepository.findOne(id);
  if (awsInstance == null) {
    AzureCloudInstance azureInstance=azureCloudInstanceRepository.findOne(id);
    if (azureInstance == null) {
      return azureCloudInstanceConverter.convert(azureInstance);
    }
 else {
      return null;
    }
  }
 else {
    return awsCloudInstanceConverter.convert(awsInstance);
  }
}","public CloudInstanceRequest get(Long id){
  AwsCloudInstance awsInstance=awsCloudInstanceRepository.findOne(id);
  if (awsInstance == null) {
    AzureCloudInstance azureInstance=azureCloudInstanceRepository.findOne(id);
    if (azureInstance == null) {
      return null;
    }
 else {
      return azureCloudInstanceConverter.convert(azureInstance);
    }
  }
 else {
    return awsCloudInstanceConverter.convert(awsInstance);
  }
}",0.7926267281105991
64111,"public InfraRequest get(Long id){
  AwsInfra awsInfra=awsInfraRepository.findOne(id);
  if (awsInfra == null) {
    AzureInfra azureInfra=azureInfraRepository.findOne(id);
    if (azureInfra == null) {
      return azureInfraConverter.convert(azureInfra);
    }
 else {
      return null;
    }
  }
 else {
    return awsInfraConverter.convert(awsInfra);
  }
}","public InfraRequest get(Long id){
  AwsInfra awsInfra=awsInfraRepository.findOne(id);
  if (awsInfra == null) {
    AzureInfra azureInfra=azureInfraRepository.findOne(id);
    if (azureInfra == null) {
      return null;
    }
 else {
      return azureInfraConverter.convert(azureInfra);
    }
  }
 else {
    return awsInfraConverter.convert(awsInfra);
  }
}",0.9083333333333332
64112,"@RequestMapping(method=RequestMethod.GET,value=""String_Node_Str"") @ResponseBody public ResponseEntity<UserJson> generate(@CurrentUser User user) throws Exception {
  UserJson json=userConverter.convert(user);
  return new ResponseEntity<>(json,HttpStatus.OK);
}","@RequestMapping(method=RequestMethod.GET,value=""String_Node_Str"") @ResponseBody public ResponseEntity<UserJson> generate(@CurrentUser User user) throws Exception {
  User oneWithLists=userRepository.findOneWithLists(user.getId());
  UserJson json=userConverter.convert(user);
  return new ResponseEntity<>(json,HttpStatus.OK);
}",0.8862478777589134
64113,"@Override public boolean isValid(ProvisionRequest request,ConstraintValidatorContext context){
  boolean valid=true;
switch (request.getCloudPlatform()) {
case AWS:
    for (    String param : requiredAWSParams) {
      if (!request.getParameters().containsKey(param)) {
        addParameterConstraintViolation(context,param,String.format(""String_Node_Str"",param));
        valid=false;
      }
    }
  break;
case AZURE:
break;
}
return valid;
}","@Override public boolean isValid(ProvisionRequest request,ConstraintValidatorContext context){
  boolean valid=true;
switch (request.getCloudPlatform()) {
case AWS:
    for (    String param : requiredAWSParams) {
      if (!request.getParameters().containsKey(param)) {
        addParameterConstraintViolation(context,param,String.format(""String_Node_Str"",param));
        valid=false;
      }
    }
  break;
case AZURE:
break;
default :
break;
}
return valid;
}",0.9812981298129811
64114,"public SampleJson(String name,String status){
  super();
  this.name=name;
  this.status=status;
}","public SampleJson(String name,String status){
  this.name=name;
  this.status=status;
}",0.9405405405405406
64115,"/** 
 * Returns the name of the test
 * @return
 */
String getName();","/** 
 * @return Returns the name of the test
 */
String getName();",0.8592592592592593
64116,"/** 
 * {@inheritDoc}. 
 */
public PlanarImage executeDrawOperation(){
  BufferedImage bi=new BufferedImage(width + (stroke_width * 2),height + (stroke_width * 2),BufferedImage.TYPE_4BYTE_ABGR_PRE);
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  if (!stroke.equals(""String_Node_Str"")) {
    BasicStroke bStroke=new BasicStroke(stroke_width);
    graphics.setColor(ColorMapper.getColorByName(stroke));
    graphics.setStroke(bStroke);
    graphics.draw(new Arc2D.Double(stroke_width,stroke_width,width,height,start,stop,type));
  }
  if (!fill.equals(""String_Node_Str"")) {
    graphics.setColor(ColorMapper.getColorByName(fill));
    graphics.fill(new Arc2D.Double(stroke_width,stroke_width,width,height,start,stop,type));
  }
  final int size=instructions.size();
  for (int i=0; i < size; i++) {
    ImageOperation instr=((ImageOperation)instructions.elementAt(i));
    if (instr instanceof DrawOperation) {
      PlanarImage img=((DrawOperation)instr).executeDrawOperation();
      graphics.drawImage(img.getAsBufferedImage(),null,0,0);
    }
 else     if (instr instanceof TransformOperation) {
      graphics=(Graphics2D)bi.getGraphics();
      PlanarImage image=((TransformOperation)instr).executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
      bi=image.getAsBufferedImage();
    }
  }
  return PlanarImage.wrapRenderedImage(bi);
}","/** 
 * {@inheritDoc}. 
 */
public PlanarImage executeDrawOperation(){
  BufferedImage bi=new BufferedImage(width + (stroke_width * 2),height + (stroke_width * 2),BufferedImage.TYPE_4BYTE_ABGR_PRE);
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  if (!stroke.equals(""String_Node_Str"")) {
    BasicStroke bStroke=new BasicStroke(stroke_width);
    graphics.setColor(ColorMapper.getColorByName(stroke));
    graphics.setStroke(bStroke);
    graphics.draw(new Arc2D.Double(stroke_width,stroke_width,width,height,start,stop,type));
  }
  if (!fill.equals(""String_Node_Str"")) {
    graphics.setColor(ColorMapper.getColorByName(fill));
    graphics.fill(new Arc2D.Double(stroke_width,stroke_width,width,height,start,stop,type));
  }
  final int size=instructions.size();
  for (int i=0; i < size; i++) {
    ImageOperation instr=((ImageOperation)instructions.elementAt(i));
    if (instr instanceof DrawOperation) {
      PlanarImage img=((DrawOperation)instr).executeDrawOperation();
      graphics.drawImage(img.getAsBufferedImage(),null,0,0);
    }
 else     if (instr instanceof TransformOperation) {
      PlanarImage image=((TransformOperation)instr).executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
      bi=image.getAsBufferedImage();
      graphics=(Graphics2D)bi.getGraphics();
    }
  }
  return PlanarImage.wrapRenderedImage(bi);
}",0.8768436578171092
64117,"/** 
 * {@inheritDoc}. 
 */
public PlanarImage executeDrawOperation(){
  BufferedImage bi=new BufferedImage(width,height,BufferedImage.TYPE_4BYTE_ABGR_PRE);
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  if (!stroke.equals(""String_Node_Str"")) {
    BasicStroke bStroke=new BasicStroke(stroke_width);
    graphics.setColor(ColorMapper.getColorByName(stroke));
    graphics.setStroke(bStroke);
    graphics.draw(new Ellipse2D.Double(0,0,width,height));
  }
  if (!fill.equals(""String_Node_Str"")) {
    graphics.setColor(ColorMapper.getColorByName(fill));
    graphics.fill(new Ellipse2D.Double(0,0,width,height));
  }
  final int size=instructions.size();
  for (int i=0; i < size; i++) {
    ImageOperation instr=((ImageOperation)instructions.elementAt(i));
    if (instr instanceof DrawOperation) {
      PlanarImage img=((DrawOperation)instr).executeDrawOperation();
      graphics.drawImage(img.getAsBufferedImage(),null,0,0);
    }
 else     if (instr instanceof TransformOperation) {
      graphics=(Graphics2D)bi.getGraphics();
      PlanarImage image=((TransformOperation)instr).executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
      bi=image.getAsBufferedImage();
    }
  }
  return PlanarImage.wrapRenderedImage(bi);
}","/** 
 * {@inheritDoc}. 
 */
public PlanarImage executeDrawOperation(){
  BufferedImage bi=new BufferedImage(width,height,BufferedImage.TYPE_4BYTE_ABGR_PRE);
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  if (!stroke.equals(""String_Node_Str"")) {
    BasicStroke bStroke=new BasicStroke(stroke_width);
    graphics.setColor(ColorMapper.getColorByName(stroke));
    graphics.setStroke(bStroke);
    graphics.draw(new Ellipse2D.Double(0,0,width,height));
  }
  if (!fill.equals(""String_Node_Str"")) {
    graphics.setColor(ColorMapper.getColorByName(fill));
    graphics.fill(new Ellipse2D.Double(0,0,width,height));
  }
  final int size=instructions.size();
  for (int i=0; i < size; i++) {
    ImageOperation instr=((ImageOperation)instructions.elementAt(i));
    if (instr instanceof DrawOperation) {
      PlanarImage img=((DrawOperation)instr).executeDrawOperation();
      graphics.drawImage(img.getAsBufferedImage(),null,0,0);
    }
 else     if (instr instanceof TransformOperation) {
      PlanarImage image=((TransformOperation)instr).executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
      bi=image.getAsBufferedImage();
      graphics=(Graphics2D)bi.getGraphics();
    }
  }
  return PlanarImage.wrapRenderedImage(bi);
}",0.8659711075441413
64118,"/** 
 * {@inheritDoc}. 
 */
public PlanarImage executeDrawOperation(){
  log(""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ arcwidth+ ""String_Node_Str""+ archeight);
  BufferedImage bi=new BufferedImage(width,height,BufferedImage.TYPE_4BYTE_ABGR_PRE);
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  if (!stroke.equals(""String_Node_Str"")) {
    BasicStroke bStroke=new BasicStroke(stroke_width);
    graphics.setColor(ColorMapper.getColorByName(stroke));
    graphics.setStroke(bStroke);
    if ((arcwidth != 0) || (archeight != 0)) {
      graphics.drawRoundRect(0,0,width,height,arcwidth,archeight);
    }
 else {
      graphics.drawRect(0,0,width,height);
    }
  }
  if (!fill.equals(""String_Node_Str"")) {
    graphics.setColor(ColorMapper.getColorByName(fill));
    if ((arcwidth != 0) || (archeight != 0)) {
      graphics.fillRoundRect(stroke_width,stroke_width,width - (stroke_width * 2),height - (stroke_width * 2),arcwidth,archeight);
    }
 else {
      graphics.fillRect(stroke_width,stroke_width,width - (stroke_width * 2),height - (stroke_width * 2));
    }
  }
  final int size=instructions.size();
  for (int i=0; i < size; i++) {
    ImageOperation instr=((ImageOperation)instructions.elementAt(i));
    if (instr instanceof DrawOperation) {
      PlanarImage img=((DrawOperation)instr).executeDrawOperation();
      graphics.drawImage(img.getAsBufferedImage(),null,0,0);
    }
 else     if (instr instanceof TransformOperation) {
      graphics=(Graphics2D)bi.getGraphics();
      PlanarImage image=((TransformOperation)instr).executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
      bi=image.getAsBufferedImage();
    }
  }
  return PlanarImage.wrapRenderedImage(bi);
}","/** 
 * {@inheritDoc}. 
 */
public PlanarImage executeDrawOperation(){
  log(""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ arcwidth+ ""String_Node_Str""+ archeight);
  BufferedImage bi=new BufferedImage(width,height,BufferedImage.TYPE_4BYTE_ABGR_PRE);
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  if (!stroke.equals(""String_Node_Str"")) {
    BasicStroke bStroke=new BasicStroke(stroke_width);
    graphics.setColor(ColorMapper.getColorByName(stroke));
    graphics.setStroke(bStroke);
    if ((arcwidth != 0) || (archeight != 0)) {
      graphics.drawRoundRect(0,0,width,height,arcwidth,archeight);
    }
 else {
      graphics.drawRect(0,0,width,height);
    }
  }
  if (!fill.equals(""String_Node_Str"")) {
    graphics.setColor(ColorMapper.getColorByName(fill));
    if ((arcwidth != 0) || (archeight != 0)) {
      graphics.fillRoundRect(stroke_width,stroke_width,width - (stroke_width * 2),height - (stroke_width * 2),arcwidth,archeight);
    }
 else {
      graphics.fillRect(stroke_width,stroke_width,width - (stroke_width * 2),height - (stroke_width * 2));
    }
  }
  final int size=instructions.size();
  for (int i=0; i < size; i++) {
    ImageOperation instr=((ImageOperation)instructions.elementAt(i));
    if (instr instanceof DrawOperation) {
      PlanarImage img=((DrawOperation)instr).executeDrawOperation();
      graphics.drawImage(img.getAsBufferedImage(),null,0,0);
    }
 else     if (instr instanceof TransformOperation) {
      PlanarImage image=((TransformOperation)instr).executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
      bi=image.getAsBufferedImage();
      graphics=(Graphics2D)bi.getGraphics();
    }
  }
  return PlanarImage.wrapRenderedImage(bi);
}",0.8960138648180243
64119,"/** 
 * Draw the text.
 * @return the resultant image.
 */
public PlanarImage executeDrawOperation(){
  log(""String_Node_Str"" + strText + ""String_Node_Str"");
  int width=1;
  int height=1;
  BufferedImage bi=new BufferedImage(width,height,BufferedImage.TYPE_4BYTE_ABGR_PRE);
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS,RenderingHints.VALUE_FRACTIONALMETRICS_ON);
  Font f=new Font(font,Font.PLAIN,point);
  FontMetrics fmetrics=graphics.getFontMetrics(f);
  height=fmetrics.getMaxAscent() + fmetrics.getMaxDescent();
  width=fmetrics.stringWidth(strText);
  bi=new BufferedImage(width,height,BufferedImage.TYPE_4BYTE_ABGR_PRE);
  graphics=(Graphics2D)bi.getGraphics();
  graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS,RenderingHints.VALUE_FRACTIONALMETRICS_ON);
  graphics.setFont(f);
  graphics.setColor(ColorMapper.getColorByName(color));
  graphics.drawString(strText,0,height - fmetrics.getMaxDescent());
  PlanarImage image=PlanarImage.wrapRenderedImage(bi);
  return image;
}","/** 
 * Draw the text.
 * @return the resultant image.
 */
public PlanarImage executeDrawOperation(){
  log(""String_Node_Str"" + strText + ""String_Node_Str"");
  int width=1;
  int height=1;
  BufferedImage bi=new BufferedImage(width,height,BufferedImage.TYPE_4BYTE_ABGR_PRE);
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS,RenderingHints.VALUE_FRACTIONALMETRICS_ON);
  Font f=createFont();
  FontMetrics fmetrics=graphics.getFontMetrics(f);
  height=fmetrics.getMaxAscent() + fmetrics.getMaxDescent();
  width=fmetrics.stringWidth(strText);
  bi=new BufferedImage(width,height,BufferedImage.TYPE_4BYTE_ABGR_PRE);
  graphics=(Graphics2D)bi.getGraphics();
  graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS,RenderingHints.VALUE_FRACTIONALMETRICS_ON);
  graphics.setFont(f);
  graphics.setColor(ColorMapper.getColorByName(color));
  graphics.drawString(strText,0,height - fmetrics.getMaxDescent());
  PlanarImage image=PlanarImage.wrapRenderedImage(bi);
  return image;
}",0.987624750499002
64120,"/** 
 * Writes a formatted list of target names to <code>System.out</code> with an optional description.
 * @param project the project instance.
 * @param names The names to be printed.Must not be <code>null</code>.
 * @param descriptions The associated target descriptions.May be <code>null</code>, in which case no descriptions are displayed. If non-<code>null</code>, this should have as many elements as <code>names</code>.
 * @param topDependencies The list of dependencies for each target.The dependencies are listed as a non null enumeration of String.
 * @param heading The heading to display.Should not be <code>null</code>.
 * @param maxlen The maximum length of the names of the targets.If descriptions are given, they are padded to this position so they line up (so long as the names really <i>are</i> shorter than this).
 */
private static void printTargets(final Project project,final Vector<String> names,final Vector<String> descriptions,final Vector<Enumeration<String>> dependencies,final String heading,final int maxlen){
  final String lSep=System.getProperty(""String_Node_Str"");
  String spaces=""String_Node_Str"";
  while (spaces.length() <= maxlen) {
    spaces+=spaces;
  }
  final StringBuilder msg=new StringBuilder();
  msg.append(heading).append(lSep).append(lSep);
  final int size=names.size();
  for (int i=0; i < size; i++) {
    msg.append(""String_Node_Str"");
    msg.append(names.elementAt(i));
    if (descriptions != null) {
      msg.append(spaces.substring(0,maxlen - names.elementAt(i).length() + 2));
      msg.append(descriptions.elementAt(i));
    }
    msg.append(lSep);
    if (!dependencies.isEmpty()) {
      final Enumeration<String> deps=dependencies.elementAt(i);
      if (deps.hasMoreElements()) {
        msg.append(""String_Node_Str"");
        while (deps.hasMoreElements()) {
          msg.append(deps.nextElement());
          if (deps.hasMoreElements()) {
            msg.append(""String_Node_Str"");
          }
        }
        msg.append(lSep);
      }
    }
  }
  project.log(msg.toString(),Project.MSG_WARN);
}","/** 
 * Writes a formatted list of target names to <code>System.out</code> with an optional description.
 * @param project the project instance.
 * @param names The names to be printed.Must not be <code>null</code>.
 * @param descriptions The associated target descriptions.May be <code>null</code>, in which case no descriptions are displayed. If non-<code>null</code>, this should have as many elements as <code>names</code>.
 * @param topDependencies The list of dependencies for each target.The dependencies are listed as a non null enumeration of String.
 * @param heading The heading to display.Should not be <code>null</code>.
 * @param maxlen The maximum length of the names of the targets.If descriptions are given, they are padded to this position so they line up (so long as the names really <i>are</i> shorter than this).
 */
private static void printTargets(final Project project,final Vector<String> names,final Vector<String> descriptions,final Vector<Enumeration<String>> dependencies,final String heading,final int maxlen){
  final String lSep=System.getProperty(""String_Node_Str"");
  StringBuilder spaces=new StringBuilder(""String_Node_Str"");
  while (spaces.length() <= maxlen) {
    spaces.append(spaces);
  }
  final StringBuilder msg=new StringBuilder();
  msg.append(heading).append(lSep).append(lSep);
  final int size=names.size();
  for (int i=0; i < size; i++) {
    msg.append(""String_Node_Str"");
    msg.append(names.elementAt(i));
    if (descriptions != null) {
      msg.append(spaces.substring(0,maxlen - names.elementAt(i).length() + 2));
      msg.append(descriptions.elementAt(i));
    }
    msg.append(lSep);
    if (!dependencies.isEmpty()) {
      final Enumeration<String> deps=dependencies.elementAt(i);
      if (deps.hasMoreElements()) {
        msg.append(""String_Node_Str"");
        while (deps.hasMoreElements()) {
          msg.append(deps.nextElement());
          if (deps.hasMoreElements()) {
            msg.append(""String_Node_Str"");
          }
        }
        msg.append(lSep);
      }
    }
  }
  project.log(msg.toString(),Project.MSG_WARN);
}",0.988246581914128
64121,"protected void dieOnCircularReference(Stack<Object> stk,Project p) throws BuildException {
  if (isChecked()) {
    return;
  }
  if (isReference()) {
    super.dieOnCircularReference(stk,p);
  }
 else {
    if (nested instanceof DataType) {
      pushAndInvokeCircularReferenceCheck((DataType)nested,stk,p);
    }
    setChecked(true);
  }
}","protected void dieOnCircularReference(Stack<Object> stk,Project p) throws BuildException {
  if (isChecked()) {
    return;
  }
  if (isReference()) {
    super.dieOnCircularReference(stk,p);
  }
 else {
    if (nested != null) {
      pushAndInvokeCircularReferenceCheck((DataType)nested,stk,p);
    }
    setChecked(true);
  }
}",0.8214285714285714
64122,"/** 
 * Parses the project file, configuring the project as it goes.
 * @param project the current project
 * @param source  the xml source
 * @param handler the root handler to use (contains the current context)
 * @exception BuildException if the configuration is invalid or cannotbe read
 */
public void parse(Project project,Object source,RootHandler handler) throws BuildException {
  AntXMLContext context=handler.context;
  File buildFile=null;
  URL url=null;
  String buildFileName=null;
  if (source instanceof File) {
    buildFile=(File)source;
  }
 else   if (source instanceof URL) {
    url=(URL)source;
  }
 else   if (source instanceof Resource) {
    FileProvider fp=((Resource)source).as(FileProvider.class);
    if (fp != null) {
      buildFile=fp.getFile();
    }
 else {
      URLProvider up=((Resource)source).as(URLProvider.class);
      if (up != null) {
        url=up.getURL();
      }
    }
  }
  if (buildFile != null) {
    buildFile=FILE_UTILS.normalize(buildFile.getAbsolutePath());
    context.setBuildFile(buildFile);
    buildFileName=buildFile.toString();
  }
 else   if (url != null) {
    try {
      context.setBuildFile((File)null);
      context.setBuildFile(url);
    }
 catch (    java.net.MalformedURLException ex) {
      throw new BuildException(ex);
    }
    buildFileName=url.toString();
  }
 else {
    throw new BuildException(""String_Node_Str"" + source.getClass().getName() + ""String_Node_Str"");
  }
  InputStream inputStream=null;
  InputSource inputSource=null;
  ZipFile zf=null;
  try {
    XMLReader parser=JAXPUtils.getNamespaceXMLReader();
    String uri=null;
    if (buildFile != null) {
      uri=FILE_UTILS.toURI(buildFile.getAbsolutePath());
      inputStream=new FileInputStream(buildFile);
    }
 else {
      uri=url.toString();
      int pling=-1;
      if (uri.startsWith(""String_Node_Str"") && (pling=uri.indexOf(""String_Node_Str"")) > -1) {
        zf=new ZipFile(org.apache.tools.ant.launch.Locator.fromJarURI(uri),""String_Node_Str"");
        inputStream=zf.getInputStream(zf.getEntry(uri.substring(pling + 1)));
      }
 else {
        URLConnection conn=url.openConnection();
        conn.setUseCaches(false);
        inputStream=conn.getInputStream();
      }
    }
    inputSource=new InputSource(inputStream);
    if (uri != null) {
      inputSource.setSystemId(uri);
    }
    project.log(""String_Node_Str"" + buildFileName + ""String_Node_Str""+ uri+ (zf != null ? ""String_Node_Str"" : ""String_Node_Str""),Project.MSG_VERBOSE);
    DefaultHandler hb=handler;
    parser.setContentHandler(hb);
    parser.setEntityResolver(hb);
    parser.setErrorHandler(hb);
    parser.setDTDHandler(hb);
    parser.parse(inputSource);
  }
 catch (  SAXParseException exc) {
    Location location=new Location(exc.getSystemId(),exc.getLineNumber(),exc.getColumnNumber());
    Throwable t=exc.getException();
    if (t instanceof BuildException) {
      BuildException be=(BuildException)t;
      if (be.getLocation() == Location.UNKNOWN_LOCATION) {
        be.setLocation(location);
      }
      throw be;
    }
    throw new BuildException(exc.getMessage(),t == null ? exc : t,location);
  }
catch (  SAXException exc) {
    Throwable t=exc.getException();
    if (t instanceof BuildException) {
      throw (BuildException)t;
    }
    throw new BuildException(exc.getMessage(),t == null ? exc : t);
  }
catch (  FileNotFoundException exc) {
    throw new BuildException(exc);
  }
catch (  UnsupportedEncodingException exc) {
    throw new BuildException(""String_Node_Str"" + buildFileName + ""String_Node_Str"",exc);
  }
catch (  IOException exc) {
    throw new BuildException(""String_Node_Str"" + buildFileName + ""String_Node_Str""+ exc.getMessage(),exc);
  }
 finally {
    FileUtils.close(inputStream);
    ZipFile.closeQuietly(zf);
  }
}","/** 
 * Parses the project file, configuring the project as it goes.
 * @param project the current project
 * @param source  the xml source
 * @param handler the root handler to use (contains the current context)
 * @exception BuildException if the configuration is invalid or cannotbe read
 */
public void parse(Project project,Object source,RootHandler handler) throws BuildException {
  AntXMLContext context=handler.context;
  File buildFile=null;
  URL url=null;
  String buildFileName=null;
  if (source instanceof File) {
    buildFile=(File)source;
  }
 else   if (source instanceof URL) {
    url=(URL)source;
  }
 else   if (source instanceof Resource) {
    FileProvider fp=((Resource)source).as(FileProvider.class);
    if (fp != null) {
      buildFile=fp.getFile();
    }
 else {
      URLProvider up=((Resource)source).as(URLProvider.class);
      if (up != null) {
        url=up.getURL();
      }
    }
  }
  if (buildFile != null) {
    buildFile=FILE_UTILS.normalize(buildFile.getAbsolutePath());
    context.setBuildFile(buildFile);
    buildFileName=buildFile.toString();
  }
 else   if (url != null) {
    try {
      context.setBuildFile((File)null);
      context.setBuildFile(url);
    }
 catch (    java.net.MalformedURLException ex) {
      throw new BuildException(ex);
    }
    buildFileName=url.toString();
  }
 else {
    throw new BuildException(""String_Node_Str"" + source.getClass().getName() + ""String_Node_Str"");
  }
  InputStream inputStream=null;
  InputSource inputSource=null;
  ZipFile zf=null;
  try {
    XMLReader parser=JAXPUtils.getNamespaceXMLReader();
    String uri=null;
    if (buildFile != null) {
      uri=FILE_UTILS.toURI(buildFile.getAbsolutePath());
      inputStream=new FileInputStream(buildFile);
    }
 else {
      uri=url.toString();
      int pling=-1;
      if (uri.startsWith(""String_Node_Str"") && (pling=uri.indexOf(""String_Node_Str"")) > -1) {
        zf=new ZipFile(org.apache.tools.ant.launch.Locator.fromJarURI(uri),""String_Node_Str"");
        inputStream=zf.getInputStream(zf.getEntry(uri.substring(pling + 2)));
      }
 else {
        URLConnection conn=url.openConnection();
        conn.setUseCaches(false);
        inputStream=conn.getInputStream();
      }
    }
    inputSource=new InputSource(inputStream);
    if (uri != null) {
      inputSource.setSystemId(uri);
    }
    project.log(""String_Node_Str"" + buildFileName + ""String_Node_Str""+ uri+ (zf != null ? ""String_Node_Str"" : ""String_Node_Str""),Project.MSG_VERBOSE);
    DefaultHandler hb=handler;
    parser.setContentHandler(hb);
    parser.setEntityResolver(hb);
    parser.setErrorHandler(hb);
    parser.setDTDHandler(hb);
    parser.parse(inputSource);
  }
 catch (  SAXParseException exc) {
    Location location=new Location(exc.getSystemId(),exc.getLineNumber(),exc.getColumnNumber());
    Throwable t=exc.getException();
    if (t instanceof BuildException) {
      BuildException be=(BuildException)t;
      if (be.getLocation() == Location.UNKNOWN_LOCATION) {
        be.setLocation(location);
      }
      throw be;
    }
    throw new BuildException(exc.getMessage(),t == null ? exc : t,location);
  }
catch (  SAXException exc) {
    Throwable t=exc.getException();
    if (t instanceof BuildException) {
      throw (BuildException)t;
    }
    throw new BuildException(exc.getMessage(),t == null ? exc : t);
  }
catch (  FileNotFoundException exc) {
    throw new BuildException(exc);
  }
catch (  UnsupportedEncodingException exc) {
    throw new BuildException(""String_Node_Str"" + buildFileName + ""String_Node_Str"",exc);
  }
catch (  IOException exc) {
    throw new BuildException(""String_Node_Str"" + buildFileName + ""String_Node_Str""+ exc.getMessage(),exc);
  }
 finally {
    FileUtils.close(inputStream);
    ZipFile.closeQuietly(zf);
  }
}",0.9997367728349564
64123,"@Test public void testXalan2RedirectViaJDKFactory() throws Exception {
  try {
    getClass().getClassLoader().loadClass(""String_Node_Str"");
  }
 catch (  Exception exc) {
    Assume.assumeNoException(""String_Node_Str"",exc);
  }
  File xsl=getFile(""String_Node_Str"");
  liaison.setStylesheet(xsl);
  ((TraXLiaison)liaison).setFeature(""String_Node_Str"",true);
  File out=new File(""String_Node_Str"");
  File in=getFile(""String_Node_Str"");
  ClassLoader orig=Thread.currentThread().getContextClassLoader();
  try {
    liaison.addParam(""String_Node_Str"",""String_Node_Str"");
    Thread.currentThread().setContextClassLoader(new ClassLoader(ClassLoader.getSystemClassLoader().getParent()){
      public InputStream getResourceAsStream(      String name){
        if (name.startsWith(""String_Node_Str"")) {
          return new ByteArrayInputStream(new byte[0]);
        }
        return super.getResourceAsStream(name);
      }
    }
);
    System.setSecurityManager(new SecurityManager(){
      public void checkPermission(      Permission perm){
      }
    }
);
    liaison.transform(in,out);
  }
  finally {
    out.delete();
    Thread.currentThread().setContextClassLoader(orig);
    System.setSecurityManager(null);
  }
}","@Test public void testXalan2RedirectViaJDKFactory() throws Exception {
  try {
    getClass().getClassLoader().loadClass(""String_Node_Str"");
  }
 catch (  Exception exc) {
    Assume.assumeNoException(""String_Node_Str"",exc);
  }
  try {
    String factoryName=TransformerFactory.newInstance().getClass().getName();
    Assume.assumeFalse(""String_Node_Str"",""String_Node_Str"".equals(factoryName));
  }
 catch (  TransformerFactoryConfigurationError exc) {
    throw new RuntimeException(exc);
  }
  File xsl=getFile(""String_Node_Str"");
  liaison.setStylesheet(xsl);
  ((TraXLiaison)liaison).setFeature(""String_Node_Str"",true);
  File out=new File(""String_Node_Str"");
  File in=getFile(""String_Node_Str"");
  ClassLoader orig=Thread.currentThread().getContextClassLoader();
  try {
    liaison.addParam(""String_Node_Str"",""String_Node_Str"");
    Thread.currentThread().setContextClassLoader(new ClassLoader(ClassLoader.getSystemClassLoader().getParent()){
      public InputStream getResourceAsStream(      String name){
        if (name.startsWith(""String_Node_Str"")) {
          return new ByteArrayInputStream(new byte[0]);
        }
        return super.getResourceAsStream(name);
      }
    }
);
    System.setSecurityManager(new SecurityManager(){
      public void checkPermission(      Permission perm){
      }
    }
);
    liaison.transform(in,out);
  }
  finally {
    out.delete();
    Thread.currentThread().setContextClassLoader(orig);
    System.setSecurityManager(null);
  }
}",0.9018450184501844
64124,"@Test public void testJunitOnMpArguments() throws Exception {
  final File tmp=new File(System.getProperty(""String_Node_Str""));
  final File workDir=new File(tmp,String.format(""String_Node_Str"",getClass().getName(),System.currentTimeMillis() / 1000));
  workDir.mkdirs();
  try {
    final File modulesDir=new File(workDir,""String_Node_Str"");
    modulesDir.mkdirs();
    final Project project=new Project();
    project.init();
    project.setBaseDir(workDir);
    final MockCommandLauncher mockProcLauncher=new MockCommandLauncher();
    project.addReference(MagicNames.ANT_VM_LAUNCHER_REF_ID,mockProcLauncher);
    JUnitTask task=new JUnitTask();
    task.setDir(workDir);
    task.setFork(true);
    task.setProject(project);
    final File junit=LoaderUtils.getResourceSource(JUnitTask.class.getClassLoader(),""String_Node_Str"");
    final Path mp=new Path(project);
    mp.add(new Path(project,junit.getAbsolutePath()));
    mp.add(new Path(project,modulesDir.getName()));
    task.createModulepath().add(mp);
    task.addTest(new JUnitTest(""String_Node_Str""));
    task.execute();
    assertNotNull(mockProcLauncher.cmd);
    String resCp=null;
    String resMp=null;
    Set<String> resExports=new TreeSet<String>();
    for (int i=1; i < mockProcLauncher.cmd.length; i++) {
      if (""String_Node_Str"".equals(mockProcLauncher.cmd[i])) {
        resCp=mockProcLauncher.cmd[++i];
      }
 else       if (""String_Node_Str"".equals(mockProcLauncher.cmd[i])) {
        resMp=mockProcLauncher.cmd[++i];
      }
 else       if (mockProcLauncher.cmd[i].equals(""String_Node_Str"")) {
        resExports.add(mockProcLauncher.cmd[++i]);
      }
 else       if (JUnitTestRunner.class.getName().equals(mockProcLauncher.cmd[i])) {
        break;
      }
    }
    assertTrue(""String_Node_Str"",resExports.isEmpty());
    assertNull(""String_Node_Str"",resCp);
    assertEquals(""String_Node_Str"",mp.toString(),resMp);
  }
  finally {
    delete(workDir);
  }
}","@Test public void testJunitOnMpArguments() throws Exception {
  final File tmp=new File(System.getProperty(""String_Node_Str""));
  final File workDir=new File(tmp,String.format(""String_Node_Str"",getClass().getName(),System.currentTimeMillis() / 1000));
  workDir.mkdirs();
  try {
    final File modulesDir=new File(workDir,""String_Node_Str"");
    modulesDir.mkdirs();
    final Project project=new Project();
    project.init();
    project.setBaseDir(workDir);
    final MockCommandLauncher mockProcLauncher=new MockCommandLauncher();
    project.addReference(MagicNames.ANT_VM_LAUNCHER_REF_ID,mockProcLauncher);
    JUnitTask task=new JUnitTask();
    task.setDir(workDir);
    task.setFork(true);
    task.setProject(project);
    final File junit=LoaderUtils.getResourceSource(JUnitTask.class.getClassLoader(),""String_Node_Str"");
    final Path mp=new Path(project);
    mp.add(new Path(project,junit.getAbsolutePath()));
    mp.add(new Path(project,modulesDir.getName()));
    task.createModulepath().add(mp);
    task.addTest(new JUnitTest(""String_Node_Str""));
    task.execute();
    assertNotNull(mockProcLauncher.cmd);
    String resCp=null;
    String resMp=null;
    Set<String> resExports=new TreeSet<String>();
    for (int i=1; i < mockProcLauncher.cmd.length; i++) {
      if (""String_Node_Str"".equals(mockProcLauncher.cmd[i])) {
        resCp=mockProcLauncher.cmd[++i];
      }
 else       if (""String_Node_Str"".equals(mockProcLauncher.cmd[i])) {
        resMp=mockProcLauncher.cmd[++i];
      }
 else       if (mockProcLauncher.cmd[i].equals(""String_Node_Str"")) {
        resExports.add(mockProcLauncher.cmd[++i]);
      }
 else       if (JUnitTestRunner.class.getName().equals(mockProcLauncher.cmd[i])) {
        break;
      }
    }
    assertTrue(""String_Node_Str"",resExports.isEmpty());
    if (System.getProperty(MagicNames.BUILD_SYSCLASSPATH) == null) {
      assertNull(""String_Node_Str"",resCp);
    }
    assertEquals(""String_Node_Str"",mp.toString(),resMp);
  }
  finally {
    delete(workDir);
  }
}",0.971558016612132
64125,"@Test public void testJunitOnCpArguments() throws Exception {
  final File tmp=new File(System.getProperty(""String_Node_Str""));
  final File workDir=new File(tmp,String.format(""String_Node_Str"",getClass().getName(),System.currentTimeMillis() / 1000));
  workDir.mkdirs();
  try {
    final File modulesDir=new File(workDir,""String_Node_Str"");
    modulesDir.mkdirs();
    final Project project=new Project();
    project.init();
    project.setBaseDir(workDir);
    final MockCommandLauncher mockProcLauncher=new MockCommandLauncher();
    project.addReference(MagicNames.ANT_VM_LAUNCHER_REF_ID,mockProcLauncher);
    JUnitTask task=new JUnitTask();
    task.setDir(workDir);
    task.setFork(true);
    task.setProject(project);
    final File junit=LoaderUtils.getResourceSource(JUnitTask.class.getClassLoader(),""String_Node_Str"");
    final Path cp=new Path(project);
    cp.setPath(junit.getAbsolutePath());
    task.createClasspath().add(cp);
    final Path mp=new Path(project);
    mp.setPath(modulesDir.getName());
    task.createModulepath().add(mp);
    task.addTest(new JUnitTest(""String_Node_Str""));
    task.execute();
    assertNotNull(mockProcLauncher.cmd);
    String resCp=null;
    String resMp=null;
    Set<String> resExports=new TreeSet<String>();
    for (int i=1; i < mockProcLauncher.cmd.length; i++) {
      if (""String_Node_Str"".equals(mockProcLauncher.cmd[i])) {
        resCp=mockProcLauncher.cmd[++i];
      }
 else       if (""String_Node_Str"".equals(mockProcLauncher.cmd[i])) {
        resMp=mockProcLauncher.cmd[++i];
      }
 else       if (mockProcLauncher.cmd[i].equals(""String_Node_Str"")) {
        resExports.add(mockProcLauncher.cmd[++i]);
      }
 else       if (JUnitTestRunner.class.getName().equals(mockProcLauncher.cmd[i])) {
        break;
      }
    }
    assertTrue(""String_Node_Str"",resExports.isEmpty());
    assertEquals(""String_Node_Str"",cp.toString(),resCp);
    assertEquals(""String_Node_Str"",mp.toString(),resMp);
  }
  finally {
    delete(workDir);
  }
}","@Test public void testJunitOnCpArguments() throws Exception {
  final File tmp=new File(System.getProperty(""String_Node_Str""));
  final File workDir=new File(tmp,String.format(""String_Node_Str"",getClass().getName(),System.currentTimeMillis() / 1000));
  workDir.mkdirs();
  try {
    final File modulesDir=new File(workDir,""String_Node_Str"");
    modulesDir.mkdirs();
    final Project project=new Project();
    project.init();
    project.setBaseDir(workDir);
    final MockCommandLauncher mockProcLauncher=new MockCommandLauncher();
    project.addReference(MagicNames.ANT_VM_LAUNCHER_REF_ID,mockProcLauncher);
    JUnitTask task=new JUnitTask();
    task.setDir(workDir);
    task.setFork(true);
    task.setProject(project);
    final File junit=LoaderUtils.getResourceSource(JUnitTask.class.getClassLoader(),""String_Node_Str"");
    final Path cp=new Path(project);
    cp.setPath(junit.getAbsolutePath());
    task.createClasspath().add(cp);
    final Path mp=new Path(project);
    mp.setPath(modulesDir.getName());
    task.createModulepath().add(mp);
    task.addTest(new JUnitTest(""String_Node_Str""));
    task.execute();
    assertNotNull(mockProcLauncher.cmd);
    String resCp=null;
    String resMp=null;
    Set<String> resExports=new TreeSet<String>();
    for (int i=1; i < mockProcLauncher.cmd.length; i++) {
      if (""String_Node_Str"".equals(mockProcLauncher.cmd[i])) {
        resCp=mockProcLauncher.cmd[++i];
      }
 else       if (""String_Node_Str"".equals(mockProcLauncher.cmd[i])) {
        resMp=mockProcLauncher.cmd[++i];
      }
 else       if (mockProcLauncher.cmd[i].equals(""String_Node_Str"")) {
        resExports.add(mockProcLauncher.cmd[++i]);
      }
 else       if (JUnitTestRunner.class.getName().equals(mockProcLauncher.cmd[i])) {
        break;
      }
    }
    assertTrue(""String_Node_Str"",resExports.isEmpty());
    if (System.getProperty(MagicNames.BUILD_SYSCLASSPATH) == null) {
      assertEquals(""String_Node_Str"",cp.toString(),resCp);
    }
    assertEquals(""String_Node_Str"",mp.toString(),resMp);
  }
  finally {
    delete(workDir);
  }
}",0.9811965811965812
64126,"/** 
 * demand creation of the package list. When you add a new package, add a new test below.
 */
private static void buildJrePackages(){
  jrePackages=new Vector<String>();
switch (javaVersionNumber) {
case VERSION_1_9:
case VERSION_1_8:
case VERSION_1_7:
case VERSION_1_6:
case VERSION_1_5:
    jrePackages.addElement(""String_Node_Str"");
case VERSION_1_4:
  if (javaVersionNumber == VERSION_1_4) {
    jrePackages.addElement(""String_Node_Str"");
    jrePackages.addElement(""String_Node_Str"");
    jrePackages.addElement(""String_Node_Str"");
    jrePackages.addElement(""String_Node_Str"");
  }
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
case VERSION_1_3:
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
case VERSION_1_2:
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
case VERSION_1_1:
default :
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
break;
}
}","/** 
 * demand creation of the package list. When you add a new package, add a new test below.
 */
private static void buildJrePackages(){
  jrePackages=new Vector<String>();
switch (javaVersionNumber) {
case VERSION_1_9:
case VERSION_1_8:
case VERSION_1_7:
    jrePackages.addElement(""String_Node_Str"");
case VERSION_1_6:
case VERSION_1_5:
  jrePackages.addElement(""String_Node_Str"");
case VERSION_1_4:
if (javaVersionNumber == VERSION_1_4) {
  jrePackages.addElement(""String_Node_Str"");
  jrePackages.addElement(""String_Node_Str"");
  jrePackages.addElement(""String_Node_Str"");
  jrePackages.addElement(""String_Node_Str"");
}
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
case VERSION_1_3:
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
case VERSION_1_2:
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
case VERSION_1_1:
default :
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
jrePackages.addElement(""String_Node_Str"");
break;
}
}",0.8525980911983033
64127,"/** 
 * Testing helper method; kept here for unification of changes.
 * @return a list of test classes depending on the java version.
 */
public static Vector<String> getJrePackageTestCases(){
  Vector<String> tests=new Vector<String>();
  tests.addElement(""String_Node_Str"");
switch (javaVersionNumber) {
case VERSION_1_9:
case VERSION_1_8:
case VERSION_1_7:
case VERSION_1_6:
case VERSION_1_5:
    tests.addElement(""String_Node_Str"");
case VERSION_1_4:
  tests.addElement(""String_Node_Str"");
if (javaVersionNumber == VERSION_1_4) {
  tests.addElement(""String_Node_Str"");
  tests.addElement(""String_Node_Str"");
  tests.addElement(""String_Node_Str"");
  tests.addElement(""String_Node_Str"");
}
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
case VERSION_1_3:
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
case VERSION_1_2:
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
case VERSION_1_1:
default :
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
break;
}
return tests;
}","/** 
 * Testing helper method; kept here for unification of changes.
 * @return a list of test classes depending on the java version.
 */
public static Vector<String> getJrePackageTestCases(){
  Vector<String> tests=new Vector<String>();
  tests.addElement(""String_Node_Str"");
switch (javaVersionNumber) {
case VERSION_1_9:
case VERSION_1_8:
case VERSION_1_7:
    tests.addElement(""String_Node_Str"");
case VERSION_1_6:
case VERSION_1_5:
  tests.addElement(""String_Node_Str"");
case VERSION_1_4:
tests.addElement(""String_Node_Str"");
if (javaVersionNumber == VERSION_1_4) {
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
}
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
case VERSION_1_3:
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
case VERSION_1_2:
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
case VERSION_1_1:
default :
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
tests.addElement(""String_Node_Str"");
break;
}
return tests;
}",0.9034070951879172
64128,"/** 
 * Sort keys by size so that tokens that are substrings of other strings are tried later.
 */
private Iterator<Object> getOrderedIterator(Properties props){
  Set<Object> keys=new TreeSet(new Comparator<Object>(){
    @Override public int compare(    Object key1,    Object key2){
      return compare(key1.toString(),key2.toString());
    }
    private int compare(    String key1,    String key2){
      return key2.length() - key1.length();
    }
  }
);
  keys.addAll(props.keySet());
  return keys.iterator();
}","/** 
 * Sort keys by size so that tokens that are substrings of other strings are tried later.
 */
private Iterator<Object> getOrderedIterator(Properties props){
  List<Object> keys=new ArrayList<Object>(props.keySet());
  Collections.sort(keys,new Comparator<Object>(){
    @Override public int compare(    Object key1,    Object key2){
      return compare(key1.toString(),key2.toString());
    }
    private int compare(    String key1,    String key2){
      return key2.length() - key1.length();
    }
  }
);
  return keys.iterator();
}",0.8331762488218661
64129,"public void testDifferentWindowsDrive(){
  if (!Os.isFamily(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
 else {
    try {
      new java.io.File(""String_Node_Str"").getCanonicalPath();
    }
 catch (    java.io.IOException e) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
    expectBuildExceptionContaining(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertPropertyUnset(""String_Node_Str"");
  }
}","public void testDifferentWindowsDrive(){
  if (!Os.isFamily(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
 else {
    File tmpdir=new File(System.getProperty(""String_Node_Str""));
    String driveLetter=""String_Node_Str"";
    try {
      String tmpCanonicalPath=tmpdir.getCanonicalPath();
      driveLetter=tmpCanonicalPath.substring(1).toUpperCase();
    }
 catch (    IOException ioe) {
      System.out.println(""String_Node_Str"" + ioe.getMessage());
    }
    String altDriveLetter=null;
    try {
      if (""String_Node_Str"".equals(driveLetter)) {
        altDriveLetter=""String_Node_Str"";
      }
 else {
        altDriveLetter=""String_Node_Str"";
      }
      new java.io.File(altDriveLetter + ""String_Node_Str"").getCanonicalPath();
    }
 catch (    java.io.IOException e) {
      System.out.println(""String_Node_Str"" + altDriveLetter + ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
    expectBuildExceptionContaining(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertPropertyUnset(""String_Node_Str"");
  }
}",0.5551232166018158
64130,"/** 
 * Run the definition.
 * @exception BuildException if an error occurs
 */
public void execute() throws BuildException {
  ClassLoader al=createLoader();
  if (!definerSet) {
    if (getURI() == null) {
      throw new BuildException(""String_Node_Str"" + getTaskName() + ""String_Node_Str"",getLocation());
    }
    if (getURI().startsWith(MagicNames.ANTLIB_PREFIX)) {
      String uri1=getURI();
      setResource(makeResourceFromURI(uri1));
    }
 else {
      throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + getURI());
    }
  }
  if (name != null) {
    if (classname == null) {
      throw new BuildException(""String_Node_Str"" + getTaskName() + ""String_Node_Str""+ ""String_Node_Str"",getLocation());
    }
    addDefinition(al,name,classname);
  }
 else {
    if (classname != null) {
      String msg=""String_Node_Str"" + ""String_Node_Str"";
      throw new BuildException(msg,getLocation());
    }
    Enumeration urls=null;
    if (file != null) {
      final URL url=fileToURL();
      if (url == null) {
        return;
      }
      urls=new Enumeration(){
        private boolean more=true;
        public boolean hasMoreElements(){
          return more;
        }
        public Object nextElement() throws NoSuchElementException {
          if (more) {
            more=false;
            return url;
          }
 else {
            throw new NoSuchElementException();
          }
        }
      }
;
    }
 else {
      urls=resourceToURLs(al);
    }
    while (urls.hasMoreElements()) {
      URL url=(URL)urls.nextElement();
      int fmt=this.format;
      if (url.toString().toLowerCase(Locale.ENGLISH).endsWith(""String_Node_Str"")) {
        fmt=Format.XML;
      }
      if (fmt == Format.PROPERTIES) {
        loadProperties(al,url);
        break;
      }
 else {
        if (resourceStack.getStack().get(url) != null) {
          log(""String_Node_Str"" + url + ""String_Node_Str""+ ""String_Node_Str""+ getLocation()+ ""String_Node_Str""+ resourceStack.getStack().get(url),Project.MSG_WARN);
        }
 else {
          try {
            resourceStack.getStack().put(url,getLocation());
            loadAntlib(al,url);
          }
  finally {
            resourceStack.getStack().remove(url);
          }
        }
      }
    }
  }
}","/** 
 * Run the definition.
 * @exception BuildException if an error occurs
 */
public void execute() throws BuildException {
  ClassLoader al=createLoader();
  if (!definerSet) {
    if (getURI() == null) {
      throw new BuildException(""String_Node_Str"" + getTaskName() + ""String_Node_Str"",getLocation());
    }
    if (getURI().startsWith(MagicNames.ANTLIB_PREFIX)) {
      String uri1=getURI();
      setResource(makeResourceFromURI(uri1));
    }
 else {
      throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + getURI() + ""String_Node_Str"");
    }
  }
  if (name != null) {
    if (classname == null) {
      throw new BuildException(""String_Node_Str"" + getTaskName() + ""String_Node_Str""+ ""String_Node_Str"",getLocation());
    }
    addDefinition(al,name,classname);
  }
 else {
    if (classname != null) {
      String msg=""String_Node_Str"" + ""String_Node_Str"";
      throw new BuildException(msg,getLocation());
    }
    Enumeration urls=null;
    if (file != null) {
      final URL url=fileToURL();
      if (url == null) {
        return;
      }
      urls=new Enumeration(){
        private boolean more=true;
        public boolean hasMoreElements(){
          return more;
        }
        public Object nextElement() throws NoSuchElementException {
          if (more) {
            more=false;
            return url;
          }
 else {
            throw new NoSuchElementException();
          }
        }
      }
;
    }
 else {
      urls=resourceToURLs(al);
    }
    while (urls.hasMoreElements()) {
      URL url=(URL)urls.nextElement();
      int fmt=this.format;
      if (url.toString().toLowerCase(Locale.ENGLISH).endsWith(""String_Node_Str"")) {
        fmt=Format.XML;
      }
      if (fmt == Format.PROPERTIES) {
        loadProperties(al,url);
        break;
      }
 else {
        if (resourceStack.getStack().get(url) != null) {
          log(""String_Node_Str"" + url + ""String_Node_Str""+ ""String_Node_Str""+ getLocation()+ ""String_Node_Str""+ resourceStack.getStack().get(url),Project.MSG_WARN);
        }
 else {
          try {
            resourceStack.getStack().put(url,getLocation());
            loadAntlib(al,url);
          }
  finally {
            resourceStack.getStack().remove(url);
          }
        }
      }
    }
  }
}",0.9956082564778216
64131,"/** 
 * Returns the next character in the filtered stream, converting non latin characters to unicode escapes.
 * @return the next character in the resulting stream, or -1if the end of the resulting stream has been reached
 * @exception IOException if the underlying stream throwsan IOException during reading
 */
public final int read() throws IOException {
  if (!getInitialized()) {
    initialize();
    setInitialized(true);
  }
  int ch=-1;
  if (unicodeBuf.length() == 0) {
    ch=in.read();
    if (ch != -1) {
      char achar=(char)ch;
      if (achar >= '\u0080') {
        unicodeBuf=new StringBuffer(""String_Node_Str"");
        String s=Integer.toHexString(ch);
        for (int i=0; i < s.length(); i++) {
          unicodeBuf.setCharAt(unicodeBuf.length() - s.length() + i,s.charAt(i));
        }
        ch='\\';
      }
    }
  }
 else {
    ch=(int)unicodeBuf.charAt(0);
    unicodeBuf.deleteCharAt(0);
  }
  return ch;
}","/** 
 * Returns the next character in the filtered stream, converting non latin characters to unicode escapes.
 * @return the next character in the resulting stream, or -1if the end of the resulting stream has been reached
 * @exception IOException if the underlying stream throwsan IOException during reading
 */
public final int read() throws IOException {
  if (!getInitialized()) {
    initialize();
    setInitialized(true);
  }
  int ch=-1;
  if (unicodeBuf.length() == 0) {
    ch=in.read();
    if (ch != -1) {
      char achar=(char)ch;
      if (achar >= '\u0080') {
        unicodeBuf=UnicodeUtil.EscapeUnicode(achar);
        ch='\\';
      }
    }
  }
 else {
    ch=(int)unicodeBuf.charAt(0);
    unicodeBuf.deleteCharAt(0);
  }
  return ch;
}",0.8549528301886793
64132,"/** 
 * Return the unicode escape sequence for a character, in the form \u005CuNNNN.
 * @param ch the character to encode
 * @return the unicode escape sequence
 */
private String escapeUnicode(char ch){
  StringBuffer buffy=new StringBuffer(""String_Node_Str"");
  String hex=Integer.toHexString((int)ch);
  buffy.append(""String_Node_Str"".substring(4 - hex.length()));
  buffy.append(hex);
  return buffy.toString();
}","/** 
 * Return the unicode escape sequence for a character, in the form \u005CuNNNN.
 * @param ch the character to encode
 * @return the unicode escape sequence
 */
private String escapeUnicode(char ch){
  return ""String_Node_Str"" + UnicodeUtil.EscapeUnicode(ch);
}",0.6656891495601173
64133,"/** 
 * Returns an array containing the target filename(s) for the given source file. <p>if the given rule doesn't apply to the source file, implementation must return null. SourceFileScanner will then omit the source file in question.</p>
 * @param sourceFileName the name of the source file relative tosome given basedirectory.
 * @return an array of strings if the ruld applies to the source file, ornull if it does not.
 */
String[] mapFileName(String sourceFileName);","/** 
 * Returns an array containing the target filename(s) for the given source file. <p>if the given rule doesn't apply to the source file, implementation must return null. SourceFileScanner will then omit the source file in question.</p>
 * @param sourceFileName the name of the source file relative tosome given basedirectory.
 * @return an array of strings if the rule applies to the source file, ornull if it does not.
 */
String[] mapFileName(String sourceFileName);",0.9978813559322034
64134,"private InetAddress selectBestAddress(InetAddress bestSoFar,InetAddress current){
  InetAddress best=bestSoFar;
  if (best == null) {
    best=current;
  }
 else {
    if (current == null || current.isLoopbackAddress()) {
    }
 else     if (current.isLinkLocalAddress()) {
      if (best.isLoopbackAddress()) {
        best=current;
      }
    }
 else     if (current.isSiteLocalAddress()) {
      if (best.isLoopbackAddress() || best.isLinkLocalAddress() || !hasHostName(best)) {
        best=current;
      }
    }
 else {
      if (best.isLoopbackAddress() || best.isLinkLocalAddress() || best.isSiteLocalAddress()|| !hasHostName(best)) {
        best=current;
      }
    }
  }
  return best;
}","private InetAddress selectBestAddress(InetAddress bestSoFar,InetAddress current){
  InetAddress best=bestSoFar;
  if (best == null) {
    best=current;
  }
 else {
    if (current == null || current.isLoopbackAddress()) {
    }
 else     if (current.isLinkLocalAddress()) {
      if (best.isLoopbackAddress()) {
        best=current;
      }
    }
 else     if (current.isSiteLocalAddress()) {
      if (best.isLoopbackAddress() || best.isLinkLocalAddress() || (best.isSiteLocalAddress() && !hasHostName(best))) {
        best=current;
      }
    }
 else {
      if (best.isLoopbackAddress() || best.isLinkLocalAddress() || best.isSiteLocalAddress()|| !hasHostName(best)) {
        best=current;
      }
    }
  }
  return best;
}",0.9783368273934312
64135,"/** 
 * This constructor extracts the needed information from the given test.
 * @param test Test to analyze
 */
public TestInfos(Test test){
  className=test.getClass().getName();
  methodName=test.toString();
  methodName=methodName.substring(0,methodName.indexOf('('));
}","/** 
 * This constructor extracts the needed information from the given test.
 * @param test Test to analyze
 */
public TestInfos(Test test){
  className=test.getClass().getName();
  String _methodName=test.toString();
  methodName=_methodName.substring(0,_methodName.indexOf('('));
}",0.982078853046595
64136,"private void writeJavaClass(){
  try {
    File sourceFile=new File((getLocationName() + ""String_Node_Str""));
    verbose(""String_Node_Str"" + sourceFile.getAbsolutePath() + ""String_Node_Str"");
    sourceFile.delete();
    writer=new BufferedWriter(new FileWriter(sourceFile));
    createClassHeader();
    createSuiteMethod();
    createClassFooter();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    FileUtils.close(writer);
  }
}","private void writeJavaClass(){
  try {
    File sourceFile=new File((getLocationName() + ""String_Node_Str""));
    verbose(""String_Node_Str"" + sourceFile.getAbsolutePath() + ""String_Node_Str"");
    if (!sourceFile.delete()) {
      throw new IOException(""String_Node_Str"" + sourceFile);
    }
    writer=new BufferedWriter(new FileWriter(sourceFile));
    createClassHeader();
    createSuiteMethod();
    createClassFooter();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    FileUtils.close(writer);
  }
}",0.6275303643724697
64137,"/** 
 * @since Ant 1.6
 */
JUnitTaskMirror.JUnitResultFormatterMirror createFormatter(ClassLoader loader) throws BuildException {
  if (classname == null) {
    throw new BuildException(""String_Node_Str"");
  }
  Class f=null;
  try {
    if (loader == null) {
      f=Class.forName(classname);
    }
 else {
      f=Class.forName(classname,true,loader);
    }
  }
 catch (  ClassNotFoundException e) {
    throw new BuildException(""String_Node_Str"" + loader + ""String_Node_Str""+ classname+ ""String_Node_Str""+ e,e);
  }
catch (  NoClassDefFoundError e) {
    throw new BuildException(""String_Node_Str"" + loader + ""String_Node_Str""+ classname+ ""String_Node_Str""+ e,e);
  }
  Object o=null;
  try {
    o=f.newInstance();
  }
 catch (  InstantiationException e) {
    throw new BuildException(e);
  }
catch (  IllegalAccessException e) {
    throw new BuildException(e);
  }
  if (!(o instanceof JUnitTaskMirror.JUnitResultFormatterMirror)) {
    throw new BuildException(classname + ""String_Node_Str"");
  }
  JUnitTaskMirror.JUnitResultFormatterMirror r=(JUnitTaskMirror.JUnitResultFormatterMirror)o;
  if (useFile && outFile != null) {
    try {
      out=new BufferedOutputStream(new FileOutputStream(outFile));
    }
 catch (    java.io.IOException e) {
      throw new BuildException(""String_Node_Str"" + outFile,e);
    }
  }
  r.setOutput(out);
  boolean needToSetProjectReference=true;
  try {
    Field field=r.getClass().getField(""String_Node_Str"");
    Object value=field.get(r);
    if (value instanceof Project) {
      needToSetProjectReference=false;
    }
  }
 catch (  Exception e) {
  }
  if (needToSetProjectReference) {
    Method setter;
    try {
      setter=r.getClass().getMethod(""String_Node_Str"",new Class[]{Project.class});
      setter.invoke(r,new Object[]{project});
    }
 catch (    Exception e) {
    }
  }
  return r;
}","/** 
 * @since Ant 1.6
 */
JUnitTaskMirror.JUnitResultFormatterMirror createFormatter(ClassLoader loader) throws BuildException {
  if (classname == null) {
    throw new BuildException(""String_Node_Str"");
  }
  Class f=null;
  try {
    if (loader == null) {
      f=Class.forName(classname);
    }
 else {
      f=Class.forName(classname,true,loader);
    }
  }
 catch (  ClassNotFoundException e) {
    throw new BuildException(""String_Node_Str"" + loader + ""String_Node_Str""+ classname+ ""String_Node_Str""+ e,e);
  }
catch (  NoClassDefFoundError e) {
    throw new BuildException(""String_Node_Str"" + loader + ""String_Node_Str""+ classname+ ""String_Node_Str""+ e,e);
  }
  Object o=null;
  try {
    o=f.newInstance();
  }
 catch (  InstantiationException e) {
    throw new BuildException(e);
  }
catch (  IllegalAccessException e) {
    throw new BuildException(e);
  }
  if (!(o instanceof JUnitTaskMirror.JUnitResultFormatterMirror)) {
    throw new BuildException(classname + ""String_Node_Str"");
  }
  JUnitTaskMirror.JUnitResultFormatterMirror r=(JUnitTaskMirror.JUnitResultFormatterMirror)o;
  if (useFile && outFile != null) {
    try {
      out=new BufferedOutputStream(new FileOutputStream(outFile));
    }
 catch (    java.io.IOException e) {
      throw new BuildException(""String_Node_Str"" + outFile,e);
    }
  }
  r.setOutput(out);
  boolean needToSetProjectReference=true;
  try {
    Field field=r.getClass().getField(""String_Node_Str"");
    Object value=field.get(r);
    if (value instanceof Project) {
      needToSetProjectReference=false;
    }
  }
 catch (  NoSuchFieldException e) {
  }
catch (  IllegalAccessException e) {
    throw new BuildException(e);
  }
  if (needToSetProjectReference) {
    Method setter;
    try {
      setter=r.getClass().getMethod(""String_Node_Str"",new Class[]{Project.class});
      setter.invoke(r,new Object[]{project});
    }
 catch (    NoSuchMethodException e) {
    }
catch (    IllegalAccessException e) {
      throw new BuildException(e);
    }
catch (    InvocationTargetException e) {
      throw new BuildException(e);
    }
  }
  return r;
}",0.9257575757575758
64138,"/** 
 * Creates a new adapter for the given class and a method within the class.
 * @param testClass test class containing the method to be executed
 * @param methodNames names of the test methods that are to be executed
 * @exception java.lang.IllegalArgumentException if any of the arguments is  {@code null}or if any of the given method names is   {@code null} or empty
 */
public JUnit4TestMethodAdapter(final Class testClass,final String[] methodNames){
  if (testClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (methodNames == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int i=0; i < methodNames.length; i++) {
    if (methodNames[i] == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    if (methodNames[i].length() == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
  }
  this.testClass=testClass;
  this.methodNames=methodNames;
  this.cache=Cache.instance;
  Request request;
  if (methodNames.length == 1) {
    request=Request.method(testClass,methodNames[0]);
  }
 else {
    request=Request.aClass(testClass).filterWith(new MultipleMethodsFilter(testClass,methodNames));
  }
  runner=request.getRunner();
}","/** 
 * Creates a new adapter for the given class and a method within the class.
 * @param testClass test class containing the method to be executed
 * @param methodNames names of the test methods that are to be executed
 * @exception java.lang.IllegalArgumentException if any of the arguments is  {@code null}or if any of the given method names is   {@code null} or empty
 */
public JUnit4TestMethodAdapter(final Class testClass,final String[] methodNames){
  if (testClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (methodNames == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int i=0; i < methodNames.length; i++) {
    if (methodNames[i] == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    if (methodNames[i].length() == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
  }
  this.testClass=testClass;
  this.methodNames=(String[])methodNames.clone();
  this.cache=Cache.instance;
  Request request;
  if (methodNames.length == 1) {
    request=Request.method(testClass,methodNames[0]);
  }
 else {
    request=Request.aClass(testClass).filterWith(new MultipleMethodsFilter(testClass,methodNames));
  }
  runner=request.getRunner();
}",0.9846035411855272
64139,"/** 
 * Creates a JUnitTest instance that shares all flags with the passed in instance but has a more meaningful name. <p>If a VM running multiple tests crashes, we don't know which test failed.  Prior to Ant 1.8.0 Ant would log the error with the last test of the batch test, which caused some confusion since the log might look as if a test had been executed last that was never started.  With Ant 1.8.0 the test's name will indicate that something went wrong with a test inside the batch without giving it a real name.</p>
 * @see https://issues.apache.org/bugzilla/show_bug.cgi?id=45227
 */
private static JUnitTest createDummyTestForBatchTest(JUnitTest test){
  JUnitTest t=(JUnitTest)test.clone();
  int index=test.getName().indexOf(""String_Node_Str"");
  String pack=index > 0 ? test.getName().substring(0,index + 1) : ""String_Node_Str"";
  t.setName(pack + NAME_OF_DUMMY_TEST);
  return t;
}","/** 
 * Creates a JUnitTest instance that shares all flags with the passed in instance but has a more meaningful name. <p>If a VM running multiple tests crashes, we don't know which test failed.  Prior to Ant 1.8.0 Ant would log the error with the last test of the batch test, which caused some confusion since the log might look as if a test had been executed last that was never started.  With Ant 1.8.0 the test's name will indicate that something went wrong with a test inside the batch without giving it a real name.</p>
 * @see https://issues.apache.org/bugzilla/show_bug.cgi?id=45227
 */
private static JUnitTest createDummyTestForBatchTest(JUnitTest test){
  JUnitTest t=(JUnitTest)test.clone();
  int index=test.getName().indexOf('.');
  String pack=index > 0 ? test.getName().substring(0,index + 1) : ""String_Node_Str"";
  t.setName(pack + NAME_OF_DUMMY_TEST);
  return t;
}",0.9887640449438202
64140,"/** 
 * Creates a new JUnitRunner and enables fork of a new Java VM.
 * @throws Exception under ??? circumstances
 * @since Ant 1.2
 */
public JUnitTask() throws Exception {
  getCommandline().setClassname(""String_Node_Str"");
}","/** 
 * Creates a new JUnitRunner and enables fork of a new Java VM.
 * @throws Exception under ??? circumstances
 * @since Ant 1.2
 */
public JUnitTask() throws Exception {
}",0.8706467661691543
64141,"/** 
 * Execute a list of tests in a single forked Java VM.
 * @param testList the list of tests to execute.
 * @throws BuildException on error.
 */
protected void execute(List testList) throws BuildException {
  JUnitTest test=null;
  File casesFile=createTempPropertiesFile(""String_Node_Str"");
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(casesFile));
    log(""String_Node_Str"" + casesFile.getAbsolutePath() + ""String_Node_Str"",Project.MSG_VERBOSE);
    PrintStream logWriter=new PrintStream(new LogOutputStream(this,Project.MSG_VERBOSE));
    Iterator iter=testList.iterator();
    while (iter.hasNext()) {
      test=(JUnitTest)iter.next();
      printDual(writer,logWriter,test.getName());
      if (test.getMethods() != null) {
        printDual(writer,logWriter,""String_Node_Str"" + test.getMethodsString().replace(',','+'));
      }
      if (test.getTodir() == null) {
        printDual(writer,logWriter,""String_Node_Str"" + getProject().resolveFile(""String_Node_Str""));
      }
 else {
        printDual(writer,logWriter,""String_Node_Str"" + test.getTodir());
      }
      if (test.getOutfile() == null) {
        printlnDual(writer,logWriter,""String_Node_Str"" + ""String_Node_Str"" + test.getName());
      }
 else {
        printlnDual(writer,logWriter,""String_Node_Str"" + test.getOutfile());
      }
    }
    writer.flush();
    writer.close();
    writer=null;
    ExecuteWatchdog watchdog=createWatchdog();
    TestResultHolder result=executeAsForked(test,watchdog,casesFile);
    actOnTestResult(result,test,""String_Node_Str"");
  }
 catch (  IOException e) {
    log(e.toString(),Project.MSG_ERR);
    throw new BuildException(e);
  }
 finally {
    FILE_UTILS.close(writer);
    try {
      FILE_UTILS.tryHardToDelete(casesFile);
    }
 catch (    Exception e) {
      log(e.toString(),Project.MSG_ERR);
    }
  }
}","/** 
 * Execute a list of tests in a single forked Java VM.
 * @param testList the list of tests to execute.
 * @throws BuildException on error.
 */
protected void execute(List testList) throws BuildException {
  JUnitTest test=null;
  File casesFile=createTempPropertiesFile(""String_Node_Str"");
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(casesFile));
    log(""String_Node_Str"" + casesFile.getAbsolutePath() + ""String_Node_Str"",Project.MSG_VERBOSE);
    PrintStream logWriter=new PrintStream(new LogOutputStream(this,Project.MSG_VERBOSE));
    Iterator iter=testList.iterator();
    while (iter.hasNext()) {
      test=(JUnitTest)iter.next();
      printDual(writer,logWriter,test.getName());
      if (test.getMethods() != null) {
        printDual(writer,logWriter,""String_Node_Str"" + test.getMethodsString().replace(',','+'));
      }
      if (test.getTodir() == null) {
        printDual(writer,logWriter,""String_Node_Str"" + getProject().resolveFile(""String_Node_Str""));
      }
 else {
        printDual(writer,logWriter,""String_Node_Str"" + test.getTodir());
      }
      if (test.getOutfile() == null) {
        printlnDual(writer,logWriter,""String_Node_Str"" + ""String_Node_Str"" + test.getName());
      }
 else {
        printlnDual(writer,logWriter,""String_Node_Str"" + test.getOutfile());
      }
    }
    writer.flush();
    writer.close();
    writer=null;
    ExecuteWatchdog watchdog=createWatchdog();
    TestResultHolder result=executeAsForked(test,watchdog,casesFile);
    actOnTestResult(result,test,""String_Node_Str"");
  }
 catch (  IOException e) {
    log(e.toString(),Project.MSG_ERR);
    throw new BuildException(e);
  }
 finally {
    FileUtils.close(writer);
    try {
      FILE_UTILS.tryHardToDelete(casesFile);
    }
 catch (    Exception e) {
      log(e.toString(),Project.MSG_ERR);
    }
  }
}",0.9777658719528528
64142,"private static String maybeStripJarAndClass(URL u){
  String s=u.toString();
  if (s.startsWith(""String_Node_Str"")) {
    int pling=s.indexOf(""String_Node_Str"");
    s=s.substring(4,pling == -1 ? s.length() : pling);
  }
  return s;
}","private static String maybeStripJarAndClass(URL u){
  String s=u.toString();
  if (s.startsWith(""String_Node_Str"")) {
    int pling=s.indexOf('!');
    s=s.substring(4,pling == -1 ? s.length() : pling);
  }
  return s;
}",0.9559471365638766
64143,"/** 
 * Get the command line used to run the tests.
 * @return the command line.
 * @since Ant 1.6.2
 */
protected CommandlineJava getCommandline(){
  if (commandline == null) {
    commandline=new CommandlineJava();
  }
  return commandline;
}","/** 
 * Get the command line used to run the tests.
 * @return the command line.
 * @since Ant 1.6.2
 */
protected CommandlineJava getCommandline(){
  if (commandline == null) {
    commandline=new CommandlineJava();
    commandline.setClassname(""String_Node_Str"");
  }
  return commandline;
}",0.9087523277467412
64144,"/** 
 * Compares URLs for equality but takes case-sensitivity into account when comparing file URLs and ignores the jar specific part of the URL if present.
 */
private static boolean urlEquals(URL u1,URL u2){
  String url1=maybeStripJarAndClass(u1);
  String url2=maybeStripJarAndClass(u2);
  if (url1.startsWith(""String_Node_Str"") && url2.startsWith(""String_Node_Str"")) {
    return new File(FILE_UTILS.fromURI(url1)).equals(new File(FILE_UTILS.fromURI(url2)));
  }
  return u1.equals(u2);
}","/** 
 * Compares URLs for equality but takes case-sensitivity into account when comparing file URLs and ignores the jar specific part of the URL if present.
 */
private static boolean urlEquals(URL u1,URL u2){
  String url1=maybeStripJarAndClass(u1);
  String url2=maybeStripJarAndClass(u2);
  if (url1.startsWith(""String_Node_Str"") && url2.startsWith(""String_Node_Str"")) {
    return new File(FILE_UTILS.fromURI(url1)).equals(new File(FILE_UTILS.fromURI(url2)));
  }
  return url1.equals(url2);
}",0.995959595959596
64145,"/** 
 * Sets up the delegate that will actually run the tests. <p>Will be invoked implicitly once the delegate is needed.</p>
 * @since Ant 1.7.1
 */
protected void setupJUnitDelegate(){
  ClassLoader myLoader=JUnitTask.class.getClassLoader();
  if (splitJunit) {
    Path path=new Path(getProject());
    path.add(antRuntimeClasses);
    Path extra=getCommandline().getClasspath();
    if (extra != null) {
      path.add(extra);
    }
    mirrorLoader=new SplitClassLoader(myLoader,path,getProject(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  }
 else {
    mirrorLoader=myLoader;
  }
  delegate=createMirror(this,mirrorLoader);
}","/** 
 * Sets up the delegate that will actually run the tests. <p>Will be invoked implicitly once the delegate is needed.</p>
 * @since Ant 1.7.1
 */
protected void setupJUnitDelegate(){
  final ClassLoader myLoader=JUnitTask.class.getClassLoader();
  if (splitJunit) {
    final Path path=new Path(getProject());
    path.add(antRuntimeClasses);
    Path extra=getCommandline().getClasspath();
    if (extra != null) {
      path.add(extra);
    }
    mirrorLoader=(ClassLoader)AccessController.doPrivileged(new PrivilegedAction(){
      public Object run(){
        return new SplitClassLoader(myLoader,path,getProject(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
      }
    }
);
  }
 else {
    mirrorLoader=myLoader;
  }
  delegate=createMirror(this,mirrorLoader);
}",0.9209621993127148
64146,"/** 
 * Execute a testcase by forking a new JVM. The command will block until it finishes. To know if the process was destroyed or not or whether the forked Java VM exited abnormally, use the attributes of the returned holder object.
 * @param test       the testcase to execute.
 * @param watchdog   the watchdog in charge of cancelling the test if itexceeds a certain amount of time. Can be <tt>null</tt>, in this case the test could probably hang forever.
 * @param casesFile list of test cases to execute. Can be <tt>null</tt>,in this case only one test is executed.
 * @return the test results from the JVM itself.
 * @throws BuildException in case of error creating a temporary property file,or if the junit process can not be forked
 */
private TestResultHolder executeAsForked(JUnitTest test,ExecuteWatchdog watchdog,File casesFile) throws BuildException {
  if (perm != null) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  CommandlineJava cmd;
  try {
    cmd=(CommandlineJava)(getCommandline().clone());
  }
 catch (  CloneNotSupportedException e) {
    throw new BuildException(""String_Node_Str"",e,getLocation());
  }
  cmd.setClassname(""String_Node_Str"");
  if (casesFile == null) {
    cmd.createArgument().setValue(test.getName());
    if (test.getMethods() != null) {
      cmd.createArgument().setValue(Constants.METHOD_NAMES + test.getMethodsString());
    }
  }
 else {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    cmd.createArgument().setValue(Constants.TESTSFILE + casesFile);
  }
  cmd.createArgument().setValue(Constants.FILTERTRACE + test.getFiltertrace());
  cmd.createArgument().setValue(Constants.HALT_ON_ERROR + test.getHaltonerror());
  cmd.createArgument().setValue(Constants.HALT_ON_FAILURE + test.getHaltonfailure());
  checkIncludeAntRuntime(cmd);
  checkIncludeSummary(cmd);
  cmd.createArgument().setValue(Constants.SHOWOUTPUT + String.valueOf(showOutput));
  cmd.createArgument().setValue(Constants.OUTPUT_TO_FORMATTERS + String.valueOf(outputToFormatters));
  cmd.createArgument().setValue(Constants.LOG_FAILED_TESTS + String.valueOf(logFailedTests));
  cmd.createArgument().setValue(Constants.LOGTESTLISTENEREVENTS + ""String_Node_Str"");
  StringBuffer formatterArg=new StringBuffer(STRING_BUFFER_SIZE);
  final FormatterElement[] feArray=mergeFormatters(test);
  for (int i=0; i < feArray.length; i++) {
    FormatterElement fe=feArray[i];
    if (fe.shouldUse(this)) {
      formatterArg.append(Constants.FORMATTER);
      formatterArg.append(fe.getClassname());
      File outFile=getOutput(fe,test);
      if (outFile != null) {
        formatterArg.append(""String_Node_Str"");
        formatterArg.append(outFile);
      }
      cmd.createArgument().setValue(formatterArg.toString());
      formatterArg=new StringBuffer();
    }
  }
  File vmWatcher=createTempPropertiesFile(""String_Node_Str"");
  cmd.createArgument().setValue(Constants.CRASHFILE + vmWatcher.getAbsolutePath());
  File propsFile=createTempPropertiesFile(""String_Node_Str"");
  cmd.createArgument().setValue(Constants.PROPSFILE + propsFile.getAbsolutePath());
  Hashtable p=getProject().getProperties();
  Properties props=new Properties();
  for (Enumeration e=p.keys(); e.hasMoreElements(); ) {
    Object key=e.nextElement();
    props.put(key,p.get(key));
  }
  try {
    FileOutputStream outstream=new FileOutputStream(propsFile);
    props.store(outstream,""String_Node_Str"");
    outstream.close();
  }
 catch (  java.io.IOException e) {
    FILE_UTILS.tryHardToDelete(propsFile);
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"",e,getLocation());
  }
  Execute execute=new Execute(new JUnitLogStreamHandler(this,Project.MSG_INFO,Project.MSG_WARN),watchdog);
  execute.setCommandline(cmd.getCommandline());
  execute.setAntRun(getProject());
  if (dir != null) {
    execute.setWorkingDirectory(dir);
  }
  String[] environment=env.getVariables();
  if (environment != null) {
    for (int i=0; i < environment.length; i++) {
      log(""String_Node_Str"" + environment[i],Project.MSG_VERBOSE);
    }
  }
  execute.setNewenvironment(newEnvironment);
  execute.setEnvironment(environment);
  log(cmd.describeCommand(),Project.MSG_VERBOSE);
  checkForkedPath(cmd);
  TestResultHolder result=new TestResultHolder();
  try {
    result.exitCode=execute.execute();
  }
 catch (  IOException e) {
    throw new BuildException(""String_Node_Str"",e,getLocation());
  }
 finally {
    String vmCrashString=""String_Node_Str"";
    BufferedReader br=null;
    try {
      if (vmWatcher.exists()) {
        br=new BufferedReader(new FileReader(vmWatcher));
        vmCrashString=br.readLine();
      }
 else {
        vmCrashString=""String_Node_Str"" + vmWatcher.getAbsolutePath() + ""String_Node_Str""+ ""String_Node_Str"";
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      FileUtils.close(br);
      if (vmWatcher.exists()) {
        FILE_UTILS.tryHardToDelete(vmWatcher);
      }
    }
    boolean crash=(watchdog != null && watchdog.killedProcess()) || !Constants.TERMINATED_SUCCESSFULLY.equals(vmCrashString);
    if (casesFile != null && crash) {
      test=createDummyTestForBatchTest(test);
    }
    if (watchdog != null && watchdog.killedProcess()) {
      result.timedOut=true;
      logTimeout(feArray,test,vmCrashString);
    }
 else     if (crash) {
      result.crashed=true;
      logVmCrash(feArray,test,vmCrashString);
    }
    if (!FILE_UTILS.tryHardToDelete(propsFile)) {
      throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + propsFile.getAbsolutePath() + ""String_Node_Str"");
    }
  }
  return result;
}","/** 
 * Execute a testcase by forking a new JVM. The command will block until it finishes. To know if the process was destroyed or not or whether the forked Java VM exited abnormally, use the attributes of the returned holder object.
 * @param test       the testcase to execute.
 * @param watchdog   the watchdog in charge of cancelling the test if itexceeds a certain amount of time. Can be <tt>null</tt>, in this case the test could probably hang forever.
 * @param casesFile list of test cases to execute. Can be <tt>null</tt>,in this case only one test is executed.
 * @return the test results from the JVM itself.
 * @throws BuildException in case of error creating a temporary property file,or if the junit process can not be forked
 */
private TestResultHolder executeAsForked(JUnitTest test,ExecuteWatchdog watchdog,File casesFile) throws BuildException {
  if (perm != null) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  CommandlineJava cmd;
  try {
    cmd=(CommandlineJava)(getCommandline().clone());
  }
 catch (  CloneNotSupportedException e) {
    throw new BuildException(""String_Node_Str"",e,getLocation());
  }
  if (casesFile == null) {
    cmd.createArgument().setValue(test.getName());
    if (test.getMethods() != null) {
      cmd.createArgument().setValue(Constants.METHOD_NAMES + test.getMethodsString());
    }
  }
 else {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    cmd.createArgument().setValue(Constants.TESTSFILE + casesFile);
  }
  cmd.createArgument().setValue(Constants.FILTERTRACE + test.getFiltertrace());
  cmd.createArgument().setValue(Constants.HALT_ON_ERROR + test.getHaltonerror());
  cmd.createArgument().setValue(Constants.HALT_ON_FAILURE + test.getHaltonfailure());
  checkIncludeAntRuntime(cmd);
  checkIncludeSummary(cmd);
  cmd.createArgument().setValue(Constants.SHOWOUTPUT + String.valueOf(showOutput));
  cmd.createArgument().setValue(Constants.OUTPUT_TO_FORMATTERS + String.valueOf(outputToFormatters));
  cmd.createArgument().setValue(Constants.LOG_FAILED_TESTS + String.valueOf(logFailedTests));
  cmd.createArgument().setValue(Constants.LOGTESTLISTENEREVENTS + ""String_Node_Str"");
  StringBuffer formatterArg=new StringBuffer(STRING_BUFFER_SIZE);
  final FormatterElement[] feArray=mergeFormatters(test);
  for (int i=0; i < feArray.length; i++) {
    FormatterElement fe=feArray[i];
    if (fe.shouldUse(this)) {
      formatterArg.append(Constants.FORMATTER);
      formatterArg.append(fe.getClassname());
      File outFile=getOutput(fe,test);
      if (outFile != null) {
        formatterArg.append(""String_Node_Str"");
        formatterArg.append(outFile);
      }
      cmd.createArgument().setValue(formatterArg.toString());
      formatterArg=new StringBuffer();
    }
  }
  File vmWatcher=createTempPropertiesFile(""String_Node_Str"");
  cmd.createArgument().setValue(Constants.CRASHFILE + vmWatcher.getAbsolutePath());
  File propsFile=createTempPropertiesFile(""String_Node_Str"");
  cmd.createArgument().setValue(Constants.PROPSFILE + propsFile.getAbsolutePath());
  Hashtable p=getProject().getProperties();
  Properties props=new Properties();
  for (Enumeration e=p.keys(); e.hasMoreElements(); ) {
    Object key=e.nextElement();
    props.put(key,p.get(key));
  }
  try {
    FileOutputStream outstream=new FileOutputStream(propsFile);
    props.store(outstream,""String_Node_Str"");
    outstream.close();
  }
 catch (  java.io.IOException e) {
    FILE_UTILS.tryHardToDelete(propsFile);
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"",e,getLocation());
  }
  Execute execute=new Execute(new JUnitLogStreamHandler(this,Project.MSG_INFO,Project.MSG_WARN),watchdog);
  execute.setCommandline(cmd.getCommandline());
  execute.setAntRun(getProject());
  if (dir != null) {
    execute.setWorkingDirectory(dir);
  }
  String[] environment=env.getVariables();
  if (environment != null) {
    for (int i=0; i < environment.length; i++) {
      log(""String_Node_Str"" + environment[i],Project.MSG_VERBOSE);
    }
  }
  execute.setNewenvironment(newEnvironment);
  execute.setEnvironment(environment);
  log(cmd.describeCommand(),Project.MSG_VERBOSE);
  checkForkedPath(cmd);
  TestResultHolder result=new TestResultHolder();
  try {
    result.exitCode=execute.execute();
  }
 catch (  IOException e) {
    throw new BuildException(""String_Node_Str"",e,getLocation());
  }
 finally {
    String vmCrashString=""String_Node_Str"";
    BufferedReader br=null;
    try {
      if (vmWatcher.exists()) {
        br=new BufferedReader(new FileReader(vmWatcher));
        vmCrashString=br.readLine();
      }
 else {
        vmCrashString=""String_Node_Str"" + vmWatcher.getAbsolutePath() + ""String_Node_Str""+ ""String_Node_Str"";
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      FileUtils.close(br);
      if (vmWatcher.exists()) {
        FILE_UTILS.tryHardToDelete(vmWatcher);
      }
    }
    boolean crash=(watchdog != null && watchdog.killedProcess()) || !Constants.TERMINATED_SUCCESSFULLY.equals(vmCrashString);
    if (casesFile != null && crash) {
      test=createDummyTestForBatchTest(test);
    }
    if (watchdog != null && watchdog.killedProcess()) {
      result.timedOut=true;
      logTimeout(feArray,test,vmCrashString);
    }
 else     if (crash) {
      result.crashed=true;
      logVmCrash(feArray,test,vmCrashString);
    }
    if (!FILE_UTILS.tryHardToDelete(propsFile)) {
      throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + propsFile.getAbsolutePath() + ""String_Node_Str"");
    }
  }
  return result;
}",0.996508817473816
64147,"/** 
 * Constructor with options.
 * @param name the name of the test.
 * @param haltOnError if true halt the tests if there is an error.
 * @param haltOnFailure if true halt the tests if there is a failure.
 * @param filtertrace if true filter stack traces.
 * @param methods if true run only test methods that failed during theprevious run of the test suite
 * @since 1.8.2
 */
public JUnitTest(String name,boolean haltOnError,boolean haltOnFailure,boolean filtertrace,String[] methods){
  this.name=name;
  this.haltOnError=haltOnError;
  this.haltOnFail=haltOnFailure;
  this.filtertrace=filtertrace;
  this.methods=methods;
  this.methodsSpecified=(methods != null);
}","/** 
 * Constructor with options.
 * @param name the name of the test.
 * @param haltOnError if true halt the tests if there is an error.
 * @param haltOnFailure if true halt the tests if there is a failure.
 * @param filtertrace if true filter stack traces.
 * @param methods if non-null run only these test methods
 * @since 1.8.2
 */
public JUnitTest(String name,boolean haltOnError,boolean haltOnFailure,boolean filtertrace,String[] methods){
  this.name=name;
  this.haltOnError=haltOnError;
  this.haltOnFail=haltOnFailure;
  this.filtertrace=filtertrace;
  this.methodsSpecified=methods != null;
  this.methods=methodsSpecified ? (String[])methods.clone() : null;
}",0.8490706319702602
64148,"/** 
 * Parses a comma-separated list of method names and check their validity.
 * @param methodNames comma-separated list of method names to be parsed
 * @return array of individual test method names
 * @exception java.lang.IllegalArgumentException if the given string is <code>null</code> or if it is not a comma-separated list of valid Java identifiers; an empty string is acceptable and is handled as an empty list
 * @since 1.8.2
 */
public static String[] parseTestMethodNamesList(String methodNames) throws IllegalArgumentException {
  if (methodNames == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  methodNames=methodNames.trim();
  int length=methodNames.length();
  if (length == 0) {
    return new String[0];
  }
  if (methodNames.charAt(length - 1) == ',') {
    methodNames=methodNames.substring(0,length - 1).trim();
    length=methodNames.length();
    if (length == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  final char[] chars=methodNames.toCharArray();
  if (chars[0] == ',') {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int wordCount=1;
  for (int i=1; i < chars.length; i++) {
    if (chars[i] == ',') {
      wordCount++;
    }
  }
  String[] result=new String[wordCount];
  final int stateBeforeWord=1;
  final int stateInsideWord=2;
  final int stateAfterWord=3;
  int state=stateBeforeWord;
  int wordStartIndex=-1;
  int wordIndex=0;
  for (int i=0; i < chars.length; i++) {
    char c=chars[i];
switch (state) {
case stateBeforeWord:
      if (c == ',') {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else       if (c == ' ') {
      }
 else       if (Character.isJavaIdentifierStart(c)) {
        wordStartIndex=i;
        state=stateInsideWord;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + c);
      }
    break;
case stateInsideWord:
  if (c == ',') {
    result[wordIndex++]=new String(methodNames.substring(wordStartIndex,i));
    state=stateBeforeWord;
  }
 else   if (c == ' ') {
    result[wordIndex++]=new String(methodNames.substring(wordStartIndex,i));
    state=stateAfterWord;
  }
 else   if (Character.isJavaIdentifierPart(c)) {
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + c);
  }
break;
case stateAfterWord:
if (c == ',') {
state=stateBeforeWord;
}
 else if (c == ' ') {
}
 else {
throw new IllegalArgumentException(""String_Node_Str"");
}
break;
default :
}
}
switch (state) {
case stateBeforeWord:
case stateAfterWord:
break;
case stateInsideWord:
result[wordIndex++]=new String(methodNames.substring(wordStartIndex,chars.length));
break;
default :
}
return result;
}","/** 
 * Parses a comma-separated list of method names and check their validity.
 * @param methodNames comma-separated list of method names to be parsed
 * @return array of individual test method names
 * @exception java.lang.IllegalArgumentException if the given string is <code>null</code> or if it is not a comma-separated list of valid Java identifiers; an empty string is acceptable and is handled as an empty list
 * @since 1.8.2
 */
public static String[] parseTestMethodNamesList(String methodNames) throws IllegalArgumentException {
  if (methodNames == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  methodNames=methodNames.trim();
  int length=methodNames.length();
  if (length == 0) {
    return new String[0];
  }
  if (methodNames.charAt(length - 1) == ',') {
    methodNames=methodNames.substring(0,length - 1).trim();
    length=methodNames.length();
    if (length == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  final char[] chars=methodNames.toCharArray();
  if (chars[0] == ',') {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int wordCount=1;
  for (int i=1; i < chars.length; i++) {
    if (chars[i] == ',') {
      wordCount++;
    }
  }
  String[] result=new String[wordCount];
  final int stateBeforeWord=1;
  final int stateInsideWord=2;
  final int stateAfterWord=3;
  int state=stateBeforeWord;
  int wordStartIndex=-1;
  int wordIndex=0;
  for (int i=0; i < chars.length; i++) {
    char c=chars[i];
switch (state) {
case stateBeforeWord:
      if (c == ',') {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
 else       if (c == ' ') {
      }
 else       if (Character.isJavaIdentifierStart(c)) {
        wordStartIndex=i;
        state=stateInsideWord;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + c);
      }
    break;
case stateInsideWord:
  if (c == ',') {
    result[wordIndex++]=methodNames.substring(wordStartIndex,i);
    state=stateBeforeWord;
  }
 else   if (c == ' ') {
    result[wordIndex++]=methodNames.substring(wordStartIndex,i);
    state=stateAfterWord;
  }
 else   if (Character.isJavaIdentifierPart(c)) {
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + c);
  }
break;
case stateAfterWord:
if (c == ',') {
state=stateBeforeWord;
}
 else if (c == ' ') {
}
 else {
throw new IllegalArgumentException(""String_Node_Str"");
}
break;
default :
}
}
switch (state) {
case stateBeforeWord:
case stateAfterWord:
break;
case stateInsideWord:
result[wordIndex++]=methodNames.substring(wordStartIndex,chars.length);
break;
default :
}
return result;
}",0.9932432432432432
64149,"/** 
 * Constructor to use when the user has specified a classpath.
 * @since 1.8.2
 */
public JUnitTestRunner(JUnitTest test,String[] methods,boolean haltOnError,boolean filtertrace,boolean haltOnFailure,boolean showOutput,boolean logTestListenerEvents,ClassLoader loader){
  JUnitTestRunner.filtertrace=filtertrace;
  this.junitTest=test;
  this.haltOnError=haltOnError;
  this.haltOnFailure=haltOnFailure;
  this.showOutput=showOutput;
  this.logTestListenerEvents=logTestListenerEvents;
  this.methods=methods;
  this.loader=loader;
}","/** 
 * Constructor to use when the user has specified a classpath.
 * @since 1.8.2
 */
public JUnitTestRunner(JUnitTest test,String[] methods,boolean haltOnError,boolean filtertrace,boolean haltOnFailure,boolean showOutput,boolean logTestListenerEvents,ClassLoader loader){
  JUnitTestRunner.filtertrace=filtertrace;
  this.junitTest=test;
  this.haltOnError=haltOnError;
  this.haltOnFailure=haltOnFailure;
  this.showOutput=showOutput;
  this.logTestListenerEvents=logTestListenerEvents;
  this.methods=methods != null ? (String[])methods.clone() : null;
  this.loader=loader;
}",0.961572832886506
64150,"/** 
 * Executes the task.
 * @exception BuildException if there is an execution problem.
 * @todo validate that if either in or our is defined, then both are
 */
public void execute() throws BuildException {
  if (""String_Node_Str"".equals(getTaskType())) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  File savedBaseDir=baseDir;
  DirectoryScanner scanner;
  String[] list;
  String[] dirs;
  String baseMessage=""String_Node_Str"" + ""String_Node_Str"";
  if (xslResource == null && xslFile == null) {
    handleError(baseMessage);
    return;
  }
  if (xslResource != null && xslFile != null) {
    handleError(baseMessage + ""String_Node_Str"");
    return;
  }
  if (inFile != null && !inFile.exists()) {
    handleError(""String_Node_Str"" + inFile + ""String_Node_Str"");
    return;
  }
  try {
    if (sysProperties.size() > 0) {
      sysProperties.setSystem();
    }
    Resource styleResource;
    if (baseDir == null) {
      baseDir=getProject().getBaseDir();
    }
    liaison=getLiaison();
    if (liaison instanceof XSLTLoggerAware) {
      ((XSLTLoggerAware)liaison).setLogger(this);
    }
    log(""String_Node_Str"" + liaison.getClass().toString(),Project.MSG_VERBOSE);
    if (xslFile != null) {
      File stylesheet=getProject().resolveFile(xslFile);
      if (!stylesheet.exists()) {
        stylesheet=FILE_UTILS.resolveFile(baseDir,xslFile);
        if (stylesheet.exists()) {
          log(""String_Node_Str"" + ""String_Node_Str"");
          log(""String_Node_Str"");
        }
      }
      FileResource fr=new FileResource();
      fr.setProject(getProject());
      fr.setFile(stylesheet);
      styleResource=fr;
    }
 else {
      styleResource=xslResource;
    }
    if (!styleResource.isExists()) {
      handleError(""String_Node_Str"" + styleResource + ""String_Node_Str"");
      return;
    }
    if (inFile != null && outFile != null) {
      process(inFile,outFile,styleResource);
      return;
    }
    checkDest();
    if (useImplicitFileset) {
      scanner=getDirectoryScanner(baseDir);
      log(""String_Node_Str"" + destDir,Project.MSG_INFO);
      list=scanner.getIncludedFiles();
      for (int i=0; i < list.length; ++i) {
        process(baseDir,list[i],destDir,styleResource);
      }
      if (performDirectoryScan) {
        dirs=scanner.getIncludedDirectories();
        for (int j=0; j < dirs.length; ++j) {
          list=new File(baseDir,dirs[j]).list();
          for (int i=0; i < list.length; ++i) {
            process(baseDir,dirs[j] + File.separator + list[i],destDir,styleResource);
          }
        }
      }
    }
 else {
      if (resources.size() == 0) {
        if (failOnNoResources) {
          handleError(""String_Node_Str"");
        }
        return;
      }
    }
    processResources(styleResource);
  }
  finally {
    if (loader != null) {
      loader.resetThreadContextLoader();
      loader.cleanup();
      loader=null;
    }
    if (sysProperties.size() > 0) {
      sysProperties.restoreSystem();
    }
    liaison=null;
    stylesheetLoaded=false;
    baseDir=savedBaseDir;
  }
}","/** 
 * Executes the task.
 * @exception BuildException if there is an execution problem.
 * @todo validate that if either in or our is defined, then both are
 */
public void execute() throws BuildException {
  if (""String_Node_Str"".equals(getTaskType())) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  File savedBaseDir=baseDir;
  DirectoryScanner scanner;
  String[] list;
  String[] dirs;
  String baseMessage=""String_Node_Str"" + ""String_Node_Str"";
  if (xslResource == null && xslFile == null) {
    handleError(baseMessage);
    return;
  }
  if (xslResource != null && xslFile != null) {
    handleError(baseMessage + ""String_Node_Str"");
    return;
  }
  if (inFile != null && !inFile.exists()) {
    handleError(""String_Node_Str"" + inFile + ""String_Node_Str"");
    return;
  }
  try {
    setupLoader();
    if (sysProperties.size() > 0) {
      sysProperties.setSystem();
    }
    Resource styleResource;
    if (baseDir == null) {
      baseDir=getProject().getBaseDir();
    }
    liaison=getLiaison();
    if (liaison instanceof XSLTLoggerAware) {
      ((XSLTLoggerAware)liaison).setLogger(this);
    }
    log(""String_Node_Str"" + liaison.getClass().toString(),Project.MSG_VERBOSE);
    if (xslFile != null) {
      File stylesheet=getProject().resolveFile(xslFile);
      if (!stylesheet.exists()) {
        stylesheet=FILE_UTILS.resolveFile(baseDir,xslFile);
        if (stylesheet.exists()) {
          log(""String_Node_Str"" + ""String_Node_Str"");
          log(""String_Node_Str"");
        }
      }
      FileResource fr=new FileResource();
      fr.setProject(getProject());
      fr.setFile(stylesheet);
      styleResource=fr;
    }
 else {
      styleResource=xslResource;
    }
    if (!styleResource.isExists()) {
      handleError(""String_Node_Str"" + styleResource + ""String_Node_Str"");
      return;
    }
    if (inFile != null && outFile != null) {
      process(inFile,outFile,styleResource);
      return;
    }
    checkDest();
    if (useImplicitFileset) {
      scanner=getDirectoryScanner(baseDir);
      log(""String_Node_Str"" + destDir,Project.MSG_INFO);
      list=scanner.getIncludedFiles();
      for (int i=0; i < list.length; ++i) {
        process(baseDir,list[i],destDir,styleResource);
      }
      if (performDirectoryScan) {
        dirs=scanner.getIncludedDirectories();
        for (int j=0; j < dirs.length; ++j) {
          list=new File(baseDir,dirs[j]).list();
          for (int i=0; i < list.length; ++i) {
            process(baseDir,dirs[j] + File.separator + list[i],destDir,styleResource);
          }
        }
      }
    }
 else {
      if (resources.size() == 0) {
        if (failOnNoResources) {
          handleError(""String_Node_Str"");
        }
        return;
      }
    }
    processResources(styleResource);
  }
  finally {
    if (loader != null) {
      loader.resetThreadContextLoader();
      loader.cleanup();
      loader=null;
    }
    if (sysProperties.size() > 0) {
      sysProperties.restoreSystem();
    }
    liaison=null;
    stylesheetLoaded=false;
    baseDir=savedBaseDir;
  }
}",0.9968979591836736
64151,"/** 
 * Load named class either via the system classloader or a given custom classloader. As a side effect, the loader is set as the thread context classloader
 * @param classname the name of the class to load.
 * @return the requested class.
 * @exception Exception if the class could not be loaded.
 */
private Class loadClass(String classname) throws Exception {
  if (classpath == null) {
    return Class.forName(classname);
  }
  loader=getProject().createClassLoader(classpath);
  loader.setThreadContextLoader();
  return Class.forName(classname,true,loader);
}","/** 
 * Load named class either via the system classloader or a given custom classloader. As a side effect, the loader is set as the thread context classloader
 * @param classname the name of the class to load.
 * @return the requested class.
 * @exception Exception if the class could not be loaded.
 */
private Class loadClass(String classname) throws Exception {
  setupLoader();
  if (loader == null) {
    return Class.forName(classname);
  }
  return Class.forName(classname,true,loader);
}",0.7774647887323943
64152,"/** 
 * Load processor here instead of in setProcessor - this will be called from within execute, so we have access to the latest classpath.
 * @param proc the name of the processor to load.
 * @exception Exception if the processor cannot be loaded.
 */
private void resolveProcessor(String proc) throws Exception {
  String classname;
  if (proc.equals(PROCESSOR_TRAX)) {
    classname=TRAX_LIAISON_CLASS;
  }
 else {
    classname=proc;
  }
  Class clazz=loadClass(classname);
  liaison=(XSLTLiaison)clazz.newInstance();
}","/** 
 * Load processor here instead of in setProcessor - this will be called from within execute, so we have access to the latest classpath.
 * @param proc the name of the processor to load.
 * @exception Exception if the processor cannot be loaded.
 */
private void resolveProcessor(String proc) throws Exception {
  String classname;
  if (proc.equals(PROCESSOR_TRAX)) {
    liaison=new org.apache.tools.ant.taskdefs.optional.TraXLiaison();
  }
 else {
    Class clazz=loadClass(proc);
    liaison=(XSLTLiaison)clazz.newInstance();
  }
}",0.8824082784571966
64153,"/** 
 * Convenience method to copy content from one Resource to another specifying whether token filtering must be used, whether filter chains must be used, whether newer destination files may be overwritten and whether the last modified time of <code>dest</code> file should be made equal to the last modified time of <code>source</code>.
 * @param source the Resource to copy from.Must not be <code>null</code>.
 * @param dest   the Resource to copy to.Must not be <code>null</code>.
 * @param filters the collection of filters to apply to this copy.
 * @param filterChains filterChains to apply during the copy.
 * @param overwrite Whether or not the destination Resource should beoverwritten if it already exists.
 * @param preserveLastModified Whether or not the last modified time ofthe destination Resource should be set to that of the source.
 * @param append Whether to append to an Appendable Resource.
 * @param inputEncoding the encoding used to read the files.
 * @param outputEncoding the encoding used to write the files.
 * @param project the project instance.
 * @param force whether read-only taret files will be overwritten
 * @throws IOException if the copying fails.
 * @since Ant 1.8.2
 */
public static void copyResource(Resource source,Resource dest,FilterSetCollection filters,Vector filterChains,boolean overwrite,boolean preserveLastModified,boolean append,String inputEncoding,String outputEncoding,Project project,boolean force) throws IOException {
  if (!(overwrite || SelectorUtils.isOutOfDate(source,dest,FileUtils.getFileUtils().getFileTimestampGranularity()))) {
    return;
  }
  final boolean filterSetsAvailable=(filters != null && filters.hasFilters());
  final boolean filterChainsAvailable=(filterChains != null && filterChains.size() > 0);
  File destFile=null;
  if (dest.as(FileProvider.class) != null) {
    destFile=((FileProvider)dest.as(FileProvider.class)).getFile();
  }
  if (destFile != null && destFile.isFile() && !destFile.canWrite()) {
    if (!force) {
      throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + destFile);
    }
 else     if (!FILE_UTILS.tryHardToDelete(destFile)) {
      throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + destFile);
    }
  }
  if (filterSetsAvailable) {
    BufferedReader in=null;
    BufferedWriter out=null;
    try {
      InputStreamReader isr=null;
      if (inputEncoding == null) {
        isr=new InputStreamReader(source.getInputStream());
      }
 else {
        isr=new InputStreamReader(source.getInputStream(),inputEncoding);
      }
      in=new BufferedReader(isr);
      OutputStream os=getOutputStream(dest,append,project);
      OutputStreamWriter osw;
      if (outputEncoding == null) {
        osw=new OutputStreamWriter(os);
      }
 else {
        osw=new OutputStreamWriter(os,outputEncoding);
      }
      out=new BufferedWriter(osw);
      if (filterChainsAvailable) {
        ChainReaderHelper crh=new ChainReaderHelper();
        crh.setBufferSize(FileUtils.BUF_SIZE);
        crh.setPrimaryReader(in);
        crh.setFilterChains(filterChains);
        crh.setProject(project);
        Reader rdr=crh.getAssembledReader();
        in=new BufferedReader(rdr);
      }
      LineTokenizer lineTokenizer=new LineTokenizer();
      lineTokenizer.setIncludeDelims(true);
      String newline=null;
      String line=lineTokenizer.getToken(in);
      while (line != null) {
        if (line.length() == 0) {
          out.newLine();
        }
 else {
          newline=filters.replaceTokens(line);
          out.write(newline);
        }
        line=lineTokenizer.getToken(in);
      }
    }
  finally {
      FileUtils.close(out);
      FileUtils.close(in);
    }
  }
 else   if (filterChainsAvailable || (inputEncoding != null && !inputEncoding.equals(outputEncoding)) || (inputEncoding == null && outputEncoding != null)) {
    BufferedReader in=null;
    BufferedWriter out=null;
    try {
      InputStreamReader isr=null;
      if (inputEncoding == null) {
        isr=new InputStreamReader(source.getInputStream());
      }
 else {
        isr=new InputStreamReader(source.getInputStream(),inputEncoding);
      }
      in=new BufferedReader(isr);
      OutputStream os=getOutputStream(dest,append,project);
      OutputStreamWriter osw;
      if (outputEncoding == null) {
        osw=new OutputStreamWriter(os);
      }
 else {
        osw=new OutputStreamWriter(os,outputEncoding);
      }
      out=new BufferedWriter(osw);
      if (filterChainsAvailable) {
        ChainReaderHelper crh=new ChainReaderHelper();
        crh.setBufferSize(FileUtils.BUF_SIZE);
        crh.setPrimaryReader(in);
        crh.setFilterChains(filterChains);
        crh.setProject(project);
        Reader rdr=crh.getAssembledReader();
        in=new BufferedReader(rdr);
      }
      char[] buffer=new char[FileUtils.BUF_SIZE];
      while (true) {
        int nRead=in.read(buffer,0,buffer.length);
        if (nRead == -1) {
          break;
        }
        out.write(buffer,0,nRead);
      }
    }
  finally {
      FileUtils.close(out);
      FileUtils.close(in);
    }
  }
 else   if (source.as(FileProvider.class) != null && destFile != null) {
    File sourceFile=((FileProvider)source.as(FileProvider.class)).getFile();
    File parent=destFile.getParentFile();
    if (parent != null && !parent.isDirectory() && !destFile.getParentFile().mkdirs()) {
      throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + destFile);
    }
    FileInputStream in=null;
    FileOutputStream out=null;
    FileChannel srcChannel=null;
    FileChannel destChannel=null;
    try {
      in=new FileInputStream(sourceFile);
      out=new FileOutputStream(destFile);
      srcChannel=in.getChannel();
      destChannel=out.getChannel();
      long position=0;
      long count=srcChannel.size();
      while (position < count) {
        long chunck=Math.min(MAX_IO_CHUNCK_SIZE,count - position);
        position+=srcChannel.transferTo(position,chunck,destChannel);
      }
    }
  finally {
      FileUtils.close(srcChannel);
      FileUtils.close(destChannel);
      FileUtils.close(out);
      FileUtils.close(in);
    }
  }
 else {
    InputStream in=null;
    OutputStream out=null;
    try {
      in=source.getInputStream();
      out=getOutputStream(dest,append,project);
      byte[] buffer=new byte[FileUtils.BUF_SIZE];
      int count=0;
      do {
        out.write(buffer,0,count);
        count=in.read(buffer,0,buffer.length);
      }
 while (count != -1);
    }
  finally {
      FileUtils.close(out);
      FileUtils.close(in);
    }
  }
  if (preserveLastModified) {
    Touchable t=(Touchable)dest.as(Touchable.class);
    if (t != null) {
      setLastModified(t,source.getLastModified());
    }
  }
}","/** 
 * Convenience method to copy content from one Resource to another specifying whether token filtering must be used, whether filter chains must be used, whether newer destination files may be overwritten and whether the last modified time of <code>dest</code> file should be made equal to the last modified time of <code>source</code>.
 * @param source the Resource to copy from.Must not be <code>null</code>.
 * @param dest   the Resource to copy to.Must not be <code>null</code>.
 * @param filters the collection of filters to apply to this copy.
 * @param filterChains filterChains to apply during the copy.
 * @param overwrite Whether or not the destination Resource should beoverwritten if it already exists.
 * @param preserveLastModified Whether or not the last modified time ofthe destination Resource should be set to that of the source.
 * @param append Whether to append to an Appendable Resource.
 * @param inputEncoding the encoding used to read the files.
 * @param outputEncoding the encoding used to write the files.
 * @param project the project instance.
 * @param force whether read-only taret files will be overwritten
 * @throws IOException if the copying fails.
 * @since Ant 1.8.2
 */
public static void copyResource(Resource source,Resource dest,FilterSetCollection filters,Vector filterChains,boolean overwrite,boolean preserveLastModified,boolean append,String inputEncoding,String outputEncoding,Project project,boolean force) throws IOException {
  if (!(overwrite || SelectorUtils.isOutOfDate(source,dest,FileUtils.getFileUtils().getFileTimestampGranularity()))) {
    return;
  }
  final boolean filterSetsAvailable=(filters != null && filters.hasFilters());
  final boolean filterChainsAvailable=(filterChains != null && filterChains.size() > 0);
  File destFile=null;
  if (dest.as(FileProvider.class) != null) {
    destFile=((FileProvider)dest.as(FileProvider.class)).getFile();
  }
  if (destFile != null && destFile.isFile() && !destFile.canWrite()) {
    if (!force) {
      throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + destFile);
    }
 else     if (!FILE_UTILS.tryHardToDelete(destFile)) {
      throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + destFile);
    }
  }
  if (filterSetsAvailable) {
    BufferedReader in=null;
    BufferedWriter out=null;
    try {
      InputStreamReader isr=null;
      if (inputEncoding == null) {
        isr=new InputStreamReader(source.getInputStream());
      }
 else {
        isr=new InputStreamReader(source.getInputStream(),inputEncoding);
      }
      in=new BufferedReader(isr);
      OutputStream os=getOutputStream(dest,append,project);
      OutputStreamWriter osw;
      if (outputEncoding == null) {
        osw=new OutputStreamWriter(os);
      }
 else {
        osw=new OutputStreamWriter(os,outputEncoding);
      }
      out=new BufferedWriter(osw);
      if (filterChainsAvailable) {
        ChainReaderHelper crh=new ChainReaderHelper();
        crh.setBufferSize(FileUtils.BUF_SIZE);
        crh.setPrimaryReader(in);
        crh.setFilterChains(filterChains);
        crh.setProject(project);
        Reader rdr=crh.getAssembledReader();
        in=new BufferedReader(rdr);
      }
      LineTokenizer lineTokenizer=new LineTokenizer();
      lineTokenizer.setIncludeDelims(true);
      String newline=null;
      String line=lineTokenizer.getToken(in);
      while (line != null) {
        if (line.length() == 0) {
          out.newLine();
        }
 else {
          newline=filters.replaceTokens(line);
          out.write(newline);
        }
        line=lineTokenizer.getToken(in);
      }
    }
  finally {
      FileUtils.close(out);
      FileUtils.close(in);
    }
  }
 else   if (filterChainsAvailable || (inputEncoding != null && !inputEncoding.equals(outputEncoding)) || (inputEncoding == null && outputEncoding != null)) {
    BufferedReader in=null;
    BufferedWriter out=null;
    try {
      InputStreamReader isr=null;
      if (inputEncoding == null) {
        isr=new InputStreamReader(source.getInputStream());
      }
 else {
        isr=new InputStreamReader(source.getInputStream(),inputEncoding);
      }
      in=new BufferedReader(isr);
      OutputStream os=getOutputStream(dest,append,project);
      OutputStreamWriter osw;
      if (outputEncoding == null) {
        osw=new OutputStreamWriter(os);
      }
 else {
        osw=new OutputStreamWriter(os,outputEncoding);
      }
      out=new BufferedWriter(osw);
      if (filterChainsAvailable) {
        ChainReaderHelper crh=new ChainReaderHelper();
        crh.setBufferSize(FileUtils.BUF_SIZE);
        crh.setPrimaryReader(in);
        crh.setFilterChains(filterChains);
        crh.setProject(project);
        Reader rdr=crh.getAssembledReader();
        in=new BufferedReader(rdr);
      }
      char[] buffer=new char[FileUtils.BUF_SIZE];
      while (true) {
        int nRead=in.read(buffer,0,buffer.length);
        if (nRead == -1) {
          break;
        }
        out.write(buffer,0,nRead);
      }
    }
  finally {
      FileUtils.close(out);
      FileUtils.close(in);
    }
  }
 else   if (source.as(FileProvider.class) != null && destFile != null) {
    File sourceFile=((FileProvider)source.as(FileProvider.class)).getFile();
    File parent=destFile.getParentFile();
    if (parent != null && !parent.isDirectory() && !destFile.getParentFile().mkdirs()) {
      throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + destFile);
    }
    FileInputStream in=null;
    FileOutputStream out=null;
    FileChannel srcChannel=null;
    FileChannel destChannel=null;
    try {
      in=new FileInputStream(sourceFile);
      out=new FileOutputStream(destFile);
      srcChannel=in.getChannel();
      destChannel=out.getChannel();
      long position=0;
      long count=srcChannel.size();
      while (position < count) {
        long chunk=Math.min(MAX_IO_CHUNCK_SIZE,count - position);
        position+=srcChannel.transferTo(position,chunk,destChannel);
      }
    }
  finally {
      FileUtils.close(srcChannel);
      FileUtils.close(destChannel);
      FileUtils.close(out);
      FileUtils.close(in);
    }
  }
 else {
    InputStream in=null;
    OutputStream out=null;
    try {
      in=source.getInputStream();
      out=getOutputStream(dest,append,project);
      byte[] buffer=new byte[FileUtils.BUF_SIZE];
      int count=0;
      do {
        out.write(buffer,0,count);
        count=in.read(buffer,0,buffer.length);
      }
 while (count != -1);
    }
  finally {
      FileUtils.close(out);
      FileUtils.close(in);
    }
  }
  if (preserveLastModified) {
    Touchable t=(Touchable)dest.as(Touchable.class);
    if (t != null) {
      setLastModified(t,source.getLastModified());
    }
  }
}",0.9998519176662224
64154,"private URLConnection openConnection(URL aSource) throws IOException {
  URLConnection connection=aSource.openConnection();
  if (hasTimestamp) {
    connection.setIfModifiedSince(timestamp);
  }
  if (uname != null || pword != null) {
    String up=uname + ""String_Node_Str"" + pword;
    String encoding;
    Base64Converter encoder=new Base64Converter();
    encoding=encoder.encode(up.getBytes());
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + encoding);
  }
  if (connection instanceof HttpURLConnection) {
    ((HttpURLConnection)connection).setInstanceFollowRedirects(false);
    ((HttpURLConnection)connection).setUseCaches(httpUseCaches);
  }
  try {
    connection.connect();
  }
 catch (  NullPointerException e) {
    throw new BuildException(""String_Node_Str"" + source.toString(),e);
  }
  if (connection instanceof HttpURLConnection) {
    HttpURLConnection httpConnection=(HttpURLConnection)connection;
    int responseCode=httpConnection.getResponseCode();
    if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) {
      String newLocation=httpConnection.getHeaderField(""String_Node_Str"");
      String message=aSource + (responseCode == HttpURLConnection.HTTP_MOVED_PERM ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ newLocation;
      log(message,logLevel);
      URL newURL=new URL(newLocation);
      if (!redirectionAllowed(aSource,newURL)) {
        return null;
      }
      return openConnection(newURL);
    }
    long lastModified=httpConnection.getLastModified();
    if (responseCode == HttpURLConnection.HTTP_NOT_MODIFIED || (lastModified != 0 && hasTimestamp && timestamp >= lastModified)) {
      log(""String_Node_Str"",logLevel);
      return null;
    }
    if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
      String message=""String_Node_Str"";
      if (ignoreErrors) {
        log(message,logLevel);
        return null;
      }
 else {
        throw new BuildException(message);
      }
    }
  }
  return connection;
}","private URLConnection openConnection(URL aSource) throws IOException {
  URLConnection connection=aSource.openConnection();
  if (hasTimestamp) {
    connection.setIfModifiedSince(timestamp);
  }
  if (uname != null || pword != null) {
    String up=uname + ""String_Node_Str"" + pword;
    String encoding;
    Base64Converter encoder=new Base64Converter();
    encoding=encoder.encode(up.getBytes());
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + encoding);
  }
  if (connection instanceof HttpURLConnection) {
    ((HttpURLConnection)connection).setInstanceFollowRedirects(false);
    ((HttpURLConnection)connection).setUseCaches(httpUseCaches);
  }
  try {
    connection.connect();
  }
 catch (  NullPointerException e) {
    throw new BuildException(""String_Node_Str"" + source.toString(),e);
  }
  if (connection instanceof HttpURLConnection) {
    HttpURLConnection httpConnection=(HttpURLConnection)connection;
    int responseCode=httpConnection.getResponseCode();
    if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) {
      String newLocation=httpConnection.getHeaderField(""String_Node_Str"");
      String message=aSource + (responseCode == HttpURLConnection.HTTP_MOVED_PERM ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ newLocation;
      log(message,logLevel);
      URL newURL=new URL(aSource,newLocation);
      if (!redirectionAllowed(aSource,newURL)) {
        return null;
      }
      return openConnection(newURL);
    }
    long lastModified=httpConnection.getLastModified();
    if (responseCode == HttpURLConnection.HTTP_NOT_MODIFIED || (lastModified != 0 && hasTimestamp && timestamp >= lastModified)) {
      log(""String_Node_Str"",logLevel);
      return null;
    }
    if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
      String message=""String_Node_Str"";
      if (ignoreErrors) {
        log(message,logLevel);
        return null;
      }
 else {
        throw new BuildException(message);
      }
    }
  }
  return connection;
}",0.9981132075471698
64155,"/** 
 * Run the functional test sequence. <p/> This is a fairly complex workflow -what is going on is that we try to clean up no matter how the run ended, and to retain the innermost exception that got thrown during cleanup. That is, if teardown fails after the tests themselves failed, it is the test failing that is more important.
 * @throws BuildException if something was caught during the run or teardown.
 */
public void execute() throws BuildException {
  if (condition != null && !condition.eval()) {
    log(SKIPPING_TESTS);
    return;
  }
  long timeoutMillis=timeout * timeoutUnitMultiplier;
  Parallel applicationRun=newParallel(timeoutMillis);
  WorkerAnt worker=new WorkerAnt(applicationRun,null);
  if (application != null) {
    applicationRun.addTask(application);
  }
  long testRunTimeout=0;
  Sequential testRun=new Sequential();
  bind(testRun);
  if (block != null) {
    testRun.addTask(new TaskAdapter(block));
    testRunTimeout=block.calculateMaxWaitMillis();
  }
  if (tests != null) {
    testRun.addTask(tests);
    testRunTimeout+=timeoutMillis;
  }
  if (reporting != null) {
    testRun.addTask(reporting);
    testRunTimeout+=timeoutMillis;
  }
  timedTests=newParallel(testRunTimeout,testRun);
  try {
    if (setup != null) {
      Parallel setupRun=newParallel(timeoutMillis,setup);
      setupRun.execute();
    }
    worker.start();
    timedTests.execute();
  }
 catch (  BuildException e) {
    testException=e;
  }
 finally {
    if (teardown != null) {
      try {
        Parallel teardownRun=newParallel(timeoutMillis,teardown);
        teardownRun.execute();
      }
 catch (      BuildException e) {
        teardownException=e;
      }
    }
  }
  try {
    long shutdownTimeMillis=shutdownTime * shutdownUnitMultiplier;
    worker.waitUntilFinished(shutdownTimeMillis);
    if (worker.isAlive()) {
      log(APPLICATION_FORCIBLY_SHUT_DOWN,Project.MSG_WARN);
      worker.interrupt();
      worker.waitUntilFinished(shutdownTimeMillis);
    }
  }
 catch (  InterruptedException e) {
    log(SHUTDOWN_INTERRUPTED,e,Project.MSG_VERBOSE);
  }
  applicationException=worker.getBuildException();
  processExceptions();
}","/** 
 * Run the functional test sequence. <p/> This is a fairly complex workflow -what is going on is that we try to clean up no matter how the run ended, and to retain the innermost exception that got thrown during cleanup. That is, if teardown fails after the tests themselves failed, it is the test failing that is more important.
 * @throws BuildException if something was caught during the run or teardown.
 */
public void execute() throws BuildException {
  validateTask(setup,""String_Node_Str"");
  validateTask(application,""String_Node_Str"");
  validateTask(tests,""String_Node_Str"");
  validateTask(reporting,""String_Node_Str"");
  validateTask(teardown,""String_Node_Str"");
  if (condition != null && !condition.eval()) {
    log(SKIPPING_TESTS);
    return;
  }
  long timeoutMillis=timeout * timeoutUnitMultiplier;
  Parallel applicationRun=newParallel(timeoutMillis);
  WorkerAnt worker=new WorkerAnt(applicationRun,null);
  if (application != null) {
    applicationRun.addTask(application);
  }
  long testRunTimeout=0;
  Sequential testRun=new Sequential();
  bind(testRun);
  if (block != null) {
    TaskAdapter ta=new TaskAdapter(block);
    ta.bindToOwner(this);
    validateTask(ta,""String_Node_Str"");
    testRun.addTask(ta);
    testRunTimeout=block.calculateMaxWaitMillis();
  }
  if (tests != null) {
    testRun.addTask(tests);
    testRunTimeout+=timeoutMillis;
  }
  if (reporting != null) {
    testRun.addTask(reporting);
    testRunTimeout+=timeoutMillis;
  }
  timedTests=newParallel(testRunTimeout,testRun);
  try {
    if (setup != null) {
      Parallel setupRun=newParallel(timeoutMillis,setup);
      setupRun.execute();
    }
    worker.start();
    timedTests.execute();
  }
 catch (  BuildException e) {
    testException=e;
  }
 finally {
    if (teardown != null) {
      try {
        Parallel teardownRun=newParallel(timeoutMillis,teardown);
        teardownRun.execute();
      }
 catch (      BuildException e) {
        teardownException=e;
      }
    }
  }
  try {
    long shutdownTimeMillis=shutdownTime * shutdownUnitMultiplier;
    worker.waitUntilFinished(shutdownTimeMillis);
    if (worker.isAlive()) {
      log(APPLICATION_FORCIBLY_SHUT_DOWN,Project.MSG_WARN);
      worker.interrupt();
      worker.waitUntilFinished(shutdownTimeMillis);
    }
  }
 catch (  InterruptedException e) {
    log(SHUTDOWN_INTERRUPTED,e,Project.MSG_VERBOSE);
  }
  applicationException=worker.getBuildException();
  processExceptions();
}",0.9251348435814456
64156,"/** 
 * Log if the definition is overriding something
 * @param name       what is being defined
 * @param definition what should be null if you don't want a warning
 */
private void logOverride(String name,Object definition){
  if (definition != null) {
    log(WARN_OVERRIDING + '<' + name+ '>',Project.MSG_WARN);
  }
}","/** 
 * Log if the definition is overriding something
 * @param name       what is being defined
 * @param definition what should be null if you don't want a warning
 */
private void logOverride(String name,Object definition){
  if (definition != null) {
    log(WARN_OVERRIDING + '<' + name+ '>',Project.MSG_INFO);
  }
}",0.9906542056074766
64157,"private char med3(char a,char b,char c){
  char t;
  if (a > b) {
    t=a;
    a=b;
    b=t;
  }
  if (b > c) {
    t=b;
    b=c;
    c=t;
  }
  if (a > b) {
    b=a;
  }
  return b;
}","private char med3(char a,char b,char c){
  char t;
  if (a > b) {
    t=a;
    a=b;
    b=t;
  }
  if (b > c) {
    b=c;
  }
  if (a > b) {
    b=a;
  }
  return b;
}",0.9485714285714286
64158,"private void sendMTFValues() throws IOException {
  char len[][]=new char[N_GROUPS][MAX_ALPHA_SIZE];
  int v, t, i, j, gs, ge, totc, bt, bc, iter;
  int nSelectors=0, alphaSize, minLen, maxLen, selCtr;
  int nGroups, nBytes;
  alphaSize=nInUse + 2;
  for (t=0; t < N_GROUPS; t++) {
    for (v=0; v < alphaSize; v++) {
      len[t][v]=(char)GREATER_ICOST;
    }
  }
  if (nMTF <= 0) {
    panic();
  }
  if (nMTF < 200) {
    nGroups=2;
  }
 else   if (nMTF < 600) {
    nGroups=3;
  }
 else   if (nMTF < 1200) {
    nGroups=4;
  }
 else   if (nMTF < 2400) {
    nGroups=5;
  }
 else {
    nGroups=6;
  }
{
    int nPart, remF, tFreq, aFreq;
    nPart=nGroups;
    remF=nMTF;
    gs=0;
    while (nPart > 0) {
      tFreq=remF / nPart;
      ge=gs - 1;
      aFreq=0;
      while (aFreq < tFreq && ge < alphaSize - 1) {
        ge++;
        aFreq+=mtfFreq[ge];
      }
      if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {
        aFreq-=mtfFreq[ge];
        ge--;
      }
      for (v=0; v < alphaSize; v++) {
        if (v >= gs && v <= ge) {
          len[nPart - 1][v]=(char)LESSER_ICOST;
        }
 else {
          len[nPart - 1][v]=(char)GREATER_ICOST;
        }
      }
      nPart--;
      gs=ge + 1;
      remF-=aFreq;
    }
  }
  int[][] rfreq=new int[N_GROUPS][MAX_ALPHA_SIZE];
  int[] fave=new int[N_GROUPS];
  short[] cost=new short[N_GROUPS];
  for (iter=0; iter < N_ITERS; iter++) {
    for (t=0; t < nGroups; t++) {
      fave[t]=0;
    }
    for (t=0; t < nGroups; t++) {
      for (v=0; v < alphaSize; v++) {
        rfreq[t][v]=0;
      }
    }
    nSelectors=0;
    totc=0;
    gs=0;
    while (true) {
      if (gs >= nMTF) {
        break;
      }
      ge=gs + G_SIZE - 1;
      if (ge >= nMTF) {
        ge=nMTF - 1;
      }
      for (t=0; t < nGroups; t++) {
        cost[t]=0;
      }
      if (nGroups == 6) {
        short cost0, cost1, cost2, cost3, cost4, cost5;
        cost0=cost1=cost2=cost3=cost4=cost5=0;
        for (i=gs; i <= ge; i++) {
          short icv=szptr[i];
          cost0+=len[0][icv];
          cost1+=len[1][icv];
          cost2+=len[2][icv];
          cost3+=len[3][icv];
          cost4+=len[4][icv];
          cost5+=len[5][icv];
        }
        cost[0]=cost0;
        cost[1]=cost1;
        cost[2]=cost2;
        cost[3]=cost3;
        cost[4]=cost4;
        cost[5]=cost5;
      }
 else {
        for (i=gs; i <= ge; i++) {
          short icv=szptr[i];
          for (t=0; t < nGroups; t++) {
            cost[t]+=len[t][icv];
          }
        }
      }
      bc=999999999;
      bt=-1;
      for (t=0; t < nGroups; t++) {
        if (cost[t] < bc) {
          bc=cost[t];
          bt=t;
        }
      }
      totc+=bc;
      fave[bt]++;
      selector[nSelectors]=(char)bt;
      nSelectors++;
      for (i=gs; i <= ge; i++) {
        rfreq[bt][szptr[i]]++;
      }
      gs=ge + 1;
    }
    for (t=0; t < nGroups; t++) {
      hbMakeCodeLengths(len[t],rfreq[t],alphaSize,20);
    }
  }
  rfreq=null;
  fave=null;
  cost=null;
  if (!(nGroups < 8)) {
    panic();
  }
  if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {
    panic();
  }
{
    char[] pos=new char[N_GROUPS];
    char ll_i, tmp2, tmp;
    for (i=0; i < nGroups; i++) {
      pos[i]=(char)i;
    }
    for (i=0; i < nSelectors; i++) {
      ll_i=selector[i];
      j=0;
      tmp=pos[j];
      while (ll_i != tmp) {
        j++;
        tmp2=tmp;
        tmp=pos[j];
        pos[j]=tmp2;
      }
      pos[0]=tmp;
      selectorMtf[i]=(char)j;
    }
  }
  int[][] code=new int[N_GROUPS][MAX_ALPHA_SIZE];
  for (t=0; t < nGroups; t++) {
    minLen=32;
    maxLen=0;
    for (i=0; i < alphaSize; i++) {
      if (len[t][i] > maxLen) {
        maxLen=len[t][i];
      }
      if (len[t][i] < minLen) {
        minLen=len[t][i];
      }
    }
    if (maxLen > 20) {
      panic();
    }
    if (minLen < 1) {
      panic();
    }
    hbAssignCodes(code[t],len[t],minLen,maxLen,alphaSize);
  }
{
    boolean[] inUse16=new boolean[16];
    for (i=0; i < 16; i++) {
      inUse16[i]=false;
      for (j=0; j < 16; j++) {
        if (inUse[i * 16 + j]) {
          inUse16[i]=true;
        }
      }
    }
    nBytes=bytesOut;
    for (i=0; i < 16; i++) {
      if (inUse16[i]) {
        bsW(1,1);
      }
 else {
        bsW(1,0);
      }
    }
    for (i=0; i < 16; i++) {
      if (inUse16[i]) {
        for (j=0; j < 16; j++) {
          if (inUse[i * 16 + j]) {
            bsW(1,1);
          }
 else {
            bsW(1,0);
          }
        }
      }
    }
  }
  nBytes=bytesOut;
  bsW(3,nGroups);
  bsW(15,nSelectors);
  for (i=0; i < nSelectors; i++) {
    for (j=0; j < selectorMtf[i]; j++) {
      bsW(1,1);
    }
    bsW(1,0);
  }
  nBytes=bytesOut;
  for (t=0; t < nGroups; t++) {
    int curr=len[t][0];
    bsW(5,curr);
    for (i=0; i < alphaSize; i++) {
      while (curr < len[t][i]) {
        bsW(2,2);
        curr++;
      }
      while (curr > len[t][i]) {
        bsW(2,3);
        curr--;
      }
      bsW(1,0);
    }
  }
  nBytes=bytesOut;
  selCtr=0;
  gs=0;
  while (true) {
    if (gs >= nMTF) {
      break;
    }
    ge=gs + G_SIZE - 1;
    if (ge >= nMTF) {
      ge=nMTF - 1;
    }
    for (i=gs; i <= ge; i++) {
      bsW(len[selector[selCtr]][szptr[i]],code[selector[selCtr]][szptr[i]]);
    }
    gs=ge + 1;
    selCtr++;
  }
  if (!(selCtr == nSelectors)) {
    panic();
  }
}","private void sendMTFValues() throws IOException {
  char len[][]=new char[N_GROUPS][MAX_ALPHA_SIZE];
  int v, t, i, j, gs, ge, totc, bt, bc, iter;
  int nSelectors=0, alphaSize, minLen, maxLen, selCtr;
  int nGroups, nBytes;
  alphaSize=nInUse + 2;
  for (t=0; t < N_GROUPS; t++) {
    for (v=0; v < alphaSize; v++) {
      len[t][v]=(char)GREATER_ICOST;
    }
  }
  if (nMTF <= 0) {
    panic();
  }
  if (nMTF < 200) {
    nGroups=2;
  }
 else   if (nMTF < 600) {
    nGroups=3;
  }
 else   if (nMTF < 1200) {
    nGroups=4;
  }
 else   if (nMTF < 2400) {
    nGroups=5;
  }
 else {
    nGroups=6;
  }
{
    int nPart, remF, tFreq, aFreq;
    nPart=nGroups;
    remF=nMTF;
    gs=0;
    while (nPart > 0) {
      tFreq=remF / nPart;
      ge=gs - 1;
      aFreq=0;
      while (aFreq < tFreq && ge < alphaSize - 1) {
        ge++;
        aFreq+=mtfFreq[ge];
      }
      if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 != 0)) {
        aFreq-=mtfFreq[ge];
        ge--;
      }
      for (v=0; v < alphaSize; v++) {
        if (v >= gs && v <= ge) {
          len[nPart - 1][v]=(char)LESSER_ICOST;
        }
 else {
          len[nPart - 1][v]=(char)GREATER_ICOST;
        }
      }
      nPart--;
      gs=ge + 1;
      remF-=aFreq;
    }
  }
  int[][] rfreq=new int[N_GROUPS][MAX_ALPHA_SIZE];
  int[] fave=new int[N_GROUPS];
  short[] cost=new short[N_GROUPS];
  for (iter=0; iter < N_ITERS; iter++) {
    for (t=0; t < nGroups; t++) {
      fave[t]=0;
    }
    for (t=0; t < nGroups; t++) {
      for (v=0; v < alphaSize; v++) {
        rfreq[t][v]=0;
      }
    }
    nSelectors=0;
    totc=0;
    gs=0;
    while (true) {
      if (gs >= nMTF) {
        break;
      }
      ge=gs + G_SIZE - 1;
      if (ge >= nMTF) {
        ge=nMTF - 1;
      }
      for (t=0; t < nGroups; t++) {
        cost[t]=0;
      }
      if (nGroups == 6) {
        short cost0, cost1, cost2, cost3, cost4, cost5;
        cost0=cost1=cost2=cost3=cost4=cost5=0;
        for (i=gs; i <= ge; i++) {
          short icv=szptr[i];
          cost0+=len[0][icv];
          cost1+=len[1][icv];
          cost2+=len[2][icv];
          cost3+=len[3][icv];
          cost4+=len[4][icv];
          cost5+=len[5][icv];
        }
        cost[0]=cost0;
        cost[1]=cost1;
        cost[2]=cost2;
        cost[3]=cost3;
        cost[4]=cost4;
        cost[5]=cost5;
      }
 else {
        for (i=gs; i <= ge; i++) {
          short icv=szptr[i];
          for (t=0; t < nGroups; t++) {
            cost[t]+=len[t][icv];
          }
        }
      }
      bc=999999999;
      bt=-1;
      for (t=0; t < nGroups; t++) {
        if (cost[t] < bc) {
          bc=cost[t];
          bt=t;
        }
      }
      totc+=bc;
      fave[bt]++;
      selector[nSelectors]=(char)bt;
      nSelectors++;
      for (i=gs; i <= ge; i++) {
        rfreq[bt][szptr[i]]++;
      }
      gs=ge + 1;
    }
    for (t=0; t < nGroups; t++) {
      hbMakeCodeLengths(len[t],rfreq[t],alphaSize,20);
    }
  }
  rfreq=null;
  fave=null;
  cost=null;
  if (!(nGroups < 8)) {
    panic();
  }
  if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {
    panic();
  }
{
    char[] pos=new char[N_GROUPS];
    char ll_i, tmp2, tmp;
    for (i=0; i < nGroups; i++) {
      pos[i]=(char)i;
    }
    for (i=0; i < nSelectors; i++) {
      ll_i=selector[i];
      j=0;
      tmp=pos[j];
      while (ll_i != tmp) {
        j++;
        tmp2=tmp;
        tmp=pos[j];
        pos[j]=tmp2;
      }
      pos[0]=tmp;
      selectorMtf[i]=(char)j;
    }
  }
  int[][] code=new int[N_GROUPS][MAX_ALPHA_SIZE];
  for (t=0; t < nGroups; t++) {
    minLen=32;
    maxLen=0;
    for (i=0; i < alphaSize; i++) {
      if (len[t][i] > maxLen) {
        maxLen=len[t][i];
      }
      if (len[t][i] < minLen) {
        minLen=len[t][i];
      }
    }
    if (maxLen > 20) {
      panic();
    }
    if (minLen < 1) {
      panic();
    }
    hbAssignCodes(code[t],len[t],minLen,maxLen,alphaSize);
  }
{
    boolean[] inUse16=new boolean[16];
    for (i=0; i < 16; i++) {
      inUse16[i]=false;
      for (j=0; j < 16; j++) {
        if (inUse[i * 16 + j]) {
          inUse16[i]=true;
        }
      }
    }
    nBytes=bytesOut;
    for (i=0; i < 16; i++) {
      if (inUse16[i]) {
        bsW(1,1);
      }
 else {
        bsW(1,0);
      }
    }
    for (i=0; i < 16; i++) {
      if (inUse16[i]) {
        for (j=0; j < 16; j++) {
          if (inUse[i * 16 + j]) {
            bsW(1,1);
          }
 else {
            bsW(1,0);
          }
        }
      }
    }
  }
  nBytes=bytesOut;
  bsW(3,nGroups);
  bsW(15,nSelectors);
  for (i=0; i < nSelectors; i++) {
    for (j=0; j < selectorMtf[i]; j++) {
      bsW(1,1);
    }
    bsW(1,0);
  }
  nBytes=bytesOut;
  for (t=0; t < nGroups; t++) {
    int curr=len[t][0];
    bsW(5,curr);
    for (i=0; i < alphaSize; i++) {
      while (curr < len[t][i]) {
        bsW(2,2);
        curr++;
      }
      while (curr > len[t][i]) {
        bsW(2,3);
        curr--;
      }
      bsW(1,0);
    }
  }
  nBytes=bytesOut;
  selCtr=0;
  gs=0;
  while (true) {
    if (gs >= nMTF) {
      break;
    }
    ge=gs + G_SIZE - 1;
    if (ge >= nMTF) {
      ge=nMTF - 1;
    }
    for (i=gs; i <= ge; i++) {
      bsW(len[selector[selCtr]][szptr[i]],code[selector[selCtr]][szptr[i]]);
    }
    gs=ge + 1;
    selCtr++;
  }
  if (!(selCtr == nSelectors)) {
    panic();
  }
}",0.9992587101556708
64159,"private void qSort3(int loSt,int hiSt,int dSt,StackElem[] stack){
  int unLo, unHi, ltLo, gtHi, med, n, m;
  int sp, lo, hi, d;
  sp=0;
  stack[sp].ll=loSt;
  stack[sp].hh=hiSt;
  stack[sp].dd=dSt;
  sp++;
  while (sp > 0) {
    if (sp >= QSORT_STACK_SIZE) {
      panic();
    }
    sp--;
    lo=stack[sp].ll;
    hi=stack[sp].hh;
    d=stack[sp].dd;
    if (hi - lo < SMALL_THRESH || d > DEPTH_THRESH) {
      simpleSort(lo,hi,d);
      if (workDone > workLimit && firstAttempt) {
        return;
      }
      continue;
    }
    med=med3(block[zptr[lo] + d + 1],block[zptr[hi] + d + 1],block[zptr[(lo + hi) >> 1] + d + 1]);
    unLo=ltLo=lo;
    unHi=gtHi=hi;
    while (true) {
      while (true) {
        if (unLo > unHi) {
          break;
        }
        n=((int)block[zptr[unLo] + d + 1]) - med;
        if (n == 0) {
          int temp=0;
          temp=zptr[unLo];
          zptr[unLo]=zptr[ltLo];
          zptr[ltLo]=temp;
          ltLo++;
          unLo++;
          continue;
        }
        if (n > 0) {
          break;
        }
        unLo++;
      }
      while (true) {
        if (unLo > unHi) {
          break;
        }
        n=((int)block[zptr[unHi] + d + 1]) - med;
        if (n == 0) {
          int temp=0;
          temp=zptr[unHi];
          zptr[unHi]=zptr[gtHi];
          zptr[gtHi]=temp;
          gtHi--;
          unHi--;
          continue;
        }
        if (n < 0) {
          break;
        }
        unHi--;
      }
      if (unLo > unHi) {
        break;
      }
      int temp=0;
      temp=zptr[unLo];
      zptr[unLo]=zptr[unHi];
      zptr[unHi]=temp;
      unLo++;
      unHi--;
    }
    if (gtHi < ltLo) {
      stack[sp].ll=lo;
      stack[sp].hh=hi;
      stack[sp].dd=d + 1;
      sp++;
      continue;
    }
    n=((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo);
    vswap(lo,unLo - n,n);
    m=((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi);
    vswap(unLo,hi - m + 1,m);
    n=lo + unLo - ltLo - 1;
    m=hi - (gtHi - unHi) + 1;
    stack[sp].ll=lo;
    stack[sp].hh=n;
    stack[sp].dd=d;
    sp++;
    stack[sp].ll=n + 1;
    stack[sp].hh=m - 1;
    stack[sp].dd=d + 1;
    sp++;
    stack[sp].ll=m;
    stack[sp].hh=hi;
    stack[sp].dd=d;
    sp++;
  }
}","private void qSort3(int loSt,int hiSt,int dSt,StackElem[] stack){
  int unLo, unHi, ltLo, gtHi, med, n, m;
  int sp, lo, hi, d;
  sp=0;
  stack[sp].ll=loSt;
  stack[sp].hh=hiSt;
  stack[sp].dd=dSt;
  sp++;
  while (sp > 0) {
    if (sp >= QSORT_STACK_SIZE) {
      panic();
    }
    sp--;
    lo=stack[sp].ll;
    hi=stack[sp].hh;
    d=stack[sp].dd;
    if (hi - lo < SMALL_THRESH || d > DEPTH_THRESH) {
      simpleSort(lo,hi,d);
      if (workDone > workLimit && firstAttempt) {
        return;
      }
      continue;
    }
    med=med3(block[zptr[lo] + d + 1],block[zptr[hi] + d + 1],block[zptr[(lo + hi) >>> 1] + d + 1]);
    unLo=ltLo=lo;
    unHi=gtHi=hi;
    while (true) {
      while (true) {
        if (unLo > unHi) {
          break;
        }
        n=((int)block[zptr[unLo] + d + 1]) - med;
        if (n == 0) {
          int temp=0;
          temp=zptr[unLo];
          zptr[unLo]=zptr[ltLo];
          zptr[ltLo]=temp;
          ltLo++;
          unLo++;
          continue;
        }
        if (n > 0) {
          break;
        }
        unLo++;
      }
      while (true) {
        if (unLo > unHi) {
          break;
        }
        n=((int)block[zptr[unHi] + d + 1]) - med;
        if (n == 0) {
          int temp=0;
          temp=zptr[unHi];
          zptr[unHi]=zptr[gtHi];
          zptr[gtHi]=temp;
          gtHi--;
          unHi--;
          continue;
        }
        if (n < 0) {
          break;
        }
        unHi--;
      }
      if (unLo > unHi) {
        break;
      }
      int temp=0;
      temp=zptr[unLo];
      zptr[unLo]=zptr[unHi];
      zptr[unHi]=temp;
      unLo++;
      unHi--;
    }
    if (gtHi < ltLo) {
      stack[sp].ll=lo;
      stack[sp].hh=hi;
      stack[sp].dd=d + 1;
      sp++;
      continue;
    }
    n=((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo);
    vswap(lo,unLo - n,n);
    m=((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi);
    vswap(unLo,hi - m + 1,m);
    n=lo + unLo - ltLo - 1;
    m=hi - (gtHi - unHi) + 1;
    stack[sp].ll=lo;
    stack[sp].hh=n;
    stack[sp].dd=d;
    sp++;
    stack[sp].ll=n + 1;
    stack[sp].hh=m - 1;
    stack[sp].dd=d + 1;
    sp++;
    stack[sp].ll=m;
    stack[sp].hh=hi;
    stack[sp].dd=d;
    sp++;
  }
}",0.999778024417314
64160,"/** 
 * Get the next entry in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.
 * @return The next TarEntry in the archive, or null.
 * @throws IOException on error
 */
public TarEntry getNextEntry() throws IOException {
  if (hasHitEOF) {
    return null;
  }
  if (currEntry != null) {
    long numToSkip=entrySize - entryOffset;
    if (debug) {
      System.err.println(""String_Node_Str"" + currEntry.getName() + ""String_Node_Str""+ entrySize+ ""String_Node_Str""+ entryOffset+ ""String_Node_Str""+ numToSkip+ ""String_Node_Str"");
    }
    if (numToSkip > 0) {
      skip(numToSkip);
    }
    readBuf=null;
  }
  byte[] headerBuf=buffer.readRecord();
  if (headerBuf == null) {
    if (debug) {
      System.err.println(""String_Node_Str"");
    }
    hasHitEOF=true;
  }
 else   if (buffer.isEOFRecord(headerBuf)) {
    if (debug) {
      System.err.println(""String_Node_Str"");
    }
    hasHitEOF=true;
  }
  if (hasHitEOF) {
    currEntry=null;
  }
 else {
    currEntry=new TarEntry(headerBuf);
    if (debug) {
      System.err.println(""String_Node_Str"" + currEntry.getName() + ""String_Node_Str""+ currEntry.getSize());
    }
    entryOffset=0;
    entrySize=currEntry.getSize();
  }
  if (currEntry != null && currEntry.isGNULongNameEntry()) {
    StringBuffer longName=new StringBuffer();
    byte[] buf=new byte[SMALL_BUFFER_SIZE];
    int length=0;
    while ((length=read(buf)) >= 0) {
      longName.append(new String(buf,0,length));
    }
    getNextEntry();
    if (currEntry == null) {
      return null;
    }
    if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
      longName.deleteCharAt(longName.length() - 1);
    }
    currEntry.setName(longName.toString());
  }
  return currEntry;
}","/** 
 * Get the next entry in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.
 * @return The next TarEntry in the archive, or null.
 * @throws IOException on error
 */
public TarEntry getNextEntry() throws IOException {
  if (hasHitEOF) {
    return null;
  }
  if (currEntry != null) {
    long numToSkip=entrySize - entryOffset;
    if (debug) {
      System.err.println(""String_Node_Str"" + currEntry.getName() + ""String_Node_Str""+ entrySize+ ""String_Node_Str""+ entryOffset+ ""String_Node_Str""+ numToSkip+ ""String_Node_Str"");
    }
    while (numToSkip > 0) {
      long skipped=skip(numToSkip);
      if (skipped <= 0) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
      }
      numToSkip-=skipped;
    }
    readBuf=null;
  }
  byte[] headerBuf=buffer.readRecord();
  if (headerBuf == null) {
    if (debug) {
      System.err.println(""String_Node_Str"");
    }
    hasHitEOF=true;
  }
 else   if (buffer.isEOFRecord(headerBuf)) {
    if (debug) {
      System.err.println(""String_Node_Str"");
    }
    hasHitEOF=true;
  }
  if (hasHitEOF) {
    currEntry=null;
  }
 else {
    currEntry=new TarEntry(headerBuf);
    if (debug) {
      System.err.println(""String_Node_Str"" + currEntry.getName() + ""String_Node_Str""+ currEntry.getSize());
    }
    entryOffset=0;
    entrySize=currEntry.getSize();
  }
  if (currEntry != null && currEntry.isGNULongNameEntry()) {
    StringBuffer longName=new StringBuffer();
    byte[] buf=new byte[SMALL_BUFFER_SIZE];
    int length=0;
    while ((length=read(buf)) >= 0) {
      longName.append(new String(buf,0,length));
    }
    getNextEntry();
    if (currEntry == null) {
      return null;
    }
    if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
      longName.deleteCharAt(longName.length() - 1);
    }
    currEntry.setName(longName.toString());
  }
  return currEntry;
}",0.9636406286652592
64161,"/** 
 * Writes bytes to the current tar archive entry. This method is aware of the current entry and will throw an exception if you attempt to write bytes past the length specified for the current entry. The method is also (painfully) aware of the record buffering required by TarBuffer, and manages buffers that are not a multiple of recordsize in length, including assembling records from small buffers.
 * @param wBuf The buffer to write to the archive.
 * @param wOffset The offset in the buffer from which to get bytes.
 * @param numToWrite The number of bytes to write.
 * @throws IOException on error
 */
public void write(byte[] wBuf,int wOffset,int numToWrite) throws IOException {
  if ((currBytes + numToWrite) > currSize) {
    throw new IOException(""String_Node_Str"" + numToWrite + ""String_Node_Str""+ currSize+ ""String_Node_Str""+ currName+ ""String_Node_Str"");
  }
  if (assemLen > 0) {
    if ((assemLen + numToWrite) >= recordBuf.length) {
      int aLen=recordBuf.length - assemLen;
      System.arraycopy(assemBuf,0,recordBuf,0,assemLen);
      System.arraycopy(wBuf,wOffset,recordBuf,assemLen,aLen);
      buffer.writeRecord(recordBuf);
      currBytes+=recordBuf.length;
      wOffset+=aLen;
      numToWrite-=aLen;
      assemLen=0;
    }
 else {
      System.arraycopy(wBuf,wOffset,assemBuf,assemLen,numToWrite);
      wOffset+=numToWrite;
      assemLen+=numToWrite;
      numToWrite-=numToWrite;
    }
  }
  while (numToWrite > 0) {
    if (numToWrite < recordBuf.length) {
      System.arraycopy(wBuf,wOffset,assemBuf,assemLen,numToWrite);
      assemLen+=numToWrite;
      break;
    }
    buffer.writeRecord(wBuf,wOffset);
    int num=recordBuf.length;
    currBytes+=num;
    numToWrite-=num;
    wOffset+=num;
  }
}","/** 
 * Writes bytes to the current tar archive entry. This method is aware of the current entry and will throw an exception if you attempt to write bytes past the length specified for the current entry. The method is also (painfully) aware of the record buffering required by TarBuffer, and manages buffers that are not a multiple of recordsize in length, including assembling records from small buffers.
 * @param wBuf The buffer to write to the archive.
 * @param wOffset The offset in the buffer from which to get bytes.
 * @param numToWrite The number of bytes to write.
 * @throws IOException on error
 */
public void write(byte[] wBuf,int wOffset,int numToWrite) throws IOException {
  if ((currBytes + numToWrite) > currSize) {
    throw new IOException(""String_Node_Str"" + numToWrite + ""String_Node_Str""+ currSize+ ""String_Node_Str""+ currName+ ""String_Node_Str"");
  }
  if (assemLen > 0) {
    if ((assemLen + numToWrite) >= recordBuf.length) {
      int aLen=recordBuf.length - assemLen;
      System.arraycopy(assemBuf,0,recordBuf,0,assemLen);
      System.arraycopy(wBuf,wOffset,recordBuf,assemLen,aLen);
      buffer.writeRecord(recordBuf);
      currBytes+=recordBuf.length;
      wOffset+=aLen;
      numToWrite-=aLen;
      assemLen=0;
    }
 else {
      System.arraycopy(wBuf,wOffset,assemBuf,assemLen,numToWrite);
      wOffset+=numToWrite;
      assemLen+=numToWrite;
      numToWrite=0;
    }
  }
  while (numToWrite > 0) {
    if (numToWrite < recordBuf.length) {
      System.arraycopy(wBuf,wOffset,assemBuf,assemLen,numToWrite);
      assemLen+=numToWrite;
      break;
    }
    buffer.writeRecord(wBuf,wOffset);
    int num=recordBuf.length;
    currBytes+=num;
    numToWrite-=num;
    wOffset+=num;
  }
}",0.8209556706966034
64162,"/** 
 * Get the central data.
 * @return the central data if present, else return the local file data
 */
public byte[] getCentralDirectoryData(){
  if (centralData != null) {
    return centralData;
  }
  return getLocalFileDataData();
}","/** 
 * Get the central data.
 * @return the central data if present, else return the local file data
 */
public byte[] getCentralDirectoryData(){
  if (centralData != null) {
    return copy(centralData);
  }
  return getLocalFileDataData();
}",0.946058091286307
64163,"/** 
 * Set the extra field data in the local file data - without Header-ID or length specifier.
 * @param data the field data to use
 */
public void setLocalFileDataData(byte[] data){
  localData=data;
}","/** 
 * Set the extra field data in the local file data - without Header-ID or length specifier.
 * @param data the field data to use
 */
public void setLocalFileDataData(byte[] data){
  localData=copy(data);
}",0.966183574879227
64164,"/** 
 * Set the extra field data in central directory.
 * @param data the data to use
 */
public void setCentralDirectoryData(byte[] data){
  centralData=data;
}","/** 
 * Set the extra field data in central directory.
 * @param data the data to use
 */
public void setCentralDirectoryData(byte[] data){
  centralData=copy(data);
}",0.9817073170731708
64165,"/** 
 * Get the local data.
 * @return the local data
 */
public byte[] getLocalFileDataData(){
  return localData;
}","/** 
 * Get the local data.
 * @return the local data
 */
public byte[] getLocalFileDataData(){
  return copy(localData);
}",0.975
64166,"/** 
 * Walks through all recorded entries and adds the data available from the local file header. <p>Also records the offsets for the data to read from the entries.</p>
 */
private void resolveLocalFileHeaderData() throws IOException {
  Enumeration e=getEntries();
  while (e.hasMoreElements()) {
    ZipEntry ze=(ZipEntry)e.nextElement();
    OffsetEntry offsetEntry=(OffsetEntry)entries.get(ze);
    long offset=offsetEntry.headerOffset;
    archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);
    byte[] b=new byte[SHORT];
    archive.readFully(b);
    int fileNameLen=ZipShort.getValue(b);
    archive.readFully(b);
    int extraFieldLen=ZipShort.getValue(b);
    archive.skipBytes(fileNameLen);
    byte[] localExtraData=new byte[extraFieldLen];
    archive.readFully(localExtraData);
    ze.setExtra(localExtraData);
    offsetEntry.dataOffset=offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT+ SHORT+ fileNameLen+ extraFieldLen;
  }
}","/** 
 * Walks through all recorded entries and adds the data available from the local file header. <p>Also records the offsets for the data to read from the entries.</p>
 */
private void resolveLocalFileHeaderData() throws IOException {
  Enumeration e=getEntries();
  while (e.hasMoreElements()) {
    ZipEntry ze=(ZipEntry)e.nextElement();
    OffsetEntry offsetEntry=(OffsetEntry)entries.get(ze);
    long offset=offsetEntry.headerOffset;
    archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);
    byte[] b=new byte[SHORT];
    archive.readFully(b);
    int fileNameLen=ZipShort.getValue(b);
    archive.readFully(b);
    int extraFieldLen=ZipShort.getValue(b);
    int lenToSkip=fileNameLen;
    while (lenToSkip > 0) {
      int skipped=archive.skipBytes(lenToSkip);
      if (skipped <= 0) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
      }
      lenToSkip-=skipped;
    }
    byte[] localExtraData=new byte[extraFieldLen];
    archive.readFully(localExtraData);
    ze.setExtra(localExtraData);
    offsetEntry.dataOffset=offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT+ SHORT+ fileNameLen+ extraFieldLen;
  }
}",0.8876190476190476
64167,"/** 
 * Reads the central directory of the given archive and populates the internal tables with ZipEntry instances. <p>The ZipEntrys will know all data that can be obtained from the central directory alone, but not the data that requires the local file header or additional data to be read.</p>
 */
private void populateFromCentralDirectory() throws IOException {
  positionAtCentralDirectory();
  byte[] cfh=new byte[CFH_LEN];
  byte[] signatureBytes=new byte[WORD];
  archive.readFully(signatureBytes);
  long sig=ZipLong.getValue(signatureBytes);
  final long cfhSig=ZipLong.getValue(ZipOutputStream.CFH_SIG);
  if (sig != cfhSig && startsWithLocalFileHeader()) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
  }
  while (sig == cfhSig) {
    archive.readFully(cfh);
    int off=0;
    ZipEntry ze=new ZipEntry();
    int versionMadeBy=ZipShort.getValue(cfh,off);
    off+=SHORT;
    ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);
    off+=WORD;
    ze.setMethod(ZipShort.getValue(cfh,off));
    off+=SHORT;
    long time=dosToJavaTime(ZipLong.getValue(cfh,off));
    ze.setTime(time);
    off+=WORD;
    ze.setCrc(ZipLong.getValue(cfh,off));
    off+=WORD;
    ze.setCompressedSize(ZipLong.getValue(cfh,off));
    off+=WORD;
    ze.setSize(ZipLong.getValue(cfh,off));
    off+=WORD;
    int fileNameLen=ZipShort.getValue(cfh,off);
    off+=SHORT;
    int extraLen=ZipShort.getValue(cfh,off);
    off+=SHORT;
    int commentLen=ZipShort.getValue(cfh,off);
    off+=SHORT;
    off+=SHORT;
    ze.setInternalAttributes(ZipShort.getValue(cfh,off));
    off+=SHORT;
    ze.setExternalAttributes(ZipLong.getValue(cfh,off));
    off+=WORD;
    byte[] fileName=new byte[fileNameLen];
    archive.readFully(fileName);
    ze.setName(getString(fileName));
    OffsetEntry offset=new OffsetEntry();
    offset.headerOffset=ZipLong.getValue(cfh,off);
    entries.put(ze,offset);
    nameMap.put(ze.getName(),ze);
    archive.skipBytes(extraLen);
    byte[] comment=new byte[commentLen];
    archive.readFully(comment);
    ze.setComment(getString(comment));
    archive.readFully(signatureBytes);
    sig=ZipLong.getValue(signatureBytes);
  }
}","/** 
 * Reads the central directory of the given archive and populates the internal tables with ZipEntry instances. <p>The ZipEntrys will know all data that can be obtained from the central directory alone, but not the data that requires the local file header or additional data to be read.</p>
 */
private void populateFromCentralDirectory() throws IOException {
  positionAtCentralDirectory();
  byte[] cfh=new byte[CFH_LEN];
  byte[] signatureBytes=new byte[WORD];
  archive.readFully(signatureBytes);
  long sig=ZipLong.getValue(signatureBytes);
  final long cfhSig=ZipLong.getValue(ZipOutputStream.CFH_SIG);
  if (sig != cfhSig && startsWithLocalFileHeader()) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
  }
  while (sig == cfhSig) {
    archive.readFully(cfh);
    int off=0;
    ZipEntry ze=new ZipEntry();
    int versionMadeBy=ZipShort.getValue(cfh,off);
    off+=SHORT;
    ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);
    off+=WORD;
    ze.setMethod(ZipShort.getValue(cfh,off));
    off+=SHORT;
    long time=dosToJavaTime(ZipLong.getValue(cfh,off));
    ze.setTime(time);
    off+=WORD;
    ze.setCrc(ZipLong.getValue(cfh,off));
    off+=WORD;
    ze.setCompressedSize(ZipLong.getValue(cfh,off));
    off+=WORD;
    ze.setSize(ZipLong.getValue(cfh,off));
    off+=WORD;
    int fileNameLen=ZipShort.getValue(cfh,off);
    off+=SHORT;
    int extraLen=ZipShort.getValue(cfh,off);
    off+=SHORT;
    int commentLen=ZipShort.getValue(cfh,off);
    off+=SHORT;
    off+=SHORT;
    ze.setInternalAttributes(ZipShort.getValue(cfh,off));
    off+=SHORT;
    ze.setExternalAttributes(ZipLong.getValue(cfh,off));
    off+=WORD;
    byte[] fileName=new byte[fileNameLen];
    archive.readFully(fileName);
    ze.setName(getString(fileName));
    OffsetEntry offset=new OffsetEntry();
    offset.headerOffset=ZipLong.getValue(cfh,off);
    entries.put(ze,offset);
    nameMap.put(ze.getName(),ze);
    int lenToSkip=extraLen;
    while (lenToSkip > 0) {
      int skipped=archive.skipBytes(lenToSkip);
      if (skipped <= 0) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
      }
      lenToSkip-=skipped;
    }
    byte[] comment=new byte[commentLen];
    archive.readFully(comment);
    ze.setComment(getString(comment));
    archive.readFully(signatureBytes);
    sig=ZipLong.getValue(signatureBytes);
  }
}",0.9494949494949496
64168,"/** 
 * Sets the timestampGranularity attribute
 * @param timestampGranularity The timestampGranularity to set.
 */
public void setTimestampGranularity(Granularity timestampGranularity){
  if (null == timestampGranularity || ""String_Node_Str"".equals(timestampGranularity)) {
    return;
  }
  this.timestampGranularity=timestampGranularity;
}","/** 
 * Sets the timestampGranularity attribute
 * @param timestampGranularity The timestampGranularity to set.
 */
public void setTimestampGranularity(Granularity timestampGranularity){
  if (null == timestampGranularity || ""String_Node_Str"".equals(timestampGranularity.getValue())) {
    return;
  }
  this.timestampGranularity=timestampGranularity;
}",0.9841726618705036
64169,"/** 
 * Checks to see if the remote file is current as compared with the local file. Returns true if the target file is up to date.
 * @param ftp ftpclient
 * @param localFile local file
 * @param remoteFile remote file
 * @return true if the target file is up to date
 * @throws IOException  in unknown circumstances
 * @throws BuildException if the date of the remote files cannot be found and the action isGET_FILES
 */
protected boolean isUpToDate(FTPClient ftp,File localFile,String remoteFile) throws IOException, BuildException {
  log(""String_Node_Str"" + remoteFile,Project.MSG_VERBOSE);
  FTPFile[] files=ftp.listFiles(remoteFile);
  if (files == null || files.length == 0) {
    if (action == SEND_FILES) {
      log(""String_Node_Str"" + remoteFile + ""String_Node_Str"",Project.MSG_VERBOSE);
      return false;
    }
 else {
      throw new BuildException(""String_Node_Str"" + ftp.getReplyString());
    }
  }
  long remoteTimestamp=files[0].getTimestamp().getTime().getTime();
  long localTimestamp=localFile.lastModified();
  long adjustedRemoteTimestamp=remoteTimestamp + this.timeDiffMillis + this.granularityMillis;
  StringBuffer msg=new StringBuffer(""String_Node_Str"").append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp))).append(""String_Node_Str"");
  log(msg.toString(),Project.MSG_VERBOSE);
  msg=new StringBuffer(""String_Node_Str"").append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp))).append(""String_Node_Str"");
  if (remoteTimestamp != adjustedRemoteTimestamp) {
    msg.append(""String_Node_Str"").append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp))).append(""String_Node_Str"");
  }
  log(msg.toString(),Project.MSG_VERBOSE);
  if (this.action == SEND_FILES) {
    return adjustedRemoteTimestamp >= localTimestamp;
  }
 else {
    return localTimestamp >= adjustedRemoteTimestamp;
  }
}","/** 
 * Checks to see if the remote file is current as compared with the local file. Returns true if the target file is up to date.
 * @param ftp ftpclient
 * @param localFile local file
 * @param remoteFile remote file
 * @return true if the target file is up to date
 * @throws IOException  in unknown circumstances
 * @throws BuildException if the date of the remote files cannot be found and the action isGET_FILES
 */
protected boolean isUpToDate(FTPClient ftp,File localFile,String remoteFile) throws IOException, BuildException {
  log(""String_Node_Str"" + remoteFile,Project.MSG_VERBOSE);
  FTPFile[] files=ftp.listFiles(remoteFile);
  if (files == null || files.length == 0) {
    if (action == SEND_FILES) {
      log(""String_Node_Str"" + remoteFile + ""String_Node_Str"",Project.MSG_VERBOSE);
      return false;
    }
 else {
      throw new BuildException(""String_Node_Str"" + ftp.getReplyString());
    }
  }
  long remoteTimestamp=files[0].getTimestamp().getTime().getTime();
  long localTimestamp=localFile.lastModified();
  long adjustedRemoteTimestamp=remoteTimestamp + this.timeDiffMillis + this.granularityMillis;
  StringBuffer msg;
synchronized (TIMESTAMP_LOGGING_SDF) {
    msg=new StringBuffer(""String_Node_Str"").append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp))).append(""String_Node_Str"");
  }
  log(msg.toString(),Project.MSG_VERBOSE);
synchronized (TIMESTAMP_LOGGING_SDF) {
    msg=new StringBuffer(""String_Node_Str"").append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp))).append(""String_Node_Str"");
  }
  if (remoteTimestamp != adjustedRemoteTimestamp) {
synchronized (TIMESTAMP_LOGGING_SDF) {
      msg.append(""String_Node_Str"").append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp))).append(""String_Node_Str"");
    }
  }
  log(msg.toString(),Project.MSG_VERBOSE);
  if (this.action == SEND_FILES) {
    return adjustedRemoteTimestamp >= localTimestamp;
  }
 else {
    return localTimestamp >= adjustedRemoteTimestamp;
  }
}",0.8406478578892372
64170,"/** 
 * Sets the serverLanguageCode attribute.
 * @param serverLanguageCode configuration to be set, unless it isnull or empty string, in which case ignored.
 * @see org.apache.commons.net.ftp.FTPClientConfig
 */
public void setServerLanguageCodeConfig(LanguageCode serverLanguageCode){
  if (serverLanguageCode != null && !serverLanguageCode.equals(""String_Node_Str"")) {
    this.serverLanguageCodeConfig=serverLanguageCode;
    configurationHasBeenSet();
  }
}","/** 
 * Sets the serverLanguageCode attribute.
 * @param serverLanguageCode configuration to be set, unless it isnull or empty string, in which case ignored.
 * @see org.apache.commons.net.ftp.FTPClientConfig
 */
public void setServerLanguageCodeConfig(LanguageCode serverLanguageCode){
  if (serverLanguageCode != null && !""String_Node_Str"".equals(serverLanguageCode.getValue())) {
    this.serverLanguageCodeConfig=serverLanguageCode;
    configurationHasBeenSet();
  }
}",0.932620320855615
64171,"/** 
 * Wrapper to identify nested resource collections as ZIP archives.
 */
public Union createZips(){
  if (isReference()) {
    throw noChildrenAllowed();
  }
  return zips;
}","/** 
 * Wrapper to identify nested resource collections as ZIP archives.
 */
public Union createZips(){
  if (isReference()) {
    throw noChildrenAllowed();
  }
  setChecked(false);
  return zips;
}",0.9442970822281168
64172,"/** 
 * Merges the nested collections.
 */
public Iterator iterator(){
  if (isReference()) {
    return ((Archives)getCheckedRef()).iterator();
  }
  List l=new LinkedList();
  for (Iterator i=grabArchives(); i.hasNext(); ) {
    l.addAll(CollectionUtils.asCollection(((ResourceCollection)i.next()).iterator()));
  }
  return l.iterator();
}","/** 
 * Merges the nested collections.
 */
public Iterator iterator(){
  if (isReference()) {
    return ((Archives)getCheckedRef()).iterator();
  }
  dieOnCircularReference();
  List l=new LinkedList();
  for (Iterator i=grabArchives(); i.hasNext(); ) {
    l.addAll(CollectionUtils.asCollection(((ResourceCollection)i.next()).iterator()));
  }
  return l.iterator();
}",0.9606741573033708
64173,"/** 
 * @return false
 */
public boolean isFilesystemOnly(){
  if (isReference()) {
    return ((MappedResourceCollection)getCheckedRef()).isFilesystemOnly();
  }
  return false;
}","/** 
 * @return false
 */
public boolean isFilesystemOnly(){
  if (isReference()) {
    return ((Archives)getCheckedRef()).isFilesystemOnly();
  }
  dieOnCircularReference();
  return false;
}",0.8494623655913979
64174,"/** 
 * Sums the sizes of nested archives.
 */
public int size(){
  if (isReference()) {
    return ((Archives)getCheckedRef()).size();
  }
  int total=0;
  for (Iterator i=grabArchives(); i.hasNext(); ) {
    total+=((ResourceCollection)i.next()).size();
  }
  return total;
}","/** 
 * Sums the sizes of nested archives.
 */
public int size(){
  if (isReference()) {
    return ((Archives)getCheckedRef()).size();
  }
  dieOnCircularReference();
  int total=0;
  for (Iterator i=grabArchives(); i.hasNext(); ) {
    total+=((ResourceCollection)i.next()).size();
  }
  return total;
}",0.9518900343642612
64175,"/** 
 * Wrapper to identify nested resource collections as ZIP archives.
 */
public Union createTars(){
  if (isReference()) {
    throw noChildrenAllowed();
  }
  return tars;
}","/** 
 * Wrapper to identify nested resource collections as ZIP archives.
 */
public Union createTars(){
  if (isReference()) {
    throw noChildrenAllowed();
  }
  setChecked(false);
  return tars;
}",0.9442970822281168
64176,"private void processFile(String file) throws BuildException {
  File srcFile=new File(srcDir,file);
  long lastModified=srcFile.lastModified();
  File destD=destDir == null ? srcDir : destDir;
  if (fcv == null) {
    FilterChain fc=new FilterChain();
    fc.add(filter);
    fcv=new Vector(1);
    fcv.add(fc);
  }
  File tmpFile=FILE_UTILS.createTempFile(""String_Node_Str"",""String_Node_Str"",null,true,false);
  try {
    FILE_UTILS.copyFile(srcFile,tmpFile,null,fcv,false,false,encoding,outputEncoding == null ? encoding : outputEncoding,getProject());
    File destFile=new File(destD,file);
    boolean destIsWrong=true;
    if (destFile.exists()) {
      log(""String_Node_Str"",Project.MSG_DEBUG);
      destIsWrong=!FILE_UTILS.contentEquals(destFile,tmpFile);
      log(destFile + (destIsWrong ? ""String_Node_Str"" : ""String_Node_Str""),Project.MSG_DEBUG);
    }
    if (destIsWrong) {
      FILE_UTILS.rename(tmpFile,destFile);
      if (preserveLastModified) {
        log(""String_Node_Str"",Project.MSG_DEBUG);
        FILE_UTILS.setFileLastModified(destFile,lastModified);
      }
      tmpFile=null;
    }
  }
 catch (  IOException e) {
    throw new BuildException(e);
  }
}","private void processFile(String file) throws BuildException {
  File srcFile=new File(srcDir,file);
  long lastModified=srcFile.lastModified();
  File destD=destDir == null ? srcDir : destDir;
  if (fcv == null) {
    FilterChain fc=new FilterChain();
    fc.add(filter);
    fcv=new Vector(1);
    fcv.add(fc);
  }
  File tmpFile=FILE_UTILS.createTempFile(""String_Node_Str"",""String_Node_Str"",null,true,false);
  try {
    FILE_UTILS.copyFile(srcFile,tmpFile,null,fcv,false,false,encoding,outputEncoding == null ? encoding : outputEncoding,getProject());
    File destFile=new File(destD,file);
    boolean destIsWrong=true;
    if (destFile.exists()) {
      log(""String_Node_Str"" + destFile + ""String_Node_Str"",Project.MSG_DEBUG);
      destIsWrong=!FILE_UTILS.contentEquals(destFile,tmpFile);
      log(destFile + (destIsWrong ? ""String_Node_Str"" : ""String_Node_Str""),Project.MSG_DEBUG);
    }
    if (destIsWrong) {
      FILE_UTILS.rename(tmpFile,destFile);
      if (preserveLastModified) {
        log(""String_Node_Str"" + destFile,Project.MSG_DEBUG);
        FILE_UTILS.setFileLastModified(destFile,lastModified);
      }
      tmpFile=null;
    }
  }
 catch (  IOException e) {
    throw new BuildException(""String_Node_Str"" + srcFile,e);
  }
}",0.971240755957272
64177,"/** 
 * Specify tab length in characters.
 * @param tlength specify the length of tab in spaces.
 * @throws BuildException on error.
 */
public void setTablength(int tlength) throws BuildException {
  try {
    filter.setTablength(tlength);
  }
 catch (  IOException e) {
    throw new BuildException(e);
  }
}","/** 
 * Specify tab length in characters.
 * @param tlength specify the length of tab in spaces.
 * @throws BuildException on error.
 */
public void setTablength(int tlength) throws BuildException {
  try {
    filter.setTablength(tlength);
  }
 catch (  IOException e) {
    throw new BuildException(e.getMessage(),e);
  }
}",0.9763779527559056
64178,"/** 
 * Get the Collection of delegates of the specified type.
 * @param type delegate type.
 * @return Collection.
 * @since Ant 1.8
 */
protected List getDelegates(Class type){
  return delegates.containsKey(type) ? (List)new ArrayList((List)delegates.get(type)) : Collections.EMPTY_LIST;
}","/** 
 * Get the Collection of delegates of the specified type.
 * @param type delegate type.
 * @return Collection.
 * @since Ant 1.8
 */
protected List getDelegates(Class type){
  Hashtable curDelegates=delegates;
  return curDelegates.containsKey(type) ? (List)new ArrayList((List)curDelegates.get(type)) : Collections.EMPTY_LIST;
}",0.9041533546325878
64179,"/** 
 * Fulfill the ResourceCollection contract.
 * @return whether this Resource is a FileProvider.
 */
public boolean isFilesystemOnly(){
  return getResource().isFilesystemOnly();
}","/** 
 * Fulfill the ResourceCollection contract.
 * @return whether this Resource is a FileProvider.
 */
public boolean isFilesystemOnly(){
  return false;
}",0.8973607038123167
64180,"/** 
 * Execute inside VM.
 * @param arg one JUnitTest
 * @throws BuildException under unspecified circumstances
 * @return the results
 */
private TestResultHolder executeInVM(JUnitTest arg) throws BuildException {
  JUnitTest test=(JUnitTest)arg.clone();
  test.setProperties(getProject().getProperties());
  if (dir != null) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  if (newEnvironment || null != env.getVariables()) {
    log(""String_Node_Str"" + ""String_Node_Str"",Project.MSG_WARN);
  }
  if (getCommandline().getBootclasspath() != null) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  CommandlineJava.SysProperties sysProperties=getCommandline().getSystemProperties();
  if (sysProperties != null) {
    sysProperties.setSystem();
  }
  try {
    log(""String_Node_Str"" + System.getProperties(),Project.MSG_VERBOSE);
    if (splitJunit) {
      classLoader=(AntClassLoader)delegate.getClass().getClassLoader();
    }
 else {
      createClassLoader();
    }
    if (classLoader != null) {
      classLoader.setThreadContextLoader();
    }
    runner=delegate.newJUnitTestRunner(test,test.getHaltonerror(),test.getFiltertrace(),test.getHaltonfailure(),false,true,classLoader);
    if (summary) {
      JUnitTaskMirror.SummaryJUnitResultFormatterMirror f=delegate.newSummaryJUnitResultFormatter();
      f.setWithOutAndErr(equalsWithOutAndErr(summaryValue));
      f.setOutput(getDefaultOutput());
      runner.addFormatter(f);
    }
    runner.setPermissions(perm);
    final FormatterElement[] feArray=mergeFormatters(test);
    for (int i=0; i < feArray.length; i++) {
      FormatterElement fe=feArray[i];
      if (fe.shouldUse(this)) {
        File outFile=getOutput(fe,test);
        if (outFile != null) {
          fe.setOutfile(outFile);
        }
 else {
          fe.setOutput(getDefaultOutput());
        }
        runner.addFormatter(fe.createFormatter(classLoader));
      }
    }
    runner.run();
    TestResultHolder result=new TestResultHolder();
    result.exitCode=runner.getRetCode();
    return result;
  }
  finally {
    if (sysProperties != null) {
      sysProperties.restoreSystem();
    }
    if (classLoader != null) {
      classLoader.resetThreadContextLoader();
    }
  }
}","/** 
 * Execute inside VM.
 * @param arg one JUnitTest
 * @throws BuildException under unspecified circumstances
 * @return the results
 */
private TestResultHolder executeInVM(JUnitTest arg) throws BuildException {
  if (delegate == null) {
    setupJUnitDelegate();
  }
  JUnitTest test=(JUnitTest)arg.clone();
  test.setProperties(getProject().getProperties());
  if (dir != null) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  if (newEnvironment || null != env.getVariables()) {
    log(""String_Node_Str"" + ""String_Node_Str"",Project.MSG_WARN);
  }
  if (getCommandline().getBootclasspath() != null) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  CommandlineJava.SysProperties sysProperties=getCommandline().getSystemProperties();
  if (sysProperties != null) {
    sysProperties.setSystem();
  }
  try {
    log(""String_Node_Str"" + System.getProperties(),Project.MSG_VERBOSE);
    if (splitJunit) {
      classLoader=(AntClassLoader)delegate.getClass().getClassLoader();
    }
 else {
      createClassLoader();
    }
    if (classLoader != null) {
      classLoader.setThreadContextLoader();
    }
    runner=delegate.newJUnitTestRunner(test,test.getHaltonerror(),test.getFiltertrace(),test.getHaltonfailure(),false,true,classLoader);
    if (summary) {
      JUnitTaskMirror.SummaryJUnitResultFormatterMirror f=delegate.newSummaryJUnitResultFormatter();
      f.setWithOutAndErr(equalsWithOutAndErr(summaryValue));
      f.setOutput(getDefaultOutput());
      runner.addFormatter(f);
    }
    runner.setPermissions(perm);
    final FormatterElement[] feArray=mergeFormatters(test);
    for (int i=0; i < feArray.length; i++) {
      FormatterElement fe=feArray[i];
      if (fe.shouldUse(this)) {
        File outFile=getOutput(fe,test);
        if (outFile != null) {
          fe.setOutfile(outFile);
        }
 else {
          fe.setOutput(getDefaultOutput());
        }
        runner.addFormatter(fe.createFormatter(classLoader));
      }
    }
    runner.run();
    TestResultHolder result=new TestResultHolder();
    result.exitCode=runner.getRetCode();
    return result;
  }
  finally {
    if (sysProperties != null) {
      sysProperties.restoreSystem();
    }
    if (classLoader != null) {
      classLoader.resetThreadContextLoader();
    }
  }
}",0.9875666074600356
64181,"/** 
 * Removes a classloader if needed.
 * @since Ant 1.7
 */
private void deleteClassLoader(){
  if (classLoader != null) {
    classLoader.cleanup();
    classLoader=null;
  }
}","/** 
 * Removes a classloader if needed.
 * @since Ant 1.7
 */
private void deleteClassLoader(){
  if (classLoader != null) {
    classLoader.cleanup();
    classLoader=null;
  }
  if (mirrorLoader instanceof SplitLoader) {
    ((SplitLoader)mirrorLoader).cleanup();
  }
  mirrorLoader=null;
}",0.7610993657505285
64182,"/** 
 * Take care that some output is produced in report files if the forked machine terminated before the test suite finished
 * @since Ant 1.7
 */
private void logVmExit(FormatterElement[] feArray,JUnitTest test,String message,String testCase){
  try {
    log(""String_Node_Str"" + System.getProperties(),Project.MSG_VERBOSE);
    if (splitJunit) {
      classLoader=(AntClassLoader)delegate.getClass().getClassLoader();
    }
 else {
      createClassLoader();
    }
    if (classLoader != null) {
      classLoader.setThreadContextLoader();
    }
    test.setCounts(1,0,1);
    test.setProperties(getProject().getProperties());
    for (int i=0; i < feArray.length; i++) {
      FormatterElement fe=feArray[i];
      File outFile=getOutput(fe,test);
      JUnitTaskMirror.JUnitResultFormatterMirror formatter=fe.createFormatter(classLoader);
      if (outFile != null && formatter != null) {
        try {
          OutputStream out=new FileOutputStream(outFile);
          delegate.addVmExit(test,formatter,out,message,testCase);
        }
 catch (        IOException e) {
        }
      }
    }
    if (summary) {
      JUnitTaskMirror.SummaryJUnitResultFormatterMirror f=delegate.newSummaryJUnitResultFormatter();
      f.setWithOutAndErr(""String_Node_Str"".equalsIgnoreCase(summaryValue));
      delegate.addVmExit(test,f,getDefaultOutput(),message,testCase);
    }
  }
  finally {
    if (classLoader != null) {
      classLoader.resetThreadContextLoader();
    }
  }
}","/** 
 * Take care that some output is produced in report files if the forked machine terminated before the test suite finished
 * @since Ant 1.7
 */
private void logVmExit(FormatterElement[] feArray,JUnitTest test,String message,String testCase){
  if (delegate == null) {
    setupJUnitDelegate();
  }
  try {
    log(""String_Node_Str"" + System.getProperties(),Project.MSG_VERBOSE);
    if (splitJunit) {
      classLoader=(AntClassLoader)delegate.getClass().getClassLoader();
    }
 else {
      createClassLoader();
    }
    if (classLoader != null) {
      classLoader.setThreadContextLoader();
    }
    test.setCounts(1,0,1);
    test.setProperties(getProject().getProperties());
    for (int i=0; i < feArray.length; i++) {
      FormatterElement fe=feArray[i];
      File outFile=getOutput(fe,test);
      JUnitTaskMirror.JUnitResultFormatterMirror formatter=fe.createFormatter(classLoader);
      if (outFile != null && formatter != null) {
        try {
          OutputStream out=new FileOutputStream(outFile);
          delegate.addVmExit(test,formatter,out,message,testCase);
        }
 catch (        IOException e) {
        }
      }
    }
    if (summary) {
      JUnitTaskMirror.SummaryJUnitResultFormatterMirror f=delegate.newSummaryJUnitResultFormatter();
      f.setWithOutAndErr(""String_Node_Str"".equalsIgnoreCase(summaryValue));
      delegate.addVmExit(test,f,getDefaultOutput(),message,testCase);
    }
  }
  finally {
    if (classLoader != null) {
      classLoader.resetThreadContextLoader();
    }
  }
}",0.9813953488372092
64183,"private void validate() throws BuildException {
  if (file != null) {
    if (srcDir != null) {
      throw new BuildException(ERROR_FILE_AND_SRCDIR);
    }
    fileset.setFile(file);
    srcDir=file.getParentFile();
  }
  if (srcDir == null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (!srcDir.exists()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (!srcDir.isDirectory()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destDir != null) {
    if (!destDir.exists()) {
      throw new BuildException(""String_Node_Str"");
    }
    if (!destDir.isDirectory()) {
      throw new BuildException(""String_Node_Str"");
    }
  }
}","private void validate() throws BuildException {
  if (file != null) {
    if (srcDir != null) {
      throw new BuildException(ERROR_FILE_AND_SRCDIR);
    }
    fileset.setFile(file);
    srcDir=file.getParentFile();
  }
  if (srcDir == null) {
    throw new BuildException(FIXCRLF_ERROR + ""String_Node_Str"");
  }
  if (!srcDir.exists()) {
    throw new BuildException(FIXCRLF_ERROR + ""String_Node_Str"" + srcDir+ ""String_Node_Str"");
  }
  if (!srcDir.isDirectory()) {
    throw new BuildException(FIXCRLF_ERROR + ""String_Node_Str"" + srcDir+ ""String_Node_Str"");
  }
  if (destDir != null) {
    if (!destDir.exists()) {
      throw new BuildException(FIXCRLF_ERROR + ""String_Node_Str"" + destDir+ ""String_Node_Str"");
    }
    if (!destDir.isDirectory()) {
      throw new BuildException(FIXCRLF_ERROR + ""String_Node_Str"" + destDir+ ""String_Node_Str"");
    }
  }
}",0.873202614379085
64184,"public Object evaluate(String property,PropertyHelper propertyHelper){
  Stack stk=(Stack)getStack.get();
  if (stk.contains(property)) {
    return null;
  }
  stk.push(property);
  try {
    if (propertyHelper.getProperty(property) != null) {
      return null;
    }
  }
  finally {
    stk.pop();
  }
  Object value=map.get(property);
  if (!(value instanceof String)) {
    return null;
  }
  stk=(Stack)replaceStack.get();
  if (stk.contains(property)) {
    throw new BuildException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  stk.push(property);
  try {
    return propertyHelper.replaceProperties((String)value);
  }
  finally {
    stk.pop();
  }
}","public Object evaluate(String property,PropertyHelper propertyHelper){
  Stack stk=(Stack)getStack.get();
  if (stk.contains(property)) {
    return null;
  }
  stk.push(property);
  try {
    if (propertyHelper.getProperty(property) != null) {
      return null;
    }
  }
  finally {
    stk.pop();
  }
  Object value=map.get(property);
  if (!(value instanceof String)) {
    return null;
  }
  stk=(Stack)replaceStack.get();
  if (stk.contains(property)) {
    throw new BuildException(""String_Node_Str"" + property + ""String_Node_Str"");
  }
  stk.push(property);
  try {
    return propertyHelper.replaceProperties((String)value);
  }
  finally {
    stk.pop();
  }
}",0.9910313901345292
64185,"private boolean hasPatterns(PatternSet ps){
  return ps.getIncludePatterns(getProject()).length > 0 || ps.getExcludePatterns(getProject()).length > 0;
}","private boolean hasPatterns(PatternSet ps){
  String[] includePatterns=ps.getIncludePatterns(getProject());
  String[] excludePatterns=ps.getExcludePatterns(getProject());
  return (includePatterns != null && includePatterns.length > 0) || (includePatterns != null && excludePatterns.length > 0);
}",0.5511111111111111
64186,"/** 
 * Constructs a file path from a <code>file:</code> URI. <p>Will be an absolute path if the given URI is absolute.</p> <p>Prior to Java 1.4, swallows '%' that are not followed by two characters.</p> See <a href=""http://www.w3.org/TR/xml11/#dt-sysid"">dt-sysid</a> which makes some mention of how characters not supported by URI Reference syntax should be escaped.
 * @param uri the URI designating a file in the local filesystem.
 * @return the local file system path for the file.
 * @throws IllegalArgumentException if the URI is malformed or not a legal file: URL
 * @since Ant 1.6
 */
public static String fromURI(String uri){
  Class uriClazz=null;
  try {
    uriClazz=Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException cnfe) {
  }
  if (uriClazz != null && uri.startsWith(""String_Node_Str"")) {
    try {
      java.lang.reflect.Method createMethod=uriClazz.getMethod(""String_Node_Str"",new Class[]{String.class});
      Object uriObj=createMethod.invoke(null,new Object[]{uri});
      java.lang.reflect.Constructor fileConst=File.class.getConstructor(new Class[]{uriClazz});
      File f=(File)fileConst.newInstance(new Object[]{uriObj});
      return f.getAbsolutePath();
    }
 catch (    java.lang.reflect.InvocationTargetException e) {
      Throwable e2=e.getTargetException();
      if (e2 instanceof IllegalArgumentException) {
        throw (IllegalArgumentException)e2;
      }
 else {
        e2.printStackTrace();
      }
    }
catch (    Exception e) {
      e.printStackTrace();
    }
  }
  URL url=null;
  try {
    url=new URL(uri);
  }
 catch (  MalformedURLException emYouEarlEx) {
  }
  if (url == null || !(""String_Node_Str"".equals(url.getProtocol()))) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  StringBuffer buf=new StringBuffer(url.getHost());
  if (buf.length() > 0) {
    buf.insert(0,File.separatorChar).insert(0,File.separatorChar);
  }
  String file=url.getFile();
  int queryPos=file.indexOf('?');
  buf.append((queryPos < 0) ? file : file.substring(0,queryPos));
  uri=buf.toString().replace('/',File.separatorChar);
  if (File.pathSeparatorChar == ';' && uri.startsWith(""String_Node_Str"") && uri.length() > 2 && Character.isLetter(uri.charAt(1)) && uri.lastIndexOf(':') > -1) {
    uri=uri.substring(1);
  }
  String path=null;
  try {
    path=decodeUri(uri);
    String cwd=System.getProperty(""String_Node_Str"");
    int posi=cwd.indexOf(""String_Node_Str"");
    if ((posi > 0) && path.startsWith(File.separator)) {
      path=cwd.substring(0,posi + 1) + path;
    }
  }
 catch (  UnsupportedEncodingException exc) {
    throw new IllegalStateException(""String_Node_Str"" + exc.getMessage());
  }
  return path;
}","/** 
 * Constructs a file path from a <code>file:</code> URI. <p>Will be an absolute path if the given URI is absolute.</p> <p>Prior to Java 1.4, swallows '%' that are not followed by two characters.</p> See <a href=""http://www.w3.org/TR/xml11/#dt-sysid"">dt-sysid</a> which makes some mention of how characters not supported by URI Reference syntax should be escaped.
 * @param uri the URI designating a file in the local filesystem.
 * @return the local file system path for the file.
 * @throws IllegalArgumentException if the URI is malformed or not a legal file: URL
 * @since Ant 1.6
 */
public static String fromURI(String uri){
  Class uriClazz=null;
  try {
    uriClazz=Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException cnfe) {
  }
  if (uriClazz != null && uri.startsWith(""String_Node_Str"")) {
    try {
      java.lang.reflect.Method createMethod=uriClazz.getMethod(""String_Node_Str"",new Class[]{String.class});
      Object uriObj=createMethod.invoke(null,new Object[]{encodeURI(uri)});
      java.lang.reflect.Constructor fileConst=File.class.getConstructor(new Class[]{uriClazz});
      File f=(File)fileConst.newInstance(new Object[]{uriObj});
      return f.getAbsolutePath();
    }
 catch (    java.lang.reflect.InvocationTargetException e) {
      Throwable e2=e.getTargetException();
      if (e2 instanceof IllegalArgumentException) {
        throw (IllegalArgumentException)e2;
      }
 else {
        e2.printStackTrace();
      }
    }
catch (    Exception e) {
      e.printStackTrace();
    }
  }
  URL url=null;
  try {
    url=new URL(uri);
  }
 catch (  MalformedURLException emYouEarlEx) {
  }
  if (url == null || !(""String_Node_Str"".equals(url.getProtocol()))) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  StringBuffer buf=new StringBuffer(url.getHost());
  if (buf.length() > 0) {
    buf.insert(0,File.separatorChar).insert(0,File.separatorChar);
  }
  String file=url.getFile();
  int queryPos=file.indexOf('?');
  buf.append((queryPos < 0) ? file : file.substring(0,queryPos));
  uri=buf.toString().replace('/',File.separatorChar);
  if (File.pathSeparatorChar == ';' && uri.startsWith(""String_Node_Str"") && uri.length() > 2 && Character.isLetter(uri.charAt(1)) && uri.lastIndexOf(':') > -1) {
    uri=uri.substring(1);
  }
  String path=null;
  try {
    path=decodeUri(uri);
    String cwd=System.getProperty(""String_Node_Str"");
    int posi=cwd.indexOf(""String_Node_Str"");
    if ((posi > 0) && path.startsWith(File.separator)) {
      path=cwd.substring(0,posi + 1) + path;
    }
  }
 catch (  UnsupportedEncodingException exc) {
    throw new IllegalStateException(""String_Node_Str"" + exc.getMessage());
  }
  return path;
}",0.996853599851934
64187,"/** 
 * Constructs a file path from a <code>file:</code> URI. <p>Will be an absolute path if the given URI is absolute.</p> <p>Prior to Java 1.4, swallows '%' that are not followed by two characters.</p> See <a href=""http://www.w3.org/TR/xml11/#dt-sysid"">dt-sysid</a> which makes some mention of how characters not supported by URI Reference syntax should be escaped.
 * @param uri the URI designating a file in the local filesystem.
 * @return the local file system path for the file.
 * @throws IllegalArgumentException if the URI is malformed or not a legal file: URL
 * @since Ant 1.6
 */
public static String fromURI(String uri){
  Class uriClazz=null;
  try {
    uriClazz=Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException cnfe) {
  }
  if (uriClazz != null && uri.startsWith(""String_Node_Str"")) {
    try {
      java.lang.reflect.Method createMethod=uriClazz.getMethod(""String_Node_Str"",new Class[]{String.class});
      Object uriObj=createMethod.invoke(null,new Object[]{encodeURI(uri)});
      java.lang.reflect.Constructor fileConst=File.class.getConstructor(new Class[]{uriClazz});
      File f=(File)fileConst.newInstance(new Object[]{uriObj});
      return f.getAbsolutePath();
    }
 catch (    java.lang.reflect.InvocationTargetException e) {
      Throwable e2=e.getTargetException();
      if (e2 instanceof IllegalArgumentException) {
        throw (IllegalArgumentException)e2;
      }
 else {
        e2.printStackTrace();
      }
    }
catch (    Exception e) {
      e.printStackTrace();
    }
  }
  URL url=null;
  try {
    url=new URL(uri);
  }
 catch (  MalformedURLException emYouEarlEx) {
  }
  if (url == null || !(""String_Node_Str"".equals(url.getProtocol()))) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  StringBuffer buf=new StringBuffer(url.getHost());
  if (buf.length() > 0) {
    buf.insert(0,File.separatorChar).insert(0,File.separatorChar);
  }
  String file=url.getFile();
  int queryPos=file.indexOf('?');
  buf.append((queryPos < 0) ? file : file.substring(0,queryPos));
  uri=buf.toString().replace('/',File.separatorChar);
  if (File.pathSeparatorChar == ';' && uri.startsWith(""String_Node_Str"") && uri.length() > 2 && Character.isLetter(uri.charAt(1)) && uri.lastIndexOf(':') > -1) {
    uri=uri.substring(1);
  }
  String path=null;
  try {
    path=decodeUri(uri);
    String cwd=System.getProperty(""String_Node_Str"");
    int posi=cwd.indexOf(""String_Node_Str"");
    if ((posi > 0) && path.startsWith(File.separator)) {
      path=cwd.substring(0,posi + 1) + path;
    }
  }
 catch (  UnsupportedEncodingException exc) {
    throw new IllegalStateException(""String_Node_Str"" + exc.getMessage());
  }
  return path;
}","/** 
 * Constructs a file path from a <code>file:</code> URI. <p>Will be an absolute path if the given URI is absolute.</p> <p>Prior to Java 1.4, swallows '%' that are not followed by two characters.</p> See <a href=""http://www.w3.org/TR/xml11/#dt-sysid"">dt-sysid</a> which makes some mention of how characters not supported by URI Reference syntax should be escaped.
 * @param uri the URI designating a file in the local filesystem.
 * @return the local file system path for the file.
 * @throws IllegalArgumentException if the URI is malformed or not a legal file: URL
 * @since Ant 1.6
 */
public static String fromURI(String uri){
  Class uriClazz=null;
  try {
    uriClazz=Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException cnfe) {
  }
  if (uriClazz != null && uri.startsWith(""String_Node_Str"")) {
    try {
      java.lang.reflect.Method createMethod=uriClazz.getMethod(""String_Node_Str"",new Class[]{String.class});
      Object uriObj=createMethod.invoke(null,new Object[]{encodeURI(uri)});
      java.lang.reflect.Constructor fileConst=File.class.getConstructor(new Class[]{uriClazz});
      File f=(File)fileConst.newInstance(new Object[]{uriObj});
      return decodeUri(f.getAbsolutePath());
    }
 catch (    java.lang.reflect.InvocationTargetException e) {
      Throwable e2=e.getTargetException();
      if (e2 instanceof IllegalArgumentException) {
        throw (IllegalArgumentException)e2;
      }
 else {
        e2.printStackTrace();
      }
    }
catch (    Exception e) {
      e.printStackTrace();
    }
  }
  URL url=null;
  try {
    url=new URL(uri);
  }
 catch (  MalformedURLException emYouEarlEx) {
  }
  if (url == null || !(""String_Node_Str"".equals(url.getProtocol()))) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  StringBuffer buf=new StringBuffer(url.getHost());
  if (buf.length() > 0) {
    buf.insert(0,File.separatorChar).insert(0,File.separatorChar);
  }
  String file=url.getFile();
  int queryPos=file.indexOf('?');
  buf.append((queryPos < 0) ? file : file.substring(0,queryPos));
  uri=buf.toString().replace('/',File.separatorChar);
  if (File.pathSeparatorChar == ';' && uri.startsWith(""String_Node_Str"") && uri.length() > 2 && Character.isLetter(uri.charAt(1)) && uri.lastIndexOf(':') > -1) {
    uri=uri.substring(1);
  }
  String path=null;
  try {
    path=decodeUri(uri);
    String cwd=System.getProperty(""String_Node_Str"");
    int posi=cwd.indexOf(""String_Node_Str"");
    if ((posi > 0) && path.startsWith(File.separator)) {
      path=cwd.substring(0,posi + 1) + path;
    }
  }
 catch (  UnsupportedEncodingException exc) {
    throw new IllegalStateException(""String_Node_Str"" + exc.getMessage());
  }
  return path;
}",0.9979723502304148
64188,"/** 
 * Logs a message, if the priority is suitable. In non-emacs mode, task level messages are prefixed by the task name which is right-justified.
 * @param event A BuildEvent containing message information.Must not be <code>null</code>.
 */
public void messageLogged(BuildEvent event){
  int priority=event.getPriority();
  if (priority <= msgOutputLevel) {
    StringBuffer message=new StringBuffer();
    if (event.getTask() != null && !emacsMode) {
      String name=event.getTask().getTaskName();
      String label=""String_Node_Str"" + name + ""String_Node_Str"";
      int size=LEFT_COLUMN_SIZE - label.length();
      StringBuffer tmp=new StringBuffer();
      for (int i=0; i < size; i++) {
        tmp.append(""String_Node_Str"");
      }
      tmp.append(label);
      label=tmp.toString();
      try {
        BufferedReader r=new BufferedReader(new StringReader(event.getMessage()));
        String line=r.readLine();
        boolean first=true;
        while (line != null) {
          if (!first) {
            message.append(StringUtils.LINE_SEP);
          }
          first=false;
          message.append(label).append(line);
          line=r.readLine();
        }
      }
 catch (      IOException e) {
        message.append(label).append(event.getMessage());
      }
    }
 else {
      message.append(event.getMessage());
    }
    String msg=message.toString();
    if (priority != Project.MSG_ERR) {
      printMessage(msg,out,priority);
    }
 else {
      printMessage(msg,err,priority);
    }
    log(msg);
  }
}","/** 
 * Logs a message, if the priority is suitable. In non-emacs mode, task level messages are prefixed by the task name which is right-justified.
 * @param event A BuildEvent containing message information.Must not be <code>null</code>.
 */
public void messageLogged(BuildEvent event){
  int priority=event.getPriority();
  if (priority <= msgOutputLevel) {
    StringBuffer message=new StringBuffer();
    if (event.getTask() != null && !emacsMode) {
      String name=event.getTask().getTaskName();
      String label=""String_Node_Str"" + name + ""String_Node_Str"";
      int size=LEFT_COLUMN_SIZE - label.length();
      StringBuffer tmp=new StringBuffer();
      for (int i=0; i < size; i++) {
        tmp.append(""String_Node_Str"");
      }
      tmp.append(label);
      label=tmp.toString();
      try {
        BufferedReader r=new BufferedReader(new StringReader(event.getMessage()));
        String line=r.readLine();
        boolean first=true;
        do {
          if (first) {
            if (line == null) {
              message.append(label);
              break;
            }
          }
 else {
            message.append(StringUtils.LINE_SEP);
          }
          first=false;
          message.append(label).append(line);
          line=r.readLine();
        }
 while (line != null);
      }
 catch (      IOException e) {
        message.append(label).append(event.getMessage());
      }
    }
 else {
      message.append(event.getMessage());
    }
    String msg=message.toString();
    if (priority != Project.MSG_ERR) {
      printMessage(msg,out,priority);
    }
 else {
      printMessage(msg,err,priority);
    }
    log(msg);
  }
}",0.943125
64189,"public void test1(){
  expectLog(""String_Node_Str"",""String_Node_Str"");
}","public void test1(){
  expectLog(""String_Node_Str"",""String_Node_Str"");
  expectOutput(""String_Node_Str"",""String_Node_Str"");
}",0.7309644670050761
64190,"/** 
 * Configures the wrapped element.  The attributes and text for the wrapped element are configured.  Each time the wrapper is configured, the attributes and text for it are reset. If the element has an <code>id</code> attribute, a reference is added to the project as well.
 * @param p The project containing the wrapped element.Must not be <code>null</code>.
 * @param configureChildren Whether to configure child elements aswell.  if true, child elements will be configured after the wrapped element.
 * @exception BuildException if the configuration fails, for instance dueto invalid attributes or children, or text being added to an element which doesn't accept it.
 */
public synchronized void maybeConfigure(Project p,boolean configureChildren) throws BuildException {
  if (proxyConfigured) {
    return;
  }
  Object target=(wrappedObject instanceof TypeAdapter) ? ((TypeAdapter)wrappedObject).getProxy() : wrappedObject;
  IntrospectionHelper ih=IntrospectionHelper.getHelper(p,target.getClass());
  if (attributeNames != null) {
    for (int i=0; i < attributeNames.size(); i++) {
      String name=(String)attributeNames.get(i);
      String value=(String)attributeMap.get(name);
      value=p.replaceProperties(value);
      try {
        ih.setAttribute(p,target,name,value);
      }
 catch (      UnsupportedAttributeException be) {
        if (name.equals(""String_Node_Str"")) {
        }
 else         if (getElementTag() == null) {
          throw be;
        }
 else {
          throw new BuildException(getElementTag() + ""String_Node_Str"" + be.getAttribute()+ ""String_Node_Str"",be);
        }
      }
catch (      BuildException be) {
        if (name.equals(""String_Node_Str"")) {
        }
 else {
          throw be;
        }
      }
    }
  }
  if (characters != null) {
    ProjectHelper.addText(p,wrappedObject,characters.substring(0));
  }
  Enumeration e=getChildren();
  while (e.hasMoreElements()) {
    RuntimeConfigurable child=(RuntimeConfigurable)e.nextElement();
synchronized (child) {
      if (child.wrappedObject instanceof Task) {
        Task childTask=(Task)child.wrappedObject;
        childTask.setRuntimeConfigurableWrapper(child);
      }
      if ((child.creator != null) && configureChildren) {
        child.maybeConfigure(p);
        child.creator.store();
        continue;
      }
      String tag=child.getElementTag().toLowerCase(Locale.US);
      if (configureChildren && ih.supportsNestedElement(tag)) {
        child.maybeConfigure(p);
        ProjectHelper.storeChild(p,target,child.wrappedObject,tag);
      }
    }
  }
  if (id != null) {
    p.addReference(id,wrappedObject);
  }
  proxyConfigured=true;
}","/** 
 * Configures the wrapped element.  The attributes and text for the wrapped element are configured.  Each time the wrapper is configured, the attributes and text for it are reset. If the element has an <code>id</code> attribute, a reference is added to the project as well.
 * @param p The project containing the wrapped element.Must not be <code>null</code>.
 * @param configureChildren ignored.
 * @exception BuildException if the configuration fails, for instance dueto invalid attributes , or text being added to an element which doesn't accept it.
 */
public synchronized void maybeConfigure(Project p,boolean configureChildren) throws BuildException {
  if (proxyConfigured) {
    return;
  }
  Object target=(wrappedObject instanceof TypeAdapter) ? ((TypeAdapter)wrappedObject).getProxy() : wrappedObject;
  IntrospectionHelper ih=IntrospectionHelper.getHelper(p,target.getClass());
  if (attributeNames != null) {
    for (int i=0; i < attributeNames.size(); i++) {
      String name=(String)attributeNames.get(i);
      String value=(String)attributeMap.get(name);
      value=p.replaceProperties(value);
      try {
        ih.setAttribute(p,target,name,value);
      }
 catch (      UnsupportedAttributeException be) {
        if (name.equals(""String_Node_Str"")) {
        }
 else         if (getElementTag() == null) {
          throw be;
        }
 else {
          throw new BuildException(getElementTag() + ""String_Node_Str"" + be.getAttribute()+ ""String_Node_Str"",be);
        }
      }
catch (      BuildException be) {
        if (name.equals(""String_Node_Str"")) {
        }
 else {
          throw be;
        }
      }
    }
  }
  if (characters != null) {
    ProjectHelper.addText(p,wrappedObject,characters.substring(0));
  }
  if (id != null) {
    p.addReference(id,wrappedObject);
  }
  proxyConfigured=true;
}",0.813220940550133
64191,"/** 
 * Try to create a nested element of <code>parent</code> for the given tag.
 * @return whether the creation has been successful
 */
private boolean handleChild(String parentUri,IntrospectionHelper ih,Object parent,UnknownElement child,RuntimeConfigurable childWrapper){
  String childName=ProjectHelper.genComponentName(child.getNamespace(),child.getTag());
  if (ih.supportsNestedElement(parentUri,childName)) {
    IntrospectionHelper.Creator creator=ih.getElementCreator(getProject(),parentUri,parent,childName,child);
    creator.setPolyType(childWrapper.getPolyType());
    Object realChild=creator.create();
    if (realChild instanceof PreSetDef.PreSetDefinition) {
      PreSetDef.PreSetDefinition def=(PreSetDef.PreSetDefinition)realChild;
      realChild=creator.getRealObject();
      child.applyPreSet(def.getPreSets());
    }
    childWrapper.setCreator(creator);
    childWrapper.setProxy(realChild);
    if (realChild instanceof Task) {
      Task childTask=(Task)realChild;
      childTask.setRuntimeConfigurableWrapper(childWrapper);
      childTask.setTaskName(childName);
      childTask.setTaskType(childName);
    }
    if (realChild instanceof ProjectComponent) {
      ((ProjectComponent)realChild).setLocation(child.getLocation());
    }
    child.handleChildren(realChild,childWrapper);
    return true;
  }
  return false;
}","/** 
 * Try to create a nested element of <code>parent</code> for the given tag.
 * @return whether the creation has been successful
 */
private boolean handleChild(String parentUri,IntrospectionHelper ih,Object parent,UnknownElement child,RuntimeConfigurable childWrapper){
  String childName=ProjectHelper.genComponentName(child.getNamespace(),child.getTag());
  if (ih.supportsNestedElement(parentUri,childName)) {
    IntrospectionHelper.Creator creator=ih.getElementCreator(getProject(),parentUri,parent,childName,child);
    creator.setPolyType(childWrapper.getPolyType());
    Object realChild=creator.create();
    if (realChild instanceof PreSetDef.PreSetDefinition) {
      PreSetDef.PreSetDefinition def=(PreSetDef.PreSetDefinition)realChild;
      realChild=creator.getRealObject();
      child.applyPreSet(def.getPreSets());
    }
    childWrapper.setCreator(creator);
    childWrapper.setProxy(realChild);
    if (realChild instanceof Task) {
      Task childTask=(Task)realChild;
      childTask.setRuntimeConfigurableWrapper(childWrapper);
      childTask.setTaskName(childName);
      childTask.setTaskType(childName);
    }
    if (realChild instanceof ProjectComponent) {
      ((ProjectComponent)realChild).setLocation(child.getLocation());
    }
    childWrapper.maybeConfigure(getProject());
    child.handleChildren(realChild,childWrapper);
    creator.store();
    return true;
  }
  return false;
}",0.9755219582433404
64192,"/** 
 * Configure the given object from this UnknownElement
 * @param realObject the real object this UnknownElement is representing.
 */
public void configure(Object realObject){
  realThing=realObject;
  getWrapper().setProxy(realThing);
  Task task=null;
  if (realThing instanceof Task) {
    task=(Task)realThing;
    task.setRuntimeConfigurableWrapper(getWrapper());
    if (getWrapper().getId() != null) {
      this.getOwningTarget().replaceChild(this,(Task)realThing);
    }
  }
  handleChildren(realThing,getWrapper());
  if (task != null) {
    task.maybeConfigure();
  }
 else {
    getWrapper().maybeConfigure(getProject());
  }
}","/** 
 * Configure the given object from this UnknownElement
 * @param realObject the real object this UnknownElement is representing.
 */
public void configure(Object realObject){
  realThing=realObject;
  getWrapper().setProxy(realThing);
  Task task=null;
  if (realThing instanceof Task) {
    task=(Task)realThing;
    task.setRuntimeConfigurableWrapper(getWrapper());
    if (getWrapper().getId() != null) {
      this.getOwningTarget().replaceChild(this,(Task)realThing);
    }
  }
  if (task != null) {
    task.maybeConfigure();
  }
 else {
    getWrapper().maybeConfigure(getProject());
  }
  handleChildren(realThing,getWrapper());
}",0.9346811819595644
64193,"/** 
 * Returns an enumeration of URLs representing all the resources with the given name by searching the class loader's classpath.
 * @param name The resource name to search for.Must not be <code>null</code>.
 * @return an enumeration of URLs for the resources
 * @exception IOException if I/O errors occurs (can't happen)
 */
protected Enumeration findResources(String name) throws IOException {
  Enumeration mine=new ResourceEnumeration(name);
  Enumeration base;
  if (parent != null && parent != getParent()) {
    base=parent.getResources(name);
  }
 else {
    base=new CollectionUtils.EmptyEnumeration();
  }
  if (isParentFirst(name)) {
    return CollectionUtils.append(base,mine);
  }
 else   if (isolated) {
    return mine;
  }
 else {
    return CollectionUtils.append(mine,base);
  }
}","/** 
 * Returns an enumeration of URLs representing all the resources with the given name by searching the class loader's classpath.
 * @param name The resource name to search for.Must not be <code>null</code>.
 * @return an enumeration of URLs for the resources
 * @exception IOException if I/O errors occurs (can't happen)
 */
protected Enumeration findResources(String name) throws IOException {
  Enumeration mine=new ResourceEnumeration(name);
  Enumeration base;
  if (parent != null && parent != getParent()) {
    base=parent.getResources(name);
  }
 else {
    base=new CollectionUtils.EmptyEnumeration();
  }
  if (isParentFirst(name)) {
    return CollectionUtils.append(base,mine);
  }
 else {
    return CollectionUtils.append(mine,base);
  }
}",0.971135343168698
64194,"/** 
 * Loads a class with this class loader. This class attempts to load the class in an order determined by whether or not the class matches the system/loader package lists, with the loader package list taking priority. If the classloader is in isolated mode, failure to load the class in this loader will result in a ClassNotFoundException.
 * @param classname The name of the class to be loaded.Must not be <code>null</code>.
 * @param resolve <code>true</code> if all classes upon which this classdepends are to be loaded.
 * @return the required Class object
 * @exception ClassNotFoundException if the requested class does not existon the system classpath (when not in isolated mode) or this loader's classpath.
 */
protected synchronized Class loadClass(String classname,boolean resolve) throws ClassNotFoundException {
  Class theClass=findLoadedClass(classname);
  if (theClass != null) {
    return theClass;
  }
  if (isParentFirst(classname)) {
    try {
      theClass=findBaseClass(classname);
      log(""String_Node_Str"" + classname + ""String_Node_Str""+ ""String_Node_Str"",Project.MSG_DEBUG);
    }
 catch (    ClassNotFoundException cnfe) {
      theClass=findClass(classname);
      log(""String_Node_Str"" + classname + ""String_Node_Str""+ ""String_Node_Str"",Project.MSG_DEBUG);
    }
  }
 else {
    try {
      theClass=findClass(classname);
      log(""String_Node_Str"" + classname + ""String_Node_Str"",Project.MSG_DEBUG);
    }
 catch (    ClassNotFoundException cnfe) {
      if (isolated) {
        throw cnfe;
      }
      theClass=findBaseClass(classname);
      log(""String_Node_Str"" + classname + ""String_Node_Str"",Project.MSG_DEBUG);
    }
  }
  if (resolve) {
    resolveClass(theClass);
  }
  return theClass;
}","/** 
 * Loads a class with this class loader. This class attempts to load the class in an order determined by whether or not the class matches the system/loader package lists, with the loader package list taking priority. If the classloader is in isolated mode, failure to load the class in this loader will result in a ClassNotFoundException.
 * @param classname The name of the class to be loaded.Must not be <code>null</code>.
 * @param resolve <code>true</code> if all classes upon which this classdepends are to be loaded.
 * @return the required Class object
 * @exception ClassNotFoundException if the requested class does not existon the system classpath (when not in isolated mode) or this loader's classpath.
 */
protected synchronized Class loadClass(String classname,boolean resolve) throws ClassNotFoundException {
  Class theClass=findLoadedClass(classname);
  if (theClass != null) {
    return theClass;
  }
  if (isParentFirst(classname)) {
    try {
      theClass=findBaseClass(classname);
      log(""String_Node_Str"" + classname + ""String_Node_Str""+ ""String_Node_Str"",Project.MSG_DEBUG);
    }
 catch (    ClassNotFoundException cnfe) {
      theClass=findClass(classname);
      log(""String_Node_Str"" + classname + ""String_Node_Str""+ ""String_Node_Str"",Project.MSG_DEBUG);
    }
  }
 else {
    try {
      theClass=findClass(classname);
      log(""String_Node_Str"" + classname + ""String_Node_Str"",Project.MSG_DEBUG);
    }
 catch (    ClassNotFoundException cnfe) {
      if (ignoreBase) {
        throw cnfe;
      }
      theClass=findBaseClass(classname);
      log(""String_Node_Str"" + classname + ""String_Node_Str"",Project.MSG_DEBUG);
    }
  }
  if (resolve) {
    resolveClass(theClass);
  }
  return theClass;
}",0.995397008055236
64195,"/** 
 * Sets whether this classloader should run in isolated mode. In isolated mode, classes not found on the given classpath will not be referred to the parent class loader but will cause a ClassNotFoundException.
 * @param isolated Whether or not this classloader should run inisolated mode.
 */
public synchronized void setIsolated(boolean isolated){
  this.isolated=isolated;
}","/** 
 * Sets whether this classloader should run in isolated mode. In isolated mode, classes not found on the given classpath will not be referred to the parent class loader but will cause a ClassNotFoundException.
 * @param isolated Whether or not this classloader should run inisolated mode.
 */
public synchronized void setIsolated(boolean isolated){
  ignoreBase=isolated;
}",0.9696969696969696
64196,"/** 
 * Delete a directory
 * @param d the directory to delete
 */
protected void removeDir(File d){
  String[] list=d.list();
  if (list == null) {
    list=new String[0];
  }
  for (int i=0; i < list.length; i++) {
    String s=list[i];
    File f=new File(d,s);
    if (f.isDirectory()) {
      removeDir(f);
    }
 else {
      log(""String_Node_Str"" + f.getAbsolutePath(),verbosity);
      if (!delete(f)) {
        handle(""String_Node_Str"" + f.getAbsolutePath());
      }
    }
  }
  log(""String_Node_Str"" + d.getAbsolutePath(),verbosity);
  if (!delete(d)) {
    handle(""String_Node_Str"" + dir.getAbsolutePath());
  }
}","/** 
 * Delete a directory
 * @param d the directory to delete
 */
protected void removeDir(File d){
  String[] list=d.list();
  if (list == null) {
    list=new String[0];
  }
  for (int i=0; i < list.length; i++) {
    String s=list[i];
    File f=new File(d,s);
    if (f.isDirectory()) {
      removeDir(f);
    }
 else {
      log(""String_Node_Str"" + f.getAbsolutePath(),quiet ? Project.MSG_VERBOSE : verbosity);
      if (!delete(f)) {
        handle(""String_Node_Str"" + f.getAbsolutePath());
      }
    }
  }
  log(""String_Node_Str"" + d.getAbsolutePath(),verbosity);
  if (!delete(d)) {
    handle(""String_Node_Str"" + dir.getAbsolutePath());
  }
}",0.9765625
64197,"/** 
 * remove an array of files in a directory, and a list of subdirectories which will only be deleted if 'includeEmpty' is true
 * @param d directory to work from
 * @param files array of files to delete; can be of zero length
 * @param dirs array of directories to delete; can of zero length
 */
protected void removeFiles(File d,String[] files,String[] dirs){
  if (files.length > 0) {
    log(""String_Node_Str"" + files.length + ""String_Node_Str""+ d.getAbsolutePath());
    for (int j=0; j < files.length; j++) {
      File f=new File(d,files[j]);
      log(""String_Node_Str"" + f.getAbsolutePath(),verbosity);
      if (!delete(f)) {
        handle(""String_Node_Str"" + f.getAbsolutePath());
      }
    }
  }
  if (dirs.length > 0 && includeEmpty) {
    int dirCount=0;
    for (int j=dirs.length - 1; j >= 0; j--) {
      File currDir=new File(d,dirs[j]);
      String[] dirFiles=currDir.list();
      if (dirFiles == null || dirFiles.length == 0) {
        log(""String_Node_Str"" + currDir.getAbsolutePath(),verbosity);
        if (!delete(currDir)) {
          handle(""String_Node_Str"" + currDir.getAbsolutePath());
        }
 else {
          dirCount++;
        }
      }
    }
    if (dirCount > 0) {
      log(""String_Node_Str"" + dirCount + ""String_Node_Str""+ (dirCount == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ d.getAbsolutePath());
    }
  }
}","/** 
 * remove an array of files in a directory, and a list of subdirectories which will only be deleted if 'includeEmpty' is true
 * @param d directory to work from
 * @param files array of files to delete; can be of zero length
 * @param dirs array of directories to delete; can of zero length
 */
protected void removeFiles(File d,String[] files,String[] dirs){
  if (files.length > 0) {
    log(""String_Node_Str"" + files.length + ""String_Node_Str""+ d.getAbsolutePath(),quiet ? Project.MSG_VERBOSE : verbosity);
    for (int j=0; j < files.length; j++) {
      File f=new File(d,files[j]);
      log(""String_Node_Str"" + f.getAbsolutePath(),quiet ? Project.MSG_VERBOSE : verbosity);
      if (!delete(f)) {
        handle(""String_Node_Str"" + f.getAbsolutePath());
      }
    }
  }
  if (dirs.length > 0 && includeEmpty) {
    int dirCount=0;
    for (int j=dirs.length - 1; j >= 0; j--) {
      File currDir=new File(d,dirs[j]);
      String[] dirFiles=currDir.list();
      if (dirFiles == null || dirFiles.length == 0) {
        log(""String_Node_Str"" + currDir.getAbsolutePath(),quiet ? Project.MSG_VERBOSE : verbosity);
        if (!delete(currDir)) {
          handle(""String_Node_Str"" + currDir.getAbsolutePath());
        }
 else {
          dirCount++;
        }
      }
    }
    if (dirCount > 0) {
      log(""String_Node_Str"" + dirCount + ""String_Node_Str""+ (dirCount == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ d.getAbsolutePath(),quiet ? Project.MSG_VERBOSE : verbosity);
    }
  }
}",0.9517241379310344
64198,"private void handle(Exception e){
  if (failonerror) {
    throw (e instanceof BuildException) ? (BuildException)e : new BuildException(e);
  }
  log(e.getMessage(),quiet ? Project.MSG_VERBOSE : Project.MSG_WARN);
}","private void handle(Exception e){
  if (failonerror) {
    throw (e instanceof BuildException) ? (BuildException)e : new BuildException(e);
  }
  log(e.getMessage(),quiet ? Project.MSG_VERBOSE : verbosity);
}",0.9408983451536644
64199,"/** 
 * Delete the file(s).
 * @exception BuildException if an error occurs
 */
public void execute() throws BuildException {
  if (usedMatchingTask) {
    log(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (file == null && dir == null && filesets.size() == 0 && rcs == null) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (quiet && failonerror) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"",getLocation());
  }
  if (file != null) {
    if (file.exists()) {
      if (file.isDirectory()) {
        log(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str""+ ""String_Node_Str"");
      }
 else {
        log(""String_Node_Str"" + file.getAbsolutePath());
        if (!delete(file)) {
          handle(""String_Node_Str"" + file.getAbsolutePath());
        }
      }
    }
 else {
      log(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"",Project.MSG_VERBOSE);
    }
  }
  if (dir != null && dir.exists() && dir.isDirectory() && !usedMatchingTask) {
    if (verbosity == Project.MSG_VERBOSE) {
      log(""String_Node_Str"" + dir.getAbsolutePath());
    }
    removeDir(dir);
  }
  Resources resourcesToDelete=new Resources();
  resourcesToDelete.setProject(getProject());
  Resources filesetDirs=new Resources();
  filesetDirs.setProject(getProject());
  for (int i=0; i < filesets.size(); i++) {
    FileSet fs=(FileSet)filesets.get(i);
    if (fs.getProject() == null) {
      log(""String_Node_Str"" + ""String_Node_Str"",Project.MSG_VERBOSE);
      fs=(FileSet)fs.clone();
      fs.setProject(getProject());
    }
    resourcesToDelete.add(fs);
    if (includeEmpty && fs.getDir().isDirectory()) {
      filesetDirs.add(new ReverseDirs(fs.getDir(),fs.getDirectoryScanner().getIncludedDirectories()));
    }
  }
  if (usedMatchingTask && dir != null && dir.isDirectory()) {
    FileSet implicit=getImplicitFileSet();
    resourcesToDelete.add(implicit);
    if (includeEmpty) {
      filesetDirs.add(new ReverseDirs(dir,implicit.getDirectoryScanner().getIncludedDirectories()));
    }
  }
  resourcesToDelete.add(filesetDirs);
  if (rcs != null) {
    Restrict exists=new Restrict();
    exists.add(EXISTS);
    exists.add(rcs);
    Sort s=new Sort();
    s.add(REVERSE_FILESYSTEM);
    s.add(exists);
    resourcesToDelete.add(s);
  }
  try {
    if (resourcesToDelete.isFilesystemOnly()) {
      for (Iterator iter=resourcesToDelete.iterator(); iter.hasNext(); ) {
        FileResource r=(FileResource)iter.next();
        if (!r.isExists()) {
          continue;
        }
        if (!(r.isDirectory()) || r.getFile().list().length == 0) {
          log(""String_Node_Str"" + r,verbosity);
          if (!delete(r.getFile()) && failonerror) {
            handle(""String_Node_Str"" + (r.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"") + r);
          }
        }
      }
    }
 else {
      handle(getTaskName() + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    handle(e);
  }
}","/** 
 * Delete the file(s).
 * @exception BuildException if an error occurs
 */
public void execute() throws BuildException {
  if (usedMatchingTask) {
    log(""String_Node_Str"" + ""String_Node_Str"",quiet ? Project.MSG_VERBOSE : verbosity);
  }
  if (file == null && dir == null && filesets.size() == 0 && rcs == null) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (quiet && failonerror) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"",getLocation());
  }
  if (file != null) {
    if (file.exists()) {
      if (file.isDirectory()) {
        log(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str""+ ""String_Node_Str"",quiet ? Project.MSG_VERBOSE : verbosity);
      }
 else {
        log(""String_Node_Str"" + file.getAbsolutePath());
        if (!delete(file)) {
          handle(""String_Node_Str"" + file.getAbsolutePath());
        }
      }
    }
 else {
      log(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"",quiet ? Project.MSG_VERBOSE : verbosity);
    }
  }
  if (dir != null && dir.exists() && dir.isDirectory() && !usedMatchingTask) {
    if (verbosity == Project.MSG_VERBOSE) {
      log(""String_Node_Str"" + dir.getAbsolutePath());
    }
    removeDir(dir);
  }
  Resources resourcesToDelete=new Resources();
  resourcesToDelete.setProject(getProject());
  Resources filesetDirs=new Resources();
  filesetDirs.setProject(getProject());
  for (int i=0, size=filesets.size(); i < size; i++) {
    FileSet fs=(FileSet)filesets.get(i);
    if (fs.getProject() == null) {
      log(""String_Node_Str"" + ""String_Node_Str"",Project.MSG_VERBOSE);
      fs=(FileSet)fs.clone();
      fs.setProject(getProject());
    }
    resourcesToDelete.add(fs);
    if (includeEmpty && fs.getDir().isDirectory()) {
      filesetDirs.add(new ReverseDirs(fs.getDir(),fs.getDirectoryScanner().getIncludedDirectories()));
    }
  }
  if (usedMatchingTask && dir != null && dir.isDirectory()) {
    FileSet implicit=getImplicitFileSet();
    resourcesToDelete.add(implicit);
    if (includeEmpty) {
      filesetDirs.add(new ReverseDirs(dir,implicit.getDirectoryScanner().getIncludedDirectories()));
    }
  }
  resourcesToDelete.add(filesetDirs);
  if (rcs != null) {
    Restrict exists=new Restrict();
    exists.add(EXISTS);
    exists.add(rcs);
    Sort s=new Sort();
    s.add(REVERSE_FILESYSTEM);
    s.add(exists);
    resourcesToDelete.add(s);
  }
  try {
    if (resourcesToDelete.isFilesystemOnly()) {
      for (Iterator iter=resourcesToDelete.iterator(); iter.hasNext(); ) {
        FileResource r=(FileResource)iter.next();
        if (!r.isExists()) {
          continue;
        }
        if (!(r.isDirectory()) || r.getFile().list().length == 0) {
          log(""String_Node_Str"" + r,verbosity);
          if (!delete(r.getFile()) && failonerror) {
            handle(""String_Node_Str"" + (r.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"") + r);
          }
        }
      }
    }
 else {
      handle(getTaskName() + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    handle(e);
  }
}",0.6083100673345377
64200,"/** 
 * Delete a directory
 * @param d the directory to delete
 */
protected void removeDir(File d){
  String[] list=d.list();
  if (list == null) {
    list=new String[0];
  }
  for (int i=0; i < list.length; i++) {
    String s=list[i];
    File f=new File(d,s);
    if (f.isDirectory()) {
      removeDir(f);
    }
 else {
      log(""String_Node_Str"" + f.getAbsolutePath(),verbosity);
      if (!delete(f)) {
        String message=""String_Node_Str"" + f.getAbsolutePath();
        if (failonerror) {
          throw new BuildException(message);
        }
 else {
          log(message,quiet ? Project.MSG_VERBOSE : Project.MSG_WARN);
        }
      }
    }
  }
  log(""String_Node_Str"" + d.getAbsolutePath(),verbosity);
  if (!delete(d)) {
    String message=""String_Node_Str"" + dir.getAbsolutePath();
    if (failonerror) {
      throw new BuildException(message);
    }
 else {
      log(message,quiet ? Project.MSG_VERBOSE : Project.MSG_WARN);
    }
  }
}","/** 
 * Delete a directory
 * @param d the directory to delete
 */
protected void removeDir(File d){
  String[] list=d.list();
  if (list == null) {
    list=new String[0];
  }
  for (int i=0; i < list.length; i++) {
    String s=list[i];
    File f=new File(d,s);
    if (f.isDirectory()) {
      removeDir(f);
    }
 else {
      log(""String_Node_Str"" + f.getAbsolutePath(),verbosity);
      if (!delete(f)) {
        handle(""String_Node_Str"" + f.getAbsolutePath());
      }
    }
  }
  log(""String_Node_Str"" + d.getAbsolutePath(),verbosity);
  if (!delete(d)) {
    handle(""String_Node_Str"" + dir.getAbsolutePath());
  }
}",0.7641866330390921
64201,"/** 
 * remove an array of files in a directory, and a list of subdirectories which will only be deleted if 'includeEmpty' is true
 * @param d directory to work from
 * @param files array of files to delete; can be of zero length
 * @param dirs array of directories to delete; can of zero length
 */
protected void removeFiles(File d,String[] files,String[] dirs){
  if (files.length > 0) {
    log(""String_Node_Str"" + files.length + ""String_Node_Str""+ d.getAbsolutePath());
    for (int j=0; j < files.length; j++) {
      File f=new File(d,files[j]);
      log(""String_Node_Str"" + f.getAbsolutePath(),verbosity);
      if (!delete(f)) {
        String message=""String_Node_Str"" + f.getAbsolutePath();
        if (failonerror) {
          throw new BuildException(message);
        }
 else {
          log(message,quiet ? Project.MSG_VERBOSE : Project.MSG_WARN);
        }
      }
    }
  }
  if (dirs.length > 0 && includeEmpty) {
    int dirCount=0;
    for (int j=dirs.length - 1; j >= 0; j--) {
      File currDir=new File(d,dirs[j]);
      String[] dirFiles=currDir.list();
      if (dirFiles == null || dirFiles.length == 0) {
        log(""String_Node_Str"" + currDir.getAbsolutePath(),verbosity);
        if (!delete(currDir)) {
          String message=""String_Node_Str"" + currDir.getAbsolutePath();
          if (failonerror) {
            throw new BuildException(message);
          }
 else {
            log(message,quiet ? Project.MSG_VERBOSE : Project.MSG_WARN);
          }
        }
 else {
          dirCount++;
        }
      }
    }
    if (dirCount > 0) {
      log(""String_Node_Str"" + dirCount + ""String_Node_Str""+ (dirCount == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ d.getAbsolutePath());
    }
  }
}","/** 
 * remove an array of files in a directory, and a list of subdirectories which will only be deleted if 'includeEmpty' is true
 * @param d directory to work from
 * @param files array of files to delete; can be of zero length
 * @param dirs array of directories to delete; can of zero length
 */
protected void removeFiles(File d,String[] files,String[] dirs){
  if (files.length > 0) {
    log(""String_Node_Str"" + files.length + ""String_Node_Str""+ d.getAbsolutePath());
    for (int j=0; j < files.length; j++) {
      File f=new File(d,files[j]);
      log(""String_Node_Str"" + f.getAbsolutePath(),verbosity);
      if (!delete(f)) {
        handle(""String_Node_Str"" + f.getAbsolutePath());
      }
    }
  }
  if (dirs.length > 0 && includeEmpty) {
    int dirCount=0;
    for (int j=dirs.length - 1; j >= 0; j--) {
      File currDir=new File(d,dirs[j]);
      String[] dirFiles=currDir.list();
      if (dirFiles == null || dirFiles.length == 0) {
        log(""String_Node_Str"" + currDir.getAbsolutePath(),verbosity);
        if (!delete(currDir)) {
          handle(""String_Node_Str"" + currDir.getAbsolutePath());
        }
 else {
          dirCount++;
        }
      }
    }
    if (dirCount > 0) {
      log(""String_Node_Str"" + dirCount + ""String_Node_Str""+ (dirCount == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ d.getAbsolutePath());
    }
  }
}",0.8714011516314779
64202,"/** 
 * Delete the file(s).
 * @exception BuildException if an error occurs
 */
public void execute() throws BuildException {
  if (usedMatchingTask) {
    log(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (file == null && dir == null && filesets.size() == 0 && rcs.size() == 0) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (quiet && failonerror) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"",getLocation());
  }
  if (file != null) {
    if (file.exists()) {
      if (file.isDirectory()) {
        log(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str""+ ""String_Node_Str"");
      }
 else {
        log(""String_Node_Str"" + file.getAbsolutePath());
        if (!delete(file)) {
          String message=""String_Node_Str"" + file.getAbsolutePath();
          if (failonerror) {
            throw new BuildException(message);
          }
 else {
            log(message,quiet ? Project.MSG_VERBOSE : Project.MSG_WARN);
          }
        }
      }
    }
 else {
      log(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"",Project.MSG_VERBOSE);
    }
  }
  if (dir != null && dir.exists() && dir.isDirectory() && !usedMatchingTask) {
    if (verbosity == Project.MSG_VERBOSE) {
      log(""String_Node_Str"" + dir.getAbsolutePath());
    }
    removeDir(dir);
  }
  Path p=new Path(getProject());
  p.addAll(rcs);
  for (int i=0; i < filesets.size(); i++) {
    FileSet fs=(FileSet)filesets.get(i);
    p.add(includeEmpty ? new BCFileSet(fs) : fs);
  }
  if (usedMatchingTask && dir != null) {
    FileSet implicit=getImplicitFileSet();
    p.add(includeEmpty ? new BCFileSet(implicit) : implicit);
  }
  Restrict exists=new Restrict();
  exists.add(EXISTS);
  exists.add(p);
  Sort s=new Sort();
  s.add(REVERSE_FILESYSTEM);
  s.add(exists);
  String errorMessage=null;
  try {
    for (Iterator iter=s.iterator(); iter.hasNext(); ) {
      FileResource r=(FileResource)iter.next();
      if (!(r.isDirectory()) || r.getFile().list().length == 0) {
        log(""String_Node_Str"" + r,verbosity);
        if (!delete(r.getFile())) {
          errorMessage=""String_Node_Str"" + (r.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"") + r;
        }
      }
    }
  }
 catch (  Exception e) {
    errorMessage=e.getMessage();
  }
  if (errorMessage != null) {
    if (failonerror) {
      throw new BuildException(errorMessage);
    }
    log(errorMessage,quiet ? Project.MSG_VERBOSE : Project.MSG_WARN);
  }
}","/** 
 * Delete the file(s).
 * @exception BuildException if an error occurs
 */
public void execute() throws BuildException {
  if (usedMatchingTask) {
    log(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (file == null && dir == null && filesets.size() == 0 && rcs == null) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (quiet && failonerror) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"",getLocation());
  }
  if (file != null) {
    if (file.exists()) {
      if (file.isDirectory()) {
        log(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str""+ ""String_Node_Str"");
      }
 else {
        log(""String_Node_Str"" + file.getAbsolutePath());
        if (!delete(file)) {
          handle(""String_Node_Str"" + file.getAbsolutePath());
        }
      }
    }
 else {
      log(""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"",Project.MSG_VERBOSE);
    }
  }
  if (dir != null && dir.exists() && dir.isDirectory() && !usedMatchingTask) {
    if (verbosity == Project.MSG_VERBOSE) {
      log(""String_Node_Str"" + dir.getAbsolutePath());
    }
    removeDir(dir);
  }
  Resources resourcesToDelete=new Resources();
  resourcesToDelete.setProject(getProject());
  Resources filesetDirs=new Resources();
  filesetDirs.setProject(getProject());
  for (int i=0; i < filesets.size(); i++) {
    FileSet fs=(FileSet)filesets.get(i);
    resourcesToDelete.add(fs);
    if (includeEmpty) {
      filesetDirs.add(new ReverseDirs(fs.getDir(),fs.getDirectoryScanner().getIncludedDirectories()));
    }
  }
  if (usedMatchingTask && dir != null) {
    FileSet implicit=getImplicitFileSet();
    resourcesToDelete.add(implicit);
    if (includeEmpty) {
      filesetDirs.add(new ReverseDirs(dir,implicit.getDirectoryScanner().getIncludedDirectories()));
    }
  }
  resourcesToDelete.add(filesetDirs);
  if (rcs != null) {
    Restrict exists=new Restrict();
    exists.add(EXISTS);
    exists.add(rcs);
    Sort s=new Sort();
    s.add(REVERSE_FILESYSTEM);
    s.add(exists);
    resourcesToDelete.add(s);
  }
  try {
    if (resourcesToDelete.isFilesystemOnly()) {
      for (Iterator iter=resourcesToDelete.iterator(); iter.hasNext(); ) {
        FileResource r=(FileResource)iter.next();
        if (!r.isExists()) {
          continue;
        }
        if (!(r.isDirectory()) || r.getFile().list().length == 0) {
          log(""String_Node_Str"" + r,verbosity);
          if (!delete(r.getFile()) && failonerror) {
            handle(""String_Node_Str"" + (r.isDirectory() ? ""String_Node_Str"" : ""String_Node_Str"") + r);
          }
        }
      }
    }
 else {
      handle(getTaskName() + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    handle(e);
  }
}",0.6388467374810318
64203,"/** 
 * Add a file to the path. Reads the manifest, if available, and adds any additional class path jars specified in the manifest.
 * @param pathComponent the file which is to be added to the path forthis class loader
 * @throws IOException if data needed from the file cannot be read.
 */
protected void addPathFile(File pathComponent) throws IOException {
  pathComponents.addElement(pathComponent);
  if (pathComponent.isDirectory()) {
    return;
  }
  String absPathPlusTimeAndLength=pathComponent.getAbsolutePath() + pathComponent.lastModified() + ""String_Node_Str""+ pathComponent.length();
  String classpath=(String)pathMap.get(absPathPlusTimeAndLength);
  if (classpath == null) {
    ZipFile jarFile=null;
    InputStream manifestStream=null;
    try {
      jarFile=new ZipFile(pathComponent);
      manifestStream=jarFile.getInputStream(new ZipEntry(""String_Node_Str""));
      if (manifestStream == null) {
        return;
      }
      Reader manifestReader=new InputStreamReader(manifestStream,""String_Node_Str"");
      org.apache.tools.ant.taskdefs.Manifest manifest=new org.apache.tools.ant.taskdefs.Manifest(manifestReader);
      classpath=manifest.getMainSection().getAttributeValue(""String_Node_Str"");
    }
 catch (    org.apache.tools.ant.taskdefs.ManifestException e) {
    }
 finally {
      if (manifestStream != null) {
        manifestStream.close();
      }
      if (jarFile != null) {
        jarFile.close();
      }
    }
    if (classpath == null) {
      classpath=""String_Node_Str"";
    }
    pathMap.put(absPathPlusTimeAndLength,classpath);
  }
  if (!""String_Node_Str"".equals(classpath)) {
    URL baseURL=FILE_UTILS.getFileURL(pathComponent);
    StringTokenizer st=new StringTokenizer(classpath);
    while (st.hasMoreTokens()) {
      String classpathElement=st.nextToken();
      URL libraryURL=new URL(baseURL,classpathElement);
      if (!libraryURL.getProtocol().equals(""String_Node_Str"")) {
        log(""String_Node_Str"" + classpathElement + ""String_Node_Str""+ ""String_Node_Str"",Project.MSG_VERBOSE);
        continue;
      }
      File libraryFile=new File(libraryURL.getFile());
      if (libraryFile.exists() && !isInPath(libraryFile)) {
        addPathFile(libraryFile);
      }
    }
  }
}","/** 
 * Add a file to the path. Reads the manifest, if available, and adds any additional class path jars specified in the manifest.
 * @param pathComponent the file which is to be added to the path forthis class loader
 * @throws IOException if data needed from the file cannot be read.
 */
protected void addPathFile(File pathComponent) throws IOException {
  pathComponents.addElement(pathComponent);
  if (pathComponent.isDirectory()) {
    return;
  }
  String absPathPlusTimeAndLength=pathComponent.getAbsolutePath() + pathComponent.lastModified() + ""String_Node_Str""+ pathComponent.length();
  String classpath=(String)pathMap.get(absPathPlusTimeAndLength);
  if (classpath == null) {
    ZipFile jarFile=null;
    InputStream manifestStream=null;
    try {
      jarFile=new ZipFile(pathComponent);
      manifestStream=jarFile.getInputStream(new ZipEntry(""String_Node_Str""));
      if (manifestStream == null) {
        return;
      }
      Reader manifestReader=new InputStreamReader(manifestStream,""String_Node_Str"");
      org.apache.tools.ant.taskdefs.Manifest manifest=new org.apache.tools.ant.taskdefs.Manifest(manifestReader);
      classpath=manifest.getMainSection().getAttributeValue(""String_Node_Str"");
    }
 catch (    org.apache.tools.ant.taskdefs.ManifestException e) {
    }
 finally {
      if (manifestStream != null) {
        manifestStream.close();
      }
      if (jarFile != null) {
        jarFile.close();
      }
    }
    if (classpath == null) {
      classpath=""String_Node_Str"";
    }
    pathMap.put(absPathPlusTimeAndLength,classpath);
  }
  if (!""String_Node_Str"".equals(classpath)) {
    URL baseURL=FILE_UTILS.getFileURL(pathComponent);
    StringTokenizer st=new StringTokenizer(classpath);
    while (st.hasMoreTokens()) {
      String classpathElement=st.nextToken();
      URL libraryURL=new URL(baseURL,classpathElement);
      if (!libraryURL.getProtocol().equals(""String_Node_Str"")) {
        log(""String_Node_Str"" + classpathElement + ""String_Node_Str""+ ""String_Node_Str"",Project.MSG_VERBOSE);
        continue;
      }
      File libraryFile=new File(URLDecoder.decode(libraryURL.getFile()));
      if (libraryFile.exists() && !isInPath(libraryFile)) {
        addPathFile(libraryFile);
      }
    }
  }
}",0.9957805907172996
64204,"public void setUp(){
  p=new Project();
  p.init();
}","public void setUp(){
  p=new Project();
  p.init();
  configureProject(""String_Node_Str"");
  getProject().executeTarget(""String_Node_Str"");
}",0.5463917525773195
64205,"/** 
 * read in lines and execute them
 * @param reader the reader contains sql lines.
 * @param out the place to output results.
 * @throws SQLException on sql problems
 * @throws IOException on io problems
 */
protected void runStatements(Reader reader,PrintStream out) throws SQLException, IOException {
  StringBuffer sql=new StringBuffer();
  String line=""String_Node_Str"";
  BufferedReader in=new BufferedReader(reader);
  while ((line=in.readLine()) != null) {
    if (!keepformat) {
      line=line.trim();
    }
    line=getProject().replaceProperties(line);
    if (!keepformat) {
      if (line.startsWith(""String_Node_Str"")) {
        continue;
      }
      if (line.startsWith(""String_Node_Str"")) {
        continue;
      }
      StringTokenizer st=new StringTokenizer(line);
      if (st.hasMoreTokens()) {
        String token=st.nextToken();
        if (""String_Node_Str"".equalsIgnoreCase(token)) {
          continue;
        }
      }
    }
    if (!keepformat) {
      sql.append(""String_Node_Str"" + line);
    }
 else {
      sql.append(""String_Node_Str"" + line);
    }
    if (!keepformat) {
      if (line.indexOf(""String_Node_Str"") >= 0) {
        sql.append(""String_Node_Str"");
      }
    }
    if ((delimiterType.equals(DelimiterType.NORMAL) && sql.toString().endsWith(delimiter)) || (delimiterType.equals(DelimiterType.ROW) && line.equals(delimiter))) {
      execSQL(sql.substring(0,sql.length() - delimiter.length()),out);
      sql.replace(0,sql.length(),""String_Node_Str"");
    }
  }
  if (!sql.equals(""String_Node_Str"")) {
    execSQL(sql.toString(),out);
  }
}","/** 
 * read in lines and execute them
 * @param reader the reader contains sql lines.
 * @param out the place to output results.
 * @throws SQLException on sql problems
 * @throws IOException on io problems
 */
protected void runStatements(Reader reader,PrintStream out) throws SQLException, IOException {
  StringBuffer sql=new StringBuffer();
  String line;
  BufferedReader in=new BufferedReader(reader);
  while ((line=in.readLine()) != null) {
    if (!keepformat) {
      line=line.trim();
    }
    line=getProject().replaceProperties(line);
    if (!keepformat) {
      if (line.startsWith(""String_Node_Str"")) {
        continue;
      }
      if (line.startsWith(""String_Node_Str"")) {
        continue;
      }
      StringTokenizer st=new StringTokenizer(line);
      if (st.hasMoreTokens()) {
        String token=st.nextToken();
        if (""String_Node_Str"".equalsIgnoreCase(token)) {
          continue;
        }
      }
    }
    if (!keepformat) {
      sql.append(""String_Node_Str"" + line);
    }
 else {
      sql.append(""String_Node_Str"" + line);
    }
    if (!keepformat) {
      if (line.indexOf(""String_Node_Str"") >= 0) {
        sql.append(""String_Node_Str"");
      }
    }
    if ((delimiterType.equals(DelimiterType.NORMAL) && StringUtils.endsWith(sql,delimiter)) || (delimiterType.equals(DelimiterType.ROW) && line.equals(delimiter))) {
      execSQL(sql.substring(0,sql.length() - delimiter.length()),out);
      sql.replace(0,sql.length(),""String_Node_Str"");
    }
  }
  if (!sql.equals(""String_Node_Str"")) {
    execSQL(sql.toString(),out);
  }
}",0.9851875196974472
64206,"private File createCommandFile(String[] cmd,String[] env) throws IOException {
  File script=FILE_UTILS.createTempFile(""String_Node_Str"",""String_Node_Str"",null);
  script.deleteOnExit();
  PrintWriter out=null;
  try {
    out=new PrintWriter(new FileWriter(script));
    if (env != null) {
      int eqIndex;
      for (int i=1; i < env.length; i++) {
        eqIndex=env[i].indexOf('=');
        if (eqIndex != -1) {
          out.print(""String_Node_Str"");
          out.print(env[i].substring(0,eqIndex));
          out.print(""String_Node_Str"");
          out.print(env[i].substring(eqIndex + 1));
          out.println('\""');
        }
      }
    }
    out.print(""String_Node_Str"" + cmd[0]);
    for (int i=1; i < cmd.length; i++) {
      out.println(""String_Node_Str"");
      out.print(cmd[i]);
    }
  }
  finally {
    if (out != null) {
      out.close();
    }
  }
  return script;
}","private File createCommandFile(String[] cmd,String[] env) throws IOException {
  File script=FILE_UTILS.createTempFile(""String_Node_Str"",""String_Node_Str"",null);
  script.deleteOnExit();
  PrintWriter out=null;
  try {
    out=new PrintWriter(new FileWriter(script));
    if (env != null) {
      int eqIndex;
      for (int i=0; i < env.length; i++) {
        eqIndex=env[i].indexOf('=');
        if (eqIndex != -1) {
          out.print(""String_Node_Str"");
          out.print(env[i].substring(0,eqIndex));
          out.print(""String_Node_Str"");
          out.print(env[i].substring(eqIndex + 1));
          out.println('\""');
        }
      }
    }
    out.print(""String_Node_Str"" + cmd[0]);
    for (int i=1; i < cmd.length; i++) {
      out.println(""String_Node_Str"");
      out.print(cmd[i]);
    }
  }
  finally {
    if (out != null) {
      out.close();
    }
  }
  return script;
}",0.9988801791713324
64207,"/** 
 * Checks to see if the remote file is current as compared with the local file. Returns true if the target file is up to date.
 * @param ftp ftpclient
 * @param localFile local file
 * @param remoteFile remote file
 * @return true if the target file is up to date
 * @throws IOException  in unknown circumstances
 * @throws BuildException if the date of the remote files cannot be found and the action isGET_FILES
 */
protected boolean isUpToDate(FTPClient ftp,File localFile,String remoteFile) throws IOException, BuildException {
  log(""String_Node_Str"" + remoteFile,Project.MSG_VERBOSE);
  FTPFile[] files=ftp.listFiles(remoteFile);
  if (files == null || files.length == 0) {
    if (action == SEND_FILES) {
      log(""String_Node_Str"" + remoteFile + ""String_Node_Str"",Project.MSG_VERBOSE);
      return false;
    }
 else {
      throw new BuildException(""String_Node_Str"" + ftp.getReplyString());
    }
  }
  long remoteTimestamp=files[0].getTimestamp().getTime().getTime();
  long localTimestamp=localFile.lastModified();
  if (this.action == SEND_FILES) {
    return remoteTimestamp + timeDiffMillis > localTimestamp;
  }
 else {
    return localTimestamp > remoteTimestamp + timeDiffMillis;
  }
}","/** 
 * Checks to see if the remote file is current as compared with the local file. Returns true if the target file is up to date.
 * @param ftp ftpclient
 * @param localFile local file
 * @param remoteFile remote file
 * @return true if the target file is up to date
 * @throws IOException  in unknown circumstances
 * @throws BuildException if the date of the remote files cannot be found and the action isGET_FILES
 */
protected boolean isUpToDate(FTPClient ftp,File localFile,String remoteFile) throws IOException, BuildException {
  log(""String_Node_Str"" + remoteFile,Project.MSG_VERBOSE);
  FTPFile[] files=ftp.listFiles(remoteFile);
  if (files == null || files.length == 0) {
    if (action == SEND_FILES) {
      log(""String_Node_Str"" + remoteFile + ""String_Node_Str"",Project.MSG_VERBOSE);
      return false;
    }
 else {
      throw new BuildException(""String_Node_Str"" + ftp.getReplyString());
    }
  }
  long remoteTimestamp=files[0].getTimestamp().getTime().getTime();
  long localTimestamp=localFile.lastModified();
  if (this.action == SEND_FILES) {
    return remoteTimestamp + timeDiffMillis >= localTimestamp;
  }
 else {
    return localTimestamp >= remoteTimestamp + timeDiffMillis;
  }
}",0.9991742361684558
64208,"/** 
 * Top level invocation for a slow scan. A slow scan builds up a full list of excluded/included files/directories, whereas a fast scan will only have full results for included files, as it ignores directories which can't possibly hold any included files/directories. <p> Returns immediately if a slow scan has already been completed.
 */
protected void slowScan(){
synchronized (slowScanLock) {
    if (haveSlowResults) {
      return;
    }
    if (slowScanning) {
      while (slowScanning) {
        try {
          slowScanLock.wait();
        }
 catch (        InterruptedException e) {
        }
      }
      return;
    }
    slowScanning=true;
  }
  try {
synchronized (this) {
      String[] excl=new String[dirsExcluded.size()];
      dirsExcluded.copyInto(excl);
      String[] notIncl=new String[dirsNotIncluded.size()];
      dirsNotIncluded.copyInto(notIncl);
      for (int i=0; i < excl.length; i++) {
        if (!couldHoldIncluded(excl[i])) {
          scandir(new File(basedir,excl[i]),excl[i] + File.separator,false);
        }
      }
      for (int i=0; i < notIncl.length; i++) {
        if (!couldHoldIncluded(notIncl[i])) {
          scandir(new File(basedir,notIncl[i]),notIncl[i] + File.separator,false);
        }
      }
    }
  }
  finally {
synchronized (slowScanLock) {
      haveSlowResults=true;
      slowScanning=false;
      slowScanLock.notifyAll();
    }
  }
}","/** 
 * Top level invocation for a slow scan. A slow scan builds up a full list of excluded/included files/directories, whereas a fast scan will only have full results for included files, as it ignores directories which can't possibly hold any included files/directories. <p> Returns immediately if a slow scan has already been completed.
 */
protected void slowScan(){
synchronized (slowScanLock) {
    if (haveSlowResults) {
      return;
    }
    if (slowScanning) {
      while (slowScanning) {
        try {
          slowScanLock.wait();
        }
 catch (        InterruptedException e) {
        }
      }
      return;
    }
    slowScanning=true;
  }
  try {
synchronized (this) {
      boolean nullIncludes=(includes == null);
      includes=nullIncludes ? new String[]{""String_Node_Str""} : includes;
      boolean nullExcludes=(excludes == null);
      excludes=nullExcludes ? new String[0] : excludes;
      String[] excl=new String[dirsExcluded.size()];
      dirsExcluded.copyInto(excl);
      String[] notIncl=new String[dirsNotIncluded.size()];
      dirsNotIncluded.copyInto(notIncl);
      for (int i=0; i < excl.length; i++) {
        if (!couldHoldIncluded(excl[i])) {
          scandir(new File(basedir,excl[i]),excl[i] + File.separator,false);
        }
      }
      for (int i=0; i < notIncl.length; i++) {
        if (!couldHoldIncluded(notIncl[i])) {
          scandir(new File(basedir,notIncl[i]),notIncl[i] + File.separator,false);
        }
      }
      clearCaches();
      includes=nullIncludes ? null : includes;
      excludes=nullExcludes ? null : excludes;
    }
  }
  finally {
synchronized (slowScanLock) {
      haveSlowResults=true;
      slowScanning=false;
      slowScanLock.notifyAll();
    }
  }
}",0.8923467767545252
64209,"/** 
 * Stop the pumper as soon as possible. Note that it may continue to block on the input stream but it will really stop the thread as soon as it gets EOF or any byte, and it will be marked as finished.
 * @since Ant 1.6.3
 */
synchronized void stop(){
  finished=true;
  notifyAll();
}","/** 
 * Stop the pumper as soon as possible. Note that it may continue to block on the input stream but it will really stop the thread as soon as it gets EOF or any byte, and it will be marked as finished.
 * @since Ant 1.6.3
 */
synchronized void stop(){
  finish=true;
  notifyAll();
}",0.9965277777777778
64210,"/** 
 * Copies data from the input stream to the output stream. Terminates as soon as the input stream is closed or an error occurs.
 */
public void run(){
synchronized (this) {
    finished=false;
  }
  final byte[] buf=new byte[SIZE];
  int length;
  try {
    while ((length=is.read(buf)) > 0 && !finished) {
      os.write(buf,0,length);
      if (autoflush) {
        os.flush();
      }
    }
  }
 catch (  Exception e) {
  }
 finally {
    if (closeWhenExhausted) {
      try {
        os.close();
      }
 catch (      IOException e) {
      }
    }
synchronized (this) {
      finished=true;
      notifyAll();
    }
  }
}","/** 
 * Copies data from the input stream to the output stream. Terminates as soon as the input stream is closed or an error occurs.
 */
public void run(){
  finished=false;
  finish=false;
  final byte[] buf=new byte[SIZE];
  int length;
  try {
    while ((length=is.read(buf)) > 0 && !finish) {
      os.write(buf,0,length);
      if (autoflush) {
        os.flush();
      }
    }
    os.flush();
  }
 catch (  Exception e) {
  }
 finally {
    if (closeWhenExhausted) {
      try {
        os.close();
      }
 catch (      IOException e) {
      }
    }
    finished=true;
synchronized (this) {
      notifyAll();
    }
  }
}",0.9239302694136292
64211,"/** 
 * Tells whether the end of the stream has been reached.
 * @return true is the stream has been exhausted.
 */
public synchronized boolean isFinished(){
  return finished;
}","/** 
 * Tells whether the end of the stream has been reached.
 * @return true is the stream has been exhausted.
 */
public boolean isFinished(){
  return finished;
}",0.9620991253644317
64212,"/** 
 * Handles an error line by logging it with the ERR priority.
 * @param output The error output to log. Should not be <code>null</code>.
 * @since Ant 1.5.2
 */
protected void handleErrorFlush(String output){
  handleErrorOutput(output);
}","/** 
 * Handles an error line by logging it with the WARN priority.
 * @param output The error output to log. Should not be <code>null</code>.
 * @since Ant 1.5.2
 */
protected void handleErrorFlush(String output){
  handleErrorOutput(output);
}",0.9897750511247444
64213,"/** 
 * Construct a new <CODE>ConcatFileInputStream</CODE> with the specified <CODE>File[]</CODE>.
 * @param file   <CODE>File[]</CODE>.
 * @throws <CODE>IOException</CODE> if I/O errors occur.
 */
public ConcatFileInputStream(File[] file) throws IOException {
  this.file=file;
  openFile(currentIndex);
}","/** 
 * Construct a new <CODE>ConcatFileInputStream</CODE> with the specified <CODE>File[]</CODE>.
 * @param file   <CODE>File[]</CODE>.
 * @throws <CODE>IOException</CODE> if I/O errors occur.
 */
public ConcatFileInputStream(File[] file) throws IOException {
  this.file=file;
}",0.955631399317406
64214,"/** 
 * Load the script from an external file ; optional.
 * @param fileName the name of the file containing the script source.
 */
public void setSrc(String fileName){
  File file=new File(fileName);
  runner.setSrc(file);
}","/** 
 * Load the script from an external file ; optional.
 * @param fileName the name of the file containing the script source.
 */
public void setSrc(String fileName){
  this.src=new File(fileName);
}",0.9061032863849764
64215,"/** 
 * Set the script text.
 * @param text a component of the script text to be added.
 */
public void addText(String text){
  runner.addText(text);
}","/** 
 * Set the script text.
 * @param text a component of the script text to be added.
 */
public void addText(String text){
  this.text=text;
}",0.918918918918919
64216,"/** 
 * Do the work.
 * @exception BuildException if something goes wrong with the build
 */
public void execute() throws BuildException {
  runner.addBeans(getProject().getProperties());
  runner.addBeans(getProject().getUserProperties());
  runner.addBeans(getProject().getTargets());
  runner.addBeans(getProject().getReferences());
  runner.addBean(""String_Node_Str"",getProject());
  runner.addBean(""String_Node_Str"",this);
  runner.executeScript(""String_Node_Str"");
}","/** 
 * Do the work.
 * @exception BuildException if something goes wrong with the build
 */
public void execute() throws BuildException {
  ScriptRunner runner=new ScriptRunner();
  if (language != null) {
    runner.setLanguage(language);
  }
  if (src != null) {
    runner.setSrc(src);
  }
  if (text != null) {
    runner.addText(text);
  }
  runner.addBeans(getProject().getProperties());
  runner.addBeans(getProject().getUserProperties());
  runner.addBeans(getProject().getTargets());
  runner.addBeans(getProject().getReferences());
  runner.addBean(""String_Node_Str"",getProject());
  runner.addBean(""String_Node_Str"",this);
  runner.executeScript(""String_Node_Str"");
}",0.8201563857515204
64217,"/** 
 * Defines the language (required).
 * @param language the scripting language name for the script.
 */
public void setLanguage(String language){
  runner.setLanguage(language);
}","/** 
 * Defines the language (required).
 * @param language the scripting language name for the script.
 */
public void setLanguage(String language){
  this.language=language;
}",0.9111111111111112
64218,"/** 
 * Read into the buffer <code>cbuf</code>.
 * @param cbuf The array to be read into.
 * @param off The offset.
 * @param len The length to read.
 * @exception IOException - possibly thrown by the reads to thereader objects.
 */
public int read(char[] cbuf,int off,int len) throws IOException {
  int amountRead=0;
  while (pos < sourceFiles.size() || (needAddSeparator)) {
    if (needAddSeparator) {
      cbuf[off]=eolString.charAt(lastPos++);
      if (lastPos >= eolString.length()) {
        lastPos=0;
        needAddSeparator=false;
        pos++;
      }
      len--;
      off++;
      amountRead++;
      if (len == 0) {
        return amountRead;
      }
      continue;
    }
    int nRead=getReader().read(cbuf,off,len);
    if (nRead == -1 || nRead == 0) {
      reader.close();
      reader=null;
      if (fixLastLine && isMissingEndOfLine()) {
        needAddSeparator=true;
        lastPos=0;
      }
 else {
        pos++;
      }
    }
 else {
      if (fixLastLine) {
        for (int i=nRead; i > (nRead - lastChars.length); --i) {
          if (i < 0) {
            break;
          }
          addLastChar(cbuf[off + i]);
        }
      }
      len-=nRead;
      off+=nRead;
      amountRead+=nRead;
      if (len == 0) {
        return amountRead;
      }
    }
  }
  if (amountRead == 0) {
    return -1;
  }
 else {
    return amountRead;
  }
}","/** 
 * Read into the buffer <code>cbuf</code>.
 * @param cbuf The array to be read into.
 * @param off The offset.
 * @param len The length to read.
 * @exception IOException - possibly thrown by the reads to thereader objects.
 */
public int read(char[] cbuf,int off,int len) throws IOException {
  int amountRead=0;
  while (pos < sourceFiles.size() || (needAddSeparator)) {
    if (needAddSeparator) {
      cbuf[off]=eolString.charAt(lastPos++);
      if (lastPos >= eolString.length()) {
        lastPos=0;
        needAddSeparator=false;
        pos++;
      }
      len--;
      off++;
      amountRead++;
      if (len == 0) {
        return amountRead;
      }
      continue;
    }
    int nRead=getReader().read(cbuf,off,len);
    if (nRead == -1 || nRead == 0) {
      reader.close();
      reader=null;
      if (fixLastLine && isMissingEndOfLine()) {
        needAddSeparator=true;
        lastPos=0;
      }
 else {
        pos++;
      }
    }
 else {
      if (fixLastLine) {
        for (int i=nRead; i > (nRead - lastChars.length); --i) {
          if (i < 0) {
            break;
          }
          addLastChar(cbuf[off + i - 1]);
        }
      }
      len-=nRead;
      off+=nRead;
      amountRead+=nRead;
      if (len == 0) {
        return amountRead;
      }
    }
  }
  if (amountRead == 0) {
    return -1;
  }
 else {
    return amountRead;
  }
}",0.9985496736765772
64219,"public void setUp(){
  configureProject(""String_Node_Str"");
  getProject().executeTarget(""String_Node_Str"");
  tmpDir=getProject().getProperty(""String_Node_Str"");
  ftp=new FTPClient();
  ftptask=new FTP();
  ftpFileSep=getProject().getProperty(""String_Node_Str"");
  ftptask.setSeparator(ftpFileSep);
  remoteTmpDir=ftptask.resolveFile(tmpDir);
  String remoteHost=getProject().getProperty(""String_Node_Str"");
  int port=Integer.parseInt(getProject().getProperty(""String_Node_Str""));
  String remoteUser=getProject().getProperty(""String_Node_Str"");
  String password=getProject().getProperty(""String_Node_Str"");
  try {
    ftp.connect(remoteHost,port);
  }
 catch (  Exception ex) {
    connectionSucceeded=false;
    loginSuceeded=false;
    System.out.println(""String_Node_Str"" + remoteHost + ""String_Node_Str""+ port);
  }
  if (connectionSucceeded) {
    try {
      ftp.login(remoteUser,password);
    }
 catch (    IOException ioe) {
      loginSuceeded=false;
      System.out.println(""String_Node_Str"" + remoteHost + ""String_Node_Str""+ remoteUser);
    }
  }
}","public void setUp(){
  configureProject(""String_Node_Str"");
  getProject().executeTarget(""String_Node_Str"");
  tmpDir=getProject().getProperty(""String_Node_Str"");
  ftp=new FTPClient();
  ftpFileSep=getProject().getProperty(""String_Node_Str"");
  myFTPTask.setSeparator(ftpFileSep);
  remoteTmpDir=myFTPTask.resolveFile(tmpDir);
  String remoteHost=getProject().getProperty(""String_Node_Str"");
  int port=Integer.parseInt(getProject().getProperty(""String_Node_Str""));
  String remoteUser=getProject().getProperty(""String_Node_Str"");
  String password=getProject().getProperty(""String_Node_Str"");
  try {
    ftp.connect(remoteHost,port);
  }
 catch (  Exception ex) {
    connectionSucceeded=false;
    loginSuceeded=false;
    System.out.println(""String_Node_Str"" + remoteHost + ""String_Node_Str""+ port);
  }
  if (connectionSucceeded) {
    try {
      ftp.login(remoteUser,password);
    }
 catch (    IOException ioe) {
      loginSuceeded=false;
      System.out.println(""String_Node_Str"" + remoteHost + ""String_Node_Str""+ remoteUser);
    }
  }
}",0.9023124115148656
64220,"/** 
 * Static method to read an ant lib definition from a url.
 * @param project   the current project
 * @param antlibUrl the url to read the definitions from
 * @return   the ant lib task
 */
public static Antlib createAntlib(Project project,URL antlibUrl){
  try {
    antlibUrl.openConnection().connect();
  }
 catch (  IOException ex) {
    throw new BuildException(""String_Node_Str"" + antlibUrl,ex);
  }
  try {
    ProjectHelper2 parser=new ProjectHelper2();
    UnknownElement ue=parser.parseUnknownElement(project,antlibUrl);
    if (!(ue.getTag().equals(TAG))) {
      throw new BuildException(""String_Node_Str"" + ue.getTag() + ""String_Node_Str""+ TAG,ue.getLocation());
    }
    Antlib antlib=new Antlib();
    antlib.setProject(project);
    antlib.setLocation(ue.getLocation());
    antlib.init();
    ue.configure(antlib);
    return antlib;
  }
 catch (  BuildException ex) {
    Location location=ex.getLocation();
    if (location == null) {
      throw ex;
    }
    throw new BuildException(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + location.toString()+ ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * Static method to read an ant lib definition from a url.
 * @param project   the current project
 * @param antlibUrl the url to read the definitions from
 * @return   the ant lib task
 */
public static Antlib createAntlib(Project project,URL antlibUrl){
  try {
    antlibUrl.openConnection().connect();
  }
 catch (  IOException ex) {
    throw new BuildException(""String_Node_Str"" + antlibUrl,ex);
  }
  ProjectHelper2 parser=new ProjectHelper2();
  UnknownElement ue=parser.parseUnknownElement(project,antlibUrl);
  if (!(ue.getTag().equals(TAG))) {
    throw new BuildException(""String_Node_Str"" + ue.getTag() + ""String_Node_Str""+ TAG,ue.getLocation());
  }
  Antlib antlib=new Antlib();
  antlib.setProject(project);
  antlib.setLocation(ue.getLocation());
  antlib.init();
  ue.configure(antlib);
  return antlib;
}",0.8134556574923547
64221,"/** 
 * Execute the nested tasks, setting the classloader for any tasks that derive from Definer.
 */
public void execute(){
  for (Iterator i=tasks.iterator(); i.hasNext(); ) {
    UnknownElement ue=(UnknownElement)i.next();
    ue.maybeConfigure();
    Task t=ue.getTask();
    if (t == null) {
      continue;
    }
    if (t instanceof Definer) {
      Definer d=(Definer)t;
      d.setInternalClassLoader(getClassLoader());
    }
    t.init();
    t.execute();
  }
}","/** 
 * Execute the nested tasks, setting the classloader for any tasks that derive from Definer.
 */
public void execute(){
  for (Iterator i=tasks.iterator(); i.hasNext(); ) {
    UnknownElement ue=(UnknownElement)i.next();
    ue.maybeConfigure();
    setLocation(ue.getLocation());
    Task t=ue.getTask();
    if (t == null) {
      continue;
    }
    if (t instanceof Definer) {
      Definer d=(Definer)t;
      d.setInternalClassLoader(getClassLoader());
    }
    t.init();
    t.execute();
  }
}",0.9641760491299898
64222,"/** 
 * Load an antlib from a url.
 * @param classLoader the classloader to use.
 * @param url the url to load the definitions from.
 */
private void loadAntlib(ClassLoader classLoader,URL url){
  try {
    Antlib antlib=Antlib.createAntlib(getProject(),url);
    antlib.setClassLoader(classLoader);
    antlib.perform();
  }
 catch (  BuildException ex) {
    Location location=ex.getLocation();
    if (location == null) {
      throw ex;
    }
    throw new BuildException(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + getLocation().toString()+ ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * Load an antlib from a url.
 * @param classLoader the classloader to use.
 * @param url the url to load the definitions from.
 */
private void loadAntlib(ClassLoader classLoader,URL url){
  try {
    Antlib antlib=Antlib.createAntlib(getProject(),url);
    antlib.setClassLoader(classLoader);
    antlib.perform();
  }
 catch (  BuildException ex) {
    Location exLocation=ex.getLocation();
    if (exLocation == null) {
      throw ex;
    }
    throw new BuildException(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + exLocation.toString()+ ""String_Node_Str""+ ex.getMessage());
  }
}",0.9743589743589745
64223,"/** 
 * this routine is actually checking all the include patterns in order to avoid scanning everything under base dir
 * @since ant1.6
 */
private void checkIncludePatterns(){
  Hashtable newroots=new Hashtable();
  for (int icounter=0; icounter < includes.length; icounter++) {
    String newpattern=SelectorUtils.rtrimWildcardTokens(includes[icounter]);
    boolean hasParent=false;
    Enumeration myenum=newroots.keys();
    Vector vdelete=new Vector();
    while (myenum.hasMoreElements()) {
      String existingpattern=(String)myenum.nextElement();
      if (existingpattern.length() >= newpattern.length()) {
        if (existingpattern.indexOf(newpattern) == 0) {
          vdelete.add(existingpattern);
        }
      }
      if (existingpattern.length() <= newpattern.length()) {
        if (newpattern.indexOf(existingpattern) == 0) {
          hasParent=true;
          break;
        }
      }
    }
    if (!hasParent) {
      newroots.put(newpattern,includes[icounter]);
      for (int icounter2=0; icounter2 < vdelete.size(); icounter2++) {
        newroots.remove(vdelete.elementAt(icounter2));
      }
    }
  }
  Enumeration enum2=newroots.keys();
  while (enum2.hasMoreElements()) {
    String currentelement=(String)enum2.nextElement();
    String originalpattern=(String)newroots.get(currentelement);
    File myfile=new File(basedir,currentelement);
    if (!myfile.exists() && !isCaseSensitive) {
      File f=findFileCaseInsensitive(basedir,currentelement);
      if (f.exists()) {
        currentelement=fileUtils.removeLeadingPath(basedir,f);
        myfile=f;
      }
    }
    if (myfile.exists()) {
      if (!followSymlinks && isSymlink(basedir,currentelement)) {
        continue;
      }
      if (myfile.isDirectory()) {
        if (isIncluded(currentelement) && currentelement.length() > 0) {
          accountForIncludedDir(currentelement,myfile,true);
        }
 else {
          if (currentelement.length() > 0) {
            if (currentelement.charAt(currentelement.length() - 1) != File.separatorChar) {
              currentelement=currentelement + File.separatorChar;
            }
          }
          scandir(myfile,currentelement,true);
        }
      }
 else {
        if (isCaseSensitive && originalpattern.equals(currentelement)) {
          accountForIncludedFile(currentelement,myfile);
        }
 else         if (!isCaseSensitive && originalpattern.equalsIgnoreCase(currentelement)) {
          accountForIncludedFile(currentelement,myfile);
        }
      }
    }
  }
}","/** 
 * this routine is actually checking all the include patterns in order to avoid scanning everything under base dir
 * @since ant1.6
 */
private void checkIncludePatterns(){
  Hashtable newroots=new Hashtable();
  for (int icounter=0; icounter < includes.length; icounter++) {
    String newpattern=SelectorUtils.rtrimWildcardTokens(includes[icounter]);
    boolean hasParent=false;
    Enumeration myenum=newroots.keys();
    Vector vdelete=new Vector();
    while (myenum.hasMoreElements()) {
      String existingpattern=(String)myenum.nextElement();
      if (existingpattern.length() >= newpattern.length()) {
        if (existingpattern.indexOf(newpattern) == 0) {
          vdelete.add(existingpattern);
        }
      }
      if (existingpattern.length() <= newpattern.length()) {
        if (newpattern.indexOf(existingpattern) == 0) {
          hasParent=true;
          break;
        }
      }
    }
    if (!hasParent) {
      newroots.put(newpattern,includes[icounter]);
      for (int icounter2=0; icounter2 < vdelete.size(); icounter2++) {
        newroots.remove(vdelete.elementAt(icounter2));
      }
    }
  }
  Enumeration enum2=newroots.keys();
  while (enum2.hasMoreElements()) {
    String currentelement=(String)enum2.nextElement();
    String originalpattern=(String)newroots.get(currentelement);
    File myfile=new File(basedir,currentelement);
    if (Os.isFamily(""String_Node_Str"") && myfile.exists()) {
      try {
        myfile=myfile.getCanonicalFile();
      }
 catch (      Exception ex) {
        throw new BuildException(ex);
      }
      currentelement=fileUtils.removeLeadingPath(basedir,myfile);
    }
    if (!myfile.exists() && !isCaseSensitive) {
      File f=findFileCaseInsensitive(basedir,currentelement);
      if (f.exists()) {
        currentelement=fileUtils.removeLeadingPath(basedir,f);
        myfile=f;
      }
    }
    if (myfile.exists()) {
      if (!followSymlinks && isSymlink(basedir,currentelement)) {
        continue;
      }
      if (myfile.isDirectory()) {
        if (isIncluded(currentelement) && currentelement.length() > 0) {
          accountForIncludedDir(currentelement,myfile,true);
        }
 else {
          if (currentelement.length() > 0) {
            if (currentelement.charAt(currentelement.length() - 1) != File.separatorChar) {
              currentelement=currentelement + File.separatorChar;
            }
          }
          scandir(myfile,currentelement,true);
        }
      }
 else {
        if (isCaseSensitive && originalpattern.equals(currentelement)) {
          accountForIncludedFile(currentelement,myfile);
        }
 else         if (!isCaseSensitive && originalpattern.equalsIgnoreCase(currentelement)) {
          accountForIncludedFile(currentelement,myfile);
        }
      }
    }
  }
}",0.9491461812722838
64224,"public void test2ButCaseInsesitive(){
  DirectoryScanner ds=new DirectoryScanner();
  ds.setBasedir(new File(getProject().getBaseDir(),""String_Node_Str""));
  ds.setIncludes(new String[]{""String_Node_Str""});
  ds.setCaseSensitive(false);
  ds.scan();
  if (Os.isFamily(""String_Node_Str"")) {
    compareFiles(ds,new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  }
 else {
    compareFiles(ds,new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  }
}","public void test2ButCaseInsesitive(){
  DirectoryScanner ds=new DirectoryScanner();
  ds.setBasedir(new File(getProject().getBaseDir(),""String_Node_Str""));
  ds.setIncludes(new String[]{""String_Node_Str""});
  ds.setCaseSensitive(false);
  ds.scan();
  compareFiles(ds,new String[]{""String_Node_Str"",""String_Node_Str""},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}",0.7971311475409836
64225,"public void testFullPathMatchesCaseSensitive(){
  DirectoryScanner ds=new DirectoryScanner();
  ds.setBasedir(new File(getProject().getBaseDir(),""String_Node_Str""));
  ds.setIncludes(new String[]{""String_Node_Str""});
  ds.scan();
  if (Os.isFamily(""String_Node_Str"")) {
    compareFiles(ds,new String[]{""String_Node_Str""},new String[]{});
  }
 else {
    compareFiles(ds,new String[]{},new String[]{});
  }
}","public void testFullPathMatchesCaseSensitive(){
  DirectoryScanner ds=new DirectoryScanner();
  ds.setBasedir(new File(getProject().getBaseDir(),""String_Node_Str""));
  ds.setIncludes(new String[]{""String_Node_Str""});
  ds.scan();
  compareFiles(ds,new String[]{},new String[]{});
}",0.8127721335268505
64226,"public void testFullPathMatchesCaseInsensitive(){
  DirectoryScanner ds=new DirectoryScanner();
  ds.setCaseSensitive(false);
  ds.setBasedir(new File(getProject().getBaseDir(),""String_Node_Str""));
  ds.setIncludes(new String[]{""String_Node_Str""});
  ds.scan();
  if (Os.isFamily(""String_Node_Str"")) {
    compareFiles(ds,new String[]{""String_Node_Str""},new String[]{});
  }
 else {
    compareFiles(ds,new String[]{""String_Node_Str""},new String[]{});
  }
}","public void testFullPathMatchesCaseInsensitive(){
  DirectoryScanner ds=new DirectoryScanner();
  ds.setCaseSensitive(false);
  ds.setBasedir(new File(getProject().getBaseDir(),""String_Node_Str""));
  ds.setIncludes(new String[]{""String_Node_Str""});
  ds.scan();
  compareFiles(ds,new String[]{""String_Node_Str""},new String[]{});
}",0.8386277001270648
64227,"/** 
 * The regular expression used to search the file.
 * @param regular expression that must match a line in the file tobe selected.
 */
public void setExpression(String theexpression){
  this.userProvidedExpression=theexpression;
}","/** 
 * The regular expression used to search the file.
 * @param theexpression this must match a line in the file to be selected.
 */
public void setExpression(String theexpression){
  this.userProvidedExpression=theexpression;
}",0.9094827586206896
64228,"/** 
 * Whether to ignore whitespace in the string being searched.
 * @param whitespace whether to ignore any whitespace (spaces, tabs, etc.) in the searchstring
 */
public void setIgnorewhitespace(boolean ignorewhitespace){
  this.ignorewhitespace=ignorewhitespace;
}","/** 
 * Whether to ignore whitespace in the string being searched.
 * @param ignorewhitespace whether to ignore any whitespace (spaces, tabs, etc.) in the searchstring
 */
public void setIgnorewhitespace(boolean ignorewhitespace){
  this.ignorewhitespace=ignorewhitespace;
}",0.988929889298893
64229,public void process(String line) throws BuildException ;,"/** 
 * processing of one line of stdout or of stderr
 * @param line
 */
public void process(String line) throws BuildException ;",0.6054054054054054
64230,public void setOutput(String line) throws BuildException ;,"/** 
 * set any data to be written to P4's stdin
 * @param line the text to write to P4's stdin
 */
public void setOutput(String line) throws BuildException ;",0.5370370370370371
64231,public abstract void process(String line);,"/** 
 * subclasses of P4HandlerAdapter must implement this routine processing of one line of stdout or of stderr
 * @param line
 */
public abstract void process(String line);",0.3888888888888889
64232,"public void stop(){
}","public void stop(){
  myHandler.stop();
}",0.6774193548387096
64233,"public void start() throws BuildException {
  try {
    if (p4input != null && p4input.length() > 0 && os != null) {
      os.write(p4input.getBytes());
      os.flush();
      os.close();
    }
    Thread output=new Thread(new Reader(is));
    Thread error=new Thread(new Reader(es));
    output.start();
    error.start();
    output.join();
    error.join();
  }
 catch (  Exception e) {
    throw new BuildException(e);
  }
}","public void start() throws BuildException {
  if (p4input != null && p4input.length() > 0) {
    myHandler=new PumpStreamHandler(new P4OutputStream(this),new P4OutputStream(this),new ByteArrayInputStream(p4input.getBytes()));
  }
 else {
    myHandler=new PumpStreamHandler(new P4OutputStream(this),new P4OutputStream(this));
  }
  myHandler.setProcessInputStream(os);
  myHandler.setProcessErrorStream(es);
  myHandler.setProcessOutputStream(is);
  myHandler.start();
}",0.2202447163515016
64234,"public void setOutput(String p4Input){
  this.p4input=p4Input;
}","/** 
 * set any data to be written to P4's stdin
 * @param p4Input the text to write to P4's stdin
 */
public void setOutput(String p4Input){
  this.p4input=p4Input;
}",0.5541125541125541
64235,"/** 
 * Assemble string for parameters common for import and export Helper method to remove double code.
 */
private String assembleImportExportParams(File dir,String[] includePatterns,String[] excludePatterns,boolean includeClasses,boolean includeResources,boolean includeSources,boolean useDefaultExcludes){
  String result=VAJToolsServlet.DIR_PARAM + ""String_Node_Str"" + URLEncoder.encode(dir.getAbsolutePath())+ ""String_Node_Str""+ VAJToolsServlet.CLASSES_PARAM+ ""String_Node_Str""+ includeClasses+ ""String_Node_Str""+ VAJToolsServlet.RESOURCES_PARAM+ ""String_Node_Str""+ includeResources+ ""String_Node_Str""+ VAJToolsServlet.SOURCES_PARAM+ ""String_Node_Str""+ includeSources+ ""String_Node_Str""+ VAJToolsServlet.DEFAULT_EXCLUDES_PARAM+ ""String_Node_Str""+ useDefaultExcludes;
  if (includePatterns != null) {
    for (int i=0; i < includePatterns.length; i++) {
      result=result + ""String_Node_Str"" + VAJExportServlet.INCLUDE_PARAM+ ""String_Node_Str""+ URLEncoder.encode(includePatterns[i]);
    }
  }
  if (excludePatterns != null) {
    for (int i=0; i < excludePatterns.length; i++) {
      result=result + ""String_Node_Str"" + VAJExportServlet.EXCLUDE_PARAM+ ""String_Node_Str""+ URLEncoder.encode(excludePatterns[i]);
    }
  }
  return result;
}","/** 
 * Assemble string for parameters common for import and export Helper method to remove double code.
 */
private String assembleImportExportParams(File dir,String[] includePatterns,String[] excludePatterns,boolean includeClasses,boolean includeResources,boolean includeSources,boolean useDefaultExcludes){
  String result=VAJToolsServlet.DIR_PARAM + ""String_Node_Str"" + URLEncoder.encode(dir.getPath())+ ""String_Node_Str""+ VAJToolsServlet.CLASSES_PARAM+ ""String_Node_Str""+ includeClasses+ ""String_Node_Str""+ VAJToolsServlet.RESOURCES_PARAM+ ""String_Node_Str""+ includeResources+ ""String_Node_Str""+ VAJToolsServlet.SOURCES_PARAM+ ""String_Node_Str""+ includeSources+ ""String_Node_Str""+ VAJToolsServlet.DEFAULT_EXCLUDES_PARAM+ ""String_Node_Str""+ useDefaultExcludes;
  if (includePatterns != null) {
    for (int i=0; i < includePatterns.length; i++) {
      result=result + ""String_Node_Str"" + VAJExportServlet.INCLUDE_PARAM+ ""String_Node_Str""+ URLEncoder.encode(includePatterns[i]);
    }
  }
  if (excludePatterns != null) {
    for (int i=0; i < excludePatterns.length; i++) {
      result=result + ""String_Node_Str"" + VAJExportServlet.EXCLUDE_PARAM+ ""String_Node_Str""+ URLEncoder.encode(excludePatterns[i]);
    }
  }
  return result;
}",0.996781979082864
64236,"public void start() throws BuildException {
  try {
    if (p4input != null && p4input.length() > 0 && os != null) {
      os.write(p4input.getBytes());
      os.flush();
      os.close();
    }
    Thread output=new Thread(new Reader(is));
    Thread error=new Thread(new Reader(es));
    output.start();
    error.start();
  }
 catch (  Exception e) {
    throw new BuildException(e);
  }
}","public void start() throws BuildException {
  try {
    if (p4input != null && p4input.length() > 0 && os != null) {
      os.write(p4input.getBytes());
      os.flush();
      os.close();
    }
    Thread output=new Thread(new Reader(is));
    Thread error=new Thread(new Reader(es));
    output.start();
    error.start();
    output.join();
    error.join();
  }
 catch (  Exception e) {
    throw new BuildException(e);
  }
}",0.9549330085261876
64237,"/** 
 * Overriden from Zip class to deal with application.xml
 */
protected void zipFile(File file,ZipOutputStream zOut,String vPath,int mode) throws IOException {
  if (vPath.equalsIgnoreCase(""String_Node_Str"")) {
    if (deploymentDescriptor == null || !deploymentDescriptor.equals(file) || descriptorAdded) {
      log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ ""String_Node_Str""+ archiveType+ ""String_Node_Str"",Project.MSG_WARN);
    }
 else {
      super.zipFile(file,zOut,vPath,mode);
      descriptorAdded=true;
    }
  }
 else {
    super.zipFile(file,zOut,vPath,mode);
  }
}","/** 
 * Overriden from Zip class to deal with application.xml
 */
protected void zipFile(File file,ZipOutputStream zOut,String vPath,int mode) throws IOException {
  if (vPath.equalsIgnoreCase(""String_Node_Str"")) {
    if (deploymentDescriptor == null || !fu.fileNameEquals(deploymentDescriptor,file) || descriptorAdded) {
      log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ ""String_Node_Str""+ archiveType+ ""String_Node_Str"",Project.MSG_WARN);
    }
 else {
      super.zipFile(file,zOut,vPath,mode);
      descriptorAdded=true;
    }
  }
 else {
    super.zipFile(file,zOut,vPath,mode);
  }
}",0.9774436090225564
64238,"/** 
 * Overriden from Zip class to deal with web.xml
 */
protected void zipFile(File file,ZipOutputStream zOut,String vPath,int mode) throws IOException {
  if (vPath.equalsIgnoreCase(""String_Node_Str"")) {
    if (deploymentDescriptor == null || !deploymentDescriptor.equals(file) || descriptorAdded) {
      log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ ""String_Node_Str""+ archiveType+ ""String_Node_Str"",Project.MSG_WARN);
    }
 else {
      super.zipFile(file,zOut,vPath,mode);
      descriptorAdded=true;
    }
  }
 else {
    super.zipFile(file,zOut,vPath,mode);
  }
}","/** 
 * Overriden from Zip class to deal with web.xml
 */
protected void zipFile(File file,ZipOutputStream zOut,String vPath,int mode) throws IOException {
  if (vPath.equalsIgnoreCase(""String_Node_Str"")) {
    if (deploymentDescriptor == null || !fu.fileNameEquals(deploymentDescriptor,file) || descriptorAdded) {
      log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ ""String_Node_Str""+ archiveType+ ""String_Node_Str"",Project.MSG_WARN);
    }
 else {
      super.zipFile(file,zOut,vPath,mode);
      descriptorAdded=true;
    }
  }
 else {
    super.zipFile(file,zOut,vPath,mode);
  }
}",0.9771380186282812
64239,"/** 
 * Compares the contents of two files. <p>simple but sub-optimal comparision algorithm.  written for working rather than fast. Better would be a block read into buffers followed by long comparisions apart from the final 1-7 bytes.</p>
 * @since 1.9
 */
public boolean contentEquals(File f1,File f2) throws IOException {
  if (f1.exists() != f2.exists()) {
    return false;
  }
  if (!f1.exists()) {
    return true;
  }
  if (f1.isDirectory() || f2.isDirectory()) {
    return false;
  }
  if (f1.equals(f2)) {
    return true;
  }
  if (f1.length() != f2.length()) {
    return false;
  }
  InputStream in1=null;
  InputStream in2=null;
  try {
    in1=new BufferedInputStream(new FileInputStream(f1));
    in2=new BufferedInputStream(new FileInputStream(f2));
    int expectedByte=in1.read();
    while (expectedByte != -1) {
      if (expectedByte != in2.read()) {
        return false;
      }
      expectedByte=in1.read();
    }
    if (in2.read() != -1) {
      return false;
    }
    return true;
  }
  finally {
    if (in1 != null) {
      try {
        in1.close();
      }
 catch (      IOException e) {
      }
    }
    if (in2 != null) {
      try {
        in2.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","/** 
 * Compares the contents of two files. <p>simple but sub-optimal comparision algorithm.  written for working rather than fast. Better would be a block read into buffers followed by long comparisions apart from the final 1-7 bytes.</p>
 * @since 1.9
 */
public boolean contentEquals(File f1,File f2) throws IOException {
  if (f1.exists() != f2.exists()) {
    return false;
  }
  if (!f1.exists()) {
    return true;
  }
  if (f1.isDirectory() || f2.isDirectory()) {
    return false;
  }
  if (fileNameEquals(f1,f2)) {
    return true;
  }
  if (f1.length() != f2.length()) {
    return false;
  }
  InputStream in1=null;
  InputStream in2=null;
  try {
    in1=new BufferedInputStream(new FileInputStream(f1));
    in2=new BufferedInputStream(new FileInputStream(f2));
    int expectedByte=in1.read();
    while (expectedByte != -1) {
      if (expectedByte != in2.read()) {
        return false;
      }
      expectedByte=in1.read();
    }
    if (in2.read() != -1) {
      return false;
    }
    return true;
  }
  finally {
    if (in1 != null) {
      try {
        in1.close();
      }
 catch (      IOException e) {
      }
    }
    if (in2 != null) {
      try {
        in2.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.994422310756972
64240,"/** 
 * Collect the resources that are newer than the corresponding entries (or missing) in the original archive. <p>If we are going to recreate the archive instead of updating it, all resources should be considered as new, if a single one is.  Because of this, subclasses overriding this method must call <code>super.getResourcesToAdd</code> and indicate with the third arg if they already know that the archive is out-of-date.</p>
 * @param filesets The filesets to grab resources from
 * @param zipFile intended archive file (may or may not exist)
 * @param needsUpdate whether we already know that the archive isout-of-date.  Subclasses overriding this method are supposed to set this value correctly in their call to super.getResourcesToAdd.
 * @return an array of resources to add for each fileset passed in.
 * @exception BuildException if it likes
 */
protected Resource[][] getResourcesToAdd(FileSet[] filesets,File zipFile,boolean needsUpdate) throws BuildException {
  if (zipFile.exists()) {
    try {
      originalManifest=getManifestFromJar(zipFile);
      if (originalManifest == null) {
        log(""String_Node_Str"",Project.MSG_VERBOSE);
        needsUpdate=true;
      }
 else {
        Manifest mf=createManifest();
        if (!mf.equals(originalManifest)) {
          log(""String_Node_Str"",Project.MSG_VERBOSE);
          needsUpdate=true;
        }
      }
    }
 catch (    Throwable t) {
      log(""String_Node_Str"" + t.getMessage(),Project.MSG_WARN);
      needsUpdate=true;
    }
  }
 else {
    needsUpdate=true;
  }
  createEmpty=needsUpdate;
  return super.getResourcesToAdd(filesets,zipFile,needsUpdate);
}","/** 
 * Collect the resources that are newer than the corresponding entries (or missing) in the original archive. <p>If we are going to recreate the archive instead of updating it, all resources should be considered as new, if a single one is.  Because of this, subclasses overriding this method must call <code>super.getResourcesToAdd</code> and indicate with the third arg if they already know that the archive is out-of-date.</p>
 * @param filesets The filesets to grab resources from
 * @param zipFile intended archive file (may or may not exist)
 * @param needsUpdate whether we already know that the archive isout-of-date.  Subclasses overriding this method are supposed to set this value correctly in their call to super.getResourcesToAdd.
 * @return an array of resources to add for each fileset passed in as wellas a flag that indicates whether the archive is uptodate.
 * @exception BuildException if it likes
 */
protected ArchiveState getResourcesToAdd(FileSet[] filesets,File zipFile,boolean needsUpdate) throws BuildException {
  if (zipFile.exists()) {
    try {
      originalManifest=getManifestFromJar(zipFile);
      if (originalManifest == null) {
        log(""String_Node_Str"",Project.MSG_VERBOSE);
        needsUpdate=true;
      }
 else {
        Manifest mf=createManifest();
        if (!mf.equals(originalManifest)) {
          log(""String_Node_Str"",Project.MSG_VERBOSE);
          needsUpdate=true;
        }
      }
    }
 catch (    Throwable t) {
      log(""String_Node_Str"" + t.getMessage(),Project.MSG_WARN);
      needsUpdate=true;
    }
  }
 else {
    needsUpdate=true;
  }
  createEmpty=needsUpdate;
  return super.getResourcesToAdd(filesets,zipFile,needsUpdate);
}",0.9736369083283404
64241,"public void executeMain() throws BuildException {
  if (baseDir == null && filesets.size() == 0 && groupfilesets.size() == 0 && ""String_Node_Str"".equals(archiveType)) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (zipFile == null) {
    throw new BuildException(""String_Node_Str"" + archiveType + ""String_Node_Str"");
  }
  File renamedFile=null;
  addingNewFiles=true;
  doUpdate=doUpdate && zipFile.exists();
  for (int i=0; i < groupfilesets.size(); i++) {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    FileSet fs=(FileSet)groupfilesets.elementAt(i);
    FileScanner scanner=fs.getDirectoryScanner(getProject());
    String[] files=scanner.getIncludedFiles();
    File basedir=scanner.getBasedir();
    for (int j=0; j < files.length; j++) {
      log(""String_Node_Str"" + files[j] + ""String_Node_Str"",Project.MSG_VERBOSE);
      ZipFileSet zf=new ZipFileSet();
      zf.setSrc(new File(basedir,files[j]));
      filesets.addElement(zf);
      filesetsFromGroupfilesets.addElement(zf);
    }
  }
  Vector vfss=new Vector();
  if (baseDir != null) {
    FileSet fs=(FileSet)getImplicitFileSet().clone();
    fs.setDir(baseDir);
    vfss.addElement(fs);
  }
  for (int i=0; i < filesets.size(); i++) {
    FileSet fs=(FileSet)filesets.elementAt(i);
    vfss.addElement(fs);
  }
  FileSet[] fss=new FileSet[vfss.size()];
  vfss.copyInto(fss);
  boolean success=false;
  try {
    Resource[][] addThem=getResourcesToAdd(fss,zipFile,false);
    if (isEmpty(addThem)) {
      return;
    }
    if (doUpdate) {
      renamedFile=fileUtils.createTempFile(""String_Node_Str"",""String_Node_Str"",fileUtils.getParentFile(zipFile));
      try {
        if (!zipFile.renameTo(renamedFile)) {
          throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 catch (      SecurityException e) {
        throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    String action=doUpdate ? ""String_Node_Str"" : ""String_Node_Str"";
    log(action + archiveType + ""String_Node_Str""+ zipFile.getAbsolutePath());
    ZipOutputStream zOut=null;
    try {
      if (!skipWriting) {
        zOut=new ZipOutputStream(new FileOutputStream(zipFile));
        zOut.setEncoding(encoding);
        if (doCompress) {
          zOut.setMethod(ZipOutputStream.DEFLATED);
        }
 else {
          zOut.setMethod(ZipOutputStream.STORED);
        }
      }
      initZipOutputStream(zOut);
      for (int i=0; i < fss.length; i++) {
        if (addThem[i].length != 0) {
          addResources(fss[i],addThem[i],zOut);
        }
      }
      if (doUpdate) {
        addingNewFiles=false;
        ZipFileSet oldFiles=new ZipFileSet();
        oldFiles.setSrc(renamedFile);
        for (int i=0; i < addedFiles.size(); i++) {
          PatternSet.NameEntry ne=oldFiles.createExclude();
          ne.setName((String)addedFiles.elementAt(i));
        }
        DirectoryScanner ds=oldFiles.getDirectoryScanner(getProject());
        String[] f=ds.getIncludedFiles();
        Resource[] r=new Resource[f.length];
        for (int i=0; i < f.length; i++) {
          r[i]=ds.getResource(f[i]);
        }
        addResources(oldFiles,r,zOut);
      }
      finalizeZipOutputStream(zOut);
      if (doUpdate) {
        if (!renamedFile.delete()) {
          log(""String_Node_Str"" + renamedFile.getName(),Project.MSG_WARN);
        }
      }
      success=true;
    }
  finally {
      try {
        if (zOut != null) {
          zOut.close();
        }
      }
 catch (      IOException ex) {
        if (success) {
          throw ex;
        }
      }
    }
  }
 catch (  IOException ioe) {
    String msg=""String_Node_Str"" + archiveType + ""String_Node_Str""+ ioe.getMessage();
    if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
      msg+=""String_Node_Str"" + ""String_Node_Str"";
    }
    if (doUpdate && renamedFile != null) {
      if (!renamedFile.renameTo(zipFile)) {
        msg+=""String_Node_Str"" + renamedFile.getName() + ""String_Node_Str"";
      }
    }
    throw new BuildException(msg,ioe,getLocation());
  }
 finally {
    cleanUp();
  }
}","public void executeMain() throws BuildException {
  if (baseDir == null && filesets.size() == 0 && groupfilesets.size() == 0 && ""String_Node_Str"".equals(archiveType)) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (zipFile == null) {
    throw new BuildException(""String_Node_Str"" + archiveType + ""String_Node_Str"");
  }
  File renamedFile=null;
  addingNewFiles=true;
  if (doUpdate && !zipFile.exists()) {
    doUpdate=false;
    log(""String_Node_Str"" + archiveType + ""String_Node_Str"",Project.MSG_DEBUG);
  }
  for (int i=0; i < groupfilesets.size(); i++) {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    FileSet fs=(FileSet)groupfilesets.elementAt(i);
    FileScanner scanner=fs.getDirectoryScanner(getProject());
    String[] files=scanner.getIncludedFiles();
    File basedir=scanner.getBasedir();
    for (int j=0; j < files.length; j++) {
      log(""String_Node_Str"" + files[j] + ""String_Node_Str"",Project.MSG_VERBOSE);
      ZipFileSet zf=new ZipFileSet();
      zf.setSrc(new File(basedir,files[j]));
      filesets.addElement(zf);
      filesetsFromGroupfilesets.addElement(zf);
    }
  }
  Vector vfss=new Vector();
  if (baseDir != null) {
    FileSet fs=(FileSet)getImplicitFileSet().clone();
    fs.setDir(baseDir);
    vfss.addElement(fs);
  }
  for (int i=0; i < filesets.size(); i++) {
    FileSet fs=(FileSet)filesets.elementAt(i);
    vfss.addElement(fs);
  }
  FileSet[] fss=new FileSet[vfss.size()];
  vfss.copyInto(fss);
  boolean success=false;
  try {
    ArchiveState state=getResourcesToAdd(fss,zipFile,false);
    if (!state.isOutOfDate()) {
      return;
    }
    Resource[][] addThem=state.getResourcesToAdd();
    if (doUpdate) {
      renamedFile=fileUtils.createTempFile(""String_Node_Str"",""String_Node_Str"",fileUtils.getParentFile(zipFile));
      try {
        if (!zipFile.renameTo(renamedFile)) {
          throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 catch (      SecurityException e) {
        throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    String action=doUpdate ? ""String_Node_Str"" : ""String_Node_Str"";
    log(action + archiveType + ""String_Node_Str""+ zipFile.getAbsolutePath());
    ZipOutputStream zOut=null;
    try {
      if (!skipWriting) {
        zOut=new ZipOutputStream(new FileOutputStream(zipFile));
        zOut.setEncoding(encoding);
        if (doCompress) {
          zOut.setMethod(ZipOutputStream.DEFLATED);
        }
 else {
          zOut.setMethod(ZipOutputStream.STORED);
        }
      }
      initZipOutputStream(zOut);
      for (int i=0; i < fss.length; i++) {
        if (addThem[i].length != 0) {
          addResources(fss[i],addThem[i],zOut);
        }
      }
      if (doUpdate) {
        addingNewFiles=false;
        ZipFileSet oldFiles=new ZipFileSet();
        oldFiles.setSrc(renamedFile);
        for (int i=0; i < addedFiles.size(); i++) {
          PatternSet.NameEntry ne=oldFiles.createExclude();
          ne.setName((String)addedFiles.elementAt(i));
        }
        DirectoryScanner ds=oldFiles.getDirectoryScanner(getProject());
        String[] f=ds.getIncludedFiles();
        Resource[] r=new Resource[f.length];
        for (int i=0; i < f.length; i++) {
          r[i]=ds.getResource(f[i]);
        }
        addResources(oldFiles,r,zOut);
      }
      finalizeZipOutputStream(zOut);
      if (doUpdate) {
        if (!renamedFile.delete()) {
          log(""String_Node_Str"" + renamedFile.getName(),Project.MSG_WARN);
        }
      }
      success=true;
    }
  finally {
      try {
        if (zOut != null) {
          zOut.close();
        }
      }
 catch (      IOException ex) {
        if (success) {
          throw ex;
        }
      }
    }
  }
 catch (  IOException ioe) {
    String msg=""String_Node_Str"" + archiveType + ""String_Node_Str""+ ioe.getMessage();
    if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
      msg+=""String_Node_Str"" + ""String_Node_Str"";
    }
    if (doUpdate && renamedFile != null) {
      if (!renamedFile.renameTo(zipFile)) {
        msg+=""String_Node_Str"" + renamedFile.getName() + ""String_Node_Str"";
      }
    }
    throw new BuildException(msg,ioe,getLocation());
  }
 finally {
    cleanUp();
  }
}",0.963209114645146
64242,"/** 
 * Collect the resources that are newer than the corresponding entries (or missing) in the original archive. <p>If we are going to recreate the archive instead of updating it, all resources should be considered as new, if a single one is.  Because of this, subclasses overriding this method must call <code>super.getResourcesToAdd</code> and indicate with the third arg if they already know that the archive is out-of-date.</p>
 * @param filesets The filesets to grab resources from
 * @param zipFile intended archive file (may or may not exist)
 * @param needsUpdate whether we already know that the archive isout-of-date.  Subclasses overriding this method are supposed to set this value correctly in their call to super.getResourcesToAdd.
 * @return an array of resources to add for each fileset passed in.
 * @exception BuildException if it likes
 */
protected Resource[][] getResourcesToAdd(FileSet[] filesets,File zipFile,boolean needsUpdate) throws BuildException {
  Resource[][] initialResources=grabResources(filesets);
  if (isEmpty(initialResources)) {
    if (emptyBehavior.equals(""String_Node_Str"")) {
      if (doUpdate) {
        log(archiveType + ""String_Node_Str"" + zipFile+ ""String_Node_Str"",Project.MSG_VERBOSE);
      }
 else {
        log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ zipFile+ ""String_Node_Str"",Project.MSG_WARN);
      }
    }
 else     if (emptyBehavior.equals(""String_Node_Str"")) {
      throw new BuildException(""String_Node_Str"" + archiveType + ""String_Node_Str""+ zipFile+ ""String_Node_Str"",getLocation());
    }
 else {
      createEmptyZip(zipFile);
    }
    return initialResources;
  }
  if (!zipFile.exists()) {
    return initialResources;
  }
  if (needsUpdate && !doUpdate) {
    return initialResources;
  }
  Resource[][] newerResources=new Resource[filesets.length][];
  for (int i=0; i < filesets.length; i++) {
    if (!(fileset instanceof ZipFileSet) || ((ZipFileSet)fileset).getSrc() == null) {
      File base=filesets[i].getDir(getProject());
      for (int j=0; j < initialResources[i].length; j++) {
        File resourceAsFile=fileUtils.resolveFile(base,initialResources[i][j].getName());
        if (resourceAsFile.equals(zipFile)) {
          throw new BuildException(""String_Node_Str"" + ""String_Node_Str"",getLocation());
        }
      }
    }
  }
  for (int i=0; i < filesets.length; i++) {
    if (initialResources[i].length == 0) {
      newerResources[i]=new Resource[]{};
      continue;
    }
    FileNameMapper myMapper=new IdentityMapper();
    if (filesets[i] instanceof ZipFileSet) {
      ZipFileSet zfs=(ZipFileSet)filesets[i];
      if (zfs.getFullpath() != null && !zfs.getFullpath().equals(""String_Node_Str"")) {
        MergingMapper fm=new MergingMapper();
        fm.setTo(zfs.getFullpath());
        myMapper=fm;
      }
 else       if (zfs.getPrefix() != null && !zfs.getPrefix().equals(""String_Node_Str"")) {
        GlobPatternMapper gm=new GlobPatternMapper();
        gm.setFrom(""String_Node_Str"");
        String prefix=zfs.getPrefix();
        if (!prefix.endsWith(""String_Node_Str"") && !prefix.endsWith(""String_Node_Str"")) {
          prefix+=""String_Node_Str"";
        }
        gm.setTo(prefix + ""String_Node_Str"");
        myMapper=gm;
      }
    }
    newerResources[i]=ResourceUtils.selectOutOfDateSources(this,initialResources[i],myMapper,getZipScanner());
    needsUpdate=needsUpdate || (newerResources[i].length > 0);
    if (needsUpdate && !doUpdate) {
      break;
    }
  }
  if (needsUpdate && !doUpdate) {
    return initialResources;
  }
  return newerResources;
}","public Resource[][] getResourcesToAdd(){
  return resourcesToAdd;
}",0.0339539978094194
64243,"/** 
 * Sets up the environment for toExecute and then runs it.
 * @throws BuildException
 */
protected void runCommand(Commandline toExecute) throws BuildException {
  Environment env=new Environment();
  if (port > 0) {
    Environment.Variable var=new Environment.Variable();
    var.setKey(""String_Node_Str"");
    var.setValue(String.valueOf(port));
    env.addVariable(var);
  }
  if (passFile == null) {
    File defaultPassFile=new File(System.getProperty(""String_Node_Str"",System.getProperty(""String_Node_Str"")) + File.separatorChar + ""String_Node_Str"");
    if (defaultPassFile.exists())     this.setPassfile(defaultPassFile);
  }
  if (passFile != null) {
    Environment.Variable var=new Environment.Variable();
    var.setKey(""String_Node_Str"");
    var.setValue(String.valueOf(passFile));
    env.addVariable(var);
    log(""String_Node_Str"" + String.valueOf(passFile),Project.MSG_INFO);
  }
  if (cvsRsh != null) {
    Environment.Variable var=new Environment.Variable();
    var.setKey(""String_Node_Str"");
    var.setValue(String.valueOf(cvsRsh));
    env.addVariable(var);
  }
  Execute exe=new Execute(getExecuteStreamHandler(),null);
  exe.setAntRun(getProject());
  if (dest == null) {
    dest=getProject().getBaseDir();
  }
  if (!dest.exists()) {
    dest.mkdirs();
  }
  exe.setWorkingDirectory(dest);
  exe.setCommandline(toExecute.getCommandline());
  exe.setEnvironment(env.getVariables());
  try {
    String actualCommandLine=executeToString(exe);
    log(actualCommandLine,Project.MSG_VERBOSE);
    int retCode=exe.execute();
    log(""String_Node_Str"" + retCode,Project.MSG_DEBUG);
    if (failOnError && retCode != 0) {
      throw new BuildException(""String_Node_Str"" + retCode + StringUtils.LINE_SEP+ ""String_Node_Str""+ actualCommandLine+ ""String_Node_Str"",getLocation());
    }
  }
 catch (  IOException e) {
    if (failOnError) {
      throw new BuildException(e,getLocation());
    }
 else {
      log(""String_Node_Str"" + e.getMessage(),Project.MSG_WARN);
    }
  }
catch (  BuildException e) {
    if (failOnError) {
      throw (e);
    }
 else {
      Throwable t=e.getException();
      if (t == null) {
        t=e;
      }
      log(""String_Node_Str"" + t.getMessage(),Project.MSG_WARN);
    }
  }
catch (  Exception e) {
    if (failOnError) {
      throw new BuildException(e,getLocation());
    }
 else {
      log(""String_Node_Str"" + e.getMessage(),Project.MSG_WARN);
    }
  }
 finally {
    if (outputStream != null) {
      try {
        outputStream.close();
      }
 catch (      IOException e) {
      }
    }
    if (errorStream != null) {
      try {
        errorStream.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","/** 
 * Sets up the environment for toExecute and then runs it.
 * @throws BuildException
 */
protected void runCommand(Commandline toExecute) throws BuildException {
  Environment env=new Environment();
  if (port > 0) {
    Environment.Variable var=new Environment.Variable();
    var.setKey(""String_Node_Str"");
    var.setValue(String.valueOf(port));
    env.addVariable(var);
  }
  if (passFile == null) {
    File defaultPassFile=new File(System.getProperty(""String_Node_Str"",System.getProperty(""String_Node_Str"")) + File.separatorChar + ""String_Node_Str"");
    if (defaultPassFile.exists()) {
      this.setPassfile(defaultPassFile);
    }
  }
  if (passFile != null) {
    if (passFile.isFile() && passFile.canRead()) {
      Environment.Variable var=new Environment.Variable();
      var.setKey(""String_Node_Str"");
      var.setValue(String.valueOf(passFile));
      env.addVariable(var);
      log(""String_Node_Str"" + String.valueOf(passFile),Project.MSG_INFO);
    }
 else     if (!passFile.canRead()) {
      log(""String_Node_Str"" + String.valueOf(passFile) + ""String_Node_Str"",Project.MSG_WARN);
    }
 else {
      log(""String_Node_Str"" + String.valueOf(passFile) + ""String_Node_Str"",Project.MSG_WARN);
    }
  }
  if (cvsRsh != null) {
    Environment.Variable var=new Environment.Variable();
    var.setKey(""String_Node_Str"");
    var.setValue(String.valueOf(cvsRsh));
    env.addVariable(var);
  }
  Execute exe=new Execute(getExecuteStreamHandler(),null);
  exe.setAntRun(getProject());
  if (dest == null) {
    dest=getProject().getBaseDir();
  }
  if (!dest.exists()) {
    dest.mkdirs();
  }
  exe.setWorkingDirectory(dest);
  exe.setCommandline(toExecute.getCommandline());
  exe.setEnvironment(env.getVariables());
  try {
    String actualCommandLine=executeToString(exe);
    log(actualCommandLine,Project.MSG_VERBOSE);
    int retCode=exe.execute();
    log(""String_Node_Str"" + retCode,Project.MSG_DEBUG);
    if (failOnError && retCode != 0) {
      throw new BuildException(""String_Node_Str"" + retCode + StringUtils.LINE_SEP+ ""String_Node_Str""+ actualCommandLine+ ""String_Node_Str"",getLocation());
    }
  }
 catch (  IOException e) {
    if (failOnError) {
      throw new BuildException(e,getLocation());
    }
 else {
      log(""String_Node_Str"" + e.getMessage(),Project.MSG_WARN);
    }
  }
catch (  BuildException e) {
    if (failOnError) {
      throw (e);
    }
 else {
      Throwable t=e.getException();
      if (t == null) {
        t=e;
      }
      log(""String_Node_Str"" + t.getMessage(),Project.MSG_WARN);
    }
  }
catch (  Exception e) {
    if (failOnError) {
      throw new BuildException(e,getLocation());
    }
 else {
      log(""String_Node_Str"" + e.getMessage(),Project.MSG_WARN);
    }
  }
 finally {
    if (outputStream != null) {
      try {
        outputStream.close();
      }
 catch (      IOException e) {
      }
    }
    if (errorStream != null) {
      try {
        errorStream.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.5205191160996142
64244,"/** 
 * Determines if the OS on which Ant is executing matches the given OS family, name, architecture and version
 * @param family   The OS family
 * @param name   The OS name
 * @param arch   The OS architecture
 * @param version   The OS version
 * @since 1.7
 */
public static boolean isOs(String family,String name,String arch,String version){
  boolean retValue=false;
  if (family != null || name != null || arch != null || version != null) {
    boolean isFamily=true;
    boolean isName=true;
    boolean isArch=true;
    boolean isVersion=true;
    if (family != null) {
      if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=pathSep.equals(""String_Node_Str"") && !isFamily(""String_Node_Str"");
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=pathSep.equals(""String_Node_Str"") && (!isFamily(""String_Node_Str"") || osName.endsWith(""String_Node_Str""));
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=isFamily(""String_Node_Str"") && !(osName.indexOf(""String_Node_Str"") >= 0 || osName.indexOf(""String_Node_Str"") >= 0 || osName.indexOf(""String_Node_Str"") >= 0);
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1 || osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else {
        throw new BuildException(""String_Node_Str"" + family + ""String_Node_Str"");
      }
    }
    if (name != null) {
      isName=name.equals(osName);
    }
    if (arch != null) {
      isArch=arch.equals(osArch);
    }
    if (version != null) {
      isVersion=version.equals(osVersion);
    }
    retValue=isFamily && isName && isArch&& isVersion;
  }
  return retValue;
}","/** 
 * Determines if the OS on which Ant is executing matches the given OS family, name, architecture and version
 * @param family   The OS family
 * @param name   The OS name
 * @param arch   The OS architecture
 * @param version   The OS version
 * @since 1.7
 */
public static boolean isOs(String family,String name,String arch,String version){
  boolean retValue=false;
  if (family != null || name != null || arch != null || version != null) {
    boolean isFamily=true;
    boolean isName=true;
    boolean isArch=true;
    boolean isVersion=true;
    if (family != null) {
      if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=pathSep.equals(""String_Node_Str"") && !isFamily(""String_Node_Str"");
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=pathSep.equals(""String_Node_Str"") && (!isFamily(""String_Node_Str"") || osName.endsWith(""String_Node_Str""));
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=isFamily(""String_Node_Str"") && !(osName.indexOf(""String_Node_Str"") >= 0 || osName.indexOf(""String_Node_Str"") >= 0 || osName.indexOf(""String_Node_Str"") >= 0 || osName.indexOf(""String_Node_Str"") >= 0);
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1 || osName.indexOf(""String_Node_Str"") > -1;
      }
 else       if (family.equals(""String_Node_Str"")) {
        isFamily=osName.indexOf(""String_Node_Str"") > -1;
      }
 else {
        throw new BuildException(""String_Node_Str"" + family + ""String_Node_Str"");
      }
    }
    if (name != null) {
      isName=name.equals(osName);
    }
    if (arch != null) {
      isArch=arch.equals(osArch);
    }
    if (version != null) {
      isVersion=version.equals(osVersion);
    }
    retValue=isFamily && isName && isArch&& isVersion;
  }
  return retValue;
}",0.990829694323144
64245,"/** 
 * Utility method to lookup a ResourceLocation in the filesystem.
 * @return An InputSource for reading the file, or <code>null</code>if the file does not exist or is not readable.
 */
private InputSource filesystemLookup(ResourceLocation matchingEntry){
  String uri=matchingEntry.getLocation();
  URL baseURL=null;
  if (matchingEntry.getBase() != null) {
    baseURL=matchingEntry.getBase();
  }
 else {
    try {
      baseURL=getProject().getBaseDir().toURL();
    }
 catch (    MalformedURLException ex) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  InputSource source=null;
  URL url=null;
  try {
    url=new URL(baseURL,uri);
  }
 catch (  MalformedURLException ex) {
  }
  if (url != null) {
    String fileName=url.getFile();
    if (fileName != null) {
      log(""String_Node_Str"" + fileName,Project.MSG_DEBUG);
      File resFile=new File(fileName);
      if (resFile.exists() && resFile.canRead()) {
        try {
          source=new InputSource(new FileInputStream(resFile));
          String sysid=JAXPUtils.getSystemId(resFile);
          source.setSystemId(sysid);
          log(""String_Node_Str"" + sysid + ""String_Node_Str"",Project.MSG_DEBUG);
        }
 catch (        FileNotFoundException ex) {
        }
catch (        IOException ex) {
        }
      }
    }
  }
  return source;
}","/** 
 * Utility method to lookup a ResourceLocation in the filesystem.
 * @return An InputSource for reading the file, or <code>null</code>if the file does not exist or is not readable.
 */
private InputSource filesystemLookup(ResourceLocation matchingEntry){
  String uri=matchingEntry.getLocation();
  URL baseURL=null;
  if (matchingEntry.getBase() != null) {
    baseURL=matchingEntry.getBase();
  }
 else {
    try {
      baseURL=fileUtils.getFileURL(getProject().getBaseDir());
    }
 catch (    MalformedURLException ex) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  InputSource source=null;
  URL url=null;
  try {
    url=new URL(baseURL,uri);
  }
 catch (  MalformedURLException ex) {
  }
  if (url != null) {
    String fileName=url.getFile();
    if (fileName != null) {
      log(""String_Node_Str"" + fileName,Project.MSG_DEBUG);
      File resFile=new File(fileName);
      if (resFile.exists() && resFile.canRead()) {
        try {
          source=new InputSource(new FileInputStream(resFile));
          String sysid=JAXPUtils.getSystemId(resFile);
          source.setSystemId(sysid);
          log(""String_Node_Str"" + sysid + ""String_Node_Str"",Project.MSG_DEBUG);
        }
 catch (        FileNotFoundException ex) {
        }
catch (        IOException ex) {
        }
      }
    }
  }
  return source;
}",0.976831091180867
64246,"/** 
 * Utility method to lookup a ResourceLocation in URL-space.
 * @return An InputSource for reading the resource, or <code>null</code>if the resource does not identify a valid URL or is not readable.
 */
private InputSource urlLookup(ResourceLocation matchingEntry){
  String uri=matchingEntry.getLocation();
  URL baseURL=null;
  if (matchingEntry.getBase() != null) {
    baseURL=matchingEntry.getBase();
  }
 else {
    try {
      baseURL=getProject().getBaseDir().toURL();
    }
 catch (    MalformedURLException ex) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  InputSource source=null;
  URL url=null;
  try {
    url=new URL(baseURL,uri);
  }
 catch (  MalformedURLException ex) {
  }
  if (url != null) {
    try {
      InputStream is=url.openStream();
      if (is != null) {
        source=new InputSource(is);
        String sysid=url.toExternalForm();
        source.setSystemId(sysid);
        log(""String_Node_Str"" + sysid + ""String_Node_Str"",Project.MSG_DEBUG);
      }
    }
 catch (    IOException ex) {
    }
  }
  return source;
}","/** 
 * Utility method to lookup a ResourceLocation in URL-space.
 * @return An InputSource for reading the resource, or <code>null</code>if the resource does not identify a valid URL or is not readable.
 */
private InputSource urlLookup(ResourceLocation matchingEntry){
  String uri=matchingEntry.getLocation();
  URL baseURL=null;
  if (matchingEntry.getBase() != null) {
    baseURL=matchingEntry.getBase();
  }
 else {
    try {
      baseURL=fileUtils.getFileURL(getProject().getBaseDir());
    }
 catch (    MalformedURLException ex) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  InputSource source=null;
  URL url=null;
  try {
    url=new URL(baseURL,uri);
  }
 catch (  MalformedURLException ex) {
  }
  if (url != null) {
    try {
      InputStream is=url.openStream();
      if (is != null) {
        source=new InputSource(is);
        String sysid=url.toExternalForm();
        source.setSystemId(sysid);
        log(""String_Node_Str"" + sysid + ""String_Node_Str"",Project.MSG_DEBUG);
      }
    }
 catch (    IOException ex) {
    }
  }
  return source;
}",0.9870490286771508
64247,"/** 
 * Constructs a <code>file:</code> URI that represents the external form of the given pathname. <p>Will be an absolute URI if the given path is absolute.</p> <p>This code doesn't handle non-ASCII characters properly.</p>
 * @since Ant 1.6
 */
public String toURI(String path){
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  try {
    path=normalize(path).getAbsolutePath();
    sb.append(""String_Node_Str"");
    if (!path.startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
  }
 catch (  BuildException e) {
  }
  path=path.replace('\\','/');
  CharacterIterator iter=new StringCharacterIterator(path);
  for (char c=iter.first(); c != CharacterIterator.DONE; c=iter.next()) {
    if (isSpecial[c]) {
      sb.append('%');
      sb.append(escapedChar1[c]);
      sb.append(escapedChar2[c]);
    }
 else {
      sb.append(c);
    }
  }
  return sb.toString();
}","/** 
 * Constructs a <code>file:</code> URI that represents the external form of the given pathname. <p>Will be an absolute URI if the given path is absolute.</p> <p>This code doesn't handle non-ASCII characters properly.</p>
 * @since Ant 1.6
 */
public String toURI(String path){
  boolean isDir=(new File(path)).isDirectory();
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  try {
    path=normalize(path).getAbsolutePath();
    sb.append(""String_Node_Str"");
    if (!path.startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
  }
 catch (  BuildException e) {
  }
  path=path.replace('\\','/');
  CharacterIterator iter=new StringCharacterIterator(path);
  for (char c=iter.first(); c != CharacterIterator.DONE; c=iter.next()) {
    if (isSpecial[c]) {
      sb.append('%');
      sb.append(escapedChar1[c]);
      sb.append(escapedChar2[c]);
    }
 else {
      sb.append(c);
    }
  }
  if (isDir && !path.endsWith(""String_Node_Str"")) {
    sb.append('/');
  }
  return sb.toString();
}",0.9354166666666668
64248,"/** 
 * Create a temporary file in a given directory. <p>The file denoted by the returned abstract pathname did not exist before this method was invoked, any subsequent invocation of this method will yield a different file name.</p> <p>This method is different to File.createTempFile of JDK 1.2 as it doesn't create the file itself and doesn't use platform specific temporary directory when the parentDir attribute is null.</p>
 * @param parentDir Directory to create the temporary file in -current working directory will be assumed if this parameter is null.
 * @since 1.8
 */
public File createTempFile(String prefix,String suffix,File parentDir){
  File result=null;
  String parent=null;
  if (parentDir != null) {
    parent=parentDir.getPath();
  }
  DecimalFormat fmt=new DecimalFormat(""String_Node_Str"");
synchronized (rand) {
    do {
      result=new File(parent,prefix + fmt.format(rand.nextInt(Integer.MAX_VALUE)) + suffix);
    }
 while (result.exists());
  }
  return result;
}","/** 
 * Create a temporary file in a given directory. <p>The file denoted by the returned abstract pathname did not exist before this method was invoked, any subsequent invocation of this method will yield a different file name.</p> <p>This method is different to File.createTempFile of JDK 1.2 as it doesn't create the file itself and doesn't use platform specific temporary directory when the parentDir attribute is null.</p>
 * @param parentDir Directory to create the temporary file in -current working directory will be assumed if this parameter is null.
 * @since 1.8
 */
public File createTempFile(String prefix,String suffix,File parentDir){
  File result=null;
  String parent=null;
  if (parentDir != null) {
    parent=parentDir.getPath();
  }
  DecimalFormat fmt=new DecimalFormat(""String_Node_Str"");
synchronized (rand) {
    do {
      result=new File(parent,prefix + fmt.format(Math.abs(rand.nextInt())) + suffix);
    }
 while (result.exists());
  }
  return result;
}",0.9863291139240506
64249,"/** 
 * Get the URL for a file taking into account # characters
 * @param file the file whose URL representation is required.
 * @return The FileURL value
 * @throws MalformedURLException if the URL representation cannot beformed.
 */
public URL getFileURL(File file) throws MalformedURLException {
  String path=file.getAbsolutePath();
  if (file.isDirectory()) {
    path+=""String_Node_Str"";
  }
  return new URL(toURI(path));
}","/** 
 * Get the URL for a file taking into account # characters
 * @param file the file whose URL representation is required.
 * @return The FileURL value
 * @throws MalformedURLException if the URL representation cannot beformed.
 */
public URL getFileURL(File file) throws MalformedURLException {
  return new URL(toURI(file.getAbsolutePath()));
}",0.8421052631578947
64250,"public boolean containsValue(Object value){
  initAll();
  return super.containsValue(value);
}","public boolean containsValue(Object value){
  initAll();
  return super.contains(value);
}",0.972972972972973
64251,"/** 
 * Adds descriptive text to the project.
 */
public void addText(String text){
  String currentDescription=getProject().getDescription();
  if (currentDescription == null) {
    getProject().setDescription(text);
  }
 else {
    getProject().setDescription(currentDescription + text);
  }
}","/** 
 * Adds descriptive text to the project.
 */
public void addText(String text){
  ProjectHelper ph=ProjectHelper.getProjectHelper();
  if (!(ph instanceof ProjectHelperImpl)) {
    return;
  }
  String currentDescription=getProject().getDescription();
  if (currentDescription == null) {
    getProject().setDescription(text);
  }
 else {
    getProject().setDescription(currentDescription + text);
  }
}",0.8392603129445235
64252,"/** 
 * Initialisation routine called after handler creation with the element name and attributes. This configures the element with its attributes and sets it up with its parent container (if any). Nested elements are then added later as the parser encounters them.
 * @param tag Name of the element which caused this handlerto be created. Must not be <code>null</code>.
 * @param attrs Attributes of the element which caused thishandler to be created. Must not be <code>null</code>.
 * @exception org.xml.sax.SAXParseException in case of error (not thrown inthis implementation)
 */
public void onStartElement(String uri,String tag,String qname,Attributes attrs,AntXmlContext context) throws SAXParseException {
  RuntimeConfigurable parentWrapper=context.currentWrapper();
  RuntimeConfigurable wrapper=null;
  UnknownElement task=new UnknownElement(qname);
  task.setProject(context.getProject());
  task.setTaskName(qname);
  Location location=new Location(context.locator.getSystemId(),context.locator.getLineNumber(),context.locator.getColumnNumber());
  task.setLocation(location);
  task.setOwningTarget(context.currentTarget);
  context.configureId(task,attrs);
  Object parent=null;
  if (parentWrapper != null) {
    parent=parentWrapper.getProxy();
  }
  if (parent != null) {
    ((UnknownElement)parent).addChild(task);
  }
 else {
    context.currentTarget.addTask(task);
  }
  wrapper=new RuntimeConfigurable(task,task.getTaskName());
  wrapper.setAttributes2(attrs);
  if (parentWrapper != null) {
    parentWrapper.addChild(wrapper);
  }
  context.pushWrapper(wrapper);
}","/** 
 * Initialisation routine called after handler creation with the element name and attributes. This configures the element with its attributes and sets it up with its parent container (if any). Nested elements are then added later as the parser encounters them.
 * @param tag Name of the element which caused this handlerto be created. Must not be <code>null</code>.
 * @param attrs Attributes of the element which caused thishandler to be created. Must not be <code>null</code>.
 * @exception org.xml.sax.SAXParseException in case of error (not thrown inthis implementation)
 */
public void onStartElement(String uri,String tag,String qname,Attributes attrs,AntXmlContext context) throws SAXParseException {
  RuntimeConfigurable parentWrapper=context.currentWrapper();
  RuntimeConfigurable wrapper=null;
  Object parent=null;
  if (parentWrapper != null) {
    parent=parentWrapper.getProxy();
  }
  if (parent != null) {
    qname=qname.toLowerCase(Locale.US);
  }
  UnknownElement task=new UnknownElement(qname);
  task.setProject(context.getProject());
  task.setTaskName(qname);
  Location location=new Location(context.locator.getSystemId(),context.locator.getLineNumber(),context.locator.getColumnNumber());
  task.setLocation(location);
  task.setOwningTarget(context.currentTarget);
  context.configureId(task,attrs);
  if (parent != null) {
    ((UnknownElement)parent).addChild(task);
  }
 else {
    context.currentTarget.addTask(task);
  }
  wrapper=new RuntimeConfigurable(task,task.getTaskName());
  wrapper.setAttributes2(attrs);
  if (parentWrapper != null) {
    parentWrapper.addChild(wrapper);
  }
  context.pushWrapper(wrapper);
}",0.7054836722119532
64253,"public boolean eval() throws BuildException {
  if (server == null) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port == 0) {
    throw new BuildException(""String_Node_Str"");
  }
  log(""String_Node_Str"" + server + ""String_Node_Str""+ port,Project.MSG_VERBOSE);
  try {
    java.net.Socket socket=new java.net.Socket(server,port);
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}","public boolean eval() throws BuildException {
  if (server == null) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (port == 0) {
    throw new BuildException(""String_Node_Str"");
  }
  log(""String_Node_Str"" + server + ""String_Node_Str""+ port,Project.MSG_VERBOSE);
  try {
    new java.net.Socket(server,port);
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}",0.9727810650887574
64254,"/** 
 * Executes the task. <p> Builds a command line to execute ccm and then calls Exec's run method to execute the command line. </p>
 */
public void execute() throws BuildException {
  Commandline commandLine=new Commandline();
  Project aProj=getProject();
  int result=0;
  commandLine.setExecutable(getCcmCommand());
  commandLine.createArgument().setValue(getCcmAction());
  checkOptions(commandLine);
  result=run(commandLine);
  if (result != 0) {
    String msg=""String_Node_Str"" + commandLine.toString();
    throw new BuildException(msg,getLocation());
  }
}","/** 
 * Executes the task. <p> Builds a command line to execute ccm and then calls Exec's run method to execute the command line. </p>
 */
public void execute() throws BuildException {
  Commandline commandLine=new Commandline();
  int result=0;
  commandLine.setExecutable(getCcmCommand());
  commandLine.createArgument().setValue(getCcmAction());
  checkOptions(commandLine);
  result=run(commandLine);
  if (result != 0) {
    String msg=""String_Node_Str"" + commandLine.toString();
    throw new BuildException(msg,getLocation());
  }
}",0.9729241877256316
64255,"/** 
 * Executes the task. <p> Builds a command line to execute ccm and then calls Exec's run method to execute the command line. </p>
 */
public void execute() throws BuildException {
  Commandline commandLine=new Commandline();
  Project aProj=getProject();
  int result=0;
  commandLine.setExecutable(getCcmCommand());
  commandLine.createArgument().setValue(getCcmAction());
  checkOptions(commandLine);
  result=run(commandLine);
  if (result != 0) {
    String msg=""String_Node_Str"" + commandLine.toString();
    throw new BuildException(msg,getLocation());
  }
}","/** 
 * Executes the task. <p> Builds a command line to execute ccm and then calls Exec's run method to execute the command line. </p>
 */
public void execute() throws BuildException {
  Commandline commandLine=new Commandline();
  int result=0;
  commandLine.setExecutable(getCcmCommand());
  commandLine.createArgument().setValue(getCcmAction());
  checkOptions(commandLine);
  result=run(commandLine);
  if (result != 0) {
    String msg=""String_Node_Str"" + commandLine.toString();
    throw new BuildException(msg,getLocation());
  }
}",0.9729241877256316
64256,"/** 
 * Read the class from a data stream. This method takes an InputStream as input and parses the class from the stream. <p>
 * @param stream an InputStream from which the class will be read
 * @exception IOException if there is a problem reading from the givenstream.
 * @exception ClassFormatError if the class cannot be parsed correctly
 */
public void read(InputStream stream) throws IOException, ClassFormatError {
  DataInputStream classStream=new DataInputStream(stream);
  if (classStream.readInt() != CLASS_MAGIC) {
    throw new ClassFormatError(""String_Node_Str"" + ""String_Node_Str"");
  }
  int minorVersion=classStream.readUnsignedShort();
  int majorVersion=classStream.readUnsignedShort();
  constantPool=new ConstantPool();
  constantPool.read(classStream);
  constantPool.resolve();
  int accessFlags=classStream.readUnsignedShort();
  int thisClassIndex=classStream.readUnsignedShort();
  int superClassIndex=classStream.readUnsignedShort();
  ClassCPInfo classInfo=(ClassCPInfo)constantPool.getEntry(thisClassIndex);
  className=classInfo.getClassName();
}","/** 
 * Read the class from a data stream. This method takes an InputStream as input and parses the class from the stream. <p>
 * @param stream an InputStream from which the class will be read
 * @exception IOException if there is a problem reading from the givenstream.
 * @exception ClassFormatError if the class cannot be parsed correctly
 */
public void read(InputStream stream) throws IOException, ClassFormatError {
  DataInputStream classStream=new DataInputStream(stream);
  if (classStream.readInt() != CLASS_MAGIC) {
    throw new ClassFormatError(""String_Node_Str"" + ""String_Node_Str"");
  }
  classStream.readUnsignedShort();
  classStream.readUnsignedShort();
  constantPool=new ConstantPool();
  constantPool.read(classStream);
  constantPool.resolve();
  classStream.readUnsignedShort();
  int thisClassIndex=classStream.readUnsignedShort();
  classStream.readUnsignedShort();
  ClassCPInfo classInfo=(ClassCPInfo)constantPool.getEntry(thisClassIndex);
  className=classInfo.getClassName();
}",0.7463976945244957
64257,"/** 
 * Validates the passed in attributes. <p> The rules are: <ol> <li> If action is ""deploy"" or ""update"" the ""application"" and ""source"" attributes must be supplied. <li> If action is ""delete"" or ""undeploy"" the ""application"" attribute must be supplied.
 * @exception BuildException                       Descriptionof Exception
 */
public void validateAttributes() throws BuildException {
  Java java=getJava();
  String action=getTask().getAction();
  if (action == null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (!isActionValid()) {
    throw new BuildException(""String_Node_Str"" + action + ""String_Node_Str"");
  }
  if (getClassName() == null) {
    setClassName(JONAS_DEPLOY_CLASS_NAME);
  }
  if (jonasroot == null || jonasroot.isDirectory()) {
    java.createJvmarg().setValue(""String_Node_Str"" + jonasroot);
    java.createJvmarg().setValue(""String_Node_Str"" + jonasroot + ""String_Node_Str"");
    if (""String_Node_Str"".equals(orb)) {
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      if (davidHost != null) {
        java.createJvmarg().setValue(""String_Node_Str"" + davidHost);
      }
      if (davidPort != 0) {
        java.createJvmarg().setValue(""String_Node_Str"" + davidPort);
      }
    }
  }
  String anAction=getTask().getAction();
  if (getServer() != null) {
    java.createArg().setLine(""String_Node_Str"" + getServer());
  }
  if (action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE) || action.equals(""String_Node_Str"")) {
    java.createArg().setLine(""String_Node_Str"" + getTask().getSource());
  }
 else   if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {
    java.createArg().setLine(""String_Node_Str"" + getTask().getSource());
  }
 else   if (action.equals(ACTION_LIST)) {
    java.createArg().setValue(""String_Node_Str"");
  }
}","/** 
 * Validates the passed in attributes. <p> The rules are: <ol> <li> If action is ""deploy"" or ""update"" the ""application"" and ""source"" attributes must be supplied. <li> If action is ""delete"" or ""undeploy"" the ""application"" attribute must be supplied.
 * @exception BuildException                       Descriptionof Exception
 */
public void validateAttributes() throws BuildException {
  Java java=getJava();
  String action=getTask().getAction();
  if (action == null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (!isActionValid()) {
    throw new BuildException(""String_Node_Str"" + action + ""String_Node_Str"");
  }
  if (getClassName() == null) {
    setClassName(JONAS_DEPLOY_CLASS_NAME);
  }
  if (jonasroot == null || jonasroot.isDirectory()) {
    java.createJvmarg().setValue(""String_Node_Str"" + jonasroot);
    java.createJvmarg().setValue(""String_Node_Str"" + jonasroot + ""String_Node_Str"");
    if (""String_Node_Str"".equals(orb)) {
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      java.createJvmarg().setValue(""String_Node_Str"");
      if (davidHost != null) {
        java.createJvmarg().setValue(""String_Node_Str"" + davidHost);
      }
      if (davidPort != 0) {
        java.createJvmarg().setValue(""String_Node_Str"" + davidPort);
      }
    }
  }
  if (getServer() != null) {
    java.createArg().setLine(""String_Node_Str"" + getServer());
  }
  if (action.equals(ACTION_DEPLOY) || action.equals(ACTION_UPDATE) || action.equals(""String_Node_Str"")) {
    java.createArg().setLine(""String_Node_Str"" + getTask().getSource());
  }
 else   if (action.equals(ACTION_DELETE) || action.equals(ACTION_UNDEPLOY)) {
    java.createArg().setLine(""String_Node_Str"" + getTask().getSource());
  }
 else   if (action.equals(ACTION_LIST)) {
    java.createArg().setValue(""String_Node_Str"");
  }
}",0.9903324687573686
64258,"public static String getClassName(InputStream input) throws IOException {
  DataInputStream data=new DataInputStream(input);
  int cookie=data.readInt();
  if (cookie != 0xCAFEBABE) {
    return null;
  }
  int version=data.readInt();
  ConstantPool constants=new ConstantPool(data);
  Object[] values=constants.values;
  int accessFlags=data.readUnsignedShort();
  int classIndex=data.readUnsignedShort();
  Integer stringIndex=(Integer)values[classIndex];
  String className=(String)values[stringIndex.intValue()];
  return className;
}","public static String getClassName(InputStream input) throws IOException {
  DataInputStream data=new DataInputStream(input);
  int cookie=data.readInt();
  if (cookie != 0xCAFEBABE) {
    return null;
  }
  data.readInt();
  ConstantPool constants=new ConstantPool(data);
  Object[] values=constants.values;
  data.readUnsignedShort();
  int classIndex=data.readUnsignedShort();
  Integer stringIndex=(Integer)values[classIndex];
  String className=(String)values[stringIndex.intValue()];
  return className;
}",0.9732824427480916
64259,"private long calcChecksum(InputStream in,long size) throws IOException {
  CRC32 crc=new CRC32();
  int len=buffer.length;
  int count=-1;
  int haveRead=0;
  while ((count=in.read(buffer,0,len)) > 0) {
    haveRead+=count;
    crc.update(buffer,0,count);
  }
  in.close();
  return crc.getValue();
}","private long calcChecksum(InputStream in) throws IOException {
  CRC32 crc=new CRC32();
  int len=buffer.length;
  int count=-1;
  int haveRead=0;
  while ((count=in.read(buffer,0,len)) > 0) {
    haveRead+=count;
    crc.update(buffer,0,count);
  }
  in.close();
  return crc.getValue();
}",0.9830508474576272
64260,"private void addFile(ZipOutputStream output,File file,String prefix,boolean compress) throws IOException {
  long checksum=0;
  if (!file.exists()) {
    return;
  }
  ZipEntry entry=new ZipEntry(getEntryName(file,prefix));
  entry.setTime(file.lastModified());
  entry.setSize(file.length());
  if (!compress) {
    entry.setCrc(calcChecksum(file));
  }
  FileInputStream input=new FileInputStream(file);
  addToOutputStream(output,input,entry);
}","private void addFile(ZipOutputStream output,File file,String prefix,boolean compress) throws IOException {
  if (!file.exists()) {
    return;
  }
  ZipEntry entry=new ZipEntry(getEntryName(file,prefix));
  entry.setTime(file.lastModified());
  entry.setSize(file.length());
  if (!compress) {
    entry.setCrc(calcChecksum(file));
  }
  FileInputStream input=new FileInputStream(file);
  addToOutputStream(output,input,entry);
}",0.9783352337514252
64261,"public void execute() throws BuildException {
  if (!destinationDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + destinationDirectory.getPath() + ""String_Node_Str"");
  }
  if (!sourceDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + sourceDirectory.getPath() + ""String_Node_Str"");
  }
  if (destinationPackage == null) {
    throw new BuildException(""String_Node_Str"",getLocation());
  }
  pathToPackage=this.destinationPackage.replace('.',File.separatorChar);
  DirectoryScanner ds=super.getDirectoryScanner(sourceDirectory);
  if (compileClasspath == null) {
    compileClasspath=new Path(getProject());
  }
  compileClasspath.append(Path.systemClasspath);
  String[] files=ds.getIncludedFiles();
  Java helperTask=(Java)getProject().createTask(""String_Node_Str"");
  helperTask.setFork(true);
  helperTask.setClassname(""String_Node_Str"");
  helperTask.setTaskName(getTaskName());
  String[] args=new String[12];
  File jspFile=null;
  String parents=""String_Node_Str"";
  String arg=""String_Node_Str"";
  int j=0;
  args[j++]=""String_Node_Str"";
  args[j++]=destinationDirectory.getAbsolutePath().trim();
  args[j++]=""String_Node_Str"";
  args[j++]=sourceDirectory.getAbsolutePath().trim();
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=compileClasspath.toString();
  this.scanDir(files);
  log(""String_Node_Str"" + filesToDo.size() + ""String_Node_Str"");
  for (int i=0; i < filesToDo.size(); i++) {
    String filename=(String)filesToDo.elementAt(i);
    jspFile=new File(filename);
    args[j]=""String_Node_Str"";
    parents=jspFile.getParent();
    if ((parents != null) && (!(""String_Node_Str"").equals(parents))) {
      parents=this.replaceString(parents,File.separator,""String_Node_Str"");
      args[j + 1]=destinationPackage + ""String_Node_Str"" + ""String_Node_Str""+ parents;
    }
 else {
      args[j + 1]=destinationPackage;
    }
    args[j + 2]=sourceDirectory + File.separator + filename;
    helperTask.clearArgs();
    for (int x=0; x < j + 3; x++) {
      helperTask.createArg().setValue(args[x]);
    }
    helperTask.setClasspath(compileClasspath);
    if (helperTask.executeJava() != 0) {
      log(filename + ""String_Node_Str"",Project.MSG_WARN);
    }
  }
}","public void execute() throws BuildException {
  if (!destinationDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + destinationDirectory.getPath() + ""String_Node_Str"");
  }
  if (!sourceDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + sourceDirectory.getPath() + ""String_Node_Str"");
  }
  if (destinationPackage == null) {
    throw new BuildException(""String_Node_Str"",getLocation());
  }
  pathToPackage=this.destinationPackage.replace('.',File.separatorChar);
  DirectoryScanner ds=super.getDirectoryScanner(sourceDirectory);
  if (compileClasspath == null) {
    compileClasspath=new Path(getProject());
  }
  compileClasspath.append(Path.systemClasspath);
  String[] files=ds.getIncludedFiles();
  Java helperTask=(Java)getProject().createTask(""String_Node_Str"");
  helperTask.setFork(true);
  helperTask.setClassname(""String_Node_Str"");
  helperTask.setTaskName(getTaskName());
  String[] args=new String[12];
  File jspFile=null;
  String parents=""String_Node_Str"";
  int j=0;
  args[j++]=""String_Node_Str"";
  args[j++]=destinationDirectory.getAbsolutePath().trim();
  args[j++]=""String_Node_Str"";
  args[j++]=sourceDirectory.getAbsolutePath().trim();
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=compileClasspath.toString();
  this.scanDir(files);
  log(""String_Node_Str"" + filesToDo.size() + ""String_Node_Str"");
  for (int i=0; i < filesToDo.size(); i++) {
    String filename=(String)filesToDo.elementAt(i);
    jspFile=new File(filename);
    args[j]=""String_Node_Str"";
    parents=jspFile.getParent();
    if ((parents != null) && (!(""String_Node_Str"").equals(parents))) {
      parents=this.replaceString(parents,File.separator,""String_Node_Str"");
      args[j + 1]=destinationPackage + ""String_Node_Str"" + ""String_Node_Str""+ parents;
    }
 else {
      args[j + 1]=destinationPackage;
    }
    args[j + 2]=sourceDirectory + File.separator + filename;
    helperTask.clearArgs();
    for (int x=0; x < j + 3; x++) {
      helperTask.createArg().setValue(args[x]);
    }
    helperTask.setClasspath(compileClasspath);
    if (helperTask.executeJava() != 0) {
      log(filename + ""String_Node_Str"",Project.MSG_WARN);
    }
  }
}",0.9930434782608696
64262,"/** 
 * @exception org.apache.tools.ant.BuildException Something is stopping the build...
 */
public void execute() throws org.apache.tools.ant.BuildException {
  Project aProj=getProject();
  int result=0;
  if (repository == null || repository.trim().equals(""String_Node_Str"")) {
    throw new BuildException(""String_Node_Str"");
  }
  Commandline commandLine=new Commandline();
  commandLine.setExecutable(getExecutable(PCLI_EXE));
  commandLine.createArgument().setValue(""String_Node_Str"");
  commandLine.createArgument().setValue(""String_Node_Str"");
  commandLine.createArgument().setValue(""String_Node_Str"");
  if (getWorkspace() != null) {
    commandLine.createArgument().setValue(""String_Node_Str"" + getWorkspace());
  }
  commandLine.createArgument().setValue(""String_Node_Str"" + getRepository());
  String uid=getUserId();
  if (uid != null) {
    commandLine.createArgument().setValue(""String_Node_Str"" + uid);
  }
  if (getPvcsproject() == null && getPvcsprojects().isEmpty()) {
    pvcsProject=""String_Node_Str"";
  }
  if (getPvcsproject() != null) {
    commandLine.createArgument().setValue(getPvcsproject());
  }
  if (!getPvcsprojects().isEmpty()) {
    Enumeration e=getPvcsprojects().elements();
    while (e.hasMoreElements()) {
      String projectName=((PvcsProject)e.nextElement()).getName();
      if (projectName == null || (projectName.trim()).equals(""String_Node_Str"")) {
        throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
      }
      commandLine.createArgument().setValue(projectName);
    }
  }
  File tmp=null;
  File tmp2=null;
  try {
    Random rand=new Random(System.currentTimeMillis());
    tmp=new File(""String_Node_Str"" + rand.nextLong() + ""String_Node_Str"");
    FileOutputStream fos=new FileOutputStream(tmp);
    tmp2=new File(""String_Node_Str"" + rand.nextLong() + ""String_Node_Str"");
    log(commandLine.describeCommand(),Project.MSG_VERBOSE);
    try {
      result=runCmd(commandLine,new PumpStreamHandler(fos,new LogOutputStream(this,Project.MSG_WARN)));
    }
  finally {
      fos.close();
    }
    if (result != 0 && !ignorerc) {
      String msg=""String_Node_Str"" + commandLine.toString();
      throw new BuildException(msg,getLocation());
    }
    if (!tmp.exists()) {
      throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    log(""String_Node_Str"",Project.MSG_INFO);
    createFolders(tmp);
    massagePCLI(tmp,tmp2);
    commandLine.clearArgs();
    commandLine.setExecutable(getExecutable(GET_EXE));
    if (getForce() != null && getForce().equals(""String_Node_Str"")) {
      commandLine.createArgument().setValue(""String_Node_Str"");
    }
 else {
      commandLine.createArgument().setValue(""String_Node_Str"");
    }
    if (getPromotiongroup() != null) {
      commandLine.createArgument().setValue(""String_Node_Str"" + getPromotiongroup());
    }
 else {
      if (getLabel() != null) {
        commandLine.createArgument().setValue(""String_Node_Str"" + getLabel());
      }
    }
    if (updateOnly) {
      commandLine.createArgument().setValue(""String_Node_Str"");
    }
    commandLine.createArgument().setValue(""String_Node_Str"" + tmp2.getAbsolutePath());
    log(""String_Node_Str"",Project.MSG_INFO);
    log(""String_Node_Str"" + commandLine.toString(),Project.MSG_VERBOSE);
    result=runCmd(commandLine,new LogStreamHandler(this,Project.MSG_INFO,Project.MSG_WARN));
    if (result != 0 && !ignorerc) {
      String msg=""String_Node_Str"" + commandLine.toString() + ""String_Node_Str""+ result;
      throw new BuildException(msg,getLocation());
    }
  }
 catch (  FileNotFoundException e) {
    String msg=""String_Node_Str"" + commandLine.toString() + ""String_Node_Str""+ e.getMessage();
    throw new BuildException(msg,getLocation());
  }
catch (  IOException e) {
    String msg=""String_Node_Str"" + commandLine.toString() + ""String_Node_Str""+ e.getMessage();
    throw new BuildException(msg,getLocation());
  }
catch (  ParseException e) {
    String msg=""String_Node_Str"" + commandLine.toString() + ""String_Node_Str""+ e.getMessage();
    throw new BuildException(msg,getLocation());
  }
 finally {
    if (tmp != null) {
      tmp.delete();
    }
    if (tmp2 != null) {
      tmp2.delete();
    }
  }
}","/** 
 * @exception org.apache.tools.ant.BuildException Something is stopping the build...
 */
public void execute() throws org.apache.tools.ant.BuildException {
  int result=0;
  if (repository == null || repository.trim().equals(""String_Node_Str"")) {
    throw new BuildException(""String_Node_Str"");
  }
  Commandline commandLine=new Commandline();
  commandLine.setExecutable(getExecutable(PCLI_EXE));
  commandLine.createArgument().setValue(""String_Node_Str"");
  commandLine.createArgument().setValue(""String_Node_Str"");
  commandLine.createArgument().setValue(""String_Node_Str"");
  if (getWorkspace() != null) {
    commandLine.createArgument().setValue(""String_Node_Str"" + getWorkspace());
  }
  commandLine.createArgument().setValue(""String_Node_Str"" + getRepository());
  String uid=getUserId();
  if (uid != null) {
    commandLine.createArgument().setValue(""String_Node_Str"" + uid);
  }
  if (getPvcsproject() == null && getPvcsprojects().isEmpty()) {
    pvcsProject=""String_Node_Str"";
  }
  if (getPvcsproject() != null) {
    commandLine.createArgument().setValue(getPvcsproject());
  }
  if (!getPvcsprojects().isEmpty()) {
    Enumeration e=getPvcsprojects().elements();
    while (e.hasMoreElements()) {
      String projectName=((PvcsProject)e.nextElement()).getName();
      if (projectName == null || (projectName.trim()).equals(""String_Node_Str"")) {
        throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
      }
      commandLine.createArgument().setValue(projectName);
    }
  }
  File tmp=null;
  File tmp2=null;
  try {
    Random rand=new Random(System.currentTimeMillis());
    tmp=new File(""String_Node_Str"" + rand.nextLong() + ""String_Node_Str"");
    FileOutputStream fos=new FileOutputStream(tmp);
    tmp2=new File(""String_Node_Str"" + rand.nextLong() + ""String_Node_Str"");
    log(commandLine.describeCommand(),Project.MSG_VERBOSE);
    try {
      result=runCmd(commandLine,new PumpStreamHandler(fos,new LogOutputStream(this,Project.MSG_WARN)));
    }
  finally {
      fos.close();
    }
    if (result != 0 && !ignorerc) {
      String msg=""String_Node_Str"" + commandLine.toString();
      throw new BuildException(msg,getLocation());
    }
    if (!tmp.exists()) {
      throw new BuildException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    log(""String_Node_Str"",Project.MSG_INFO);
    createFolders(tmp);
    massagePCLI(tmp,tmp2);
    commandLine.clearArgs();
    commandLine.setExecutable(getExecutable(GET_EXE));
    if (getForce() != null && getForce().equals(""String_Node_Str"")) {
      commandLine.createArgument().setValue(""String_Node_Str"");
    }
 else {
      commandLine.createArgument().setValue(""String_Node_Str"");
    }
    if (getPromotiongroup() != null) {
      commandLine.createArgument().setValue(""String_Node_Str"" + getPromotiongroup());
    }
 else {
      if (getLabel() != null) {
        commandLine.createArgument().setValue(""String_Node_Str"" + getLabel());
      }
    }
    if (updateOnly) {
      commandLine.createArgument().setValue(""String_Node_Str"");
    }
    commandLine.createArgument().setValue(""String_Node_Str"" + tmp2.getAbsolutePath());
    log(""String_Node_Str"",Project.MSG_INFO);
    log(""String_Node_Str"" + commandLine.toString(),Project.MSG_VERBOSE);
    result=runCmd(commandLine,new LogStreamHandler(this,Project.MSG_INFO,Project.MSG_WARN));
    if (result != 0 && !ignorerc) {
      String msg=""String_Node_Str"" + commandLine.toString() + ""String_Node_Str""+ result;
      throw new BuildException(msg,getLocation());
    }
  }
 catch (  FileNotFoundException e) {
    String msg=""String_Node_Str"" + commandLine.toString() + ""String_Node_Str""+ e.getMessage();
    throw new BuildException(msg,getLocation());
  }
catch (  IOException e) {
    String msg=""String_Node_Str"" + commandLine.toString() + ""String_Node_Str""+ e.getMessage();
    throw new BuildException(msg,getLocation());
  }
catch (  ParseException e) {
    String msg=""String_Node_Str"" + commandLine.toString() + ""String_Node_Str""+ e.getMessage();
    throw new BuildException(msg,getLocation());
  }
 finally {
    if (tmp != null) {
      tmp.delete();
    }
    if (tmp2 != null) {
      tmp2.delete();
    }
  }
}",0.996443812233286
64263,"public ClassFile(InputStream is) throws IOException {
  DataInputStream dis=new DataInputStream(is);
  ConstantPool constantPool=new ConstantPool();
  int magic=dis.readInt();
  int minor=dis.readShort();
  int major=dis.readShort();
  constantPool.read(dis);
  constantPool.resolve();
  access_flags=dis.readShort();
  int this_class=dis.readShort();
  fullname=((ClassCPInfo)constantPool.getEntry(this_class)).getClassName().replace('/','.');
  int super_class=dis.readShort();
  int count=dis.readShort();
  dis.skipBytes(count * 2);
  int numFields=dis.readShort();
  for (int i=0; i < numFields; i++) {
    dis.skip(2 * 3);
    int attributes_count=dis.readUnsignedShort();
    for (int j=0; j < attributes_count; j++) {
      dis.skipBytes(2);
      int len=dis.readInt();
      dis.skipBytes(len);
    }
  }
  int method_count=dis.readShort();
  methods=new MethodInfo[method_count];
  for (int i=0; i < method_count; i++) {
    methods[i]=new MethodInfo();
    methods[i].read(constantPool,dis);
  }
  int attributes_count=dis.readUnsignedShort();
  for (int j=0; j < attributes_count; j++) {
    int attr_id=dis.readShort();
    int len=dis.readInt();
    String attr_name=Utils.getUTF8Value(constantPool,attr_id);
    if (AttributeInfo.SOURCE_FILE.equals(attr_name)) {
      int name_index=dis.readShort();
      sourceFile=((Utf8CPInfo)constantPool.getEntry(name_index)).getValue();
    }
 else {
      dis.skipBytes(len);
    }
  }
}","public ClassFile(InputStream is) throws IOException {
  DataInputStream dis=new DataInputStream(is);
  ConstantPool constantPool=new ConstantPool();
  dis.readInt();
  dis.readShort();
  dis.readShort();
  constantPool.read(dis);
  constantPool.resolve();
  access_flags=dis.readShort();
  int this_class=dis.readShort();
  fullname=((ClassCPInfo)constantPool.getEntry(this_class)).getClassName().replace('/','.');
  dis.readShort();
  int count=dis.readShort();
  dis.skipBytes(count * 2);
  int numFields=dis.readShort();
  for (int i=0; i < numFields; i++) {
    dis.skip(2 * 3);
    int attributes_count=dis.readUnsignedShort();
    for (int j=0; j < attributes_count; j++) {
      dis.skipBytes(2);
      int len=dis.readInt();
      dis.skipBytes(len);
    }
  }
  int method_count=dis.readShort();
  methods=new MethodInfo[method_count];
  for (int i=0; i < method_count; i++) {
    methods[i]=new MethodInfo();
    methods[i].read(constantPool,dis);
  }
  int attributes_count=dis.readUnsignedShort();
  for (int j=0; j < attributes_count; j++) {
    int attr_id=dis.readShort();
    int len=dis.readInt();
    String attr_name=Utils.getUTF8Value(constantPool,attr_id);
    if (AttributeInfo.SOURCE_FILE.equals(attr_name)) {
      int name_index=dis.readShort();
      sourceFile=((Utf8CPInfo)constantPool.getEntry(name_index)).getValue();
    }
 else {
      dis.skipBytes(len);
    }
  }
}",0.9704641350210972
64264,"public PlanarImage executeTransformOperation(PlanarImage image){
  BufferedImage bi=image.getAsBufferedImage();
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  for (int i=0; i < instructions.size(); i++) {
    ImageOperation instr=((ImageOperation)instructions.elementAt(i));
    if (instr instanceof DrawOperation) {
      PlanarImage op=((DrawOperation)instr).executeDrawOperation();
      log(""String_Node_Str"" + xloc + ""String_Node_Str""+ yloc);
      graphics.drawImage(op.getAsBufferedImage(),null,xloc,yloc);
    }
 else     if (instr instanceof TransformOperation) {
      PlanarImage op=((TransformOperation)instr).executeTransformOperation(null);
      BufferedImage child=op.getAsBufferedImage();
      log(""String_Node_Str"" + xloc + ""String_Node_Str""+ yloc);
      graphics.drawImage(child,null,xloc,yloc);
      PlanarImage test=PlanarImage.wrapRenderedImage(bi);
    }
  }
  image=PlanarImage.wrapRenderedImage(bi);
  return image;
}","public PlanarImage executeTransformOperation(PlanarImage image){
  BufferedImage bi=image.getAsBufferedImage();
  Graphics2D graphics=(Graphics2D)bi.getGraphics();
  for (int i=0; i < instructions.size(); i++) {
    ImageOperation instr=((ImageOperation)instructions.elementAt(i));
    if (instr instanceof DrawOperation) {
      PlanarImage op=((DrawOperation)instr).executeDrawOperation();
      log(""String_Node_Str"" + xloc + ""String_Node_Str""+ yloc);
      graphics.drawImage(op.getAsBufferedImage(),null,xloc,yloc);
    }
 else     if (instr instanceof TransformOperation) {
      PlanarImage op=((TransformOperation)instr).executeTransformOperation(null);
      BufferedImage child=op.getAsBufferedImage();
      log(""String_Node_Str"" + xloc + ""String_Node_Str""+ yloc);
      graphics.drawImage(child,null,xloc,yloc);
      PlanarImage.wrapRenderedImage(bi);
    }
  }
  image=PlanarImage.wrapRenderedImage(bi);
  return image;
}",0.9326974032856384
64265,"/** 
 * Convienence method to copy a file from a source to a destination specifying if token filtering must be used, if filter chains must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>.
 * @throws IOException
 * @since 1.15, Ant 1.5
 */
public void copyFile(File sourceFile,File destFile,FilterSetCollection filters,Vector filterChains,boolean overwrite,boolean preserveLastModified,String encoding,Project project) throws IOException {
  if (overwrite || !destFile.exists() || destFile.lastModified() < sourceFile.lastModified()) {
    if (destFile.exists() && destFile.isFile()) {
      destFile.delete();
    }
    File parent=getParentFile(destFile);
    if (!parent.exists()) {
      parent.mkdirs();
    }
    final boolean filterSetsAvailable=(filters != null && filters.hasFilters());
    final boolean filterChainsAvailable=(filterChains != null && filterChains.size() > 0);
    if (filterSetsAvailable || filterChainsAvailable) {
      BufferedReader in=null;
      BufferedWriter out=null;
      try {
        if (encoding == null) {
          in=new BufferedReader(new FileReader(sourceFile));
          out=new BufferedWriter(new FileWriter(destFile));
        }
 else {
          in=new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile),encoding));
          out=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(destFile),encoding));
        }
        if (filterChainsAvailable) {
          ChainReaderHelper crh=new ChainReaderHelper();
          crh.setBufferSize(8192);
          crh.setPrimaryReader(in);
          crh.setFilterChains(filterChains);
          crh.setProject(project);
          Reader rdr=crh.getAssembledReader();
          in=new BufferedReader(rdr);
        }
        int length;
        String newline=null;
        String line=in.readLine();
        while (line != null) {
          if (line.length() == 0) {
            out.newLine();
          }
 else {
            if (filterSetsAvailable) {
              newline=filters.replaceTokens(line);
            }
 else {
              newline=line;
            }
            out.write(newline);
            out.newLine();
          }
          line=in.readLine();
        }
      }
  finally {
        if (out != null) {
          out.close();
        }
        if (in != null) {
          in.close();
        }
      }
    }
 else {
      FileInputStream in=null;
      FileOutputStream out=null;
      try {
        in=new FileInputStream(sourceFile);
        out=new FileOutputStream(destFile);
        byte[] buffer=new byte[8 * 1024];
        int count=0;
        do {
          out.write(buffer,0,count);
          count=in.read(buffer,0,buffer.length);
        }
 while (count != -1);
      }
  finally {
        if (out != null) {
          out.close();
        }
        if (in != null) {
          in.close();
        }
      }
    }
    if (preserveLastModified) {
      setFileLastModified(destFile,sourceFile.lastModified());
    }
  }
}","/** 
 * Convienence method to copy a file from a source to a destination specifying if token filtering must be used, if filter chains must be used, if source files may overwrite newer destination files and the last modified time of <code>destFile</code> file should be made equal to the last modified time of <code>sourceFile</code>.
 * @throws IOException
 * @since 1.15, Ant 1.5
 */
public void copyFile(File sourceFile,File destFile,FilterSetCollection filters,Vector filterChains,boolean overwrite,boolean preserveLastModified,String encoding,Project project) throws IOException {
  if (overwrite || !destFile.exists() || destFile.lastModified() < sourceFile.lastModified()) {
    if (destFile.exists() && destFile.isFile()) {
      destFile.delete();
    }
    File parent=getParentFile(destFile);
    if (!parent.exists()) {
      parent.mkdirs();
    }
    final boolean filterSetsAvailable=(filters != null && filters.hasFilters());
    final boolean filterChainsAvailable=(filterChains != null && filterChains.size() > 0);
    if (filterSetsAvailable || filterChainsAvailable) {
      BufferedReader in=null;
      BufferedWriter out=null;
      try {
        if (encoding == null) {
          in=new BufferedReader(new FileReader(sourceFile));
          out=new BufferedWriter(new FileWriter(destFile));
        }
 else {
          in=new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile),encoding));
          out=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(destFile),encoding));
        }
        if (filterChainsAvailable) {
          ChainReaderHelper crh=new ChainReaderHelper();
          crh.setBufferSize(8192);
          crh.setPrimaryReader(in);
          crh.setFilterChains(filterChains);
          crh.setProject(project);
          Reader rdr=crh.getAssembledReader();
          in=new BufferedReader(rdr);
        }
        String newline=null;
        String line=in.readLine();
        while (line != null) {
          if (line.length() == 0) {
            out.newLine();
          }
 else {
            if (filterSetsAvailable) {
              newline=filters.replaceTokens(line);
            }
 else {
              newline=line;
            }
            out.write(newline);
            out.newLine();
          }
          line=in.readLine();
        }
      }
  finally {
        if (out != null) {
          out.close();
        }
        if (in != null) {
          in.close();
        }
      }
    }
 else {
      FileInputStream in=null;
      FileOutputStream out=null;
      try {
        in=new FileInputStream(sourceFile);
        out=new FileOutputStream(destFile);
        byte[] buffer=new byte[8 * 1024];
        int count=0;
        do {
          out.write(buffer,0,count);
          count=in.read(buffer,0,buffer.length);
        }
 while (count != -1);
      }
  finally {
        if (out != null) {
          out.close();
        }
        if (in != null) {
          in.close();
        }
      }
    }
    if (preserveLastModified) {
      setFileLastModified(destFile,sourceFile.lastModified());
    }
  }
}",0.9967824967824968
64266,"public AncestorAnalyzer(){
  try {
    ClassParser parser=new ClassParser(""String_Node_Str"");
  }
 catch (  IOException e) {
  }
}","public AncestorAnalyzer(){
  try {
    new ClassParser(""String_Node_Str"");
  }
 catch (  IOException e) {
  }
}",0.921161825726141
64267,"public FullAnalyzer(){
  try {
    ClassParser parser=new ClassParser(""String_Node_Str"");
  }
 catch (  IOException e) {
  }
}","public FullAnalyzer(){
  try {
    new ClassParser(""String_Node_Str"");
  }
 catch (  IOException e) {
  }
}",0.9184549356223176
64268,"/** 
 * Parse an octal integer from a header buffer.
 * @param header The header buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The number of header bytes to parse.
 * @return The integer value of the octal bytes.
 */
public static int getOctalBytes(long value,byte[] buf,int offset,int length){
  byte[] result=new byte[length];
  int idx=length - 1;
  buf[offset + idx]=0;
  --idx;
  buf[offset + idx]=(byte)' ';
  --idx;
  if (value == 0) {
    buf[offset + idx]=(byte)'0';
    --idx;
  }
 else {
    for (long val=value; idx >= 0 && val > 0; --idx) {
      buf[offset + idx]=(byte)((byte)'0' + (byte)(val & 7));
      val=val >> 3;
    }
  }
  for (; idx >= 0; --idx) {
    buf[offset + idx]=(byte)' ';
  }
  return offset + length;
}","/** 
 * Parse an octal integer from a header buffer.
 * @param header The header buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The number of header bytes to parse.
 * @return The integer value of the octal bytes.
 */
public static int getOctalBytes(long value,byte[] buf,int offset,int length){
  int idx=length - 1;
  buf[offset + idx]=0;
  --idx;
  buf[offset + idx]=(byte)' ';
  --idx;
  if (value == 0) {
    buf[offset + idx]=(byte)'0';
    --idx;
  }
 else {
    for (long val=value; idx >= 0 && val > 0; --idx) {
      buf[offset + idx]=(byte)((byte)'0' + (byte)(val & 7));
      val=val >> 3;
    }
  }
  for (; idx >= 0; --idx) {
    buf[offset + idx]=(byte)' ';
  }
  return offset + length;
}",0.9783163265306124
64269,"protected void nextLine() throws BuildException {
  int ch=-1;
  int eolcount=0;
  eolStr.setLength(0);
  line.setLength(0);
  try {
    ch=reader.read();
    while (ch != -1 && ch != '\r' && ch != '\n') {
      line.append((char)ch);
      ch=reader.read();
    }
    if (ch == -1 && line.length() == 0) {
      reachedEof=true;
      return;
    }
switch ((char)ch) {
case '\r':
      ++eolcount;
    eolStr.append('\r');
  reader.mark(2);
switch ((ch=reader.read())) {
case '\r':
  if ((char)(ch=reader.read()) == '\n') {
    eolcount+=2;
    eolStr.append(""String_Node_Str"");
  }
 else {
    reader.reset();
  }
break;
case '\n':
++eolcount;
eolStr.append('\n');
break;
case -1:
break;
default :
reader.reset();
break;
}
break;
case '\n':
++eolcount;
eolStr.append('\n');
break;
}
if (eolcount == 0) {
int i=line.length();
while (--i >= 0 && line.charAt(i) == CTRLZ) {
}
if (i < line.length() - 1) {
eofStr.append(line.toString().substring(i + 1));
if (i < 0) {
line.setLength(0);
reachedEof=true;
}
 else {
line.setLength(i + 1);
}
}
}
}
 catch (IOException e) {
throw new BuildException(e);
}
}","protected void nextLine() throws BuildException {
  int ch=-1;
  int eolcount=0;
  eolStr.setLength(0);
  line.setLength(0);
  try {
    ch=reader.read();
    while (ch != -1 && ch != '\r' && ch != '\n') {
      line.append((char)ch);
      ch=reader.read();
    }
    if (ch == -1 && line.length() == 0) {
      reachedEof=true;
      return;
    }
switch ((char)ch) {
case '\r':
      ++eolcount;
    eolStr.append('\r');
  reader.mark(2);
switch ((ch=reader.read())) {
case '\r':
  if ((char)(ch=reader.read()) == '\n') {
    eolcount+=2;
    eolStr.append(""String_Node_Str"");
  }
 else {
    reader.reset();
  }
break;
case '\n':
++eolcount;
eolStr.append('\n');
break;
case -1:
break;
default :
reader.reset();
break;
}
break;
case '\n':
++eolcount;
eolStr.append('\n');
break;
}
if (eolcount == 0) {
int i=line.length();
while (--i >= 0 && line.charAt(i) == CTRLZ) {
}
if (i < line.length() - 1) {
eofStr.append(line.toString().substring(i + 1));
if (i < 0) {
line.setLength(0);
reachedEof=true;
}
 else {
line.setLength(i + 1);
}
}
}
}
 catch (IOException e) {
throw new BuildException(srcFile + ""String_Node_Str"" + e.getMessage(),e,getLocation());
}
}",0.967684816290394
64270,"public OneLiner(File srcFile) throws BuildException {
  try {
    reader=new BufferedReader(getReader(srcFile),INBUFLEN);
    nextLine();
  }
 catch (  IOException e) {
    throw new BuildException(e);
  }
}","public OneLiner(File srcFile) throws BuildException {
  this.srcFile=srcFile;
  try {
    reader=new BufferedReader(getReader(srcFile),INBUFLEN);
    nextLine();
  }
 catch (  IOException e) {
    throw new BuildException(srcFile + ""String_Node_Str"" + e.getMessage(),e,getLocation());
  }
}",0.8289738430583501
64271,"/** 
 * Writes a formatted list of target names to <code>System.out</code> with an optional description.
 * @param names The names to be printed.Must not be <code>null</code>.
 * @param descriptions The associated target descriptions.May be <code>null</code>, in which case no descriptions are displayed. If non-<code>null</code>, this should have as many elements as <code>names</code>.
 * @param heading The heading to display.Should not be <code>null</code>.
 * @param maxlen The maximum length of the names of the targets.If descriptions are given, they are padded to this position so they line up (so long as the names really <i>are</i> shorter than this).
 */
private static void printTargets(Project project,Vector names,Vector descriptions,String heading,int maxlen){
  String lSep=System.getProperty(""String_Node_Str"");
  String spaces=""String_Node_Str"";
  while (spaces.length() < maxlen) {
    spaces+=spaces;
  }
  StringBuffer msg=new StringBuffer();
  msg.append(heading + lSep + lSep);
  for (int i=0; i < names.size(); i++) {
    msg.append(""String_Node_Str"");
    msg.append(names.elementAt(i));
    if (descriptions != null) {
      msg.append(spaces.substring(0,maxlen - ((String)names.elementAt(i)).length() + 2));
      msg.append(descriptions.elementAt(i));
    }
    msg.append(lSep);
  }
  project.log(msg.toString());
}","/** 
 * Writes a formatted list of target names to <code>System.out</code> with an optional description.
 * @param names The names to be printed.Must not be <code>null</code>.
 * @param descriptions The associated target descriptions.May be <code>null</code>, in which case no descriptions are displayed. If non-<code>null</code>, this should have as many elements as <code>names</code>.
 * @param heading The heading to display.Should not be <code>null</code>.
 * @param maxlen The maximum length of the names of the targets.If descriptions are given, they are padded to this position so they line up (so long as the names really <i>are</i> shorter than this).
 */
private static void printTargets(Project project,Vector names,Vector descriptions,String heading,int maxlen){
  String lSep=System.getProperty(""String_Node_Str"");
  String spaces=""String_Node_Str"";
  while (spaces.length() <= maxlen) {
    spaces+=spaces;
  }
  StringBuffer msg=new StringBuffer();
  msg.append(heading + lSep + lSep);
  for (int i=0; i < names.size(); i++) {
    msg.append(""String_Node_Str"");
    msg.append(names.elementAt(i));
    if (descriptions != null) {
      msg.append(spaces.substring(0,maxlen - ((String)names.elementAt(i)).length() + 2));
      msg.append(descriptions.elementAt(i));
    }
    msg.append(lSep);
  }
  project.log(msg.toString());
}",0.9996281145407214
64272,"/** 
 * our execute method
 */
public boolean execute() throws BuildException {
  getJspc().log(""String_Node_Str"",Project.MSG_VERBOSE);
  CommandlineJava cmd=setupJasperCommand();
  try {
    Java java=(Java)(getProject().createTask(""String_Node_Str""));
    if (getJspc().getClasspath() != null) {
      java.setClasspath(getJspc().getClasspath());
    }
 else {
      Path classpath=new Path(getProject());
      classpath.concatSystemClasspath();
      java.setClasspath(classpath);
    }
    java.setDir(getProject().getBaseDir());
    java.setClassname(""String_Node_Str"");
    String args[]=cmd.getJavaCommand().getArguments();
    for (int i=0; i < args.length; i++) {
      java.createArg().setValue(args[i]);
    }
    java.setFailonerror(getJspc().getFailonerror());
    java.setFork(true);
    java.execute();
    return true;
  }
 catch (  Exception ex) {
    if (ex instanceof BuildException) {
      throw (BuildException)ex;
    }
 else {
      throw new BuildException(""String_Node_Str"",ex,getJspc().getLocation());
    }
  }
 finally {
    getJspc().deleteEmptyJavaFiles();
  }
}","/** 
 * our execute method
 */
public boolean execute() throws BuildException {
  getJspc().log(""String_Node_Str"",Project.MSG_VERBOSE);
  CommandlineJava cmd=setupJasperCommand();
  try {
    Java java=(Java)(getProject().createTask(""String_Node_Str""));
    if (getJspc().getClasspath() != null) {
      getProject().log(""String_Node_Str"" + getJspc().getClasspath(),Project.MSG_DEBUG);
      java.setClasspath(getJspc().getClasspath());
    }
 else {
      Path classpath=new Path(getProject());
      classpath=classpath.concatSystemClasspath(""String_Node_Str"");
      getProject().log(""String_Node_Str"" + classpath,Project.MSG_DEBUG);
      java.setClasspath(classpath);
    }
    java.setDir(getProject().getBaseDir());
    java.setClassname(""String_Node_Str"");
    String args[]=cmd.getJavaCommand().getArguments();
    for (int i=0; i < args.length; i++) {
      java.createArg().setValue(args[i]);
    }
    java.setFailonerror(getJspc().getFailonerror());
    java.setFork(true);
    java.setTaskName(""String_Node_Str"");
    java.execute();
    return true;
  }
 catch (  Exception ex) {
    if (ex instanceof BuildException) {
      throw (BuildException)ex;
    }
 else {
      throw new BuildException(""String_Node_Str"",ex,getJspc().getLocation());
    }
  }
 finally {
    getJspc().deleteEmptyJavaFiles();
  }
}",0.9002896152254861
64273,"/** 
 * Removes a leading path from a second path.
 * @param leading The leading path, must not be null, must be absolute.
 * @param path The path to remove from, must not be null, must be absolute.
 * @return path's normalized absolute if it doesn't start withleading, path's path with leading's path removed otherwise.
 * @since Ant 1.5
 */
public String removeLeadingPath(File leading,File path){
  String l=normalize(leading.getAbsolutePath()).getAbsolutePath();
  String p=normalize(path.getAbsolutePath()).getAbsolutePath();
  if (p.startsWith(l)) {
    String result=p.substring(l.length());
    if (result.startsWith(File.separator)) {
      result=result.substring(File.separator.length());
    }
    return result;
  }
 else {
    return p;
  }
}","/** 
 * Removes a leading path from a second path.
 * @param leading The leading path, must not be null, must be absolute.
 * @param path The path to remove from, must not be null, must be absolute.
 * @return path's normalized absolute if it doesn't start withleading, path's path with leading's path removed otherwise.
 * @since Ant 1.5
 */
public String removeLeadingPath(File leading,File path){
  String l=normalize(leading.getAbsolutePath()).getAbsolutePath() + File.separator;
  String p=normalize(path.getAbsolutePath()).getAbsolutePath();
  if (p.startsWith(l)) {
    return p.substring(l.length());
  }
 else {
    return p;
  }
}",0.8610315186246418
64274,"/** 
 * Test removeLeadingPath.
 */
public void testRemoveLeadingPath(){
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(fu.normalize(""String_Node_Str"").getAbsolutePath(),fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
}","/** 
 * Test removeLeadingPath.
 */
public void testRemoveLeadingPath(){
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(fu.normalize(""String_Node_Str"").getAbsolutePath(),fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
  assertEquals(fu.normalize(""String_Node_Str"").getAbsolutePath(),fu.removeLeadingPath(new File(""String_Node_Str""),new File(""String_Node_Str"")));
}",0.9393559180259304
64275,"/** 
 * Set the generated manifest file.  For each EJB that is processed an entry is created in this file. This can then be used to create a jar file for dploying the beans.
 * @param manfestFilename the name of the manifest file to be generated.
 */
public void setManifest(String manifestFilename){
  generatedManifestFile=new File(manifestFilename);
}","/** 
 * Set the generated manifest file. For each EJB that is processed an entry is created in this file. This can then be used to create a jar file for dploying the beans.
 * @param manifestFilename the name of the manifest file to be generated.
 */
public void setManifest(String manifestFilename){
  generatedManifestFile=new File(manifestFilename);
}",0.9971751412429378
64276,"/** 
 * Do the work. The work is actually done by creating a separate JVM to run a helper task.  This approach allows the classpath of the helper task to be set. Since the  weblogic tools require the class files of the project's home and remote  interfaces to be available in the classpath, this also avoids having to  start ant with the class path of the project it is building.
 * @exception BuildException if someting goes wrong with the build
 */
public void execute() throws BuildException {
  if (descriptorDirectory == null || !descriptorDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + descriptorDirectory.getPath() + ""String_Node_Str"");
  }
  if (generatedFilesDirectory == null || !generatedFilesDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + generatedFilesDirectory.getPath() + ""String_Node_Str"");
  }
  if (sourceDirectory == null || !sourceDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + sourceDirectory.getPath() + ""String_Node_Str"");
  }
  String systemClassPath=System.getProperty(""String_Node_Str"");
  String execClassPath=project.translatePath(systemClassPath + ""String_Node_Str"" + classpath+ ""String_Node_Str""+ generatedFilesDirectory);
  DirectoryScanner ds=super.getDirectoryScanner(descriptorDirectory);
  String[] files=ds.getIncludedFiles();
  Java helperTask=(Java)project.createTask(""String_Node_Str"");
  helperTask.setTaskName(getTaskName());
  helperTask.setFork(true);
  helperTask.setClassname(""String_Node_Str"");
  String args=""String_Node_Str"";
  args+=""String_Node_Str"" + descriptorDirectory;
  args+=""String_Node_Str"" + generatedFilesDirectory;
  args+=""String_Node_Str"" + sourceDirectory;
  args+=""String_Node_Str"" + generatedManifestFile;
  args+=""String_Node_Str"" + keepgenerated;
  for (int i=0; i < files.length; ++i) {
    args+=""String_Node_Str"" + files[i];
  }
  Commandline.Argument arguments=helperTask.createArg();
  arguments.setLine(args);
  helperTask.setClasspath(new Path(project,execClassPath));
  if (helperTask.executeJava() != 0) {
    throw new BuildException(""String_Node_Str"");
  }
}","/** 
 * Do the work. The work is actually done by creating a separate JVM to run a helper task. This approach allows the classpath of the helper task to be set. Since the weblogic tools require the class files of the project's home and remote interfaces to be available in the classpath, this also avoids having to start ant with the class path of the project it is building.
 * @exception BuildException if someting goes wrong with the build
 */
public void execute() throws BuildException {
  if (descriptorDirectory == null || !descriptorDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + descriptorDirectory.getPath() + ""String_Node_Str"");
  }
  if (generatedFilesDirectory == null || !generatedFilesDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + generatedFilesDirectory.getPath() + ""String_Node_Str"");
  }
  if (sourceDirectory == null || !sourceDirectory.isDirectory()) {
    throw new BuildException(""String_Node_Str"" + sourceDirectory.getPath() + ""String_Node_Str"");
  }
  String systemClassPath=System.getProperty(""String_Node_Str"");
  String execClassPath=project.translatePath(systemClassPath + ""String_Node_Str"" + classpath+ ""String_Node_Str""+ generatedFilesDirectory);
  DirectoryScanner ds=super.getDirectoryScanner(descriptorDirectory);
  String[] files=ds.getIncludedFiles();
  Java helperTask=(Java)project.createTask(""String_Node_Str"");
  helperTask.setTaskName(getTaskName());
  helperTask.setFork(true);
  helperTask.setClassname(""String_Node_Str"");
  String args=""String_Node_Str"";
  args+=""String_Node_Str"" + descriptorDirectory;
  args+=""String_Node_Str"" + generatedFilesDirectory;
  args+=""String_Node_Str"" + sourceDirectory;
  args+=""String_Node_Str"" + generatedManifestFile;
  args+=""String_Node_Str"" + keepgenerated;
  for (int i=0; i < files.length; ++i) {
    args+=""String_Node_Str"" + files[i];
  }
  Commandline.Argument arguments=helperTask.createArg();
  arguments.setLine(args);
  helperTask.setClasspath(new Path(project,execClassPath));
  if (helperTask.executeJava() != 0) {
    throw new BuildException(""String_Node_Str"");
  }
}",0.9990574929311968
64277,"/** 
 * Execute P4 command assembled by subclasses.
 * @param command The command to run
 * @param p4input Input to be fed to command on stdin
 * @param handler A P4Handler to process any input and output
 */
protected void execP4Command(String command,P4Handler handler) throws BuildException {
  try {
    Commandline commandline=new Commandline();
    commandline.setExecutable(""String_Node_Str"");
    if (P4Port != null && P4Port.length() != 0) {
      commandline.createArgument().setValue(P4Port);
    }
    if (P4User != null && P4User.length() != 0) {
      commandline.createArgument().setValue(P4User);
    }
    if (P4Client != null && P4Client.length() != 0) {
      commandline.createArgument().setValue(P4Client);
    }
    commandline.createArgument().setLine(command);
    String[] cmdline=commandline.getCommandline();
    String cmdl=""String_Node_Str"";
    for (int i=0; i < cmdline.length; i++) {
      cmdl+=cmdline[i] + ""String_Node_Str"";
    }
    log(cmdl.describeCommand(),Project.MSG_VERBOSE);
    if (handler == null) {
      handler=new SimpleP4OutputHandler(this);
    }
    Execute exe=new Execute(handler,null);
    exe.setAntRun(project);
    exe.setCommandline(commandline.getCommandline());
    try {
      exe.execute();
    }
 catch (    IOException e) {
      throw new BuildException(e);
    }
 finally {
      try {
        handler.stop();
      }
 catch (      Exception e) {
      }
    }
  }
 catch (  Exception e) {
    String failMsg=""String_Node_Str"" + e.getMessage();
    if (failOnError) {
      throw new BuildException(failMsg);
    }
 else {
      log(failMsg,Project.MSG_ERR);
    }
  }
}","/** 
 * Execute P4 command assembled by subclasses.
 * @param command The command to run
 * @param p4input Input to be fed to command on stdin
 * @param handler A P4Handler to process any input and output
 */
protected void execP4Command(String command,P4Handler handler) throws BuildException {
  try {
    Commandline commandline=new Commandline();
    commandline.setExecutable(""String_Node_Str"");
    if (P4Port != null && P4Port.length() != 0) {
      commandline.createArgument().setValue(P4Port);
    }
    if (P4User != null && P4User.length() != 0) {
      commandline.createArgument().setValue(P4User);
    }
    if (P4Client != null && P4Client.length() != 0) {
      commandline.createArgument().setValue(P4Client);
    }
    commandline.createArgument().setLine(command);
    String[] cmdline=commandline.getCommandline();
    String cmdl=""String_Node_Str"";
    for (int i=0; i < cmdline.length; i++) {
      cmdl+=cmdline[i] + ""String_Node_Str"";
    }
    log(commandline.describeCommand(),Project.MSG_VERBOSE);
    if (handler == null) {
      handler=new SimpleP4OutputHandler(this);
    }
    Execute exe=new Execute(handler,null);
    exe.setAntRun(project);
    exe.setCommandline(commandline.getCommandline());
    try {
      exe.execute();
    }
 catch (    IOException e) {
      throw new BuildException(e);
    }
 finally {
      try {
        handler.stop();
      }
 catch (      Exception e) {
      }
    }
  }
 catch (  Exception e) {
    String failMsg=""String_Node_Str"" + e.getMessage();
    if (failOnError) {
      throw new BuildException(failMsg);
    }
 else {
      log(failMsg,Project.MSG_ERR);
    }
  }
}",0.9960402071276272
64278,"/** 
 * Sole constructor, which is private to ensure that all  IntrospectionHelpers are created via   {@link #getHelper(Class) getHelper}. Introspects the given class for bean-like methods. Each method is examined in turn, and the following rules are applied: <p> <ul> <li>If the method is <code>Task.setLocation(Location)</code>,  <code>Task.setTaskType(String)</code> or <code>TaskContainer.addTask(Task)</code>, it is ignored. These  methods are handled differently elsewhere. <li><code>void addText(String)</code> is recognised as the method for adding PCDATA to a bean. <li><code>void setFoo(Bar)</code> is recognised as a method for  setting the value of attribute <code>foo</code>, so long as  <code>Bar</code> is non-void and is not an array type. Non-String  parameter types always overload String parameter types, but that is the only guarantee made in terms of priority. <li><code>Foo createBar()</code> is recognised as a method for creating a nested element called <code>bar</code> of type  <code>Foo</code>, so long as <code>Foo</code> is not a primitive or array type. <li><code>void addConfiguredFoo(Bar)</code> is recognised as a method for storing a pre-configured element called  <code>foo</code> and of type <code>Bar</code>, so long as <code>Bar</code> is not an array, primitive or String type.  <code>Bar</code> must have an accessible constructor taking no  arguments. <li><code>void addFoo(Bar)</code> is recognised as a method for storing an element called <code>foobar</code>  and of type <code>Baz</code>, so long as <code>Baz</code> is not an array, primitive or String type.  <code>Baz</code> must have an accessible constructor taking no  arguments. </ul> Note that only one method is retained to create/set/addConfigured/add  any element or attribute.
 * @param bean The bean type to introspect. Must not be <code>null</code>.
 * @see #getHelper(Class)
 */
private IntrospectionHelper(final Class bean){
  attributeTypes=new Hashtable();
  attributeSetters=new Hashtable();
  nestedTypes=new Hashtable();
  nestedCreators=new Hashtable();
  nestedStorers=new Hashtable();
  this.bean=bean;
  Method[] methods=bean.getMethods();
  for (int i=0; i < methods.length; i++) {
    final Method m=methods[i];
    final String name=m.getName();
    Class returnType=m.getReturnType();
    Class[] args=m.getParameterTypes();
    if (org.apache.tools.ant.Task.class.isAssignableFrom(bean) && args.length == 1 && ((""String_Node_Str"".equals(name) && org.apache.tools.ant.Location.class.equals(args[0])) || (""String_Node_Str"".equals(name) && java.lang.String.class.equals(args[0])))) {
      continue;
    }
    if (org.apache.tools.ant.TaskContainer.class.isAssignableFrom(bean) && args.length == 1 && ""String_Node_Str"".equals(name) && org.apache.tools.ant.Task.class.equals(args[0])) {
      continue;
    }
    if (""String_Node_Str"".equals(name) && java.lang.Void.TYPE.equals(returnType) && args.length == 1 && java.lang.String.class.equals(args[0])) {
      addText=methods[i];
    }
 else     if (name.startsWith(""String_Node_Str"") && java.lang.Void.TYPE.equals(returnType) && args.length == 1 && !args[0].isArray()) {
      String propName=getPropertyName(name,""String_Node_Str"");
      if (attributeSetters.get(propName) != null) {
        if (java.lang.String.class.equals(args[0])) {
          continue;
        }
      }
      AttributeSetter as=createAttributeSetter(m,args[0]);
      if (as != null) {
        attributeTypes.put(propName,args[0]);
        attributeSetters.put(propName,as);
      }
    }
 else     if (name.startsWith(""String_Node_Str"") && !returnType.isArray() && !returnType.isPrimitive()&& args.length == 0) {
      String propName=getPropertyName(name,""String_Node_Str"");
      nestedTypes.put(propName,returnType);
      nestedCreators.put(propName,new NestedCreator(){
        public Object create(        Object parent) throws InvocationTargetException, IllegalAccessException {
          return m.invoke(parent,new Object[]{});
        }
      }
);
      nestedStorers.remove(propName);
    }
 else     if (name.startsWith(""String_Node_Str"") && java.lang.Void.TYPE.equals(returnType) && args.length == 1 && !java.lang.String.class.equals(args[0]) && !args[0].isArray() && !args[0].isPrimitive()) {
      try {
        final Constructor c=args[0].getConstructor(new Class[]{});
        String propName=getPropertyName(name,""String_Node_Str"");
        nestedTypes.put(propName,args[0]);
        nestedCreators.put(propName,new NestedCreator(){
          public Object create(          Object parent) throws InvocationTargetException, IllegalAccessException, InstantiationException {
            Object o=c.newInstance(new Object[]{});
            return o;
          }
        }
);
        nestedStorers.put(propName,new NestedStorer(){
          public void store(          Object parent,          Object child) throws InvocationTargetException, IllegalAccessException, InstantiationException {
            m.invoke(parent,new Object[]{child});
          }
        }
);
      }
 catch (      NoSuchMethodException nse) {
      }
    }
 else     if (name.startsWith(""String_Node_Str"") && java.lang.Void.TYPE.equals(returnType) && args.length == 1 && !java.lang.String.class.equals(args[0]) && !args[0].isArray() && !args[0].isPrimitive()) {
      try {
        final Constructor c=args[0].getConstructor(new Class[]{});
        String propName=getPropertyName(name,""String_Node_Str"");
        nestedTypes.put(propName,args[0]);
        nestedCreators.put(propName,new NestedCreator(){
          public Object create(          Object parent) throws InvocationTargetException, IllegalAccessException, InstantiationException {
            Object o=c.newInstance(new Object[]{});
            m.invoke(parent,new Object[]{o});
            return o;
          }
        }
);
        nestedStorers.remove(name);
      }
 catch (      NoSuchMethodException nse) {
      }
    }
  }
}","/** 
 * Sole constructor, which is private to ensure that all  IntrospectionHelpers are created via   {@link #getHelper(Class) getHelper}. Introspects the given class for bean-like methods. Each method is examined in turn, and the following rules are applied: <p> <ul> <li>If the method is <code>Task.setLocation(Location)</code>,  <code>Task.setTaskType(String)</code> or <code>TaskContainer.addTask(Task)</code>, it is ignored. These  methods are handled differently elsewhere. <li><code>void addText(String)</code> is recognised as the method for adding PCDATA to a bean. <li><code>void setFoo(Bar)</code> is recognised as a method for  setting the value of attribute <code>foo</code>, so long as  <code>Bar</code> is non-void and is not an array type. Non-String  parameter types always overload String parameter types, but that is the only guarantee made in terms of priority. <li><code>Foo createBar()</code> is recognised as a method for creating a nested element called <code>bar</code> of type  <code>Foo</code>, so long as <code>Foo</code> is not a primitive or array type. <li><code>void addConfiguredFoo(Bar)</code> is recognised as a method for storing a pre-configured element called  <code>foo</code> and of type <code>Bar</code>, so long as <code>Bar</code> is not an array, primitive or String type.  <code>Bar</code> must have an accessible constructor taking no  arguments. <li><code>void addFoo(Bar)</code> is recognised as a method for storing an element called <code>foobar</code>  and of type <code>Baz</code>, so long as <code>Baz</code> is not an array, primitive or String type.  <code>Baz</code> must have an accessible constructor taking no  arguments. </ul> Note that only one method is retained to create/set/addConfigured/add  any element or attribute.
 * @param bean The bean type to introspect. Must not be <code>null</code>.
 * @see #getHelper(Class)
 */
private IntrospectionHelper(final Class bean){
  attributeTypes=new Hashtable();
  attributeSetters=new Hashtable();
  nestedTypes=new Hashtable();
  nestedCreators=new Hashtable();
  nestedStorers=new Hashtable();
  this.bean=bean;
  Method[] methods=bean.getMethods();
  for (int i=0; i < methods.length; i++) {
    final Method m=methods[i];
    final String name=m.getName();
    Class returnType=m.getReturnType();
    Class[] args=m.getParameterTypes();
    if (org.apache.tools.ant.Task.class.isAssignableFrom(bean) && args.length == 1 && isHiddenSetMethod(name,args[0])) {
      continue;
    }
    if (org.apache.tools.ant.TaskContainer.class.isAssignableFrom(bean) && args.length == 1 && ""String_Node_Str"".equals(name) && org.apache.tools.ant.Task.class.equals(args[0])) {
      continue;
    }
    if (""String_Node_Str"".equals(name) && java.lang.Void.TYPE.equals(returnType) && args.length == 1 && java.lang.String.class.equals(args[0])) {
      addText=methods[i];
    }
 else     if (name.startsWith(""String_Node_Str"") && java.lang.Void.TYPE.equals(returnType) && args.length == 1 && !args[0].isArray()) {
      String propName=getPropertyName(name,""String_Node_Str"");
      if (attributeSetters.get(propName) != null) {
        if (java.lang.String.class.equals(args[0])) {
          continue;
        }
      }
      AttributeSetter as=createAttributeSetter(m,args[0]);
      if (as != null) {
        attributeTypes.put(propName,args[0]);
        attributeSetters.put(propName,as);
      }
    }
 else     if (name.startsWith(""String_Node_Str"") && !returnType.isArray() && !returnType.isPrimitive()&& args.length == 0) {
      String propName=getPropertyName(name,""String_Node_Str"");
      nestedTypes.put(propName,returnType);
      nestedCreators.put(propName,new NestedCreator(){
        public Object create(        Object parent) throws InvocationTargetException, IllegalAccessException {
          return m.invoke(parent,new Object[]{});
        }
      }
);
      nestedStorers.remove(propName);
    }
 else     if (name.startsWith(""String_Node_Str"") && java.lang.Void.TYPE.equals(returnType) && args.length == 1 && !java.lang.String.class.equals(args[0]) && !args[0].isArray() && !args[0].isPrimitive()) {
      try {
        final Constructor c=args[0].getConstructor(new Class[]{});
        String propName=getPropertyName(name,""String_Node_Str"");
        nestedTypes.put(propName,args[0]);
        nestedCreators.put(propName,new NestedCreator(){
          public Object create(          Object parent) throws InvocationTargetException, IllegalAccessException, InstantiationException {
            Object o=c.newInstance(new Object[]{});
            return o;
          }
        }
);
        nestedStorers.put(propName,new NestedStorer(){
          public void store(          Object parent,          Object child) throws InvocationTargetException, IllegalAccessException, InstantiationException {
            m.invoke(parent,new Object[]{child});
          }
        }
);
      }
 catch (      NoSuchMethodException nse) {
      }
    }
 else     if (name.startsWith(""String_Node_Str"") && java.lang.Void.TYPE.equals(returnType) && args.length == 1 && !java.lang.String.class.equals(args[0]) && !args[0].isArray() && !args[0].isPrimitive()) {
      try {
        final Constructor c=args[0].getConstructor(new Class[]{});
        String propName=getPropertyName(name,""String_Node_Str"");
        nestedTypes.put(propName,args[0]);
        nestedCreators.put(propName,new NestedCreator(){
          public Object create(          Object parent) throws InvocationTargetException, IllegalAccessException, InstantiationException {
            Object o=c.newInstance(new Object[]{});
            m.invoke(parent,new Object[]{o});
            return o;
          }
        }
);
        nestedStorers.remove(name);
      }
 catch (      NoSuchMethodException nse) {
      }
    }
  }
}",0.984646878198567
64279,"/** 
 * Returns a copy of the properties table.
 * @return a hashtable containing all properties(including user properties).
 */
public Hashtable getProperties(){
  Hashtable propsCopy=new Hashtable();
  Map contextProps=m_context.getProperties();
  Iterator propNames=contextProps.keySet().iterator();
  while (propNames.hasNext()) {
    String name=(String)propNames.next();
    String value=getProperty(name);
    if (value != null) {
      propsCopy.put(name,value);
    }
  }
  return propsCopy;
}","/** 
 * Returns a copy of the properties table.
 * @return a hashtable containing all properties(including user properties).
 */
public Hashtable getProperties(){
  final Hashtable propsCopy=new Hashtable();
  final Map contextProps;
  try {
    contextProps=m_context.getProperties();
  }
 catch (  final TaskException e) {
    throw new BuildException(e);
  }
  final Iterator propNames=contextProps.keySet().iterator();
  while (propNames.hasNext()) {
    final String name=(String)propNames.next();
    final String value=getProperty(name);
    if (value != null) {
      propsCopy.put(name,value);
    }
  }
  return propsCopy;
}",0.8838028169014085
64280,"/** 
 * Returns the file location where the error occurred.
 * @return the file location where the error occurred.
 */
public Location getLocation(){
  return location;
}","/** 
 * Returns the file location where the error occurred.
 * @return the file location where the error occurred.
 */
public Location getLocation(){
  return m_location;
}",0.9941520467836256
64281,"/** 
 * Returns the nested exception, if any.
 * @return the nested exception, or <code>null</code> if noexception is associated with this one
 */
public Throwable getException(){
  return cause;
}","/** 
 * Returns the nested exception, if any.
 * @return the nested exception, or <code>null</code> if noexception is associated with this one
 */
public Throwable getException(){
  return m_cause;
}",0.9949494949494948
64282,"/** 
 * Prints the stack trace of this exception and any nested exception to the specified PrintWriter.
 * @param pw The PrintWriter to print the stack trace to.Must not be <code>null</code>.
 */
public void printStackTrace(PrintWriter pw){
synchronized (pw) {
    super.printStackTrace(pw);
    if (cause != null) {
      pw.println(""String_Node_Str"");
      cause.printStackTrace(pw);
    }
  }
}","/** 
 * Prints the stack trace of this exception and any nested exception to the specified PrintWriter.
 * @param pw The PrintWriter to print the stack trace to.Must not be <code>null</code>.
 */
public void printStackTrace(PrintWriter pw){
synchronized (pw) {
    super.printStackTrace(pw);
    if (m_cause != null) {
      pw.println(""String_Node_Str"");
      m_cause.printStackTrace(pw);
    }
  }
}",0.995
64283,"/** 
 * Sets the file location where the error occurred.
 * @param location The file location where the error occurred.Must not be <code>null</code>.
 */
public void setLocation(Location location){
  this.location=location;
}","/** 
 * Sets the file location where the error occurred.
 * @param location The file location where the error occurred.Must not be <code>null</code>.
 */
public void setLocation(final Location location){
  m_location=location;
}",0.9713024282560706
64284,"/** 
 * Returns the location of the error and the error message.
 * @return the location of the error and the error message
 */
public String toString(){
  return location.toString() + getMessage();
}","/** 
 * Returns the location of the error and the error message.
 * @return the location of the error and the error message
 */
public String toString(){
  return m_location.toString() + getMessage();
}",0.9950248756218906
64285,"/** 
 * Constructs an exception with the given exception as a root cause and a location in a file.
 * @param cause The exception that might have caused this one.Should not be <code>null</code>.
 * @param location The location in the project file where the error occurred. Must not be <code>null</code>.
 */
public BuildException(Throwable cause,Location location){
  this(cause);
  this.location=location;
}","/** 
 * Constructs an exception with the given exception as a root cause and a location in a file.
 * @param cause The exception that might have caused this one.Should not be <code>null</code>.
 * @param location The location in the project file where the error occurred. Must not be <code>null</code>.
 */
public BuildException(final Throwable cause,final Location location){
  this(cause);
  m_location=location;
}",0.976913730255164
64286,"/** 
 * Myrmidon-friendly cascading exception method.
 * @return the cascading cause of this exception.
 */
public Throwable getCause(){
  return cause;
}","/** 
 * Myrmidon-friendly cascading exception method.
 * @return the cascading cause of this exception.
 */
public Throwable getCause(){
  return m_cause;
}",0.9935483870967742
64287,"/** 
 * Process a line while in ""GET_PREVIOUS_REVISION"" state.
 * @param line the line
 */
private void processGetPreviousRevision(final String line){
  if (!line.startsWith(""String_Node_Str"")) {
    final String message=REZ.getString(""String_Node_Str"",line);
    throw new IllegalStateException(message);
  }
  m_previousRevision=line.substring(9);
  saveEntry();
  m_revision=m_previousRevision;
  m_status=GET_COMMENT;
}","/** 
 * Process a line while in ""GET_PREVIOUS_REVISION"" state.
 * @param line the line
 */
private void processGetPreviousRevision(final String line){
  if (!line.startsWith(""String_Node_Str"")) {
    final String message=REZ.getString(""String_Node_Str"",line);
    throw new IllegalStateException(message);
  }
  m_previousRevision=line.substring(9);
  saveEntry();
  m_revision=m_previousRevision;
  m_status=GET_DATE;
}",0.98932384341637
64288,"/** 
 * Process a line while in ""GET_COMMENT"" state.
 * @param line the line
 */
private void processComment(final String line){
  final String lineSeparator=System.getProperty(""String_Node_Str"");
  if (line.startsWith(""String_Node_Str"")) {
    final int end=m_comment.length() - lineSeparator.length();
    m_comment=m_comment.substring(0,end);
    m_comment=""String_Node_Str"" + m_comment + ""String_Node_Str"";
    saveEntry();
    m_status=GET_FILE;
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    final int end=m_comment.length() - lineSeparator.length();
    m_comment=m_comment.substring(0,end);
    m_comment=""String_Node_Str"" + m_comment + ""String_Node_Str"";
    m_status=GET_PREVIOUS_REV;
  }
 else {
    m_comment+=line + lineSeparator;
  }
}","/** 
 * Process a line while in ""GET_COMMENT"" state.
 * @param line the line
 */
private void processComment(final String line){
  final String lineSeparator=System.getProperty(""String_Node_Str"");
  if (line.startsWith(""String_Node_Str"")) {
    final int end=m_comment.length() - lineSeparator.length();
    m_comment=m_comment.substring(0,end);
    saveEntry();
    m_status=GET_FILE;
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    final int end=m_comment.length() - lineSeparator.length();
    m_comment=m_comment.substring(0,end);
    m_status=GET_PREVIOUS_REV;
  }
 else {
    m_comment+=line + lineSeparator;
  }
}",0.9064748201438848
64289,"/** 
 * Process a line while in ""DATE"" state.
 * @param line the line
 */
private void processDate(final String line){
  if (line.startsWith(""String_Node_Str"")) {
    m_date=line.substring(6,16);
    String lineData=line.substring(line.indexOf(""String_Node_Str"") + 1);
    m_author=lineData.substring(10,lineData.indexOf(""String_Node_Str""));
    if (m_userList.containsKey(m_author)) {
      m_author=""String_Node_Str"" + m_userList.getProperty(m_author) + ""String_Node_Str"";
    }
    m_status=GET_COMMENT;
    m_comment=""String_Node_Str"";
  }
}","/** 
 * Process a line while in ""DATE"" state.
 * @param line the line
 */
private void processDate(final String line){
  if (line.startsWith(""String_Node_Str"")) {
    m_date=line.substring(6,16);
    String lineData=line.substring(line.indexOf(""String_Node_Str"") + 1);
    m_author=lineData.substring(10,lineData.indexOf(""String_Node_Str""));
    if (m_userList.containsKey(m_author)) {
      m_author=m_userList.getProperty(m_author);
    }
    m_status=GET_COMMENT;
    m_comment=""String_Node_Str"";
  }
}",0.961904761904762
64290,"/** 
 * Process a line while in ""GET_PREVIOUS_REVISION"" state.
 * @param line the line
 */
private void processGetPreviousRevision(final String line){
  if (!line.startsWith(""String_Node_Str"")) {
    throw new IllegalStateException(""String_Node_Str"" + line);
  }
  m_previousRevision=line.substring(9);
  saveEntry();
  m_revision=m_previousRevision;
  m_status=GET_COMMENT;
}","/** 
 * Process a line while in ""GET_PREVIOUS_REVISION"" state.
 * @param line the line
 */
private void processGetPreviousRevision(final String line){
  if (!line.startsWith(""String_Node_Str"")) {
    throw new IllegalStateException(""String_Node_Str"" + line);
  }
  m_previousRevision=line.substring(9);
  saveEntry();
  m_revision=m_previousRevision;
  m_status=GET_DATE;
}",0.9879839786381842
64291,"/** 
 * Process a line while in ""GET_PREVIOUS_REVISION"" state.
 * @param line the line
 */
private void processGetPreviousRevision(final String line){
  final String entryKey=m_date + m_author + m_comment;
  if (line.startsWith(""String_Node_Str"")) {
    m_previousRevision=line.substring(9);
    m_status=GET_FILE;
    CVSEntry entry;
    if (!m_entries.containsKey(entryKey)) {
      entry=new CVSEntry(parseDate(m_date),m_author,m_comment);
      m_entries.put(entryKey,entry);
    }
 else {
      entry=(CVSEntry)m_entries.get(entryKey);
    }
    entry.addFile(m_file,m_revision,m_previousRevision);
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    m_status=GET_FILE;
    CVSEntry entry;
    if (!m_entries.containsKey(entryKey)) {
      entry=new CVSEntry(parseDate(m_date),m_author,m_comment);
      m_entries.put(entryKey,entry);
    }
 else {
      entry=(CVSEntry)m_entries.get(entryKey);
    }
    entry.addFile(m_file,m_revision);
  }
}","/** 
 * Process a line while in ""GET_PREVIOUS_REVISION"" state.
 * @param line the line
 */
private void processGetPreviousRevision(final String line){
  if (!line.startsWith(""String_Node_Str"")) {
    throw new IllegalStateException(""String_Node_Str"" + line);
  }
  m_previousRevision=line.substring(9);
  saveEntry();
  m_revision=m_previousRevision;
  m_status=GET_COMMENT;
}",0.2672672672672673
64292,"/** 
 * Receive notification about the process writing to standard output.
 */
public void stdout(final String line){
switch (m_status) {
case GET_FILE:
    processFile(line);
  break;
case GET_REVISION:
processRevision(line);
case GET_DATE:
processDate(line);
break;
case GET_COMMENT:
processComment(line);
break;
case GET_PREVIOUS_REV:
processGetPreviousRevision(line);
break;
}
}","/** 
 * Receive notification about the process writing to standard output.
 */
public void stdout(final String line){
switch (m_status) {
case GET_FILE:
    processFile(line);
  break;
case GET_REVISION:
processRevision(line);
break;
case GET_DATE:
processDate(line);
break;
case GET_COMMENT:
processComment(line);
break;
case GET_PREVIOUS_REV:
processGetPreviousRevision(line);
break;
}
}",0.9909208819714656
64293,"/** 
 * Process a line while in ""GET_COMMENT"" state.
 * @param line the line
 */
private void processComment(final String line){
  final String lineSeparator=System.getProperty(""String_Node_Str"");
  if (line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"")) {
    final int end=m_comment.length() - lineSeparator.length();
    m_comment=m_comment.substring(0,end);
    m_comment=""String_Node_Str"" + m_comment + ""String_Node_Str"";
    m_status=GET_PREVIOUS_REV;
  }
 else {
    m_comment+=line + lineSeparator;
  }
}","/** 
 * Process a line while in ""GET_COMMENT"" state.
 * @param line the line
 */
private void processComment(final String line){
  final String lineSeparator=System.getProperty(""String_Node_Str"");
  if (line.startsWith(""String_Node_Str"")) {
    final int end=m_comment.length() - lineSeparator.length();
    m_comment=m_comment.substring(0,end);
    m_comment=""String_Node_Str"" + m_comment + ""String_Node_Str"";
    saveEntry();
    m_status=GET_FILE;
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    final int end=m_comment.length() - lineSeparator.length();
    m_comment=m_comment.substring(0,end);
    m_comment=""String_Node_Str"" + m_comment + ""String_Node_Str"";
    m_status=GET_PREVIOUS_REV;
  }
 else {
    m_comment+=line + lineSeparator;
  }
}",0.8191653786707882
64294,"/** 
 * test for compilation needed. true means yes, false means our tests do not indicate this, but as the TLDs are not used for dependency checking this is not guaranteed. The current tests are <ol> <li>no dest file <li>dest file out of date w.r.t source <li>dest file zero bytes long </ol>
 * @param srcFile JSP source file
 * @param javaFile JSP dest file
 * @return true if a compile is definately needed.
 */
private boolean isCompileNeeded(File srcFile,File javaFile){
  boolean shouldCompile=false;
  if (!javaFile.exists()) {
    shouldCompile=true;
    log(""String_Node_Str"" + srcFile.getPath() + ""String_Node_Str""+ javaFile.getPath()+ ""String_Node_Str"",Project.MSG_VERBOSE);
  }
 else {
    if (srcFile.lastModified() > javaFile.lastModified()) {
      shouldCompile=true;
      log(""String_Node_Str"" + srcFile.getPath() + ""String_Node_Str""+ javaFile.getPath(),Project.MSG_VERBOSE);
    }
 else {
      if (javaFile.length() == 0) {
        shouldCompile=true;
        log(""String_Node_Str"" + srcFile.getPath() + ""String_Node_Str""+ javaFile.getPath()+ ""String_Node_Str"",Project.MSG_VERBOSE);
      }
    }
  }
  return shouldCompile;
}","/** 
 * Test whether or not compilation is needed. A return value of  <code>true<code> means yes, <code>false</code> means our tests do not indicate this, but as the TLDs are not used for dependency checking this is not guaranteed. The current tests are <ol> <li>no dest file <li>dest file out of date w.r.t source <li>dest file zero bytes long </ol>
 * @param srcFile JSP source file
 * @param javaFile JSP dest file
 * @return true if a compile is definately needed.
 */
private boolean isCompileNeeded(File srcFile,File javaFile){
  boolean shouldCompile=false;
  if (!javaFile.exists()) {
    shouldCompile=true;
    log(""String_Node_Str"" + srcFile.getPath() + ""String_Node_Str""+ javaFile.getPath()+ ""String_Node_Str"",Project.MSG_VERBOSE);
  }
 else {
    if (srcFile.lastModified() > javaFile.lastModified()) {
      shouldCompile=true;
      log(""String_Node_Str"" + srcFile.getPath() + ""String_Node_Str""+ javaFile.getPath(),Project.MSG_VERBOSE);
    }
 else {
      if (javaFile.length() == 0) {
        shouldCompile=true;
        log(""String_Node_Str"" + srcFile.getPath() + ""String_Node_Str""+ javaFile.getPath()+ ""String_Node_Str"",Project.MSG_VERBOSE);
      }
    }
  }
  return shouldCompile;
}",0.9540425531914892
64295,"/** 
 * web apps param. only one is allowed.
 * @param fs  add a web app fileset
 */
public void addWebApp(WebAppParameter webappParam) throws BuildException {
  if (webApp == null) {
    webApp=webappParam;
  }
 else {
    throw new BuildException(""String_Node_Str"");
  }
}","/** 
 * Web apps parameter. Only one is allowed.
 * @param fs  add a web app fileset
 */
public void addWebApp(WebAppParameter webappParam) throws BuildException {
  if (webApp == null) {
    webApp=webappParam;
  }
 else {
    throw new BuildException(""String_Node_Str"");
  }
}",0.9384057971014492
64296,"/** 
 * set the compiler. optional: default=jasper
 */
public void setCompiler(String compiler){
  this.compilerName=compiler;
}","/** 
 * Sets the compiler to use. Optional: default=jasper
 */
public void setCompiler(String compiler){
  this.compilerName=compiler;
}",0.9545454545454546
64297,"/** 
 * Set the comment to apply in SourceSafe <p> If this is null or empty, it will be replaced with ""-"" which is what SourceSafe uses for an empty comment.
 */
public void setComment(String comment){
  if (comment.equals(""String_Node_Str"") || comment.equals(""String_Node_Str"")) {
    m_Comment=""String_Node_Str"";
  }
 else {
    m_Comment=comment;
  }
}","/** 
 * Sets the comment to apply in SourceSafe. <p> If this is null or empty, it will be replaced with ""-"" which is what SourceSafe uses for an empty comment.
 */
public void setComment(String comment){
  if (comment.equals(""String_Node_Str"") || comment.equals(""String_Node_Str"")) {
    m_Comment=""String_Node_Str"";
  }
 else {
    m_Comment=comment;
  }
}",0.9971910112359552
64298,"/** 
 * Set the comment to apply in SourceSafe <p> If this is null or empty, it will be replaced with ""-"" which is what SourceSafe uses for an empty comment.
 * @param comment the comment to apply in SourceSafe
 */
public void setComment(String comment){
  if (comment.equals(""String_Node_Str"") || comment.equals(""String_Node_Str"")) {
    m_Comment=""String_Node_Str"";
  }
 else {
    m_Comment=comment;
  }
}","/** 
 * Sets the comment to apply in SourceSafe. <p> If this is null or empty, it will be replaced with ""-"" which is what SourceSafe uses for an empty comment.
 * @param comment the comment to apply in SourceSafe
 */
public void setComment(String comment){
  if (comment.equals(""String_Node_Str"") || comment.equals(""String_Node_Str"")) {
    m_Comment=""String_Node_Str"";
  }
 else {
    m_Comment=comment;
  }
}",0.9975550122249388
64299,"/** 
 * Add a class name in slash format (e.g. org/apache/tools/ant/...)
 * @param classname the class name in slash format
 */
private void addSlashClass(String classname){
  addClass(classname.replace('/','.'));
}","/** 
 * Adds a class name in slash format  (for example org/apache/tools/ant/Main).
 * @param classname the class name in slash format
 */
private void addSlashClass(String classname){
  addClass(classname.replace('/','.'));
}",0.2312925170068027
64300,"/** 
 * Create an instance of converter with specified name.
 * @param name the name of converter
 * @return the created converter instance
 * @throws java.lang.Exception if converter can not be created.
 */
protected abstract Converter createConverter(final String name) throws Exception ;","/** 
 * Create an instance of converter with specified name.
 * @param name the name of converter
 * @return the created converter instance
 * @throws Exception if converter can not be created.
 */
protected abstract Converter createConverter(final String name) throws Exception ;",0.9824561403508772
64301,"/** 
 * Get the next entry in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.
 * @return The next TarEntry in the archive, or null.
 * @exception IOException Description of Exception
 */
public TarEntry getNextEntry() throws IOException {
  if (m_hasHitEOF) {
    return null;
  }
  if (m_currEntry != null) {
    final int numToSkip=m_entrySize - m_entryOffset;
    if (m_debug) {
      final String message=""String_Node_Str"" + m_currEntry.getName() + ""String_Node_Str""+ m_entrySize+ ""String_Node_Str""+ m_entryOffset+ ""String_Node_Str""+ numToSkip+ ""String_Node_Str"";
      debug(message);
    }
    if (numToSkip > 0) {
      skip(numToSkip);
    }
    m_readBuf=null;
  }
  final byte[] headerBuf=m_buffer.readRecord();
  if (headerBuf == null) {
    if (m_debug) {
      debug(""String_Node_Str"");
    }
    m_hasHitEOF=true;
  }
 else   if (m_buffer.isEOFRecord(headerBuf)) {
    if (m_debug) {
      debug(""String_Node_Str"");
    }
    m_hasHitEOF=true;
  }
  if (m_hasHitEOF) {
    m_currEntry=null;
  }
 else {
    m_currEntry=new TarEntry(headerBuf);
    if (!(headerBuf[257] == 'u' && headerBuf[258] == 's' && headerBuf[259] == 't' && headerBuf[260] == 'a' && headerBuf[261] == 'r')) {
      m_v7Format=true;
    }
    if (m_debug) {
      final String message=""String_Node_Str"" + m_currEntry.getName() + ""String_Node_Str""+ m_currEntry.getSize();
      debug(message);
    }
    m_entryOffset=0;
    m_entrySize=(int)m_currEntry.getSize();
  }
  if (null != m_currEntry && m_currEntry.isGNULongNameEntry()) {
    final StringBuffer longName=new StringBuffer();
    final byte[] buffer=new byte[256];
    int length=0;
    while ((length=read(buffer)) >= 0) {
      final String str=new String(buffer,0,length);
      longName.append(str);
    }
    getNextEntry();
    m_currEntry.setName(longName.toString());
  }
  return m_currEntry;
}","/** 
 * Get the next entry in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.
 * @return The next TarEntry in the archive, or null.
 * @exception IOException Description of Exception
 */
public TarEntry getNextEntry() throws IOException {
  if (m_hasHitEOF) {
    return null;
  }
  if (m_currEntry != null) {
    final int numToSkip=m_entrySize - m_entryOffset;
    if (m_debug) {
      final String message=""String_Node_Str"" + m_currEntry.getName() + ""String_Node_Str""+ m_entrySize+ ""String_Node_Str""+ m_entryOffset+ ""String_Node_Str""+ numToSkip+ ""String_Node_Str"";
      debug(message);
    }
    if (numToSkip > 0) {
      skip(numToSkip);
    }
    m_readBuf=null;
  }
  final byte[] headerBuf=m_buffer.readRecord();
  if (headerBuf == null) {
    if (m_debug) {
      debug(""String_Node_Str"");
    }
    m_hasHitEOF=true;
  }
 else   if (m_buffer.isEOFRecord(headerBuf)) {
    if (m_debug) {
      debug(""String_Node_Str"");
    }
    m_hasHitEOF=true;
  }
  if (m_hasHitEOF) {
    m_currEntry=null;
  }
 else {
    m_currEntry=new TarEntry(headerBuf);
    if (!(headerBuf[257] == 'u' && headerBuf[258] == 's' && headerBuf[259] == 't' && headerBuf[260] == 'a' && headerBuf[261] == 'r')) {
    }
    if (m_debug) {
      final String message=""String_Node_Str"" + m_currEntry.getName() + ""String_Node_Str""+ m_currEntry.getSize();
      debug(message);
    }
    m_entryOffset=0;
    m_entrySize=(int)m_currEntry.getSize();
  }
  if (null != m_currEntry && m_currEntry.isGNULongNameEntry()) {
    final StringBuffer longName=new StringBuffer();
    final byte[] buffer=new byte[256];
    int length=0;
    while ((length=read(buffer)) >= 0) {
      final String str=new String(buffer,0,length);
      longName.append(str);
    }
    getNextEntry();
    m_currEntry.setName(longName.toString());
  }
  return m_currEntry;
}",0.99468453894153
64302,"/** 
 * Reads bytes from the current tar archive entry. This method is aware of the boundaries of the current entry in the archive and will deal with them as if they were this stream's start and EOF.
 * @param buf The buffer into which to place bytes read.
 * @param offset The offset at which to place bytes read.
 * @param count The number of bytes to read.
 * @return The number of bytes read, or -1 at EOF.
 */
public int read(final byte[] buffer,final int offset,final int count) throws IOException {
  int position=offset;
  int numToRead=count;
  int totalRead=0;
  if (m_entryOffset >= m_entrySize) {
    return -1;
  }
  if ((numToRead + m_entryOffset) > m_entrySize) {
    numToRead=(m_entrySize - m_entryOffset);
  }
  if (null != m_readBuf) {
    final int size=(numToRead > m_readBuf.length) ? m_readBuf.length : numToRead;
    System.arraycopy(m_readBuf,0,buffer,position,size);
    if (size >= m_readBuf.length) {
      m_readBuf=null;
    }
 else {
      final int newLength=m_readBuf.length - size;
      final byte[] newBuffer=new byte[newLength];
      System.arraycopy(m_readBuf,size,newBuffer,0,newLength);
      m_readBuf=newBuffer;
    }
    totalRead+=size;
    numToRead-=size;
    position+=size;
  }
  while (numToRead > 0) {
    final byte[] rec=m_buffer.readRecord();
    if (null == rec) {
      final String message=""String_Node_Str"" + numToRead + ""String_Node_Str"";
      throw new IOException(message);
    }
    int size=numToRead;
    final int recordLength=rec.length;
    if (recordLength > size) {
      System.arraycopy(rec,0,buffer,position,size);
      m_readBuf=new byte[recordLength - size];
      System.arraycopy(rec,size,m_readBuf,0,recordLength - size);
    }
 else {
      size=recordLength;
      System.arraycopy(rec,0,buffer,position,recordLength);
    }
    totalRead+=size;
    numToRead-=size;
    position+=size;
  }
  m_entryOffset+=totalRead;
  return totalRead;
}","/** 
 * Reads bytes from the current tar archive entry. This method is aware of the boundaries of the current entry in the archive and will deal with them as if they were this stream's start and EOF.
 * @param buffer The buffer into which to place bytes read.
 * @param offset The offset at which to place bytes read.
 * @param count The number of bytes to read.
 * @return The number of bytes read, or -1 at EOF.
 */
public int read(final byte[] buffer,final int offset,final int count) throws IOException {
  int position=offset;
  int numToRead=count;
  int totalRead=0;
  if (m_entryOffset >= m_entrySize) {
    return -1;
  }
  if ((numToRead + m_entryOffset) > m_entrySize) {
    numToRead=(m_entrySize - m_entryOffset);
  }
  if (null != m_readBuf) {
    final int size=(numToRead > m_readBuf.length) ? m_readBuf.length : numToRead;
    System.arraycopy(m_readBuf,0,buffer,position,size);
    if (size >= m_readBuf.length) {
      m_readBuf=null;
    }
 else {
      final int newLength=m_readBuf.length - size;
      final byte[] newBuffer=new byte[newLength];
      System.arraycopy(m_readBuf,size,newBuffer,0,newLength);
      m_readBuf=newBuffer;
    }
    totalRead+=size;
    numToRead-=size;
    position+=size;
  }
  while (numToRead > 0) {
    final byte[] rec=m_buffer.readRecord();
    if (null == rec) {
      final String message=""String_Node_Str"" + numToRead + ""String_Node_Str"";
      throw new IOException(message);
    }
    int size=numToRead;
    final int recordLength=rec.length;
    if (recordLength > size) {
      System.arraycopy(rec,0,buffer,position,size);
      m_readBuf=new byte[recordLength - size];
      System.arraycopy(rec,size,m_readBuf,0,recordLength - size);
    }
 else {
      size=recordLength;
      System.arraycopy(rec,0,buffer,position,recordLength);
    }
    totalRead+=size;
    numToRead-=size;
    position+=size;
  }
  m_entryOffset+=totalRead;
  return totalRead;
}",0.9992197659297788
64303,"/** 
 * Copies the contents of the current tar archive entry directly into an output stream.
 * @param out The OutputStream into which to write the entry's data.
 * @exception IOException Description of Exception
 */
public void copyEntryContents(final OutputStream output) throws IOException {
  final byte[] buffer=new byte[32 * 1024];
  while (true) {
    final int numRead=read(buffer,0,buffer.length);
    if (numRead == -1) {
      break;
    }
    output.write(buffer,0,numRead);
  }
}","/** 
 * Copies the contents of the current tar archive entry directly into an output stream.
 * @param output The OutputStream into which to write the entry's data.
 * @exception IOException Description of Exception
 */
public void copyEntryContents(final OutputStream output) throws IOException {
  final byte[] buffer=new byte[32 * 1024];
  while (true) {
    final int numRead=read(buffer,0,buffer.length);
    if (numRead == -1) {
      break;
    }
    output.write(buffer,0,numRead);
  }
}",0.9969604863221884
64304,"public TarOutputStream(final OutputStream output,final int blockSize,final int recordSize){
  super(output);
  m_buffer=new TarBuffer(output,blockSize,recordSize);
  m_debug=false;
  m_assemLen=0;
  m_assemBuf=new byte[recordSize];
  m_recordBuf=new byte[recordSize];
  m_oneBuf=new byte[1];
}","public TarOutputStream(final OutputStream output,final int blockSize,final int recordSize){
  super(output);
  m_buffer=new TarBuffer(output,blockSize,recordSize);
  m_assemLen=0;
  m_assemBuf=new byte[recordSize];
  m_recordBuf=new byte[recordSize];
  m_oneBuf=new byte[1];
}",0.9701230228471002
64305,"/** 
 * Resets the buffer for the current thread.
 */
private void resetBufferInfo(){
  Thread current=Thread.currentThread();
  buffers.remove(current);
}","/** 
 * Resets the buffer for the current thread.
 */
private void resetBufferInfo(){
  Thread current=Thread.currentThread();
  BufferInfo bufferInfo=(BufferInfo)buffers.get(current);
  try {
    bufferInfo.buffer.close();
  }
 catch (  IOException e) {
  }
  bufferInfo.buffer=new ByteArrayOutputStream();
  bufferInfo.skip=false;
}",0.5439672801635992
64306,"/** 
 * Equivalent to flushing the stream.
 * @exception IOException if there is a problem closing the stream.
 * @see #flush
 */
public void close() throws IOException {
  flush();
}","/** 
 * Equivalent to flushing the stream.
 * @exception IOException if there is a problem closing the stream.
 * @see #flush
 */
public void close() throws IOException {
  flush();
  removeBuffer();
}",0.953125
64307,"/** 
 * Set the path to zip-file.
 * @param s Path to zip-file.
 */
public void setSrc(final File src){
  m_src=src;
}","/** 
 * Set the path to zip-file.
 * @param src Path to zip-file.
 */
public void setSrc(final File src){
  m_src=src;
}",0.9915966386554622
64308,"/** 
 * Should we overwrite files in dest, even if they are newer than the corresponding entries in the archive?
 * @param b The new Overwrite value
 */
public void setOverwrite(final boolean overwrite){
  m_overwrite=overwrite;
}","/** 
 * Should we overwrite files in dest, even if they are newer than the corresponding entries in the archive?
 * @param overwrite The new Overwrite value
 */
public void setOverwrite(final boolean overwrite){
  m_overwrite=overwrite;
}",0.9786324786324786
64309,"/** 
 * Set the path to zip-file.
 * @param s Path to zip-file.
 */
public void setSrc(final File src){
  m_src=src;
}","/** 
 * Set the path to zip-file.
 * @param src Path to zip-file.
 */
public void setSrc(final File src){
  m_src=src;
}",0.9915966386554622
64310,"/** 
 * Should we overwrite files in dest, even if they are newer than the corresponding entries in the archive?
 * @param b The new Overwrite value
 */
public void setOverwrite(final boolean overwrite){
  m_overwrite=overwrite;
}","/** 
 * Should we overwrite files in dest, even if they are newer than the corresponding entries in the archive?
 * @param overwrite The new Overwrite value
 */
public void setOverwrite(final boolean overwrite){
  m_overwrite=overwrite;
}",0.9786324786324786
64311,"/** 
 * Executes the task.
 */
public void execute() throws BuildException {
  if ((sourceFileSets.size() == 0) && (sourceFileLists.size() == 0)) {
    throw new BuildException(""String_Node_Str"");
  }
  if ((targetFileSets.size() == 0) && (targetFileLists.size() == 0)) {
    throw new BuildException(""String_Node_Str"");
  }
  long now=(new Date()).getTime();
  if (Os.isFamily(""String_Node_Str"")) {
    now+=2000;
  }
  Vector allTargets=new Vector();
  long oldestTargetTime=0;
  File oldestTarget=null;
  Enumeration enumTargetSets=targetFileSets.elements();
  while (enumTargetSets.hasMoreElements()) {
    FileSet targetFS=(FileSet)enumTargetSets.nextElement();
    DirectoryScanner targetDS=targetFS.getDirectoryScanner(project);
    String[] targetFiles=targetDS.getIncludedFiles();
    for (int i=0; i < targetFiles.length; i++) {
      File dest=new File(targetFS.getDir(project),targetFiles[i]);
      allTargets.addElement(dest);
      if (dest.lastModified() > now) {
        log(""String_Node_Str"" + targetFiles[i] + ""String_Node_Str"",Project.MSG_WARN);
      }
      if (oldestTarget == null || dest.lastModified() < oldestTargetTime) {
        oldestTargetTime=dest.lastModified();
        oldestTarget=dest;
      }
    }
  }
  boolean upToDate=true;
  Enumeration enumTargetLists=targetFileLists.elements();
  while (enumTargetLists.hasMoreElements()) {
    FileList targetFL=(FileList)enumTargetLists.nextElement();
    String[] targetFiles=targetFL.getFiles(project);
    for (int i=0; i < targetFiles.length; i++) {
      File dest=new File(targetFL.getDir(project),targetFiles[i]);
      if (!dest.exists()) {
        log(targetFiles[i] + ""String_Node_Str"",Project.MSG_VERBOSE);
        upToDate=false;
        continue;
      }
 else {
        allTargets.addElement(dest);
      }
      if (dest.lastModified() > now) {
        log(""String_Node_Str"" + targetFiles[i] + ""String_Node_Str"",Project.MSG_WARN);
      }
      if (oldestTarget == null || dest.lastModified() < oldestTargetTime) {
        oldestTargetTime=dest.lastModified();
        oldestTarget=dest;
      }
    }
  }
  if (oldestTarget != null) {
    log(oldestTarget + ""String_Node_Str"",Project.MSG_VERBOSE);
  }
 else {
    upToDate=false;
  }
  if (upToDate) {
    Enumeration enumSourceLists=sourceFileLists.elements();
    while (upToDate && enumSourceLists.hasMoreElements()) {
      FileList sourceFL=(FileList)enumSourceLists.nextElement();
      String[] sourceFiles=sourceFL.getFiles(project);
      int i=0;
      do {
        File src=new File(sourceFL.getDir(project),sourceFiles[i]);
        if (src.lastModified() > now) {
          log(""String_Node_Str"" + sourceFiles[i] + ""String_Node_Str"",Project.MSG_WARN);
        }
        if (!src.exists()) {
          log(sourceFiles[i] + ""String_Node_Str"",Project.MSG_VERBOSE);
          upToDate=false;
          break;
        }
        if (src.lastModified() > oldestTargetTime) {
          upToDate=false;
          log(oldestTarget + ""String_Node_Str"" + sourceFiles[i],Project.MSG_VERBOSE);
        }
      }
 while (upToDate && (++i < sourceFiles.length));
    }
  }
  if (upToDate) {
    Enumeration enumSourceSets=sourceFileSets.elements();
    while (upToDate && enumSourceSets.hasMoreElements()) {
      FileSet sourceFS=(FileSet)enumSourceSets.nextElement();
      DirectoryScanner sourceDS=sourceFS.getDirectoryScanner(project);
      String[] sourceFiles=sourceDS.getIncludedFiles();
      for (int i=0; upToDate && i < sourceFiles.length; i++) {
        File src=new File(sourceFS.getDir(project),sourceFiles[i]);
        if (src.lastModified() > now) {
          log(""String_Node_Str"" + sourceFiles[i] + ""String_Node_Str"",Project.MSG_WARN);
        }
        if (src.lastModified() > oldestTargetTime) {
          upToDate=false;
          log(oldestTarget + ""String_Node_Str"" + sourceFiles[i],Project.MSG_VERBOSE);
        }
      }
    }
  }
  if (!upToDate) {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    for (Enumeration e=allTargets.elements(); e.hasMoreElements(); ) {
      File fileToRemove=(File)e.nextElement();
      log(""String_Node_Str"" + fileToRemove.getAbsolutePath(),Project.MSG_VERBOSE);
      fileToRemove.delete();
    }
  }
}","/** 
 * Executes the task.
 */
public void execute() throws BuildException {
  if ((sourceFileSets.size() == 0) && (sourceFileLists.size() == 0)) {
    throw new BuildException(""String_Node_Str"");
  }
  if ((targetFileSets.size() == 0) && (targetFileLists.size() == 0)) {
    throw new BuildException(""String_Node_Str"");
  }
  long now=(new Date()).getTime();
  if (Os.isFamily(""String_Node_Str"")) {
    now+=2000;
  }
  Vector allTargets=new Vector();
  long oldestTargetTime=0;
  File oldestTarget=null;
  Enumeration enumTargetSets=targetFileSets.elements();
  while (enumTargetSets.hasMoreElements()) {
    FileSet targetFS=(FileSet)enumTargetSets.nextElement();
    DirectoryScanner targetDS=targetFS.getDirectoryScanner(project);
    String[] targetFiles=targetDS.getIncludedFiles();
    for (int i=0; i < targetFiles.length; i++) {
      File dest=new File(targetFS.getDir(project),targetFiles[i]);
      allTargets.addElement(dest);
      if (dest.lastModified() > now) {
        log(""String_Node_Str"" + targetFiles[i] + ""String_Node_Str"",Project.MSG_WARN);
      }
      if (oldestTarget == null || dest.lastModified() < oldestTargetTime) {
        oldestTargetTime=dest.lastModified();
        oldestTarget=dest;
      }
    }
  }
  boolean upToDate=true;
  Enumeration enumTargetLists=targetFileLists.elements();
  while (enumTargetLists.hasMoreElements()) {
    FileList targetFL=(FileList)enumTargetLists.nextElement();
    String[] targetFiles=targetFL.getFiles(project);
    for (int i=0; i < targetFiles.length; i++) {
      File dest=new File(targetFL.getDir(project),targetFiles[i]);
      if (!dest.exists()) {
        log(targetFiles[i] + ""String_Node_Str"",Project.MSG_VERBOSE);
        upToDate=false;
        continue;
      }
 else {
        allTargets.addElement(dest);
      }
      if (dest.lastModified() > now) {
        log(""String_Node_Str"" + targetFiles[i] + ""String_Node_Str"",Project.MSG_WARN);
      }
      if (oldestTarget == null || dest.lastModified() < oldestTargetTime) {
        oldestTargetTime=dest.lastModified();
        oldestTarget=dest;
      }
    }
  }
  if (oldestTarget != null) {
    log(oldestTarget + ""String_Node_Str"",Project.MSG_VERBOSE);
  }
 else {
    upToDate=false;
  }
  if (upToDate) {
    Enumeration enumSourceLists=sourceFileLists.elements();
    while (upToDate && enumSourceLists.hasMoreElements()) {
      FileList sourceFL=(FileList)enumSourceLists.nextElement();
      String[] sourceFiles=sourceFL.getFiles(project);
      for (int i=0; upToDate && i < sourceFiles.length; i++) {
        File src=new File(sourceFL.getDir(project),sourceFiles[i]);
        if (src.lastModified() > now) {
          log(""String_Node_Str"" + sourceFiles[i] + ""String_Node_Str"",Project.MSG_WARN);
        }
        if (!src.exists()) {
          log(sourceFiles[i] + ""String_Node_Str"",Project.MSG_VERBOSE);
          upToDate=false;
          break;
        }
        if (src.lastModified() > oldestTargetTime) {
          upToDate=false;
          log(oldestTarget + ""String_Node_Str"" + sourceFiles[i],Project.MSG_VERBOSE);
        }
      }
    }
  }
  if (upToDate) {
    Enumeration enumSourceSets=sourceFileSets.elements();
    while (upToDate && enumSourceSets.hasMoreElements()) {
      FileSet sourceFS=(FileSet)enumSourceSets.nextElement();
      DirectoryScanner sourceDS=sourceFS.getDirectoryScanner(project);
      String[] sourceFiles=sourceDS.getIncludedFiles();
      for (int i=0; upToDate && i < sourceFiles.length; i++) {
        File src=new File(sourceFS.getDir(project),sourceFiles[i]);
        if (src.lastModified() > now) {
          log(""String_Node_Str"" + sourceFiles[i] + ""String_Node_Str"",Project.MSG_WARN);
        }
        if (src.lastModified() > oldestTargetTime) {
          upToDate=false;
          log(oldestTarget + ""String_Node_Str"" + sourceFiles[i],Project.MSG_VERBOSE);
        }
      }
    }
  }
  if (!upToDate) {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    for (Enumeration e=allTargets.elements(); e.hasMoreElements(); ) {
      File fileToRemove=(File)e.nextElement();
      log(""String_Node_Str"" + fileToRemove.getAbsolutePath(),Project.MSG_VERBOSE);
      fileToRemove.delete();
    }
  }
}",0.9876308277830638
64312,"/** 
 * Runs a process defined by the command line and returns its exit status.
 * @return the exit status of the subprocess or <code>INVALID</code>
 * @exception java.io.IOExcpetion The exception is thrown, if launchingof the subprocess failed
 */
public int execute() throws IOException {
  CommandLauncher launcher=vmLauncher != null ? vmLauncher : shellLauncher;
  if (!useVMLauncher) {
    launcher=shellLauncher;
  }
  final Process process=launcher.exec(project,getCommandline(),getEnvironment(),workingDirectory);
  try {
    streamHandler.setProcessInputStream(process.getOutputStream());
    streamHandler.setProcessOutputStream(process.getInputStream());
    streamHandler.setProcessErrorStream(process.getErrorStream());
  }
 catch (  IOException e) {
    process.destroy();
    throw e;
  }
  streamHandler.start();
  processDestroyer.add(process);
  if (watchdog != null) {
    watchdog.start(process);
  }
  waitFor(process);
  processDestroyer.remove(process);
  if (watchdog != null) {
    watchdog.stop();
  }
  streamHandler.stop();
  if (watchdog != null) {
    watchdog.checkException();
  }
  return getExitValue();
}","/** 
 * Runs a process defined by the command line and returns its exit status.
 * @return the exit status of the subprocess or <code>INVALID</code>
 * @exception java.io.IOExcpetion The exception is thrown, if launchingof the subprocess failed
 */
public int execute() throws IOException {
  final Process process=launch(project,getCommandline(),getEnvironment(),workingDirectory,useVMLauncher);
  try {
    streamHandler.setProcessInputStream(process.getOutputStream());
    streamHandler.setProcessOutputStream(process.getInputStream());
    streamHandler.setProcessErrorStream(process.getErrorStream());
  }
 catch (  IOException e) {
    process.destroy();
    throw e;
  }
  streamHandler.start();
  processDestroyer.add(process);
  if (watchdog != null) {
    watchdog.start(process);
  }
  waitFor(process);
  processDestroyer.remove(process);
  if (watchdog != null) {
    watchdog.stop();
  }
  streamHandler.stop();
  if (watchdog != null) {
    watchdog.checkException();
  }
  return getExitValue();
}",0.8676265675801208
64313,"/** 
 * Copies data from the input stream to the output stream. Terminates as soon as the input stream is closed or an error occurs.
 */
public void run(){
  final byte[] buf=new byte[SIZE];
  int length;
  try {
    while ((length=is.read(buf)) > 0) {
      os.write(buf,0,length);
      try {
        Thread.sleep(SLEEP);
      }
 catch (      InterruptedException e) {
      }
    }
  }
 catch (  IOException e) {
  }
}","/** 
 * Copies data from the input stream to the output stream. Terminates as soon as the input stream is closed or an error occurs.
 */
public void run(){
synchronized (this) {
    finished=false;
  }
  final byte[] buf=new byte[SIZE];
  int length;
  try {
    while ((length=is.read(buf)) > 0) {
      os.write(buf,0,length);
      try {
        Thread.sleep(SLEEP);
      }
 catch (      InterruptedException e) {
      }
    }
  }
 catch (  IOException e) {
  }
 finally {
synchronized (this) {
      finished=true;
      notify();
    }
  }
}",0.8680412371134021
64314,"public void execute() throws BuildException {
  checkConfiguration();
  Vector files=getFileList();
  if (isUpToDate(files)) {
    return;
  }
  log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ cabFile.getAbsolutePath());
  if (!Os.isFamily(""String_Node_Str"")) {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    StringBuffer sb=new StringBuffer();
    Enumeration fileEnum=files.elements();
    while (fileEnum.hasMoreElements()) {
      sb.append(fileEnum.nextElement()).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"").append(cabFile.getAbsolutePath()).append(""String_Node_Str"");
    try {
      Process p=Runtime.getRuntime().exec(""String_Node_Str"");
      OutputStream out=p.getOutputStream();
      out.write(sb.toString().getBytes());
      out.flush();
      out.close();
    }
 catch (    IOException ex) {
      String msg=""String_Node_Str"" + cabFile + ""String_Node_Str""+ ex.getMessage();
      throw new BuildException(msg);
    }
  }
 else {
    try {
      File listFile=createListFile(files);
      ExecTask exec=createExec();
      File outFile=null;
      exec.setFailonerror(true);
      exec.setDir(baseDir);
      if (!doVerbose) {
        outFile=fileUtils.createTempFile(""String_Node_Str"",""String_Node_Str"",null);
        exec.setOutput(outFile);
      }
      exec.setCommand(createCommand(listFile));
      exec.execute();
      if (outFile != null) {
        outFile.delete();
      }
      listFile.delete();
    }
 catch (    IOException ioe) {
      String msg=""String_Node_Str"" + cabFile + ""String_Node_Str""+ ioe.getMessage();
      throw new BuildException(msg);
    }
  }
}","public void execute() throws BuildException {
  checkConfiguration();
  Vector files=getFileList();
  if (isUpToDate(files)) {
    return;
  }
  log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ cabFile.getAbsolutePath());
  if (!Os.isFamily(""String_Node_Str"")) {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    StringBuffer sb=new StringBuffer();
    Enumeration fileEnum=files.elements();
    while (fileEnum.hasMoreElements()) {
      sb.append(fileEnum.nextElement()).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"").append(cabFile.getAbsolutePath()).append(""String_Node_Str"");
    try {
      Process p=Execute.launch(getProject(),new String[]{""String_Node_Str""},null,baseDir,true);
      OutputStream out=p.getOutputStream();
      out.write(sb.toString().getBytes());
      out.flush();
      out.close();
      LogOutputStream outLog=new LogOutputStream(this,Project.MSG_VERBOSE);
      LogOutputStream errLog=new LogOutputStream(this,Project.MSG_ERR);
      StreamPumper outPump=new StreamPumper(p.getInputStream(),outLog);
      StreamPumper errPump=new StreamPumper(p.getErrorStream(),errLog);
      (new Thread(outPump)).start();
      (new Thread(errPump)).start();
      int result=-99;
      try {
        result=p.waitFor();
        outPump.waitFor();
        outLog.close();
        errPump.waitFor();
        errLog.close();
      }
 catch (      InterruptedException ie) {
        log(""String_Node_Str"" + ie);
      }
      if (result != 0) {
        log(""String_Node_Str"" + result);
      }
    }
 catch (    IOException ex) {
      String msg=""String_Node_Str"" + cabFile + ""String_Node_Str""+ ex.getMessage();
      throw new BuildException(msg);
    }
  }
 else {
    try {
      File listFile=createListFile(files);
      ExecTask exec=createExec();
      File outFile=null;
      exec.setFailonerror(true);
      exec.setDir(baseDir);
      if (!doVerbose) {
        outFile=fileUtils.createTempFile(""String_Node_Str"",""String_Node_Str"",null);
        exec.setOutput(outFile);
      }
      exec.setCommand(createCommand(listFile));
      exec.execute();
      if (outFile != null) {
        outFile.delete();
      }
      listFile.delete();
    }
 catch (    IOException ioe) {
      String msg=""String_Node_Str"" + cabFile + ""String_Node_Str""+ ioe.getMessage();
      throw new BuildException(msg);
    }
  }
}",0.8051102204408818
64315,"public boolean execute() throws TaskException {
  getLogger().debug(""String_Node_Str"");
  Commandline cmd=setupRmicCommand();
  try {
    Class c=Class.forName(""String_Node_Str"");
    Constructor cons=c.getConstructor(new Class[]{OutputStream.class,String.class});
    Object rmic=cons.newInstance(new Object[]{System.out,""String_Node_Str""});
    Method doRmic=c.getMethod(""String_Node_Str"",new Class[]{String[].class});
    Boolean ok=(Boolean)doRmic.invoke(rmic,(new Object[]{cmd.getArguments()}));
    return ok.booleanValue();
  }
 catch (  ClassNotFoundException ex) {
    throw new TaskException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  Exception ex) {
    if (ex instanceof TaskException) {
      throw (TaskException)ex;
    }
 else {
      throw new TaskException(""String_Node_Str"",ex);
    }
  }
 finally {
    try {
      logstr.close();
    }
 catch (    IOException e) {
      throw new TaskException(""String_Node_Str"",e);
    }
  }
}","public boolean execute() throws TaskException {
  getLogger().debug(""String_Node_Str"");
  Commandline cmd=setupRmicCommand();
  try {
    Class c=Class.forName(""String_Node_Str"");
    Constructor cons=c.getConstructor(new Class[]{OutputStream.class,String.class});
    Object rmic=cons.newInstance(new Object[]{System.out,""String_Node_Str""});
    Method doRmic=c.getMethod(""String_Node_Str"",new Class[]{String[].class});
    Boolean ok=(Boolean)doRmic.invoke(rmic,(new Object[]{cmd.getArguments()}));
    return ok.booleanValue();
  }
 catch (  ClassNotFoundException ex) {
    throw new TaskException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  Exception ex) {
    if (ex instanceof TaskException) {
      throw (TaskException)ex;
    }
 else {
      throw new TaskException(""String_Node_Str"",ex);
    }
  }
}",0.921892189218922
64316,"public boolean execute() throws TaskException {
  getLogger().debug(""String_Node_Str"");
  Commandline cmd=setupRmicCommand();
  try {
    Class c=Class.forName(""String_Node_Str"");
    Constructor cons=c.getConstructor(new Class[]{OutputStream.class,String.class});
    Object rmic=cons.newInstance(new Object[]{System.out,""String_Node_Str""});
    Method doRmic=c.getMethod(""String_Node_Str"",new Class[]{String[].class});
    Boolean ok=(Boolean)doRmic.invoke(rmic,(new Object[]{cmd.getArguments()}));
    return ok.booleanValue();
  }
 catch (  ClassNotFoundException ex) {
    throw new TaskException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  Exception ex) {
    if (ex instanceof TaskException) {
      throw (TaskException)ex;
    }
 else {
      throw new TaskException(""String_Node_Str"",ex);
    }
  }
 finally {
    try {
      logstr.close();
    }
 catch (    IOException e) {
      throw new TaskException(""String_Node_Str"",e);
    }
  }
}","public boolean execute() throws TaskException {
  getLogger().debug(""String_Node_Str"");
  Commandline cmd=setupRmicCommand();
  try {
    Class c=Class.forName(""String_Node_Str"");
    Constructor cons=c.getConstructor(new Class[]{OutputStream.class,String.class});
    Object rmic=cons.newInstance(new Object[]{System.out,""String_Node_Str""});
    Method doRmic=c.getMethod(""String_Node_Str"",new Class[]{String[].class});
    Boolean ok=(Boolean)doRmic.invoke(rmic,(new Object[]{cmd.getArguments()}));
    return ok.booleanValue();
  }
 catch (  ClassNotFoundException ex) {
    throw new TaskException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  Exception ex) {
    if (ex instanceof TaskException) {
      throw (TaskException)ex;
    }
 else {
      throw new TaskException(""String_Node_Str"",ex);
    }
  }
}",0.921892189218922
64317,"/** 
 * Method to execute a particular target instance.
 * @param targetName the name of target
 * @param target the target
 * @param context the context in which to execute
 * @exception TaskException if an error occurs
 */
private void executeTarget(final String name,final Target target,final ExecutionFrame frame) throws TaskException {
  final Condition condition=target.getCondition();
  if (null != condition) {
    try {
      final boolean result=condition.evaluate(frame.getContext());
      if (!result) {
        final String message=REZ.getString(""String_Node_Str"",name);
        getLogger().debug(message);
        return;
      }
    }
 catch (    final TaskException te) {
      final String message=REZ.getString(""String_Node_Str"",name);
      throw new TaskException(message,te);
    }
  }
  final String message=REZ.getString(""String_Node_Str"",name);
  getLogger().debug(message);
  final Configuration[] tasks=target.getTasks();
  for (int i=0; i < tasks.length; i++) {
    executeTask(tasks[i],frame);
  }
}","/** 
 * Method to execute a particular target instance.
 * @param name the name of target
 * @param target the target
 * @param frame the frame in which to execute
 * @exception TaskException if an error occurs
 */
private void executeTarget(final String name,final Target target,final ExecutionFrame frame) throws TaskException {
  final Condition condition=target.getCondition();
  if (null != condition) {
    try {
      final boolean result=condition.evaluate(frame.getContext());
      if (!result) {
        final String message=REZ.getString(""String_Node_Str"",name);
        getLogger().debug(message);
        return;
      }
    }
 catch (    final TaskException te) {
      final String message=REZ.getString(""String_Node_Str"",name);
      throw new TaskException(message,te);
    }
  }
  final String message=REZ.getString(""String_Node_Str"",name);
  getLogger().debug(message);
  final Configuration[] tasks=target.getTasks();
  for (int i=0; i < tasks.length; i++) {
    executeTask(tasks[i],frame);
  }
}",0.9843597262952102
64318,"/** 
 * Execute a task.
 * @param task the task definition
 * @param context the context
 * @exception TaskException if an error occurs
 */
private void executeTask(final Configuration task,final ExecutionFrame frame) throws TaskException {
  final String name=task.getName();
  final String message=REZ.getString(""String_Node_Str"",name);
  getLogger().debug(message);
  frame.getContext().setProperty(TaskContext.NAME,name);
  m_listenerSupport.taskStarted(name);
  m_executor.execute(task,frame);
  m_listenerSupport.taskFinished();
}","/** 
 * Execute a task.
 * @param task the task definition
 * @param frame the frame to execute in
 * @exception TaskException if an error occurs
 */
private void executeTask(final Configuration task,final ExecutionFrame frame) throws TaskException {
  final String name=task.getName();
  final String message=REZ.getString(""String_Node_Str"",name);
  getLogger().debug(message);
  frame.getContext().setProperty(TaskContext.NAME,name);
  m_listenerSupport.taskStarted(name);
  m_executor.execute(task,frame);
  m_listenerSupport.taskFinished();
}",0.9648798521256932
64319,"private void deployTypeLib(final Deployer deployer,final Project project) throws TaskException {
  final TypeLib[] typeLibs=project.getTypeLibs();
  for (int i=0; i < typeLibs.length; i++) {
    final TypeLib typeLib=typeLibs[i];
    final File file=findTypeLib(typeLib.getLibrary());
    try {
      final TypeDeployer typeDeployer=deployer.createDeployer(file);
      if (null == typeLib.getRole()) {
        typeDeployer.deployAll();
      }
 else {
        typeDeployer.deployType(typeLib.getRole(),typeLib.getName());
      }
    }
 catch (    final DeploymentException de) {
      final String message=REZ.getString(""String_Node_Str"",typeLib,file);
      throw new TaskException(message,de);
    }
  }
}","private void deployTypeLib(final Deployer deployer,final Project project) throws TaskException {
  final TypeLib[] typeLibs=project.getTypeLibs();
  for (int i=0; i < typeLibs.length; i++) {
    final TypeLib typeLib=typeLibs[i];
    final File file=findTypeLib(typeLib.getLibrary());
    try {
      final TypeDeployer typeDeployer=deployer.createDeployer(file);
      if (null == typeLib.getRole()) {
        typeDeployer.deployAll();
      }
 else {
        typeDeployer.deployType(typeLib.getRole(),typeLib.getName());
      }
    }
 catch (    final DeploymentException de) {
      final String message=REZ.getString(""String_Node_Str"",typeLib.getLibrary(),file);
      throw new TaskException(message,de);
    }
  }
}",0.9909154437456325
64320,"/** 
 * Helper method to execute a target.
 * @param project the Project
 * @param target the name of the target
 * @param context the context
 * @param done the list of targets already executed in current run
 * @exception TaskException if an error occurs
 */
private void execute(final Project project,final String targetName,final ProjectEntry entry) throws TaskException {
  final int index=targetName.indexOf(""String_Node_Str"");
  if (-1 != index) {
    final String name=targetName.substring(0,index);
    final String otherTargetName=targetName.substring(index + 2);
    final Project otherProject=getProject(name,project);
    final ProjectEntry otherEntry=getProjectEntry(otherProject);
    execute(otherProject,otherTargetName,otherEntry);
    return;
  }
  final Target target=project.getTarget(targetName);
  if (null == target) {
    final String message=REZ.getString(""String_Node_Str"",targetName);
    throw new TaskException(message);
  }
  entry.completeTarget(targetName);
  final String[] dependencies=target.getDependencies();
  for (int i=0; i < dependencies.length; i++) {
    if (!entry.isTargetCompleted(dependencies[i])) {
      execute(project,dependencies[i],entry);
    }
  }
  m_listenerSupport.targetStarted(targetName);
  executeTarget(targetName,target,entry.getFrame());
  m_listenerSupport.targetFinished();
}","/** 
 * Helper method to execute a target.
 * @param project the Project
 * @param targetName the name of the target
 * @param entry the context
 * @exception TaskException if an error occurs
 */
private void execute(final Project project,final String targetName,final ProjectEntry entry) throws TaskException {
  final int index=targetName.indexOf(""String_Node_Str"");
  if (-1 != index) {
    final String name=targetName.substring(0,index);
    final String otherTargetName=targetName.substring(index + 2);
    final Project otherProject=getProject(name,project);
    final ProjectEntry otherEntry=getProjectEntry(otherProject);
    execute(otherProject,otherTargetName,otherEntry);
    return;
  }
  final Target target=project.getTarget(targetName);
  if (null == target) {
    final String message=REZ.getString(""String_Node_Str"",targetName);
    throw new TaskException(message);
  }
  entry.completeTarget(targetName);
  final String[] dependencies=target.getDependencies();
  for (int i=0; i < dependencies.length; i++) {
    if (!entry.isTargetCompleted(dependencies[i])) {
      execute(project,dependencies[i],entry);
    }
  }
  m_listenerSupport.targetStarted(targetName);
  executeTarget(targetName,target,entry.getFrame());
  m_listenerSupport.targetFinished();
}",0.9607020221289584
64321,"/** 
 * Run the sub-build
 * @exception ExecutionException if the build can't be run
 */
public void execute() throws ExecutionException {
  if (baseDir == null) {
    baseDir=getContext().getBaseDir();
  }
  if (antFile == null) {
    antFile=new File(baseDir,""String_Node_Str"");
  }
  ComponentService componentService=(ComponentService)getCoreService(ComponentService.class);
  componentService.runBuild(antFile,getProperties(),getTargets());
}","/** 
 * Run the sub-build
 * @exception ExecutionException if the build can't be run
 */
public void execute() throws ExecutionException {
  if (baseDir == null) {
    baseDir=getContext().getBaseDir();
  }
  if (antFile == null) {
    antFile=new File(baseDir,""String_Node_Str"");
    if (!antFile.exists()) {
      antFile=new File(baseDir,""String_Node_Str"");
    }
  }
  ComponentService componentService=(ComponentService)getCoreService(ComponentService.class);
  componentService.runBuild(antFile,getProperties(),getTargets());
}",0.9122448979591836
64322,"/** 
 * @return all collected tests specified with test elements.
 */
protected Enumeration collectTests(){
  Enumeration[] tests=new Enumeration[testCollectors.size()];
  for (int i=0; i < testCollectors.size(); i++) {
    TestCollector te=(TestCollector)testCollectors.elementAt(i);
    tests[i]=te.collectTests();
  }
  return Enumerations.fromCompound(tests);
}","/** 
 * @return all collected tests specified with test elements.
 */
protected Enumeration collectTests(){
  Enumeration[] tests=new Enumeration[testCollectors.size()];
  for (int i=0; i < testCollectors.size(); i++) {
    TestCollector te=(TestCollector)testCollectors.elementAt(i);
    tests[i]=te.collectTests();
  }
  return new CompoundEnumeration(tests);
}",0.9642857142857144
64323,"/** 
 * create the Formatter corresponding to this element.
 */
protected Formatter createFormatter() throws BuildException {
  if (classname == null) {
    throw new BuildException(""String_Node_Str"");
  }
  Formatter f=null;
  try {
    Class clazz=Class.forName(classname);
    if (!Formatter.class.isAssignableFrom(clazz)) {
      throw new BuildException(clazz + ""String_Node_Str"");
    }
    f=(Formatter)clazz.newInstance();
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Exception e) {
    throw new BuildException(e);
  }
  for (int i=filters.size() - 1; i >= 0; i--) {
    FilterElement fe=(FilterElement)filters.elementAt(i);
    f=fe.createFilterFormatter(f);
  }
  f.init(params);
  return f;
}","/** 
 * create the Formatter corresponding to this element.
 */
protected Formatter createFormatter() throws BuildException {
  if (classname == null) {
    throw new BuildException(""String_Node_Str"");
  }
  Formatter f=null;
  try {
    Class clazz=Class.forName(classname);
    if (!Formatter.class.isAssignableFrom(clazz)) {
      throw new BuildException(clazz + ""String_Node_Str"");
    }
    f=(Formatter)clazz.newInstance();
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Exception e) {
    throw new BuildException(e);
  }
  for (int i=filters.size() - 1; i >= 0; i--) {
    FilterElement fe=(FilterElement)filters.elementAt(i);
    f=fe.createFilterFormatter(f);
  }
  Properties props=new Properties();
  for (int i=0; i < params.size(); i++) {
    Parameter param=(Parameter)params.elementAt(i);
    props.put(param.getName(),param.getValue());
  }
  f.init(props);
  return f;
}",0.8537939543491672
64324,"/** 
 * Add a parameter that can be used for configuration.
 */
public void addParam(Parameter param){
  params.setProperty(param.getName(),param.getValue());
}","/** 
 * Add a parameter that can be used for configuration.
 */
public void addParam(Parameter param){
  params.addElement(param);
}",0.8493150684931506
64325,"/** 
 * add a new formatter element 
 */
public void addFormatter(FormatterElement fe){
  Formatter f=fe.createFormatter();
  formatters.addElement(f);
}","/** 
 * add a new formatter element 
 */
public void addFormatter(FormatterElement fe){
  formatterElements.addElement(fe);
}",0.841726618705036
64326,"/** 
 * start the server and block until client has finished 
 */
public void execute() throws BuildException {
  Server server=new Server(port);
  Enumeration listeners=formatters.elements();
  while (listeners.hasMoreElements()) {
    server.addListener((TestRunListener)listeners.nextElement());
  }
  server.start();
}","/** 
 * start the server and block until client has finished 
 */
public void execute() throws BuildException {
  Server server=new Server(port);
  Enumeration listeners=formatterElements.elements();
  while (listeners.hasMoreElements()) {
    FormatterElement fe=(FormatterElement)listeners.nextElement();
    Formatter formatter=fe.createFormatter();
    server.addListener(formatter);
  }
  server.start();
}",0.7694406548431105
64327,"public Enumeration collectTests(){
  return Enumerations.fromArray(new String[]{name});
}","public Enumeration collectTests(){
  return new ArrayEnumeration(new String[]{name});
}",0.8863636363636364
64328,"/** 
 * Set the source dir to find the files to be compiled
 * @param srcDirName  The new SrcDir value 
 */
public void setSrcDir(File srcDirName){
}","/** 
 * Set the source dir to find the files to be compiled
 * @param srcDirName  The new SrcDir value 
 */
public void setSrcDir(File srcDirName){
  _srcDir=srcDirName;
}",0.93125
64329,"protected Hashtable getFiles(){
  if (files == null) {
    return files;
  }
  files=new Hashtable();
  DirectoryScanner ds=getDirectoryScanner(viewpath);
  String[] includes=ds.getIncludedDirectories();
  addElements(files,ds.getBasedir(),includes);
  includes=ds.getIncludedFiles();
  addElements(files,ds.getBasedir(),includes);
  return files;
}","protected Hashtable getFiles(){
  if (files != null) {
    return files;
  }
  files=new Hashtable();
  DirectoryScanner ds=getDirectoryScanner(viewpath);
  String[] includes=ds.getIncludedDirectories();
  addElements(files,ds.getBasedir(),includes);
  includes=ds.getIncludedFiles();
  addElements(files,ds.getBasedir(),includes);
  return files;
}",0.997134670487106
64330,"/** 
 * Interface TestListener. <p>A Test is finished.
 */
public void endTest(Test test){
  Element currentTest=(Element)testElements.get(test);
  Long l=(Long)testStarts.get(test);
  currentTest.setAttribute(ATTR_TIME,""String_Node_Str"" + ((System.currentTimeMillis() - l.longValue()) / 1000.0));
}","/** 
 * Interface TestListener. <p>A Test is finished.
 */
public void endTest(Test test){
  Element currentTest=(Element)testElements.get(test);
  if (currentTest == null) {
    startTest(test);
    currentTest=(Element)testElements.get(test);
  }
  Long l=(Long)testStarts.get(test);
  currentTest.setAttribute(ATTR_TIME,""String_Node_Str"" + ((System.currentTimeMillis() - l.longValue()) / 1000.0));
}",0.8530670470756063
64331,"private final Configuration prepareAspects(final Configuration taskModel) throws TaskException {
  final DefaultConfiguration newTaskModel=new DefaultConfiguration(taskModel.getName(),taskModel.getLocation());
  final HashMap parameterMap=new HashMap();
  final HashMap elementMap=new HashMap();
  processAttributes(taskModel,newTaskModel,parameterMap);
  processElements(taskModel,newTaskModel,elementMap);
  dispatchAspectsSettings(parameterMap,elementMap);
  checkForUnusedSettings(parameterMap,elementMap);
  return newTaskModel;
}","private final Configuration prepareAspects(final Configuration taskModel) throws TaskException {
  final DefaultConfiguration newTaskModel=new DefaultConfiguration(taskModel.getName(),taskModel.getLocation());
  final HashMap parameterMap=new HashMap();
  final HashMap elementMap=new HashMap();
  processAttributes(taskModel,newTaskModel,parameterMap);
  processElements(taskModel,newTaskModel,elementMap);
  try {
    newTaskModel.setValue(taskModel.getValue());
  }
 catch (  final ConfigurationException cee) {
  }
  dispatchAspectsSettings(parameterMap,elementMap);
  checkForUnusedSettings(parameterMap,elementMap);
  return newTaskModel;
}",0.9060118543607112
64332,"public void execute() throws TaskException {
  if (project.getJavaVersion().equals(Project.JAVA_1_1)) {
    throw new TaskException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (null == alias) {
    throw new TaskException(""String_Node_Str"");
  }
  if (null == storepass) {
    throw new TaskException(""String_Node_Str"");
  }
  if (null == dname && null == expandedDname) {
    throw new TaskException(""String_Node_Str"");
  }
  final StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  if (verbose) {
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(alias);
  sb.append(""String_Node_Str"");
  if (null != dname) {
    sb.append(""String_Node_Str"");
    sb.append(dname);
    sb.append(""String_Node_Str"");
  }
  if (null != expandedDname) {
    sb.append(""String_Node_Str"");
    sb.append(expandedDname);
    sb.append(""String_Node_Str"");
  }
  if (null != keystore) {
    sb.append(""String_Node_Str"");
    sb.append(keystore);
    sb.append(""String_Node_Str"");
  }
  if (null != storepass) {
    sb.append(""String_Node_Str"");
    sb.append(storepass);
    sb.append(""String_Node_Str"");
  }
  if (null != storetype) {
    sb.append(""String_Node_Str"");
    sb.append(storetype);
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (null != keypass) {
    sb.append(keypass);
  }
 else {
    sb.append(storepass);
  }
  sb.append(""String_Node_Str"");
  if (null != sigalg) {
    sb.append(""String_Node_Str"");
    sb.append(sigalg);
    sb.append(""String_Node_Str"");
  }
  if (null != keyalg) {
    sb.append(""String_Node_Str"");
    sb.append(keyalg);
    sb.append(""String_Node_Str"");
  }
  if (0 < keysize) {
    sb.append(""String_Node_Str"");
    sb.append(keysize);
    sb.append(""String_Node_Str"");
  }
  if (0 < validity) {
    sb.append(""String_Node_Str"");
    sb.append(validity);
    sb.append(""String_Node_Str"");
  }
  log(""String_Node_Str"" + alias);
  final ExecTask cmd=(ExecTask)project.createTask(""String_Node_Str"");
  cmd.setCommand(new Commandline(sb.toString()));
  cmd.setFailonerror(true);
  cmd.execute();
}","public void execute() throws TaskException {
  if (project.getJavaVersion().equals(Project.JAVA_1_1)) {
    throw new TaskException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (null == alias) {
    throw new TaskException(""String_Node_Str"");
  }
  if (null == storepass) {
    throw new TaskException(""String_Node_Str"");
  }
  if (null == dname && null == expandedDname) {
    throw new TaskException(""String_Node_Str"");
  }
  log(""String_Node_Str"" + alias);
  final ExecTask cmd=(ExecTask)project.createTask(""String_Node_Str"");
  cmd.setExecutable(""String_Node_Str"");
  cmd.createArg().setValue(""String_Node_Str"");
  if (verbose) {
    cmd.createArg().setValue(""String_Node_Str"");
  }
  cmd.createArg().setValue(""String_Node_Str"");
  cmd.createArg().setValue(alias);
  if (null != dname) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(dname);
  }
  if (null != expandedDname) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(expandedDname.toString());
  }
  if (null != keystore) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(keystore);
  }
  if (null != storepass) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(storepass);
  }
  if (null != storetype) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(storetype);
  }
  cmd.createArg().setValue(""String_Node_Str"");
  if (null != keypass) {
    cmd.createArg().setValue(keypass);
  }
 else {
    cmd.createArg().setValue(storepass);
  }
  if (null != sigalg) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(sigalg);
  }
  if (null != keyalg) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(keyalg);
  }
  if (0 < keysize) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(""String_Node_Str"" + keysize);
  }
  if (0 < validity) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(""String_Node_Str"" + validity);
  }
  cmd.setFailonerror(true);
  cmd.execute();
}",0.4594852240228789
64333,"/** 
 * Move the generated source file(s) to the base directory
 * @param baseDir Description of Parameter
 * @param sourceBaseFile Description of Parameter
 * @param classname Description of Parameter
 * @param adapter Description of Parameter
 * @exception TaskException Description of Exception
 */
private void moveGeneratedFile(File baseDir,File sourceBaseFile,String classname,RmicAdapter adapter) throws TaskException {
  String classFileName=classname.replace('.',File.separatorChar) + ""String_Node_Str"";
  String[] generatedFiles=adapter.getMapper().mapFileName(classFileName);
  for (int i=0; i < generatedFiles.length; i++) {
    String sourceFileName=classFileName.substring(0,classFileName.length() - 6) + ""String_Node_Str"";
    File oldFile=new File(baseDir,sourceFileName);
    File newFile=new File(sourceBaseFile,sourceFileName);
    try {
      FileUtils.newFileUtils().copyFile(oldFile,newFile,filtering);
      oldFile.delete();
    }
 catch (    IOException ioe) {
      String msg=""String_Node_Str"" + oldFile + ""String_Node_Str""+ newFile+ ""String_Node_Str""+ ioe.getMessage();
      throw new TaskException(msg,ioe);
    }
  }
}","/** 
 * Move the generated source file(s) to the base directory
 * @param baseDir Description of Parameter
 * @param sourceBaseFile Description of Parameter
 * @param classname Description of Parameter
 * @param adapter Description of Parameter
 * @exception TaskException Description of Exception
 */
private void moveGeneratedFile(File baseDir,File sourceBaseFile,String classname,RmicAdapter adapter) throws TaskException {
  String classFileName=classname.replace('.',File.separatorChar) + ""String_Node_Str"";
  String[] generatedFiles=adapter.getMapper().mapFileName(classFileName);
  for (int i=0; i < generatedFiles.length; i++) {
    String sourceFileName=classFileName.substring(0,classFileName.length() - 6) + ""String_Node_Str"";
    File oldFile=new File(baseDir,sourceFileName);
    File newFile=new File(sourceBaseFile,sourceFileName);
    try {
      if (filtering) {
        final FilterSetCollection filters=new FilterSetCollection(project.getGlobalFilterSet());
        FileUtils.newFileUtils().copyFile(oldFile,newFile,filters);
      }
 else {
        FileUtils.newFileUtils().copyFile(oldFile,newFile);
      }
      oldFile.delete();
    }
 catch (    IOException ioe) {
      String msg=""String_Node_Str"" + oldFile + ""String_Node_Str""+ newFile+ ""String_Node_Str""+ ioe.getMessage();
      throw new TaskException(msg,ioe);
    }
  }
}",0.9160671462829736
64334,"public void execute() throws TaskException {
  checkConfiguration();
  Vector files=getFileList();
  if (isUpToDate(files))   return;
  log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ cabFile.getAbsolutePath());
  if (!Os.isFamily(""String_Node_Str"")) {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    StringBuffer sb=new StringBuffer();
    Enumeration fileEnum=files.elements();
    while (fileEnum.hasMoreElements()) {
      sb.append(fileEnum.nextElement()).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"").append(cabFile.getAbsolutePath()).append(""String_Node_Str"");
    try {
      Process p=Runtime.getRuntime().exec(""String_Node_Str"");
      OutputStream out=p.getOutputStream();
      out.write(sb.toString().getBytes());
      out.flush();
      out.close();
    }
 catch (    IOException ex) {
      String msg=""String_Node_Str"" + cabFile + ""String_Node_Str""+ ex.getMessage();
      throw new TaskException(msg);
    }
  }
 else {
    try {
      File listFile=createListFile(files);
      ExecTask exec=createExec();
      File outFile=null;
      exec.setFailonerror(true);
      exec.setDir(baseDir);
      if (!doVerbose) {
        outFile=fileUtils.createTempFile(""String_Node_Str"",""String_Node_Str"",null);
        exec.setOutput(outFile);
      }
      exec.setCommand(createCommand(listFile));
      exec.execute();
      if (outFile != null) {
        outFile.delete();
      }
      listFile.delete();
    }
 catch (    IOException ioe) {
      String msg=""String_Node_Str"" + cabFile + ""String_Node_Str""+ ioe.getMessage();
      throw new TaskException(msg);
    }
  }
}","public void execute() throws TaskException {
  checkConfiguration();
  Vector files=getFileList();
  if (isUpToDate(files))   return;
  log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ cabFile.getAbsolutePath());
  if (!Os.isFamily(""String_Node_Str"")) {
    log(""String_Node_Str"",Project.MSG_VERBOSE);
    StringBuffer sb=new StringBuffer();
    Enumeration fileEnum=files.elements();
    while (fileEnum.hasMoreElements()) {
      sb.append(fileEnum.nextElement()).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"").append(cabFile.getAbsolutePath()).append(""String_Node_Str"");
    try {
      Process p=Runtime.getRuntime().exec(""String_Node_Str"");
      OutputStream out=p.getOutputStream();
      out.write(sb.toString().getBytes());
      out.flush();
      out.close();
    }
 catch (    IOException ex) {
      String msg=""String_Node_Str"" + cabFile + ""String_Node_Str""+ ex.getMessage();
      throw new TaskException(msg);
    }
  }
 else {
    try {
      File listFile=createListFile(files);
      ExecTask exec=createExec();
      File outFile=null;
      exec.setFailonerror(true);
      exec.setDir(baseDir);
      if (!doVerbose) {
        outFile=fileUtils.createTempFile(""String_Node_Str"",""String_Node_Str"",null);
        exec.setOutput(outFile);
      }
      setupCommand(listFile,exec);
      exec.execute();
      if (outFile != null) {
        outFile.delete();
      }
      listFile.delete();
    }
 catch (    IOException ioe) {
      String msg=""String_Node_Str"" + cabFile + ""String_Node_Str""+ ioe.getMessage();
      throw new TaskException(msg);
    }
  }
}",0.9848062015503876
64335,"public void execute() throws TaskException {
  if (!destinationDirectory.isDirectory()) {
    throw new TaskException(""String_Node_Str"" + destinationDirectory.getPath() + ""String_Node_Str"");
  }
  if (!sourceDirectory.isDirectory()) {
    throw new TaskException(""String_Node_Str"" + sourceDirectory.getPath() + ""String_Node_Str"");
  }
  if (destinationPackage == null) {
    throw new TaskException(""String_Node_Str"");
  }
  String systemClassPath=System.getProperty(""String_Node_Str"");
  pathToPackage=this.destinationPackage.replace('.',File.separatorChar);
  DirectoryScanner ds=super.getDirectoryScanner(sourceDirectory);
  if (compileClasspath == null) {
    compileClasspath=new Path(project);
  }
  compileClasspath.append(Path.systemClasspath);
  String[] files=ds.getIncludedFiles();
  Java helperTask=(Java)project.createTask(""String_Node_Str"");
  helperTask.setFork(true);
  helperTask.setClassname(""String_Node_Str"");
  String[] args=new String[12];
  File jspFile=null;
  String parents=""String_Node_Str"";
  String arg=""String_Node_Str"";
  int j=0;
  args[j++]=""String_Node_Str"";
  args[j++]=destinationDirectory.getAbsolutePath().trim();
  args[j++]=""String_Node_Str"";
  args[j++]=sourceDirectory.getAbsolutePath().trim();
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=compileClasspath.toString();
  this.scanDir(files);
  log(""String_Node_Str"" + filesToDo.size() + ""String_Node_Str"");
  for (int i=0; i < filesToDo.size(); i++) {
    jspFile=new File((String)filesToDo.elementAt(i));
    args[j]=""String_Node_Str"";
    parents=jspFile.getParent();
    if ((parents != null) && (!(""String_Node_Str"").equals(parents))) {
      parents=this.replaceString(parents,File.separator,""String_Node_Str"");
      args[j + 1]=destinationPackage + ""String_Node_Str"" + ""String_Node_Str""+ parents;
    }
 else {
      args[j + 1]=destinationPackage;
    }
    args[j + 2]=sourceDirectory + File.separator + (String)filesToDo.elementAt(i);
    arg=""String_Node_Str"";
    for (int x=0; x < 12; x++) {
      arg+=""String_Node_Str"" + args[x];
    }
    System.out.println(""String_Node_Str"" + arg);
    helperTask.clearArgs();
    helperTask.setArgs(arg);
    helperTask.setClasspath(compileClasspath);
    if (helperTask.executeJava() != 0) {
      log(files[i] + ""String_Node_Str"",Project.MSG_WARN);
    }
  }
}","public void execute() throws TaskException {
  if (!destinationDirectory.isDirectory()) {
    throw new TaskException(""String_Node_Str"" + destinationDirectory.getPath() + ""String_Node_Str"");
  }
  if (!sourceDirectory.isDirectory()) {
    throw new TaskException(""String_Node_Str"" + sourceDirectory.getPath() + ""String_Node_Str"");
  }
  if (destinationPackage == null) {
    throw new TaskException(""String_Node_Str"");
  }
  String systemClassPath=System.getProperty(""String_Node_Str"");
  pathToPackage=this.destinationPackage.replace('.',File.separatorChar);
  DirectoryScanner ds=super.getDirectoryScanner(sourceDirectory);
  if (compileClasspath == null) {
    compileClasspath=new Path(project);
  }
  compileClasspath.append(Path.systemClasspath);
  String[] files=ds.getIncludedFiles();
  Java helperTask=(Java)project.createTask(""String_Node_Str"");
  helperTask.setFork(true);
  helperTask.setClassname(""String_Node_Str"");
  String[] args=new String[12];
  File jspFile=null;
  String parents=""String_Node_Str"";
  String arg=""String_Node_Str"";
  int j=0;
  args[j++]=""String_Node_Str"";
  args[j++]=destinationDirectory.getAbsolutePath().trim();
  args[j++]=""String_Node_Str"";
  args[j++]=sourceDirectory.getAbsolutePath().trim();
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=""String_Node_Str"";
  args[j++]=compileClasspath.toString();
  this.scanDir(files);
  log(""String_Node_Str"" + filesToDo.size() + ""String_Node_Str"");
  for (int i=0; i < filesToDo.size(); i++) {
    jspFile=new File((String)filesToDo.elementAt(i));
    args[j]=""String_Node_Str"";
    parents=jspFile.getParent();
    if ((parents != null) && (!(""String_Node_Str"").equals(parents))) {
      parents=this.replaceString(parents,File.separator,""String_Node_Str"");
      args[j + 1]=destinationPackage + ""String_Node_Str"" + ""String_Node_Str""+ parents;
    }
 else {
      args[j + 1]=destinationPackage;
    }
    args[j + 2]=sourceDirectory + File.separator + (String)filesToDo.elementAt(i);
    arg=""String_Node_Str"";
    for (int x=0; x < 12; x++) {
      arg+=""String_Node_Str"" + args[x];
    }
    System.out.println(""String_Node_Str"" + arg);
    helperTask.clearArgs();
    helperTask.createArg().setValue(arg);
    helperTask.setClasspath(compileClasspath);
    if (helperTask.executeJava() != 0) {
      log(files[i] + ""String_Node_Str"",Project.MSG_WARN);
    }
  }
}",0.9956313709174122
64336,"public void execute() throws TaskException {
  if (project.getJavaVersion().equals(Project.JAVA_1_1)) {
    throw new TaskException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (null == alias) {
    throw new TaskException(""String_Node_Str"");
  }
  if (null == storepass) {
    throw new TaskException(""String_Node_Str"");
  }
  if (null == dname && null == expandedDname) {
    throw new TaskException(""String_Node_Str"");
  }
  final StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  if (verbose) {
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(alias);
  sb.append(""String_Node_Str"");
  if (null != dname) {
    sb.append(""String_Node_Str"");
    sb.append(dname);
    sb.append(""String_Node_Str"");
  }
  if (null != expandedDname) {
    sb.append(""String_Node_Str"");
    sb.append(expandedDname);
    sb.append(""String_Node_Str"");
  }
  if (null != keystore) {
    sb.append(""String_Node_Str"");
    sb.append(keystore);
    sb.append(""String_Node_Str"");
  }
  if (null != storepass) {
    sb.append(""String_Node_Str"");
    sb.append(storepass);
    sb.append(""String_Node_Str"");
  }
  if (null != storetype) {
    sb.append(""String_Node_Str"");
    sb.append(storetype);
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (null != keypass) {
    sb.append(keypass);
  }
 else {
    sb.append(storepass);
  }
  sb.append(""String_Node_Str"");
  if (null != sigalg) {
    sb.append(""String_Node_Str"");
    sb.append(sigalg);
    sb.append(""String_Node_Str"");
  }
  if (null != keyalg) {
    sb.append(""String_Node_Str"");
    sb.append(keyalg);
    sb.append(""String_Node_Str"");
  }
  if (0 < keysize) {
    sb.append(""String_Node_Str"");
    sb.append(keysize);
    sb.append(""String_Node_Str"");
  }
  if (0 < validity) {
    sb.append(""String_Node_Str"");
    sb.append(validity);
    sb.append(""String_Node_Str"");
  }
  log(""String_Node_Str"" + alias);
  final ExecTask cmd=(ExecTask)project.createTask(""String_Node_Str"");
  cmd.setCommand(new Commandline(sb.toString()));
  cmd.setFailonerror(true);
  cmd.execute();
}","public void execute() throws TaskException {
  if (project.getJavaVersion().equals(Project.JAVA_1_1)) {
    throw new TaskException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (null == alias) {
    throw new TaskException(""String_Node_Str"");
  }
  if (null == storepass) {
    throw new TaskException(""String_Node_Str"");
  }
  if (null == dname && null == expandedDname) {
    throw new TaskException(""String_Node_Str"");
  }
  log(""String_Node_Str"" + alias);
  final ExecTask cmd=(ExecTask)project.createTask(""String_Node_Str"");
  cmd.setExecutable(""String_Node_Str"");
  cmd.createArg().setValue(""String_Node_Str"");
  if (verbose) {
    cmd.createArg().setValue(""String_Node_Str"");
  }
  cmd.createArg().setValue(""String_Node_Str"");
  cmd.createArg().setValue(alias);
  if (null != dname) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(dname);
  }
  if (null != expandedDname) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(expandedDname.toString());
  }
  if (null != keystore) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(keystore);
  }
  if (null != storepass) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(storepass);
  }
  if (null != storetype) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(storetype);
  }
  cmd.createArg().setValue(""String_Node_Str"");
  if (null != keypass) {
    cmd.createArg().setValue(keypass);
  }
 else {
    cmd.createArg().setValue(storepass);
  }
  if (null != sigalg) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(sigalg);
  }
  if (null != keyalg) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(keyalg);
  }
  if (0 < keysize) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(""String_Node_Str"" + keysize);
  }
  if (0 < validity) {
    cmd.createArg().setValue(""String_Node_Str"");
    cmd.createArg().setValue(""String_Node_Str"" + validity);
  }
  cmd.setFailonerror(true);
  cmd.execute();
}",0.4594852240228789
64337,"/** 
 * Move the generated source file(s) to the base directory
 * @param baseDir Description of Parameter
 * @param sourceBaseFile Description of Parameter
 * @param classname Description of Parameter
 * @param adapter Description of Parameter
 * @exception TaskException Description of Exception
 */
private void moveGeneratedFile(File baseDir,File sourceBaseFile,String classname,RmicAdapter adapter) throws TaskException {
  String classFileName=classname.replace('.',File.separatorChar) + ""String_Node_Str"";
  String[] generatedFiles=adapter.getMapper().mapFileName(classFileName);
  for (int i=0; i < generatedFiles.length; i++) {
    String sourceFileName=classFileName.substring(0,classFileName.length() - 6) + ""String_Node_Str"";
    File oldFile=new File(baseDir,sourceFileName);
    File newFile=new File(sourceBaseFile,sourceFileName);
    try {
      FileUtils.newFileUtils().copyFile(oldFile,newFile,filtering);
      oldFile.delete();
    }
 catch (    IOException ioe) {
      String msg=""String_Node_Str"" + oldFile + ""String_Node_Str""+ newFile+ ""String_Node_Str""+ ioe.getMessage();
      throw new TaskException(msg,ioe);
    }
  }
}","/** 
 * Move the generated source file(s) to the base directory
 * @param baseDir Description of Parameter
 * @param sourceBaseFile Description of Parameter
 * @param classname Description of Parameter
 * @param adapter Description of Parameter
 * @exception TaskException Description of Exception
 */
private void moveGeneratedFile(File baseDir,File sourceBaseFile,String classname,RmicAdapter adapter) throws TaskException {
  String classFileName=classname.replace('.',File.separatorChar) + ""String_Node_Str"";
  String[] generatedFiles=adapter.getMapper().mapFileName(classFileName);
  for (int i=0; i < generatedFiles.length; i++) {
    String sourceFileName=classFileName.substring(0,classFileName.length() - 6) + ""String_Node_Str"";
    File oldFile=new File(baseDir,sourceFileName);
    File newFile=new File(sourceBaseFile,sourceFileName);
    try {
      if (filtering) {
        final FilterSetCollection filters=new FilterSetCollection(project.getGlobalFilterSet());
        FileUtils.newFileUtils().copyFile(oldFile,newFile,filters);
      }
 else {
        FileUtils.newFileUtils().copyFile(oldFile,newFile);
      }
      oldFile.delete();
    }
 catch (    IOException ioe) {
      String msg=""String_Node_Str"" + oldFile + ""String_Node_Str""+ newFile+ ""String_Node_Str""+ ioe.getMessage();
      throw new TaskException(msg,ioe);
    }
  }
}",0.9160671462829736
64338,"/** 
 * create the parameters file that contains all file to merge and the output filename.
 */
protected File createParamFile() throws BuildException {
  File[] snapshots=getSnapshots();
  File file=createTmpFile();
  FileWriter fw=null;
  try {
    fw=new FileWriter(file);
    PrintWriter pw=new PrintWriter(fw);
    for (int i=0; i < snapshots.length; i++) {
      pw.println(snapshots[i].getAbsolutePath());
    }
    pw.println(project.resolveFile(tofile.getPath()));
    pw.flush();
    return file;
  }
 catch (  IOException e) {
    if (fw != null) {
      try {
        fw.close();
      }
 catch (      IOException ignored) {
      }
    }
    throw new BuildException(""String_Node_Str"" + file,e);
  }
}","/** 
 * create the parameters file that contains all file to merge and the output filename.
 */
protected File createParamFile() throws BuildException {
  File[] snapshots=getSnapshots();
  File file=createTmpFile();
  FileWriter fw=null;
  try {
    fw=new FileWriter(file);
    PrintWriter pw=new PrintWriter(fw);
    for (int i=0; i < snapshots.length; i++) {
      pw.println(snapshots[i].getAbsolutePath());
    }
    pw.println(project.resolveFile(tofile.getPath()));
    pw.flush();
  }
 catch (  IOException e) {
    throw new BuildException(""String_Node_Str"" + file,e);
  }
 finally {
    if (fw != null) {
      try {
        fw.close();
      }
 catch (      IOException ignored) {
      }
    }
  }
  return file;
}",0.8868841082581541
64339,"/** 
 * create an empty class element with its default cov.data (0) 
 */
protected Element createClassElement(ClassFile classFile){
  Element classElem=report.createElement(""String_Node_Str"");
  classElem.setAttribute(""String_Node_Str"",classFile.getName());
  classElem.setAttribute(""String_Node_Str"",classFile.getSourceFile());
  Element classData=report.createElement(""String_Node_Str"");
  classElem.appendChild(classData);
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  return classElem;
}","/** 
 * create an empty class element with its default cov.data (0) 
 */
protected Element createClassElement(ClassFile classFile){
  Element classElem=report.createElement(""String_Node_Str"");
  classElem.setAttribute(""String_Node_Str"",classFile.getName());
  if (null != classFile.getSourceFile()) {
    classElem.setAttribute(""String_Node_Str"",classFile.getSourceFile());
  }
  Element classData=report.createElement(""String_Node_Str"");
  classElem.appendChild(classData);
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  classData.setAttribute(""String_Node_Str"",""String_Node_Str"");
  return classElem;
}",0.9688493324856962
64340,"/** 
 * Create a nested <src ...> element for multiple source path support.
 * @return a nexted src element.
 */
public Path createSrc(){
  if (src == null) {
    src=new Path(project);
  }
  return src.createPath();
}","/** 
 * Create a nested src element for multiple source path support.
 * @return a nested src element.
 */
public Path createSrc(){
  if (src == null) {
    src=new Path(project);
  }
  return src.createPath();
}",0.7767441860465116
64341,"/** 
 * Nested <replacevalue> element.
 */
public NestedString createReplaceValue(){
  return value;
}","/** 
 * Nested &lt;replacevalue&gt; element.
 */
public NestedString createReplaceValue(){
  return value;
}",0.9523809523809524
64342,"/** 
 * Add nested <replacefilter> element.
 */
public Replacefilter createReplacefilter(){
  Replacefilter filter=new Replacefilter();
  replacefilters.addElement(filter);
  return filter;
}","/** 
 * Add nested &lt;replacefilter&gt; element.
 */
public Replacefilter createReplacefilter(){
  Replacefilter filter=new Replacefilter();
  replacefilters.addElement(filter);
  return filter;
}",0.9742268041237112
64343,"/** 
 * Nested <replacetoken> element.
 */
public NestedString createReplaceToken(){
  if (token == null) {
    token=new NestedString();
  }
  return token;
}","/** 
 * Nested &lt;replacetoken&gt; element.
 */
public NestedString createReplaceToken(){
  if (token == null) {
    token=new NestedString();
  }
  return token;
}",0.9691358024691358
64344,"/** 
 * @exception java.io.IOException <description>
 */
public void start() throws IOException {
}","/** 
 * @exception java.io.IOException
 */
public void start() throws IOException {
}",0.9239130434782608
64345,"/** 
 * @param param1 <description>
 * @exception java.io.IOException <description>
 */
public void setProcessErrorStream(InputStream is) throws IOException {
  BufferedReader reader=new BufferedReader(new InputStreamReader(is));
  String s=reader.readLine();
  if (s != null) {
    log(""String_Node_Str"" + s,Project.MSG_DEBUG);
  }
}","/** 
 * @param param1
 * @exception java.io.IOException
 */
public void setProcessErrorStream(InputStream is) throws IOException {
  BufferedReader reader=new BufferedReader(new InputStreamReader(is));
  String s=reader.readLine();
  if (s != null) {
    log(""String_Node_Str"" + s,Project.MSG_DEBUG);
  }
}",0.95625
64346,"/** 
 * @param param1 <description>
 * @exception java.io.IOException <description>
 */
public void setProcessInputStream(OutputStream param1) throws IOException {
}","/** 
 * @param param1
 * @exception java.io.IOException
 */
public void setProcessInputStream(OutputStream param1) throws IOException {
}",0.9072847682119204
64347,"/** 
 * @param param1 <description>
 * @exception java.io.IOException <description>
 */
public void setProcessErrorStream(InputStream is) throws IOException {
  BufferedReader reader=new BufferedReader(new InputStreamReader(is));
  String s=reader.readLine();
  if (s != null) {
    log(""String_Node_Str"" + s,Project.MSG_DEBUG);
  }
}","/** 
 * @param param1
 * @exception java.io.IOException
 */
public void setProcessErrorStream(InputStream is) throws IOException {
  BufferedReader reader=new BufferedReader(new InputStreamReader(is));
  String s=reader.readLine();
  if (s != null) {
    log(""String_Node_Str"" + s,Project.MSG_DEBUG);
  }
}",0.95625
64348,"/** 
 * @param param1 <description>
 * @exception java.io.IOException <description>
 */
public void setProcessOutputStream(InputStream is) throws IOException {
  try {
    BufferedReader reader=new BufferedReader(new InputStreamReader(is));
    String javafile;
    while ((javafile=reader.readLine()) != null) {
      log(""String_Node_Str"" + javafile,Project.MSG_DEBUG);
      if (javafile.endsWith(""String_Node_Str"")) {
        String classfile=toClassFile(javafile);
        String key=classfile.substring(getConfig().srcDir.getAbsolutePath().length() + 1);
        log(""String_Node_Str"" + classfile,Project.MSG_DEBUG);
        log(""String_Node_Str"" + key,Project.MSG_DEBUG);
        _genfiles.put(key,new File(classfile));
      }
    }
    reader.close();
  }
 catch (  Exception e) {
    String msg=""String_Node_Str"" + e.toString();
    throw new BuildException(msg,e);
  }
}","/** 
 * @param is
 * @exception java.io.IOException
 */
public void setProcessOutputStream(InputStream is) throws IOException {
  try {
    BufferedReader reader=new BufferedReader(new InputStreamReader(is));
    String javafile;
    while ((javafile=reader.readLine()) != null) {
      log(""String_Node_Str"" + javafile,Project.MSG_DEBUG);
      if (javafile.endsWith(""String_Node_Str"")) {
        String classfile=toClassFile(javafile);
        String key=classfile.substring(getConfig().srcDir.getAbsolutePath().length() + 1);
        log(""String_Node_Str"" + classfile,Project.MSG_DEBUG);
        log(""String_Node_Str"" + key,Project.MSG_DEBUG);
        _genfiles.put(key,new File(classfile));
      }
    }
    reader.close();
  }
 catch (  Exception e) {
    String msg=""String_Node_Str"" + e.toString();
    throw new BuildException(msg,e);
  }
}",0.9791907514450868
64349,"/** 
 * Getter method that returns the value of the <ejb-name> element.
 */
public String getEjbName(){
  return ejbName;
}","/** 
 * Getter method that returns the value of the &lt;ejb-name&gt; element.
 */
public String getEjbName(){
  return ejbName;
}",0.9603174603174603
64350,"/** 
 * A subTask <write> tag was found.  Create the object,  Save it in our list, and return it.
 */
public TelnetSubTask createWrite(){
  TelnetSubTask task=(TelnetSubTask)new TelnetWrite();
  telnetTasks.addElement(task);
  return task;
}","/** 
 * A subTask &lt;write&gt; tag was found.  Create the object,  Save it in our list, and return it.
 */
public TelnetSubTask createWrite(){
  TelnetSubTask task=(TelnetSubTask)new TelnetWrite();
  telnetTasks.addElement(task);
  return task;
}",0.9795081967213116
64351,"/** 
 * A subTask <read> tag was found.  Create the object,  Save it in our list, and return it.
 */
public TelnetSubTask createRead(){
  TelnetSubTask task=(TelnetSubTask)new TelnetRead();
  telnetTasks.addElement(task);
  return task;
}","/** 
 * A subTask &lt;read&gt; tag was found.  Create the object,  Save it in our list, and return it.
 */
public TelnetSubTask createRead(){
  TelnetSubTask task=(TelnetSubTask)new TelnetRead();
  telnetTasks.addElement(task);
  return task;
}",0.9626556016597512
64352,"/** 
 * if no host is set, returning ':<port>', will take localhost 
 */
public String toString(){
  return host + ""String_Node_Str"" + port;
}","/** 
 * if no host is set, returning ':&lt;port&gt;', will take localhost 
 */
public String toString(){
  return host + ""String_Node_Str"" + port;
}",0.9655172413793104
64353,"/** 
 * Convert to a CovReport-like signature ie, <classname>.<method>()
 */
protected String getMethodSignature(ClassFile clazz,MethodInfo method){
  StringBuffer buf=new StringBuffer(clazz.getFullName());
  buf.append(""String_Node_Str"");
  buf.append(method.getName());
  buf.append(""String_Node_Str"");
  return buf.toString();
}","/** 
 * Convert to a CovReport-like signature ie, &lt;classname&gt;.&lt;method&gt;()
 */
protected String getMethodSignature(ClassFile clazz,MethodInfo method){
  StringBuffer buf=new StringBuffer(clazz.getFullName());
  buf.append(""String_Node_Str"");
  buf.append(method.getName());
  buf.append(""String_Node_Str"");
  return buf.toString();
}",0.9495548961424332
64354,"public void execute() throws BuildException {
  if (null == jar && null == filesets) {
    throw new BuildException(""String_Node_Str"");
  }
  if (null != jar) {
    doOneJar(jar,signedjar);
    return;
  }
 else {
    for (int i=0; i < filesets.size(); i++) {
      FileSet fs=(FileSet)filesets.elementAt(i);
      DirectoryScanner ds=fs.getDirectoryScanner(project);
      String[] jarFiles=ds.getIncludedFiles();
      for (int j=0; j < jarFiles.length; j++) {
        doOneJar(new File(jarFiles[j]),null);
      }
    }
  }
}","public void execute() throws BuildException {
  if (null == jar && null == filesets) {
    throw new BuildException(""String_Node_Str"");
  }
  if (null != jar) {
    doOneJar(jar,signedjar);
    return;
  }
 else {
    for (int i=0; i < filesets.size(); i++) {
      FileSet fs=(FileSet)filesets.elementAt(i);
      DirectoryScanner ds=fs.getDirectoryScanner(project);
      String[] jarFiles=ds.getIncludedFiles();
      for (int j=0; j < jarFiles.length; j++) {
        doOneJar(new File(fs.getDir(project),jarFiles[j]),null);
      }
    }
  }
}",0.9823255813953488
64355,"public void process(String line){
  if (!util.match(""String_Node_Str"",line)) {
    if (util.match(""String_Node_Str"",line)) {
      log(""String_Node_Str"",Project.MSG_VERBOSE);
      throw new BuildException(""String_Node_Str"");
    }
 else     if (util.match(""String_Node_Str"",line)) {
      line=util.substitute(""String_Node_Str"" + description + ""String_Node_Str"",line);
    }
 else     if (util.match(""String_Node_Str"",line)) {
      return;
    }
    stringbuf.append(line);
    stringbuf.append(""String_Node_Str"");
  }
}","public void process(String line){
  if (!util.match(""String_Node_Str"",line)) {
    if (util.match(""String_Node_Str"",line)) {
      log(""String_Node_Str"",Project.MSG_VERBOSE);
      throw new BuildException(""String_Node_Str"");
    }
 else     if (util.match(""String_Node_Str"",line)) {
      description=backslash(description);
      line=util.substitute(""String_Node_Str"" + description + ""String_Node_Str"",line);
    }
 else     if (util.match(""String_Node_Str"",line)) {
      return;
    }
    stringbuf.append(line);
    stringbuf.append(""String_Node_Str"");
  }
}",0.9410681399631676
64356,"public String getEmptyChangeList() throws BuildException {
  final StringBuffer stringbuf=new StringBuffer();
  execP4Command(""String_Node_Str"",new P4HandlerAdapter(){
    public void process(    String line){
      if (!util.match(""String_Node_Str"",line)) {
        if (util.match(""String_Node_Str"",line)) {
          log(""String_Node_Str"",Project.MSG_VERBOSE);
          throw new BuildException(""String_Node_Str"");
        }
 else         if (util.match(""String_Node_Str"",line)) {
          line=util.substitute(""String_Node_Str"" + description + ""String_Node_Str"",line);
        }
 else         if (util.match(""String_Node_Str"",line)) {
          return;
        }
        stringbuf.append(line);
        stringbuf.append(""String_Node_Str"");
      }
    }
  }
);
  return stringbuf.toString();
}","public String getEmptyChangeList() throws BuildException {
  final StringBuffer stringbuf=new StringBuffer();
  execP4Command(""String_Node_Str"",new P4HandlerAdapter(){
    public void process(    String line){
      if (!util.match(""String_Node_Str"",line)) {
        if (util.match(""String_Node_Str"",line)) {
          log(""String_Node_Str"",Project.MSG_VERBOSE);
          throw new BuildException(""String_Node_Str"");
        }
 else         if (util.match(""String_Node_Str"",line)) {
          description=backslash(description);
          line=util.substitute(""String_Node_Str"" + description + ""String_Node_Str"",line);
        }
 else         if (util.match(""String_Node_Str"",line)) {
          return;
        }
        stringbuf.append(line);
        stringbuf.append(""String_Node_Str"");
      }
    }
  }
);
  return stringbuf.toString();
}",0.9719853836784408
64357,"/** 
 * Sets whether to fork the javac compiler.
 * @param f ""true|false|on|off|yes|no"" or the name of the javacexecutable.
 */
public void setFork(String f){
  if (f.equalsIgnoreCase(""String_Node_Str"") || f.equalsIgnoreCase(""String_Node_Str"") || f.equalsIgnoreCase(""String_Node_Str"")) {
    fork=""String_Node_Str"";
    forkedExecutable=getSystemJavac();
  }
 else   if (f.equalsIgnoreCase(""String_Node_Str"") || f.equalsIgnoreCase(""String_Node_Str"") || f.equalsIgnoreCase(""String_Node_Str"")) {
    fork=""String_Node_Str"";
  }
 else {
    fork=""String_Node_Str"";
    forkedExecutable=f;
  }
}","/** 
 * Sets whether to fork the javac compiler.
 * @param f ""true|false|on|off|yes|no"" or the name of the javacexecutable.
 */
public void setFork(String f){
  if (f.equalsIgnoreCase(""String_Node_Str"") || f.equalsIgnoreCase(""String_Node_Str"") || f.equalsIgnoreCase(""String_Node_Str"")) {
    fork=""String_Node_Str"";
    forkedExecutable=getSystemJavac();
  }
 else   if (f.equalsIgnoreCase(""String_Node_Str"") || f.equalsIgnoreCase(""String_Node_Str"") || f.equalsIgnoreCase(""String_Node_Str"")) {
    fork=""String_Node_Str"";
    forkedExecutable=null;
  }
 else {
    fork=""String_Node_Str"";
    forkedExecutable=f;
  }
}",0.9098428453267164
64358,"/** 
 * The name of the javac executable to use in fork-mode.
 */
public String getJavacExecutable(){
  return forkedExecutable;
}","/** 
 * The name of the javac executable to use in fork-mode.
 */
public String getJavacExecutable(){
  if (forkedExecutable == null && isForkedJavac()) {
    forkedExecutable=getSystemJavac();
  }
 else   if (forkedExecutable != null && !isForkedJavac()) {
    forkedExecutable=null;
  }
  return forkedExecutable;
}",0.4787472035794183
64359,"/** 
 * Handle operations for type <code>int</code>.
 * @param oldValue the current value read from the property file or<code>null</code> if the <code>key</code> was not contained in the property file.
 */
private void executeInteger(String oldValue) throws BuildException {
  int value=0;
  int newValue=0;
  DecimalFormat fmt=(m_pattern != null) ? new DecimalFormat(m_pattern) : new DecimalFormat();
  if (oldValue != null) {
    try {
      value=fmt.parse(oldValue).intValue();
    }
 catch (    NumberFormatException nfe) {
    }
catch (    ParseException pe) {
    }
  }
  if (m_value != null) {
    try {
      value=fmt.parse(m_value).intValue();
    }
 catch (    NumberFormatException nfe) {
    }
catch (    ParseException pe) {
    }
  }
  if (m_default != null && oldValue == null) {
    try {
      value=fmt.parse(m_default).intValue();
    }
 catch (    NumberFormatException nfe) {
    }
catch (    ParseException pe) {
    }
  }
  if (m_operation == Operation.EQUALS_OPER) {
    newValue=value;
  }
 else   if (m_operation == Operation.INCREMENT_OPER) {
    newValue+=value;
  }
 else   if (m_operation == Operation.DECREMENT_OPER) {
    newValue-=value;
  }
  m_value=fmt.format(newValue);
}","/** 
 * Handle operations for type <code>int</code>.
 * @param oldValue the current value read from the property file or<code>null</code> if the <code>key</code> was not contained in the property file.
 */
private void executeInteger(String oldValue) throws BuildException {
  int value=0;
  int newValue=0;
  DecimalFormat fmt=(m_pattern != null) ? new DecimalFormat(m_pattern) : new DecimalFormat();
  if (oldValue != null) {
    try {
      value=fmt.parse(oldValue).intValue();
    }
 catch (    NumberFormatException nfe) {
    }
catch (    ParseException pe) {
    }
  }
  if (m_value != null) {
    try {
      value=fmt.parse(m_value).intValue();
    }
 catch (    NumberFormatException nfe) {
    }
catch (    ParseException pe) {
    }
  }
  if (m_default != null && oldValue == null) {
    try {
      value=fmt.parse(m_default).intValue();
    }
 catch (    NumberFormatException nfe) {
    }
catch (    ParseException pe) {
    }
  }
  if (m_operation == Operation.EQUALS_OPER) {
    newValue=value;
  }
 else   if (m_operation == Operation.INCREMENT_OPER) {
    newValue=++value;
  }
 else   if (m_operation == Operation.DECREMENT_OPER) {
    newValue=--value;
  }
  m_value=fmt.format(newValue);
}",0.9975227085053676
64360,"/** 
 * SAX parser call-back method that is invoked when an element is exited. Used to blank out (set to the empty string, not nullify) the name of the currentAttribute.  A better method would be to use a stack as an instance variable, however since we are only interested in leaf-node data this is a simpler and workable solution.
 * @param name The name of the attribute being exited. Ignoredin this implementation.
 */
public void endElement(String name) throws SAXException {
}","/** 
 * SAX parser call-back method that is invoked when an element is exited. Used to blank out (set to the empty string, not nullify) the name of the currentAttribute.  A better method would be to use a stack as an instance variable, however since we are only interested in leaf-node data this is a simpler and workable solution.
 * @param name The name of the attribute being exited. Ignoredin this implementation.
 */
public void endElement(String name) throws SAXException {
  processElement();
  currentText=""String_Node_Str"";
  this.currentElement=""String_Node_Str"";
  if (name.equals(EJB_REF)) {
    inEJBRef=false;
  }
 else   if (parseState == STATE_IN_ENTITY && name.equals(ENTITY_BEAN)) {
    parseState=STATE_IN_BEANS;
  }
 else   if (parseState == STATE_IN_SESSION && name.equals(SESSION_BEAN)) {
    parseState=STATE_IN_BEANS;
  }
 else   if (parseState == STATE_IN_MESSAGE && name.equals(MESSAGE_BEAN)) {
    parseState=STATE_IN_BEANS;
  }
 else   if (parseState == STATE_IN_BEANS && name.equals(ENTERPRISE_BEANS)) {
    parseState=STATE_IN_EJBJAR;
  }
 else   if (parseState == STATE_IN_EJBJAR && name.equals(EJB_JAR)) {
    parseState=STATE_LOOKING_EJBJAR;
  }
}",0.5791691751956652
64361,"/** 
 * Perform the replacement on the given file. The replacement is performed on a temporary file which then replaces the original file.
 * @param src the source file
 */
private void processFile(File src) throws BuildException {
  if (!src.exists()) {
    throw new BuildException(""String_Node_Str"" + src.getPath() + ""String_Node_Str"",location);
  }
  File temp=new File(src.getPath() + ""String_Node_Str"");
  if (temp.exists()) {
    throw new BuildException(""String_Node_Str"" + temp.getPath() + ""String_Node_Str"",location);
  }
  try {
    Reader fileReader=encoding == null ? new FileReader(src) : new InputStreamReader(new FileInputStream(src),encoding);
    Writer fileWriter=encoding == null ? new FileWriter(src) : new OutputStreamWriter(new FileOutputStream(src),encoding);
    BufferedReader br=new BufferedReader(fileReader);
    BufferedWriter bw=new BufferedWriter(fileWriter);
    int fileLengthInBytes=(int)(src.length());
    StringBuffer tmpBuf=new StringBuffer(fileLengthInBytes);
    int readChar=0;
    int totread=0;
    while (true) {
      readChar=br.read();
      if (readChar < 0) {
        break;
      }
      tmpBuf.append((char)readChar);
      totread++;
    }
    String buf=tmpBuf.toString();
    String newString=new String(buf);
    if (token != null) {
      String linesep=System.getProperty(""String_Node_Str"");
      String val=stringReplace(value.getText(),""String_Node_Str"",linesep);
      String tok=stringReplace(token.getText(),""String_Node_Str"",linesep);
      log(""String_Node_Str"" + src.getPath() + ""String_Node_Str""+ token.getText()+ ""String_Node_Str""+ value.getText(),Project.MSG_VERBOSE);
      newString=stringReplace(newString,tok,val);
    }
    if (replacefilters.size() > 0) {
      newString=processReplacefilters(newString,src.getPath());
    }
    boolean changes=!newString.equals(buf);
    if (changes) {
      bw.write(newString,0,newString.length());
      bw.flush();
    }
    bw.close();
    br.close();
    if (changes) {
      ++fileCount;
      src.delete();
      temp.renameTo(src);
    }
 else {
      temp.delete();
    }
  }
 catch (  IOException ioe) {
    throw new BuildException(""String_Node_Str"" + src + ""String_Node_Str""+ ioe.getClass().getName()+ ""String_Node_Str""+ ioe.getMessage(),ioe,location);
  }
}","/** 
 * Perform the replacement on the given file. The replacement is performed on a temporary file which then replaces the original file.
 * @param src the source file
 */
private void processFile(File src) throws BuildException {
  if (!src.exists()) {
    throw new BuildException(""String_Node_Str"" + src.getPath() + ""String_Node_Str"",location);
  }
  File temp=new File(src.getPath() + ""String_Node_Str"");
  if (temp.exists()) {
    throw new BuildException(""String_Node_Str"" + temp.getPath() + ""String_Node_Str"",location);
  }
  try {
    Reader fileReader=encoding == null ? new FileReader(src) : new InputStreamReader(new FileInputStream(src),encoding);
    Writer fileWriter=encoding == null ? new FileWriter(temp) : new OutputStreamWriter(new FileOutputStream(temp),encoding);
    BufferedReader br=new BufferedReader(fileReader);
    BufferedWriter bw=new BufferedWriter(fileWriter);
    int fileLengthInBytes=(int)(src.length());
    StringBuffer tmpBuf=new StringBuffer(fileLengthInBytes);
    int readChar=0;
    int totread=0;
    while (true) {
      readChar=br.read();
      if (readChar < 0) {
        break;
      }
      tmpBuf.append((char)readChar);
      totread++;
    }
    String buf=tmpBuf.toString();
    String newString=new String(buf);
    if (token != null) {
      String linesep=System.getProperty(""String_Node_Str"");
      String val=stringReplace(value.getText(),""String_Node_Str"",linesep);
      String tok=stringReplace(token.getText(),""String_Node_Str"",linesep);
      log(""String_Node_Str"" + src.getPath() + ""String_Node_Str""+ token.getText()+ ""String_Node_Str""+ value.getText(),Project.MSG_VERBOSE);
      newString=stringReplace(newString,tok,val);
    }
    if (replacefilters.size() > 0) {
      newString=processReplacefilters(newString,src.getPath());
    }
    boolean changes=!newString.equals(buf);
    if (changes) {
      bw.write(newString,0,newString.length());
      bw.flush();
    }
    bw.close();
    br.close();
    if (changes) {
      ++fileCount;
      src.delete();
      temp.renameTo(src);
    }
 else {
      temp.delete();
    }
  }
 catch (  IOException ioe) {
    throw new BuildException(""String_Node_Str"" + src + ""String_Node_Str""+ ioe.getClass().getName()+ ""String_Node_Str""+ ioe.getMessage(),ioe,location);
  }
}",0.9969352014010509
64362,"/** 
 * Apply a template on a part of the xml document.
 * @param root root of the document fragment
 * @param xslfile style file
 * @param outfilename filename of the result of the style applied on the Node
 * @throws SAXException SAX Parsing Error on the style Sheet.
 */
protected void transform(Node root,String xslname,String htmlname) throws SAXException {
  try {
    final long t0=System.currentTimeMillis();
    XSLTInputSource xsl_source=getXSLStreamSource(xslname);
    XSLTProcessor processor=XSLTProcessorFactory.getProcessor();
    File htmlfile=new File(toDir,htmlname);
    File dir=new File(htmlfile.getParent());
    if (!dir.exists()) {
      dir.mkdirs();
    }
    task.log(""String_Node_Str"" + xslname + ""String_Node_Str""+ htmlfile+ ""String_Node_Str"",Project.MSG_VERBOSE);
    processor.process(new XSLTInputSource(root),xsl_source,new XSLTResultTarget(htmlfile.getAbsolutePath()));
    final long dt=System.currentTimeMillis() - t0;
    task.log(""String_Node_Str"" + xslname + ""String_Node_Str""+ dt+ ""String_Node_Str"");
  }
 catch (  IOException e) {
    task.log(e.getMessage(),Project.MSG_ERR);
    e.printStackTrace();
    throw new SAXException(e.getMessage());
  }
}","/** 
 * Apply a template on a part of the xml document.
 * @param root root of the document fragment
 * @param xslfile style file
 * @param outfilename filename of the result of the style applied on the Node
 * @throws SAXException SAX Parsing Error on the style Sheet.
 */
protected void transform(Node root,String xslname,String htmlname) throws SAXException {
  try {
    XSLTInputSource xsl_source=getXSLStreamSource(xslname);
    XSLTProcessor processor=XSLTProcessorFactory.getProcessor();
    File htmlfile=new File(toDir,htmlname);
    File dir=new File(htmlfile.getParent());
    if (!dir.exists()) {
      dir.mkdirs();
    }
    task.log(""String_Node_Str"" + xslname + ""String_Node_Str""+ htmlfile+ ""String_Node_Str"",Project.MSG_VERBOSE);
    processor.process(new XSLTInputSource(root),xsl_source,new XSLTResultTarget(htmlfile.getAbsolutePath()));
  }
 catch (  IOException e) {
    task.log(e.getMessage(),Project.MSG_ERR);
    e.printStackTrace();
    throw new SAXException(e.getMessage());
  }
}",0.9168559745570196
64363,"/** 
 * default xsls are embedded in the distribution jar. As a default we will use them, otherwise we will get the one supplied by the client in a given directory. It must have the same name.
 */
protected XSLTInputSource getXSLStreamSource(String name) throws IOException {
  InputStream in;
  String systemId;
  if (styleDir == null) {
    in=getResourceAsStream(""String_Node_Str"" + name);
    systemId=getClass().getResource(""String_Node_Str"" + name).toString();
  }
 else {
    File f=new File(styleDir,name);
    in=new FileInputStream(f);
    systemId=f.getAbsolutePath();
  }
  XSLTInputSource ss=new XSLTInputSource(in);
  ss.setSystemId(systemId);
  return ss;
}","/** 
 * default xsls are embedded in the distribution jar. As a default we will use them, otherwise we will get the one supplied by the client in a given directory. It must have the same name.
 */
protected XSLTInputSource getXSLStreamSource(String name) throws IOException {
  InputStream in;
  String systemId;
  if (styleDir == null) {
    in=getResourceAsStream(""String_Node_Str"" + name);
    systemId=getClass().getResource(""String_Node_Str"" + name).toString();
  }
 else {
    File f=new File(styleDir,name);
    in=new FileInputStream(f);
    systemId=""String_Node_Str"" + f.getAbsolutePath();
  }
  XSLTInputSource ss=new XSLTInputSource(in);
  ss.setSystemId(systemId);
  return ss;
}",0.9853372434017597
64364,"public void init(String propType,AttributeList attrs) throws SAXParseException {
  try {
    element=project.createDataType(propType);
    if (element == null) {
      throw new BuildException(""String_Node_Str"" + propType);
    }
    configureId(element,attrs);
    if (target != null) {
      wrapper=new RuntimeConfigurable(element);
      wrapper.setAttributes(attrs);
      target.addDataType(wrapper);
    }
 else {
      configure(element,attrs,project);
    }
  }
 catch (  BuildException exc) {
    throw new SAXParseException(exc.getMessage(),locator,exc);
  }
}","public void init(String propType,AttributeList attrs) throws SAXParseException {
  try {
    element=project.createDataType(propType);
    if (element == null) {
      throw new BuildException(""String_Node_Str"" + propType);
    }
    if (target != null) {
      wrapper=new RuntimeConfigurable(element);
      wrapper.setAttributes(attrs);
      target.addDataType(wrapper);
    }
 else {
      configure(element,attrs,project);
      configureId(element,attrs);
    }
  }
 catch (  BuildException exc) {
    throw new SAXParseException(exc.getMessage(),locator,exc);
  }
}",0.9423076923076924
64365,"public void setupDirectoryScanner(FileScanner ds,Project p){
  if (ds == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ds.setBasedir(dir);
  for (int i=0; i < additionalPatterns.size(); i++) {
    Object o=additionalPatterns.elementAt(i);
    defaultPatterns.append((PatternSet)o,p);
  }
  ds.setIncludes(defaultPatterns.getIncludePatterns(p));
  ds.setExcludes(defaultPatterns.getExcludePatterns(p));
  if (useDefaultExcludes)   ds.addDefaultExcludes();
}","public void setupDirectoryScanner(FileScanner ds,Project p){
  if (ds == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ds.setBasedir(dir);
  for (int i=0; i < additionalPatterns.size(); i++) {
    Object o=additionalPatterns.elementAt(i);
    defaultPatterns.append((PatternSet)o,p);
  }
  p.log(""String_Node_Str"" + dir + ""String_Node_Str""+ defaultPatterns,p.MSG_DEBUG);
  ds.setIncludes(defaultPatterns.getIncludePatterns(p));
  ds.setExcludes(defaultPatterns.getExcludePatterns(p));
  if (useDefaultExcludes)   ds.addDefaultExcludes();
}",0.9208770257387988
64366,"/** 
 * Create a type instance based on name.
 * @param name the name
 * @return the type instance
 * @exception TypeException if an error occurs
 */
public Object create(final String name) throws TypeException {
  TypeFactory factory=getTypeFactory(name);
  if (null == factory && null != m_parent) {
    m_parent.getTypeFactory(name);
  }
  if (null == factory)   return null;
 else {
    final Object object=factory.create(name);
    if (!m_type.isInstance(object)) {
      throw new TypeException(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ m_type.getName()+ ""String_Node_Str"");
    }
    return object;
  }
}","/** 
 * Create a type instance based on name.
 * @param name the name
 * @return the type instance
 * @exception TypeException if an error occurs
 */
public Object create(final String name) throws TypeException {
  TypeFactory factory=getTypeFactory(name);
  if (null == factory && null != m_parent) {
    factory=m_parent.getTypeFactory(name);
  }
  if (null == factory) {
    throw new TypeException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
 else {
    final Object object=factory.create(name);
    if (!m_type.isInstance(object)) {
      throw new TypeException(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ m_type.getName()+ ""String_Node_Str"");
    }
    return object;
  }
}",0.92548435171386
64367,"/** 
 * Find the list of environment variables for this process.
 */
public static synchronized Vector getProcEnvironment(){
  if (procEnvironment != null)   return procEnvironment;
  procEnvironment=new Vector();
  try {
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    Execute exe=new Execute(new PumpStreamHandler(out));
    exe.setCommandline(getProcEnvCommand());
    exe.setNewenvironment(true);
    int retval=exe.execute();
    if (retval != 0) {
    }
    BufferedReader in=new BufferedReader(new StringReader(out.toString()));
    String line;
    while ((line=in.readLine()) != null) {
      procEnvironment.addElement(line);
    }
  }
 catch (  java.io.IOException exc) {
    exc.printStackTrace();
  }
  return procEnvironment;
}","/** 
 * Find the list of environment variables for this process.
 */
public static synchronized Vector getProcEnvironment(){
  if (procEnvironment != null)   return procEnvironment;
  procEnvironment=new Vector();
  try {
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    Execute exe=new Execute(new PumpStreamHandler(out));
    exe.setCommandline(getProcEnvCommand());
    exe.setNewenvironment(true);
    int retval=exe.execute();
    if (retval != 0) {
    }
    BufferedReader in=new BufferedReader(new StringReader(out.toString()));
    String var=null;
    String line, lineSep=System.getProperty(""String_Node_Str"");
    while ((line=in.readLine()) != null) {
      if (line.indexOf('=') == -1) {
        if (var == null) {
          var=lineSep + line;
        }
 else {
          var+=lineSep + line;
        }
      }
 else {
        if (var != null) {
          procEnvironment.addElement(var);
        }
        var=line;
      }
    }
    procEnvironment.addElement(var);
  }
 catch (  java.io.IOException exc) {
    exc.printStackTrace();
  }
  return procEnvironment;
}",0.775377969762419
64368,"protected void loadEnvironment(String prefix){
  Properties props=new Properties();
  if (!prefix.endsWith(""String_Node_Str""))   prefix+=""String_Node_Str"";
  log(""String_Node_Str"" + prefix,Project.MSG_VERBOSE);
  try {
    Vector osEnv=Execute.getProcEnvironment();
    for (Enumeration e=osEnv.elements(); e.hasMoreElements(); ) {
      String entry=(String)e.nextElement();
      int pos=entry.indexOf('=');
      props.put(prefix + entry.substring(0,pos),entry.substring(pos + 1));
    }
    addProperties(props);
  }
 catch (  Exception ex) {
    throw new BuildException(ex,location);
  }
}","protected void loadEnvironment(String prefix){
  Properties props=new Properties();
  if (!prefix.endsWith(""String_Node_Str""))   prefix+=""String_Node_Str"";
  log(""String_Node_Str"" + prefix,Project.MSG_VERBOSE);
  try {
    Vector osEnv=Execute.getProcEnvironment();
    for (Enumeration e=osEnv.elements(); e.hasMoreElements(); ) {
      String entry=(String)e.nextElement();
      int pos=entry.indexOf('=');
      if (pos == -1) {
        log(""String_Node_Str"" + entry,Project.MSG_WARN);
      }
 else {
        props.put(prefix + entry.substring(0,pos),entry.substring(pos + 1));
      }
    }
    addProperties(props);
  }
 catch (  Exception ex) {
    throw new BuildException(ex,location);
  }
}",0.9182098765432098
64369,"/** 
 * Execute P4 command assembled by subclasses.
 * @param command The command to run
 * @param p4input Input to be fed to command on stdin
 * @param handler A P4Handler to process any input and output
 */
protected void execP4Command(String command,P4Handler handler) throws BuildException {
  try {
    Commandline commandline=new Commandline();
    commandline.setExecutable(""String_Node_Str"");
    commandline.createArgument().setValue(P4Port);
    commandline.createArgument().setValue(P4User);
    commandline.createArgument().setValue(P4Client);
    commandline.createArgument().setLine(command);
    log(""String_Node_Str"" + commandline.getCommandline(),Project.MSG_VERBOSE);
    if (handler == null)     handler=new SimpleP4OutputHandler(this);
    Execute exe=new Execute(handler,null);
    exe.setAntRun(project);
    exe.setCommandline(commandline.getCommandline());
    try {
      exe.execute();
    }
 catch (    IOException e) {
      throw new BuildException(e);
    }
 finally {
      try {
        handler.stop();
      }
 catch (      Exception e) {
      }
    }
  }
 catch (  Exception e) {
    throw new BuildException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Execute P4 command assembled by subclasses.
 * @param command The command to run
 * @param p4input Input to be fed to command on stdin
 * @param handler A P4Handler to process any input and output
 */
protected void execP4Command(String command,P4Handler handler) throws BuildException {
  try {
    Commandline commandline=new Commandline();
    commandline.setExecutable(""String_Node_Str"");
    if (P4Port != null && P4Port.length() != 0) {
      commandline.createArgument().setValue(P4Port);
    }
    if (P4User != null && P4User.length() != 0) {
      commandline.createArgument().setValue(P4User);
    }
    if (P4Client != null && P4Client.length() != 0) {
      commandline.createArgument().setValue(P4Client);
    }
    commandline.createArgument().setLine(command);
    log(""String_Node_Str"" + commandline.getCommandline(),Project.MSG_VERBOSE);
    if (handler == null)     handler=new SimpleP4OutputHandler(this);
    Execute exe=new Execute(handler,null);
    exe.setAntRun(project);
    exe.setCommandline(commandline.getCommandline());
    try {
      exe.execute();
    }
 catch (    IOException e) {
      throw new BuildException(e);
    }
 finally {
      try {
        handler.stop();
      }
 catch (      Exception e) {
      }
    }
  }
 catch (  Exception e) {
    throw new BuildException(""String_Node_Str"" + e.getMessage());
  }
}",0.9301960784313724
64370,"/** 
 * Called when an event is to be posed to the member.
 * @param event Event to post.
 * @return true if event should be propogated, false ifit should be cancelled.
 */
public boolean eventPosted(EventObject event){
  ElementSelectionEvent e=(ElementSelectionEvent)event;
  String text=_defText;
  ACSElement[] selected=e.getSelectedElements();
  if (selected != null && selected.length > 0) {
    StringBuffer buf=new StringBuffer();
    for (int i=0; i < selected.length; i++) {
      if (selected[i] instanceof ACSTargetElement) {
        if (buf.length() > 0) {
          buf.append(""String_Node_Str"");
        }
        buf.append(((ACSTargetElement)selected[i]).getName());
      }
    }
    if (buf.length() > 0) {
      text=buf.toString();
    }
  }
  setText(text);
  return true;
}","/** 
 * Called when an event is to be posed to the member.
 * @param event Event to post.
 * @return true if event should be propogated, false ifit should be cancelled.
 */
public boolean eventPosted(EventObject event){
  ElementSelectionEvent e=(ElementSelectionEvent)event;
  String text=_defText;
  ACSElement[] selected=e.getSelectedElements();
  if (selected != null && selected.length > 0) {
    StringBuffer buf=new StringBuffer();
    String name=null;
    for (int i=0; i < selected.length; i++) {
      if (selected[i] instanceof ACSTargetElement) {
        name=((ACSTargetElement)selected[i]).getName();
        if (buf.toString().indexOf(name) < 0) {
          if (buf.length() > 0) {
            buf.append(""String_Node_Str"");
          }
          buf.append(name);
        }
      }
    }
    if (buf.length() > 0) {
      text=buf.toString();
    }
  }
  setText(text);
  return true;
}",0.7557386698057681
64371,"public void actionPerformed(ActionEvent e){
  JFileChooser chooser=null;
  if (_widget.getText().length() > 0) {
    chooser=new JFileChooser(_widget.getText());
  }
 else {
    chooser=new JFileChooser();
  }
  _filter=(_filter == null ? chooser.getAcceptAllFileFilter() : _filter);
  chooser.setFileFilter(_filter);
  chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
  if (chooser.showDialog(getChild(),""String_Node_Str"") == JFileChooser.APPROVE_OPTION) {
    Object oldValue=getValue();
    Object newValue=chooser.getSelectedFile();
    setValue(newValue);
    firePropertyChange(oldValue,newValue);
  }
}","public void actionPerformed(ActionEvent e){
  JFileChooser chooser=null;
  chooser=new JFileChooser();
  chooser.setSelectedFile((File)getValue());
  _filter=(_filter == null ? chooser.getAcceptAllFileFilter() : _filter);
  chooser.setFileFilter(_filter);
  chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
  if (chooser.showDialog(getChild(),""String_Node_Str"") == JFileChooser.APPROVE_OPTION) {
    Object oldValue=getValue();
    Object newValue=chooser.getSelectedFile();
    setValue(newValue);
    firePropertyChange(oldValue,newValue);
  }
}",0.8521008403361344
64372,"public void actionPerformed(ActionEvent e){
  JFileChooser chooser=null;
  if (_widget.getText().length() > 0) {
    chooser=new JFileChooser(_widget.getText());
  }
 else   if (_path != null) {
    chooser=new JFileChooser(_path);
  }
 else {
    chooser=new JFileChooser();
  }
  _filter=(_filter == null ? chooser.getAcceptAllFileFilter() : _filter);
  chooser.setFileFilter(_filter);
  chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
  if (chooser.showDialog(getChild(),""String_Node_Str"") == JFileChooser.APPROVE_OPTION) {
    setValue(chooser.getSelectedFile());
  }
}","public void actionPerformed(ActionEvent e){
  JFileChooser chooser=null;
  if (_widget.getText().length() > 0) {
    chooser=new JFileChooser(_widget.getText());
  }
 else {
    chooser=new JFileChooser();
  }
  _filter=(_filter == null ? chooser.getAcceptAllFileFilter() : _filter);
  chooser.setFileFilter(_filter);
  chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
  if (chooser.showDialog(getChild(),""String_Node_Str"") == JFileChooser.APPROVE_OPTION) {
    Object oldValue=getValue();
    Object newValue=chooser.getSelectedFile();
    setValue(newValue);
    firePropertyChange(oldValue,newValue);
  }
}",0.8414133114215283
64373,"/** 
 * Default ctor.
 */
public FilePropertyEditor(){
  _container=new JPanel(new BorderLayout());
  _widget=new JTextField(){
    public boolean isManagingFocus(){
      return false;
    }
  }
;
  _widget.addFocusListener(new FocusHandler(this));
  _container.add(_widget,BorderLayout.CENTER);
  JButton b=new JButton(""String_Node_Str"");
  b.addActionListener(new ActionHandler());
  _container.add(b,BorderLayout.EAST);
}","/** 
 * Default ctor.
 */
public FilePropertyEditor(){
  _container=new JPanel(new BorderLayout());
  _widget=new JTextField();
  _widget.addFocusListener(new FocusHandler(this));
  _container.add(_widget,BorderLayout.CENTER);
  JButton b=new JButton(""String_Node_Str"");
  b.addActionListener(new ActionHandler());
  _container.add(b,BorderLayout.EAST);
}",0.9102564102564102
64374,"/** 
 * Called when an event is to be posted to the member.
 * @param event Event to post.
 * @return true if event should be propogated, false ifit should be cancelled.
 */
public boolean eventPosted(EventObject event){
  ElementSelectionEvent e=(ElementSelectionEvent)event;
  ACSElement[] elements=e.getSelectedElements();
  updateDisplay(elements);
  return true;
}","/** 
 * Called when an event is to be posted to the member.
 * @param event Event to post.
 * @return true if event should be propogated, false ifit should be cancelled.
 */
public boolean eventPosted(EventObject event){
  if (event instanceof ProjectClosedEvent) {
    updateDisplay(null);
  }
 else {
    ElementSelectionEvent e=(ElementSelectionEvent)event;
    ACSElement[] elements=e.getSelectedElements();
    updateDisplay(elements);
  }
  return true;
}",0.8891566265060241
64375,"/** 
 * Determines if the given event should be accepted.
 * @param event Event to test.
 * @return True if event should be given to BusMember, false otherwise.
 */
public boolean accept(EventObject event){
  return event instanceof ElementSelectionEvent;
}","/** 
 * Determines if the given event should be accepted.
 * @param event Event to test.
 * @return True if event should be given to BusMember, false otherwise.
 */
public boolean accept(EventObject event){
  return event instanceof ElementSelectionEvent || event instanceof ProjectClosedEvent;
}",0.929475587703436
64376,"/** 
 * Update the display for the current items. 
 * @param items Current items to display.
 */
private void updateDisplay(ACSElement[] items){
  if (_customizer != null) {
    _container.remove((Component)_customizer);
    _customizer=null;
  }
  if (items != null && items.length > 0) {
    ACSElement item=items[items.length - 1];
    try {
      BeanInfo info=Introspector.getBeanInfo(item.getClass());
      _customizer=(Customizer)info.getBeanDescriptor().getCustomizerClass().newInstance();
      _customizer.setObject(item);
      _container.add(BorderLayout.CENTER,(Component)_customizer);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
  }
  _container.repaint();
}","/** 
 * Update the display for the current items. 
 * @param items Current items to display.
 */
private void updateDisplay(ACSElement[] items){
  if (_customizer != null) {
    _container.remove((Component)_customizer);
    _customizer=null;
  }
  if (items != null && items.length > 0) {
    ACSElement item=items[items.length - 1];
    try {
      BeanInfo info=Introspector.getBeanInfo(item.getClass());
      _customizer=(Customizer)info.getBeanDescriptor().getCustomizerClass().newInstance();
      _customizer.setObject(item);
      _container.add(BorderLayout.CENTER,(Component)_customizer);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
  }
  _container.validate();
  _container.repaint();
}",0.9823819591261452
64377,"/** 
 * Save the project to the current file name.
 */
public void run(){
  FileFilter filter=new XMLFileFilter(getContext().getResources());
  if (_project == null) {
    _project=getContext().getSelectionManager().getSelectedProject();
  }
  if (_project != null) {
    if (_location == null) {
      JFileChooser chooser=new JFileChooser();
      chooser.addChoosableFileFilter(filter);
      int val=chooser.showSaveDialog(getContext().getParentFrame());
      if (val == JFileChooser.APPROVE_OPTION) {
        File file=chooser.getSelectedFile();
        if (file.exists()) {
          String title=getContext().getResources().getString(SaveCmd.class,""String_Node_Str"");
          String message=getContext().getResources().getMessage(SaveCmd.class,""String_Node_Str"",new Object[]{file.toString()});
          val=JOptionPane.showConfirmDialog(getContext().getParentFrame(),message,title,JOptionPane.YES_NO_OPTION);
          if (val == JOptionPane.YES_OPTION) {
            try {
              _location=new URL(""String_Node_Str"",null,file.getAbsolutePath());
            }
 catch (            MalformedURLException ex) {
              ex.printStackTrace();
            }
          }
        }
      }
    }
    if (_location != null) {
      try {
        getContext().getProjectManager().saveAs(_project,_location);
      }
 catch (      IOException ex) {
        String message=getContext().getResources().getMessage(SaveCmd.class,""String_Node_Str"",new Object[]{_location.toString()});
        getContext().getEventBus().postEvent(new ErrorEvent(getContext(),message));
      }
    }
  }
 else {
    String message=getContext().getResources().getString(SaveCmd.class,""String_Node_Str"");
    getContext().getEventBus().postEvent(new ErrorEvent(getContext(),message));
  }
}","/** 
 * Save the project to the current file name.
 */
public void run(){
  FileFilter filter=new XMLFileFilter(getContext().getResources());
  if (_project == null) {
    _project=getContext().getSelectionManager().getSelectedProject();
  }
  if (_project != null) {
    if (_location == null) {
      JFileChooser chooser=new JFileChooser();
      chooser.addChoosableFileFilter(filter);
      int val=chooser.showSaveDialog(getContext().getParentFrame());
      if (val == JFileChooser.APPROVE_OPTION) {
        File file=chooser.getSelectedFile();
        if (file.exists()) {
          String title=getContext().getResources().getString(SaveCmd.class,""String_Node_Str"");
          String message=getContext().getResources().getMessage(SaveCmd.class,""String_Node_Str"",new Object[]{file.toString()});
          val=JOptionPane.showConfirmDialog(getContext().getParentFrame(),message,title,JOptionPane.YES_NO_OPTION);
          if (val != JOptionPane.YES_OPTION) {
            return;
          }
        }
        try {
          _location=new URL(""String_Node_Str"",null,file.getAbsolutePath());
        }
 catch (        MalformedURLException ex) {
          ex.printStackTrace();
        }
      }
    }
    if (_location != null) {
      try {
        getContext().getProjectManager().saveAs(_project,_location);
      }
 catch (      IOException ex) {
        String message=getContext().getResources().getMessage(SaveCmd.class,""String_Node_Str"",new Object[]{_location.toString()});
        getContext().getEventBus().postEvent(new ErrorEvent(getContext(),message,ex));
      }
    }
  }
 else {
    String message=getContext().getResources().getString(SaveCmd.class,""String_Node_Str"");
    getContext().getEventBus().postEvent(new ErrorEvent(getContext(),message));
  }
}",0.9761168867659454
64378,"/** 
 * Load a project from the given XML file. XXX fix me.
 * @param f File to load.
 * @return 
 */
public ACSProjectElement load(File f) throws IOException, SAXException {
  XmlDocument doc=null;
  try {
    SAXParser sax=SAXParserFactory.newInstance().newSAXParser();
    Parser parser=(Parser)sax.getParser();
    XmlDocumentBuilder builder=new XmlDocumentBuilder();
    builder.setIgnoringLexicalInfo(false);
    SimpleElementFactory fact=new SimpleElementFactory();
    fact.addMapping(_elementMap,ACSFactory.class.getClassLoader());
    builder.setElementFactory(fact);
    parser.setDocumentHandler(builder);
    parser.setEntityResolver(new Resolver());
    sax.parse(f,null);
    doc=builder.getDocument();
  }
 catch (  ParserConfigurationException ex) {
    ex.printStackTrace();
    throw new IOException(ex.getMessage());
  }
  return (ACSProjectElement)doc.getDocumentElement();
}","/** 
 * Load a project from the given XML file. XXX fix me.
 * @param location Location of the file.
 * @return Loaded project.
 */
public ACSProjectElement load(URL location) throws IOException {
  XmlDocument doc=null;
  try {
    SAXParser sax=SAXParserFactory.newInstance().newSAXParser();
    Parser parser=(Parser)sax.getParser();
    XmlDocumentBuilder builder=new XmlDocumentBuilder();
    builder.setIgnoringLexicalInfo(false);
    SimpleElementFactory fact=new SimpleElementFactory();
    fact.addMapping(_elementMap,ACSFactory.class.getClassLoader());
    builder.setElementFactory(fact);
    parser.setDocumentHandler(builder);
    parser.setEntityResolver(new Resolver());
    sax.parse(location.openStream(),null);
    doc=builder.getDocument();
  }
 catch (  ParserConfigurationException ex) {
    ex.printStackTrace();
    throw new IOException(ex.getMessage());
  }
catch (  SAXException ex) {
    ex.printStackTrace();
    throw new IOException(ex.getMessage());
  }
  return (ACSProjectElement)doc.getDocumentElement();
}",0.8915289256198347
64379,"/** 
 * Standard ctor.
 * @param bus Event bus to post events to.
 */
public ActionManager(EventBus bus){
  _bus=bus;
  bus.addMember(EventBus.RESPONDING,new Enabler());
  _mapper=new EventToActionMapper();
  String toTok=_resources.getString(""String_Node_Str"");
  StringTokenizer tok=new StringTokenizer(toTok,""String_Node_Str"");
  _actionIDs=new String[tok.countTokens()];
  for (int i=0; i < _actionIDs.length; i++) {
    _actionIDs[i]=tok.nextToken();
    AntAction action=new AntAction(_resources,_bus,_actionIDs[i]);
    _actions.put(_actionIDs[i],action);
    _mapper.addAction(action);
  }
}","/** 
 * Standard ctor.
 * @param bus Event bus to post events to.
 * @param resources Location of resources.
 */
public ActionManager(EventBus bus,ResourceManager resources){
  _bus=bus;
  _resources=resources;
  bus.addMember(EventBus.RESPONDING,new Enabler());
  _mapper=new EventToActionMapper();
  String[] names=_resources.getStringArray(""String_Node_Str"");
  _actionIDs=new String[names.length];
  for (int i=0; i < _actionIDs.length; i++) {
    _actionIDs[i]=names[i];
    AntAction action=new AntAction(_resources,_bus,_actionIDs[i]);
    _actions.put(_actionIDs[i],action);
    _mapper.addAction(action);
  }
}",0.8095238095238095
64380,"/** 
 * Standard ctor.
 * @param id Unique id for the action
 */
public AntAction(ResourceBundle resources,EventBus bus,String id){
  _resources=resources;
  _bus=bus;
  _id=id;
  putValue(NAME,getString(""String_Node_Str""));
  putValue(SHORT_DESCRIPTION,getString(""String_Node_Str""));
  putValue(PARENT_MENU_NAME,getString(PARENT_MENU_NAME));
  putValue(SEPARATOR,getString(SEPARATOR));
  String enabled=getString(ENABLED);
  if (enabled != null) {
    setEnabled(Boolean.valueOf(enabled).booleanValue());
  }
  String accelerator=getString(ACCELERATOR);
  if (accelerator != null) {
    putValue(ACCELERATOR,KeyStroke.getKeyStroke(accelerator));
  }
  String toggle=getString(TOGGLE);
  if (toggle != null) {
    _toggle=Boolean.valueOf(toggle).booleanValue();
  }
  String command=getString(COMMAND);
  if (command != null) {
    try {
      Class cmd=Class.forName(command);
      putValue(COMMAND,cmd);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
  }
  String iconName=getString(""String_Node_Str"");
  if (iconName != null) {
    try {
      URL imageLoc=AntAction.class.getResource(""String_Node_Str"" + iconName);
      if (imageLoc != null) {
        putValue(SMALL_ICON,new ImageIcon(imageLoc));
      }
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
  }
  _enableOn=resolveClasses(getString(ENABLE_ON));
  _disableOn=resolveClasses(getString(DISABLE_ON));
}","/** 
 * Standard ctor.
 * @param id Unique id for the action
 */
public AntAction(ResourceManager resources,EventBus bus,String id){
  _resources=resources;
  _bus=bus;
  _id=id;
  putValue(NAME,getString(""String_Node_Str""));
  putValue(SHORT_DESCRIPTION,getString(""String_Node_Str""));
  putValue(PARENT_MENU_NAME,getString(PARENT_MENU_NAME));
  putValue(SEPARATOR,getString(SEPARATOR));
  String enabled=getString(ENABLED);
  if (enabled != null) {
    setEnabled(Boolean.valueOf(enabled).booleanValue());
  }
  String accelerator=getString(ACCELERATOR);
  if (accelerator != null) {
    putValue(ACCELERATOR,KeyStroke.getKeyStroke(accelerator));
  }
  String toggle=getString(TOGGLE);
  if (toggle != null) {
    _toggle=Boolean.valueOf(toggle).booleanValue();
  }
  String command=getString(COMMAND);
  if (command != null) {
    try {
      Class cmd=Class.forName(command);
      putValue(COMMAND,cmd);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
  }
  String iconName=getString(""String_Node_Str"");
  if (iconName != null) {
    putValue(SMALL_ICON,_resources.loadImageIcon(iconName));
  }
  _enableOn=resolveClasses(getString(ENABLE_ON));
  _disableOn=resolveClasses(getString(DISABLE_ON));
}",0.9049429657794676
64381,"/** 
 * Generate a composit key from the given class and key name.
 * @param clazz Class to find resource for.
 * @param name Name of the resource.
 * @return Composite key.
 */
private String getKey(Class clazz,String name){
  return clazz.getName() + ""String_Node_Str"" + name;
}","/** 
 * Generate a composit key from the given class and key name.
 * @param clazz Class to find resource for.
 * @param name Name of the resource.
 * @return Composite key.
 */
private String getKey(Class clazz,String name){
  name=name == null ? ""String_Node_Str"" : name;
  return clazz == null ? name : clazz.getName() + ""String_Node_Str"" + name;
}",0.8684627575277337
64382,"/** 
 * Generate a localized message using the given set of arguments to  format the message with.
 * @param clazz Class to get message resource for.
 * @param name 
 * @param arguments 
 * @return 
 */
public String getMessage(Class clazz,String name,Object[] arguments){
  String format=getString(clazz,name);
  return MessageFormat.format(format,arguments);
}","/** 
 * Generate a localized message using the given set of arguments to  format the message with.
 * @param clazz Class to get message resource for.
 * @param name Name of the message.
 * @param arguments Arguments to the message.
 * @return The formatted message.
 */
public String getMessage(Class clazz,String name,Object[] arguments){
  String format=getString(clazz,name);
  return MessageFormat.format(format,arguments);
}",0.9152970922882429
64383,"/** 
 * Get an array of string resources for the given class.
 * @param clazz Class to get resource for.
 * @param name Name of the string resource.
 * @return Array of string resources for the given class.
 */
public String[] getStringArray(Class clazz,String name){
  if (clazz == null || name == null) {
    return null;
  }
  String key=getKey(clazz,name);
  String toTok=null;
  try {
    toTok=_resources.getString(key);
  }
 catch (  MissingResourceException ex) {
  }
  if (toTok == null) {
    return _resources.getStringArray(key);
  }
 else {
    StringTokenizer tok=new StringTokenizer(toTok,""String_Node_Str"");
    String[] retval=new String[tok.countTokens()];
    for (int i=0; i < retval.length; i++) {
      retval[i]=tok.nextToken();
    }
    return retval;
  }
}","/** 
 * Get an array of string resources for the given class.
 * @param clazz Class to get resource for.
 * @param name Name of the string resource.
 * @return Array of string resources for the given class.
 */
public String[] getStringArray(Class clazz,String name){
  if (name == null) {
    return null;
  }
  String key=getKey(clazz,name);
  String toTok=null;
  try {
    toTok=_resources.getString(key);
  }
 catch (  MissingResourceException ex) {
  }
  if (toTok == null) {
    return _resources.getStringArray(key);
  }
 else {
    StringTokenizer tok=new StringTokenizer(toTok,""String_Node_Str"");
    String[] retval=new String[tok.countTokens()];
    for (int i=0; i < retval.length; i++) {
      retval[i]=tok.nextToken();
    }
    return retval;
  }
}",0.989010989010989
64384,"/** 
 * Get a string resource for the given class.
 * @param clazz Class to get resource for.
 * @param name Name of the string resource.
 * @return String resource for the given class.
 */
public String getString(Class clazz,String name){
  if (clazz == null || name == null) {
    return null;
  }
  return _resources.getString(getKey(clazz,name));
}","/** 
 * Get a string resource for the given class.
 * @param clazz Class to get resource for.
 * @param name Name of the string resource.
 * @return String resource for the given class.
 */
public String getString(Class clazz,String name){
  if (name == null) {
    return null;
  }
  return _resources.getString(getKey(clazz,name));
}",0.975254730713246
64385,"/** 
 * Get the image as an ImageIcon with the given file name.  For example ""open.gif"". The image is loaded from the resources package.
 * @param fileName Image file to load.
 * @return Image as an ImageIcon, or null if not found.
 */
public ImageIcon getImageIcon(String fileName){
  if (fileName == null)   return null;
  ImageIcon icon=null;
  URL location=getClass().getResource(IMG_PATH + ""String_Node_Str"" + fileName);
  if (location != null) {
    icon=new ImageIcon(location);
  }
  return icon;
}","/** 
 * Get the image as an ImageIcon assigned to the given class with the given key.
 * @param clazz The class to load icon for.
 * @param key The key for looking up the icon.
 * @return Image as an ImageIcon, or null if not found.
 */
public ImageIcon getImageIcon(Class clazz,String key){
  return loadImageIcon(getString(clazz,key));
}",0.2177514792899408
64386,"/** 
 * Iterate over the given Vector of relocatablefilesets and add all files to the ZipOutputStream using the given prefix.
 */
protected void addPrefixedFiles(Vector v,ZipOutputStream zOut) throws IOException {
  for (int i=0; i < v.size(); i++) {
    PrefixedFileSet fs=(PrefixedFileSet)v.elementAt(i);
    DirectoryScanner ds=fs.getDirectoryScanner(project);
    String prefix=fs.getPrefix();
    if (prefix.length() > 0 && !prefix.endsWith(""String_Node_Str"") && !prefix.endsWith(""String_Node_Str"")) {
      prefix+=""String_Node_Str"";
    }
    zipDir(null,zOut,prefix);
    addFiles(ds,zOut,prefix);
  }
}","/** 
 * Iterate over the given Vector of prefixedfilesets and add all files to the ZipOutputStream using the given prefix.
 */
protected void addPrefixedFiles(Vector v,ZipOutputStream zOut) throws IOException {
  for (int i=0; i < v.size(); i++) {
    PrefixedFileSet fs=(PrefixedFileSet)v.elementAt(i);
    DirectoryScanner ds=fs.getDirectoryScanner(project);
    String prefix=fs.getPrefix();
    if (prefix.length() > 0 && !prefix.endsWith(""String_Node_Str"") && !prefix.endsWith(""String_Node_Str"")) {
      prefix+=""String_Node_Str"";
    }
    if (prefix.length() > 0) {
      addParentDirs(null,prefix,zOut,""String_Node_Str"");
      zipDir(null,zOut,prefix);
    }
    addFiles(ds,zOut,prefix);
  }
}",0.8638783269961977
64387,"public void execute() throws BuildException {
  if (baseDir == null && filesets.size() == 0 && ""String_Node_Str"".equals(archiveType))   throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
  if (zipFile == null) {
    throw new BuildException(""String_Node_Str"" + archiveType + ""String_Node_Str"");
  }
  Vector dss=new Vector();
  if (baseDir != null)   dss.addElement(getDirectoryScanner(baseDir));
  for (int i=0; i < filesets.size(); i++) {
    FileSet fs=(FileSet)filesets.elementAt(i);
    dss.addElement(fs.getDirectoryScanner(project));
  }
  int dssSize=dss.size();
  FileScanner[] scanners=new FileScanner[dssSize + locFileSets.size()];
  dss.copyInto(scanners);
  addScanners(scanners,dssSize,locFileSets);
  if (isUpToDate(scanners,zipFile))   return;
  log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ zipFile.getAbsolutePath());
  try {
    ZipOutputStream zOut=new ZipOutputStream(new FileOutputStream(zipFile));
    try {
      if (doCompress) {
        zOut.setMethod(ZipOutputStream.DEFLATED);
      }
 else {
        zOut.setMethod(ZipOutputStream.STORED);
      }
      initZipOutputStream(zOut);
      addPrefixedFiles(locFileSets,zOut);
      for (int j=0; j < dssSize; j++) {
        addFiles(scanners[j],zOut,""String_Node_Str"");
      }
    }
  finally {
      zOut.close();
    }
  }
 catch (  IOException ioe) {
    String msg=""String_Node_Str"" + archiveType + ""String_Node_Str""+ ioe.getMessage();
    if (!zipFile.delete()) {
      msg+=""String_Node_Str"";
    }
    throw new BuildException(msg,ioe,location);
  }
}","public void execute() throws BuildException {
  if (baseDir == null && filesets.size() == 0 && locFileSets.size() == 0 && ""String_Node_Str"".equals(archiveType)) {
    throw new BuildException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (zipFile == null) {
    throw new BuildException(""String_Node_Str"" + archiveType + ""String_Node_Str"");
  }
  Vector dss=new Vector();
  if (baseDir != null)   dss.addElement(getDirectoryScanner(baseDir));
  for (int i=0; i < filesets.size(); i++) {
    FileSet fs=(FileSet)filesets.elementAt(i);
    dss.addElement(fs.getDirectoryScanner(project));
  }
  int dssSize=dss.size();
  FileScanner[] scanners=new FileScanner[dssSize + locFileSets.size()];
  dss.copyInto(scanners);
  addScanners(scanners,dssSize,locFileSets);
  if (isUpToDate(scanners,zipFile))   return;
  log(""String_Node_Str"" + archiveType + ""String_Node_Str""+ zipFile.getAbsolutePath());
  try {
    boolean success=false;
    ZipOutputStream zOut=new ZipOutputStream(new FileOutputStream(zipFile));
    try {
      if (doCompress) {
        zOut.setMethod(ZipOutputStream.DEFLATED);
      }
 else {
        zOut.setMethod(ZipOutputStream.STORED);
      }
      initZipOutputStream(zOut);
      addPrefixedFiles(locFileSets,zOut);
      for (int j=0; j < dssSize; j++) {
        addFiles(scanners[j],zOut,""String_Node_Str"");
        success=true;
      }
    }
  finally {
      try {
        if (zOut != null)         zOut.close();
      }
 catch (      IOException ex) {
        if (success)         throw ex;
      }
    }
  }
 catch (  IOException ioe) {
    String msg=""String_Node_Str"" + archiveType + ""String_Node_Str""+ ioe.getMessage();
    if (!zipFile.delete()) {
      msg+=""String_Node_Str"";
    }
    throw new BuildException(msg,ioe,location);
  }
}",0.9282497748423896
64388,"/** 
 * File loading ctor.
 * @param file File containing build file to load.
 */
public ProjectProxy(AppContext context,File file) throws IOException {
  _file=file;
  _context=context;
  loadProject();
}","/** 
 * File loading ctor.
 * @param file File containing build file to load.
 */
public ProjectProxy(AppContext context,File file) throws IOException, SAXException {
  _file=file;
  _context=context;
  loadProject();
}",0.9669811320754716
64389,"/** 
 * Load the project from the build file.
 */
private void loadProject() throws IOException {
  _project=ACSFactory.getInstance().load(_file);
  _selections=new ElementSelectionModel();
  _selections.addTreeSelectionListener(new SelectionForwarder());
}","/** 
 * Load the project from the build file.
 */
private void loadProject() throws IOException, SAXException {
  _project=ACSFactory.getInstance().load(_file);
  _selections=new ElementSelectionModel();
  _selections.addTreeSelectionListener(new SelectionForwarder());
}",0.9734848484848484
64390,"/** 
 * Scans the directory looking for source files to be compiled.   The results are returned in the class variable compileList
 */
protected void scanDir(File srcDir,File destDir,String files[]){
  GlobPatternMapper m=new GlobPatternMapper();
  m.setFrom(""String_Node_Str"");
  m.setTo(""String_Node_Str"");
  SourceFileScanner sfs=new SourceFileScanner(this);
  compileList=sfs.restrictAsFiles(files,srcDir,destDir,m);
}","/** 
 * Scans the directory looking for source files to be compiled.   The results are returned in the class variable compileList
 */
protected void scanDir(File srcDir,File destDir,String files[]){
  GlobPatternMapper m=new GlobPatternMapper();
  m.setFrom(""String_Node_Str"");
  m.setTo(""String_Node_Str"");
  SourceFileScanner sfs=new SourceFileScanner(this);
  File[] newFiles=sfs.restrictAsFiles(files,srcDir,destDir,m);
  if (newFiles.length > 0) {
    File[] newCompileList=new File[compileList.length + newFiles.length];
    System.arraycopy(compileList,0,newCompileList,0,compileList.length);
    System.arraycopy(newFiles,0,newCompileList,compileList.length,newFiles.length);
    compileList=newCompileList;
  }
}",0.7180385288966725
64391,"/** 
 * Ensure we have a consistent and legal set of attributes, and set any internal flags necessary based on different combinations  of attributes.
 */
protected void validateAttributes() throws BuildException {
  if (file == null && filesets.size() == 0) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destFile != null && destDir != null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destFile == null && destDir == null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (file != null && destFile != null && file.exists() && file.isDirectory()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destFile != null && filesets.size() > 0) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destFile != null) {
    destDir=new File(destFile.getParent());
  }
}","/** 
 * Ensure we have a consistent and legal set of attributes, and set any internal flags necessary based on different combinations  of attributes.
 */
protected void validateAttributes() throws BuildException {
  if (file == null && filesets.size() == 0) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destFile != null && destDir != null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destFile == null && destDir == null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (file != null && file.exists() && file.isDirectory()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destFile != null && filesets.size() > 0) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destFile != null) {
    destDir=new File(destFile.getParent());
  }
}",0.9876543209876544
64392,"protected ExecuteStreamHandler createHandler() throws BuildException {
  if (out != null) {
    try {
      fos=new FileOutputStream(out);
      log(""String_Node_Str"" + out,Project.MSG_VERBOSE);
      return new PumpStreamHandler(fos);
    }
 catch (    FileNotFoundException fne) {
      throw new BuildException(""String_Node_Str"" + out,fne,location);
    }
  }
 else {
    return new LogStreamHandler(this,Project.MSG_INFO,Project.MSG_WARN);
  }
}","protected ExecuteStreamHandler createHandler() throws BuildException {
  if (out != null) {
    try {
      fos=new FileOutputStream(out);
      log(""String_Node_Str"" + out,Project.MSG_VERBOSE);
      return new PumpStreamHandler(fos);
    }
 catch (    FileNotFoundException fne) {
      throw new BuildException(""String_Node_Str"" + out,fne,location);
    }
catch (    IOException ioe) {
      throw new BuildException(""String_Node_Str"" + out,ioe,location);
    }
  }
 else {
    return new LogStreamHandler(this,Project.MSG_INFO,Project.MSG_WARN);
  }
}",0.8944223107569721
64393,"public void execute() throws BuildException {
  if (target == null || !target.isFile()) {
    throw new BuildException(""String_Node_Str"" + target);
  }
  final File javaFile=new File(target.toString().substring(0,target.toString().indexOf(""String_Node_Str"")) + ""String_Node_Str"");
  if (javaFile.exists() && target.lastModified() < javaFile.lastModified()) {
    project.log(""String_Node_Str"" + target + ""String_Node_Str"");
    return;
  }
  cmdl.createArgument().setValue(target.getAbsolutePath());
  if (metahome == null || !metahome.isDirectory()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (metaworkingdir == null || !metaworkingdir.isDirectory()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (userclasspath == null) {
    throw new BuildException(""String_Node_Str"");
  }
  final Path classpath=cmdl.createClasspath();
  classpath.createPathElement().setLocation(metahome.getAbsolutePath() + ""String_Node_Str"");
  classpath.createPathElement().setLocation(metahome.getAbsolutePath() + ""String_Node_Str"");
  classpath.createPathElement().setLocation(metahome.getAbsolutePath() + ""String_Node_Str"");
  final Commandline.Argument arg=cmdl.createVmArgument();
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"" + metaworkingdir.getAbsolutePath());
  arg.setValue(""String_Node_Str"" + metahome.getAbsolutePath());
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"" + userclasspath);
  final Execute process=new Execute(new LogStreamHandler(this,Project.MSG_INFO,Project.MSG_INFO),null);
  log(cmdl.toString(),Project.MSG_VERBOSE);
  process.setCommandline(cmdl.getCommandline());
  try {
    try {
      if (process.execute() != 0) {
        throw new BuildException(""String_Node_Str"");
      }
    }
  finally {
      if (cleanupHack) {
        final File oo393=new File(javaFile.getParentFile(),""String_Node_Str"");
        if (oo393.exists()) {
          project.log(""String_Node_Str"" + oo393.getName());
          oo393.delete();
        }
        final File sunjj=new File(javaFile.getParentFile(),""String_Node_Str"" + javaFile.getName().substring(0,javaFile.getName().indexOf(""String_Node_Str"")) + ""String_Node_Str"");
        if (sunjj.exists()) {
          project.log(""String_Node_Str"" + sunjj.getName());
          sunjj.delete();
        }
      }
    }
  }
 catch (  IOException e) {
    throw new BuildException(""String_Node_Str"" + e);
  }
}","public void execute() throws BuildException {
  if (target == null || !target.isFile()) {
    throw new BuildException(""String_Node_Str"" + target);
  }
  final File javaFile=new File(target.toString().substring(0,target.toString().indexOf(""String_Node_Str"")) + ""String_Node_Str"");
  if (javaFile.exists() && target.lastModified() < javaFile.lastModified()) {
    project.log(""String_Node_Str"" + target + ""String_Node_Str"");
    return;
  }
  cmdl.createArgument().setValue(target.getAbsolutePath());
  if (metahome == null || !metahome.isDirectory()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (metaworkingdir == null || !metaworkingdir.isDirectory()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (userclasspath == null) {
    throw new BuildException(""String_Node_Str"");
  }
  final Path classpath=cmdl.createClasspath();
  classpath.createPathElement().setLocation(metahome.getAbsolutePath() + ""String_Node_Str"");
  classpath.createPathElement().setLocation(metahome.getAbsolutePath() + ""String_Node_Str"");
  classpath.createPathElement().setLocation(metahome.getAbsolutePath() + ""String_Node_Str"");
  final Commandline.Argument arg=cmdl.createVmArgument();
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"" + metaworkingdir.getAbsolutePath());
  arg.setValue(""String_Node_Str"" + metahome.getAbsolutePath());
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"");
  arg.setValue(""String_Node_Str"" + userclasspath);
  final Execute process=new Execute(new LogStreamHandler(this,Project.MSG_INFO,Project.MSG_INFO),null);
  log(cmdl.toString(),Project.MSG_VERBOSE);
  process.setCommandline(cmdl.getCommandline());
  try {
    try {
      if (process.execute() != 0) {
        throw new BuildException(""String_Node_Str"");
      }
    }
  finally {
      if (cleanupHack) {
        final File oo393=new File(javaFile.getParent(),""String_Node_Str"");
        if (oo393.exists()) {
          project.log(""String_Node_Str"" + oo393.getName());
          oo393.delete();
        }
        final File sunjj=new File(javaFile.getParent(),""String_Node_Str"" + javaFile.getName().substring(0,javaFile.getName().indexOf(""String_Node_Str"")) + ""String_Node_Str"");
        if (sunjj.exists()) {
          project.log(""String_Node_Str"" + sunjj.getName());
          sunjj.delete();
        }
      }
    }
  }
 catch (  IOException e) {
    throw new BuildException(""String_Node_Str"" + e);
  }
}",0.9984939759036144
64394,"/** 
 * Return the package name of the given java source file. This method performs valid java parsing to figure out the package.
 */
private String getPackageName(File file){
  String name=null;
  try {
    BufferedReader reader=new BufferedReader(new JavaReader(new BufferedReader(new FileReader(file))));
    String line;
    while (true) {
      line=reader.readLine();
      if (line == null) {
        log(""String_Node_Str"" + file,Project.MSG_WARN);
        return null;
      }
      if (line.trim().startsWith(""String_Node_Str"")) {
        name=line.substring(8,line.indexOf(""String_Node_Str"")).trim();
        break;
      }
    }
    reader.close();
  }
 catch (  Exception e) {
    log(""String_Node_Str"" + e + ""String_Node_Str""+ file,Project.MSG_WARN);
    return null;
  }
  log(file + ""String_Node_Str"" + name,Project.MSG_VERBOSE);
  return name;
}","/** 
 * Return the package name of the given java source file. This method performs valid java parsing to figure out the package.
 */
private String getPackageName(File file){
  String name=null;
  try {
    BufferedReader reader=new BufferedReader(new JavaReader(new BufferedReader(new FileReader(file))));
    String line;
    while (true) {
      line=reader.readLine();
      if (line == null) {
        log(""String_Node_Str"" + file,Project.MSG_WARN);
        return null;
      }
      if (line.trim().startsWith(""String_Node_Str"") || line.trim().startsWith(""String_Node_Str"")) {
        name=line.substring(8,line.indexOf(""String_Node_Str"")).trim();
        break;
      }
    }
    reader.close();
  }
 catch (  Exception e) {
    log(""String_Node_Str"" + e + ""String_Node_Str""+ file,Project.MSG_WARN);
    return null;
  }
  log(file + ""String_Node_Str"" + name,Project.MSG_VERBOSE);
  return name;
}",0.9745331069609507
64395,"public void setTag(String p){
  this.tag=p;
}","public void setTag(String p){
  if (p != null) {
    if (p.trim().equals(""String_Node_Str""))     p=null;
  }
  this.tag=p;
}",0.5325443786982249
64396,"/** 
 * Executes the task.
 */
public void execute() throws BuildException {
  if (srcDir == null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (!srcDir.exists()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (!srcDir.isDirectory()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destDir != null) {
    if (!destDir.exists()) {
      throw new BuildException(""String_Node_Str"");
    }
    if (!destDir.isDirectory()) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  project.log(""String_Node_Str"" + ""String_Node_Str"" + (addcr == -1 ? ""String_Node_Str"" : addcr == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (addtab == -1 ? ""String_Node_Str"" : addtab == 0 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (ctrlz == -1 ? ""String_Node_Str"" : ctrlz == 0 ? ""String_Node_Str"" : ""String_Node_Str""),""String_Node_Str"",project.MSG_VERBOSE);
  DirectoryScanner ds=super.getDirectoryScanner(srcDir);
  String[] files=ds.getIncludedFiles();
  try {
    for (int i=0; i < files.length; i++) {
      File srcFile=new File(srcDir,files[i]);
      int count=(int)srcFile.length();
      byte indata[]=new byte[count];
      try {
        FileInputStream inStream=new FileInputStream(srcFile);
        inStream.read(indata);
        inStream.close();
      }
 catch (      IOException e) {
        throw new BuildException(e);
      }
      int cr=0;
      int lf=0;
      int tab=0;
      for (int k=0; k < count; k++) {
        byte c=indata[k];
        if (c == '\r')         cr++;
        if (c == '\n')         lf++;
        if (c == '\t')         tab++;
      }
      boolean eof=((count > 0) && (indata[count - 1] == 0x1A));
      project.log(srcFile + ""String_Node_Str"" + count+ ""String_Node_Str""+ cr+ ""String_Node_Str""+ lf+ ""String_Node_Str""+ tab+ ""String_Node_Str""+ eof,""String_Node_Str"",project.MSG_VERBOSE);
      int outsize=count;
      if (addcr != 0)       outsize-=cr;
      if (addcr == +1)       outsize+=lf;
      if (addtab == -1)       outsize+=tab * 7;
      if (ctrlz == +1)       outsize+=1;
      byte outdata[]=new byte[outsize];
      int o=0;
      int line=o;
      int col=0;
      for (int k=0; k < count; k++) {
switch (indata[k]) {
case ' ':
          if (addtab == 0)           outdata[o++]=indata[k];
        col++;
      break;
case '\t':
    if (addtab == 0) {
      outdata[o++]=indata[k];
      col++;
    }
 else {
      col=(col | 7) + 1;
    }
  break;
case '\r':
if (addcr == 0) {
  outdata[o++]=indata[k];
  col++;
}
break;
case '\n':
if (addcr == +1) outdata[o++]='\r';
outdata[o++]='\n';
line=o;
col=0;
break;
default :
if (addtab > 0 && o + 1 < line + col) {
int diff=o - line;
while ((diff | 7) < col) {
outdata[o++]='\t';
line-=7 - (diff & 7);
diff=o - line;
}
;
}
;
while (o < line + col) outdata[o++]=' ';
outdata[o++]=indata[k];
col++;
}
}
if (ctrlz == +1) {
if (outdata[o - 1] != 0x1A) outdata[o++]=0x1A;
}
 else if (ctrlz == -1) {
if (o > 2 && outdata[o - 1] == 0x0A && outdata[o - 2] == 0x1A) o--;
if (o > 1 && outdata[o - 1] == 0x1A) o--;
}
try {
File destFile=srcFile;
if (destDir != null) destFile=new File(destDir,files[i]);
FileOutputStream outStream=new FileOutputStream(destFile);
outStream.write(outdata,0,o);
outStream.close();
}
 catch (IOException e) {
throw new BuildException(e);
}
}
}
 catch (Exception e) {
e.printStackTrace();
throw new BuildException(e);
}
}","/** 
 * Executes the task.
 */
public void execute() throws BuildException {
  if (srcDir == null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (!srcDir.exists()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (!srcDir.isDirectory()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (destDir != null) {
    if (!destDir.exists()) {
      throw new BuildException(""String_Node_Str"");
    }
    if (!destDir.isDirectory()) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  project.log(""String_Node_Str"" + ""String_Node_Str"" + (addcr == -1 ? ""String_Node_Str"" : addcr == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (addtab == -1 ? ""String_Node_Str"" : addtab == 0 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (ctrlz == -1 ? ""String_Node_Str"" : ctrlz == 0 ? ""String_Node_Str"" : ""String_Node_Str""),""String_Node_Str"",project.MSG_VERBOSE);
  DirectoryScanner ds=super.getDirectoryScanner(srcDir);
  String[] files=ds.getIncludedFiles();
  try {
    for (int i=0; i < files.length; i++) {
      File srcFile=new File(srcDir,files[i]);
      int count=(int)srcFile.length();
      byte indata[]=new byte[count];
      try {
        FileInputStream inStream=new FileInputStream(srcFile);
        inStream.read(indata);
        inStream.close();
      }
 catch (      IOException e) {
        throw new BuildException(e);
      }
      int cr=0;
      int lf=0;
      int tab=0;
      for (int k=0; k < count; k++) {
        byte c=indata[k];
        if (c == '\r')         cr++;
        if (c == '\n')         lf++;
        if (c == '\t')         tab++;
      }
      boolean eof=((count > 0) && (indata[count - 1] == 0x1A));
      project.log(srcFile + ""String_Node_Str"" + count+ ""String_Node_Str""+ cr+ ""String_Node_Str""+ lf+ ""String_Node_Str""+ tab+ ""String_Node_Str""+ eof,""String_Node_Str"",project.MSG_VERBOSE);
      int outsize=count;
      if (addcr != 0)       outsize-=cr;
      if (addcr == +1)       outsize+=lf;
      if (addtab == -1)       outsize+=tab * 7;
      if (ctrlz == +1)       outsize+=1;
      byte outdata[]=new byte[outsize];
      int o=0;
      int line=o;
      int col=0;
      for (int k=0; k < count; k++) {
switch (indata[k]) {
case ' ':
          if (addtab == 0)           outdata[o++]=(byte)' ';
        col++;
      break;
case '\t':
    if (addtab == 0) {
      outdata[o++]=(byte)'\t';
      col++;
    }
 else {
      col=(col | 7) + 1;
    }
  break;
case '\r':
if (addcr == 0) {
  outdata[o++]=(byte)'\r';
  col++;
}
break;
case '\n':
if (addcr == +1) outdata[o++]=(byte)'\r';
outdata[o++]=(byte)'\n';
line=o;
col=0;
break;
default :
if (addtab > 0 && o + 1 < line + col) {
int diff=o - line;
while ((diff | 7) < col) {
outdata[o++]=(byte)'\t';
line-=7 - (diff & 7);
diff=o - line;
}
;
}
;
while (o < line + col) outdata[o++]=(byte)' ';
outdata[o++]=indata[k];
col++;
}
}
if (ctrlz == +1) {
if (outdata[o - 1] != 0x1A) outdata[o++]=0x1A;
}
 else if (ctrlz == -1) {
if (o > 2 && outdata[o - 1] == 0x0A && outdata[o - 2] == 0x1A) o--;
if (o > 1 && outdata[o - 1] == 0x1A) o--;
}
try {
File destFile=srcFile;
if (destDir != null) destFile=new File(destDir,files[i]);
FileOutputStream outStream=new FileOutputStream(destFile);
outStream.write(outdata,0,o);
outStream.close();
}
 catch (IOException e) {
throw new BuildException(e);
}
}
}
 catch (Exception e) {
e.printStackTrace();
throw new BuildException(e);
}
}",0.9598946135831382
64397,"public void addAttachment(String filePath,String fileName) throws Exception {
  BodyPart messageBodyPart=new MimeBodyPart();
  DataSource source=new FileDataSource(filePath);
  messageBodyPart.setDataHandler(new DataHandler(source));
  messageBodyPart.setFileName(fileName);
  multipart.addBodyPart(messageBodyPart);
}","public void addAttachment(String filePath,String fileName) throws Exception {
  BodyPart messageBodyPart=new MimeBodyPart();
  ((MimeBodyPart)messageBodyPart).attachFile(filePath);
  multipart.addBodyPart(messageBodyPart);
}",0.4870848708487085
64398,"public boolean send() throws MessagingException {
  if (!user.equals(""String_Node_Str"") && !pass.equals(""String_Node_Str"") && !to.equals(""String_Node_Str"")&& !from.equals(""String_Node_Str"")) {
    Session session=Session.getDefaultInstance(props,this);
    Log.d(""String_Node_Str"",host + ""String_Node_Str"" + port+ ""String_Node_Str""+ user+ ""String_Node_Str""+ pass);
    MimeMessage msg=new MimeMessage(session);
    msg.setFrom(new InternetAddress(from));
    InternetAddress addressTo=new InternetAddress(to);
    msg.setRecipient(MimeMessage.RecipientType.TO,addressTo);
    msg.setSubject(subject);
    msg.setSentDate(new Date());
    BodyPart messageBodyPart=new MimeBodyPart();
    messageBodyPart.setText(body);
    multipart.addBodyPart(messageBodyPart);
    msg.setContent(multipart);
    Transport.send(msg);
    return true;
  }
 else {
    return false;
  }
}","public boolean send() throws MessagingException {
  if (!user.equals(""String_Node_Str"") && !pass.equals(""String_Node_Str"") && !to.equals(""String_Node_Str"")&& !from.equals(""String_Node_Str"")) {
    Session session=Session.getDefaultInstance(props,this);
    Log.d(""String_Node_Str"",host + ""String_Node_Str"" + port+ ""String_Node_Str""+ user+ ""String_Node_Str""+ pass);
    MimeMessage msg=new MimeMessage(session);
    msg.setFrom(new InternetAddress(from));
    InternetAddress addressTo=new InternetAddress(to);
    msg.setRecipient(MimeMessage.RecipientType.TO,addressTo);
    msg.setSubject(subject);
    msg.setSentDate(new Date());
    BodyPart messageBodyPart=new MimeBodyPart();
    messageBodyPart.setText(body);
    multipart.addBodyPart(messageBodyPart,0);
    msg.setContent(multipart);
    Transport.send(msg);
    return true;
  }
 else {
    return false;
  }
}",0.9988518943742823
64399,"/** 
 * Construct the mean and standard deviation Previews for one specific  parameter value.
 * @param numEntriesPerPreview
 * @param numParamValues
 * @param paramValue
 */
private void constructMeanStdPreviewsForParam(int numEntriesPerPreview,int numParamValues,int paramValue){
  List<double[]> meanParamMeasurements=calculateMeanMeasurementsForParam(numEntriesPerPreview,numParamValues,paramValue);
  List<double[]> stdParamMeasurements=calculateStdMeasurementsForParam(numEntriesPerPreview,numParamValues,paramValue,meanParamMeasurements);
  String[] meanMeasurementNames=this.origMultiRunPreviews.getMeasurementNames();
  meanMeasurementNames=Arrays.copyOfRange(meanMeasurementNames,4,meanMeasurementNames.length);
  String[] stdMeasurementNames=new String[meanMeasurementNames.length];
  for (int m=0; m < meanMeasurementNames.length; m++) {
    stdMeasurementNames[m]=""String_Node_Str"" + meanMeasurementNames[m + 4];
  }
  LearningCurve meanLearningCurve=new LearningCurve(""String_Node_Str"");
  meanLearningCurve.setData(Arrays.asList(meanMeasurementNames),meanParamMeasurements);
  LearningCurve stdLearningCurve=new LearningCurve(""String_Node_Str"");
  stdLearningCurve.setData(Arrays.asList(stdMeasurementNames),stdParamMeasurements);
  Preview meanParamValuePreview=new PreviewCollectionLearningCurveWrapper(meanLearningCurve,this.origMultiRunPreviews.taskClass);
  Preview stdParamValuePreview=new PreviewCollectionLearningCurveWrapper(stdLearningCurve,this.origMultiRunPreviews.taskClass);
  this.meanPreviews.setPreview(paramValue,meanParamValuePreview);
  this.stdPreviews.setPreview(paramValue,stdParamValuePreview);
}","/** 
 * Construct the mean and standard deviation Previews for one specific  parameter value.
 * @param numEntriesPerPreview
 * @param numParamValues
 * @param paramValue
 */
private void constructMeanStdPreviewsForParam(int numEntriesPerPreview,int numParamValues,int paramValue){
  List<double[]> meanParamMeasurements=calculateMeanMeasurementsForParam(numEntriesPerPreview,numParamValues,paramValue);
  List<double[]> stdParamMeasurements=calculateStdMeasurementsForParam(numEntriesPerPreview,numParamValues,paramValue,meanParamMeasurements);
  String[] meanMeasurementNames=this.origMultiRunPreviews.getMeasurementNames();
  meanMeasurementNames=Arrays.copyOfRange(meanMeasurementNames,4,meanMeasurementNames.length);
  String[] stdMeasurementNames=new String[meanMeasurementNames.length];
  for (int m=0; m < meanMeasurementNames.length; m++) {
    stdMeasurementNames[m]=""String_Node_Str"" + meanMeasurementNames[m];
  }
  LearningCurve meanLearningCurve=new LearningCurve(""String_Node_Str"");
  meanLearningCurve.setData(Arrays.asList(meanMeasurementNames),meanParamMeasurements);
  LearningCurve stdLearningCurve=new LearningCurve(""String_Node_Str"");
  stdLearningCurve.setData(Arrays.asList(stdMeasurementNames),stdParamMeasurements);
  Preview meanParamValuePreview=new PreviewCollectionLearningCurveWrapper(meanLearningCurve,this.origMultiRunPreviews.taskClass);
  Preview stdParamValuePreview=new PreviewCollectionLearningCurveWrapper(stdLearningCurve,this.origMultiRunPreviews.taskClass);
  this.meanPreviews.setPreview(paramValue,meanParamValuePreview);
  this.stdPreviews.setPreview(paramValue,stdParamValuePreview);
}",0.9987752602571952
64400,"@Override protected Object doMainTask(TaskMonitor monitor,ObjectRepository repository){
  Object result=null;
  Task taskBase=(Task)task;
  for (int i=0; i < this.numStreamsOption.getValue(); i++) {
    this.task=(Task)((MOAObject)taskBase).copy();
    result=this.task.doTask(monitor,repository);
  }
  return result;
}","@Override protected Object doMainTask(TaskMonitor monitor,ObjectRepository repository){
  Object result=null;
  String arffFile, outputFile;
  FileStream fStream;
  for (int i=0; i < this.numStreamsOption.getValue(); i++) {
    this.task=new EvaluateClustering();
    this.task.learnerOption.setValueViaCLIString(this.learnerOption.getValueAsCLIString());
    fStream=(FileStream)getPreparedClassOption(this.streamOption);
    arffFile=fStream.arffFileOption.getValueAsCLIString();
    arffFile=arffFile.substring(0,arffFile.length() - 6).concat(i + ""String_Node_Str"");
    fStream.arffFileOption.setValueViaCLIString(arffFile);
    this.task.streamOption.setValueViaCLIString(fStream.getCLICreationString(fStream.getClass()));
    outputFile=this.dumpFileOption.getValueAsCLIString();
    if (outputFile.substring(outputFile.length() - 4,outputFile.length()).equals(""String_Node_Str"")) {
      outputFile=outputFile.substring(0,outputFile.length() - 4);
    }
    outputFile=outputFile.concat(""String_Node_Str"" + i + ""String_Node_Str"");
    this.task.dumpFileOption.setValueViaCLIString(outputFile);
    this.task.instanceLimitOption.setValue(-1);
    this.task.measureCollectionTypeOption.setValue(0);
    System.out.println(this.task.getCLICreationString(this.task.getClass()));
    result=this.task.doTask(monitor,repository);
  }
  return result;
}",0.2665869695158398
64401,"@Override protected Object doMainTask(TaskMonitor monitor,ObjectRepository repository){
  String streamCLI=this.streamOption.getValueAsCLIString();
  String fileCLI=this.arffFileOption.getValueAsCLIString();
  for (int i=0; i < this.numStreamsOption.getValue(); i++) {
    String s=streamCLI;
    if (this.randomFlagOne.isSet()) {
      s=s.concat(""String_Node_Str"" + randomOneOption.getValue() + ""String_Node_Str""+ WriteMultipleStreamsToARFF.primesAndBiprimes[i]);
    }
    if (this.randomFlagTwo.isSet()) {
      System.out.println(""String_Node_Str"" + randomTwoOption.getValue());
      s=s.concat(""String_Node_Str"" + randomTwoOption.getValue() + ""String_Node_Str""+ WriteMultipleStreamsToARFF.primesAndBiprimes[i / WriteMultipleStreamsToARFF.primesAndBiprimes.length]);
    }
    this.streamOption.setValueViaCLIString(s);
    s=fileCLI;
    if (s.substring(s.length() - 5,s.length()).equals(""String_Node_Str"")) {
      s=s.substring(0,s.length() - 5);
    }
    s=s.concat(""String_Node_Str"" + i + ""String_Node_Str"");
    this.arffFileOption.setValueViaCLIString(s);
    File destFile=this.arffFileOption.getFile();
    if (destFile != null) {
      try {
        Writer w=new BufferedWriter(new FileWriter(destFile));
        System.out.println(""String_Node_Str"" + this.streamOption.getValueAsCLIString() + ""String_Node_Str""+ this.arffFileOption.getValueAsCLIString());
        monitor.setCurrentActivityDescription(""String_Node_Str"" + this.streamOption.getValueAsCLIString() + ""String_Node_Str""+ this.arffFileOption.getValueAsCLIString());
        if (!this.suppressHeaderOption.isSet()) {
          w.write(stream.getHeader().toString());
          w.write(""String_Node_Str"");
        }
        int numWritten=0;
        while ((numWritten < this.maxInstancesOption.getValue()) && stream.hasMoreInstances()) {
          w.write(stream.nextInstance().getData().toString());
          w.write(""String_Node_Str"");
          numWritten++;
        }
        w.close();
      }
 catch (      Exception ex) {
        throw new RuntimeException(""String_Node_Str"" + destFile,ex);
      }
    }
  }
  return ""String_Node_Str"";
}","@Override protected Object doMainTask(TaskMonitor monitor,ObjectRepository repository){
  String streamCLI=this.streamOption.getValueAsCLIString();
  String fileCLI=this.arffFileOption.getValueAsCLIString();
  stream=(InstanceStream)getPreparedClassOption(this.streamOption);
  for (int i=0; i < this.numStreamsOption.getValue(); i++) {
    String s=streamCLI;
    if (this.randomFlagOne.isSet()) {
      s=s.concat(""String_Node_Str"" + randomOneOption.getValue() + ""String_Node_Str""+ WriteMultipleStreamsToARFF.primesAndBiprimes[i]);
    }
    if (this.randomFlagTwo.isSet()) {
      System.out.println(""String_Node_Str"" + randomTwoOption.getValue());
      s=s.concat(""String_Node_Str"" + randomTwoOption.getValue() + ""String_Node_Str""+ WriteMultipleStreamsToARFF.primesAndBiprimes[i / WriteMultipleStreamsToARFF.primesAndBiprimes.length]);
    }
    this.streamOption.setValueViaCLIString(s);
    s=fileCLI;
    if (s.substring(s.length() - 5,s.length()).equals(""String_Node_Str"")) {
      s=s.substring(0,s.length() - 5);
    }
    s=s.concat(""String_Node_Str"" + i + ""String_Node_Str"");
    this.arffFileOption.setValueViaCLIString(s);
    File destFile=this.arffFileOption.getFile();
    if (destFile != null) {
      try {
        Writer w=new BufferedWriter(new FileWriter(destFile));
        System.out.println(""String_Node_Str"" + this.streamOption.getValueAsCLIString() + ""String_Node_Str""+ this.arffFileOption.getValueAsCLIString());
        monitor.setCurrentActivityDescription(""String_Node_Str"" + this.streamOption.getValueAsCLIString() + ""String_Node_Str""+ this.arffFileOption.getValueAsCLIString());
        if (!this.suppressHeaderOption.isSet()) {
          w.write(stream.getHeader().toString());
          w.write(""String_Node_Str"");
        }
        int numWritten=0;
        while ((numWritten < this.maxInstancesOption.getValue()) && stream.hasMoreInstances()) {
          w.write(stream.nextInstance().getData().toString());
          w.write(""String_Node_Str"");
          numWritten++;
        }
        w.close();
      }
 catch (      Exception ex) {
        throw new RuntimeException(""String_Node_Str"" + destFile,ex);
      }
    }
  }
  return ""String_Node_Str"";
}",0.9842446709916588
64402,"/** 
 * Performs classwise kMeans++ clustering for given samples with corresponding labels. The number of samples is halved per class.
 */
private void clusterDown(){
  int classIndex=this.ltm.classIndex();
  for (int c=0; c <= this.maxClassValue; c++) {
    List<double[]> classSamples=new ArrayList<>();
    for (int i=this.ltm.numInstances() - 1; i > -1; i--) {
      if (this.ltm.get(i).classValue() == c) {
        classSamples.add(this.ltm.get(i).toDoubleArray());
        this.ltm.delete(i);
      }
    }
    for (    double[] sample : classSamples) {
      if (classIndex != 0) {
        sample[classIndex]=sample[0];
      }
      sample[0]=1;
    }
    List<double[]> centroids=this.kMeans(classSamples,Math.max(classSamples.size() / 2,1));
    for (    double[] centroid : centroids) {
      double[] attributes=new double[this.ltm.numAttributes()];
      System.arraycopy(centroid,0,attributes,1,this.ltm.numAttributes() - 1);
      if (classIndex != 0) {
        attributes[0]=attributes[classIndex];
      }
      attributes[classIndex]=c;
      Instance inst=new InstanceImpl(1,attributes);
      inst.setDataset(this.ltm);
      this.ltm.add(inst);
    }
  }
}","/** 
 * Performs classwise kMeans++ clustering for given samples with corresponding labels. The number of samples is halved per class.
 */
private void clusterDown(){
  int classIndex=this.ltm.classIndex();
  for (int c=0; c <= this.maxClassValue; c++) {
    List<double[]> classSamples=new ArrayList<>();
    for (int i=this.ltm.numInstances() - 1; i > -1; i--) {
      if (this.ltm.get(i).classValue() == c) {
        classSamples.add(this.ltm.get(i).toDoubleArray());
        this.ltm.delete(i);
      }
    }
    if (classSamples.size() > 0) {
      for (      double[] sample : classSamples) {
        if (classIndex != 0) {
          sample[classIndex]=sample[0];
        }
        sample[0]=1;
      }
      List<double[]> centroids=this.kMeans(classSamples,Math.max(classSamples.size() / 2,1));
      for (      double[] centroid : centroids) {
        double[] attributes=new double[this.ltm.numAttributes()];
        System.arraycopy(centroid,0,attributes,1,this.ltm.numAttributes() - 1);
        if (classIndex != 0) {
          attributes[0]=attributes[classIndex];
        }
        attributes[classIndex]=c;
        Instance inst=new InstanceImpl(1,attributes);
        inst.setDataset(this.ltm);
        this.ltm.add(inst);
      }
    }
  }
}",0.9470225872689938
64403,"/** 
 * Generates the initial centroids like the k-means++ algorithm.
 * @param k number of centroids
 * @param input input clustering
 * @param random instance to generate a stream of pseudorandom numbers
 * @return the generated centroids
 */
public static List<double[]> generatekMeansPlusPlusCentroids(int k,List<double[]> input,Random random){
  int n=input.size();
  assert(n > 0);
  int d=input.get(0).length - 1;
  assert(k <= n);
  List<double[]> centerValue=new ArrayList<double[]>(k);
  double[] lastCenter=new double[d];
  System.arraycopy(input.get(random.nextInt(n)),1,lastCenter,0,d);
  centerValue.add(lastCenter);
  double[] distance=new double[n];
  for (int j=0; j < n; j++) {
    distance[j]=Double.POSITIVE_INFINITY;
  }
  for (int i=1; i < k; i++) {
    double sum=0.0;
    Iterator<double[]> jIter=input.iterator();
    for (int j=0; j < n; j++) {
      double[] point=jIter.next();
      distance[j]=Math.min(distance[j],point[0] * Metric.distanceSquared(lastCenter,point,1));
      sum+=distance[j];
    }
    double nextCenterValue=sum * random.nextDouble();
    double currentValue=distance[0];
    int candidate=0;
    while (!(nextCenterValue < currentValue)) {
      currentValue+=distance[++candidate];
    }
    lastCenter=new double[d];
    System.arraycopy(input.get(candidate),1,lastCenter,0,d);
    centerValue.add(lastCenter);
  }
  return centerValue;
}","/** 
 * Generates the initial centroids like the k-means++ algorithm.
 * @param k number of centroids
 * @param input input clustering
 * @param random instance to generate a stream of pseudorandom numbers
 * @return the generated centroids
 */
public static List<double[]> generatekMeansPlusPlusCentroids(int k,List<double[]> input,Random random){
  int n=input.size();
  assert(n > 0);
  int d=input.get(0).length - 1;
  assert(k <= n);
  List<double[]> centerValue=new ArrayList<double[]>(k);
  double[] lastCenter=new double[d];
  System.arraycopy(input.get(random.nextInt(n)),1,lastCenter,0,d);
  centerValue.add(lastCenter);
  double[] distance=new double[n];
  for (int j=0; j < n; j++) {
    distance[j]=Double.POSITIVE_INFINITY;
  }
  for (int i=1; i < k; i++) {
    double sum=0.0;
    Iterator<double[]> jIter=input.iterator();
    for (int j=0; j < n; j++) {
      double[] point=jIter.next();
      distance[j]=Math.min(distance[j],point[0] * Metric.distanceSquared(lastCenter,point,1));
      sum+=distance[j];
    }
    int candidate=0;
    if (sum > 0) {
      double nextCenterValue=sum * random.nextDouble();
      double currentValue=distance[0];
      while (!(nextCenterValue < currentValue)) {
        currentValue+=distance[++candidate];
      }
    }
    lastCenter=new double[d];
    System.arraycopy(input.get(candidate),1,lastCenter,0,d);
    centerValue.add(lastCenter);
  }
  return centerValue;
}",0.9740859069932551
64404,"@Override protected Object doMainTask(TaskMonitor monitor,ObjectRepository repository){
  Option[] variedParamValueOptions=this.variedParamValuesOption.getList();
  double[] variedParamValues=new double[variedParamValueOptions.length];
  for (int i=0; i < variedParamValueOptions.length; i++) {
    variedParamValues[i]=Double.valueOf(variedParamValueOptions[i].getValueAsCLIString());
  }
  PreviewCollection<PreviewCollectionLearningCurveWrapper> previewCollection=new PreviewCollection<>(""String_Node_Str"",""String_Node_Str"",this.getClass(),this.variedParamNameOption.getValueAsCLIString(),variedParamValues);
  monitor.setCurrentActivity(""String_Node_Str"",-1.0);
  for (int i=0; i < this.subtaskThreads.size(); ++i) {
    subtaskThreads.get(i).start();
  }
  int numSubtaskThreads=subtaskThreads.size();
  boolean allThreadsCompleted=false;
  while (!allThreadsCompleted) {
    allThreadsCompleted=true;
    int oldNumEntries=previewCollection.numEntries();
    double completionSum=0;
    for (int i=0; i < numSubtaskThreads; ++i) {
      ALTaskThread currentTaskThread=subtaskThreads.get(i);
      allThreadsCompleted&=currentTaskThread.isComplete();
      if (currentTaskThread.failed() || currentTaskThread.cancelled()) {
        monitor.requestCancel();
      }
      completionSum+=currentTaskThread.getCurrentActivityFracComplete();
      PreviewCollectionLearningCurveWrapper latestPreview=(PreviewCollectionLearningCurveWrapper)currentTaskThread.getLatestResultPreview();
      if (latestPreview != null && latestPreview.numEntries() > 0) {
        previewCollection.setPreview(i,latestPreview);
      }
 else {
        break;
      }
    }
    double completionFraction=completionSum / numSubtaskThreads;
    monitor.setCurrentActivityFractionComplete(completionFraction);
    if (monitor.taskShouldAbort()) {
      return null;
    }
    if (oldNumEntries < previewCollection.numEntries()) {
      if (monitor.resultPreviewRequested() || isSubtask()) {
        monitor.setLatestResultPreview(previewCollection.copy());
        monitor.setCurrentActivityFractionComplete(-1.0);
      }
    }
  }
  return previewCollection;
}","@Override protected Object doMainTask(TaskMonitor monitor,ObjectRepository repository){
  Option[] variedParamValueOptions=this.variedParamValuesOption.getList();
  double[] variedParamValues=new double[variedParamValueOptions.length];
  for (int i=0; i < variedParamValueOptions.length; i++) {
    variedParamValues[i]=Double.valueOf(variedParamValueOptions[i].getValueAsCLIString());
  }
  PreviewCollection<PreviewCollectionLearningCurveWrapper> previewCollection=new PreviewCollection<>(""String_Node_Str"",""String_Node_Str"",this.getClass(),this.variedParamNameOption.getValueAsCLIString(),variedParamValues);
  monitor.setCurrentActivity(""String_Node_Str"",-1.0);
  for (int i=0; i < this.subtaskThreads.size(); ++i) {
    subtaskThreads.get(i).start();
  }
  int numSubtaskThreads=subtaskThreads.size();
  boolean allThreadsCompleted=false;
  while (!allThreadsCompleted) {
    allThreadsCompleted=true;
    int oldNumEntries=previewCollection.numEntries();
    double completionSum=0;
    for (int i=0; i < numSubtaskThreads; ++i) {
      ALTaskThread currentTaskThread=subtaskThreads.get(i);
      allThreadsCompleted&=currentTaskThread.isComplete();
      if (currentTaskThread.failed() || currentTaskThread.cancelled()) {
        monitor.requestCancel();
      }
      completionSum+=currentTaskThread.getCurrentActivityFracComplete();
      PreviewCollectionLearningCurveWrapper latestPreview=(PreviewCollectionLearningCurveWrapper)currentTaskThread.getLatestResultPreview();
      if (latestPreview != null && latestPreview.numEntries() > 0) {
        previewCollection.setPreview(i,latestPreview);
      }
 else       if (!currentTaskThread.isComplete()) {
        break;
      }
    }
    double completionFraction=completionSum / numSubtaskThreads;
    monitor.setCurrentActivityFractionComplete(completionFraction);
    if (monitor.taskShouldAbort()) {
      return null;
    }
    if (oldNumEntries < previewCollection.numEntries()) {
      if (monitor.resultPreviewRequested() || isSubtask()) {
        monitor.setLatestResultPreview(previewCollection.copy());
        monitor.setCurrentActivityFractionComplete(-1.0);
      }
    }
  }
  return previewCollection;
}",0.9900439916647372
64405,"@Override protected Object doMainTask(TaskMonitor monitor,ObjectRepository repository){
  ALMultiParamTask multiParamTask=(ALMultiParamTask)this.multiParamTaskOption.getPreMaterializedObject();
  Option[] variedParamValueOptions=multiParamTask.variedParamValuesOption.getList();
  int numVariedParams=variedParamValueOptions.length;
  double[] variedParamValues=new double[numVariedParams];
  for (int i=0; i < numVariedParams; i++) {
    variedParamValues[i]=Double.valueOf(variedParamValueOptions[i].getValueAsCLIString());
  }
  PreviewCollection<PreviewCollection<PreviewCollectionLearningCurveWrapper>> previewCollection=new PreviewCollection<>(""String_Node_Str"",""String_Node_Str"",this.getClass(),multiParamTask.variedParamNameOption.getValueAsCLIString(),variedParamValues);
  monitor.setCurrentActivity(""String_Node_Str"",50.0);
  monitor.setCurrentActivity(""String_Node_Str"",-1.0);
  for (int i=0; i < this.subtaskThreads.size(); ++i) {
    subtaskThreads.get(i).start();
  }
  int numSubtaskThreads=subtaskThreads.size();
  boolean allThreadsCompleted=false;
  while (!allThreadsCompleted) {
    allThreadsCompleted=true;
    int oldNumEntries=previewCollection.numEntries();
    double completionSum=0;
    for (int i=0; i < numSubtaskThreads; ++i) {
      ALTaskThread currentTaskThread=subtaskThreads.get(i);
      allThreadsCompleted&=currentTaskThread.isComplete();
      if (currentTaskThread.failed() || currentTaskThread.cancelled()) {
        monitor.requestCancel();
      }
      completionSum+=currentTaskThread.getCurrentActivityFracComplete();
      @SuppressWarnings(""String_Node_Str"") PreviewCollection<PreviewCollectionLearningCurveWrapper> latestPreview=(PreviewCollection<PreviewCollectionLearningCurveWrapper>)currentTaskThread.getLatestResultPreview();
      if (latestPreview != null && latestPreview.numEntries() > 0) {
        previewCollection.setPreview(i,latestPreview);
      }
 else {
        break;
      }
    }
    double completionFraction=completionSum / numSubtaskThreads;
    monitor.setCurrentActivityFractionComplete(completionFraction);
    if (monitor.taskShouldAbort()) {
      return null;
    }
    if (oldNumEntries < previewCollection.numEntries()) {
      if (monitor.resultPreviewRequested() || isSubtask()) {
        monitor.setLatestResultPreview(previewCollection.copy());
      }
    }
  }
  return previewCollection;
}","@Override protected Object doMainTask(TaskMonitor monitor,ObjectRepository repository){
  ALMultiParamTask multiParamTask=(ALMultiParamTask)this.multiParamTaskOption.getPreMaterializedObject();
  Option[] variedParamValueOptions=multiParamTask.variedParamValuesOption.getList();
  int numVariedParams=variedParamValueOptions.length;
  double[] variedParamValues=new double[numVariedParams];
  for (int i=0; i < numVariedParams; i++) {
    variedParamValues[i]=Double.valueOf(variedParamValueOptions[i].getValueAsCLIString());
  }
  PreviewCollection<PreviewCollection<PreviewCollectionLearningCurveWrapper>> previewCollection=new PreviewCollection<>(""String_Node_Str"",""String_Node_Str"",this.getClass(),multiParamTask.variedParamNameOption.getValueAsCLIString(),variedParamValues);
  monitor.setCurrentActivity(""String_Node_Str"",50.0);
  monitor.setCurrentActivity(""String_Node_Str"",-1.0);
  for (int i=0; i < this.subtaskThreads.size(); ++i) {
    subtaskThreads.get(i).start();
  }
  int numSubtaskThreads=subtaskThreads.size();
  boolean allThreadsCompleted=false;
  while (!allThreadsCompleted) {
    allThreadsCompleted=true;
    int oldNumEntries=previewCollection.numEntries();
    double completionSum=0;
    for (int i=0; i < numSubtaskThreads; ++i) {
      ALTaskThread currentTaskThread=subtaskThreads.get(i);
      allThreadsCompleted&=currentTaskThread.isComplete();
      if (currentTaskThread.failed() || currentTaskThread.cancelled()) {
        monitor.requestCancel();
      }
      completionSum+=currentTaskThread.getCurrentActivityFracComplete();
      @SuppressWarnings(""String_Node_Str"") PreviewCollection<PreviewCollectionLearningCurveWrapper> latestPreview=(PreviewCollection<PreviewCollectionLearningCurveWrapper>)currentTaskThread.getLatestResultPreview();
      if (latestPreview != null && latestPreview.numEntries() > 0) {
        previewCollection.setPreview(i,latestPreview);
      }
 else       if (!currentTaskThread.isComplete()) {
        break;
      }
    }
    double completionFraction=completionSum / numSubtaskThreads;
    monitor.setCurrentActivityFractionComplete(completionFraction);
    if (monitor.taskShouldAbort()) {
      return null;
    }
    if (oldNumEntries < previewCollection.numEntries()) {
      if (monitor.resultPreviewRequested() || isSubtask()) {
        monitor.setLatestResultPreview(previewCollection.copy());
      }
    }
  }
  return previewCollection;
}",0.9910397999583248
64406,"/** 
 * Constructor.
 * @param value score value
 * @param isPositive true if the example's true label is positive
 */
public Score(double value,int position,boolean isPositive){
  this.value=value;
  this.isPositive=isPositive;
}","/** 
 * Constructor.
 * @param value score value
 * @param isPositive true if the example's true label is positive
 */
public Score(double value,int position,boolean isPositive){
  this.value=value;
  this.isPositive=isPositive;
  this.position=position;
}",0.9465020576131687
64407,"/** 
 * Trains the classifier with the given instance.
 * @param instance    the new training instance to include in the model
 */
@Override public void trainOnInstanceImpl(Instance instance){
  if (m_weights == null) {
    m_weights=new DoubleVector();
    m_gradients=new DoubleVector();
    m_velocity=new DoubleVector();
    m_weights.setValue(instance.numAttributes(),0);
  }
  if (instance.classIsMissing()) {
    return;
  }
  double z=dotProd(instance,m_weights,instance.classIndex()) + m_bias;
  double y;
  double yhat;
  double dldz;
  if (instance.classAttribute().isNominal()) {
    y=(instance.classValue() == 0) ? 0 : 1;
    if (m_loss == LOGLOSS) {
      yhat=1.0 / (1.0 + Math.exp(-z));
      dldz=(yhat - y) * (yhat * (1.0 - yhat));
    }
 else {
      y=y * 2 - 1;
      yhat=z > 0.0 ? 1.0 : -1.0;
      if (y * z < 1.0) {
        dldz=-y;
      }
 else {
        dldz=0;
      }
    }
  }
 else {
    y=instance.classValue();
    yhat=z;
    dldz=z - y;
  }
  for (int i=0; i < m_weights.numValues(); i++) {
    m_gradients.setValue(i,(m_lambda / m_t) * m_weights.getValue(i));
  }
  int n=instance.numValues();
  for (int i=0; i < n; i++) {
    m_gradients.addToValue(instance.index(i),instance.valueSparse(i) * dldz);
  }
  double biasGradient=dldz;
  m_biasVelocity+=biasGradient * biasGradient;
  m_bias-=(m_learningRate / (Math.sqrt(m_biasVelocity) + m_epsilon)) * biasGradient;
  for (int i=0; i < m_weights.numValues(); i++) {
    double g=m_gradients.getValue(i);
    m_velocity.addToValue(i,g * g);
    m_weights.addToValue(i,-(m_learningRate / (Math.sqrt(m_velocity.getValue(i)) + m_epsilon)) * g);
  }
  m_t+=1.0;
}","/** 
 * Trains the classifier with the given instance.
 * @param instance    the new training instance to include in the model
 */
@Override public void trainOnInstanceImpl(Instance instance){
  if (m_weights == null) {
    m_weights=new DoubleVector();
    m_gradients=new DoubleVector();
    m_velocity=new DoubleVector();
    m_weights.setValue(instance.numAttributes(),0);
  }
  if (instance.classIsMissing()) {
    return;
  }
  double z=dotProd(instance,m_weights,instance.classIndex()) + m_bias;
  double y;
  double dldz;
  if (instance.classAttribute().isNominal()) {
    y=(instance.classValue() == 0) ? 0 : 1;
    if (m_loss == LOGLOSS) {
      double yhat=1.0 / (1.0 + Math.exp(-z));
      dldz=(yhat - y);
    }
 else {
      y=y * 2 - 1;
      if (y * z < 1.0) {
        dldz=-y;
      }
 else {
        dldz=0;
      }
    }
  }
 else {
    y=instance.classValue();
    dldz=z - y;
  }
  for (int i=0; i < m_weights.numValues(); i++) {
    m_gradients.setValue(i,(m_lambda / m_t) * m_weights.getValue(i));
  }
  int n=instance.numValues();
  for (int i=0; i < n; i++) {
    m_gradients.addToValue(instance.index(i),instance.valueSparse(i) * dldz);
  }
  double biasGradient=dldz;
  m_biasVelocity+=biasGradient * biasGradient;
  m_bias-=(m_learningRate / (Math.sqrt(m_biasVelocity) + m_epsilon)) * biasGradient;
  for (int i=0; i < m_weights.numValues(); i++) {
    double g=m_gradients.getValue(i);
    m_velocity.addToValue(i,g * g);
    m_weights.addToValue(i,-(m_learningRate / (Math.sqrt(m_velocity.getValue(i)) + m_epsilon)) * g);
  }
  m_t+=1.0;
}",0.9536547433903576
64408,"/** 
 * discarding all instances which are exluded until an instance which can be seen by this stream or the stream is empty
 */
protected void discardNexInstancesNotFromPartition(){
  while (!isNextInstanceFromPartition() && baseStream.hasMoreInstances()) {
    baseStream.nextInstance();
  }
}","/** 
 * discarding all instances which are exluded until an instance which can be seen by this stream or the stream is empty
 */
protected void discardNexInstancesNotFromPartition(){
  while (!isNextInstanceFromPartition() && baseStream.hasMoreInstances() && numPartitions > 1) {
    baseStream.nextInstance();
  }
}",0.9656301145662848
64409,"@Override public long estimatedRemainingInstances(){
  long baseEstimatedRemainingInstances=baseStream.estimatedRemainingInstances();
  if (baseEstimatedRemainingInstances < 0) {
    return baseEstimatedRemainingInstances;
  }
  return (baseEstimatedRemainingInstances * (numPartitions - 1)) / (numPartitions);
}","@Override public long estimatedRemainingInstances(){
  long baseEstimatedRemainingInstances=baseStream.estimatedRemainingInstances();
  if (baseEstimatedRemainingInstances < 0) {
    return baseEstimatedRemainingInstances;
  }
  long numRemaining=(baseEstimatedRemainingInstances * (numPartitions - 1)) / (numPartitions);
  if (numPartitions == 1) {
    numRemaining=baseEstimatedRemainingInstances;
  }
  return numRemaining;
}",0.8243243243243243
64410,"/** 
 * Draws a single curve on the canvas.
 * @param g 	  the Graphics context in which to paint
 * @param m 	  curve information
 * @param mSelect currently selected measure
 * @param pf 	  process frequency of the curve
 * @param color   colour the curve will be drawn in
 */
private void paintFullCurve(Graphics g,MeasureCollection m,int mSelect,int pf,Color color){
  if (m.getNumberOfValues(mSelect) == 0) {
    return;
  }
  g.setColor(color);
  int height=getHeight();
  int n=m.getNumberOfValues(mSelect);
  int[] x=new int[n];
  int[] y=new int[n];
  for (int i=0; i < n; i++) {
    x[i]=(int)(i * x_resolution);
    y[i]=(int)(height - (m.getValue(mSelect,i) / this.upper_y_value) * height);
    if (this.isStandardDeviationPainted) {
      double std=m.getValue(mSelect + 7,i);
      int len=(int)((std / this.upper_y_value) * height);
      paintStandardDeviation(g,len,x[i],y[i]);
    }
  }
  g.drawPolyline(x,y,n);
}","/** 
 * Draws a single curve on the canvas.
 * @param g 	  the Graphics context in which to paint
 * @param m 	  curve information
 * @param mSelect currently selected measure
 * @param pf 	  process frequency of the curve
 * @param color   colour the curve will be drawn in
 */
private void paintFullCurve(Graphics g,MeasureCollection m,int mSelect,int pf,Color color){
  if (m.getNumberOfValues(mSelect) == 0) {
    return;
  }
  g.setColor(color);
  int height=getHeight();
  int n=m.getNumberOfValues(mSelect);
  int[] x=new int[n];
  int[] y=new int[n];
  for (int i=0; i < n; i++) {
    x[i]=(int)(i * x_resolution);
    y[i]=(int)(height - (m.getValue(mSelect,i) / this.upper_y_value) * height);
    if (this.isStandardDeviationPainted && mSelect <= 6) {
      double std=m.getValue(mSelect + 7,i);
      int len=(int)((std / this.upper_y_value) * height);
      paintStandardDeviation(g,len,x[i],y[i]);
    }
  }
  g.drawPolyline(x,y,n);
}",0.9914802981895634
64411,"/** 
 * Draws the y axis, containing og the axis line, the horizontal helping line and the labels.
 * @param g the Graphics context in which to paint
 */
private void yAxis(Graphics g){
  g.setColor(Color.BLACK);
  g.drawLine(X_OFFSET_LEFT,calcY(0),X_OFFSET_LEFT,Y_OFFSET_TOP);
  g.setColor(new Color(220,220,220));
  g.drawLine(X_OFFSET_LEFT,height / 2 + Y_OFFSET_TOP,getWidth(),height / 2 + Y_OFFSET_TOP);
  g.setColor(Color.BLACK);
  DecimalFormat d=new DecimalFormat(""String_Node_Str"");
  int digits_y=(int)(Math.log10(max_value)) - 1;
  double upper=Math.ceil(max_value / Math.pow(10,digits_y));
  if (digits_y < 0)   upper*=Math.pow(10,digits_y);
  if (Double.isNaN(upper)) {
    upper=1.0;
  }
  double numLabels=Math.min(Math.pow(2,y_resolution),32);
  for (int i=0; i <= numLabels; i++) {
    double fraction=i / numLabels;
    double value=fraction * upper;
    g.drawString(d.format(value),1,(int)((1 - fraction) * height) + Y_OFFSET_TOP + 5);
    g.drawLine(X_OFFSET_LEFT - 5,(int)((1 - fraction) * height) + Y_OFFSET_TOP,X_OFFSET_LEFT,(int)((1 - fraction) * height) + Y_OFFSET_TOP);
  }
}","/** 
 * Draws the y axis, containing og the axis line, the horizontal helping line and the labels.
 * @param g the Graphics context in which to paint
 */
private void yAxis(Graphics g){
  g.setColor(Color.BLACK);
  g.drawLine(X_OFFSET_LEFT,calcY(0),X_OFFSET_LEFT,Y_OFFSET_TOP);
  g.setColor(new Color(220,220,220));
  g.drawLine(X_OFFSET_LEFT,height / 2 + Y_OFFSET_TOP,getWidth(),height / 2 + Y_OFFSET_TOP);
  g.setColor(Color.BLACK);
  DecimalFormat d=new DecimalFormat(""String_Node_Str"");
  double numLabels=Math.min(Math.pow(2,y_resolution),32);
  for (int i=0; i <= numLabels; i++) {
    double fraction=i / numLabels;
    double value=fraction * upper_value;
    g.drawString(d.format(value),1,(int)((1 - fraction) * height) + Y_OFFSET_TOP + 5);
    g.drawLine(X_OFFSET_LEFT - 5,(int)((1 - fraction) * height) + Y_OFFSET_TOP,X_OFFSET_LEFT,(int)((1 - fraction) * height) + Y_OFFSET_TOP);
  }
}",0.5295295295295295
64412,"/** 
 * Sets the maximum y value
 * @param max maximum y value
 */
public void setYMaxValue(double max){
  max_value=max;
}","/** 
 * Sets the maximum y value
 * @param max maximum y value
 */
public void setYMaxValue(double max){
  this.max_value=max;
}",0.9800796812749004
64413,"/** 
 * Initialises a AbstractGraphAxes by setting the initial values and the layout.
 */
public AbstractGraphAxes(){
  this.max_value=1;
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(this);
  this.setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0,400,Short.MAX_VALUE));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0,300,Short.MAX_VALUE));
}","/** 
 * Initialises a AbstractGraphAxes by setting the initial values and the layout.
 */
public AbstractGraphAxes(){
  this.max_value=1;
  this.upper_value=1;
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(this);
  this.setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0,400,Short.MAX_VALUE));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0,300,Short.MAX_VALUE));
}",0.9780876494023903
64414,"/** 
 * Computes the maximum values of the registered measure collections and updates the member values accordingly.
 * @return true, if the values have changed
 */
private boolean updateMaxValues(){
  int max_x_value_new;
  double max_y_value_new;
  if (this.measures == null) {
    max_x_value_new=1;
    max_y_value_new=1;
  }
 else {
    max_x_value_new=maxNumValues();
    max_y_value_new=maxValue();
  }
  if (max_x_value_new != this.max_x_value || max_y_value_new != this.max_y_value) {
    this.max_x_value=max_x_value_new;
    this.max_y_value=max_y_value_new;
    updateMaxYValue();
    return true;
  }
  return false;
}","/** 
 * Computes the maximum values of the registered measure collections and updates the member values accordingly.
 * @return true, if the values have changed
 */
private boolean updateMaxValues(){
  int max_x_value_new;
  double max_y_value_new;
  if (this.measures == null) {
    max_x_value_new=1;
    max_y_value_new=1;
  }
 else {
    max_x_value_new=maxNumValues();
    max_y_value_new=maxValue();
  }
  if (max_x_value_new != this.max_x_value || max_y_value_new != this.max_y_value) {
    this.max_x_value=max_x_value_new;
    this.max_y_value=max_y_value_new;
    updateMaxYValue();
    updateYUpperValue();
    return true;
  }
  return false;
}",0.9805749805749806
64415,"public AbstractGraphPlot(){
  this.max_value=1;
  this.measureSelected=0;
  setOpaque(false);
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(this);
  this.setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0,1000,Short.MAX_VALUE));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0,300,Short.MAX_VALUE));
}","public AbstractGraphPlot(){
  this.max_value=1;
  this.upper_value=1;
  this.measureSelected=0;
  setOpaque(false);
  javax.swing.GroupLayout layout=new javax.swing.GroupLayout(this);
  this.setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0,1000,Short.MAX_VALUE));
  layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0,300,Short.MAX_VALUE));
}",0.9760348583877996
64416,"/** 
 * Draws a single curve on the canvas.
 * @param g 	  the Graphics context in which to paint
 * @param m 	  curve information
 * @param mSelect currently selected measure
 * @param pf 	  process frequency of the curve
 * @param color   colour the curve will be drawn in
 */
private void paintFullCurve(Graphics g,MeasureCollection m,int mSelect,int pf,Color color){
  if (m.getNumberOfValues(mSelect) == 0) {
    return;
  }
  int height=getHeight();
  int n=m.getNumberOfValues(mSelect);
  int[] x=new int[n];
  int[] y=new int[n];
  for (int i=0; i < n; i++) {
    x[i]=(int)(i / x_resolution);
    y[i]=(int)(height - (m.getValue(mSelect,i) / this.max_value) * height);
  }
  g.setColor(color);
  g.drawPolyline(x,y,n);
}","/** 
 * Draws a single curve on the canvas.
 * @param g 	  the Graphics context in which to paint
 * @param m 	  curve information
 * @param mSelect currently selected measure
 * @param pf 	  process frequency of the curve
 * @param color   colour the curve will be drawn in
 */
private void paintFullCurve(Graphics g,MeasureCollection m,int mSelect,int pf,Color color){
  if (m.getNumberOfValues(mSelect) == 0) {
    return;
  }
  int height=getHeight();
  int n=m.getNumberOfValues(mSelect);
  int[] x=new int[n];
  int[] y=new int[n];
  for (int i=0; i < n; i++) {
    x[i]=(int)(i / x_resolution);
    y[i]=(int)(height - (m.getValue(mSelect,i) / this.upper_value) * height);
  }
  g.setColor(color);
  g.drawPolyline(x,y,n);
}",0.9945205479452056
64417,"/** 
 * Paint a dot onto the panel.
 * @param g graphics object
 * @param m MeasureCollection containing the data
 */
private void scatter(Graphics g,MeasureCollection m,double variedParamValue){
  int height=getHeight();
  int width=getWidth();
  int x=(int)(width * variedParamValue);
  double value=m.getLastValue(this.measureSelected);
  if (Double.isNaN(value)) {
    return;
  }
  int y=(int)(height - (value / this.max_value) * height);
  g.fillOval(x - DOT_SIZE / 2,y - DOT_SIZE / 2,DOT_SIZE,DOT_SIZE);
}","/** 
 * Paint a dot onto the panel.
 * @param g graphics object
 * @param m MeasureCollection containing the data
 */
private void scatter(Graphics g,MeasureCollection m,double variedParamValue){
  int height=getHeight();
  int width=getWidth();
  int x=(int)(width * variedParamValue);
  double value=m.getLastValue(this.measureSelected);
  if (Double.isNaN(value)) {
    return;
  }
  int y=(int)(height - (value / this.upper_value) * height);
  g.fillOval(x - DOT_SIZE / 2,y - DOT_SIZE / 2,DOT_SIZE,DOT_SIZE);
}",0.9922027290448344
64418,"@Override public void setModelContext(InstancesHeader ih){
  super.setModelContext(ih);
  this.numClasses=ih.numClasses();
  for (int m=0; m <= mMax; ++m) {
    distributions.add(getAllDistributionPossibilities(m,numClasses));
  }
  kernelEstimators=new MCPALEstimatorMultivariate[numClasses];
  for (int cIdx=0; cIdx < numClasses; ++cIdx) {
    kernelEstimators[cIdx]=new MCPALEstimatorMultivariate(bandwidth);
  }
}","@Override public void setModelContext(InstancesHeader ih){
  super.setModelContext(ih);
  this.numClasses=ih.numClasses();
  for (int m=0; m <= mMax; ++m) {
    distributions.add(getAllDistributionPossibilities(m,numClasses));
  }
  kernelEstimators=new MCPALEstimatorMultivariate[numClasses];
  for (int cIdx=0; cIdx < numClasses; ++cIdx) {
    kernelEstimators[cIdx]=new MCPALEstimatorMultivariate(bandwidth,100);
  }
}",0.9952267303102624
64419,"public double getNormal(Matrix x,Matrix mu){
  double prob=0;
  Matrix diff=x.minus(mu);
  Matrix exponent=diff.transpose().times(invCovariance).times(diff);
  double pow=-0.5 * exponent.get(0,0);
  prob=Math.exp(pow);
  return prob;
}","public double getNormal(double[] x,double[] mu){
  int numFeatures=x.length;
  double v=0;
  for (int i=0; i < numFeatures; ++i) {
    double d=(x[i] - mu[i]);
    v+=d * d / bandwidth;
  }
  return Math.exp(-0.5 * v);
}",0.167032967032967
64420,"public MCPALEstimatorMultivariate(double bandwidth){
  this.bandwidth=bandwidth;
  this.points=new ArrayList<Matrix>();
}","public MCPALEstimatorMultivariate(double bandwidth,int bufferSize){
  this.bandwidth=bandwidth;
  this.points=new RingBuffer<>(bufferSize);
}",0.816793893129771
64421,"/** 
 * Returns the frequency of instances at position x NOT the density
 * @param x
 * @return
 */
public double getFrequencyEstimate(double[] x){
  if (points.size() == 0)   return 0;
  Matrix point=doubleArrayToMatrix(x);
  double prob=0;
  for (int i=0; i < points.size(); i++) {
    prob+=getNormal(point,points.get(i));
  }
  return prob;
}","/** 
 * Returns the frequency of instances at position x NOT the density
 * @param x
 * @return
 */
public double getFrequencyEstimate(double[] x){
  if (points.size() == 0)   return 0;
  double prob=0;
  for (int i=0; i < points.size(); i++) {
    prob+=getNormal(x,points.get(i));
  }
  return prob;
}",0.930662557781202
64422,"public void addValue(double[] x){
  Matrix point=doubleArrayToMatrix(x);
  points.add(point);
  if (points.size() > 100) {
    points.remove(0);
  }
  if (dimSet == false)   initCovariance(x.length);
}","public void addValue(double[] x){
  points.add(x);
}",0.4110671936758893
64423,"@Override public Object getValueAt(int row,int column){
  return data.get(row)[column];
}","@Override public Object getValueAt(int row,int column){
  if (row >= data.size() || column >= data.get(row).length) {
    return 0.0;
  }
  return data.get(row)[column];
}",0.6846153846153846
64424,"@Override public double[] getEntryData(int entryIndex){
  double[] entry=new double[getMeasurementNameCount()];
  int numSubPreviews=subPreviews.size();
  int subPreviewIndex=entryIndex % numSubPreviews;
  int subPreviewEntryIndex=entryIndex / numSubPreviews;
  double[] subPreviewEntry=subPreviews.get(subPreviewIndex).getEntryData(subPreviewEntryIndex);
  entry[0]=entryIndex;
  entry[1]=subPreviewEntryIndex;
  for (int measurementIdx=0; measurementIdx < subPreviewEntry.length; ++measurementIdx) {
    entry[2 + measurementIdx]=subPreviewEntry[measurementIdx];
  }
  return entry;
}","@Override public double[] getEntryData(int entryIndex){
  double[] entry=new double[getMeasurementNameCount()];
  int numSubPreviews=subPreviews.size();
  int subPreviewIndex=entryIndex % numSubPreviews;
  int subPreviewEntryIndex=entryIndex / numSubPreviews;
  double[] subPreviewEntry=subPreviews.get(subPreviewIndex).getEntryData(subPreviewEntryIndex);
  entry[0]=entryIndex;
  entry[1]=subPreviewIndex;
  for (int measurementIdx=0; measurementIdx < subPreviewEntry.length; ++measurementIdx) {
    entry[2 + measurementIdx]=subPreviewEntry[measurementIdx];
  }
  return entry;
}",0.9957155098543272
64425,"/** 
 * Updates the TaskTextViewerPanel by adding the new text to the text area and updating the live graph.
 * @param newText  the new information used to update text and graph
 */
public void setText(Preview preview){
  Point p=this.scrollPane.getViewport().getViewPosition();
  this.previewTableModel.setPreview(preview);
  if (previewTableModel.structureChanged()) {
    rescaleTableColumns();
  }
  this.previewTable.repaint();
  this.scrollPane.getViewport().setViewPosition(p);
  this.exportButton.setEnabled(preview != null);
}","/** 
 * Updates the TaskTextViewerPanel by adding the new text to the text area and updating the live graph.
 * @param newText  the new information used to update text and graph
 */
public void setText(Preview preview){
  Point p=this.scrollPane.getViewport().getViewPosition();
  previewTableModel.setPreview(preview);
  SwingUtilities.invokeLater(new Runnable(){
    boolean structureChanged=previewTableModel.structureChanged();
    public void run(){
      if (structureChanged) {
        previewTableModel.fireTableStructureChanged();
        rescaleTableColumns();
      }
 else {
        previewTableModel.fireTableDataChanged();
      }
      previewTable.repaint();
    }
  }
);
  this.scrollPane.getViewport().setViewPosition(p);
  this.exportButton.setEnabled(preview != null);
}",0.7245283018867924
64426,"public void setPreview(Preview preview){
  structureChangeFlag=false;
  if (latestPreview != null && preview == null) {
    names=new ArrayList<>();
    data=new ArrayList<>();
    fireTableStructureChanged();
    structureChangeFlag=true;
  }
 else   if (latestPreview == null && preview != null || latestPreview != null && preview != null && preview.getTaskClass() != currentTaskClass) {
    names=new ArrayList<>();
    for (int measurementNameIdx=0; measurementNameIdx < preview.getMeasurementNameCount(); ++measurementNameIdx) {
      names.add(preview.getMeasurementName(measurementNameIdx));
    }
    fireTableStructureChanged();
    structureChangeFlag=true;
  }
  latestPreview=preview;
  if (preview != null) {
    currentTaskClass=preview.getTaskClass();
    data=preview.getData();
    fireTableDataChanged();
  }
}","public void setPreview(Preview preview){
  structureChangeFlag=false;
  if (preview == null) {
    if (latestPreview != null) {
      System.out.println(""String_Node_Str"");
      names=new ArrayList<>();
      data=new ArrayList<>();
      structureChangeFlag=true;
    }
  }
 else {
    structureChangeFlag|=latestPreview == null;
    structureChangeFlag|=latestPreview != null && latestPreview.numEntries() == 0 && preview.numEntries() > 0;
    structureChangeFlag|=latestPreview != null && latestPreview.getTaskClass() != preview.getTaskClass();
  }
  latestPreview=preview;
  if (preview != null) {
    data=preview.getData();
    if (structureChangeFlag) {
      copyMeasurementNames(preview);
    }
  }
}",0.1898569570871261
64427,"public PreviewTableModel(){
  names=new ArrayList<>();
  data=new ArrayList<>();
  latestPreview=null;
  structureChangeFlag=false;
  currentTaskClass=null;
}","public PreviewTableModel(){
  names=new ArrayList<>();
  data=new ArrayList<>();
  latestPreview=null;
  structureChangeFlag=false;
}",0.9140893470790378
64428,"/** 
 * Text representation of a InstanceImpl.
 */
@Override public String toString(){
  double[] aux=this.instanceData.toDoubleArray();
  StringBuilder str=new StringBuilder();
  for (int i=0; i < aux.length; i++) {
    str.append(aux[i]).append(""String_Node_Str"");
  }
  return str.toString();
}","/** 
 * Text representation of a InstanceImpl.
 */
@Override public String toString(){
  StringBuilder str=new StringBuilder();
  for (int attIndex=0; attIndex < this.numAttributes(); attIndex++) {
    if (this.attribute(attIndex).isNominal()) {
      int valueIndex=(int)this.value(attIndex);
      String stringValue=this.attribute(attIndex).value(valueIndex);
      str.append(stringValue).append(""String_Node_Str"");
    }
 else     if (this.attribute(attIndex).isNumeric()) {
      str.append(this.value(attIndex)).append(""String_Node_Str"");
    }
 else     if (this.attribute(attIndex).isDate()) {
      SimpleDateFormat dateFormatter=new SimpleDateFormat(""String_Node_Str"");
      str.append(dateFormatter.format(this.value(attIndex))).append(""String_Node_Str"");
    }
  }
  return str.toString();
}",0.3139745916515426
64429,"@Override public int branchForInstance(Instance inst){
  int instAttIndex=this.attIndex;
  if (inst.isMissing(instAttIndex)) {
    return -1;
  }
  double v=inst.value(instAttIndex);
  if (v == this.attValue) {
    return this.equalsPassesTest ? 0 : 1;
  }
  return v < this.attValue ? 0 : 1;
}","@Override public int branchForInstance(Instance inst){
  int instAttIndex=this.attIndex;
  if (inst.isMissing(instAttIndex)) {
    return -1;
  }
  double v=inst.valueInputAttribute(instAttIndex);
  if (v == this.attValue) {
    return this.equalsPassesTest ? 0 : 1;
  }
  return v < this.attValue ? 0 : 1;
}",0.9767441860465116
64430,"private boolean skipInLevelCount(){
  return false;
}","protected boolean skipInLevelCount(){
  return false;
}",0.925925925925926
64431,"@SuppressWarnings(""String_Node_Str"") private boolean skipInLevelCount(){
  return true;
}","@SuppressWarnings(""String_Node_Str"") protected boolean skipInLevelCount(){
  return true;
}",0.9555555555555556
64432,"public double getPrediction(Instance inst,FIMTDD tree){
  return children.get(splitTest.branchForInstance(inst)).getPrediction(inst);
}","public double getPrediction(Instance inst){
  return children.get(splitTest.branchForInstance(inst)).getPrediction(inst);
}",0.9534883720930232
64433,"@Override public InstanceExample nextInstance(){
  Instance x=(Instance)((Instance)this.inputStream.nextInstance().getData());
  if (dataset == null) {
    System.out.println(""String_Node_Str"");
    initialize(x);
  }
  System.out.println(""String_Node_Str"");
  double z_[]=new double[dataset.numAttributes()];
  Instance z=new InstanceImpl(x.weight(),z_);
  int d=x.numAttributes();
  int h=z_.length;
  int j_c=x.classIndex();
  for (int k=0; k < h; k++) {
    double sum_k=0.;
    for (int j=0; j < d; j++) {
      if (j != j_c)       sum_k+=(x.value(j) - c[k]);
    }
    double v=sum_k / Math.pow(r[k],2);
    z.setValue(k,Math.exp(-sum_k));
  }
  z.setDataset(dataset);
  return new InstanceExample(z);
}","@Override public InstanceExample nextInstance(){
  Instance x=(Instance)((Instance)this.inputStream.nextInstance().getData());
  if (dataset == null) {
    System.out.println(""String_Node_Str"");
    initialize(x);
  }
  double z_[]=new double[dataset.numAttributes()];
  Instance z=new InstanceImpl(x.weight(),z_);
  int d=x.numAttributes();
  int h=numLatentOption.getValue();
  int j_c=x.classIndex();
  for (int k=0; k < h; k++) {
    double sum_k=0.;
    for (int j=0; j < d; j++) {
      sum_k+=(x.value(j) - c[k]);
    }
    double v=sum_k / Math.pow(r[k],2);
    z.setValue(k,Math.exp(-sum_k));
  }
  z.setValue(h,x.classValue());
  z.setDataset(dataset);
  return new InstanceExample(z);
}",0.9103840682788052
64434,"private void initialize(Instance instance){
  int h=numLatentOption.getValue();
  c=new double[h];
  r=new double[h];
  for (int j=0; j < h; j++) {
    c[j]=this.random.nextGaussian();
    r[j]=this.random.nextDouble();
  }
  Instances ds=new Instances();
  List<Attribute> v=new ArrayList<Attribute>(h);
  List<Integer> indexValues=new ArrayList<Integer>(h);
  for (int j=0; j < h; j++) {
    v.add(new Attribute(""String_Node_Str"" + String.valueOf(j)));
    indexValues.add(j);
  }
  v.add(instance.dataset().classAttribute());
  indexValues.add(h);
  ds.setAttributes(v,indexValues);
  Range r=new Range(""String_Node_Str"");
  ds.setRangeOutputIndices(r);
  dataset=(new InstancesHeader(ds));
  dataset.setClassIndex(h);
  System.out.println(""String_Node_Str"" + ds);
  System.out.println(""String_Node_Str"" + dataset.numClasses());
  System.out.println(""String_Node_Str"" + dataset.numInstances());
  System.out.println(""String_Node_Str"" + dataset.numAttributes());
}","private void initialize(Instance instance){
  int h=numLatentOption.getValue();
  c=new double[h];
  r=new double[h];
  for (int j=0; j < h; j++) {
    c[j]=this.random.nextGaussian();
    r[j]=this.random.nextDouble();
  }
  Instances ds=new Instances();
  List<Attribute> v=new ArrayList<Attribute>(h);
  List<Integer> indexValues=new ArrayList<Integer>(h);
  for (int j=0; j < h; j++) {
    v.add(new Attribute(""String_Node_Str"" + String.valueOf(j)));
    indexValues.add(j);
  }
  v.add(instance.dataset().classAttribute());
  indexValues.add(h);
  ds.setAttributes(v,indexValues);
  Range r=new Range(""String_Node_Str"");
  ds.setRangeOutputIndices(r);
  dataset=(new InstancesHeader(ds));
  dataset.setClassIndex(h);
  System.out.println(""String_Node_Str"" + dataset);
  System.out.println(""String_Node_Str"" + dataset.classIndex());
  System.out.println(""String_Node_Str"" + dataset.numClasses());
  System.out.println(""String_Node_Str"" + dataset.numInstances());
  System.out.println(""String_Node_Str"" + dataset.numAttributes());
}",0.9645177411294352
64435,"@Override public void trainOnInstanceImpl(MultiLabelInstance instance){
  if (this.hasStarted == false) {
    this.ensemble=new Classifier[instance.numberOutputTargets()];
    Classifier baseLearner=(Classifier)getPreparedClassOption(this.baseLearnerOption);
    baseLearner.resetLearning();
    for (int i=0; i < this.ensemble.length; i++) {
      this.ensemble[i]=baseLearner.copy();
    }
    this.hasStarted=true;
  }
  for (int i=0; i < this.ensemble.length; i++) {
    Instance weightedInst=transformInstance(instance,i);
    this.ensemble[i].trainOnInstance(weightedInst);
  }
}","@Override public void trainOnInstanceImpl(MultiLabelInstance instance){
  if (this.hasStarted == false) {
    this.ensemble=new Classifier[instance.numberOutputTargets()];
    Classifier baseLearner=(Classifier)getPreparedClassOption(this.baseLearnerOption);
    baseLearner.resetLearning();
    for (int i=0; i < this.ensemble.length; i++) {
      this.ensemble[i]=baseLearner.copy();
    }
    this.hasStarted=true;
  }
  for (int i=0; i < this.ensemble.length; i++) {
    Instance weightedInst=transformInstance(instance,i);
    this.ensemble[i].trainOnInstance(weightedInst);
  }
  if (instance.numberOutputTargets() != ensemble.length)   System.out.println(""String_Node_Str"");
}",0.9227129337539433
64436,"@Override public void trainOnInstanceImpl(MultiLabelInstance instance){
  numInstances+=instance.weight();
  debug(""String_Node_Str"",3);
  debug(""String_Node_Str"" + numInstances + ""String_Node_Str""+ instance.toString(),3);
  boolean rulesCoveringInstance=false;
  ListIterator<MultiLabelRule> ruleIterator=this.ruleSet.listIterator();
  while (ruleIterator.hasNext()) {
    MultiLabelRule rule=ruleIterator.next();
    if (rule.isCovering(instance) == true) {
      rulesCoveringInstance=true;
      if (!rule.updateAnomalyDetection(instance)) {
        if (rule.updateChangeDetection(instance)) {
          debug(""String_Node_Str"" + this.numInstances + ""String_Node_Str""+ rule.getWeightSeenSinceExpansion()+ ""String_Node_Str""+ rule.getRuleNumberID(),1);
          ruleIterator.remove();
          this.numChangesDetected+=instance.weight();
        }
 else {
          rule.trainOnInstance(instance);
          if (rule.getWeightSeenSinceExpansion() % this.gracePeriodOption.getValue() == 0.0) {
            if (rule.tryToExpand(this.splitConfidenceOption.getValue(),this.tieThresholdOption.getValue())) {
              setRuleOptions(rule);
              if (!dropOldRuleAfterExpansionOption.isSet() && rule.hasNewRuleFromOtherOutputs()) {
                MultiLabelRule otherMultiLabelRule=rule.getNewRuleFromOtherOutputs();
                otherMultiLabelRule.setRuleNumberID(++ruleNumberID);
                setRuleOptions(otherMultiLabelRule);
                ruleIterator.add(otherMultiLabelRule);
              }
              debug(""String_Node_Str"",2);
              debug(rule.toString(),2);
            }
          }
        }
      }
 else {
        debug(""String_Node_Str"" + this.numInstances + ""String_Node_Str""+ rule.getRuleNumberID(),1);
        this.numAnomaliesDetected+=instance.weight();
      }
      if (!this.unorderedRulesOption.isSet())       break;
    }
  }
  if (rulesCoveringInstance == false) {
    defaultRule.trainOnInstance(instance);
    if (defaultRule.getWeightSeenSinceExpansion() % this.gracePeriodOption.getValue() == 0.0) {
      debug(""String_Node_Str"" + defaultRule.getWeightSeenSinceExpansion(),4);
      if (defaultRule.tryToExpand(this.splitConfidenceOption.getValue(),this.tieThresholdOption.getValue()) == true) {
        MultiLabelRule newDefaultRule=defaultRule.getNewRuleFromOtherBranch();
        newDefaultRule.setRuleNumberID(++ruleNumberID);
        setRuleOptions(newDefaultRule);
        setRuleOptions(defaultRule);
        ruleSet.add(this.defaultRule);
        debug(""String_Node_Str"",2);
        debug(defaultRule.toString(),2);
        debug(""String_Node_Str"",3);
        debug(newDefaultRule.toString(),3);
        defaultRule=newDefaultRule;
      }
    }
  }
}","@Override public void trainOnInstanceImpl(MultiLabelInstance instance){
  numInstances+=instance.weight();
  debug(""String_Node_Str"",3);
  debug(""String_Node_Str"" + numInstances + ""String_Node_Str""+ instance.toString(),3);
  boolean rulesCoveringInstance=false;
  ListIterator<MultiLabelRule> ruleIterator=this.ruleSet.listIterator();
  while (ruleIterator.hasNext()) {
    MultiLabelRule rule=ruleIterator.next();
    if (rule.isCovering(instance) == true) {
      rulesCoveringInstance=true;
      if (!rule.updateAnomalyDetection(instance)) {
        if (rule.updateChangeDetection(instance)) {
          debug(""String_Node_Str"" + this.numInstances + ""String_Node_Str""+ rule.getWeightSeenSinceExpansion()+ ""String_Node_Str""+ rule.getRuleNumberID(),1);
          ruleIterator.remove();
          this.numChangesDetected+=instance.weight();
        }
 else {
          rule.trainOnInstance(instance);
          if (rule.getWeightSeenSinceExpansion() % this.gracePeriodOption.getValue() == 0.0) {
            if (rule.tryToExpand(this.splitConfidenceOption.getValue(),this.tieThresholdOption.getValue())) {
              if (!dropOldRuleAfterExpansionOption.isSet() && rule.hasNewRuleFromOtherOutputs()) {
                MultiLabelRule otherMultiLabelRule=rule.getNewRuleFromOtherOutputs();
                otherMultiLabelRule.setRuleNumberID(++ruleNumberID);
                setRuleOptions(otherMultiLabelRule);
                ruleIterator.add(otherMultiLabelRule);
              }
              setRuleOptions(rule);
              debug(""String_Node_Str"",2);
              debug(rule.toString(),2);
            }
          }
        }
      }
 else {
        debug(""String_Node_Str"" + this.numInstances + ""String_Node_Str""+ rule.getRuleNumberID(),1);
        this.numAnomaliesDetected+=instance.weight();
      }
      if (!this.unorderedRulesOption.isSet())       break;
    }
  }
  if (rulesCoveringInstance == false) {
    defaultRule.trainOnInstance(instance);
    if (defaultRule.getWeightSeenSinceExpansion() % this.gracePeriodOption.getValue() == 0.0) {
      debug(""String_Node_Str"" + defaultRule.getWeightSeenSinceExpansion(),4);
      if (defaultRule.tryToExpand(this.splitConfidenceOption.getValue(),this.tieThresholdOption.getValue()) == true) {
        MultiLabelRule newDefaultRule=defaultRule.getNewRuleFromOtherBranch();
        newDefaultRule.setRuleNumberID(++ruleNumberID);
        setRuleOptions(newDefaultRule);
        setRuleOptions(defaultRule);
        ruleSet.add(this.defaultRule);
        debug(""String_Node_Str"",2);
        debug(defaultRule.toString(),2);
        debug(""String_Node_Str"",3);
        debug(newDefaultRule.toString(),3);
        defaultRule=newDefaultRule;
      }
    }
  }
}",0.986788990825688
64437,"@Override public void resetLearningImpl(){
  defaultRule=newDefaultRule();
  defaultRule.setLearner((MultiLabelLearner)((MultiLabelLearner)getPreparedClassOption(learnerOption)).copy());
  setRuleOptions(defaultRule);
  ruleSet=new MultiLabelRuleSet();
  ruleNumberID=1;
  statistics=null;
}","@Override public void resetLearningImpl(){
  defaultRule=newDefaultRule();
  defaultRule.setLearner((MultiLabelLearner)((MultiLabelLearner)getPreparedClassOption(learnerOption)).copy());
  defaultRule.setInstanceTransformer(new NoInstanceTransformation());
  setRuleOptions(defaultRule);
  ruleSet=new MultiLabelRuleSet();
  ruleNumberID=1;
  statistics=null;
}",0.8926380368098159
64438,"public Prediction getPredictionForInstance(MultiLabelInstance instance){
  Prediction prediction=null;
  if (learner != null && this.instanceTransformer != null) {
    Instance transfInstance=this.instanceTransformer.sourceInstanceToTarget(instance);
    Prediction targetPrediction=learner.getPredictionForInstance(transfInstance);
    prediction=this.instanceTransformer.targetPredictionToSource(targetPrediction);
  }
  return prediction;
}","public Prediction getPredictionForInstance(MultiLabelInstance instance){
  Prediction prediction=null;
  if (learner != null) {
    Instance transfInstance=this.instanceTransformer.sourceInstanceToTarget(instance);
    Prediction targetPrediction=learner.getPredictionForInstance(transfInstance);
    prediction=this.instanceTransformer.targetPredictionToSource(targetPrediction);
  }
  return prediction;
}",0.9576470588235294
64439,"@Override public boolean tryToExpand(double splitConfidence,double tieThreshold){
  boolean shouldSplit=false;
  AttributeExpansionSuggestion[] bestSplitSuggestions=this.getBestSplitSuggestions(splitCriterion);
  Arrays.sort(bestSplitSuggestions);
  int[] oldInputs=inputsToLearn.clone();
  inputsToLearn=inputSelector.getNextInputIndices(bestSplitSuggestions);
  Arrays.sort(this.inputsToLearn);
  for (int i=0; i < oldInputs.length; i++) {
    if (attributesMask[oldInputs[i]]) {
      if (Arrays.binarySearch(inputsToLearn,oldInputs[i]) < 0) {
        this.attributeObservers.set(oldInputs[i],null);
      }
    }
  }
  if (bestSplitSuggestions.length < 2) {
    bestSuggestion=bestSplitSuggestions[bestSplitSuggestions.length - 1];
    shouldSplit=true;
  }
 else {
    double hoeffdingBound=computeHoeffdingBound(splitCriterion.getRangeOfMerit(this.literalStatistics),splitConfidence,weightSeen);
    bestSuggestion=bestSplitSuggestions[bestSplitSuggestions.length - 1];
    AttributeExpansionSuggestion secondBestSuggestion=bestSplitSuggestions[bestSplitSuggestions.length - 2];
    if ((((bestSuggestion.merit - secondBestSuggestion.merit)) > hoeffdingBound) || (hoeffdingBound < tieThreshold)) {
      shouldSplit=true;
    }
  }
  if (shouldSplit) {
    DoubleVector[][] resultingStatistics=bestSuggestion.getResultingNodeStatistics();
    double[] branchMerits=splitCriterion.getBranchesSplitMerits(resultingStatistics);
    DoubleVector[] newLiteralStatistics;
    if (branchMerits[1] > branchMerits[0]) {
      bestSuggestion.getPredicate().negateCondition();
      newLiteralStatistics=getBranchStatistics(resultingStatistics,1);
    }
 else {
      newLiteralStatistics=getBranchStatistics(resultingStatistics,0);
    }
    int[] newOutputs=outputSelector.getNextOutputIndices(newLiteralStatistics,literalStatistics,outputsToLearn);
    Arrays.sort(newOutputs);
    otherBranchLearningLiteral=new LearningLiteralRegression();
    otherBranchLearningLiteral.setLearner((MultiLabelLearner)learner.copy());
    otherBranchLearningLiteral.setInstanceTransformer(this.instanceTransformer);
    if (learner instanceof AMRulesFunction) {
      ((AMRulesFunction)learner).resetWithMemory();
      if (newOutputs.length != outputsToLearn.length) {
        int[] otherOutputs=Utils.complementSet(outputsToLearn,newOutputs);
        otherOutputsLearningLiteral=new LearningLiteralRegression(otherOutputs);
        MultiLabelLearner otherOutputsLearner=(MultiLabelLearner)learner.copy();
        int[] indices=newLearnerOutputIndices(outputsToLearn,otherOutputs);
        ((AMRulesFunction)otherOutputsLearner).selectOutputsToLearn(indices);
        otherOutputsLearningLiteral.setLearner(otherOutputsLearner);
        indices=newLearnerOutputIndices(outputsToLearn,newOutputs);
        ((AMRulesFunction)learner).selectOutputsToLearn(indices);
      }
    }
 else {
      if (newOutputs.length != outputsToLearn.length) {
        otherOutputsLearningLiteral=new LearningLiteralRegression();
        MultiLabelLearner otherOutputsLearner=(MultiLabelLearner)learner.copy();
        otherOutputsLearningLiteral.setLearner(otherOutputsLearner);
      }
      learner.resetLearning();
    }
    expandedLearningLiteral=new LearningLiteralRegression(newOutputs);
    expandedLearningLiteral.setLearner((MultiLabelLearner)this.learner.copy());
  }
  return shouldSplit;
}","@Override public boolean tryToExpand(double splitConfidence,double tieThreshold){
  boolean shouldSplit=false;
  AttributeExpansionSuggestion[] bestSplitSuggestions=this.getBestSplitSuggestions(splitCriterion);
  Arrays.sort(bestSplitSuggestions);
  int[] oldInputs=inputsToLearn.clone();
  inputsToLearn=inputSelector.getNextInputIndices(bestSplitSuggestions);
  Arrays.sort(this.inputsToLearn);
  for (int i=0; i < oldInputs.length; i++) {
    if (attributesMask[oldInputs[i]]) {
      if (Arrays.binarySearch(inputsToLearn,oldInputs[i]) < 0) {
        this.attributeObservers.set(oldInputs[i],null);
      }
    }
  }
  if (bestSplitSuggestions.length < 2) {
    bestSuggestion=bestSplitSuggestions[bestSplitSuggestions.length - 1];
    shouldSplit=true;
  }
 else {
    double hoeffdingBound=computeHoeffdingBound(splitCriterion.getRangeOfMerit(this.literalStatistics),splitConfidence,weightSeen);
    bestSuggestion=bestSplitSuggestions[bestSplitSuggestions.length - 1];
    AttributeExpansionSuggestion secondBestSuggestion=bestSplitSuggestions[bestSplitSuggestions.length - 2];
    if ((((bestSuggestion.merit - secondBestSuggestion.merit)) > hoeffdingBound) || (hoeffdingBound < tieThreshold)) {
      shouldSplit=true;
    }
  }
  if (shouldSplit) {
    DoubleVector[][] resultingStatistics=bestSuggestion.getResultingNodeStatistics();
    double[] branchMerits=splitCriterion.getBranchesSplitMerits(resultingStatistics);
    DoubleVector[] newLiteralStatistics;
    if (branchMerits[1] > branchMerits[0]) {
      bestSuggestion.getPredicate().negateCondition();
      newLiteralStatistics=getBranchStatistics(resultingStatistics,1);
    }
 else {
      newLiteralStatistics=getBranchStatistics(resultingStatistics,0);
    }
    int[] newOutputs=outputSelector.getNextOutputIndices(newLiteralStatistics,literalStatistics,outputsToLearn);
    Arrays.sort(newOutputs);
    otherBranchLearningLiteral=new LearningLiteralRegression();
    otherBranchLearningLiteral.instanceHeader=instanceHeader;
    otherBranchLearningLiteral.learner=(MultiLabelLearner)learner.copy();
    otherBranchLearningLiteral.instanceTransformer=(InstanceTransformer)this.instanceTransformer;
    if (learner instanceof AMRulesFunction) {
      if (newOutputs.length != outputsToLearn.length) {
        int[] otherOutputs=Utils.complementSet(outputsToLearn,newOutputs);
        int[] indices;
        if (otherOutputs.length > 0) {
          otherOutputsLearningLiteral=new LearningLiteralRegression(otherOutputs);
          MultiLabelLearner otherOutputsLearner=(MultiLabelLearner)learner.copy();
          indices=Utils.getIndexCorrespondence(outputsToLearn,otherOutputs);
          ((AMRulesFunction)otherOutputsLearner).selectOutputsToLearn(indices);
          ((AMRulesFunction)otherOutputsLearner).resetWithMemory();
          otherOutputsLearningLiteral.learner=otherOutputsLearner;
          otherOutputsLearningLiteral.instanceHeader=instanceHeader;
          otherOutputsLearningLiteral.instanceTransformer=new InstanceOutputAttributesSelector(instanceHeader,otherOutputs);
        }
        indices=Utils.getIndexCorrespondence(outputsToLearn,newOutputs);
        ((AMRulesFunction)learner).selectOutputsToLearn(indices);
      }
      ((AMRulesFunction)learner).resetWithMemory();
    }
 else {
      if (newOutputs.length != outputsToLearn.length) {
        int[] otherOutputs=Utils.complementSet(outputsToLearn,newOutputs);
        if (otherOutputs.length > 0) {
          otherOutputsLearningLiteral=new LearningLiteralRegression();
          MultiLabelLearner otherOutputsLearner=(MultiLabelLearner)learner.copy();
          otherOutputsLearner.resetLearning();
          otherOutputsLearningLiteral.learner=otherOutputsLearner;
          otherOutputsLearningLiteral.instanceHeader=instanceHeader;
          otherOutputsLearningLiteral.instanceTransformer=new InstanceOutputAttributesSelector(instanceHeader,otherOutputs);
        }
      }
      learner.resetLearning();
    }
    expandedLearningLiteral=new LearningLiteralRegression(newOutputs);
    expandedLearningLiteral.learner=(MultiLabelLearner)this.learner.copy();
    expandedLearningLiteral.instanceHeader=instanceHeader;
    expandedLearningLiteral.instanceTransformer=new InstanceOutputAttributesSelector(instanceHeader,newOutputs);
  }
  return shouldSplit;
}",0.668054110301769
64440,"@Override public void trainOnInstance(MultiLabelInstance instance){
  if (attributesMask == null)   initializeAttibutesMask(instance);
  int numOutputs=instance.numberOutputTargets();
  int numInputs=instance.numInputAttributes();
  if (!hasStarted) {
    if (outputsToLearn == null) {
      outputsToLearn=new int[numOutputs];
      for (int i=0; i < numOutputs; i++) {
        outputsToLearn[i]=i;
      }
    }
    if (inputsToLearn == null) {
      inputsToLearn=new int[numInputs];
      for (int i=0; i < numInputs; i++) {
        if (attributesMask[i])         inputsToLearn[i]=i;
      }
    }
    literalStatistics=new DoubleVector[outputsToLearn.length];
    varianceShift=new double[outputsToLearn.length];
    for (int i=0; i < outputsToLearn.length; i++) {
      literalStatistics[i]=new DoubleVector(new double[5]);
      varianceShift[i]=instance.valueOutputAttribute(outputsToLearn[i]);
    }
    if (outputsToLearn.length == instance.numOutputAttributes())     instanceTransformer=new NoInstanceTransformation();
 else     instanceTransformer=new InstanceOutputAttributesSelector((InstancesHeader)instance.dataset(),outputsToLearn);
    hasStarted=true;
  }
  double weight=instance.weight();
  DoubleVector[] exampleStatistics=new DoubleVector[outputsToLearn.length];
  for (int i=0; i < outputsToLearn.length; i++) {
    double target=instance.valueOutputAttribute(outputsToLearn[i]);
    double sum=weight * target;
    double squaredSum=weight * target * target;
    double sumShifted=weight * target - varianceShift[i];
    double squaredSumShifted=weight * (target - varianceShift[i]) * (target - varianceShift[i]);
    exampleStatistics[i]=new DoubleVector(new double[]{weight,sum,squaredSum,sumShifted,squaredSumShifted});
    literalStatistics[i].addValues(exampleStatistics[i].getArrayRef());
  }
  if (this.attributeObservers == null)   this.attributeObservers=new AutoExpandVector<AttributeStatisticsObserver>();
  for (int i=0; i < inputsToLearn.length; i++) {
    if (attributesMask[inputsToLearn[i]]) {
      AttributeStatisticsObserver obs=this.attributeObservers.get(inputsToLearn[i]);
      if (obs == null) {
        if (instance.attribute(inputsToLearn[i]).isNumeric()) {
          obs=((NumericStatisticsObserver)numericStatisticsObserver.copy());
        }
 else         if (instance.attribute(inputsToLearn[i]).isNominal()) {
          obs=((NominalStatisticsObserver)nominalStatisticsObserver.copy());
        }
        this.attributeObservers.set(inputsToLearn[i],obs);
      }
      obs.observeAttribute(instance.valueInputAttribute(inputsToLearn[i]),exampleStatistics);
    }
  }
  Instance transformedInstance=instanceTransformer.sourceInstanceToTarget(instance);
  Prediction prediction=null;
  Prediction targetPrediction=learner.getPredictionForInstance(transformedInstance);
  if (targetPrediction != null)   prediction=instanceTransformer.targetPredictionToSource(targetPrediction);
  if (prediction != null)   errorMeasurer.addPrediction(prediction,instance);
  learner.trainOnInstance(transformedInstance);
  weightSeen+=instance.weight();
}","@Override public void trainOnInstance(MultiLabelInstance instance){
  if (attributesMask == null)   initializeAttibutesMask(instance);
  int numOutputs=instance.numberOutputTargets();
  int numInputs=instance.numInputAttributes();
  if (!hasStarted) {
    if (outputsToLearn == null) {
      outputsToLearn=new int[numOutputs];
      for (int i=0; i < numOutputs; i++) {
        outputsToLearn[i]=i;
      }
    }
    if (inputsToLearn == null) {
      inputsToLearn=new int[numInputs];
      for (int i=0; i < numInputs; i++) {
        if (attributesMask[i])         inputsToLearn[i]=i;
      }
    }
    literalStatistics=new DoubleVector[outputsToLearn.length];
    varianceShift=new double[outputsToLearn.length];
    for (int i=0; i < outputsToLearn.length; i++) {
      literalStatistics[i]=new DoubleVector(new double[5]);
      varianceShift[i]=instance.valueOutputAttribute(outputsToLearn[i]);
    }
    instanceHeader=(InstancesHeader)instance.dataset();
    hasStarted=true;
  }
  double weight=instance.weight();
  DoubleVector[] exampleStatistics=new DoubleVector[outputsToLearn.length];
  for (int i=0; i < outputsToLearn.length; i++) {
    double target=instance.valueOutputAttribute(outputsToLearn[i]);
    double sum=weight * target;
    double squaredSum=weight * target * target;
    double sumShifted=weight * target - varianceShift[i];
    double squaredSumShifted=weight * (target - varianceShift[i]) * (target - varianceShift[i]);
    exampleStatistics[i]=new DoubleVector(new double[]{weight,sum,squaredSum,sumShifted,squaredSumShifted});
    literalStatistics[i].addValues(exampleStatistics[i].getArrayRef());
  }
  if (this.attributeObservers == null)   this.attributeObservers=new AutoExpandVector<AttributeStatisticsObserver>();
  for (int i=0; i < inputsToLearn.length; i++) {
    if (attributesMask[inputsToLearn[i]]) {
      AttributeStatisticsObserver obs=this.attributeObservers.get(inputsToLearn[i]);
      if (obs == null) {
        if (instance.attribute(inputsToLearn[i]).isNumeric()) {
          obs=((NumericStatisticsObserver)numericStatisticsObserver.copy());
        }
 else         if (instance.attribute(inputsToLearn[i]).isNominal()) {
          obs=((NominalStatisticsObserver)nominalStatisticsObserver.copy());
        }
        this.attributeObservers.set(inputsToLearn[i],obs);
      }
      obs.observeAttribute(instance.valueInputAttribute(inputsToLearn[i]),exampleStatistics);
    }
  }
  Instance transformedInstance=instanceTransformer.sourceInstanceToTarget(instance);
  Prediction prediction=null;
  Prediction targetPrediction=learner.getPredictionForInstance(transformedInstance);
  if (targetPrediction != null)   prediction=instanceTransformer.targetPredictionToSource(targetPrediction);
  if (prediction != null)   errorMeasurer.addPrediction(prediction,instance);
  learner.trainOnInstance(transformedInstance);
  weightSeen+=instance.weight();
}",0.9641726378936843
64441,"public boolean tryToExpand(double splitConfidence,double tieThresholdOption){
  boolean hasExpanded=learningLiteral.tryToExpand(splitConfidence,tieThresholdOption);
  if (hasExpanded) {
    LearningLiteral otherOutputsLiteral=learningLiteral.getOtherOutputsLearningLiteral();
    if (otherOutputsLiteral != null) {
      otherOutputsRule=new MultiLabelRule();
      otherOutputsRule.instanceInformation=instanceInformation;
      otherOutputsRule.literalList=new LinkedList<Literal>(literalList);
      otherOutputsRule.learningLiteral=otherOutputsLiteral;
    }
    otherBranchRule=new MultiLabelRule(learningLiteral.getOtherBranchLearningLiteral());
    int attribIndex=learningLiteral.getBestSuggestion().getPredicate().getAttributeIndex();
    boolean isEqualOrLess=learningLiteral.getBestSuggestion().getPredicate().isEqualOrLess();
    Iterator<Literal> it=literalList.iterator();
    while (it.hasNext()) {
      Literal l=it.next();
      if (l.predicate.getAttributeIndex() == attribIndex && l.predicate.isEqualOrLess() == isEqualOrLess) {
        it.remove();
        break;
      }
    }
    this.literalList.add(new Literal(learningLiteral.getBestSuggestion().getPredicate()));
    learningLiteral=learningLiteral.getExpandedLearningLiteral();
  }
  return hasExpanded;
}","public boolean tryToExpand(double splitConfidence,double tieThresholdOption){
  boolean hasExpanded=learningLiteral.tryToExpand(splitConfidence,tieThresholdOption);
  if (hasExpanded) {
    LearningLiteral otherOutputsLiteral=learningLiteral.getOtherOutputsLearningLiteral();
    if (otherOutputsLiteral != null && this.literalList.size() > 0) {
      otherOutputsRule=new MultiLabelRule();
      otherOutputsRule.instanceInformation=instanceInformation;
      otherOutputsRule.literalList=new LinkedList<Literal>(this.literalList);
      otherOutputsRule.learningLiteral=otherOutputsLiteral;
    }
    otherBranchRule=new MultiLabelRule((LearningLiteral)learningLiteral.getOtherBranchLearningLiteral());
    int attribIndex=learningLiteral.getBestSuggestion().getPredicate().getAttributeIndex();
    boolean isEqualOrLess=learningLiteral.getBestSuggestion().getPredicate().isEqualOrLess();
    Iterator<Literal> it=literalList.iterator();
    while (it.hasNext()) {
      Literal l=it.next();
      if (l.predicate.getAttributeIndex() == attribIndex && l.predicate.isEqualOrLess() == isEqualOrLess) {
        it.remove();
        break;
      }
    }
    this.literalList.add(new Literal(learningLiteral.getBestSuggestion().getPredicate()));
    learningLiteral=learningLiteral.getExpandedLearningLiteral();
  }
  return hasExpanded;
}",0.9797632684230624
64442,"@Override public Prediction computeWeightedVote(){
  int n=votes.size();
  if (n > 0) {
    int numOutputs=outputAttributesCount.length;
    weights=new double[n][numOutputs];
    weightedVote=new MultiLabelPrediction(numOutputs);
    double[] sumError=new double[numOutputs];
    for (int o=0; o < numOutputs; o++) {
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o) && errors.get(i) != null) {
          weights[i][o]=1.0 / (errors.get(i)[o] + EPS);
          sumError[o]+=weights[i][o];
        }
      }
      int numClasses=votes.get(0).numClasses(o);
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o)) {
          if (sumError[o] > 0)           weights[i][o]/=sumError[o];
 else           weights[i][o]=1.0 / outputAttributesCount[o];
        }
        for (int j=0; j < numClasses; j++) {
          weightedVote.setVote(o,j,weightedVote.getVote(o,j) + votes.get(i).getVote(o,j) * weights[i][o]);
        }
      }
    }
  }
  return weightedVote;
}","@Override public Prediction computeWeightedVote(){
  int n=votes.size();
  if (n > 0) {
    int numOutputs=outputAttributesCount.length;
    weights=new double[n][numOutputs];
    weightedVote=new MultiLabelPrediction(numOutputs);
    double[] sumError=new double[numOutputs];
    for (int o=0; o < numOutputs; o++) {
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o) && errors.get(i) != null) {
          weights[i][o]=1.0 / (errors.get(i)[o] + EPS);
          sumError[o]+=weights[i][o];
        }
      }
      for (int i=0; i < n; i++) {
        int numClasses=votes.get(i).numClasses(o);
        if (votes.get(i).hasVotesForAttribute(o)) {
          if (sumError[o] > 0)           weights[i][o]/=sumError[o];
 else           weights[i][o]=1.0 / outputAttributesCount[o];
        }
        for (int j=0; j < numClasses; j++) {
          weightedVote.setVote(o,j,weightedVote.getVote(o,j) + votes.get(i).getVote(o,j) * weights[i][o]);
        }
      }
    }
  }
  return weightedVote;
}",0.9510763209393346
64443,"@Override public Prediction computeWeightedVote(){
  int n=votes.size();
  if (n > 0) {
    int numOutputs=outputAttributesCount.length;
    weights=new double[n][numOutputs];
    weightedVote=new MultiLabelPrediction(numOutputs);
    for (int o=0; o < numOutputs; o++) {
      int numClasses=votes.get(0).numClasses(o);
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o))         weights[i][o]=1.0 / outputAttributesCount[o];
        for (int j=0; j < numClasses; j++) {
          weightedVote.setVote(o,j,weightedVote.getVote(o,j) + votes.get(i).getVote(o,j) * weights[i][o]);
        }
      }
    }
  }
  return weightedVote;
}","@Override public Prediction computeWeightedVote(){
  int n=votes.size();
  if (n > 0) {
    int numOutputs=outputAttributesCount.length;
    weights=new double[n][numOutputs];
    weightedVote=new MultiLabelPrediction(numOutputs);
    for (int o=0; o < numOutputs; o++) {
      for (int i=0; i < n; i++) {
        int numClasses=votes.get(i).numClasses(o);
        if (votes.get(i).hasVotesForAttribute(o))         weights[i][o]=1.0 / outputAttributesCount[o];
        for (int j=0; j < numClasses; j++) {
          weightedVote.setVote(o,j,weightedVote.getVote(o,j) + votes.get(i).getVote(o,j) * weights[i][o]);
        }
      }
    }
  }
  return weightedVote;
}",0.9246987951807228
64444,"/** 
 * getVotes extension of the instance method getVotesForInstance  in moa.classifier.java returns the prediction of the instance.
 */
public ErrorWeightedVoteMultiLabel getVotes(MultiLabelInstance instance){
  ErrorWeightedVoteMultiLabel errorWeightedVote=newErrorWeightedVote();
  VerboseToConsole(instance);
  for (  MultiLabelRule rule : ruleSet) {
    if (rule.isCovering(instance) == true) {
      Prediction vote=rule.getPredictionForInstance(instance);
      if (vote != null) {
        double[] errors=rule.getCurrentErrors();
        if (errors == null)         errors=defaultRuleErrors(vote);
        debug(""String_Node_Str"" + rule.getRuleNumberID() + ""String_Node_Str""+ vote.toString()+ ""String_Node_Str""+ errors+ ""String_Node_Str""+ instance.classValue(),3);
        errorWeightedVote.addVote(vote,errors);
      }
      if (!this.unorderedRulesOption.isSet()) {
        break;
      }
    }
  }
  if (!errorWeightedVote.coversAllOutputs()) {
    Prediction vote=errorWeightedVote.getPrediction();
    if (vote == null) {
      vote=new MultiLabelPrediction(instance.numberOutputTargets());
    }
    Prediction defaultVote=defaultRule.getPredictionForInstance(instance);
    if (defaultVote != null) {
      double[] defaultErrors=defaultRule.getCurrentErrors();
      double[] fixErrors=new double[vote.numOutputAttributes()];
      Prediction fixVote=new MultiLabelPrediction(vote.numOutputAttributes());
      for (int i=0; i < vote.numOutputAttributes(); i++) {
        if (!vote.hasVotesForAttribute(i)) {
          fixVote.setVotes(i,defaultVote.getVotes(i));
        }
      }
      errorWeightedVote.addVote(fixVote,fixErrors);
      debug(""String_Node_Str"" + defaultVote.toString() + ""String_Node_Str""+ defaultErrors+ ""String_Node_Str""+ instance,3);
    }
  }
  errorWeightedVote.computeWeightedVote();
  return errorWeightedVote;
}","/** 
 * getVotes extension of the instance method getVotesForInstance  in moa.classifier.java returns the prediction of the instance.
 */
public ErrorWeightedVoteMultiLabel getVotes(MultiLabelInstance instance){
  ErrorWeightedVoteMultiLabel errorWeightedVote=newErrorWeightedVote();
  VerboseToConsole(instance);
  for (  MultiLabelRule rule : ruleSet) {
    if (rule.isCovering(instance) == true) {
      Prediction vote=rule.getPredictionForInstance(instance);
      if (vote != null) {
        double[] errors=rule.getCurrentErrors();
        if (errors == null)         errors=defaultRuleErrors(vote);
        debug(""String_Node_Str"" + rule.getRuleNumberID() + ""String_Node_Str""+ vote.toString()+ ""String_Node_Str""+ errors+ ""String_Node_Str""+ instance.classValue(),3);
        errorWeightedVote.addVote(vote,errors);
      }
      if (!this.unorderedRulesOption.isSet()) {
        break;
      }
    }
  }
  if (!errorWeightedVote.coversAllOutputs()) {
    Prediction vote=errorWeightedVote.getPrediction();
    if (vote == null) {
      vote=new MultiLabelPrediction(instance.numberOutputTargets());
    }
    Prediction defaultVote=defaultRule.getPredictionForInstance(instance);
    if (defaultVote != null) {
      double[] defaultErrors=defaultRule.getCurrentErrors();
      if (defaultErrors == null)       defaultErrors=defaultRuleErrors(defaultVote);
      double[] fixErrors=new double[vote.numOutputAttributes()];
      Prediction fixVote=new MultiLabelPrediction(vote.numOutputAttributes());
      for (int i=0; i < vote.numOutputAttributes(); i++) {
        if (!vote.hasVotesForAttribute(i)) {
          fixVote.setVotes(i,defaultVote.getVotes(i));
          fixErrors[i]=defaultErrors[i];
        }
      }
      errorWeightedVote.addVote(fixVote,fixErrors);
      debug(""String_Node_Str"" + defaultVote.toString() + ""String_Node_Str""+ defaultErrors+ ""String_Node_Str""+ instance,3);
    }
  }
  errorWeightedVote.computeWeightedVote();
  return errorWeightedVote;
}",0.9411458333333332
64445,"@Override public Prediction computeWeightedVote(){
  int n=votes.size();
  if (n > 0) {
    int numOutputs=outputAttributesCount.length;
    weights=new double[n][numOutputs];
    weightedVote=new MultiLabelPrediction(numOutputs);
    double[] sumError=new double[numOutputs];
    for (int o=0; o < numOutputs; o++) {
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o) && errors.get(i) != null) {
          weights[i][o]=1.0 / (errors.get(i)[o] + EPS);
          sumError[o]+=weights[i][o];
        }
      }
      int numClasses=votes.get(0).numClasses(o);
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o)) {
          if (sumError[o] > 0)           weights[i][o]/=sumError[o];
 else           weights[i][o]=1.0 / outputAttributesCount[o];
        }
        for (int j=0; j < numClasses; j++) {
          weightedVote.setVote(o,j,weightedVote.getVote(o,j) + votes.get(i).getVote(o,j) * weights[i][o]);
        }
      }
    }
  }
  return weightedVote;
}","@Override public Prediction computeWeightedVote(){
  int n=votes.size();
  if (n > 0) {
    int numOutputs=outputAttributesCount.length;
    weights=new double[n][numOutputs];
    weightedVote=new MultiLabelPrediction(numOutputs);
    double[] sumError=new double[numOutputs];
    for (int o=0; o < numOutputs; o++) {
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o) && errors.get(i) != null) {
          weights[i][o]=1.0 / (errors.get(i)[o] + EPS);
          sumError[o]+=weights[i][o];
        }
      }
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o)) {
          if (sumError[o] > 0)           weights[i][o]/=sumError[o];
 else           weights[i][o]=1.0 / outputAttributesCount[o];
        }
        weightedVote.setVotes(o,votes.get(i).getVotes(o));
      }
    }
  }
  return weightedVote;
}",0.855026455026455
64446,"@Override public Prediction computeWeightedVote(){
  int n=votes.size();
  if (n > 0) {
    int numOutputs=outputAttributesCount.length;
    weights=new double[n][numOutputs];
    weightedVote=new MultiLabelPrediction(numOutputs);
    for (int o=0; o < numOutputs; o++) {
      int numClasses=votes.get(0).numClasses(o);
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o))         weights[i][o]=1.0 / outputAttributesCount[o];
        for (int j=0; j < numClasses; j++) {
          weightedVote.setVote(o,j,weightedVote.getVote(o,j) + votes.get(i).getVote(o,j) * weights[i][o]);
        }
      }
    }
  }
  return weightedVote;
}","@Override public Prediction computeWeightedVote(){
  int n=votes.size();
  if (n > 0) {
    int numOutputs=outputAttributesCount.length;
    weights=new double[n][numOutputs];
    weightedVote=new MultiLabelPrediction(numOutputs);
    for (int o=0; o < numOutputs; o++) {
      for (int i=0; i < n; i++) {
        if (votes.get(i).hasVotesForAttribute(o))         weights[i][o]=1.0 / outputAttributesCount[o];
        weightedVote.setVotes(o,votes.get(i).getVotes(o));
      }
    }
  }
  return weightedVote;
}",0.787052810902896
64447,"public double prediction(Instance inst,int classVal){
  double sum=0.0;
  for (int i=0; i < inst.numAttributes() - 1; i++) {
    sum+=weightAttribute[classVal][i] * inst.value(i);
  }
  sum+=weightAttribute[classVal][inst.numAttributes() - 1];
  return 1.0 / (1.0 + Math.exp(-sum));
}","public double prediction(Instance inst,int classVal){
  double sum=0.0;
  for (int i=0; i < inst.numAttributes() - 1; i++) {
    sum+=weightAttribute[classVal][i] * inst.valueInputAttribute(i);
  }
  sum+=weightAttribute[classVal][inst.numAttributes() - 1];
  return 1.0 / (1.0 + Math.exp(-sum));
}",0.9759450171821306
64448,"@Override public void trainOnInstanceImpl(Instance inst){
  if (this.reset == true) {
    this.reset=false;
    this.numberAttributes=inst.numAttributes();
    this.numberClasses=inst.numClasses();
    this.weightAttribute=new double[inst.numClasses()][inst.numAttributes()];
    for (int i=0; i < inst.numClasses(); i++) {
      for (int j=0; j < inst.numAttributes(); j++) {
        weightAttribute[i][j]=0.2 * Math.random() - 0.1;
      }
    }
  }
  double[] preds=new double[inst.numClasses()];
  for (int i=0; i < inst.numClasses(); i++) {
    preds[i]=prediction(inst,i);
  }
  double learningRatio=learningRatioOption.getValue();
  int actualClass=(int)inst.classValue();
  for (int i=0; i < inst.numClasses(); i++) {
    double actual=(i == actualClass) ? 1.0 : 0.0;
    double delta=(actual - preds[i]) * preds[i] * (1 - preds[i]);
    for (int j=0; j < inst.numAttributes() - 1; j++) {
      this.weightAttribute[i][j]+=learningRatio * delta * inst.value(j);
    }
    this.weightAttribute[i][inst.numAttributes() - 1]+=learningRatio * delta;
  }
}","@Override public void trainOnInstanceImpl(Instance inst){
  if (this.reset == true) {
    this.reset=false;
    this.numberAttributes=inst.numAttributes();
    this.numberClasses=inst.numClasses();
    this.weightAttribute=new double[inst.numClasses()][inst.numAttributes()];
    for (int i=0; i < inst.numClasses(); i++) {
      for (int j=0; j < inst.numAttributes(); j++) {
        weightAttribute[i][j]=0.2 * this.classifierRandom.nextDouble() - 0.1;
      }
    }
  }
  double[] preds=new double[inst.numClasses()];
  for (int i=0; i < inst.numClasses(); i++) {
    preds[i]=prediction(inst,i);
  }
  double learningRatio=learningRatioOption.getValue();
  int actualClass=(int)inst.classValue();
  for (int i=0; i < inst.numClasses(); i++) {
    double actual=(i == actualClass) ? 1.0 : 0.0;
    double delta=(actual - preds[i]) * preds[i] * (1 - preds[i]);
    for (int j=0; j < inst.numAttributes() - 1; j++) {
      this.weightAttribute[i][j]+=learningRatio * delta * inst.valueInputAttribute(j);
    }
    this.weightAttribute[i][inst.numAttributes() - 1]+=learningRatio * delta;
  }
}",0.973525313516024
64449,"@Override public boolean isRandomizable(){
  return false;
}","@Override public boolean isRandomizable(){
  return true;
}",0.9411764705882352
64450,"@Override public Learner[] getSublearners(){
  return null;
}","@Override public Learner[] getSublearners(){
  return getSubClassifiers();
}",0.8613138686131386
64451,"/** 
 * Instantiates a new arff loader.
 * @param reader the reader
 * @param range 
 * @param size the size
 * @param classAttribute the class attribute
 */
public ArffLoader(Reader reader,Range range){
  this.range=range;
  BufferedReader br=new BufferedReader(reader);
  streamTokenizer=new StreamTokenizer(br);
  streamTokenizer.resetSyntax();
  streamTokenizer.whitespaceChars(0,' ');
  streamTokenizer.wordChars(' ' + 1,'\u00FF');
  streamTokenizer.whitespaceChars(',',',');
  streamTokenizer.commentChar('%');
  streamTokenizer.quoteChar('""');
  streamTokenizer.quoteChar('\'');
  streamTokenizer.ordinaryChar('{');
  streamTokenizer.ordinaryChar('}');
  streamTokenizer.eolIsSignificant(true);
  this.instanceInformation=this.getHeader();
  if (range != null) {
    this.instanceInformation.setClassIndex(this.instanceInformation.inputInstanceInformation.numAttributes() - 1);
  }
}","/** 
 * Instantiates a new arff loader.
 * @param reader the reader
 * @param range 
 * @param size the size
 * @param classAttribute the class attribute
 */
public ArffLoader(Reader reader,Range range){
  this.range=range;
  BufferedReader br=new BufferedReader(reader);
  streamTokenizer=new StreamTokenizer(br);
  streamTokenizer.resetSyntax();
  streamTokenizer.whitespaceChars(0,' ');
  streamTokenizer.wordChars(' ' + 1,'\u00FF');
  streamTokenizer.whitespaceChars(',',',');
  streamTokenizer.commentChar('%');
  streamTokenizer.quoteChar('""');
  streamTokenizer.quoteChar('\'');
  streamTokenizer.ordinaryChar('{');
  streamTokenizer.ordinaryChar('}');
  streamTokenizer.eolIsSignificant(true);
  this.instanceInformation=this.getHeader();
  if (range != null) {
    this.instanceInformation.setClassIndex(Integer.MAX_VALUE);
  }
}",0.9537037037037036
64452,"public void setClassIndex(int classIndex){
  if (outputInstanceInformation.numAttributes() > 0) {
    this.inputInstanceInformation.attributes.add(classIndex,outputInstanceInformation.attributes.get(0));
    outputInstanceInformation.attributes.remove(0);
  }
  Attribute classAtribute=this.inputAttribute(classIndex);
  List<Attribute> listAttribute=new ArrayList<Attribute>();
  listAttribute.add(classAtribute);
  this.outputInstanceInformation.setAttributes(listAttribute);
  this.inputInstanceInformation.attributes.remove(classAtribute);
  this.classIndex=classIndex;
}","public void setClassIndex(int classIndex){
  if (classIndex < Integer.MAX_VALUE) {
    if (outputInstanceInformation.numAttributes() > 0) {
      this.inputInstanceInformation.attributes.add(classIndex,outputInstanceInformation.attributes.get(0));
      outputInstanceInformation.attributes.remove(0);
    }
    Attribute classAtribute=this.inputAttribute(classIndex);
    List<Attribute> listAttribute=new ArrayList<Attribute>();
    listAttribute.add(classAtribute);
    this.outputInstanceInformation.setAttributes(listAttribute);
    this.inputInstanceInformation.attributes.remove(classAtribute);
    this.classIndex=classIndex;
  }
}",0.8912685337726524
64453,"@Override public void trainOnInstanceImpl(Instance instance){
  numInstances+=instance.weight();
  debug(""String_Node_Str"",3);
  debug(""String_Node_Str"" + numInstances + ""String_Node_Str""+ instance.toString(),3);
  boolean rulesCoveringInstance=false;
  Iterator<Rule> ruleIterator=this.ruleSet.iterator();
  while (ruleIterator.hasNext()) {
    Rule rule=ruleIterator.next();
    if (rule.isCovering(instance) == true) {
      rulesCoveringInstance=true;
      if (isAnomaly(instance,rule) == false) {
        double error=rule.computeError(instance);
        boolean changeDetected=rule.getLearningNode().updateChangeDetection(error);
        if (changeDetected == true) {
          debug(""String_Node_Str"" + this.numInstances + ""String_Node_Str""+ rule.getInstancesSeen()+ ""String_Node_Str""+ rule.getRuleNumberID(),1);
          ruleIterator.remove();
          this.numChangesDetected+=instance.weight();
        }
 else {
          rule.updateStatistics(instance);
          if (rule.getInstancesSeen() % this.gracePeriodOption.getValue() == 0.0) {
            if (rule.tryToExpand(this.splitConfidenceOption.getValue(),this.tieThresholdOption.getValue())) {
              rule.split();
              debug(""String_Node_Str"",2);
              debug(rule.printRule(),2);
            }
          }
        }
        if (!this.unorderedRulesOption.isSet())         break;
      }
 else {
        debug(""String_Node_Str"" + this.numInstances + ""String_Node_Str""+ rule.getRuleNumberID(),1);
        this.numAnomaliesDetected=+instance.weight();
      }
    }
  }
  if (rulesCoveringInstance == false) {
    defaultRule.updateStatistics(instance);
    if (defaultRule.getInstancesSeen() % this.gracePeriodOption.getValue() == 0.0) {
      debug(""String_Node_Str"" + defaultRule.getInstancesSeen(),4);
      if (defaultRule.tryToExpand(this.splitConfidenceOption.getValue(),this.tieThresholdOption.getValue()) == true) {
        Rule newDefaultRule=newRule(defaultRule.getRuleNumberID(),defaultRule.getLearningNode(),defaultRule.getLearningNode().getStatisticsOtherBranchSplit());
        defaultRule.split();
        defaultRule.setRuleNumberID(++ruleNumberID);
        this.ruleSet.add(this.defaultRule);
        debug(""String_Node_Str"",2);
        debug(defaultRule.printRule(),2);
        debug(""String_Node_Str"",3);
        debug(newDefaultRule.printRule(),3);
        defaultRule=newDefaultRule;
      }
    }
  }
}","@Override public void trainOnInstanceImpl(Instance instance){
  numInstances+=instance.weight();
  debug(""String_Node_Str"",3);
  debug(""String_Node_Str"" + numInstances + ""String_Node_Str""+ instance.toString(),3);
  boolean rulesCoveringInstance=false;
  Iterator<Rule> ruleIterator=this.ruleSet.iterator();
  while (ruleIterator.hasNext()) {
    Rule rule=ruleIterator.next();
    if (rule.isCovering(instance) == true) {
      rulesCoveringInstance=true;
      if (isAnomaly(instance,rule) == false) {
        double error=rule.computeError(instance);
        boolean changeDetected=rule.getLearningNode().updateChangeDetection(error);
        if (changeDetected == true) {
          debug(""String_Node_Str"" + this.numInstances + ""String_Node_Str""+ rule.getInstancesSeen()+ ""String_Node_Str""+ rule.getRuleNumberID(),1);
          ruleIterator.remove();
          this.numChangesDetected+=instance.weight();
        }
 else {
          rule.updateStatistics(instance);
          if (rule.getInstancesSeen() % this.gracePeriodOption.getValue() == 0.0) {
            if (rule.tryToExpand(this.splitConfidenceOption.getValue(),this.tieThresholdOption.getValue())) {
              rule.split();
              debug(""String_Node_Str"",2);
              debug(rule.printRule(),2);
            }
          }
        }
        if (!this.unorderedRulesOption.isSet())         break;
      }
 else {
        debug(""String_Node_Str"" + this.numInstances + ""String_Node_Str""+ rule.getRuleNumberID(),1);
        this.numAnomaliesDetected+=instance.weight();
      }
    }
  }
  if (rulesCoveringInstance == false) {
    defaultRule.updateStatistics(instance);
    if (defaultRule.getInstancesSeen() % this.gracePeriodOption.getValue() == 0.0) {
      debug(""String_Node_Str"" + defaultRule.getInstancesSeen(),4);
      if (defaultRule.tryToExpand(this.splitConfidenceOption.getValue(),this.tieThresholdOption.getValue()) == true) {
        Rule newDefaultRule=newRule(defaultRule.getRuleNumberID(),defaultRule.getLearningNode(),defaultRule.getLearningNode().getStatisticsOtherBranchSplit());
        defaultRule.split();
        defaultRule.setRuleNumberID(++ruleNumberID);
        this.ruleSet.add(this.defaultRule);
        debug(""String_Node_Str"",2);
        debug(defaultRule.printRule(),2);
        debug(""String_Node_Str"",3);
        debug(newDefaultRule.printRule(),3);
        defaultRule=newDefaultRule;
      }
    }
  }
}",0.9995860927152318
64454,"@Override protected Measurement[] getModelMeasurementsImpl(){
  Measurement[] baseLearnerMeasurements=((AbstractAMRules)getPreparedClassOption(this.baseLearnerOption)).getModelMeasurements();
  int nMeasurements=baseLearnerMeasurements.length;
  Measurement[] m=new Measurement[nMeasurements + 1];
  for (int i=0; i < baseLearnerMeasurements.length; i++)   m[i + 1]=baseLearnerMeasurements[i];
  int ensembleSize=0;
  if (this.ensemble != null) {
    ensembleSize=this.ensemble.length;
    for (int i=0; i < nMeasurements; i++) {
      double value=0;
      for (int j=0; j < ensembleSize; ++j) {
        value+=baseLearnerMeasurements[i].getValue();
      }
      m[i + 1]=new Measurement(""String_Node_Str"" + baseLearnerMeasurements[i].getName(),value / nMeasurements);
    }
  }
  m[0]=new Measurement(""String_Node_Str"",ensembleSize);
  return m;
}","@Override protected Measurement[] getModelMeasurementsImpl(){
  Measurement[] baseLearnerMeasurements=((AbstractAMRules)getPreparedClassOption(this.baseLearnerOption)).getModelMeasurements();
  int nMeasurements=baseLearnerMeasurements.length;
  Measurement[] m=new Measurement[nMeasurements + 1];
  for (int i=0; i < baseLearnerMeasurements.length; i++)   m[i + 1]=baseLearnerMeasurements[i];
  int ensembleSize=0;
  if (this.ensemble != null) {
    ensembleSize=this.ensemble.length;
    for (int i=0; i < nMeasurements; i++) {
      double value=0;
      for (int j=0; j < ensembleSize; ++j) {
        value+=ensemble[j].getModelMeasurements()[i].getValue();
      }
      m[i + 1]=new Measurement(""String_Node_Str"" + baseLearnerMeasurements[i].getName(),value / ensembleSize);
    }
  }
  m[0]=new Measurement(""String_Node_Str"",ensembleSize);
  return m;
}",0.952046783625731
64455,"public void setRandomSeed(int randomSeed){
  this.randomSeed=randomSeed;
}","public void setRandomSeed(int randomSeed){
  this.classifierRandom.setSeed(randomSeed);
}",0.7730061349693251
64456,"public void learnFromInstance(Instance inst){
  nodeStatistics.addToValue(0,1);
  nodeStatistics.addToValue(1,inst.classValue());
  nodeStatistics.addToValue(2,inst.classValue() * inst.classValue());
  if (attributesMask == null) {
    numAttributesSelected=(int)Math.round((inst.numAttributes() - 1) * this.amRules.getAttributesPercentage()) / 100;
    attributesMask=new boolean[inst.numAttributes()];
    ArrayList<Integer> indices=new ArrayList<Integer>();
    for (int i=0; i < inst.numAttributes() && i != inst.classIndex(); i++)     indices.add(i);
    indices.add(inst.classIndex());
    Collections.shuffle(indices,this.amRules.classifierRandom);
    for (int i=0; i < numAttributesSelected; ++i)     attributesMask[indices.get(i)]=true;
  }
  for (int i=0, ct=0; i < attributesMask.length; i++) {
    if (attributesMask[i]) {
      AttributeClassObserver obs=this.attributeObservers.get(ct);
      if (obs == null) {
        if (inst.attribute(ct).isNumeric()) {
          obs=newNumericClassObserver();
          this.attributeObservers.set(ct,obs);
        }
      }
      if (obs != null) {
        ((FIMTDDNumericAttributeClassObserver)obs).observeAttributeClass(inst.value(i),inst.classValue(),inst.weight());
      }
      ++ct;
    }
  }
}","public void learnFromInstance(Instance inst){
  nodeStatistics.addToValue(0,1);
  nodeStatistics.addToValue(1,inst.classValue());
  nodeStatistics.addToValue(2,inst.classValue() * inst.classValue());
  if (attributesMask == null) {
    numAttributesSelected=(int)Math.round((inst.numAttributes() - 1) * this.amRules.getAttributesPercentage()) / 100;
    attributesMask=new boolean[inst.numAttributes()];
    ArrayList<Integer> indices=new ArrayList<Integer>();
    for (int i=0; i < inst.numAttributes() && i != inst.classIndex(); i++)     indices.add(i);
    Collections.shuffle(indices,this.amRules.classifierRandom);
    indices.add(inst.classIndex());
    for (int i=0; i < numAttributesSelected; ++i)     attributesMask[indices.get(i)]=true;
  }
  for (int i=0, ct=0; i < attributesMask.length; i++) {
    if (attributesMask[i]) {
      AttributeClassObserver obs=this.attributeObservers.get(ct);
      if (obs == null) {
        if (inst.attribute(ct).isNumeric()) {
          obs=newNumericClassObserver();
          this.attributeObservers.set(ct,obs);
        }
      }
      if (obs != null) {
        ((FIMTDDNumericAttributeClassObserver)obs).observeAttributeClass(inst.value(i),inst.classValue(),inst.weight());
      }
      ++ct;
    }
  }
}",0.9713375796178344
64457,"@Override public void resetLearningImpl(){
  this.ensemble=new Classifier[this.ensembleSizeOption.getValue()];
  AbstractAMRules baseLearner=(AbstractAMRules)getPreparedClassOption(this.baseLearnerOption);
  baseLearner.setAttributesPercentage(numAttributesPercentageOption.getValue());
  baseLearner.resetLearning();
  for (int i=0; i < this.ensemble.length; i++) {
    this.ensemble[i]=baseLearner.copy();
  }
  this.isRegression=(baseLearner instanceof Regressor);
}","@Override public void resetLearningImpl(){
  this.ensemble=new Classifier[this.ensembleSizeOption.getValue()];
  AbstractAMRules baseLearner=(AbstractAMRules)getPreparedClassOption(this.baseLearnerOption);
  baseLearner.setAttributesPercentage(numAttributesPercentageOption.getValue());
  baseLearner.resetLearning();
  for (int i=0; i < this.ensemble.length; i++) {
    this.ensemble[i]=baseLearner.copy();
    this.ensemble[i].setRandomSeed(this.classifierRandom.nextInt());
  }
  this.isRegression=(baseLearner instanceof Regressor);
}",0.9314796425024826
64458,"public void runVisual(){
  int processCounter=0;
  int speedCounter=0;
  LinkedList<DataPoint> pointBuffer0=new LinkedList<DataPoint>();
  while (work || processCounter != 0) {
    if (m_stream0.hasMoreInstances()) {
      timestamp++;
      speedCounter++;
      processCounter++;
      if (timestamp % 100 == 0) {
        m_visualPanel.setProcessedPointsCounter(timestamp);
      }
      Instance next0=m_stream0.nextInstance();
      DataPoint point0=new DataPoint(next0,timestamp);
      pointBuffer0.add(point0);
      while (pointBuffer0.size() > m_stream0_decayHorizon) {
        pointBuffer0.removeFirst();
      }
      if (m_visualPanel.isEnabledDrawPoints()) {
        m_streampanel0.drawPoint(point0);
        if (m_clusterer1 != null)         m_streampanel1.drawPoint(point0);
        if (processCounter % m_redrawInterval == 0) {
          m_streampanel0.applyDrawDecay(m_stream0_decayHorizon / (float)(m_redrawInterval));
          if (m_clusterer1 != null)           m_streampanel1.applyDrawDecay(m_stream0_decayHorizon / (float)(m_redrawInterval));
        }
      }
      Instance traininst0=new DenseInstance(point0);
      if (m_clusterer0.keepClassLabel())       traininst0.setDataset(point0.dataset());
 else       traininst0.deleteAttributeAt(point0.classIndex());
      m_clusterer0.trainOnInstanceImpl(traininst0);
      if (m_clusterer1 != null) {
        Instance traininst1=new DenseInstance(point0);
        if (m_clusterer1.keepClassLabel())         traininst1.setDataset(point0.dataset());
 else         traininst1.deleteAttributeAt(point0.classIndex());
        m_clusterer1.trainOnInstanceImpl(traininst1);
      }
      if (processCounter >= m_processFrequency) {
        processCounter=0;
        for (        DataPoint p : pointBuffer0)         p.updateWeight(timestamp,m_stream0_decay_rate);
        ArrayList<DataPoint> pointarray0=new ArrayList<DataPoint>(pointBuffer0);
        ArrayList<DataPoint> pointarray1=new ArrayList<DataPoint>(pointBuffer0);
        processClusterings(pointarray0,pointarray1);
        int pauseInterval=m_visualPanel.getPauseInterval();
        if (pauseInterval != 0 && lastPauseTimestamp + pauseInterval <= timestamp) {
          m_visualPanel.toggleVisualizer(true);
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      return;
    }
    if (speedCounter > m_wait_frequency * 30 && m_wait_frequency < 15) {
      try {
synchronized (this) {
          if (m_wait_frequency == 0)           wait(50);
 else           wait(1);
        }
      }
 catch (      InterruptedException ex) {
      }
      speedCounter=0;
    }
  }
  if (!stop) {
    m_streampanel0.drawPointPanels(pointBuffer0,timestamp,m_stream0_decay_rate,m_stream0_decay_threshold);
    if (m_clusterer1 != null)     m_streampanel1.drawPointPanels(pointBuffer0,timestamp,m_stream0_decay_rate,m_stream0_decay_threshold);
    work_pause();
  }
}","public void runVisual(){
  int processCounter=0;
  int speedCounter=0;
  LinkedList<DataPoint> pointBuffer0=new LinkedList<DataPoint>();
  LinkedList<DataPoint> pointBuffer1=new LinkedList<DataPoint>();
  ArrayList<DataPoint> pointarray0=null;
  ArrayList<DataPoint> pointarray1=null;
  while (work || processCounter != 0) {
    if (m_stream0.hasMoreInstances()) {
      timestamp++;
      speedCounter++;
      processCounter++;
      if (timestamp % 100 == 0) {
        m_visualPanel.setProcessedPointsCounter(timestamp);
      }
      Instance next0=m_stream0.nextInstance();
      DataPoint point0=new DataPoint(next0,timestamp);
      pointBuffer0.add(point0);
      while (pointBuffer0.size() > m_stream0_decayHorizon) {
        pointBuffer0.removeFirst();
      }
      DataPoint point1=null;
      if (m_clusterer1 != null) {
        point1=new DataPoint(next0,timestamp);
        pointBuffer1.add(point1);
        while (pointBuffer1.size() > m_stream0_decayHorizon) {
          pointBuffer1.removeFirst();
        }
      }
      if (m_visualPanel.isEnabledDrawPoints()) {
        m_streampanel0.drawPoint(point0);
        if (m_clusterer1 != null)         m_streampanel1.drawPoint(point1);
        if (processCounter % m_redrawInterval == 0) {
          m_streampanel0.applyDrawDecay(m_stream0_decayHorizon / (float)(m_redrawInterval));
          if (m_clusterer1 != null)           m_streampanel1.applyDrawDecay(m_stream0_decayHorizon / (float)(m_redrawInterval));
        }
      }
      Instance traininst0=new DenseInstance(point0);
      if (m_clusterer0.keepClassLabel())       traininst0.setDataset(point0.dataset());
 else       traininst0.deleteAttributeAt(point0.classIndex());
      m_clusterer0.trainOnInstanceImpl(traininst0);
      if (m_clusterer1 != null) {
        Instance traininst1=new DenseInstance(point1);
        if (m_clusterer1.keepClassLabel())         traininst1.setDataset(point1.dataset());
 else         traininst1.deleteAttributeAt(point1.classIndex());
        m_clusterer1.trainOnInstanceImpl(traininst1);
      }
      if (processCounter >= m_processFrequency) {
        processCounter=0;
        for (        DataPoint p : pointBuffer0)         p.updateWeight(timestamp,m_stream0_decay_rate);
        pointarray0=new ArrayList<DataPoint>(pointBuffer0);
        if (m_clusterer1 != null) {
          for (          DataPoint p : pointBuffer1)           p.updateWeight(timestamp,m_stream0_decay_rate);
          pointarray1=new ArrayList<DataPoint>(pointBuffer1);
        }
        processClusterings(pointarray0,pointarray1);
        int pauseInterval=m_visualPanel.getPauseInterval();
        if (pauseInterval != 0 && lastPauseTimestamp + pauseInterval <= timestamp) {
          m_visualPanel.toggleVisualizer(true);
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      return;
    }
    if (speedCounter > m_wait_frequency * 30 && m_wait_frequency < 15) {
      try {
synchronized (this) {
          if (m_wait_frequency == 0)           wait(50);
 else           wait(1);
        }
      }
 catch (      InterruptedException ex) {
      }
      speedCounter=0;
    }
  }
  if (!stop) {
    m_streampanel0.drawPointPanels(pointarray0,timestamp,m_stream0_decay_rate,m_stream0_decay_threshold);
    if (m_clusterer1 != null)     m_streampanel1.drawPointPanels(pointarray1,timestamp,m_stream0_decay_rate,m_stream0_decay_threshold);
    work_pause();
  }
}",0.8563309125355226
64459,"void drawPointPanels(LinkedList<DataPoint> pointBuffer,int timestamp,double decay_rate,double decay_threshold){
  for (int p=0; p < pointBuffer.size(); p++) {
    PointPanel pointPanel=new PointPanel(pointBuffer.get(p),decay_rate,decay_threshold);
    layerPoints.add(pointPanel);
    pointPanel.updateLocation();
  }
  layerPointCanvas.setVisible(false);
  layerPoints.setVisible(pointsVisible);
}","void drawPointPanels(ArrayList<DataPoint> points,int timestamp,double decay_rate,double decay_threshold){
  for (int p=0; p < points.size(); p++) {
    PointPanel pointPanel=new PointPanel(points.get(p),decay_rate,decay_threshold);
    layerPoints.add(pointPanel);
    pointPanel.updateLocation();
  }
  layerPointCanvas.setVisible(false);
  layerPoints.setVisible(pointsVisible);
}",0.4871794871794871
64460,"public GenerateReferenceParetoSetAndFrontFromDoubleSolutions(Experiment<?,?> experimentConfiguration){
  this.experiment=experimentConfiguration;
  experiment.removeDuplicatedAlgorithms();
}","public GenerateReferenceParetoSetAndFrontFromDoubleSolutions(Experiment<?,?> experimentConfiguration){
  this.experiment=experimentConfiguration;
}",0.8724035608308606
64461,"/** 
 * The run() method creates de output directory and compute the fronts
 */
@Override public void run() throws IOException {
  String outputDirectoryName=experiment.getReferenceFrontDirectory();
  createOutputDirectory(outputDirectoryName);
  List<String> referenceFrontFileNames=new LinkedList<>();
  for (  ExperimentProblem<?> problem : experiment.getProblemList()) {
    List<DoubleSolution> nonDominatedSolutions=getNonDominatedSolutions(problem);
    referenceFrontFileNames.add(problem.getTag() + ""String_Node_Str"");
    writeReferenceFrontFile(outputDirectoryName,problem,nonDominatedSolutions);
    writeReferenceSetFile(outputDirectoryName,problem,nonDominatedSolutions);
    writeFilesWithTheSolutionsContributedByEachAlgorithm(outputDirectoryName,problem,nonDominatedSolutions);
  }
}","/** 
 * The run() method creates de output directory and compute the fronts
 */
@Override public void run() throws IOException {
  String outputDirectoryName=experiment.getReferenceFrontDirectory();
  createOutputDirectory(outputDirectoryName);
  List<String> referenceFrontFileNames=new LinkedList<>();
  for (  ExperimentProblem<?> problem : experiment.getProblemList()) {
    List<DoubleSolution> nonDominatedSolutions=getNonDominatedSolutions(problem);
    referenceFrontFileNames.add(problem.getReferenceFront());
    writeReferenceFrontFile(outputDirectoryName,problem,nonDominatedSolutions);
    writeReferenceSetFile(outputDirectoryName,problem,nonDominatedSolutions);
    writeFilesWithTheSolutionsContributedByEachAlgorithm(outputDirectoryName,problem,nonDominatedSolutions);
  }
}",0.9742300439974858
64462,"/** 
 * Create a list of non dominated   {@link DoubleSolution} solutions from the FUNx.tsv and VARx.tsv files thatmust have been previously obtained (probably by invoking the  {@link ExecuteAlgorithms#run} method).
 * @param problem
 * @return
 * @throws FileNotFoundException
 */
private List<DoubleSolution> getNonDominatedSolutions(ExperimentProblem<?> problem) throws FileNotFoundException {
  NonDominatedSolutionListArchive<DoubleSolution> nonDominatedSolutionArchive=new NonDominatedSolutionListArchive<DoubleSolution>();
  for (  ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList()) {
    String problemDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getAlgorithmTag()+ ""String_Node_Str""+ problem.getTag();
    for (int i=0; i < experiment.getIndependentRuns(); i++) {
      String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
      String paretoSetFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoSetFileName()+ i+ ""String_Node_Str"";
      Front frontWithObjectiveValues=new ArrayFront(frontFileName);
      Front frontWithVariableValues=new ArrayFront(paretoSetFileName);
      List<DoubleSolution> solutionList=createSolutionListFrontFiles(algorithm.getAlgorithmTag(),frontWithVariableValues,frontWithObjectiveValues);
      for (      DoubleSolution solution : solutionList) {
        nonDominatedSolutionArchive.add(solution);
      }
    }
  }
  return nonDominatedSolutionArchive.getSolutionList();
}","/** 
 * Create a list of non dominated   {@link DoubleSolution} solutions from the FUNx.tsv and VARx.tsv files thatmust have been previously obtained (probably by invoking the  {@link ExecuteAlgorithms#run} method).
 * @param problem
 * @return
 * @throws FileNotFoundException
 */
private List<DoubleSolution> getNonDominatedSolutions(ExperimentProblem<?> problem) throws FileNotFoundException {
  NonDominatedSolutionListArchive<DoubleSolution> nonDominatedSolutionArchive=new NonDominatedSolutionListArchive<DoubleSolution>();
  for (  ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList().stream().filter(s -> s.getProblemTag().equals(problem.getTag())).collect(Collectors.toCollection(ArrayList::new))) {
    String problemDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getAlgorithmTag()+ ""String_Node_Str""+ problem.getTag();
    String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ algorithm.getRunId()+ ""String_Node_Str"";
    String paretoSetFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoSetFileName()+ algorithm.getRunId()+ ""String_Node_Str"";
    Front frontWithObjectiveValues=new ArrayFront(frontFileName);
    Front frontWithVariableValues=new ArrayFront(paretoSetFileName);
    List<DoubleSolution> solutionList=createSolutionListFrontFiles(algorithm.getAlgorithmTag(),frontWithVariableValues,frontWithObjectiveValues);
    for (    DoubleSolution solution : solutionList) {
      nonDominatedSolutionArchive.add(solution);
    }
  }
  return nonDominatedSolutionArchive.getSolutionList();
}",0.8370927318295739
64463,"private void writeReferenceFrontFile(String outputDirectoryName,ExperimentProblem<?> problem,List<DoubleSolution> nonDominatedSolutions) throws IOException {
  String referenceFrontFileName=outputDirectoryName + ""String_Node_Str"" + problem.getTag()+ ""String_Node_Str"";
  new SolutionListOutput(nonDominatedSolutions).printObjectivesToFile(referenceFrontFileName);
}","private void writeReferenceFrontFile(String outputDirectoryName,ExperimentProblem<?> problem,List<DoubleSolution> nonDominatedSolutions) throws IOException {
  String referenceFrontFileName=outputDirectoryName + ""String_Node_Str"" + problem.getReferenceFront();
  new SolutionListOutput(nonDominatedSolutions).printObjectivesToFile(referenceFrontFileName);
}",0.9501385041551248
64464,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  AbstractGenericSolution<?,?> that=(AbstractGenericSolution<?,?>)o;
  if (!attributes.equals(that.attributes))   return false;
  if (!Arrays.equals(objectives,that.objectives))   return false;
  if (!variables.equals(that.variables))   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (!this.equalsIgnoringAttributes(o)) {
    return false;
  }
  AbstractGenericSolution<?,?> that=(AbstractGenericSolution<?,?>)o;
  if (attributes.size() != that.attributes.size()) {
    return false;
  }
  for (  Object key : attributes.keySet()) {
    Object value=attributes.get(key);
    Object valueThat=that.attributes.get(key);
    if (value != valueThat) {
      if (value == null) {
        return false;
      }
 else       if (valueThat == null) {
        return false;
      }
 else {
        boolean areAttributeValuesEqual;
        if (value instanceof AbstractGenericSolution) {
          areAttributeValuesEqual=((AbstractGenericSolution)value).equalsIgnoringAttributes(valueThat);
        }
 else {
          areAttributeValuesEqual=!value.equals(valueThat);
        }
        if (!areAttributeValuesEqual) {
          return false;
        }
      }
    }
  }
  return true;
}",0.2273402674591381
64465,"/** 
 * Constructor 
 */
public ExecuteAlgorithms(Experiment<S,Result> configuration){
  this.experiment=configuration;
}","/** 
 * Constructor
 */
public ExecuteAlgorithms(Experiment<S,Result> configuration){
  this.experiment=configuration;
}",0.995850622406639
64466,"@Override public void run(){
  JMetalLogger.logger.info(""String_Node_Str"");
  prepareOutputDirectory();
  System.setProperty(""String_Node_Str"",""String_Node_Str"" + this.experiment.getNumberOfCores());
  for (int i=0; i < experiment.getIndependentRuns(); i++) {
    final int id=i;
    experiment.getAlgorithmList().parallelStream().forEach(algorithm -> algorithm.runAlgorithm(id,experiment));
  }
}","@Override public void run(){
  JMetalLogger.logger.info(""String_Node_Str"");
  prepareOutputDirectory();
  System.setProperty(""String_Node_Str"",""String_Node_Str"" + this.experiment.getNumberOfCores());
  experiment.getAlgorithmList().parallelStream().forEach(algorithm -> algorithm.runAlgorithm(experiment));
}",0.873758865248227
64467,"public ExperimentAlgorithm(Algorithm<Result> algorithm,String problemTag){
  this(algorithm,algorithm.getName(),problemTag);
}","public ExperimentAlgorithm(Algorithm<Result> algorithm,String problemTag,int runId){
  this(algorithm,algorithm.getName(),problemTag,runId);
}",0.9402985074626866
64468,"public void runAlgorithm(int id,Experiment<?,?> experimentData){
  String outputDirectoryName=experimentData.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmTag+ ""String_Node_Str""+ problemTag;
  File outputDirectory=new File(outputDirectoryName);
  if (!outputDirectory.exists()) {
    boolean result=new File(outputDirectoryName).mkdirs();
    if (result) {
      JMetalLogger.logger.info(""String_Node_Str"" + outputDirectoryName);
    }
 else {
      JMetalLogger.logger.severe(""String_Node_Str"" + outputDirectoryName + ""String_Node_Str"");
    }
  }
  String funFile=outputDirectoryName + ""String_Node_Str"" + id+ ""String_Node_Str"";
  String varFile=outputDirectoryName + ""String_Node_Str"" + id+ ""String_Node_Str"";
  JMetalLogger.logger.info(""String_Node_Str"" + algorithmTag + ""String_Node_Str""+ problemTag+ ""String_Node_Str""+ id+ ""String_Node_Str""+ funFile);
  algorithm.run();
  Result population=algorithm.getResult();
  new SolutionListOutput((List<S>)population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(varFile)).setFunFileOutputContext(new DefaultFileOutputContext(funFile)).print();
}","public void runAlgorithm(Experiment<?,?> experimentData){
  String outputDirectoryName=experimentData.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmTag+ ""String_Node_Str""+ problemTag;
  File outputDirectory=new File(outputDirectoryName);
  if (!outputDirectory.exists()) {
    boolean result=new File(outputDirectoryName).mkdirs();
    if (result) {
      JMetalLogger.logger.info(""String_Node_Str"" + outputDirectoryName);
    }
 else {
      JMetalLogger.logger.severe(""String_Node_Str"" + outputDirectoryName + ""String_Node_Str"");
    }
  }
  String funFile=outputDirectoryName + ""String_Node_Str"" + runId+ ""String_Node_Str"";
  String varFile=outputDirectoryName + ""String_Node_Str"" + runId+ ""String_Node_Str"";
  JMetalLogger.logger.info(""String_Node_Str"" + algorithmTag + ""String_Node_Str""+ problemTag+ ""String_Node_Str""+ runId+ ""String_Node_Str""+ funFile);
  algorithm.run();
  Result population=algorithm.getResult();
  new SolutionListOutput((List<S>)population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(varFile)).setFunFileOutputContext(new DefaultFileOutputContext(funFile)).print();
}",0.990426457789382
64469,"/** 
 * The algorithm list is composed of pairs   {@link Algorithm} + {@link Problem} which form part ofa  {@link ExperimentAlgorithm}, which is a decorator for class   {@link Algorithm}.
 */
static List<ExperimentAlgorithm<BinarySolution,List<BinarySolution>>> configureAlgorithmList(List<ExperimentProblem<BinarySolution>> problemList){
  List<ExperimentAlgorithm<BinarySolution,List<BinarySolution>>> algorithms=new ArrayList<>();
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<BinarySolution>> algorithm=new NSGAIIBuilder<BinarySolution>(problemList.get(i).getProblem(),new SinglePointCrossover(1.0),new BitFlipMutation(1.0 / ((BinaryProblem)problemList.get(i).getProblem()).getNumberOfBits(0))).setMaxEvaluations(25000).setPopulationSize(100).build();
    algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag()));
  }
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<BinarySolution>> algorithm=new SPEA2Builder<BinarySolution>(problemList.get(i).getProblem(),new SinglePointCrossover(1.0),new BitFlipMutation(1.0 / ((BinaryProblem)problemList.get(i).getProblem()).getNumberOfBits(0))).setMaxIterations(250).setPopulationSize(100).build();
    algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag()));
  }
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<BinarySolution>> algorithm=new MOCellBuilder<BinarySolution>(problemList.get(i).getProblem(),new SinglePointCrossover(1.0),new BitFlipMutation(1.0 / ((BinaryProblem)problemList.get(i).getProblem()).getNumberOfBits(0))).setMaxEvaluations(25000).setPopulationSize(100).build();
    algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag()));
  }
  for (int i=0; i < problemList.size(); i++) {
    CrossoverOperator<BinarySolution> crossoverOperator;
    MutationOperator<BinarySolution> mutationOperator;
    SelectionOperator<List<BinarySolution>,BinarySolution> parentsSelection;
    SelectionOperator<List<BinarySolution>,List<BinarySolution>> newGenerationSelection;
    crossoverOperator=new HUXCrossover(1.0);
    parentsSelection=new RandomSelection<BinarySolution>();
    newGenerationSelection=new RankingAndCrowdingSelection<BinarySolution>(100);
    mutationOperator=new BitFlipMutation(0.35);
    Algorithm<List<BinarySolution>> algorithm=new MOCHCBuilder((BinaryProblem)problemList.get(i).getProblem()).setInitialConvergenceCount(0.25).setConvergenceValue(3).setPreservedPopulation(0.05).setPopulationSize(100).setMaxEvaluations(25000).setCrossover(crossoverOperator).setNewGenerationSelection(newGenerationSelection).setCataclysmicMutation(mutationOperator).setParentSelection(parentsSelection).setEvaluator(new SequentialSolutionListEvaluator<BinarySolution>()).build();
    algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag()));
  }
  return algorithms;
}","/** 
 * The algorithm list is composed of pairs   {@link Algorithm} + {@link Problem} which form part ofa  {@link ExperimentAlgorithm}, which is a decorator for class   {@link Algorithm}.
 */
static List<ExperimentAlgorithm<BinarySolution,List<BinarySolution>>> configureAlgorithmList(List<ExperimentProblem<BinarySolution>> problemList){
  List<ExperimentAlgorithm<BinarySolution,List<BinarySolution>>> algorithms=new ArrayList<>();
  for (int run=0; run < INDEPENDENT_RUNS; run++) {
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<BinarySolution>> algorithm=new NSGAIIBuilder<BinarySolution>(problemList.get(i).getProblem(),new SinglePointCrossover(1.0),new BitFlipMutation(1.0 / ((BinaryProblem)problemList.get(i).getProblem()).getNumberOfBits(0))).setMaxEvaluations(25000).setPopulationSize(100).build();
      algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag(),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<BinarySolution>> algorithm=new SPEA2Builder<BinarySolution>(problemList.get(i).getProblem(),new SinglePointCrossover(1.0),new BitFlipMutation(1.0 / ((BinaryProblem)problemList.get(i).getProblem()).getNumberOfBits(0))).setMaxIterations(250).setPopulationSize(100).build();
      algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag(),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<BinarySolution>> algorithm=new MOCellBuilder<BinarySolution>(problemList.get(i).getProblem(),new SinglePointCrossover(1.0),new BitFlipMutation(1.0 / ((BinaryProblem)problemList.get(i).getProblem()).getNumberOfBits(0))).setMaxEvaluations(25000).setPopulationSize(100).build();
      algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag(),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      CrossoverOperator<BinarySolution> crossoverOperator;
      MutationOperator<BinarySolution> mutationOperator;
      SelectionOperator<List<BinarySolution>,BinarySolution> parentsSelection;
      SelectionOperator<List<BinarySolution>,List<BinarySolution>> newGenerationSelection;
      crossoverOperator=new HUXCrossover(1.0);
      parentsSelection=new RandomSelection<BinarySolution>();
      newGenerationSelection=new RankingAndCrowdingSelection<BinarySolution>(100);
      mutationOperator=new BitFlipMutation(0.35);
      Algorithm<List<BinarySolution>> algorithm=new MOCHCBuilder((BinaryProblem)problemList.get(i).getProblem()).setInitialConvergenceCount(0.25).setConvergenceValue(3).setPreservedPopulation(0.05).setPopulationSize(100).setMaxEvaluations(25000).setCrossover(crossoverOperator).setNewGenerationSelection(newGenerationSelection).setCataclysmicMutation(mutationOperator).setParentSelection(parentsSelection).setEvaluator(new SequentialSolutionListEvaluator<BinarySolution>()).build();
      algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag(),run));
    }
  }
  return algorithms;
}",0.9715744680851064
64470,"/** 
 * The algorithm list is composed of pairs   {@link Algorithm} + {@link Problem} which form part ofa  {@link ExperimentAlgorithm}, which is a decorator for class   {@link Algorithm}. The   {@link ExperimentAlgorithm} has an optional tag component, that can be set as it is shown in this example,where four variants of a same algorithm are defined.
 */
static List<ExperimentAlgorithm<DoubleSolution,List<DoubleSolution>>> configureAlgorithmList(List<ExperimentProblem<DoubleSolution>> problemList){
  List<ExperimentAlgorithm<DoubleSolution,List<DoubleSolution>>> algorithms=new ArrayList<>();
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<>(problemList.get(i).getProblem(),new SBXCrossover(1.0,20),new PolynomialMutation(1.0 / problemList.get(i).getProblem().getNumberOfVariables(),20.0)).setMaxEvaluations(25000).setPopulationSize(100).build();
    algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag()));
  }
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<DoubleSolution>> algorithm=new SPEA2Builder<DoubleSolution>(problemList.get(i).getProblem(),new SBXCrossover(1.0,10.0),new PolynomialMutation(1.0 / problemList.get(i).getProblem().getNumberOfVariables(),20.0)).build();
    algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag()));
  }
  for (int i=0; i < problemList.size(); i++) {
    double mutationProbability=1.0 / problemList.get(i).getProblem().getNumberOfVariables();
    double mutationDistributionIndex=20.0;
    Algorithm<List<DoubleSolution>> algorithm=new SMPSOBuilder((DoubleProblem)problemList.get(i).getProblem(),new CrowdingDistanceArchive<DoubleSolution>(100)).setMutation(new PolynomialMutation(mutationProbability,mutationDistributionIndex)).setMaxIterations(250).setSwarmSize(100).setSolutionListEvaluator(new SequentialSolutionListEvaluator<DoubleSolution>()).build();
    algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag()));
  }
  for (int i=0; i < problemList.size(); i++) {
    double cr=0.5;
    double f=0.5;
    Algorithm<List<DoubleSolution>> algorithm=new GDE3Builder((DoubleProblem)problemList.get(i).getProblem()).setCrossover(new DifferentialEvolutionCrossover(cr,f,""String_Node_Str"")).setSelection(new DifferentialEvolutionSelection()).setMaxEvaluations(25000).setPopulationSize(100).setSolutionSetEvaluator(new SequentialSolutionListEvaluator<>()).build();
    algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag()));
  }
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<DoubleSolution>> algorithm=new MOCellBuilder<DoubleSolution>((DoubleProblem)problemList.get(i).getProblem(),new SBXCrossover(1.0,20.0),new PolynomialMutation(1.0 / problemList.get(i).getProblem().getNumberOfVariables(),20.0)).setSelectionOperator(new BinaryTournamentSelection<>()).setMaxEvaluations(25000).setPopulationSize(100).setArchive(new CrowdingDistanceArchive<DoubleSolution>(100)).build();
    algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag()));
  }
  return algorithms;
}","/** 
 * The algorithm list is composed of pairs   {@link Algorithm} + {@link Problem} which form part ofa  {@link ExperimentAlgorithm}, which is a decorator for class   {@link Algorithm}. The   {@link ExperimentAlgorithm} has an optional tag component, that can be set as it is shown in this example,where four variants of a same algorithm are defined.
 */
static List<ExperimentAlgorithm<DoubleSolution,List<DoubleSolution>>> configureAlgorithmList(List<ExperimentProblem<DoubleSolution>> problemList){
  List<ExperimentAlgorithm<DoubleSolution,List<DoubleSolution>>> algorithms=new ArrayList<>();
  for (int run=0; run < INDEPENDENT_RUNS; run++) {
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<>(problemList.get(i).getProblem(),new SBXCrossover(1.0,20),new PolynomialMutation(1.0 / problemList.get(i).getProblem().getNumberOfVariables(),20.0)).setMaxEvaluations(25000).setPopulationSize(100).build();
      algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag(),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<DoubleSolution>> algorithm=new SPEA2Builder<DoubleSolution>(problemList.get(i).getProblem(),new SBXCrossover(1.0,10.0),new PolynomialMutation(1.0 / problemList.get(i).getProblem().getNumberOfVariables(),20.0)).build();
      algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag(),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      double mutationProbability=1.0 / problemList.get(i).getProblem().getNumberOfVariables();
      double mutationDistributionIndex=20.0;
      Algorithm<List<DoubleSolution>> algorithm=new SMPSOBuilder((DoubleProblem)problemList.get(i).getProblem(),new CrowdingDistanceArchive<DoubleSolution>(100)).setMutation(new PolynomialMutation(mutationProbability,mutationDistributionIndex)).setMaxIterations(250).setSwarmSize(100).setSolutionListEvaluator(new SequentialSolutionListEvaluator<DoubleSolution>()).build();
      algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag(),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      double cr=0.5;
      double f=0.5;
      Algorithm<List<DoubleSolution>> algorithm=new GDE3Builder((DoubleProblem)problemList.get(i).getProblem()).setCrossover(new DifferentialEvolutionCrossover(cr,f,""String_Node_Str"")).setSelection(new DifferentialEvolutionSelection()).setMaxEvaluations(25000).setPopulationSize(100).setSolutionSetEvaluator(new SequentialSolutionListEvaluator<>()).build();
      algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag(),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<DoubleSolution>> algorithm=new MOCellBuilder<DoubleSolution>((DoubleProblem)problemList.get(i).getProblem(),new SBXCrossover(1.0,20.0),new PolynomialMutation(1.0 / problemList.get(i).getProblem().getNumberOfVariables(),20.0)).setSelectionOperator(new BinaryTournamentSelection<>()).setMaxEvaluations(25000).setPopulationSize(100).setArchive(new CrowdingDistanceArchive<DoubleSolution>(100)).build();
      algorithms.add(new ExperimentAlgorithm<>(algorithm,problemList.get(i).getTag(),run));
    }
  }
  return algorithms;
}",0.9732519943688408
64471,"private void writeReferenceSetFile(String outputDirectoryName,Problem<?> problem,List<DoubleSolution> nonDominatedSolutions) throws IOException {
  String referenceSetFileName=outputDirectoryName + ""String_Node_Str"" + problem.getName()+ ""String_Node_Str"";
  new SolutionListOutput(nonDominatedSolutions).printVariablesToFile(referenceSetFileName);
}","private void writeReferenceSetFile(String outputDirectoryName,ExperimentProblem<?> problem,List<DoubleSolution> nonDominatedSolutions) throws IOException {
  String referenceSetFileName=outputDirectoryName + ""String_Node_Str"" + problem.getTag()+ ""String_Node_Str"";
  new SolutionListOutput(nonDominatedSolutions).printVariablesToFile(referenceSetFileName);
}",0.975954738330976
64472,"/** 
 * The run() method creates de output directory and compute the fronts
 */
@Override public void run() throws IOException {
  String outputDirectoryName=experiment.getReferenceFrontDirectory();
  createOutputDirectory(outputDirectoryName);
  List<String> referenceFrontFileNames=new LinkedList<>();
  for (  ExperimentProblem<?> problem : experiment.getProblemList()) {
    List<DoubleSolution> nonDominatedSolutions=getNonDominatedSolutions(problem.getProblem());
    referenceFrontFileNames.add(problem.getTag() + ""String_Node_Str"");
    writeReferenceFrontFile(outputDirectoryName,problem.getProblem(),nonDominatedSolutions);
    writeReferenceSetFile(outputDirectoryName,problem.getProblem(),nonDominatedSolutions);
    writeFilesWithTheSolutionsContributedByEachAlgorithm(outputDirectoryName,problem.getProblem(),nonDominatedSolutions);
  }
  experiment.setReferenceFrontFileNames(referenceFrontFileNames);
}","/** 
 * The run() method creates de output directory and compute the fronts
 */
@Override public void run() throws IOException {
  String outputDirectoryName=experiment.getReferenceFrontDirectory();
  createOutputDirectory(outputDirectoryName);
  List<String> referenceFrontFileNames=new LinkedList<>();
  for (  ExperimentProblem<?> problem : experiment.getProblemList()) {
    List<DoubleSolution> nonDominatedSolutions=getNonDominatedSolutions(problem);
    referenceFrontFileNames.add(problem.getTag() + ""String_Node_Str"");
    writeReferenceFrontFile(outputDirectoryName,problem,nonDominatedSolutions);
    writeReferenceSetFile(outputDirectoryName,problem,nonDominatedSolutions);
    writeFilesWithTheSolutionsContributedByEachAlgorithm(outputDirectoryName,problem,nonDominatedSolutions);
  }
  experiment.setReferenceFrontFileNames(referenceFrontFileNames);
}",0.8228699551569507
64473,"private void writeFilesWithTheSolutionsContributedByEachAlgorithm(String outputDirectoryName,Problem<?> problem,List<DoubleSolution> nonDominatedSolutions) throws IOException {
  GenericSolutionAttribute<DoubleSolution,String> solutionAttribute=new GenericSolutionAttribute<DoubleSolution,String>();
  for (  ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList()) {
    List<DoubleSolution> solutionsPerAlgorithm=new ArrayList<>();
    for (    DoubleSolution solution : nonDominatedSolutions) {
      if (algorithm.getAlgorithmTag().equals(solutionAttribute.getAttribute(solution))) {
        solutionsPerAlgorithm.add(solution);
      }
    }
    new SolutionListOutput(solutionsPerAlgorithm).printObjectivesToFile(outputDirectoryName + ""String_Node_Str"" + problem.getName()+ ""String_Node_Str""+ algorithm.getAlgorithmTag()+ ""String_Node_Str"");
    new SolutionListOutput(solutionsPerAlgorithm).printVariablesToFile(outputDirectoryName + ""String_Node_Str"" + problem.getName()+ ""String_Node_Str""+ algorithm.getAlgorithmTag()+ ""String_Node_Str"");
  }
}","private void writeFilesWithTheSolutionsContributedByEachAlgorithm(String outputDirectoryName,ExperimentProblem<?> problem,List<DoubleSolution> nonDominatedSolutions) throws IOException {
  GenericSolutionAttribute<DoubleSolution,String> solutionAttribute=new GenericSolutionAttribute<DoubleSolution,String>();
  for (  ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList()) {
    List<DoubleSolution> solutionsPerAlgorithm=new ArrayList<>();
    for (    DoubleSolution solution : nonDominatedSolutions) {
      if (algorithm.getAlgorithmTag().equals(solutionAttribute.getAttribute(solution))) {
        solutionsPerAlgorithm.add(solution);
      }
    }
    new SolutionListOutput(solutionsPerAlgorithm).printObjectivesToFile(outputDirectoryName + ""String_Node_Str"" + problem.getTag()+ ""String_Node_Str""+ algorithm.getAlgorithmTag()+ ""String_Node_Str"");
    new SolutionListOutput(solutionsPerAlgorithm).printVariablesToFile(outputDirectoryName + ""String_Node_Str"" + problem.getTag()+ ""String_Node_Str""+ algorithm.getAlgorithmTag()+ ""String_Node_Str"");
  }
}",0.9428838951310862
64474,"/** 
 * Create a list of non dominated   {@link DoubleSolution} solutions from the FUNx.tsv and VARx.tsv files thatmust have been previously obtained (probably by invoking the  {@link ExecuteAlgorithms#run} method).
 * @param problem
 * @return
 * @throws FileNotFoundException
 */
private List<DoubleSolution> getNonDominatedSolutions(Problem<?> problem) throws FileNotFoundException {
  NonDominatedSolutionListArchive<DoubleSolution> nonDominatedSolutionArchive=new NonDominatedSolutionListArchive<DoubleSolution>();
  for (  ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList()) {
    String problemDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getAlgorithmTag()+ ""String_Node_Str""+ problem.getName();
    for (int i=0; i < experiment.getIndependentRuns(); i++) {
      String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
      String paretoSetFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoSetFileName()+ i+ ""String_Node_Str"";
      Front frontWithObjectiveValues=new ArrayFront(frontFileName);
      Front frontWithVariableValues=new ArrayFront(paretoSetFileName);
      List<DoubleSolution> solutionList=createSolutionListFrontFiles(algorithm.getAlgorithmTag(),frontWithVariableValues,frontWithObjectiveValues);
      for (      DoubleSolution solution : solutionList) {
        nonDominatedSolutionArchive.add(solution);
      }
    }
  }
  return nonDominatedSolutionArchive.getSolutionList();
}","/** 
 * Create a list of non dominated   {@link DoubleSolution} solutions from the FUNx.tsv and VARx.tsv files thatmust have been previously obtained (probably by invoking the  {@link ExecuteAlgorithms#run} method).
 * @param problem
 * @return
 * @throws FileNotFoundException
 */
private List<DoubleSolution> getNonDominatedSolutions(ExperimentProblem<?> problem) throws FileNotFoundException {
  NonDominatedSolutionListArchive<DoubleSolution> nonDominatedSolutionArchive=new NonDominatedSolutionListArchive<DoubleSolution>();
  for (  ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList()) {
    String problemDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getAlgorithmTag()+ ""String_Node_Str""+ problem.getTag();
    for (int i=0; i < experiment.getIndependentRuns(); i++) {
      String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
      String paretoSetFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoSetFileName()+ i+ ""String_Node_Str"";
      Front frontWithObjectiveValues=new ArrayFront(frontFileName);
      Front frontWithVariableValues=new ArrayFront(paretoSetFileName);
      List<DoubleSolution> solutionList=createSolutionListFrontFiles(algorithm.getAlgorithmTag(),frontWithVariableValues,frontWithObjectiveValues);
      for (      DoubleSolution solution : solutionList) {
        nonDominatedSolutionArchive.add(solution);
      }
    }
  }
  return nonDominatedSolutionArchive.getSolutionList();
}",0.9945460378569136
64475,"private void writeReferenceFrontFile(String outputDirectoryName,Problem<?> problem,List<DoubleSolution> nonDominatedSolutions) throws IOException {
  String referenceFrontFileName=outputDirectoryName + ""String_Node_Str"" + problem.getName()+ ""String_Node_Str"";
  new SolutionListOutput(nonDominatedSolutions).printObjectivesToFile(referenceFrontFileName);
}","private void writeReferenceFrontFile(String outputDirectoryName,ExperimentProblem<?> problem,List<DoubleSolution> nonDominatedSolutions) throws IOException {
  String referenceFrontFileName=outputDirectoryName + ""String_Node_Str"" + problem.getTag()+ ""String_Node_Str"";
  new SolutionListOutput(nonDominatedSolutions).printObjectivesToFile(referenceFrontFileName);
}",0.9764216366158114
64476,"@Override protected void updateProgress(){
  evaluations.increment(getMaxPopulationSize());
  solutionListMeasure.push(getPopulation());
  hypervolumeValue.push(new PISAHypervolume<S>(referenceFront).evaluate(getNonDominatedSolutions(getPopulation())));
}","@Override protected void updateProgress(){
  evaluations.increment(getMaxPopulationSize());
  solutionListMeasure.push(getPopulation());
  if (referenceFront.getNumberOfPoints() > 0) {
    hypervolumeValue.push(new PISAHypervolume<S>(referenceFront).evaluate(getNonDominatedSolutions(getPopulation())));
  }
}",0.9042553191489362
64477,"public double computeHypervolume(List<S> solutionList,Point referencePoint){
  double hv=0.0;
  if (solutionList.size() == 0) {
    hv=0.0;
  }
 else {
    numberOfObjectives=solutionList.get(0).getNumberOfObjectives();
    this.referencePoint=referencePoint;
    if (numberOfObjectives == 2) {
      Collections.sort(solutionList,new ObjectiveComparator<S>(0,ObjectiveComparator.Ordering.DESCENDING));
      hv=get2DHV(solutionList);
    }
 else {
      WfgHypervolumeVersion wfgHv=new WfgHypervolumeVersion(numberOfObjectives,solutionList.size());
      hv=wfgHv.getHV(new WfgHypervolumeFront(solutionList));
    }
  }
  return hv;
}","public double computeHypervolume(List<S> solutionList,Point referencePoint){
  double hv=0.0;
  if (solutionList.size() == 0) {
    hv=0.0;
  }
 else {
    numberOfObjectives=solutionList.get(0).getNumberOfObjectives();
    this.referencePoint=referencePoint;
    if (numberOfObjectives == 2) {
      Collections.sort(solutionList,new ObjectiveComparator<S>(1,ObjectiveComparator.Ordering.DESCENDING));
      hv=get2DHV(solutionList);
    }
 else {
      WfgHypervolumeVersion wfgHv=new WfgHypervolumeVersion(numberOfObjectives,solutionList.size());
      hv=wfgHv.getHV(new WfgHypervolumeFront(solutionList));
    }
  }
  return hv;
}",0.9984251968503935
64478,"/** 
 * Computes the HV of a solution list. REQUIRES: The problem is bi-objective REQUIRES: The setArchive is ordered in descending order by the second objective
 * @return
 */
public double get2DHV(List<? extends Solution<?>> solutionSet){
  double hv=0.0;
  if (solutionSet.size() > 0) {
    hv=Math.abs((solutionSet.get(0).getObjective(0) - referencePoint.getDimensionValue(0)) * (solutionSet.get(0).getObjective(1) - referencePoint.getDimensionValue(1)));
    for (int i=1; i < solutionSet.size(); i++) {
      double tmp=Math.abs((solutionSet.get(i).getObjective(0) - referencePoint.getDimensionValue(0)) * (solutionSet.get(i).getObjective(1) - solutionSet.get(i - 1).getObjective(1)));
      hv+=tmp;
    }
  }
  return hv;
}","/** 
 * Computes the HV of a solution list. REQUIRES: The problem is bi-objective REQUIRES: The setArchive is ordered in descending order by the second objective
 * @return
 */
public double get2DHV(List<? extends Solution<?>> solutionSet){
  double hv=0.0;
  if (solutionSet.size() > 0) {
    hv=Math.abs((solutionSet.get(0).getObjective(0) - referencePoint.getDimensionValue(0)) * (solutionSet.get(0).getObjective(1) - referencePoint.getDimensionValue(1)));
    for (int i=1; i < solutionSet.size(); i++) {
      double tmp;
      tmp=Math.abs((solutionSet.get(i).getObjective(0) - referencePoint.getDimensionValue(0)) * (solutionSet.get(i).getObjective(1) - solutionSet.get(i - 1).getObjective(1)));
      hv+=tmp;
    }
  }
  return hv;
}",0.992532247114732
64479,"/** 
 * CASE 1: solution set -> front obtained from the ZDT1.rf file. Reference front: [0,1], [1,0]
 * @throws FileNotFoundException
 */
@Test public void shouldEvaluateWorkProperlyCase1() throws FileNotFoundException {
  Front referenceFront=new ArrayFront(2,2);
  referenceFront.setPoint(0,new ArrayPoint(new double[]{1.0,0.0}));
  referenceFront.setPoint(0,new ArrayPoint(new double[]{0.0,1.0}));
  Front storeFront=new ArrayFront(""String_Node_Str"");
  DoubleProblem problem=new MockDoubleProblem(2);
  List<DoubleSolution> frontToEvaluate=new ArrayList<>();
  for (int i=0; i < storeFront.getNumberOfPoints(); i++) {
    DoubleSolution solution=problem.createSolution();
    solution.setObjective(0,storeFront.getPoint(i).getDimensionValue(0));
    solution.setObjective(1,storeFront.getPoint(i).getDimensionValue(1));
    frontToEvaluate.add(solution);
  }
  WFGHypervolume<DoubleSolution> hypervolume=new WFGHypervolume<>();
  double result=hypervolume.computeHypervolume(frontToEvaluate,new ArrayPoint(new double[]{0.0,1.0}));
  System.out.println(""String_Node_Str"" + result);
  assertEquals(0.6661,result,0.0001);
}","/** 
 * CASE 1: solution set -> front composed of the points [0.25, 0.75] and [0.75, 0.25]. Reference point: [0,0]
 */
@Test public void shouldEvaluateWorkProperlyCase1() throws FileNotFoundException {
  DoubleProblem problem=new MockDoubleProblem(2);
  List<DoubleSolution> frontToEvaluate=new ArrayList<>();
  DoubleSolution solution=problem.createSolution();
  solution.setObjective(0,0.25);
  solution.setObjective(1,0.75);
  frontToEvaluate.add(solution);
  solution=problem.createSolution();
  solution.setObjective(0,0.75);
  solution.setObjective(1,0.25);
  frontToEvaluate.add(solution);
  WFGHypervolume<DoubleSolution> hypervolume=new WFGHypervolume<>();
  double result=hypervolume.computeHypervolume(frontToEvaluate,new ArrayPoint(new double[]{1.0,1.0}));
  System.out.println(""String_Node_Str"" + result);
  assertEquals(0.25 * 0.75 + 0.25 * 0.5,result,0.0001);
}",0.464232116058029
64480,"public GWASFGA(Problem<S> problem,int populationSize,int maxIterations,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator,SolutionListEvaluator<S> evaluator){
  super(problem,populationSize,maxIterations,crossoverOperator,mutationOperator,selectionOperator,evaluator,null);
  setMaxPopulationSize(populationSize);
  double[][] weights=WeightVector.initUniformWeights2D(0.005,getMaxPopulationSize());
  int halfVectorSize=weights.length / 2;
  int evenVectorsSize=(weights.length % 2 == 0) ? halfVectorSize : (halfVectorSize + 1);
  int oddVectorsSize=halfVectorSize;
  double[][] evenVectors=new double[evenVectorsSize][getProblem().getNumberOfObjectives()];
  double[][] oddVectors=new double[oddVectorsSize][getProblem().getNumberOfObjectives()];
  int index=0;
  for (int i=0; i < weights.length; i=i + 2)   evenVectors[index++]=weights[i];
  index=0;
  for (int i=1; i < weights.length; i=i + 2)   oddVectors[index++]=weights[i];
  this.achievementScalarizingNadir=createUtilityFunction(this.getNadirPoint(),evenVectors);
  this.achievementScalarizingUtopia=createUtilityFunction(this.getReferencePoint(),oddVectors);
}","public GWASFGA(Problem<S> problem,int populationSize,int maxIterations,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator,SolutionListEvaluator<S> evaluator){
  super(problem,populationSize,maxIterations,crossoverOperator,mutationOperator,selectionOperator,evaluator,null);
  setMaxPopulationSize(populationSize);
  WeightVector weightVector=new WeightVector();
  double[][] weights=weightVector.initUniformWeights2D(0.005,getMaxPopulationSize());
  int halfVectorSize=weights.length / 2;
  int evenVectorsSize=(weights.length % 2 == 0) ? halfVectorSize : (halfVectorSize + 1);
  int oddVectorsSize=halfVectorSize;
  double[][] evenVectors=new double[evenVectorsSize][getProblem().getNumberOfObjectives()];
  double[][] oddVectors=new double[oddVectorsSize][getProblem().getNumberOfObjectives()];
  int index=0;
  for (int i=0; i < weights.length; i=i + 2)   evenVectors[index++]=weights[i];
  index=0;
  for (int i=1; i < weights.length; i=i + 2)   oddVectors[index++]=weights[i];
  this.achievementScalarizingNadir=createUtilityFunction(this.getNadirPoint(),evenVectors);
  this.achievementScalarizingUtopia=createUtilityFunction(this.getReferencePoint(),oddVectors);
}",0.970467596390484
64481,"/** 
 * Constructor
 * @param problem Problem to solve
 */
public WASFGA(Problem<S> problem,int populationSize,int maxIterations,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator,SolutionListEvaluator<S> evaluator,List<Double> referencePoint){
  super(problem,maxIterations,crossoverOperator,mutationOperator,selectionOperator,evaluator);
  setMaxPopulationSize(populationSize);
  this.interestPoint=referencePoint;
  this.achievementScalarizingFunction=createUtilityFunction();
}","/** 
 * Constructor
 * @param problem Problem to solve
 */
public WASFGA(Problem<S> problem,int populationSize,int maxIterations,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator,SolutionListEvaluator<S> evaluator,List<Double> referencePoint){
  this(problem,populationSize,maxIterations,crossoverOperator,mutationOperator,selectionOperator,evaluator,referencePoint,""String_Node_Str"");
}",0.805528134254689
64482,"protected Ranking<S> computeRanking(List<S> solutionList){
  Ranking<S> ranking=new WASFGARanking<>(this.achievementScalarizingFunction);
  ranking.computeRanking(solutionList);
  return ranking;
}","protected Ranking<S> computeRanking(List<S> solutionList){
  Ranking<S> ranking=new WASFGARankingConstraint<>(this.achievementScalarizingFunction);
  ranking.computeRanking(solutionList);
  return ranking;
}",0.9752475247524752
64483,"public AbstractUtilityFunctionsSet<S> createUtilityFunction(){
  double[][] weights=WeightVector.initUniformWeights2D(0.005,getMaxPopulationSize());
  weights=WeightVector.invertWeights(weights,true);
  ASFWASFGA<S> aux=new ASFWASFGA<>(weights,interestPoint);
  return aux;
}","public AbstractUtilityFunctionsSet<S> createUtilityFunction(){
  WeightVector weightVector=new WeightVector();
  double[][] weights;
  if (""String_Node_Str"".equals(this.weightVectorsFileName)) {
    weights=weightVector.initUniformWeights2D(0.005,getMaxPopulationSize());
  }
 else {
    weights=weightVector.getWeightsFromFile(this.weightVectorsFileName);
  }
  weights=WeightVector.invertWeights(weights,true);
  if (weights.length != maxPopulationSize) {
    throw new JMetalException(""String_Node_Str"" + weights.length + ""String_Node_Str""+ maxPopulationSize+ ""String_Node_Str"");
  }
  ASFWASFGA<S> aux=new ASFWASFGA<>(weights,interestPoint);
  return aux;
}",0.5854700854700855
64484,"/** 
 * Returns the euclidean distance between a pair of solutions in the objective space
 * @param firstSolution
 * @param secondSolution
 * @return
 */
static <S extends Solution<?>>double distanceBetweenObjectives(S firstSolution,S secondSolution){
  double diff;
  double distance=0.0;
  for (int nObj=0; nObj < firstSolution.getNumberOfObjectives(); nObj++) {
    diff=firstSolution.getObjective(nObj) - secondSolution.getObjective(nObj);
    distance+=Math.pow(diff,2.0);
  }
  return Math.sqrt(distance);
}","/** 
 * Returns the euclidean distance between a pair of solutions in the objective space
 */
public static <S extends Solution<?>>double distanceBetweenObjectives(S firstSolution,S secondSolution){
  double diff;
  double distance=0.0;
  for (int nObj=0; nObj < firstSolution.getNumberOfObjectives(); nObj++) {
    diff=firstSolution.getObjective(nObj) - secondSolution.getObjective(nObj);
    distance+=Math.pow(diff,2.0);
  }
  return Math.sqrt(distance);
}",0.9290853031860226
64485,"/** 
 * Return the best solution between those passed as arguments. If they are equal or incomparable one of them is chosen based on the given policy.
 * @param solution1
 * @param solution2
 * @param equalityPolicy
 * @return The best solution
 */
public static <S extends Solution<?>>S getBestSolution(S solution1,S solution2,Comparator<S> comparator,BinaryOperator<S> equalityPolicy){
  S result;
  int flag=comparator.compare(solution1,solution2);
  if (flag == -1) {
    result=solution1;
  }
 else   if (flag == 1) {
    result=solution2;
  }
 else {
    result=equalityPolicy.apply(solution1,solution2);
  }
  return result;
}","/** 
 * Return the best solution between those passed as arguments. If they are equal or incomparable one of them is chosen based on the given policy.
 * @return The best solution
 */
public static <S extends Solution<?>>S getBestSolution(S solution1,S solution2,Comparator<S> comparator,BinaryOperator<S> equalityPolicy){
  S result;
  int flag=comparator.compare(solution1,solution2);
  if (flag == -1) {
    result=solution1;
  }
 else   if (flag == 1) {
    result=solution2;
  }
 else {
    result=equalityPolicy.apply(solution1,solution2);
  }
  return result;
}",0.945878434637802
64486,"/** 
 * Returns the minimum distance from a <code>Solution</code> to a <code>SolutionSet according to the encodings.variable values</code>.
 * @param solution The <code>Solution</code>.
 * @param solutionList The <code>List<Solution></></code>.
 * @return The minimum distance between solution and the set.
 */
public static double distanceToSolutionListInSolutionSpace(DoubleSolution solution,List<DoubleSolution> solutionList){
  double distance=Double.MAX_VALUE;
  for (int i=0; i < solutionList.size(); i++) {
    double aux=distanceBetweenSolutions(solution,solutionList.get(i));
    if (aux < distance)     distance=aux;
  }
  return distance;
}","/** 
 * Returns the minimum distance from a <code>Solution</code> to a <code>SolutionSet according to the encodings.variable values</code>.
 * @param solution     The <code>Solution</code>.
 * @param solutionList The <code>List<Solution></></code>.
 * @return The minimum distance between solution and the set.
 */
public static double distanceToSolutionListInSolutionSpace(DoubleSolution solution,List<DoubleSolution> solutionList){
  double distance=Double.MAX_VALUE;
  for (int i=0; i < solutionList.size(); i++) {
    double aux=distanceBetweenSolutions(solution,solutionList.get(i));
    if (aux < distance)     distance=aux;
  }
  return distance;
}",0.996937212863706
64487,"public RNSGAIIRanking(PreferenceNSGAII<S> utilityFunctions,double epsilon,List<Double> interestPoint){
  this.utilityFunctions=utilityFunctions;
  this.epsilon=epsilon;
  referencePoint=interestPoint;
}","public RNSGAIIRanking(PreferenceNSGAII<S> utilityFunctions,double epsilon,List<Double> interestPoint){
  this.utilityFunctions=utilityFunctions;
  this.epsilon=epsilon;
  referencePoint=interestPoint;
  this.numberOfViolatedConstraints=new NumberOfViolatedConstraints<S>();
}",0.8469601677148847
64488,"private void removeRank(S solution){
  boolean enc=false;
  int i=0;
  while (i < this.rankedSubpopulations.size()) {
    enc=this.rankedSubpopulations.get(i).contains(solution);
    if (enc) {
      this.rankedSubpopulations.get(i).remove(solution);
    }
    i++;
  }
}","private void removeRank(S solution){
  boolean enc=false;
  int i=0;
  while (i < this.rankedSubpopulations.size()) {
    while (this.rankedSubpopulations.get(i).contains(solution)) {
      this.rankedSubpopulations.get(i).remove(solution);
    }
    i++;
  }
}",0.7669172932330827
64489,"@Override public Ranking<S> computeRanking(List<S> population){
  int size=population.size();
  List<Double> upperBound=new ArrayList<>();
  List<Double> lowerBound=new ArrayList<>();
  int numberObjectives=population.get(0).getNumberOfObjectives();
  for (int i=0; i < population.get(0).getNumberOfObjectives(); i++) {
    Collections.sort(population,new ObjectiveComparator<S>(i));
    double objetiveMinn=population.get(0).getObjective(i);
    double objetiveMaxn=population.get(population.size() - 1).getObjective(i);
    upperBound.add(objetiveMaxn);
    lowerBound.add(objetiveMinn);
  }
  this.utilityFunctions.setLowerBounds(lowerBound);
  this.utilityFunctions.setUpperBounds(upperBound);
  List<S> temporalList=new LinkedList();
  temporalList.addAll(population);
  int numberOfPoint=this.referencePoint.size() / numberObjectives;
  int indexReference=0;
  this.numberOfRanks=population.size() + 1;
  this.rankedSubpopulations=new ArrayList(this.numberOfRanks);
  for (int i=0; i < numberOfRanks - 1; i++) {
    this.rankedSubpopulations.add(new ArrayList<>());
  }
  for (int i=0; i < numberOfPoint; i++) {
    List<Double> interestPoint=nextInterestPoint(indexReference,numberObjectives);
    indexReference+=numberObjectives;
    this.utilityFunctions.updatePointOfInterest(interestPoint);
    SortedMap<Double,S> map=new TreeMap<>();
    for (    S solution : temporalList) {
      double value=this.utilityFunctions.evaluate(solution).doubleValue();
      map.put(value,solution);
    }
    int rank=0;
    List<S> populationOrder=new ArrayList<>(map.values());
    for (    S solution : populationOrder) {
      this.setAttribute(solution,rank);
      this.rankedSubpopulations.get(rank).add(solution);
      rank++;
    }
  }
  while (!temporalList.isEmpty()) {
    int indexRandom=JMetalRandom.getInstance().nextInt(0,temporalList.size() - 1);
    S solutionRandom=temporalList.get(indexRandom);
    temporalList.remove(indexRandom);
    for (int i=0; i < temporalList.size(); i++) {
      S solution=temporalList.get(i);
      double sum=this.preference(solutionRandom,solution,upperBound,lowerBound);
      if (sum < epsilon) {
        removeRank(solution);
        this.setAttribute(solution,this.rankedSubpopulations.size() - 1);
        List<S> rankListAux=this.rankedSubpopulations.get(this.rankedSubpopulations.size() - 1);
        if (rankListAux == null) {
          rankListAux=new ArrayList();
        }
        rankListAux.add(solution);
        temporalList.remove(i);
      }
    }
  }
  return this;
}","@Override public Ranking<S> computeRanking(List<S> population){
  int size=population.size();
  List<Double> upperBound=new ArrayList<>();
  List<Double> lowerBound=new ArrayList<>();
  int numberObjectives=population.get(0).getNumberOfObjectives();
  for (int i=0; i < population.get(0).getNumberOfObjectives(); i++) {
    Collections.sort(population,new ObjectiveComparator<S>(i));
    double objetiveMinn=population.get(0).getObjective(i);
    double objetiveMaxn=population.get(population.size() - 1).getObjective(i);
    upperBound.add(objetiveMaxn);
    lowerBound.add(objetiveMinn);
  }
  this.utilityFunctions.setLowerBounds(lowerBound);
  this.utilityFunctions.setUpperBounds(upperBound);
  List<S> temporalList=new LinkedList();
  temporalList.addAll(population);
  int numberOfPoint=this.referencePoint.size() / numberObjectives;
  int indexReference=0;
  this.numberOfRanks=population.size() + 1;
  this.rankedSubpopulations=new ArrayList(this.numberOfRanks);
  for (int i=0; i < numberOfRanks - 1; i++) {
    this.rankedSubpopulations.add(new ArrayList<>());
  }
  for (int i=0; i < numberOfPoint; i++) {
    List<Double> interestPoint=nextInterestPoint(indexReference,numberObjectives);
    indexReference+=numberObjectives;
    this.utilityFunctions.updatePointOfInterest(interestPoint);
    SortedMap<Double,List<S>> map=new TreeMap<>();
    for (    S solution : temporalList) {
      double value=this.utilityFunctions.evaluate(solution).doubleValue();
      List<S> auxiliar=map.get(value);
      if (auxiliar == null) {
        auxiliar=new ArrayList<>();
      }
      auxiliar.add(solution);
      map.put(value,auxiliar);
    }
    int rank=0;
    List<List<S>> populationOrder=new ArrayList<>(map.values());
    for (    List<S> solutionList : populationOrder) {
      for (      S solution : solutionList) {
        Integer nConstrains=numberOfViolatedConstraints.getAttribute(solution);
        if (nConstrains != null && nConstrains == 0) {
          this.setAttribute(solution,rank);
          this.rankedSubpopulations.get(rank).add(solution);
        }
 else {
          this.setAttribute(solution,numberOfRanks - 2);
          this.rankedSubpopulations.get(numberOfRanks - 2).add(solution);
        }
      }
      rank++;
    }
  }
  while (!temporalList.isEmpty()) {
    int indexRandom=JMetalRandom.getInstance().nextInt(0,temporalList.size() - 1);
    S solutionRandom=temporalList.get(indexRandom);
    temporalList.remove(indexRandom);
    for (int i=0; i < temporalList.size(); i++) {
      S solution=temporalList.get(i);
      double sum=this.preference(solutionRandom,solution,upperBound,lowerBound);
      if (sum < epsilon) {
        removeRank(solution);
        this.setAttribute(solution,this.rankedSubpopulations.size() - 1);
        List<S> rankListAux=this.rankedSubpopulations.get(this.rankedSubpopulations.size() - 1);
        if (rankListAux == null) {
          rankListAux=new ArrayList();
        }
        rankListAux.add(solution);
        temporalList.remove(i);
      }
    }
  }
  return this;
}",0.8158883521202361
64490,"/** 
 * @param args Command line arguments.
 * @throws JMetalException
 * @throws FileNotFoundException Invoking command: java org.uma.jmetal.runner.multiobjective.RNSGAIIRunner problemName [referenceFront]
 */
public static void main(String[] args) throws JMetalException, FileNotFoundException {
  Problem<DoubleSolution> problem;
  Algorithm<List<DoubleSolution>> algorithm;
  CrossoverOperator<DoubleSolution> crossover;
  MutationOperator<DoubleSolution> mutation;
  SelectionOperator<List<DoubleSolution>,DoubleSolution> selection;
  String referenceParetoFront=""String_Node_Str"";
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
  }
 else   if (args.length == 2) {
    problemName=args[0];
    referenceParetoFront=args[1];
  }
 else {
    problemName=""String_Node_Str"";
    referenceParetoFront=""String_Node_Str"";
  }
  problem=ProblemUtils.<DoubleSolution>loadProblem(problemName);
  double crossoverProbability=0.9;
  double crossoverDistributionIndex=20.0;
  crossover=new SBXCrossover(crossoverProbability,crossoverDistributionIndex);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  selection=new BinaryTournamentSelection<DoubleSolution>(new RankingAndCrowdingDistanceComparator<DoubleSolution>());
  List<Double> referencePoint=new ArrayList<>();
  referencePoint.add(0.1);
  referencePoint.add(0.6);
  referencePoint.add(0.3);
  referencePoint.add(0.6);
  referencePoint.add(0.5);
  referencePoint.add(0.2);
  referencePoint.add(0.7);
  referencePoint.add(0.2);
  referencePoint.add(0.9);
  referencePoint.add(0.0);
  double epsilon=0.001;
  algorithm=new RNSGAIIBuilder<DoubleSolution>(problem,crossover,mutation,referencePoint,epsilon).setSelectionOperator(selection).setMaxEvaluations(25000).setPopulationSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=algorithm.getResult();
  long computingTime=algorithmRunner.getComputingTime();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  printFinalSolutionSet(population);
  if (!referenceParetoFront.equals(""String_Node_Str"")) {
    printQualityIndicators(population,referenceParetoFront);
  }
}","/** 
 * @param args Command line arguments.
 * @throws JMetalException
 * @throws FileNotFoundException Invoking command: java org.uma.jmetal.runner.multiobjective.RNSGAIIRunner problemName [referenceFront]
 */
public static void main(String[] args) throws JMetalException, FileNotFoundException {
  Problem<DoubleSolution> problem;
  Algorithm<List<DoubleSolution>> algorithm;
  CrossoverOperator<DoubleSolution> crossover;
  MutationOperator<DoubleSolution> mutation;
  SelectionOperator<List<DoubleSolution>,DoubleSolution> selection;
  String referenceParetoFront=""String_Node_Str"";
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
  }
 else   if (args.length == 2) {
    problemName=args[0];
    referenceParetoFront=args[1];
  }
 else {
    problemName=""String_Node_Str"";
    referenceParetoFront=""String_Node_Str"";
  }
  problem=new Tanaka();
  double crossoverProbability=0.9;
  double crossoverDistributionIndex=20.0;
  crossover=new SBXCrossover(crossoverProbability,crossoverDistributionIndex);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  selection=new BinaryTournamentSelection<DoubleSolution>(new RankingAndCrowdingDistanceComparator<DoubleSolution>());
  List<Double> referencePoint=new ArrayList<>();
  referencePoint.add(0.3);
  referencePoint.add(0.6);
  double epsilon=0.001;
  algorithm=new RNSGAIIBuilder<DoubleSolution>(problem,crossover,mutation,referencePoint,epsilon).setSelectionOperator(selection).setMaxEvaluations(25000).setPopulationSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=algorithm.getResult();
  long computingTime=algorithmRunner.getComputingTime();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  printFinalSolutionSet(population);
  if (!referenceParetoFront.equals(""String_Node_Str"")) {
    printQualityIndicators(population,referenceParetoFront);
  }
}",0.9368113334832472
64491,"protected List<S> crowdingDistanceSelection(Ranking<S> ranking){
  CrowdingDistance<S> crowdingDistance=new CrowdingDistance<S>();
  List<S> population=new ArrayList<>(solutionsToSelect);
  int rankingIndex=0;
  while (population.size() < solutionsToSelect) {
    if (subfrontFillsIntoThePopulation(ranking,rankingIndex,population)) {
      addRankedSolutionsToPopulation(ranking,rankingIndex,population);
      rankingIndex++;
    }
 else {
      crowdingDistance.computeDensityEstimator(ranking.getSubfront(rankingIndex));
      addLastRankedSolutionsToPopulation(ranking,rankingIndex,population);
    }
  }
  return population;
}","protected List<S> crowdingDistanceSelection(Ranking<S> ranking){
  CrowdingDistance<S> crowdingDistance=new CrowdingDistance<S>();
  List<S> population=new ArrayList<>(solutionsToSelect);
  int rankingIndex=0;
  while (population.size() < solutionsToSelect) {
    if (subfrontFillsIntoThePopulation(ranking,rankingIndex,population)) {
      crowdingDistance.computeDensityEstimator(ranking.getSubfront(rankingIndex));
      addRankedSolutionsToPopulation(ranking,rankingIndex,population);
      rankingIndex++;
    }
 else {
      crowdingDistance.computeDensityEstimator(ranking.getSubfront(rankingIndex));
      addLastRankedSolutionsToPopulation(ranking,rankingIndex,population);
    }
  }
  return population;
}",0.9383815887156643
64492,"/** 
 * The run() method creates de output directory and compute the fronts
 */
@Override public void run() throws IOException {
  String outputDirectoryName=experiment.getReferenceFrontDirectory();
  createOutputDirectory(outputDirectoryName);
  List<String> referenceFrontFileNames=new LinkedList<>();
  for (  ExperimentProblem<?> problem : experiment.getProblemList()) {
    NonDominatedSolutionListArchive<PointSolution> nonDominatedSolutionArchive=new NonDominatedSolutionListArchive<PointSolution>();
    for (    ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList()) {
      String problemDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getAlgorithmTag()+ ""String_Node_Str""+ problem.getTag();
      for (int i=0; i < experiment.getIndependentRuns(); i++) {
        String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
        Front front=new ArrayFront(frontFileName);
        List<PointSolution> solutionList=FrontUtils.convertFrontToSolutionList(front);
        GenericSolutionAttribute<PointSolution,String> solutionAttribute=new GenericSolutionAttribute<PointSolution,String>();
        for (        PointSolution solution : solutionList) {
          solutionAttribute.setAttribute(solution,algorithm.getAlgorithmTag());
          nonDominatedSolutionArchive.add(solution);
        }
      }
    }
    String referenceSetFileName=outputDirectoryName + ""String_Node_Str"" + problem.getTag()+ ""String_Node_Str"";
    referenceFrontFileNames.add(problem.getTag() + ""String_Node_Str"");
    new SolutionListOutput(nonDominatedSolutionArchive.getSolutionList()).printObjectivesToFile(referenceSetFileName);
    writeFilesWithTheSolutionsContributedByEachAlgorithm(outputDirectoryName,problem.getProblem(),nonDominatedSolutionArchive.getSolutionList());
  }
  experiment.setReferenceFrontFileNames(referenceFrontFileNames);
}","/** 
 * The run() method creates de output directory and compute the fronts
 */
@Override public void run() throws IOException {
  String outputDirectoryName=experiment.getReferenceFrontDirectory();
  createOutputDirectory(outputDirectoryName);
  List<String> referenceFrontFileNames=new LinkedList<>();
  for (  ExperimentProblem<?> problem : experiment.getProblemList()) {
    NonDominatedSolutionListArchive<PointSolution> nonDominatedSolutionArchive=new NonDominatedSolutionListArchive<PointSolution>();
    for (    ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList()) {
      String problemDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getAlgorithmTag()+ ""String_Node_Str""+ problem.getTag();
      for (int i=0; i < experiment.getIndependentRuns(); i++) {
        String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
        Front front=new ArrayFront(frontFileName);
        List<PointSolution> solutionList=FrontUtils.convertFrontToSolutionList(front);
        GenericSolutionAttribute<PointSolution,String> solutionAttribute=new GenericSolutionAttribute<PointSolution,String>();
        for (        PointSolution solution : solutionList) {
          solutionAttribute.setAttribute(solution,algorithm.getAlgorithmTag());
          nonDominatedSolutionArchive.add(solution);
        }
      }
    }
    String referenceSetFileName=outputDirectoryName + ""String_Node_Str"" + problem.getTag()+ ""String_Node_Str"";
    referenceFrontFileNames.add(problem.getTag() + ""String_Node_Str"");
    new SolutionListOutput(nonDominatedSolutionArchive.getSolutionList()).printObjectivesToFile(referenceSetFileName);
    writeFilesWithTheSolutionsContributedByEachAlgorithm(outputDirectoryName,problem,nonDominatedSolutionArchive.getSolutionList());
  }
  experiment.setReferenceFrontFileNames(referenceFrontFileNames);
}",0.9394797836724182
64493,"private void writeFilesWithTheSolutionsContributedByEachAlgorithm(String outputDirectoryName,Problem<?> problem,List<PointSolution> nonDominatedSolutions) throws IOException {
  GenericSolutionAttribute<PointSolution,String> solutionAttribute=new GenericSolutionAttribute<PointSolution,String>();
  for (  ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList()) {
    List<PointSolution> solutionsPerAlgorithm=new ArrayList<>();
    for (    PointSolution solution : nonDominatedSolutions) {
      if (algorithm.getAlgorithmTag().equals(solutionAttribute.getAttribute(solution))) {
        solutionsPerAlgorithm.add(solution);
      }
    }
    new SolutionListOutput(solutionsPerAlgorithm).printObjectivesToFile(outputDirectoryName + ""String_Node_Str"" + problem.getName()+ ""String_Node_Str""+ algorithm.getAlgorithmTag()+ ""String_Node_Str"");
  }
}","private void writeFilesWithTheSolutionsContributedByEachAlgorithm(String outputDirectoryName,ExperimentProblem<?> problem,List<PointSolution> nonDominatedSolutions) throws IOException {
  GenericSolutionAttribute<PointSolution,String> solutionAttribute=new GenericSolutionAttribute<PointSolution,String>();
  for (  ExperimentAlgorithm<?,?> algorithm : experiment.getAlgorithmList()) {
    List<PointSolution> solutionsPerAlgorithm=new ArrayList<>();
    for (    PointSolution solution : nonDominatedSolutions) {
      if (algorithm.getAlgorithmTag().equals(solutionAttribute.getAttribute(solution))) {
        solutionsPerAlgorithm.add(solution);
      }
    }
    new SolutionListOutput(solutionsPerAlgorithm).printObjectivesToFile(outputDirectoryName + ""String_Node_Str"" + problem.getTag()+ ""String_Node_Str""+ algorithm.getAlgorithmTag()+ ""String_Node_Str"");
  }
}",0.9901563404748118
64494,"/** 
 * Evaluate() method 
 */
@Override public void evaluate(DoubleSolution solution){
  double[] fx=new double[2];
  double[] x=new double[solution.getNumberOfVariables()];
  for (int i=0; i < solution.getNumberOfVariables(); i++) {
    x[i]=solution.getVariableValue(i);
  }
  fx[0]=106780.37 * (x[1] + x[2]) + 61704.67;
  fx[1]=3000 * x[0];
  fx[2]=305700 * 2289 * x[1] / Math.pow(0.06 * 2289,0.65);
  fx[3]=250 * 2289 * Math.exp(-39.75 * x[1] + 9.9 * x[2] + 2.74);
  fx[4]=25 * (1.39 / (x[0] * x[1]) + 4940 * x[2] - 80);
  solution.setObjective(0,fx[0]);
  solution.setObjective(1,fx[1]);
  solution.setObjective(2,fx[2]);
  solution.setObjective(3,fx[3]);
  solution.setObjective(4,fx[4]);
}","/** 
 * Evaluate() method 
 */
@Override public void evaluate(DoubleSolution solution){
  double[] fx=new double[solution.getNumberOfObjectives()];
  double[] x=new double[solution.getNumberOfVariables()];
  for (int i=0; i < solution.getNumberOfVariables(); i++) {
    x[i]=solution.getVariableValue(i);
  }
  fx[0]=106780.37 * (x[1] + x[2]) + 61704.67;
  fx[1]=3000 * x[0];
  fx[2]=305700 * 2289 * x[1] / Math.pow(0.06 * 2289,0.65);
  fx[3]=250 * 2289 * Math.exp(-39.75 * x[1] + 9.9 * x[2] + 2.74);
  fx[4]=25 * (1.39 / (x[0] * x[1]) + 4940 * x[2] - 80);
  solution.setObjective(0,fx[0]);
  solution.setObjective(1,fx[1]);
  solution.setObjective(2,fx[2]);
  solution.setObjective(3,fx[3]);
  solution.setObjective(4,fx[4]);
}",0.9768421052631578
64495,"@Override protected Ranking<S> computeRanking(List<S> solutionList){
  Ranking<S> ranking=new RNSGAIIRanking<S>(achievementScalarizingFunction,epsilon,interestPoint);
  ranking.computeRanking(solutionList);
  return ranking;
}","protected Ranking<S> computeRanking(List<S> solutionList){
  Ranking<S> ranking=new RNSGAIIRanking<S>(achievementScalarizingFunction,epsilon,interestPoint);
  ranking.computeRanking(solutionList);
  return ranking;
}",0.9773755656108596
64496,"public PreferenceNSGAII<S> createUtilityFunction(){
  List<Double> weights=new ArrayList<>();
  for (int i=0; i < getProblem().getNumberOfObjectives(); i++) {
    weights.add(1.0d / getProblem().getNumberOfObjectives());
  }
  PreferenceNSGAII<S> aux=new PreferenceNSGAII<S>(weights,this.interestPoint);
  return aux;
}","public PreferenceNSGAII<S> createUtilityFunction(){
  List<Double> weights=new ArrayList<>();
  for (int i=0; i < getProblem().getNumberOfObjectives(); i++) {
    weights.add(1.0d / getProblem().getNumberOfObjectives());
  }
  PreferenceNSGAII<S> aux=new PreferenceNSGAII<S>(weights);
  return aux;
}",0.9693053311793216
64497,"public void updateReferencePoint(List<Double> pointList){
  this.achievementScalarizingFunction.updatePointOfInterest(pointList);
}","public void updateReferencePoint(List<Double> newReferencePoints){
  this.interestPoint=newReferencePoints;
}",0.65
64498,"@Override protected Ranking<S> computeRanking(List<S> solutionList){
  Ranking<S> ranking=new RNSGAIIRanking<S>(achievementScalarizingFunction,epsilon);
  ranking.computeRanking(solutionList);
  return ranking;
}","@Override protected Ranking<S> computeRanking(List<S> solutionList){
  Ranking<S> ranking=new RNSGAIIRanking<S>(achievementScalarizingFunction,epsilon,interestPoint);
  ranking.computeRanking(solutionList);
  return ranking;
}",0.9680365296803652
64499,"/** 
 * NSGAIIBuilder constructor
 */
public RNSGAIIBuilder(Problem<S> problem,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,List<Double> referencePoint){
  this.problem=problem;
  maxEvaluations=25000;
  populationSize=100;
  this.crossoverOperator=crossoverOperator;
  this.mutationOperator=mutationOperator;
  selectionOperator=new BinaryTournamentSelection<S>(new RankingAndCrowdingDistanceComparator<S>());
  evaluator=new SequentialSolutionListEvaluator<S>();
  this.referencePoint=referencePoint;
}","/** 
 * NSGAIIBuilder constructor
 */
public RNSGAIIBuilder(Problem<S> problem,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,List<Double> referencePoint,double epsilon){
  this.problem=problem;
  maxEvaluations=25000;
  populationSize=100;
  this.crossoverOperator=crossoverOperator;
  this.mutationOperator=mutationOperator;
  selectionOperator=new BinaryTournamentSelection<S>(new RankingAndCrowdingDistanceComparator<S>());
  evaluator=new SequentialSolutionListEvaluator<S>();
  this.referencePoint=referencePoint;
  this.epsilon=epsilon;
}",0.9648331830477908
64500,"public RNSGAII<S> build(){
  RNSGAII<S> algorithm=new RNSGAII<S>(problem,maxEvaluations,populationSize,crossoverOperator,mutationOperator,selectionOperator,evaluator,referencePoint,0.001);
  return algorithm;
}","public RNSGAII<S> build(){
  RNSGAII<S> algorithm=new RNSGAII<S>(problem,maxEvaluations,populationSize,crossoverOperator,mutationOperator,selectionOperator,evaluator,referencePoint,epsilon);
  return algorithm;
}",0.971563981042654
64501,"public Double evaluate(S solution){
  List<Double> objectiveValues=new ArrayList(solution.getNumberOfObjectives());
  for (int i=0; i < solution.getNumberOfObjectives(); ++i) {
    objectiveValues.add(solution.getObjective(i));
  }
  double totalDistance=0.0D;
  double normalizeDiff=0.0D;
  int numberOfPoint=this.interestPoint.size() / solution.getNumberOfObjectives();
  int index=0;
  for (int j=0; j < numberOfPoint; j++) {
    double distance=0.0D;
    for (int i=0; i < solution.getNumberOfObjectives(); i++) {
      if (this.upperBounds != null && this.lowerBounds != null) {
        normalizeDiff=(solution.getObjective(i) - this.interestPoint.get(index)) / (this.upperBounds.get(i) - this.lowerBounds.get(i));
      }
 else {
        normalizeDiff=solution.getObjective(i) - this.interestPoint.get(index);
      }
      distance+=weights.get(i) * Math.pow(normalizeDiff,2.0D);
      index++;
    }
    totalDistance+=Math.sqrt(distance);
  }
  return totalDistance;
}","public Double evaluate(S solution){
  List<Double> objectiveValues=new ArrayList(solution.getNumberOfObjectives());
  for (int i=0; i < solution.getNumberOfObjectives(); ++i) {
    objectiveValues.add(solution.getObjective(i));
  }
  double normalizeDiff=0.0D;
  double distance=0.0D;
  for (int i=0; i < solution.getNumberOfObjectives(); i++) {
    if (this.upperBounds != null && this.lowerBounds != null) {
      normalizeDiff=(solution.getObjective(i) - this.interestPoint.get(i)) / (this.upperBounds.get(i) - this.lowerBounds.get(i));
    }
 else {
      normalizeDiff=solution.getObjective(i) - this.interestPoint.get(i);
    }
    distance+=weights.get(i) * Math.pow(normalizeDiff,2.0D);
  }
  return Math.sqrt(distance);
}",0.7685998828353837
64502,"public PreferenceNSGAII(List<Double> weights,List<Double> interestPoint){
  this.weights=weights;
  this.interestPoint=interestPoint;
}","public PreferenceNSGAII(List<Double> weights){
  this.weights=weights;
}",0.6956521739130435
64503,"public void updatePointOfInterest(List<Double> newInterestPoint){
  if (this.interestPoint.size() != newInterestPoint.size()) {
    throw new JMetalException(""String_Node_Str"");
  }
 else {
    for (int i=0; i < newInterestPoint.size(); ++i) {
      this.interestPoint.set(i,newInterestPoint.get(i));
    }
  }
}","public void updatePointOfInterest(List<Double> newInterestPoint){
  interestPoint=newInterestPoint;
}",0.4891041162227603
64504,"public RNSGAIIRanking(PreferenceNSGAII<S> utilityFunctions,double epsilon){
  this.utilityFunctions=utilityFunctions;
  this.epsilon=epsilon;
}","public RNSGAIIRanking(PreferenceNSGAII<S> utilityFunctions,double epsilon,List<Double> interestPoint){
  this.utilityFunctions=utilityFunctions;
  this.epsilon=epsilon;
  referencePoint=interestPoint;
}",0.8289855072463768
64505,"public List<S> getSubfront(int rank){
  if (rank >= this.rankedSubpopulations.size()) {
    rank=this.rankedSubpopulations.size() - 1;
  }
  return (List)this.rankedSubpopulations.get(rank);
}","public List<S> getSubfront(int rank){
  return (List)this.rankedSubpopulations.get(rank);
}",0.6431095406360424
64506,"private void removeRank(S solution){
  boolean enc=false;
  int i=0;
  while (!enc && i < this.rankedSubpopulations.size()) {
    enc=this.rankedSubpopulations.get(i).contains(solution);
    if (enc) {
      this.rankedSubpopulations.get(i).remove(solution);
    }
    i++;
  }
}","private void removeRank(S solution){
  boolean enc=false;
  int i=0;
  while (i < this.rankedSubpopulations.size()) {
    enc=this.rankedSubpopulations.get(i).contains(solution);
    if (enc) {
      this.rankedSubpopulations.get(i).remove(solution);
    }
    i++;
  }
}",0.9854545454545456
64507,"@Override public Ranking<S> computeRanking(List<S> population){
  int size=population.size();
  List<Double> upperBound=new ArrayList<>();
  List<Double> lowerBound=new ArrayList<>();
  for (int i=0; i < population.get(0).getNumberOfObjectives(); i++) {
    Collections.sort(population,new ObjectiveComparator<S>(i));
    double objetiveMinn=population.get(0).getObjective(i);
    double objetiveMaxn=population.get(population.size() - 1).getObjective(i);
    upperBound.add(objetiveMaxn);
    lowerBound.add(objetiveMinn);
  }
  this.utilityFunctions.setLowerBounds(lowerBound);
  this.utilityFunctions.setUpperBounds(upperBound);
  List<S> temporalList=new LinkedList();
  temporalList.addAll(population);
  SortedMap<Double,S> map=new TreeMap<>();
  for (  S solution : temporalList) {
    double value=this.utilityFunctions.evaluate(solution).doubleValue();
    map.put(value,solution);
  }
  int rank=0;
  List<S> populationOrder=new ArrayList<>(map.values());
  this.numberOfRanks=populationOrder.size() + 1;
  this.rankedSubpopulations=new ArrayList(this.numberOfRanks);
  for (int i=0; i < numberOfRanks - 1; i++) {
    this.rankedSubpopulations.add(new ArrayList<>());
  }
  for (  S solution : populationOrder) {
    this.setAttribute(solution,rank);
    this.rankedSubpopulations.get(rank).add(solution);
    rank++;
  }
  rank=0;
  int rankPreference=0;
  while (!populationOrder.isEmpty()) {
    int indexRandom=JMetalRandom.getInstance().nextInt(0,populationOrder.size() - 1);
    S solutionRandom=populationOrder.get(indexRandom);
    populationOrder.remove(indexRandom);
    for (int i=0; i < populationOrder.size(); i++) {
      S solution=populationOrder.get(i);
      double sum=this.preference(solutionRandom,solution,upperBound,lowerBound);
      if (sum < epsilon) {
        removeRank(solution);
        this.setAttribute(solution,this.rankedSubpopulations.size() - 1);
        List<S> rankListAux=this.rankedSubpopulations.get(this.rankedSubpopulations.size() - 1);
        if (rankListAux == null) {
          rankListAux=new ArrayList();
        }
        rankListAux.add(solution);
        populationOrder.remove(i);
      }
    }
    rank++;
  }
  return this;
}","@Override public Ranking<S> computeRanking(List<S> population){
  int size=population.size();
  List<Double> upperBound=new ArrayList<>();
  List<Double> lowerBound=new ArrayList<>();
  int numberObjectives=population.get(0).getNumberOfObjectives();
  for (int i=0; i < population.get(0).getNumberOfObjectives(); i++) {
    Collections.sort(population,new ObjectiveComparator<S>(i));
    double objetiveMinn=population.get(0).getObjective(i);
    double objetiveMaxn=population.get(population.size() - 1).getObjective(i);
    upperBound.add(objetiveMaxn);
    lowerBound.add(objetiveMinn);
  }
  this.utilityFunctions.setLowerBounds(lowerBound);
  this.utilityFunctions.setUpperBounds(upperBound);
  List<S> temporalList=new LinkedList();
  temporalList.addAll(population);
  int numberOfPoint=this.referencePoint.size() / numberObjectives;
  int indexReference=0;
  this.numberOfRanks=population.size() + 1;
  this.rankedSubpopulations=new ArrayList(this.numberOfRanks);
  for (int i=0; i < numberOfRanks - 1; i++) {
    this.rankedSubpopulations.add(new ArrayList<>());
  }
  for (int i=0; i < numberOfPoint; i++) {
    List<Double> interestPoint=nextInterestPoint(indexReference,numberObjectives);
    indexReference+=numberObjectives;
    this.utilityFunctions.updatePointOfInterest(interestPoint);
    SortedMap<Double,S> map=new TreeMap<>();
    for (    S solution : temporalList) {
      double value=this.utilityFunctions.evaluate(solution).doubleValue();
      map.put(value,solution);
    }
    int rank=0;
    List<S> populationOrder=new ArrayList<>(map.values());
    for (    S solution : populationOrder) {
      this.setAttribute(solution,rank);
      this.rankedSubpopulations.get(rank).add(solution);
      rank++;
    }
  }
  while (!temporalList.isEmpty()) {
    int indexRandom=JMetalRandom.getInstance().nextInt(0,temporalList.size() - 1);
    S solutionRandom=temporalList.get(indexRandom);
    temporalList.remove(indexRandom);
    for (int i=0; i < temporalList.size(); i++) {
      S solution=temporalList.get(i);
      double sum=this.preference(solutionRandom,solution,upperBound,lowerBound);
      if (sum < epsilon) {
        removeRank(solution);
        this.setAttribute(solution,this.rankedSubpopulations.size() - 1);
        List<S> rankListAux=this.rankedSubpopulations.get(this.rankedSubpopulations.size() - 1);
        if (rankListAux == null) {
          rankListAux=new ArrayList();
        }
        rankListAux.add(solution);
        temporalList.remove(i);
      }
    }
  }
  return this;
}",0.7256562235393734
64508,"/** 
 * initUniformWeight
 */
private void initUniformWeight(){
  if ((problem.getNumberOfObjectives() == 2) && (swarmSize < 300)) {
    for (int n=0; n < swarmSize; n++) {
      double a=1.0 * n / (swarmSize - 1);
      lambda[n][0]=a;
      lambda[n][1]=1 - a;
    }
  }
 else {
    String dataFileName;
    dataDirectory=""String_Node_Str"";
    dataFileName=""String_Node_Str"" + problem.getNumberOfObjectives() + ""String_Node_Str""+ swarmSize+ ""String_Node_Str"";
    try {
      FileInputStream fis=new FileInputStream(dataDirectory + ""String_Node_Str"" + dataFileName);
      InputStreamReader isr=new InputStreamReader(fis);
      BufferedReader br=new BufferedReader(isr);
      int i=0;
      int j=0;
      String aux=br.readLine();
      while (aux != null) {
        StringTokenizer st=new StringTokenizer(aux);
        j=0;
        while (st.hasMoreTokens()) {
          double value=(new Double(st.nextToken())).doubleValue();
          lambda[i][j]=value;
          j++;
        }
        aux=br.readLine();
        i++;
      }
      br.close();
    }
 catch (    Exception e) {
      throw new JMetalException(""String_Node_Str"" + dataDirectory + ""String_Node_Str""+ dataFileName);
    }
  }
}","/** 
 * initUniformWeight
 */
private void initUniformWeight(){
  if ((problem.getNumberOfObjectives() == 2) && (swarmSize < 300)) {
    for (int n=0; n < swarmSize; n++) {
      double a=1.0 * n / (swarmSize - 1);
      lambda[n][0]=a;
      lambda[n][1]=1 - a;
    }
  }
 else {
    String dataFileName;
    dataFileName=""String_Node_Str"" + problem.getNumberOfObjectives() + ""String_Node_Str""+ swarmSize+ ""String_Node_Str"";
    try {
      InputStream in=getClass().getResourceAsStream(""String_Node_Str"" + dataDirectory + ""String_Node_Str""+ dataFileName);
      InputStreamReader isr=new InputStreamReader(in);
      BufferedReader br=new BufferedReader(isr);
      int i=0;
      int j=0;
      String aux=br.readLine();
      while (aux != null) {
        StringTokenizer st=new StringTokenizer(aux);
        j=0;
        while (st.hasMoreTokens()) {
          double value=(new Double(st.nextToken())).doubleValue();
          lambda[i][j]=value;
          j++;
        }
        aux=br.readLine();
        i++;
      }
      br.close();
    }
 catch (    Exception e) {
      throw new JMetalException(""String_Node_Str"" + dataDirectory + ""String_Node_Str""+ dataFileName);
    }
  }
}",0.8849853617733167
64509,"@Override protected void initProgress(){
  evaluations=1;
}","@Override protected void initProgress(){
  evaluations=mu;
}",0.9747899159663864
64510,"@Override public void run() throws IOException {
  String rDirectoryName=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + DEFAULT_R_DIRECTORY;
  File rOutput;
  rOutput=new File(rDirectoryName);
  if (!rOutput.exists()) {
    boolean result=new File(rDirectoryName).mkdirs();
    System.out.println(""String_Node_Str"" + rDirectoryName + ""String_Node_Str"");
  }
  for (  GenericIndicator<? extends Solution<?>> indicator : experiment.getIndicatorList()) {
    String rFileName=rDirectoryName + ""String_Node_Str"" + indicator.getName()+ ""String_Node_Str""+ ""String_Node_Str"";
    FileWriter os=new FileWriter(rFileName,false);
    os.write(""String_Node_Str"" + indicator.getName() + ""String_Node_Str""+ ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + experiment.getAlgorithmList().size());
    for (int i=0; i < experiment.getAlgorithmList().size(); i++) {
      String algorithmName=experiment.getAlgorithmList().get(i).getAlgorithmTag();
      os.write(""String_Node_Str"" + algorithmName + ""String_Node_Str""+ algorithmName+ ""String_Node_Str""+ ""String_Node_Str"");
      os.write(""String_Node_Str"" + algorithmName + ""String_Node_Str""+ algorithmName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      os.write(""String_Node_Str"" + algorithmName + ""String_Node_Str""+ algorithmName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      os.write(algorithmName + ""String_Node_Str"" + ""String_Node_Str""+ algorithmName+ ""String_Node_Str""+ ""String_Node_Str"");
      os.write(""String_Node_Str"");
    }
    os.write(""String_Node_Str"");
    for (int i=0; i < experiment.getAlgorithmList().size() - 1; i++) {
      os.write(""String_Node_Str"" + experiment.getAlgorithmList().get(i).getAlgorithmTag() + ""String_Node_Str"");
    }
    os.write(""String_Node_Str"" + experiment.getAlgorithmList().get(experiment.getAlgorithmList().size() - 1).getAlgorithmTag() + ""String_Node_Str""+ ""String_Node_Str"");
    os.write(""String_Node_Str"");
    for (int i=0; i < experiment.getAlgorithmList().size(); i++) {
      os.write(experiment.getAlgorithmList().get(i).getAlgorithmTag() + ""String_Node_Str"");
    }
    if (displayNotch) {
      os.write(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      os.write(""String_Node_Str"" + ""String_Node_Str"");
    }
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + numberOfRows + ""String_Node_Str""+ numberOfColumns+ ""String_Node_Str""+ ""String_Node_Str"");
    os.write(""String_Node_Str"" + indicator.getName() + ""String_Node_Str""+ ""String_Node_Str"");
    for (    ExperimentProblem<?> problem : experiment.getProblemList()) {
      os.write(""String_Node_Str"" + problem.getTag() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    os.close();
  }
}","@Override public void run() throws IOException {
  String rDirectoryName=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + DEFAULT_R_DIRECTORY;
  File rOutput;
  rOutput=new File(rDirectoryName);
  if (!rOutput.exists()) {
    boolean result=new File(rDirectoryName).mkdirs();
    System.out.println(""String_Node_Str"" + rDirectoryName + ""String_Node_Str"");
  }
  for (  GenericIndicator<? extends Solution<?>> indicator : experiment.getIndicatorList()) {
    String rFileName=rDirectoryName + ""String_Node_Str"" + indicator.getName()+ ""String_Node_Str""+ ""String_Node_Str"";
    FileWriter os=new FileWriter(rFileName,false);
    os.write(""String_Node_Str"" + indicator.getName() + ""String_Node_Str""+ ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    for (int i=0; i < experiment.getAlgorithmList().size(); i++) {
      String algorithmName=experiment.getAlgorithmList().get(i).getAlgorithmTag();
      os.write(""String_Node_Str"" + algorithmName + ""String_Node_Str""+ algorithmName+ ""String_Node_Str""+ ""String_Node_Str"");
      os.write(""String_Node_Str"" + algorithmName + ""String_Node_Str""+ algorithmName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      os.write(""String_Node_Str"" + algorithmName + ""String_Node_Str""+ algorithmName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      os.write(algorithmName + ""String_Node_Str"" + ""String_Node_Str""+ algorithmName+ ""String_Node_Str""+ ""String_Node_Str"");
      os.write(""String_Node_Str"");
    }
    os.write(""String_Node_Str"");
    for (int i=0; i < experiment.getAlgorithmList().size() - 1; i++) {
      os.write(""String_Node_Str"" + experiment.getAlgorithmList().get(i).getAlgorithmTag() + ""String_Node_Str"");
    }
    os.write(""String_Node_Str"" + experiment.getAlgorithmList().get(experiment.getAlgorithmList().size() - 1).getAlgorithmTag() + ""String_Node_Str""+ ""String_Node_Str"");
    os.write(""String_Node_Str"");
    for (int i=0; i < experiment.getAlgorithmList().size(); i++) {
      os.write(experiment.getAlgorithmList().get(i).getAlgorithmTag() + ""String_Node_Str"");
    }
    if (displayNotch) {
      os.write(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      os.write(""String_Node_Str"" + ""String_Node_Str"");
    }
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + ""String_Node_Str"");
    os.write(""String_Node_Str"" + numberOfRows + ""String_Node_Str""+ numberOfColumns+ ""String_Node_Str""+ ""String_Node_Str"");
    os.write(""String_Node_Str"" + indicator.getName() + ""String_Node_Str""+ ""String_Node_Str"");
    for (    ExperimentProblem<?> problem : experiment.getProblemList()) {
      os.write(""String_Node_Str"" + problem.getTag() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    os.close();
  }
}",0.9862738533645798
64511,"private void printGenerateMainScript(GenericIndicator<?> indicator,String rFileName,String latexFileName) throws IOException {
  FileWriter os=new FileWriter(rFileName,true);
  String output=""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  String problemList=""String_Node_Str"";
  String algorithmList=""String_Node_Str"";
  for (int i=0; i < (experiment.getProblemList().size() - 1); i++) {
    problemList+=""String_Node_Str"" + experiment.getProblemList().get(i).getTag() + ""String_Node_Str"";
  }
  problemList+=""String_Node_Str"" + experiment.getProblemList().get(experiment.getProblemList().size() - 1).getTag() + ""String_Node_Str"";
  for (int i=0; i < (experiment.getAlgorithmList().size() - 1); i++) {
    algorithmList+=""String_Node_Str"" + experiment.getAlgorithmList().get(i).getAlgorithmTag() + ""String_Node_Str"";
  }
  algorithmList+=""String_Node_Str"" + experiment.getAlgorithmList().get(experiment.getAlgorithmList().size() - 1).getAlgorithmTag() + ""String_Node_Str"";
  String latexTabularAlignment=""String_Node_Str"";
  for (int i=1; i < experiment.getAlgorithmList().size(); i++) {
    latexTabularAlignment+=""String_Node_Str"";
  }
  latexTabularAlignment=""String_Node_Str"";
  String latexTableFirstLine=""String_Node_Str"";
  for (int i=1; i < experiment.getAlgorithmList().size(); i++) {
    latexTabularAlignment+=""String_Node_Str"";
    latexTableFirstLine+=""String_Node_Str"" + experiment.getAlgorithmList().get(i).getAlgorithmTag();
  }
  latexTableFirstLine+=""String_Node_Str"";
  String tabularString=""String_Node_Str"" + ""String_Node_Str"" + latexTabularAlignment + ""String_Node_Str""+ ""String_Node_Str"";
  String tableFirstLine=""String_Node_Str"" + ""String_Node_Str"" + latexTableFirstLine + ""String_Node_Str"";
  output=""String_Node_Str"" + ""String_Node_Str"" + problemList + ""String_Node_Str""+ algorithmList+ ""String_Node_Str""+ tabularString+ ""String_Node_Str""+ tableFirstLine+ ""String_Node_Str""+ ""String_Node_Str""+ indicator.getName()+ ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  problemList=""String_Node_Str"";
  for (  ExperimentProblem<?> problem : experiment.getProblemList()) {
    problemList+=problem.getTag() + ""String_Node_Str"";
  }
  latexTabularAlignment=""String_Node_Str"";
  latexTableFirstLine=""String_Node_Str"";
  for (int i=1; i < experiment.getAlgorithmList().size(); i++) {
    for (    ExperimentProblem<?> problem : experiment.getProblemList()) {
      latexTabularAlignment+=""String_Node_Str"";
    }
    latexTableFirstLine+=""String_Node_Str"" + experiment.getProblemList().size() + ""String_Node_Str""+ experiment.getAlgorithmList().get(i).getAlgorithmTag()+ ""String_Node_Str"";
    latexTabularAlignment+=""String_Node_Str"";
  }
  latexTableFirstLine+=""String_Node_Str"";
  tabularString=""String_Node_Str"" + ""String_Node_Str"" + latexTabularAlignment + ""String_Node_Str""+ ""String_Node_Str"";
  latexTableFirstLine=""String_Node_Str"" + ""String_Node_Str"" + latexTableFirstLine + ""String_Node_Str""+ ""String_Node_Str"";
  output=tabularString;
  os.write(output + ""String_Node_Str"" + ""String_Node_Str"");
  output=latexTableFirstLine;
  os.write(output + ""String_Node_Str"" + ""String_Node_Str"");
  output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + problemList + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ experiment.getAlgorithmList().get(experiment.getAlgorithmList().size() - 1).getProblemTag()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ experiment.getProblemList().get(experiment.getProblemList().size() - 1).getTag()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ experiment.getAlgorithmList().get(experiment.getAlgorithmList().size() - 1).getProblemTag()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  os.close();
}","private void printGenerateMainScript(GenericIndicator<?> indicator,String rFileName,String latexFileName) throws IOException {
  FileWriter os=new FileWriter(rFileName,true);
  String output=""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  String problemList=""String_Node_Str"";
  String algorithmList=""String_Node_Str"";
  for (int i=0; i < (experiment.getProblemList().size() - 1); i++) {
    problemList+=""String_Node_Str"" + experiment.getProblemList().get(i).getTag() + ""String_Node_Str"";
  }
  problemList+=""String_Node_Str"" + experiment.getProblemList().get(experiment.getProblemList().size() - 1).getTag() + ""String_Node_Str"";
  for (int i=0; i < (experiment.getAlgorithmList().size() - 1); i++) {
    algorithmList+=""String_Node_Str"" + experiment.getAlgorithmList().get(i).getAlgorithmTag() + ""String_Node_Str"";
  }
  algorithmList+=""String_Node_Str"" + experiment.getAlgorithmList().get(experiment.getAlgorithmList().size() - 1).getAlgorithmTag() + ""String_Node_Str"";
  String latexTabularAlignment=""String_Node_Str"";
  for (int i=1; i < experiment.getAlgorithmList().size(); i++) {
    latexTabularAlignment+=""String_Node_Str"";
  }
  latexTabularAlignment=""String_Node_Str"";
  String latexTableFirstLine=""String_Node_Str"";
  for (int i=1; i < experiment.getAlgorithmList().size(); i++) {
    latexTabularAlignment+=""String_Node_Str"";
    latexTableFirstLine+=""String_Node_Str"" + experiment.getAlgorithmList().get(i).getAlgorithmTag();
  }
  latexTableFirstLine+=""String_Node_Str"";
  String tabularString=""String_Node_Str"" + ""String_Node_Str"" + latexTabularAlignment + ""String_Node_Str""+ ""String_Node_Str"";
  String tableFirstLine=""String_Node_Str"" + ""String_Node_Str"" + latexTableFirstLine + ""String_Node_Str"";
  output=""String_Node_Str"" + ""String_Node_Str"" + problemList + ""String_Node_Str""+ algorithmList+ ""String_Node_Str""+ tabularString+ ""String_Node_Str""+ tableFirstLine+ ""String_Node_Str""+ ""String_Node_Str""+ indicator.getName()+ ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  problemList=""String_Node_Str"";
  for (  ExperimentProblem<?> problem : experiment.getProblemList()) {
    problemList+=problem.getTag() + ""String_Node_Str"";
  }
  latexTabularAlignment=""String_Node_Str"";
  latexTableFirstLine=""String_Node_Str"";
  for (int i=1; i < experiment.getAlgorithmList().size(); i++) {
    for (    ExperimentProblem<?> problem : experiment.getProblemList()) {
      latexTabularAlignment+=""String_Node_Str"";
    }
    latexTableFirstLine+=""String_Node_Str"" + experiment.getProblemList().size() + ""String_Node_Str""+ experiment.getAlgorithmList().get(i).getAlgorithmTag()+ ""String_Node_Str"";
    latexTabularAlignment+=""String_Node_Str"";
  }
  latexTableFirstLine+=""String_Node_Str"";
  tabularString=""String_Node_Str"" + ""String_Node_Str"" + latexTabularAlignment + ""String_Node_Str""+ ""String_Node_Str"";
  latexTableFirstLine=""String_Node_Str"" + ""String_Node_Str"" + latexTableFirstLine + ""String_Node_Str""+ ""String_Node_Str"";
  output=tabularString;
  os.write(output + ""String_Node_Str"" + ""String_Node_Str"");
  output=latexTableFirstLine;
  os.write(output + ""String_Node_Str"" + ""String_Node_Str"");
  output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + problemList + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ experiment.getAlgorithmList().get(experiment.getAlgorithmList().size() - 1).getAlgorithmTag()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ experiment.getProblemList().get(experiment.getProblemList().size() - 1).getTag()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ experiment.getAlgorithmList().get(experiment.getAlgorithmList().size() - 1).getAlgorithmTag()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  os.close();
}",0.9974117212053984
64512,"public static void main(String[] args) throws IOException {
  if (args.length != 2) {
    throw new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  String referenceFrontDirectory=args[1];
  List<ExperimentProblem<DoubleSolution>> problemList=new ArrayList<>();
  problemList.add(new ExperimentProblem<>(new ZDT1()));
  problemList.add(new ExperimentProblem<>(new ZDT2()));
  problemList.add(new ExperimentProblem<>(new ZDT3()));
  problemList.add(new ExperimentProblem<>(new ZDT4()));
  problemList.add(new ExperimentProblem<>(new ZDT6()));
  List<ExperimentAlgorithm<DoubleSolution,List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  ExperimentBuilder<DoubleSolution,List<DoubleSolution>> zdt2Study=new ExperimentBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"");
  zdt2Study.setAlgorithmList(algorithmList);
  zdt2Study.setProblemList(problemList);
  zdt2Study.setExperimentBaseDirectory(experimentBaseDirectory);
  zdt2Study.setOutputParetoFrontFileName(""String_Node_Str"");
  zdt2Study.setOutputParetoSetFileName(""String_Node_Str"");
  zdt2Study.setReferenceFrontDirectory(referenceFrontDirectory);
  zdt2Study.setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>()));
  zdt2Study.setIndependentRuns(INDEPENDENT_RUNS);
  zdt2Study.setNumberOfCores(8);
  Experiment<DoubleSolution,List<DoubleSolution>> experiment=zdt2Study.build();
  new ExecuteAlgorithms<>(experiment).run();
  new GenerateReferenceParetoSetAndFrontFromDoubleSolutions(experiment).run();
  new ComputeQualityIndicators<>(experiment).run();
  new GenerateLatexTablesWithStatistics(experiment).run();
  new GenerateWilcoxonTestTablesWithR<>(experiment).run();
  new GenerateFriedmanTestTables<>(experiment).run();
  new GenerateBoxplotsWithR<>(experiment).setRows(3).setColumns(3).setDisplayNotch().run();
}","public static void main(String[] args) throws IOException {
  if (args.length != 2) {
    throw new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  String referenceFrontDirectory=args[1];
  List<ExperimentProblem<DoubleSolution>> problemList=new ArrayList<>();
  problemList.add(new ExperimentProblem<>(new ZDT1()));
  problemList.add(new ExperimentProblem<>(new ZDT2()));
  problemList.add(new ExperimentProblem<>(new ZDT3()));
  problemList.add(new ExperimentProblem<>(new ZDT4()));
  problemList.add(new ExperimentProblem<>(new ZDT6()));
  List<ExperimentAlgorithm<DoubleSolution,List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  ExperimentBuilder<DoubleSolution,List<DoubleSolution>> zdt2Study=new ExperimentBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"");
  zdt2Study.setAlgorithmList(algorithmList);
  zdt2Study.setProblemList(problemList);
  zdt2Study.setExperimentBaseDirectory(experimentBaseDirectory);
  zdt2Study.setOutputParetoFrontFileName(""String_Node_Str"");
  zdt2Study.setOutputParetoSetFileName(""String_Node_Str"");
  zdt2Study.setReferenceFrontDirectory(referenceFrontDirectory);
  zdt2Study.setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>()));
  zdt2Study.setIndependentRuns(INDEPENDENT_RUNS);
  zdt2Study.setNumberOfCores(8);
  Experiment<DoubleSolution,List<DoubleSolution>> experiment=zdt2Study.build();
  new GenerateReferenceParetoSetAndFrontFromDoubleSolutions(experiment).run();
  new ComputeQualityIndicators<>(experiment).run();
  new GenerateLatexTablesWithStatistics(experiment).run();
  new GenerateWilcoxonTestTablesWithR<>(experiment).run();
  new GenerateFriedmanTestTables<>(experiment).run();
  new GenerateBoxplotsWithR<>(experiment).setRows(3).setColumns(3).setDisplayNotch().run();
}",0.9890163534293386
64513,"/** 
 * Constructor Creates a default instance of the Rosenbrock problem
 * @param numberOfVariables Number of variables of the problem
 */
public Rosenbrock(Integer numberOfVariables){
  setNumberOfVariables(numberOfVariables);
  setNumberOfObjectives(1);
  setNumberOfConstraints(0);
  setName(""String_Node_Str"");
  List<Double> lowerLimit=new ArrayList<>(getNumberOfVariables());
  List<Double> upperLimit=new ArrayList<>(getNumberOfVariables());
  for (int i=0; i < getNumberOfVariables(); i++) {
    lowerLimit.add(-5.12);
    upperLimit.add(5.12);
  }
}","/** 
 * Constructor Creates a default instance of the Rosenbrock problem
 * @param numberOfVariables Number of variables of the problem
 */
public Rosenbrock(Integer numberOfVariables){
  setNumberOfVariables(numberOfVariables);
  setNumberOfObjectives(1);
  setNumberOfConstraints(0);
  setName(""String_Node_Str"");
  List<Double> lowerLimit=new ArrayList<>(getNumberOfVariables());
  List<Double> upperLimit=new ArrayList<>(getNumberOfVariables());
  for (int i=0; i < getNumberOfVariables(); i++) {
    lowerLimit.add(-5.12);
    upperLimit.add(5.12);
  }
  setLowerLimit(lowerLimit);
  setUpperLimit(upperLimit);
}",0.9506802721088436
64514,"public void prune(){
  Iterator<S> iterator=getSolutionList().iterator();
  boolean removed=false;
  while (iterator.hasNext()) {
    if (!removed) {
      S element=iterator.next();
      int location=grid.location(element);
      if (location == grid.getMostPopulatedHypercube()) {
        iterator.remove();
        grid.removeSolution(location);
        removed=true;
      }
    }
  }
}","public void prune(){
  Iterator<S> iterator=getSolutionList().iterator();
  while (iterator.hasNext()) {
    S element=iterator.next();
    int location=grid.location(element);
    if (location == grid.getMostPopulatedHypercube()) {
      iterator.remove();
      grid.removeSolution(location);
      return;
    }
  }
}",0.7116736990154712
64515,"public void prune(){
  Iterator<S> iterator=getSolutionList().iterator();
  boolean removed=false;
  while (iterator.hasNext()) {
    if (!removed) {
      S element=iterator.next();
      int location=grid.location(element);
      if (location == grid.getMostPopulatedHypercube()) {
        iterator.remove();
        grid.removeSolution(location);
        removed=true;
      }
    }
  }
}","public void prune(){
  Iterator<S> iterator=getSolutionList().iterator();
  while (iterator.hasNext()) {
    S element=iterator.next();
    int location=grid.location(element);
    if (location == grid.getMostPopulatedHypercube()) {
      iterator.remove();
      grid.removeSolution(location);
      return;
    }
  }
}",0.7116736990154712
64516,"void alphaFunction(double alpha[],List<Double> x,int dim,int type){
  if (dim == 2) {
    if (type == 21) {
      alpha[0]=x.get(0);
      alpha[1]=1 - Math.sqrt(x.get(0));
    }
    if (type == 22) {
      alpha[0]=x.get(0);
      alpha[1]=1 - x.get(0) * x.get(0);
    }
    if (type == 23) {
      alpha[0]=x.get(0);
      alpha[1]=1 - Math.sqrt(alpha[0]) - alpha[0] * Math.sin(10 * alpha[0] * alpha[0]* Math.PI);
    }
    if (type == 24) {
      alpha[0]=x.get(0);
      alpha[1]=1 - x.get(0) - 0.05 * Math.sin(4 * Math.PI * x.get(0));
    }
  }
 else {
    if (type == 31) {
      alpha[1]=Math.cos(x.get(0) * Math.PI / 2) * Math.sin(x.get(1) * Math.PI / 2);
      alpha[2]=Math.sin(x.get(0) * Math.PI / 2);
    }
    if (type == 32) {
      alpha[0]=1 - Math.cos(x.get(0) * Math.PI / 2) * Math.cos(x.get(1) * Math.PI / 2);
      alpha[1]=1 - Math.cos(x.get(0) * Math.PI / 2) * Math.sin(x.get(1) * Math.PI / 2);
      alpha[2]=1 - Math.sin(x.get(0) * Math.PI / 2);
    }
    if (type == 33) {
      alpha[0]=x.get(0);
      alpha[1]=x.get(1);
      alpha[2]=3 - (Math.sin(3 * Math.PI * x.get(0)) + Math.sin(3 * Math.PI * x.get(1))) - 2 * (x.get(0) + x.get(1));
    }
    if (type == 34) {
      alpha[0]=x.get(0) * x.get(1);
      alpha[1]=x.get(0) * (1 - x.get(1));
      alpha[2]=(1 - x.get(0));
    }
  }
}","void alphaFunction(double alpha[],List<Double> x,int dim,int type){
  if (dim == 2) {
    if (type == 21) {
      alpha[0]=x.get(0);
      alpha[1]=1 - Math.sqrt(x.get(0));
    }
    if (type == 22) {
      alpha[0]=x.get(0);
      alpha[1]=1 - x.get(0) * x.get(0);
    }
    if (type == 23) {
      alpha[0]=x.get(0);
      alpha[1]=1 - Math.sqrt(alpha[0]) - alpha[0] * Math.sin(10 * alpha[0] * alpha[0]* Math.PI);
    }
    if (type == 24) {
      alpha[0]=x.get(0);
      alpha[1]=1 - x.get(0) - 0.05 * Math.sin(4 * Math.PI * x.get(0));
    }
  }
 else {
    if (type == 31) {
      alpha[0]=Math.cos(x.get(0) * Math.PI / 2) * Math.cos(x.get(1) * Math.PI / 2);
      alpha[1]=Math.cos(x.get(0) * Math.PI / 2) * Math.sin(x.get(1) * Math.PI / 2);
      alpha[2]=Math.sin(x.get(0) * Math.PI / 2);
    }
    if (type == 32) {
      alpha[0]=1 - Math.cos(x.get(0) * Math.PI / 2) * Math.cos(x.get(1) * Math.PI / 2);
      alpha[1]=1 - Math.cos(x.get(0) * Math.PI / 2) * Math.sin(x.get(1) * Math.PI / 2);
      alpha[2]=1 - Math.sin(x.get(0) * Math.PI / 2);
    }
    if (type == 33) {
      alpha[0]=x.get(0);
      alpha[1]=x.get(1);
      alpha[2]=3 - (Math.sin(3 * Math.PI * x.get(0)) + Math.sin(3 * Math.PI * x.get(1))) - 2 * (x.get(0) + x.get(1));
    }
    if (type == 34) {
      alpha[0]=x.get(0) * x.get(1);
      alpha[1]=x.get(0) * (1 - x.get(1));
      alpha[2]=(1 - x.get(0));
    }
  }
}",0.9579646017699116
64517,"@Override protected void updateProgress(){
  iterations.increment(1);
  ;
  updateLeadersDensityEstimator();
  for (double i=0; i < 1000000000; i++) {
    double v=i * i / 3.0;
  }
  solutionListMeasure.push(super.getResult());
}","@Override protected void updateProgress(){
  iterations.increment(1);
  ;
  updateLeadersDensityEstimator();
  solutionListMeasure.push(super.getResult());
}",0.8134715025906736
64518,"@Override synchronized public void measureGenerated(Long value){
  if ((value % 50 == 0)) {
    System.out.println(""String_Node_Str"" + value);
  }
}","@Override synchronized public void measureGenerated(Long value){
  if ((value % 10 == 0)) {
    System.out.println(""String_Node_Str"" + value);
  }
}",0.9932432432432432
64519,"/** 
 * @param args Command line arguments.
 * @throws SecurityException Invoking command: java org.uma.jmetal.runner.multiobjective.NSGAIIMeasuresRunner problemName [referenceFront]
 */
public static void main(String[] args) throws JMetalException, InterruptedException, FileNotFoundException {
  DoubleProblem problem;
  Algorithm<List<DoubleSolution>> algorithm;
  MutationOperator<DoubleSolution> mutation;
  String referenceParetoFront=""String_Node_Str"";
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
  }
 else   if (args.length == 2) {
    problemName=args[0];
    referenceParetoFront=args[1];
  }
 else {
    problemName=""String_Node_Str"";
    referenceParetoFront=""String_Node_Str"";
  }
  problem=(DoubleProblem)ProblemUtils.<DoubleSolution>loadProblem(problemName);
  BoundedArchive<DoubleSolution> archive=new CrowdingDistanceArchive<DoubleSolution>(100);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  int maxIterations=250;
  int swarmSize=100;
  algorithm=new SMPSOBuilder(problem,archive).setMutation(mutation).setMaxIterations(maxIterations).setSwarmSize(swarmSize).setRandomGenerator(new MersenneTwisterGenerator()).setSolutionListEvaluator(new SequentialSolutionListEvaluator<DoubleSolution>()).setVariant(SMPSOBuilder.SMPSOVariant.Measures).build();
  MeasureManager measureManager=((SMPSOMeasures)algorithm).getMeasureManager();
  CountingMeasure currentIteration=(CountingMeasure)measureManager.<Long>getPullMeasure(""String_Node_Str"");
  DurationMeasure currentComputingTime=(DurationMeasure)measureManager.<Long>getPullMeasure(""String_Node_Str"");
  BasicMeasure<List<DoubleSolution>> solutionListMeasure=(BasicMeasure<List<DoubleSolution>>)measureManager.<List<DoubleSolution>>getPushMeasure(""String_Node_Str"");
  CountingMeasure iteration2=(CountingMeasure)measureManager.<Long>getPushMeasure(""String_Node_Str"");
  solutionListMeasure.register(new Listener());
  iteration2.register(new Listener2());
  Thread algorithmThread=new Thread(algorithm);
  algorithmThread.start();
  int i=0;
  while (currentIteration.get() < maxIterations) {
    TimeUnit.SECONDS.sleep(5);
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ currentIteration.get());
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ currentComputingTime.get());
    i++;
  }
  algorithmThread.join();
  List<DoubleSolution> population=algorithm.getResult();
  long computingTime=currentComputingTime.get();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  printFinalSolutionSet(population);
  if (!referenceParetoFront.equals(""String_Node_Str"")) {
    printQualityIndicators(population,referenceParetoFront);
  }
}","/** 
 * @param args Command line arguments.
 * @throws SecurityException Invoking command: java org.uma.jmetal.runner.multiobjective.NSGAIIMeasuresRunner problemName [referenceFront]
 */
public static void main(String[] args) throws JMetalException, InterruptedException, FileNotFoundException {
  DoubleProblem problem;
  Algorithm<List<DoubleSolution>> algorithm;
  MutationOperator<DoubleSolution> mutation;
  String referenceParetoFront=""String_Node_Str"";
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
  }
 else   if (args.length == 2) {
    problemName=args[0];
    referenceParetoFront=args[1];
  }
 else {
    problemName=""String_Node_Str"";
    referenceParetoFront=""String_Node_Str"";
  }
  problem=(DoubleProblem)ProblemUtils.<DoubleSolution>loadProblem(problemName);
  BoundedArchive<DoubleSolution> archive=new CrowdingDistanceArchive<DoubleSolution>(100);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  int maxIterations=250;
  int swarmSize=100;
  algorithm=new SMPSOBuilder(problem,archive).setMutation(mutation).setMaxIterations(maxIterations).setSwarmSize(swarmSize).setRandomGenerator(new MersenneTwisterGenerator()).setSolutionListEvaluator(new SequentialSolutionListEvaluator<DoubleSolution>()).setVariant(SMPSOBuilder.SMPSOVariant.Measures).build();
  MeasureManager measureManager=((SMPSOMeasures)algorithm).getMeasureManager();
  CountingMeasure currentIteration=(CountingMeasure)measureManager.<Long>getPullMeasure(""String_Node_Str"");
  DurationMeasure currentComputingTime=(DurationMeasure)measureManager.<Long>getPullMeasure(""String_Node_Str"");
  BasicMeasure<List<DoubleSolution>> solutionListMeasure=(BasicMeasure<List<DoubleSolution>>)measureManager.<List<DoubleSolution>>getPushMeasure(""String_Node_Str"");
  CountingMeasure iteration2=(CountingMeasure)measureManager.<Long>getPushMeasure(""String_Node_Str"");
  solutionListMeasure.register(new Listener());
  iteration2.register(new Listener2());
  Thread algorithmThread=new Thread(algorithm);
  algorithmThread.start();
  int i=0;
  while (currentIteration.get() < maxIterations) {
    TimeUnit.SECONDS.sleep(1);
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ currentIteration.get());
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ currentComputingTime.get());
    i++;
  }
  algorithmThread.join();
  List<DoubleSolution> population=algorithm.getResult();
  long computingTime=currentComputingTime.get();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  printFinalSolutionSet(population);
  if (!referenceParetoFront.equals(""String_Node_Str"")) {
    printQualityIndicators(population,referenceParetoFront);
  }
}",0.9996476391825228
64520,"/** 
 * Creates a new instance of problem CEC2009_UF4.
 * @param numberOfVariables Number of variables.
 * @param solutionType The solution type must ""Real"" or ""BinaryReal"".
 */
public UF4(String solutionType,Integer numberOfVariables){
  setNumberOfVariables(numberOfVariables);
  setNumberOfObjectives(2);
  setNumberOfConstraints(0);
  setName(""String_Node_Str"");
  List<Double> lowerLimit=new ArrayList<>(getNumberOfVariables());
  List<Double> upperLimit=new ArrayList<>(getNumberOfVariables());
  lowerLimit.add(0.0);
  upperLimit.add(1.0);
  for (int i=1; i < getNumberOfVariables(); i++) {
    lowerLimit.add(-2.0);
    upperLimit.add(2.0);
  }
  setLowerLimit(lowerLimit);
  setUpperLimit(upperLimit);
}","/** 
 * Creates a new instance of problem CEC2009_UF4.
 * @param numberOfVariables Number of variables.
 */
public UF4(Integer numberOfVariables){
  setNumberOfVariables(numberOfVariables);
  setNumberOfObjectives(2);
  setNumberOfConstraints(0);
  setName(""String_Node_Str"");
  List<Double> lowerLimit=new ArrayList<>(getNumberOfVariables());
  List<Double> upperLimit=new ArrayList<>(getNumberOfVariables());
  lowerLimit.add(0.0);
  upperLimit.add(1.0);
  for (int i=1; i < getNumberOfVariables(); i++) {
    lowerLimit.add(-2.0);
    upperLimit.add(2.0);
  }
  setLowerLimit(lowerLimit);
  setUpperLimit(upperLimit);
}",0.9325337331334332
64521,"@Override public Ranking<S> computeRanking(List<S> solutionSet){
  List<S> population=solutionSet;
  int[] dominateMe=new int[population.size()];
  List<List<Integer>> iDominate=new ArrayList<>(population.size());
  List<List<Integer>> front=new ArrayList<>(population.size() + 1);
  for (int i=0; i < front.size(); i++) {
    front.set(i,new LinkedList<Integer>());
  }
  for (int p=0; p < population.size(); p++) {
    iDominate.set(p,new LinkedList<Integer>());
    dominateMe[p]=0;
  }
  int flagDominate;
  for (int p=0; p < (population.size() - 1); p++) {
    for (int q=p + 1; q < population.size(); q++) {
      flagDominate=CONSTRAINT_VIOLATION_COMPARATOR.compare(solutionSet.get(p),solutionSet.get(q));
      if (flagDominate == 0) {
        flagDominate=DOMINANCE_COMPARATOR.compare(solutionSet.get(p),solutionSet.get(q));
      }
      if (flagDominate == -1) {
        iDominate.get(p).add(q);
        dominateMe[q]++;
      }
 else       if (flagDominate == 1) {
        iDominate.get(q).add(p);
        dominateMe[p]++;
      }
    }
  }
  for (int i=0; i < population.size(); i++) {
    if (dominateMe[i] == 0) {
      front.get(0).add(i);
      solutionSet.get(i).setAttribute(getAttributeID(),0);
    }
  }
  int i=0;
  Iterator<Integer> it1, it2;
  while (front.get(i).size() != 0) {
    i++;
    it1=front.get(i - 1).iterator();
    while (it1.hasNext()) {
      it2=iDominate.get(it1.next()).iterator();
      while (it2.hasNext()) {
        int index=it2.next();
        dominateMe[index]--;
        if (dominateMe[index] == 0) {
          front.get(i).add(index);
          solutionSet.get(index).setAttribute(getAttributeID(),i);
        }
      }
    }
  }
  rankedSubpopulations=new ArrayList<>();
  for (int j=0; j < i; j++) {
    rankedSubpopulations.add(j,new ArrayList<S>(front.get(j).size()));
    it1=front.get(j).iterator();
    while (it1.hasNext()) {
      rankedSubpopulations.get(j).add(solutionSet.get(it1.next()));
    }
  }
  return this;
}","@Override public Ranking<S> computeRanking(List<S> solutionSet){
  List<S> population=solutionSet;
  int[] dominateMe=new int[population.size()];
  List<Integer>[] iDominate=new List[population.size()];
  List<Integer>[] front=new List[population.size() + 1];
  for (int i=0; i < front.length; i++) {
    front[i]=new LinkedList<>();
  }
  for (int p=0; p < population.size(); p++) {
    iDominate[p]=new LinkedList<>();
    dominateMe[p]=0;
  }
  int flagDominate;
  for (int p=0; p < (population.size() - 1); p++) {
    for (int q=p + 1; q < population.size(); q++) {
      flagDominate=CONSTRAINT_VIOLATION_COMPARATOR.compare(solutionSet.get(p),solutionSet.get(q));
      if (flagDominate == 0) {
        flagDominate=DOMINANCE_COMPARATOR.compare(solutionSet.get(p),solutionSet.get(q));
      }
      if (flagDominate == -1) {
        iDominate[p].add(q);
        dominateMe[q]++;
      }
 else       if (flagDominate == 1) {
        iDominate[q].add(p);
        dominateMe[p]++;
      }
    }
  }
  for (int i=0; i < population.size(); i++) {
    if (dominateMe[i] == 0) {
      front[0].add(i);
      solutionSet.get(i).setAttribute(getAttributeID(),0);
    }
  }
  int i=0;
  Iterator<Integer> it1, it2;
  while (front[i].size() != 0) {
    i++;
    it1=front[i - 1].iterator();
    while (it1.hasNext()) {
      it2=iDominate[it1.next()].iterator();
      while (it2.hasNext()) {
        int index=it2.next();
        dominateMe[index]--;
        if (dominateMe[index] == 0) {
          front[i].add(index);
          solutionSet.get(index).setAttribute(getAttributeID(),i);
        }
      }
    }
  }
  rankedSubpopulations=new ArrayList<>();
  for (int j=0; j < i; j++) {
    rankedSubpopulations.add(j,new ArrayList<S>(front[j].size()));
    it1=front[j].iterator();
    while (it1.hasNext()) {
      rankedSubpopulations.get(j).add(solutionSet.get(it1.next()));
    }
  }
  return this;
}",0.8587628865979381
64522,"@Override public void run() throws IOException {
  for (  GenericIndicator<?> indicator : experiment.getIndicatorList()) {
    JMetalLogger.logger.info(""String_Node_Str"" + indicator.getName());
    ;
    for (    TaggedAlgorithm<Result> algorithm : experiment.getAlgorithmList()) {
      String algorithmDirectory;
      algorithmDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getTag();
      for (int problemId=0; problemId < experiment.getProblemList().size(); problemId++) {
        String problemDirectory=algorithmDirectory + ""String_Node_Str"" + experiment.getProblemList().get(problemId).getName();
        String referenceFrontDirectory=experiment.getReferenceFrontDirectory();
        String referenceFrontName=referenceFrontDirectory + ""String_Node_Str"" + experiment.getReferenceFrontFileNames().get(problemId);
        JMetalLogger.logger.info(""String_Node_Str"" + referenceFrontName);
        ;
        Front referenceFront=new ArrayFront(referenceFrontName);
        FrontNormalizer frontNormalizer=new FrontNormalizer(referenceFront);
        Front normalizedReferenceFront=frontNormalizer.normalize(referenceFront);
        String qualityIndicatorFile=problemDirectory + ""String_Node_Str"" + indicator.getName();
        resetFile(qualityIndicatorFile);
        indicator.setReferenceParetoFront(normalizedReferenceFront);
        for (int i=0; i < experiment.getIndependentRuns(); i++) {
          String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
          String variableFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoSetFileName()+ i+ ""String_Node_Str"";
          Front front=new ArrayFront(frontFileName);
          Front normalizedFront=frontNormalizer.normalize(front);
          List<DoubleSolution> normalizedPopulation=FrontUtils.convertFrontToSolutionList(normalizedFront);
          Double indicatorValue=(Double)indicator.evaluate(normalizedPopulation);
          JMetalLogger.logger.info(indicator.getName() + ""String_Node_Str"" + indicatorValue);
          writeQualityIndicatorValueToFile(indicatorValue,qualityIndicatorFile);
        }
      }
    }
  }
  findBestIndicatorFronts(experiment);
}","@Override public void run() throws IOException {
  for (  GenericIndicator indicator : experiment.getIndicatorList()) {
    JMetalLogger.logger.info(""String_Node_Str"" + indicator.getName());
    ;
    for (    TaggedAlgorithm<Result> algorithm : experiment.getAlgorithmList()) {
      String algorithmDirectory;
      algorithmDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getTag();
      for (int problemId=0; problemId < experiment.getProblemList().size(); problemId++) {
        String problemDirectory=algorithmDirectory + ""String_Node_Str"" + experiment.getProblemList().get(problemId).getName();
        String referenceFrontDirectory=experiment.getReferenceFrontDirectory();
        String referenceFrontName=referenceFrontDirectory + ""String_Node_Str"" + experiment.getReferenceFrontFileNames().get(problemId);
        JMetalLogger.logger.info(""String_Node_Str"" + referenceFrontName);
        ;
        Front referenceFront=new ArrayFront(referenceFrontName);
        FrontNormalizer frontNormalizer=new FrontNormalizer(referenceFront);
        Front normalizedReferenceFront=frontNormalizer.normalize(referenceFront);
        String qualityIndicatorFile=problemDirectory + ""String_Node_Str"" + indicator.getName();
        resetFile(qualityIndicatorFile);
        indicator.setReferenceParetoFront(normalizedReferenceFront);
        for (int i=0; i < experiment.getIndependentRuns(); i++) {
          String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
          Front front=new ArrayFront(frontFileName);
          Front normalizedFront=frontNormalizer.normalize(front);
          List<DoubleSolution> normalizedPopulation=FrontUtils.convertFrontToSolutionList(normalizedFront);
          Double indicatorValue=(Double)indicator.evaluate(normalizedPopulation);
          JMetalLogger.logger.info(indicator.getName() + ""String_Node_Str"" + indicatorValue);
          writeQualityIndicatorValueToFile(indicatorValue,qualityIndicatorFile);
        }
      }
    }
  }
  findBestIndicatorFronts(experiment);
}",0.9682575930577756
64523,"/** 
 * initUniformWeight
 */
private void initUniformWeight(){
  if ((problem.getNumberOfObjectives() == 2) && (swarmSize < 300)) {
    for (int n=0; n < swarmSize; n++) {
      double a=1.0 * n / (swarmSize - 1);
      lambda[n][0]=a;
      lambda[n][1]=1 - a;
    }
  }
 else {
    String dataFileName;
    dataDirectory=""String_Node_Str"";
    dataFileName=""String_Node_Str"" + problem.getNumberOfObjectives() + ""String_Node_Str""+ swarmSize+ ""String_Node_Str"";
    try {
      FileInputStream fis=new FileInputStream(dataDirectory + ""String_Node_Str"" + dataFileName);
      InputStreamReader isr=new InputStreamReader(fis);
      BufferedReader br=new BufferedReader(isr);
      int i=0;
      int j=0;
      String aux=br.readLine();
      while (aux != null) {
        StringTokenizer st=new StringTokenizer(aux);
        j=0;
        while (st.hasMoreTokens()) {
          double value=(new Double(st.nextToken())).doubleValue();
          lambda[i][j]=value;
          j++;
        }
        aux=br.readLine();
        i++;
      }
      br.close();
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + dataDirectory + ""String_Node_Str""+ dataFileName);
      e.printStackTrace();
    }
  }
}","/** 
 * initUniformWeight
 */
private void initUniformWeight(){
  if ((problem.getNumberOfObjectives() == 2) && (swarmSize < 300)) {
    for (int n=0; n < swarmSize; n++) {
      double a=1.0 * n / (swarmSize - 1);
      lambda[n][0]=a;
      lambda[n][1]=1 - a;
    }
  }
 else {
    String dataFileName;
    dataDirectory=""String_Node_Str"";
    dataFileName=""String_Node_Str"" + problem.getNumberOfObjectives() + ""String_Node_Str""+ swarmSize+ ""String_Node_Str"";
    try {
      FileInputStream fis=new FileInputStream(dataDirectory + ""String_Node_Str"" + dataFileName);
      InputStreamReader isr=new InputStreamReader(fis);
      BufferedReader br=new BufferedReader(isr);
      int i=0;
      int j=0;
      String aux=br.readLine();
      while (aux != null) {
        StringTokenizer st=new StringTokenizer(aux);
        j=0;
        while (st.hasMoreTokens()) {
          double value=(new Double(st.nextToken())).doubleValue();
          lambda[i][j]=value;
          j++;
        }
        aux=br.readLine();
        i++;
      }
      br.close();
    }
 catch (    Exception e) {
      throw new JMetalException(""String_Node_Str"" + dataDirectory + ""String_Node_Str""+ dataFileName);
    }
  }
}",0.9306930693069309
64524,"/** 
 * Read a set of weight vector from a file
 * @param filePath A file containing the weight vectors
 * @return A set of weight vectors
 */
public static double[][] getWeightsFromFile(String filePath){
  double[][] weights=new double[0][0];
  Vector<double[]> listOfWeights=new Vector<double[]>();
  try {
    FileInputStream fis=new FileInputStream(filePath);
    InputStreamReader isr=new InputStreamReader(fis);
    BufferedReader br=new BufferedReader(isr);
    int numberOfObjectives=0;
    int i=0;
    int j=0;
    String aux=br.readLine();
    while (aux != null) {
      StringTokenizer st=new StringTokenizer(aux);
      j=0;
      numberOfObjectives=st.countTokens();
      double[] weight=new double[numberOfObjectives];
      while (st.hasMoreTokens()) {
        weight[j]=(new Double(st.nextToken())).doubleValue();
        j++;
      }
      listOfWeights.add(weight);
      aux=br.readLine();
      i++;
    }
    br.close();
    weights=new double[listOfWeights.size()][numberOfObjectives];
    for (int indexWeight=0; indexWeight < listOfWeights.size(); indexWeight++) {
      for (int indexOfObjective=0; indexOfObjective < numberOfObjectives; indexOfObjective++) {
        weights[indexWeight][indexOfObjective]=listOfWeights.get(indexWeight)[indexOfObjective];
      }
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + filePath);
    e.printStackTrace();
  }
  return weights;
}","/** 
 * Read a set of weight vector from a file
 * @param filePath A file containing the weight vectors
 * @return A set of weight vectors
 */
public static double[][] getWeightsFromFile(String filePath){
  double[][] weights=new double[0][0];
  Vector<double[]> listOfWeights=new Vector<double[]>();
  try {
    FileInputStream fis=new FileInputStream(filePath);
    InputStreamReader isr=new InputStreamReader(fis);
    BufferedReader br=new BufferedReader(isr);
    int numberOfObjectives=0;
    int i=0;
    int j=0;
    String aux=br.readLine();
    while (aux != null) {
      StringTokenizer st=new StringTokenizer(aux);
      j=0;
      numberOfObjectives=st.countTokens();
      double[] weight=new double[numberOfObjectives];
      while (st.hasMoreTokens()) {
        weight[j]=(new Double(st.nextToken())).doubleValue();
        j++;
      }
      listOfWeights.add(weight);
      aux=br.readLine();
      i++;
    }
    br.close();
    weights=new double[listOfWeights.size()][numberOfObjectives];
    for (int indexWeight=0; indexWeight < listOfWeights.size(); indexWeight++) {
      for (int indexOfObjective=0; indexOfObjective < numberOfObjectives; indexOfObjective++) {
        weights[indexWeight][indexOfObjective]=listOfWeights.get(indexWeight)[indexOfObjective];
      }
    }
  }
 catch (  Exception e) {
    throw new JMetalException(""String_Node_Str"" + filePath);
  }
  return weights;
}",0.9774806474313864
64525,"/** 
 * Create a   {@link PushMeasure} which checks at regular intervals the valueof a  {@link PullMeasure}. If the value have changed since the last check (or since the creation of the   {@link PushMeasure}), a notification will be generated by the   {@link PushMeasure} with the new {@link Value}.<br/> <br/> Notice that if the period is two small, the checking process could have a significant impact on performances, because a   {@link Thread} is run inparallel to check regularly the  {@link Value} modifications. If theperiod is too big, you could miss relevant notifications, especially if the  {@link PullMeasure} change to a new {@link Value} and change back toits previous  {@link Value} between two consecutive checks. In such acase, no notification will be sent because the  {@link Value} during thetwo checks is equal.
 * @param pull the  {@link PullMeasure} to cover
 * @param period the number of milliseconds between each check
 * @return a {@link PushMeasure} which will notify any change occurred onthe  {@link PullMeasure} at the given frequency
 */
public <Value>PushMeasure<Value> createPushFromPull(PullMeasure<Value> pull,final long period){
  SimplePushMeasure<Value> push=new SimplePushMeasure<>(pull.getName(),pull.getDescription());
  final WeakReference<PullMeasure<Value>> weakPull=new WeakReference<PullMeasure<Value>>(pull);
  final WeakReference<SimplePushMeasure<Value>> weakPush=new WeakReference<SimplePushMeasure<Value>>(push);
  final Value initialValue=pull.get();
  Thread thread=new Thread(new Runnable(){
    private Value lastValue=initialValue;
    @Override public void run(){
      boolean isThreadNeeded=true;
      long alreadyConsumed=0;
      while (isThreadNeeded) {
        if (alreadyConsumed > period) {
          long realConsumption=alreadyConsumed;
          long missed=alreadyConsumed / period;
          alreadyConsumed=alreadyConsumed % period;
          log.warning(""String_Node_Str"" + realConsumption + ""String_Node_Str""+ period+ ""String_Node_Str""+ missed+ ""String_Node_Str""+ alreadyConsumed);
        }
 else {
        }
        try {
          Thread.sleep(period - alreadyConsumed);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
        long measureStart=System.currentTimeMillis();
        PullMeasure<Value> pull=weakPull.get();
        SimplePushMeasure<Value> push=weakPush.get();
        if (pull == null || push == null) {
          isThreadNeeded=false;
        }
 else {
          Value value=pull.get();
          if (value == lastValue || value != null && value.equals(lastValue)) {
          }
 else {
            lastValue=value;
            push.push(value);
          }
        }
        pull=null;
        push=null;
        long measureEnd=System.currentTimeMillis();
        alreadyConsumed=measureEnd - measureStart;
      }
    }
  }
);
  thread.setDaemon(true);
  thread.start();
  return push;
}","/** 
 * Create a   {@link PushMeasure} which checks at regular intervals the valueof a  {@link PullMeasure}. If the value have changed since the last check (or since the creation of the   {@link PushMeasure}), a notification will be generated by the   {@link PushMeasure} with the new {@link Value}.<br/> <br/> Notice that if the period is two small, the checking process could have a significant impact on performances, because a   {@link Thread} is run inparallel to check regularly the  {@link Value} modifications. If theperiod is too big, you could miss relevant notifications, especially if the  {@link PullMeasure} change to a new {@link Value} and change back toits previous  {@link Value} between two consecutive checks. In such acase, no notification will be sent because the  {@link Value} during thetwo checks is equal.
 * @param pull the  {@link PullMeasure} to cover
 * @param period the number of milliseconds between each check
 * @return a {@link PushMeasure} which will notify any change occurred onthe  {@link PullMeasure} at the given frequency
 */
public <Value>PushMeasure<Value> createPushFromPull(PullMeasure<Value> pull,final long period){
  SimplePushMeasure<Value> push=new SimplePushMeasure<>(pull.getName(),pull.getDescription());
  final WeakReference<PullMeasure<Value>> weakPull=new WeakReference<PullMeasure<Value>>(pull);
  final WeakReference<SimplePushMeasure<Value>> weakPush=new WeakReference<SimplePushMeasure<Value>>(push);
  final Value initialValue=pull.get();
  Thread thread=new Thread(new Runnable(){
    private Value lastValue=initialValue;
    @Override public void run(){
      boolean isThreadNeeded=true;
      long alreadyConsumed=0;
      while (isThreadNeeded) {
        if (alreadyConsumed > period) {
          long realConsumption=alreadyConsumed;
          long missed=alreadyConsumed / period;
          alreadyConsumed=alreadyConsumed % period;
          log.warning(""String_Node_Str"" + realConsumption + ""String_Node_Str""+ period+ ""String_Node_Str""+ missed+ ""String_Node_Str""+ alreadyConsumed);
        }
 else {
        }
        try {
          Thread.sleep(period - alreadyConsumed);
        }
 catch (        InterruptedException e) {
          throw new JMetalException(""String_Node_Str"",e);
        }
        long measureStart=System.currentTimeMillis();
        PullMeasure<Value> pull=weakPull.get();
        SimplePushMeasure<Value> push=weakPush.get();
        if (pull == null || push == null) {
          isThreadNeeded=false;
        }
 else {
          Value value=pull.get();
          if (value == lastValue || value != null && value.equals(lastValue)) {
          }
 else {
            lastValue=value;
            push.push(value);
          }
        }
        pull=null;
        push=null;
        long measureEnd=System.currentTimeMillis();
        alreadyConsumed=measureEnd - measureStart;
      }
    }
  }
);
  thread.setDaemon(true);
  thread.start();
  return push;
}",0.7737548869624341
64526,"@Override public void run(){
  boolean isThreadNeeded=true;
  long alreadyConsumed=0;
  while (isThreadNeeded) {
    if (alreadyConsumed > period) {
      long realConsumption=alreadyConsumed;
      long missed=alreadyConsumed / period;
      alreadyConsumed=alreadyConsumed % period;
      log.warning(""String_Node_Str"" + realConsumption + ""String_Node_Str""+ period+ ""String_Node_Str""+ missed+ ""String_Node_Str""+ alreadyConsumed);
    }
 else {
    }
    try {
      Thread.sleep(period - alreadyConsumed);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    long measureStart=System.currentTimeMillis();
    PullMeasure<Value> pull=weakPull.get();
    SimplePushMeasure<Value> push=weakPush.get();
    if (pull == null || push == null) {
      isThreadNeeded=false;
    }
 else {
      Value value=pull.get();
      if (value == lastValue || value != null && value.equals(lastValue)) {
      }
 else {
        lastValue=value;
        push.push(value);
      }
    }
    pull=null;
    push=null;
    long measureEnd=System.currentTimeMillis();
    alreadyConsumed=measureEnd - measureStart;
  }
}","@Override public void run(){
  boolean isThreadNeeded=true;
  long alreadyConsumed=0;
  while (isThreadNeeded) {
    if (alreadyConsumed > period) {
      long realConsumption=alreadyConsumed;
      long missed=alreadyConsumed / period;
      alreadyConsumed=alreadyConsumed % period;
      log.warning(""String_Node_Str"" + realConsumption + ""String_Node_Str""+ period+ ""String_Node_Str""+ missed+ ""String_Node_Str""+ alreadyConsumed);
    }
 else {
    }
    try {
      Thread.sleep(period - alreadyConsumed);
    }
 catch (    InterruptedException e) {
      throw new JMetalException(""String_Node_Str"",e);
    }
    long measureStart=System.currentTimeMillis();
    PullMeasure<Value> pull=weakPull.get();
    SimplePushMeasure<Value> push=weakPush.get();
    if (pull == null || push == null) {
      isThreadNeeded=false;
    }
 else {
      Value value=pull.get();
      if (value == lastValue || value != null && value.equals(lastValue)) {
      }
 else {
        lastValue=value;
        push.push(value);
      }
    }
    pull=null;
    push=null;
    long measureEnd=System.currentTimeMillis();
    alreadyConsumed=measureEnd - measureStart;
  }
}",0.973280770915462
64527,"private void readDataFromFile(String path,Vector<Vector<Double>> data,int algorithmIndex){
  String string=""String_Node_Str"";
  try {
    FileInputStream fis=new FileInputStream(path);
    byte[] bytes=new byte[4096];
    int readBytes=0;
    while (readBytes != -1) {
      readBytes=fis.read(bytes);
      if (readBytes != -1) {
        string+=new String(bytes,0,readBytes);
      }
    }
    fis.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
    System.exit(-1);
  }
  StringTokenizer lines=new StringTokenizer(string,""String_Node_Str"");
  double valor=0.0;
  int n=0;
  while (lines.hasMoreTokens()) {
    valor=valor + Double.parseDouble(lines.nextToken());
    n++;
  }
  if (n != 0) {
    (data.elementAt(algorithmIndex)).add(valor / n);
  }
 else {
    (data.elementAt(algorithmIndex)).add(valor);
  }
}","private void readDataFromFile(String path,Vector<Vector<Double>> data,int algorithmIndex){
  String string=""String_Node_Str"";
  try {
    FileInputStream fis=new FileInputStream(path);
    byte[] bytes=new byte[4096];
    int readBytes=0;
    while (readBytes != -1) {
      readBytes=fis.read(bytes);
      if (readBytes != -1) {
        string+=new String(bytes,0,readBytes);
      }
    }
    fis.close();
  }
 catch (  IOException e) {
    throw new JMetalException(""String_Node_Str"",e);
  }
  StringTokenizer lines=new StringTokenizer(string,""String_Node_Str"");
  double valor=0.0;
  int n=0;
  while (lines.hasMoreTokens()) {
    valor=valor + Double.parseDouble(lines.nextToken());
    n++;
  }
  if (n != 0) {
    (data.elementAt(algorithmIndex)).add(valor / n);
  }
 else {
    (data.elementAt(algorithmIndex)).add(valor);
  }
}",0.9508393285371702
64528,"/** 
 * Write the file contents in the output file
 * @param indicator
 * @param fileContents
 */
private void writeLatexFile(QualityIndicator indicator,String fileContents){
  String outputFile=latexDirectoryName + ""String_Node_Str"" + indicator.getName()+ ""String_Node_Str"";
  try {
    File latexOutput;
    latexOutput=new File(latexDirectoryName);
    if (!latexOutput.exists()) {
      latexOutput.mkdirs();
    }
    FileOutputStream fileOutputStream=new FileOutputStream(outputFile);
    DataOutputStream dataOutputStream=new DataOutputStream(fileOutputStream);
    dataOutputStream.writeBytes(fileContents);
    dataOutputStream.close();
    fileOutputStream.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
    System.exit(-1);
  }
}","/** 
 * Write the file contents in the output file
 * @param indicator
 * @param fileContents
 */
private void writeLatexFile(QualityIndicator indicator,String fileContents){
  String outputFile=latexDirectoryName + ""String_Node_Str"" + indicator.getName()+ ""String_Node_Str"";
  try {
    File latexOutput;
    latexOutput=new File(latexDirectoryName);
    if (!latexOutput.exists()) {
      latexOutput.mkdirs();
    }
    FileOutputStream fileOutputStream=new FileOutputStream(outputFile);
    DataOutputStream dataOutputStream=new DataOutputStream(fileOutputStream);
    dataOutputStream.writeBytes(fileContents);
    dataOutputStream.close();
    fileOutputStream.close();
  }
 catch (  IOException e) {
    throw new JMetalException(""String_Node_Str"",e);
  }
}",0.9448094612352168
64529,"/** 
 * Program to generate data representing the distribution of points generated by a SBX crossover operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - alpha: alpha value - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  if (args.length != 4) {
    throw new JMetalException(""String_Node_Str"");
  }
  int numberOfPoints=Integer.valueOf(args[0]);
  int granularity=Integer.valueOf(args[1]);
  double alpha=Double.valueOf(args[2]);
  String outputFileName=args[3];
  DoubleProblem problem;
  problem=new Kursawe(1);
  CrossoverOperator<DoubleSolution> crossover=new BLXAlphaCrossover(1.0,alpha);
  DoubleSolution solution1=problem.createSolution();
  DoubleSolution solution2=problem.createSolution();
  solution1.setVariableValue(0,-2.0);
  solution2.setVariableValue(0,2.0);
  List<DoubleSolution> parents=Arrays.asList(solution1,solution2);
  List<DoubleSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    List<DoubleSolution> solutions=(List<DoubleSolution>)crossover.execute(parents);
    population.add(solutions.get(0));
    population.add(solutions.get(1));
  }
  Collections.sort(population,new VariableComparator());
  new SolutionListOutput(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Program to generate data representing the distribution of points generated by a SBX crossover operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - alpha: alpha value - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  if (args.length != 4) {
    throw new JMetalException(""String_Node_Str"");
  }
  int numberOfPoints=Integer.valueOf(args[0]);
  int granularity=Integer.valueOf(args[1]);
  double alpha=Double.valueOf(args[2]);
  String outputFileName=args[3];
  DoubleProblem problem;
  problem=new Kursawe(1);
  CrossoverOperator<DoubleSolution> crossover=new BLXAlphaCrossover(1.0,alpha);
  DoubleSolution solution1=problem.createSolution();
  DoubleSolution solution2=problem.createSolution();
  solution1.setVariableValue(0,-2.0);
  solution2.setVariableValue(0,2.0);
  List<DoubleSolution> parents=Arrays.asList(solution1,solution2);
  List<DoubleSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    List<DoubleSolution> solutions=(List<DoubleSolution>)crossover.execute(parents);
    population.add(solutions.get(0));
    population.add(solutions.get(1));
  }
  Collections.sort(population,new VariableComparator());
  new SolutionListOutput(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    throw new JMetalException(""String_Node_Str"",e);
  }
}",0.9844097995545658
64530,"/** 
 * Program to generate data representing the distribution of points generated by a polynomial mutation operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - distributionIndex: distribution index of the polynomial mutation operator - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  int numberOfPoints;
  int granularity;
  double distributionIndex;
  String outputFileName;
  if (args.length != 4) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    numberOfPoints=10000;
    granularity=100;
    distributionIndex=20.0;
    outputFileName=""String_Node_Str"";
  }
 else {
    numberOfPoints=Integer.valueOf(args[0]);
    granularity=Integer.valueOf(args[1]);
    distributionIndex=Double.valueOf(args[2]);
    outputFileName=args[3];
  }
  IntegerProblem problem;
  problem=new NIntegerMin(1,10,-1000,1000);
  MutationOperator<IntegerSolution> mutation=new IntegerPolynomialMutation(1.0,distributionIndex);
  IntegerSolution solution=problem.createSolution();
  solution.setVariableValue(0,0);
  List<IntegerSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    IntegerSolution newSolution=(IntegerSolution)solution.copy();
    mutation.execute(newSolution);
    population.add(newSolution);
  }
  Collections.sort(population,new VariableComparator());
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Program to generate data representing the distribution of points generated by a polynomial mutation operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - distributionIndex: distribution index of the polynomial mutation operator - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  int numberOfPoints;
  int granularity;
  double distributionIndex;
  String outputFileName;
  if (args.length != 4) {
    JMetalLogger.logger.info(""String_Node_Str"");
    JMetalLogger.logger.info(""String_Node_Str"");
    numberOfPoints=10000;
    granularity=100;
    distributionIndex=20.0;
    outputFileName=""String_Node_Str"";
  }
 else {
    numberOfPoints=Integer.valueOf(args[0]);
    granularity=Integer.valueOf(args[1]);
    distributionIndex=Double.valueOf(args[2]);
    outputFileName=args[3];
  }
  IntegerProblem problem;
  problem=new NIntegerMin(1,10,-1000,1000);
  MutationOperator<IntegerSolution> mutation=new IntegerPolynomialMutation(1.0,distributionIndex);
  IntegerSolution solution=problem.createSolution();
  solution.setVariableValue(0,0);
  List<IntegerSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    IntegerSolution newSolution=(IntegerSolution)solution.copy();
    mutation.execute(newSolution);
    population.add(newSolution);
  }
  Collections.sort(population,new VariableComparator());
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    throw new JMetalException(""String_Node_Str"",e);
  }
}",0.9644694927713796
64531,"/** 
 * Program to generate data representing the distribution of points generated by a SBX crossover operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - distributionIndex: distribution index of the polynomial mutation operator - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  if (args.length != 4) {
    throw new JMetalException(""String_Node_Str"");
  }
  int numberOfPoints=Integer.valueOf(args[0]);
  int granularity=Integer.valueOf(args[1]);
  double distributionIndex=Double.valueOf(args[2]);
  String outputFileName=args[3];
  IntegerProblem problem;
  problem=new NMMin(1,-50,50,-100,100);
  CrossoverOperator<IntegerSolution> crossover=new IntegerSBXCrossover(1.0,distributionIndex);
  IntegerSolution solution1=problem.createSolution();
  IntegerSolution solution2=problem.createSolution();
  solution1.setVariableValue(0,-50);
  solution2.setVariableValue(0,50);
  List<IntegerSolution> parents=Arrays.asList(solution1,solution2);
  List<IntegerSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    List<IntegerSolution> solutions=(List<IntegerSolution>)crossover.execute(parents);
    population.add(solutions.get(0));
    population.add(solutions.get(1));
  }
  Collections.sort(population,new VariableComparator());
  new SolutionListOutput(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Program to generate data representing the distribution of points generated by a SBX crossover operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - distributionIndex: distribution index of the polynomial mutation operator - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  if (args.length != 4) {
    throw new JMetalException(""String_Node_Str"");
  }
  int numberOfPoints=Integer.valueOf(args[0]);
  int granularity=Integer.valueOf(args[1]);
  double distributionIndex=Double.valueOf(args[2]);
  String outputFileName=args[3];
  IntegerProblem problem;
  problem=new NMMin(1,-50,50,-100,100);
  CrossoverOperator<IntegerSolution> crossover=new IntegerSBXCrossover(1.0,distributionIndex);
  IntegerSolution solution1=problem.createSolution();
  IntegerSolution solution2=problem.createSolution();
  solution1.setVariableValue(0,-50);
  solution2.setVariableValue(0,50);
  List<IntegerSolution> parents=Arrays.asList(solution1,solution2);
  List<IntegerSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    List<IntegerSolution> solutions=(List<IntegerSolution>)crossover.execute(parents);
    population.add(solutions.get(0));
    population.add(solutions.get(1));
  }
  Collections.sort(population,new VariableComparator());
  new SolutionListOutput(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    throw new JMetalException(""String_Node_Str"",e);
  }
}",0.9851520150836672
64532,"/** 
 * Program to generate data representing the distribution of points generated by a polynomial mutation operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - distributionIndex: distribution index of the polynomial mutation operator - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  if (args.length != 4) {
    throw new JMetalException(""String_Node_Str"");
  }
  int numberOfPoints=Integer.valueOf(args[0]);
  int granularity=Integer.valueOf(args[1]);
  double distributionIndex=Double.valueOf(args[2]);
  String outputFileName=args[3];
  DoubleProblem problem;
  problem=new Sphere(1);
  MutationOperator<DoubleSolution> mutation=new PolynomialMutation(1.0,distributionIndex);
  DoubleSolution solution=problem.createSolution();
  solution.setVariableValue(0,0.0);
  List<DoubleSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    DoubleSolution newSolution=(DoubleSolution)solution.copy();
    mutation.execute(newSolution);
    population.add(newSolution);
  }
  Collections.sort(population,new VariableComparator());
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Program to generate data representing the distribution of points generated by a polynomial mutation operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - distributionIndex: distribution index of the polynomial mutation operator - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  if (args.length != 4) {
    throw new JMetalException(""String_Node_Str"");
  }
  int numberOfPoints=Integer.valueOf(args[0]);
  int granularity=Integer.valueOf(args[1]);
  double distributionIndex=Double.valueOf(args[2]);
  String outputFileName=args[3];
  DoubleProblem problem;
  problem=new Sphere(1);
  MutationOperator<DoubleSolution> mutation=new PolynomialMutation(1.0,distributionIndex);
  DoubleSolution solution=problem.createSolution();
  solution.setVariableValue(0,0.0);
  List<DoubleSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    DoubleSolution newSolution=(DoubleSolution)solution.copy();
    mutation.execute(newSolution);
    population.add(newSolution);
  }
  Collections.sort(population,new VariableComparator());
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    throw new JMetalException(""String_Node_Str"",e);
  }
}",0.9821377941593422
64533,"/** 
 * Program to generate data representing the distribution of points generated by a SBX crossover operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - distributionIndex: distribution index of the polynomial mutation operator - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  if (args.length != 4) {
    throw new JMetalException(""String_Node_Str"");
  }
  int numberOfPoints=Integer.valueOf(args[0]);
  int granularity=Integer.valueOf(args[1]);
  double distributionIndex=Double.valueOf(args[2]);
  String outputFileName=args[3];
  DoubleProblem problem;
  problem=new Kursawe(1);
  CrossoverOperator<DoubleSolution> crossover=new SBXCrossover(1.0,distributionIndex);
  DoubleSolution solution1=problem.createSolution();
  DoubleSolution solution2=problem.createSolution();
  solution1.setVariableValue(0,-3.0);
  solution2.setVariableValue(0,3.0);
  List<DoubleSolution> parents=Arrays.asList(solution1,solution2);
  List<DoubleSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    List<DoubleSolution> solutions=(List<DoubleSolution>)crossover.execute(parents);
    population.add(solutions.get(0));
    population.add(solutions.get(1));
  }
  Collections.sort(population,new VariableComparator());
  new SolutionListOutput(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Program to generate data representing the distribution of points generated by a SBX crossover operator. The parameters to be introduced by the command line are: - numberOfSolutions: number of solutions to generate - granularity: number of subdivisions to be considered. - distributionIndex: distribution index of the polynomial mutation operator - outputFile: file containing the results
 * @param args Command line arguments
 */
public static void main(String[] args) throws FileNotFoundException {
  if (args.length != 4) {
    throw new JMetalException(""String_Node_Str"");
  }
  int numberOfPoints=Integer.valueOf(args[0]);
  int granularity=Integer.valueOf(args[1]);
  double distributionIndex=Double.valueOf(args[2]);
  String outputFileName=args[3];
  DoubleProblem problem;
  problem=new Kursawe(1);
  CrossoverOperator<DoubleSolution> crossover=new SBXCrossover(1.0,distributionIndex);
  DoubleSolution solution1=problem.createSolution();
  DoubleSolution solution2=problem.createSolution();
  solution1.setVariableValue(0,-3.0);
  solution2.setVariableValue(0,3.0);
  List<DoubleSolution> parents=Arrays.asList(solution1,solution2);
  List<DoubleSolution> population=new ArrayList<>(numberOfPoints);
  for (int i=0; i < numberOfPoints; i++) {
    List<DoubleSolution> solutions=(List<DoubleSolution>)crossover.execute(parents);
    population.add(solutions.get(0));
    population.add(solutions.get(1));
  }
  Collections.sort(population,new VariableComparator());
  new SolutionListOutput(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  double[][] classifier=classify(population,problem,granularity);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFileName)));
  try {
    for (int i=0; i < classifier.length; i++) {
      bufferedWriter.write(classifier[i][0] + ""String_Node_Str"" + classifier[i][1]);
      bufferedWriter.newLine();
    }
    bufferedWriter.close();
  }
 catch (  IOException e) {
    throw new JMetalException(""String_Node_Str"",e);
  }
}",0.9849606111243734
64534,"/** 
 * The run() method creates de output directory and compute the fronts
 */
@Override public void run() throws IOException {
  String outputDirectoryName=experiment.getReferenceFrontDirectory();
  File outputDirectory=createOutputDirectory(outputDirectoryName);
  List<String> referenceFrontFileNames=new LinkedList<>();
  for (  Problem<?> problem : experiment.getProblemList()) {
    NonDominatedSolutionListArchive<DoubleSolution> nonDominatedSolutionArchive=new NonDominatedSolutionListArchive<DoubleSolution>();
    for (    TaggedAlgorithm<?> algorithm : experiment.getAlgorithmList()) {
      String problemDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getTag()+ ""String_Node_Str""+ problem.getName();
      for (int i=0; i < experiment.getIndependentRuns(); i++) {
        String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
        Front front=new ArrayFront(frontFileName);
        List<DoubleSolution> solutionList=FrontUtils.convertFrontToSolutionList(front);
        for (        DoubleSolution solution : solutionList) {
          nonDominatedSolutionArchive.add(solution);
        }
      }
    }
    String referenceSetFileName=outputDirectoryName + ""String_Node_Str"" + problem.getName()+ ""String_Node_Str"";
    referenceFrontFileNames.add(problem.getName() + ""String_Node_Str"");
    new SolutionListOutput(nonDominatedSolutionArchive.getSolutionList()).printObjectivesToFile(referenceSetFileName);
    ;
  }
  experiment.setReferenceFrontFileNames(referenceFrontFileNames);
}","/** 
 * The run() method creates de output directory and compute the fronts
 */
@Override public void run() throws IOException {
  String outputDirectoryName=experiment.getReferenceFrontDirectory();
  File outputDirectory=createOutputDirectory(outputDirectoryName);
  List<String> referenceFrontFileNames=new LinkedList<>();
  for (  Problem<?> problem : experiment.getProblemList()) {
    NonDominatedSolutionListArchive<DoubleSolution> nonDominatedSolutionArchive=new NonDominatedSolutionListArchive<DoubleSolution>();
    for (    TaggedAlgorithm<?> algorithm : experiment.getAlgorithmList()) {
      String problemDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getTag()+ ""String_Node_Str""+ problem.getName();
      for (int i=0; i < experiment.getIndependentRuns(); i++) {
        String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
        Front front=new ArrayFront(frontFileName);
        List<DoubleSolution> solutionList=FrontUtils.convertFrontToSolutionList(front);
        GenericSolutionAttribute<DoubleSolution,String> solutionAttribute=new GenericSolutionAttribute<DoubleSolution,String>();
        for (        DoubleSolution solution : solutionList) {
          solutionAttribute.setAttribute(solution,algorithm.getTag());
          nonDominatedSolutionArchive.add(solution);
        }
      }
    }
    String referenceSetFileName=outputDirectoryName + ""String_Node_Str"" + problem.getName()+ ""String_Node_Str"";
    referenceFrontFileNames.add(problem.getName() + ""String_Node_Str"");
    new SolutionListOutput(nonDominatedSolutionArchive.getSolutionList()).printObjectivesToFile(referenceSetFileName);
    writeFilesWithTheSolutionsContributedByEachAlgorithm(outputDirectoryName,problem,nonDominatedSolutionArchive.getSolutionList());
  }
  experiment.setReferenceFrontFileNames(referenceFrontFileNames);
}",0.9074964639321076
64535,"/** 
 * Deletes a file or directory if it does exist
 * @param file
 */
private void resetFile(String file){
  File f=new File(file);
  if (f.exists()) {
    System.out.println(""String_Node_Str"" + file + ""String_Node_Str"");
    if (f.isDirectory()) {
      System.out.println(""String_Node_Str"" + file + ""String_Node_Str"");
      if (f.delete()) {
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
 else {
      System.out.println(""String_Node_Str"" + file + ""String_Node_Str"");
      if (f.delete()) {
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 else {
    System.out.println(""String_Node_Str"" + file + ""String_Node_Str"");
  }
}","/** 
 * Deletes a file or directory if it does exist
 * @param file
 */
private void resetFile(String file){
  File f=new File(file);
  if (f.exists()) {
    JMetalLogger.logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
    if (f.isDirectory()) {
      JMetalLogger.logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
      if (f.delete()) {
        JMetalLogger.logger.info(""String_Node_Str"");
      }
 else {
        JMetalLogger.logger.info(""String_Node_Str"");
      }
    }
 else {
      JMetalLogger.logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
      if (f.delete()) {
        JMetalLogger.logger.info(""String_Node_Str"");
      }
 else {
        JMetalLogger.logger.info(""String_Node_Str"");
      }
    }
  }
 else {
    JMetalLogger.logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
  }
}",0.5530864197530864
64536,"@Override public void run() throws IOException {
  for (  GenericIndicator indicator : indicatorList) {
    System.out.println(indicator.getName());
    for (    TaggedAlgorithm algorithm : configuration.getAlgorithmList()) {
      String algorithmDirectory;
      algorithmDirectory=configuration.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getTag();
      for (int problemId=0; problemId < configuration.getProblemList().size(); problemId++) {
        String problemDirectory=algorithmDirectory + ""String_Node_Str"" + configuration.getProblemList().get(problemId).getName();
        String referenceFrontDirectory=configuration.getReferenceFrontDirectory();
        String referenceFrontName=referenceFrontDirectory + ""String_Node_Str"" + configuration.getReferenceFrontFileNames().get(problemId);
        Front referenceFront=new ArrayFront(referenceFrontName);
        Front normalizedReferenceFront=new FrontNormalizer(referenceFront).normalize(referenceFront);
        String qualityIndicatorFile=problemDirectory + ""String_Node_Str"" + indicator.getName();
        System.out.println(""String_Node_Str"" + qualityIndicatorFile);
        resetFile(qualityIndicatorFile);
        indicator.setReferenceParetoFront(normalizedReferenceFront);
        for (int i=0; i < configuration.getIndependentRuns(); i++) {
          String frontFileName;
          frontFileName=problemDirectory + ""String_Node_Str"" + configuration.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
          Front front=new ArrayFront(frontFileName);
          Front normalizedFront=new FrontNormalizer(normalizedReferenceFront).normalize(front);
          Double indicatorValue=(Double)indicator.evaluate(FrontUtils.convertFrontToSolutionList(normalizedFront));
          System.out.println(indicator.getName() + ""String_Node_Str"" + indicatorValue);
          FileWriter os;
          try {
            os=new FileWriter(qualityIndicatorFile,true);
            os.write(""String_Node_Str"" + indicatorValue + ""String_Node_Str"");
            os.close();
          }
 catch (          IOException ex) {
            throw new JMetalException(""String_Node_Str"" + ex);
          }
        }
      }
    }
  }
}","@Override public void run() throws IOException {
  for (  GenericIndicator indicator : indicatorList) {
    JMetalLogger.logger.info(""String_Node_Str"" + indicator.getName());
    ;
    for (    TaggedAlgorithm algorithm : configuration.getAlgorithmList()) {
      String algorithmDirectory;
      algorithmDirectory=configuration.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getTag();
      for (int problemId=0; problemId < configuration.getProblemList().size(); problemId++) {
        String problemDirectory=algorithmDirectory + ""String_Node_Str"" + configuration.getProblemList().get(problemId).getName();
        String referenceFrontDirectory=configuration.getReferenceFrontDirectory();
        String referenceFrontName=referenceFrontDirectory + ""String_Node_Str"" + configuration.getReferenceFrontFileNames().get(problemId);
        JMetalLogger.logger.info(""String_Node_Str"" + referenceFrontName);
        ;
        Front referenceFront=new ArrayFront(referenceFrontName);
        FrontNormalizer frontNormalizer=new FrontNormalizer(referenceFront);
        Front normalizedReferenceFront=frontNormalizer.normalize(referenceFront);
        String qualityIndicatorFile=problemDirectory + ""String_Node_Str"" + indicator.getName();
        resetFile(qualityIndicatorFile);
        indicator.setReferenceParetoFront(normalizedReferenceFront);
        for (int i=0; i < configuration.getIndependentRuns(); i++) {
          String frontFileName;
          frontFileName=problemDirectory + ""String_Node_Str"" + configuration.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
          Front front=new ArrayFront(frontFileName);
          Front normalizedFront=frontNormalizer.normalize(front);
          List<DoubleSolution> normalizedPopulation=FrontUtils.convertFrontToSolutionList(normalizedFront);
          Double indicatorValue=(Double)indicator.evaluate(normalizedPopulation);
          JMetalLogger.logger.info(indicator.getName() + ""String_Node_Str"" + indicatorValue);
          FileWriter os;
          try {
            os=new FileWriter(qualityIndicatorFile,true);
            os.write(""String_Node_Str"" + indicatorValue + ""String_Node_Str"");
            os.close();
          }
 catch (          IOException ex) {
            throw new JMetalException(""String_Node_Str"" + ex);
          }
        }
      }
    }
  }
}",0.8563256325632563
64537,"public static void main(String[] args) throws IOException {
  if (args.length < 2) {
    new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  List<String> referenceFrontFileNames=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Experiment<DoubleSolution,List<DoubleSolution>> configuration=new ExperimentBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setExperimentBaseDirectory(experimentBaseDirectory).setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setReferenceFrontDirectory(""String_Node_Str"").setReferenceFrontFileNames(referenceFrontFileNames).setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>())).setIndependentRuns(30).setNumberOfCores(8).build();
  new ExecuteAlgorithms<>(configuration).run();
  new ComputeQualityIndicators<>(configuration).run();
  new GenerateLatexTablesWithStatistics(configuration).run();
  new GenerateWilcoxonTestTablesWithR<>(configuration).run();
  new GenerateFriedmanTestTables<>(configuration).run();
  new GenerateBoxplotsWithR<>(configuration).setRows(3).setColumns(3).run();
}","public static void main(String[] args) throws IOException {
  if (args.length < 2) {
    throw new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  List<String> referenceFrontFileNames=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Experiment<DoubleSolution,List<DoubleSolution>> experiment=new ExperimentBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setExperimentBaseDirectory(experimentBaseDirectory).setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setReferenceFrontDirectory(""String_Node_Str"").setReferenceFrontFileNames(referenceFrontFileNames).setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>())).setIndependentRuns(30).setNumberOfCores(8).build();
  new ExecuteAlgorithms<>(experiment).run();
  new ComputeQualityIndicators<>(experiment).run();
  new GenerateLatexTablesWithStatistics(experiment).run();
  new GenerateWilcoxonTestTablesWithR<>(experiment).run();
  new GenerateFriedmanTestTables<>(experiment).run();
  new GenerateBoxplotsWithR<>(experiment).setRows(3).setColumns(3).run();
}",0.9505478235119929
64538,"public static void main(String[] args) throws IOException {
  if (args.length < 2) {
    new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  Experiment<DoubleSolution,List<DoubleSolution>> configuration=new ExperimentBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setExperimentBaseDirectory(experimentBaseDirectory).setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>())).setIndependentRuns(25).setNumberOfCores(8).build();
  new ExecuteAlgorithms<>(configuration).run();
  new GenerateReferenceParetoFront(configuration).run();
  new ComputeQualityIndicators<>(configuration).run();
  new GenerateLatexTablesWithStatistics(configuration).run();
  new GenerateWilcoxonTestTablesWithR<>(configuration).run();
  new GenerateBoxplotsWithR<>(configuration).setRows(3).setColumns(3).run();
}","public static void main(String[] args) throws IOException {
  if (args.length < 2) {
    throw new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  Experiment<DoubleSolution,List<DoubleSolution>> experiment=new ExperimentBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setExperimentBaseDirectory(experimentBaseDirectory).setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>())).setIndependentRuns(25).setNumberOfCores(8).build();
  new ExecuteAlgorithms<>(experiment).run();
  new GenerateReferenceParetoSetAndFrontFromDoubleSolutions(experiment).run();
  new ComputeQualityIndicators<>(experiment).run();
  new GenerateLatexTablesWithStatistics(experiment).run();
  new GenerateWilcoxonTestTablesWithR<>(experiment).run();
  new GenerateFriedmanTestTables<>(experiment).run();
  new GenerateBoxplotsWithR<>(experiment).setRows(3).setColumns(3).run();
}",0.9164983164983164
64539,"private void generateLatexScript(List<List<List<List<Double>>>> data) throws IOException {
  String latexDirectoryName=configuration.getExperimentBaseDirectory() + ""String_Node_Str"" + DEFAULT_LATEX_DIRECTORY;
  File latexOutput;
  latexOutput=new File(latexDirectoryName);
  if (!latexOutput.exists()) {
    boolean result=new File(latexDirectoryName).mkdirs();
    System.out.println(""String_Node_Str"" + latexDirectoryName + ""String_Node_Str"");
  }
  String latexFile=latexDirectoryName + ""String_Node_Str"" + configuration.getExperimentName()+ ""String_Node_Str"";
  printHeaderLatexCommands(latexFile);
  for (int i=0; i < configuration.getIndicatorList().size(); i++) {
    printData(latexFile,i,mean,stdDeviation,""String_Node_Str"");
    printData(latexFile,i,median,iqr,""String_Node_Str"");
  }
  printEndLatexCommands(latexFile);
}","private void generateLatexScript(List<List<List<List<Double>>>> data) throws IOException {
  String latexDirectoryName=configuration.getExperimentBaseDirectory() + ""String_Node_Str"" + DEFAULT_LATEX_DIRECTORY;
  File latexOutput;
  latexOutput=new File(latexDirectoryName);
  if (!latexOutput.exists()) {
    boolean result=new File(latexDirectoryName).mkdirs();
    JMetalLogger.logger.info(""String_Node_Str"" + latexDirectoryName + ""String_Node_Str"");
  }
  String latexFile=latexDirectoryName + ""String_Node_Str"" + configuration.getExperimentName()+ ""String_Node_Str"";
  printHeaderLatexCommands(latexFile);
  for (int i=0; i < configuration.getIndicatorList().size(); i++) {
    printData(latexFile,i,mean,stdDeviation,""String_Node_Str"");
    printData(latexFile,i,median,iqr,""String_Node_Str"");
  }
  printEndLatexCommands(latexFile);
}",0.9772727272727272
64540,"private void printData(String latexFile,int indicatorIndex,double[][][] centralTendency,double[][][] dispersion,String caption) throws IOException {
  FileWriter os=new FileWriter(latexFile,true);
  os.write(""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + configuration.getIndicatorList().get(indicatorIndex).getName() + ""String_Node_Str""+ caption+ ""String_Node_Str""+ ""String_Node_Str"");
  os.write(""String_Node_Str"" + configuration.getIndicatorList().get(indicatorIndex).getName() + ""String_Node_Str""+ ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"");
  for (  TaggedAlgorithm algorithm : configuration.getAlgorithmList()) {
    os.write(""String_Node_Str"");
  }
  os.write(""String_Node_Str"");
  os.write(""String_Node_Str"");
  for (int i=-1; i < configuration.getAlgorithmList().size(); i++) {
    if (i == -1) {
      os.write(""String_Node_Str"");
    }
 else     if (i == (configuration.getAlgorithmList().size() - 1)) {
      os.write(""String_Node_Str"" + configuration.getAlgorithmList().get(i).getTag() + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      os.write(""String_Node_Str"" + configuration.getAlgorithmList().get(i).getTag() + ""String_Node_Str"");
    }
  }
  os.write(""String_Node_Str"");
  for (int i=0; i < configuration.getProblemList().size(); i++) {
    double bestCentralTendencyValue;
    double bestDispersionValue;
    double secondBestCentralTendencyValue;
    double secondBestDispersionValue;
    int bestIndex=-1;
    int secondBestIndex=-1;
    if (configuration.getIndicatorList().get(indicatorIndex).isTheLowerTheIndicatorValueTheBetter()) {
      bestCentralTendencyValue=Double.MAX_VALUE;
      bestDispersionValue=Double.MAX_VALUE;
      secondBestCentralTendencyValue=Double.MAX_VALUE;
      secondBestDispersionValue=Double.MAX_VALUE;
      for (int j=0; j < (configuration.getAlgorithmList().size()); j++) {
        if ((centralTendency[indicatorIndex][i][j] < bestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == bestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < bestDispersionValue))) {
          secondBestIndex=bestIndex;
          secondBestCentralTendencyValue=bestCentralTendencyValue;
          secondBestDispersionValue=bestDispersionValue;
          bestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          bestDispersionValue=dispersion[indicatorIndex][i][j];
          bestIndex=j;
        }
 else         if ((centralTendency[indicatorIndex][i][j] < secondBestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == secondBestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < secondBestDispersionValue))) {
          secondBestIndex=j;
          secondBestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          secondBestDispersionValue=dispersion[indicatorIndex][i][j];
        }
      }
    }
 else {
      bestCentralTendencyValue=Double.MIN_VALUE;
      bestDispersionValue=Double.MIN_VALUE;
      secondBestCentralTendencyValue=Double.MIN_VALUE;
      secondBestDispersionValue=Double.MIN_VALUE;
      for (int j=0; j < (configuration.getAlgorithmList().size()); j++) {
        if ((centralTendency[indicatorIndex][i][j] > bestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == bestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < bestDispersionValue))) {
          secondBestIndex=bestIndex;
          secondBestCentralTendencyValue=bestCentralTendencyValue;
          secondBestDispersionValue=bestDispersionValue;
          bestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          bestDispersionValue=dispersion[indicatorIndex][i][j];
          bestIndex=j;
        }
 else         if ((centralTendency[indicatorIndex][i][j] > secondBestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == secondBestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < secondBestDispersionValue))) {
          secondBestIndex=j;
          secondBestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          secondBestDispersionValue=dispersion[indicatorIndex][i][j];
        }
      }
    }
    os.write(configuration.getProblemList().get(i).getName().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
    for (int j=0; j < (configuration.getAlgorithmList().size() - 1); j++) {
      if (j == bestIndex) {
        os.write(""String_Node_Str"");
      }
      if (j == secondBestIndex) {
        os.write(""String_Node_Str"");
      }
      String m=String.format(Locale.ENGLISH,""String_Node_Str"",centralTendency[indicatorIndex][i][j]);
      String s=String.format(Locale.ENGLISH,""String_Node_Str"",dispersion[indicatorIndex][i][j]);
      os.write(""String_Node_Str"" + m + ""String_Node_Str""+ s+ ""String_Node_Str"");
    }
    if (bestIndex == (configuration.getAlgorithmList().size() - 1)) {
      os.write(""String_Node_Str"");
    }
    String m=String.format(Locale.ENGLISH,""String_Node_Str"",centralTendency[indicatorIndex][i][configuration.getAlgorithmList().size() - 1]);
    String s=String.format(Locale.ENGLISH,""String_Node_Str"",dispersion[indicatorIndex][i][configuration.getAlgorithmList().size() - 1]);
    os.write(""String_Node_Str"" + m + ""String_Node_Str""+ s+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.close();
}","private void printData(String latexFile,int indicatorIndex,double[][][] centralTendency,double[][][] dispersion,String caption) throws IOException {
  FileWriter os=new FileWriter(latexFile,true);
  os.write(""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + configuration.getIndicatorList().get(indicatorIndex).getName() + ""String_Node_Str""+ caption+ ""String_Node_Str""+ ""String_Node_Str"");
  os.write(""String_Node_Str"" + configuration.getIndicatorList().get(indicatorIndex).getName() + ""String_Node_Str""+ ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"");
  for (  TaggedAlgorithm algorithm : configuration.getAlgorithmList()) {
    os.write(""String_Node_Str"");
  }
  os.write(""String_Node_Str"");
  os.write(""String_Node_Str"");
  for (int i=-1; i < configuration.getAlgorithmList().size(); i++) {
    if (i == -1) {
      os.write(""String_Node_Str"");
    }
 else     if (i == (configuration.getAlgorithmList().size() - 1)) {
      os.write(""String_Node_Str"" + configuration.getAlgorithmList().get(i).getTag() + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      os.write(""String_Node_Str"" + configuration.getAlgorithmList().get(i).getTag() + ""String_Node_Str"");
    }
  }
  os.write(""String_Node_Str"");
  for (int i=0; i < configuration.getProblemList().size(); i++) {
    double bestCentralTendencyValue;
    double bestDispersionValue;
    double secondBestCentralTendencyValue;
    double secondBestDispersionValue;
    int bestIndex=-1;
    int secondBestIndex=-1;
    if (configuration.getIndicatorList().get(indicatorIndex).isTheLowerTheIndicatorValueTheBetter()) {
      bestCentralTendencyValue=Double.MAX_VALUE;
      bestDispersionValue=Double.MAX_VALUE;
      secondBestCentralTendencyValue=Double.MAX_VALUE;
      secondBestDispersionValue=Double.MAX_VALUE;
      for (int j=0; j < (configuration.getAlgorithmList().size()); j++) {
        if ((centralTendency[indicatorIndex][i][j] < bestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == bestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < bestDispersionValue))) {
          secondBestIndex=bestIndex;
          secondBestCentralTendencyValue=bestCentralTendencyValue;
          secondBestDispersionValue=bestDispersionValue;
          bestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          bestDispersionValue=dispersion[indicatorIndex][i][j];
          bestIndex=j;
        }
 else         if ((centralTendency[indicatorIndex][i][j] < secondBestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == secondBestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < secondBestDispersionValue))) {
          secondBestIndex=j;
          secondBestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          secondBestDispersionValue=dispersion[indicatorIndex][i][j];
        }
      }
    }
 else {
      bestCentralTendencyValue=Double.MIN_VALUE;
      bestDispersionValue=Double.MIN_VALUE;
      secondBestCentralTendencyValue=Double.MIN_VALUE;
      secondBestDispersionValue=Double.MIN_VALUE;
      for (int j=0; j < (configuration.getAlgorithmList().size()); j++) {
        if ((centralTendency[indicatorIndex][i][j] > bestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == bestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < bestDispersionValue))) {
          secondBestIndex=bestIndex;
          secondBestCentralTendencyValue=bestCentralTendencyValue;
          secondBestDispersionValue=bestDispersionValue;
          bestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          bestDispersionValue=dispersion[indicatorIndex][i][j];
          bestIndex=j;
        }
 else         if ((centralTendency[indicatorIndex][i][j] > secondBestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == secondBestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < secondBestDispersionValue))) {
          secondBestIndex=j;
          secondBestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          secondBestDispersionValue=dispersion[indicatorIndex][i][j];
        }
      }
    }
    os.write(configuration.getProblemList().get(i).getName().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
    for (int j=0; j < (configuration.getAlgorithmList().size() - 1); j++) {
      if (j == bestIndex) {
        os.write(""String_Node_Str"");
      }
      if (j == secondBestIndex) {
        os.write(""String_Node_Str"");
      }
      String m=String.format(Locale.ENGLISH,""String_Node_Str"",centralTendency[indicatorIndex][i][j]);
      String s=String.format(Locale.ENGLISH,""String_Node_Str"",dispersion[indicatorIndex][i][j]);
      os.write(""String_Node_Str"" + m + ""String_Node_Str""+ s+ ""String_Node_Str"");
    }
    if (bestIndex == (configuration.getAlgorithmList().size() - 1)) {
      os.write(""String_Node_Str"");
    }
    if (secondBestIndex == (configuration.getAlgorithmList().size() - 1)) {
      os.write(""String_Node_Str"");
    }
    String m=String.format(Locale.ENGLISH,""String_Node_Str"",centralTendency[indicatorIndex][i][configuration.getAlgorithmList().size() - 1]);
    String s=String.format(Locale.ENGLISH,""String_Node_Str"",dispersion[indicatorIndex][i][configuration.getAlgorithmList().size() - 1]);
    os.write(""String_Node_Str"" + m + ""String_Node_Str""+ s+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.close();
}",0.9896925381023698
64541,"/** 
 * Constructor
 */
public MOCHC(BinaryProblem problem,int populationSize,int maxEvaluations,int convergenceValue,double preservedPopulation,double initialConvergenceCount,CrossoverOperator<BinarySolution> crossoverOperator,MutationOperator<BinarySolution> cataclysmicMutation,SelectionOperator<List<BinarySolution>,List<BinarySolution>> newGenerationSelection,SelectionOperator<List<BinarySolution>,BinarySolution> parentSelection,SolutionListEvaluator<BinarySolution> evaluator){
  super();
  this.problem=problem;
  setMaxPopulationSize(populationSize);
  this.maxEvaluations=maxEvaluations;
  this.convergenceValue=convergenceValue;
  this.preservedPopulation=preservedPopulation;
  this.initialConvergenceCount=initialConvergenceCount;
  this.crossover=crossoverOperator;
  this.cataclysmicMutation=cataclysmicMutation;
  this.newGenerationSelection=newGenerationSelection;
  this.parentSelection=parentSelection;
  this.evaluator=evaluator;
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    size+=problem.getNumberOfBits(i);
  }
  minimumDistance=(int)Math.floor(this.initialConvergenceCount * size);
  comparator=new CrowdingDistanceComparator<BinarySolution>();
}","/** 
 * Constructor
 */
public MOCHC(BinaryProblem problem,int populationSize,int maxEvaluations,int convergenceValue,double preservedPopulation,double initialConvergenceCount,CrossoverOperator<BinarySolution> crossoverOperator,MutationOperator<BinarySolution> cataclysmicMutation,SelectionOperator<List<BinarySolution>,List<BinarySolution>> newGenerationSelection,SelectionOperator<List<BinarySolution>,BinarySolution> parentSelection,SolutionListEvaluator<BinarySolution> evaluator){
  super();
  this.problem=problem;
  setMaxPopulationSize(populationSize);
  this.maxEvaluations=maxEvaluations;
  this.convergenceValue=convergenceValue;
  this.preservedPopulation=preservedPopulation;
  this.initialConvergenceCount=initialConvergenceCount;
  this.crossover=crossoverOperator;
  this.cataclysmicMutation=cataclysmicMutation;
  this.newGenerationSelection=newGenerationSelection;
  this.parentSelection=parentSelection;
  this.evaluator=evaluator;
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    size+=problem.getNumberOfBits(i);
  }
  minimumDistance=(int)Math.floor(this.initialConvergenceCount * size);
  System.out.println(""String_Node_Str"" + minimumDistance);
  comparator=new CrowdingDistanceComparator<BinarySolution>();
}",0.975770020533881
64542,"@Override protected List<BinarySolution> replacement(List<BinarySolution> population,List<BinarySolution> offspringPopulation){
  List<BinarySolution> union=new ArrayList<>();
  union.addAll(population);
  union.addAll(offspringPopulation);
  List<BinarySolution> newPopulation=newGenerationSelection.execute(union);
  if (solutionSetsAreEquals(population,newPopulation)) {
    minimumDistance--;
  }
  if (minimumDistance <= -convergenceValue) {
    minimumDistance=(int)(1.0 / size * (1 - 1.0 / size) * size);
    int preserve=(int)Math.floor(preservedPopulation * population.size());
    newPopulation=new ArrayList<>(getMaxPopulationSize());
    Collections.sort(population,comparator);
    for (int i=0; i < preserve; i++) {
      newPopulation.add((BinarySolution)population.get(i).copy());
    }
    for (int i=preserve; i < getMaxPopulationSize(); i++) {
      BinarySolution solution=(BinarySolution)population.get(i).copy();
      cataclysmicMutation.execute(solution);
      newPopulation.add(solution);
    }
  }
  return newPopulation;
}","@Override protected List<BinarySolution> replacement(List<BinarySolution> population,List<BinarySolution> offspringPopulation){
  List<BinarySolution> union=new ArrayList<>();
  union.addAll(population);
  union.addAll(offspringPopulation);
  List<BinarySolution> newPopulation=newGenerationSelection.execute(union);
  if (SolutionListUtils.solutionListsAreEquals(population,newPopulation)) {
    minimumDistance--;
  }
  if (minimumDistance <= -convergenceValue) {
    minimumDistance=(int)(0.35 * (1 - 0.35) * size);
    int preserve=(int)Math.floor(preservedPopulation * population.size());
    newPopulation=new ArrayList<>(getMaxPopulationSize());
    Collections.sort(population,comparator);
    for (int i=0; i < preserve; i++) {
      newPopulation.add((BinarySolution)population.get(i).copy());
    }
    for (int i=preserve; i < getMaxPopulationSize(); i++) {
      BinarySolution solution=(BinarySolution)population.get(i).copy();
      cataclysmicMutation.execute(solution);
      newPopulation.add(solution);
    }
  }
  return newPopulation;
}",0.9625059326056004
64543,"@Override public void run(){
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    size+=problem.getNumberOfBits(i);
  }
  minimumDistance=(int)Math.floor(this.initialConvergenceCount * size);
  comparator=new CrowdingDistanceComparator<BinarySolution>();
  evaluations=0;
  population=new ArrayList<>();
  for (int i=0; i < populationSize; i++) {
    BinarySolution newIndividual=problem.createSolution();
    problem.evaluate(newIndividual);
    population.add(newIndividual);
    evaluations++;
  }
  boolean finishCondition=false;
  while (!finishCondition) {
    List<BinarySolution> offspringPopulation=new ArrayList<>(populationSize);
    for (int i=0; i < population.size() / 2; i++) {
      List<BinarySolution> parents=new ArrayList<>(2);
      parents.add(parentSelection.execute(population));
      parents.add(parentSelection.execute(population));
      if (hammingDistance(parents.get(0),parents.get(1)) >= minimumDistance) {
        List<BinarySolution> offspring=crossover.execute(parents);
        problem.evaluate(offspring.get(0));
        problem.evaluate(offspring.get(1));
        offspringPopulation.add(offspring.get(0));
        offspringPopulation.add(offspring.get(1));
        evaluations+=2;
      }
    }
    List<BinarySolution> union=new ArrayList<>();
    union.addAll(population);
    union.addAll(offspringPopulation);
    List<BinarySolution> newPopulation=newGenerationSelection.execute(union);
    if (solutionSetsAreEquals(population,newPopulation)) {
      minimumDistance--;
    }
    if (minimumDistance <= -convergenceValue) {
      minimumDistance=(int)(1.0 / size * (1 - 1.0 / size) * size);
      int preserve=(int)Math.floor(preservedPopulation * population.size());
      newPopulation=new ArrayList<>(populationSize);
      Collections.sort(population,comparator);
      for (int i=0; i < preserve; i++) {
        newPopulation.add((BinarySolution)population.get(i).copy());
      }
      for (int i=preserve; i < populationSize; i++) {
        BinarySolution solution=(BinarySolution)population.get(i).copy();
        cataclysmicMutation.execute(solution);
        problem.evaluate(solution);
        newPopulation.add(solution);
        evaluations++;
      }
    }
    population=newPopulation;
    if (evaluations >= maxEvaluations) {
      finishCondition=true;
    }
  }
}","@Override public void run(){
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    size+=problem.getNumberOfBits(i);
  }
  minimumDistance=(int)Math.floor(this.initialConvergenceCount * size);
  comparator=new CrowdingDistanceComparator<BinarySolution>();
  evaluations=0;
  population=new ArrayList<>();
  for (int i=0; i < populationSize; i++) {
    BinarySolution newIndividual=problem.createSolution();
    problem.evaluate(newIndividual);
    population.add(newIndividual);
    evaluations++;
  }
  boolean finishCondition=false;
  while (!finishCondition) {
    List<BinarySolution> offspringPopulation=new ArrayList<>(populationSize);
    for (int i=0; i < population.size() / 2; i++) {
      List<BinarySolution> parents=new ArrayList<>(2);
      parents.add(parentSelection.execute(population));
      parents.add(parentSelection.execute(population));
      if (hammingDistance(parents.get(0),parents.get(1)) >= minimumDistance) {
        List<BinarySolution> offspring=crossover.execute(parents);
        problem.evaluate(offspring.get(0));
        problem.evaluate(offspring.get(1));
        offspringPopulation.add(offspring.get(0));
        offspringPopulation.add(offspring.get(1));
        evaluations+=2;
      }
    }
    List<BinarySolution> union=new ArrayList<>();
    union.addAll(population);
    union.addAll(offspringPopulation);
    List<BinarySolution> newPopulation=newGenerationSelection.execute(union);
    if (SolutionListUtils.solutionListsAreEquals(population,newPopulation)) {
      minimumDistance--;
    }
    if (minimumDistance <= -convergenceValue) {
      minimumDistance=(int)(1.0 / size * (1 - 1.0 / size) * size);
      int preserve=(int)Math.floor(preservedPopulation * population.size());
      newPopulation=new ArrayList<>(populationSize);
      Collections.sort(population,comparator);
      for (int i=0; i < preserve; i++) {
        newPopulation.add((BinarySolution)population.get(i).copy());
      }
      for (int i=preserve; i < populationSize; i++) {
        BinarySolution solution=(BinarySolution)population.get(i).copy();
        cataclysmicMutation.execute(solution);
        problem.evaluate(solution);
        newPopulation.add(solution);
        evaluations++;
      }
    }
    population=newPopulation;
    if (evaluations >= maxEvaluations) {
      finishCondition=true;
    }
  }
}",0.992112555958218
64544,"/** 
 * This method receives a normalized list of non-dominated solutions and return the inverted one. This operation is needed for minimization problem
 * @param solutionSet The front to invert
 * @return The inverted front
 */
public static <S extends Solution<?>>List<S> getInvertedFront(List<S> solutionSet){
  List<S> invertedFront=new ArrayList<>(solutionSet.size());
  int numberOfObjectives=solutionSet.get(0).getNumberOfObjectives();
  for (int i=0; i < solutionSet.size(); i++) {
    invertedFront.add(i,(S)solutionSet.get(i).copy());
    for (int j=0; j < numberOfObjectives; j++) {
      if (solutionSet.get(i).getObjective(j) <= 1.0 && solutionSet.get(i).getObjective(j) >= 0.0) {
        invertedFront.get(i).setObjective(j,1.0 - solutionSet.get(i).getObjective(j));
      }
 else       if (solutionSet.get(i).getObjective(j) > 1.0) {
        invertedFront.get(i).setObjective(j,0.0);
      }
 else       if (solutionSet.get(i).getObjective(j) < 0.0) {
        invertedFront.get(i).setObjective(j,1.0);
      }
    }
  }
  return invertedFront;
}","/** 
 * This method receives a normalized list of non-dominated solutions and return the inverted one. This operation is needed for minimization problem
 * @param solutionSet The front to invert
 * @return The inverted front
 */
@SuppressWarnings(""String_Node_Str"") public static <S extends Solution<?>>List<S> getInvertedFront(List<S> solutionSet){
  List<S> invertedFront=new ArrayList<>(solutionSet.size());
  int numberOfObjectives=solutionSet.get(0).getNumberOfObjectives();
  for (int i=0; i < solutionSet.size(); i++) {
    invertedFront.add(i,(S)solutionSet.get(i).copy());
    for (int j=0; j < numberOfObjectives; j++) {
      if (solutionSet.get(i).getObjective(j) <= 1.0 && solutionSet.get(i).getObjective(j) >= 0.0) {
        invertedFront.get(i).setObjective(j,1.0 - solutionSet.get(i).getObjective(j));
      }
 else       if (solutionSet.get(i).getObjective(j) > 1.0) {
        invertedFront.get(i).setObjective(j,0.0);
      }
 else       if (solutionSet.get(i).getObjective(j) < 0.0) {
        invertedFront.get(i).setObjective(j,1.0);
      }
    }
  }
  return invertedFront;
}",0.9828465461288828
64545,"private void printTableHeader(GenericIndicator<?> indicator,String rFileName,String latexFileName) throws IOException {
  FileWriter os=new FileWriter(rFileName,true);
  String caption=indicator.getName() + ""String_Node_Str"";
  for (  Problem<?> problem : configuration.getProblemList()) {
    caption+=problem.getName() + ""String_Node_Str"";
  }
  String latexTableLabel=""String_Node_Str"";
  String latexTabularAlignment=""String_Node_Str"";
  String latexTableFirstLine=""String_Node_Str"";
  String latexTableCaption=""String_Node_Str"";
  latexTableCaption=""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ indicator.getName()+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str"";
  latexTableLabel=""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ indicator.getName()+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str"";
  String output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ latexTableCaption+ ""String_Node_Str""+ latexTableLabel+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  os.close();
}","private void printTableHeader(GenericIndicator<?> indicator,String rFileName,String latexFileName) throws IOException {
  FileWriter os=new FileWriter(rFileName,true);
  String caption=indicator.getName() + ""String_Node_Str"";
  for (  Problem<?> problem : configuration.getProblemList()) {
    caption+=problem.getName() + ""String_Node_Str"";
  }
  String latexTableLabel=""String_Node_Str"";
  String latexTableCaption=""String_Node_Str"";
  latexTableCaption=""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ indicator.getName()+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str"";
  latexTableLabel=""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ indicator.getName()+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str"";
  String output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ latexTableCaption+ ""String_Node_Str""+ latexTableLabel+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  os.write(output + ""String_Node_Str"");
  os.close();
}",0.9733695652173912
64546,"public void prune(){
  Iterator<S> iterator=getSolutionList().iterator();
  boolean removed=false;
  while (iterator.hasNext()) {
    if (!removed) {
      S element=iterator.next();
      int location2=grid.location(element);
      if (location2 == grid.getMostPopulatedHypercube()) {
        iterator.remove();
        grid.removeSolution(location2);
      }
    }
  }
}","public void prune(){
  Iterator<S> iterator=getSolutionList().iterator();
  boolean removed=false;
  while (iterator.hasNext()) {
    if (!removed) {
      S element=iterator.next();
      int location=grid.location(element);
      if (location == grid.getMostPopulatedHypercube()) {
        iterator.remove();
        grid.removeSolution(location);
        removed=true;
      }
    }
  }
}",0.9646133682830932
64547,"@Override public void run() throws IOException {
  for (  GenericIndicator indicator : experiment.getIndicatorList()) {
    JMetalLogger.logger.info(""String_Node_Str"" + indicator.getName());
    ;
    for (    TaggedAlgorithm algorithm : experiment.getAlgorithmList()) {
      String algorithmDirectory;
      algorithmDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getTag();
      for (int problemId=0; problemId < experiment.getProblemList().size(); problemId++) {
        String problemDirectory=algorithmDirectory + ""String_Node_Str"" + experiment.getProblemList().get(problemId).getName();
        String referenceFrontDirectory=experiment.getReferenceFrontDirectory();
        String referenceFrontName=referenceFrontDirectory + ""String_Node_Str"" + experiment.getReferenceFrontFileNames().get(problemId);
        JMetalLogger.logger.info(""String_Node_Str"" + referenceFrontName);
        ;
        Front referenceFront=new ArrayFront(referenceFrontName);
        FrontNormalizer frontNormalizer=new FrontNormalizer(referenceFront);
        Front normalizedReferenceFront=frontNormalizer.normalize(referenceFront);
        String qualityIndicatorFile=problemDirectory + ""String_Node_Str"" + indicator.getName();
        resetFile(qualityIndicatorFile);
        indicator.setReferenceParetoFront(normalizedReferenceFront);
        for (int i=0; i < experiment.getIndependentRuns(); i++) {
          String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
          String variableFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoSetFileName()+ i+ ""String_Node_Str"";
          Front front=new ArrayFront(frontFileName);
          Front normalizedFront=frontNormalizer.normalize(front);
          List<DoubleSolution> normalizedPopulation=FrontUtils.convertFrontToSolutionList(normalizedFront);
          Double indicatorValue=(Double)indicator.evaluate(normalizedPopulation);
          JMetalLogger.logger.info(indicator.getName() + ""String_Node_Str"" + indicatorValue);
          writeQualityIndicatorValueToFile(indicatorValue,qualityIndicatorFile);
        }
        findBestIndicatorFronts(experiment);
      }
    }
  }
}","@Override public void run() throws IOException {
  for (  GenericIndicator indicator : experiment.getIndicatorList()) {
    JMetalLogger.logger.info(""String_Node_Str"" + indicator.getName());
    ;
    for (    TaggedAlgorithm algorithm : experiment.getAlgorithmList()) {
      String algorithmDirectory;
      algorithmDirectory=experiment.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithm.getTag();
      for (int problemId=0; problemId < experiment.getProblemList().size(); problemId++) {
        String problemDirectory=algorithmDirectory + ""String_Node_Str"" + experiment.getProblemList().get(problemId).getName();
        String referenceFrontDirectory=experiment.getReferenceFrontDirectory();
        String referenceFrontName=referenceFrontDirectory + ""String_Node_Str"" + experiment.getReferenceFrontFileNames().get(problemId);
        JMetalLogger.logger.info(""String_Node_Str"" + referenceFrontName);
        ;
        Front referenceFront=new ArrayFront(referenceFrontName);
        FrontNormalizer frontNormalizer=new FrontNormalizer(referenceFront);
        Front normalizedReferenceFront=frontNormalizer.normalize(referenceFront);
        String qualityIndicatorFile=problemDirectory + ""String_Node_Str"" + indicator.getName();
        resetFile(qualityIndicatorFile);
        indicator.setReferenceParetoFront(normalizedReferenceFront);
        for (int i=0; i < experiment.getIndependentRuns(); i++) {
          String frontFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoFrontFileName()+ i+ ""String_Node_Str"";
          String variableFileName=problemDirectory + ""String_Node_Str"" + experiment.getOutputParetoSetFileName()+ i+ ""String_Node_Str"";
          Front front=new ArrayFront(frontFileName);
          Front normalizedFront=frontNormalizer.normalize(front);
          List<DoubleSolution> normalizedPopulation=FrontUtils.convertFrontToSolutionList(normalizedFront);
          Double indicatorValue=(Double)indicator.evaluate(normalizedPopulation);
          JMetalLogger.logger.info(indicator.getName() + ""String_Node_Str"" + indicatorValue);
          writeQualityIndicatorValueToFile(indicatorValue,qualityIndicatorFile);
        }
      }
    }
  }
  findBestIndicatorFronts(experiment);
}",0.9933362949800087
64548,"private void printData(String latexFile,int indicatorIndex,double[][][] centralTendency,double[][][] dispersion,String caption) throws IOException {
  FileWriter os=new FileWriter(latexFile,true);
  os.write(""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + configuration.getIndicatorList().get(indicatorIndex).getName() + ""String_Node_Str""+ caption+ ""String_Node_Str""+ ""String_Node_Str"");
  os.write(""String_Node_Str"" + configuration.getIndicatorList().get(indicatorIndex).getName() + ""String_Node_Str""+ ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"");
  for (  TaggedAlgorithm algorithm : configuration.getAlgorithmList()) {
    os.write(""String_Node_Str"");
  }
  os.write(""String_Node_Str"");
  os.write(""String_Node_Str"");
  for (int i=-1; i < configuration.getAlgorithmList().size(); i++) {
    if (i == -1) {
      os.write(""String_Node_Str"");
    }
 else     if (i == (configuration.getAlgorithmList().size() - 1)) {
      os.write(""String_Node_Str"" + configuration.getAlgorithmList().get(i).getTag() + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      os.write(""String_Node_Str"" + configuration.getAlgorithmList().get(i).getTag() + ""String_Node_Str"");
    }
  }
  os.write(""String_Node_Str"");
  for (int i=0; i < configuration.getProblemList().size(); i++) {
    double bestCentralTendencyValue;
    double bestDispersionValue;
    double secondBestCentralTendencyValue;
    double secondBestDispersionValue;
    int bestIndex=-1;
    int secondBestIndex=-1;
    if (configuration.getIndicatorList().get(indicatorIndex).getName().equals(""String_Node_Str"")) {
      bestCentralTendencyValue=Double.MIN_VALUE;
      bestDispersionValue=Double.MIN_VALUE;
      secondBestCentralTendencyValue=Double.MIN_VALUE;
      secondBestDispersionValue=Double.MIN_VALUE;
      for (int j=0; j < (configuration.getAlgorithmList().size()); j++) {
        if ((centralTendency[indicatorIndex][i][j] > bestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == bestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < bestDispersionValue))) {
          secondBestIndex=bestIndex;
          secondBestCentralTendencyValue=bestCentralTendencyValue;
          secondBestDispersionValue=bestDispersionValue;
          bestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          bestDispersionValue=dispersion[indicatorIndex][i][j];
          bestIndex=j;
        }
 else         if ((centralTendency[indicatorIndex][i][j] > secondBestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == secondBestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < secondBestDispersionValue))) {
          secondBestIndex=j;
          secondBestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          secondBestDispersionValue=dispersion[indicatorIndex][i][j];
        }
      }
    }
 else {
      bestCentralTendencyValue=Double.MAX_VALUE;
      bestDispersionValue=Double.MAX_VALUE;
      secondBestCentralTendencyValue=Double.MAX_VALUE;
      secondBestDispersionValue=Double.MAX_VALUE;
      for (int j=0; j < (configuration.getAlgorithmList().size()); j++) {
        if ((centralTendency[indicatorIndex][i][j] < bestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == bestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < bestDispersionValue))) {
          secondBestIndex=bestIndex;
          secondBestCentralTendencyValue=bestCentralTendencyValue;
          secondBestDispersionValue=bestDispersionValue;
          bestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          bestDispersionValue=dispersion[indicatorIndex][i][j];
          bestIndex=j;
        }
 else         if ((centralTendency[indicatorIndex][i][j] < secondBestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == secondBestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < secondBestDispersionValue))) {
          secondBestIndex=j;
          secondBestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          secondBestDispersionValue=dispersion[indicatorIndex][i][j];
        }
      }
    }
    os.write(configuration.getProblemList().get(i).getName().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
    for (int j=0; j < (configuration.getAlgorithmList().size() - 1); j++) {
      if (j == bestIndex) {
        os.write(""String_Node_Str"");
      }
      if (j == secondBestIndex) {
        os.write(""String_Node_Str"");
      }
      String m=String.format(Locale.ENGLISH,""String_Node_Str"",centralTendency[indicatorIndex][i][j]);
      String s=String.format(Locale.ENGLISH,""String_Node_Str"",dispersion[indicatorIndex][i][j]);
      os.write(""String_Node_Str"" + m + ""String_Node_Str""+ s+ ""String_Node_Str"");
    }
    if (bestIndex == (configuration.getAlgorithmList().size() - 1)) {
      os.write(""String_Node_Str"");
    }
    String m=String.format(Locale.ENGLISH,""String_Node_Str"",centralTendency[indicatorIndex][i][configuration.getAlgorithmList().size() - 1]);
    String s=String.format(Locale.ENGLISH,""String_Node_Str"",dispersion[indicatorIndex][i][configuration.getAlgorithmList().size() - 1]);
    os.write(""String_Node_Str"" + m + ""String_Node_Str""+ s+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.close();
}","private void printData(String latexFile,int indicatorIndex,double[][][] centralTendency,double[][][] dispersion,String caption) throws IOException {
  FileWriter os=new FileWriter(latexFile,true);
  os.write(""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + configuration.getIndicatorList().get(indicatorIndex).getName() + ""String_Node_Str""+ caption+ ""String_Node_Str""+ ""String_Node_Str"");
  os.write(""String_Node_Str"" + configuration.getIndicatorList().get(indicatorIndex).getName() + ""String_Node_Str""+ ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"");
  for (  TaggedAlgorithm algorithm : configuration.getAlgorithmList()) {
    os.write(""String_Node_Str"");
  }
  os.write(""String_Node_Str"");
  os.write(""String_Node_Str"");
  for (int i=-1; i < configuration.getAlgorithmList().size(); i++) {
    if (i == -1) {
      os.write(""String_Node_Str"");
    }
 else     if (i == (configuration.getAlgorithmList().size() - 1)) {
      os.write(""String_Node_Str"" + configuration.getAlgorithmList().get(i).getTag() + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      os.write(""String_Node_Str"" + configuration.getAlgorithmList().get(i).getTag() + ""String_Node_Str"");
    }
  }
  os.write(""String_Node_Str"");
  for (int i=0; i < configuration.getProblemList().size(); i++) {
    double bestCentralTendencyValue;
    double bestDispersionValue;
    double secondBestCentralTendencyValue;
    double secondBestDispersionValue;
    int bestIndex=-1;
    int secondBestIndex=-1;
    if (configuration.getIndicatorList().get(indicatorIndex).isTheLowerTheIndicatorValueTheBetter()) {
      bestCentralTendencyValue=Double.MAX_VALUE;
      bestDispersionValue=Double.MAX_VALUE;
      secondBestCentralTendencyValue=Double.MAX_VALUE;
      secondBestDispersionValue=Double.MAX_VALUE;
      for (int j=0; j < (configuration.getAlgorithmList().size()); j++) {
        if ((centralTendency[indicatorIndex][i][j] < bestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == bestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < bestDispersionValue))) {
          secondBestIndex=bestIndex;
          secondBestCentralTendencyValue=bestCentralTendencyValue;
          secondBestDispersionValue=bestDispersionValue;
          bestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          bestDispersionValue=dispersion[indicatorIndex][i][j];
          bestIndex=j;
        }
 else         if ((centralTendency[indicatorIndex][i][j] < secondBestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == secondBestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < secondBestDispersionValue))) {
          secondBestIndex=j;
          secondBestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          secondBestDispersionValue=dispersion[indicatorIndex][i][j];
        }
      }
    }
 else {
      bestCentralTendencyValue=Double.MIN_VALUE;
      bestDispersionValue=Double.MIN_VALUE;
      secondBestCentralTendencyValue=Double.MIN_VALUE;
      secondBestDispersionValue=Double.MIN_VALUE;
      for (int j=0; j < (configuration.getAlgorithmList().size()); j++) {
        if ((centralTendency[indicatorIndex][i][j] > bestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == bestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < bestDispersionValue))) {
          secondBestIndex=bestIndex;
          secondBestCentralTendencyValue=bestCentralTendencyValue;
          secondBestDispersionValue=bestDispersionValue;
          bestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          bestDispersionValue=dispersion[indicatorIndex][i][j];
          bestIndex=j;
        }
 else         if ((centralTendency[indicatorIndex][i][j] > secondBestCentralTendencyValue) || ((centralTendency[indicatorIndex][i][j] == secondBestCentralTendencyValue) && (dispersion[indicatorIndex][i][j] < secondBestDispersionValue))) {
          secondBestIndex=j;
          secondBestCentralTendencyValue=centralTendency[indicatorIndex][i][j];
          secondBestDispersionValue=dispersion[indicatorIndex][i][j];
        }
      }
    }
    os.write(configuration.getProblemList().get(i).getName().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
    for (int j=0; j < (configuration.getAlgorithmList().size() - 1); j++) {
      if (j == bestIndex) {
        os.write(""String_Node_Str"");
      }
      if (j == secondBestIndex) {
        os.write(""String_Node_Str"");
      }
      String m=String.format(Locale.ENGLISH,""String_Node_Str"",centralTendency[indicatorIndex][i][j]);
      String s=String.format(Locale.ENGLISH,""String_Node_Str"",dispersion[indicatorIndex][i][j]);
      os.write(""String_Node_Str"" + m + ""String_Node_Str""+ s+ ""String_Node_Str"");
    }
    if (bestIndex == (configuration.getAlgorithmList().size() - 1)) {
      os.write(""String_Node_Str"");
    }
    String m=String.format(Locale.ENGLISH,""String_Node_Str"",centralTendency[indicatorIndex][i][configuration.getAlgorithmList().size() - 1]);
    String s=String.format(Locale.ENGLISH,""String_Node_Str"",dispersion[indicatorIndex][i][configuration.getAlgorithmList().size() - 1]);
    os.write(""String_Node_Str"" + m + ""String_Node_Str""+ s+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.write(""String_Node_Str"" + ""String_Node_Str"");
  os.close();
}",0.9901166414388746
64549,"private void printLines(GenericIndicator<?> indicator,String rFileName,String latexFileName) throws IOException {
  FileWriter os=new FileWriter(rFileName,true);
  String output;
  if (indicator.getName().equals(""String_Node_Str"")) {
    output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  os.write(output + ""String_Node_Str"");
  os.close();
}","private void printLines(GenericIndicator<?> indicator,String rFileName,String latexFileName) throws IOException {
  FileWriter os=new FileWriter(rFileName,true);
  String output;
  if (indicator.isTheLowerTheIndicatorValueTheBetter()) {
    output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    output=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + latexFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ latexFileName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  os.write(output + ""String_Node_Str"");
  os.close();
}",0.9880229126887692
64550,"public static void main(String[] args) throws IOException {
  if (args.length < 2) {
    new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  List<String> referenceFrontFileNames=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ExperimentConfiguration<DoubleSolution,List<DoubleSolution>> configuration=new ExperimentConfigurationBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setExperimentBaseDirectory(experimentBaseDirectory).setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setReferenceFrontDirectory(""String_Node_Str"").setReferenceFrontFileNames(referenceFrontFileNames).setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>())).setIndependentRuns(30).setNumberOfCores(8).build();
  new ExecuteAlgorithms<>(configuration).run();
  new ComputeQualityIndicators<>(configuration).run();
  new GenerateLatexTablesWithStatistics(configuration).run();
  new GenerateWilcoxonTestTablesWithR<>(configuration).run();
  new GenerateFriedmanTestTables<>(configuration).run();
  new GenerateBoxplots<>(configuration).setRows(3).setColumns(3).run();
}","public static void main(String[] args) throws IOException {
  if (args.length < 2) {
    new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  List<String> referenceFrontFileNames=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ExperimentConfiguration<DoubleSolution,List<DoubleSolution>> configuration=new ExperimentConfigurationBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setExperimentBaseDirectory(experimentBaseDirectory).setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setReferenceFrontDirectory(""String_Node_Str"").setReferenceFrontFileNames(referenceFrontFileNames).setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>())).setIndependentRuns(30).setNumberOfCores(8).build();
  new ExecuteAlgorithms<>(configuration).run();
  new ComputeQualityIndicators<>(configuration).run();
  new GenerateLatexTablesWithStatistics(configuration).run();
  new GenerateWilcoxonTestTablesWithR<>(configuration).run();
  new GenerateFriedmanTestTables<>(configuration).run();
  new GenerateBoxplotsWithR<>(configuration).setRows(3).setColumns(3).run();
}",0.9985460889793544
64551,"public static void main(String[] args) throws IOException {
  if (args.length < 2) {
    throw new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<String> referenceFrontFileNames=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  Experiment<DoubleSolution,List<DoubleSolution>> experiment=new ExperimentBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setReferenceFrontDirectory(""String_Node_Str"").setReferenceFrontFileNames(referenceFrontFileNames).setExperimentBaseDirectory(experimentBaseDirectory).setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>())).setIndependentRuns(20).setNumberOfCores(8).build();
  new ExecuteAlgorithms<>(experiment).run();
  new ComputeQualityIndicators<>(experiment).run();
  new GenerateLatexTablesWithStatistics(experiment).run();
  new GenerateWilcoxonTestTablesWithR<>(experiment).run();
  new GenerateFriedmanTestTables<>(experiment).run();
  new GenerateBoxplotsWithR<>(experiment).setRows(3).setColumns(3).setDisplayNotch().run();
}","public static void main(String[] args) throws IOException {
  if (args.length != 1) {
    throw new JMetalException(""String_Node_Str"");
  }
  String experimentBaseDirectory=args[0];
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<String> referenceFrontFileNames=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  Experiment<DoubleSolution,List<DoubleSolution>> experiment=new ExperimentBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setReferenceFrontDirectory(""String_Node_Str"").setReferenceFrontFileNames(referenceFrontFileNames).setExperimentBaseDirectory(experimentBaseDirectory).setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setIndicatorList(Arrays.asList(new Epsilon<DoubleSolution>(),new Spread<DoubleSolution>(),new GenerationalDistance<DoubleSolution>(),new PISAHypervolume<DoubleSolution>(),new InvertedGenerationalDistance<DoubleSolution>(),new InvertedGenerationalDistancePlus<DoubleSolution>())).setIndependentRuns(20).setNumberOfCores(8).build();
  new ExecuteAlgorithms<>(experiment).run();
  new ComputeQualityIndicators<>(experiment).run();
  new GenerateLatexTablesWithStatistics(experiment).run();
  new GenerateWilcoxonTestTablesWithR<>(experiment).run();
  new GenerateFriedmanTestTables<>(experiment).run();
  new GenerateBoxplotsWithR<>(experiment).setRows(3).setColumns(3).setDisplayNotch().run();
}",0.9979405707561048
64552,"/** 
 * Perform the crossover operation
 * @param probability Crossover setProbability
 * @param parent1     The first parent
 * @param parent2     The second parent
 * @return An array containing the two offspring
 * @throws org.uma.jmetal.util.JMetalException
 */
public List<BinarySolution> doCrossover(double probability,BinarySolution parent1,BinarySolution parent2) throws JMetalException {
  List<BinarySolution> offspring=new ArrayList<>();
  offspring.add((BinarySolution)parent1.copy());
  offspring.add((BinarySolution)parent2.copy());
  if (randomGenerator.nextDouble() < probability) {
    for (int var=0; var < parent1.getNumberOfVariables(); var++) {
      BitSet p1=parent1.getVariableValue(var);
      BitSet p2=parent1.getVariableValue(var);
      for (int bit=0; bit < parent1.getNumberOfBits(var); bit++) {
        if ((p1.get(bit) != p2.get(bit)) && (randomGenerator.nextDouble() < 0.5)) {
          offspring.get(0).getVariableValue(var).set(bit,p2.get(bit));
          offspring.get(1).getVariableValue(var).set(bit,p1.get(bit));
        }
      }
    }
  }
  return offspring;
}","/** 
 * Perform the crossover operation
 * @param probability Crossover setProbability
 * @param parent1     The first parent
 * @param parent2     The second parent
 * @return An array containing the two offspring
 * @throws org.uma.jmetal.util.JMetalException
 */
public List<BinarySolution> doCrossover(double probability,BinarySolution parent1,BinarySolution parent2) throws JMetalException {
  List<BinarySolution> offspring=new ArrayList<>();
  offspring.add((BinarySolution)parent1.copy());
  offspring.add((BinarySolution)parent2.copy());
  if (randomGenerator.nextDouble() < probability) {
    for (int var=0; var < parent1.getNumberOfVariables(); var++) {
      BinarySet p1=parent1.getVariableValue(var);
      BinarySet p2=parent2.getVariableValue(var);
      for (int bit=0; bit < p1.size(); bit++) {
        if (p1.get(bit) != p2.get(bit)) {
          if (randomGenerator.nextDouble() < 0.5) {
            offspring.get(0).getVariableValue(var).set(bit,p2.get(bit));
            offspring.get(1).getVariableValue(var).set(bit,p1.get(bit));
          }
        }
      }
    }
  }
  return offspring;
}",0.96617050067659
64553,"@Override public int getPopulationSize(){
  return getMaxPopulationSize();
}","public int getPopulationSize(){
  return getMaxPopulationSize();
}",0.9295774647887324
64554,"@Test public void shouldTheAlgorithmReturnANumberOfSolutionsWhenSolvingASimpleProblem() throws Exception {
  DTLZ1 problem=new DTLZ1();
  CrossoverOperator<DoubleSolution> crossover;
  MutationOperator<DoubleSolution> mutation;
  SelectionOperator<List<DoubleSolution>,DoubleSolution> selection;
  JMetalRandom randomGenerator=JMetalRandom.getInstance();
  randomGenerator.setSeed(1450278534242L);
  double crossoverProbability=0.9;
  double crossoverDistributionIndex=20.0;
  crossover=new SBXCrossover(crossoverProbability,crossoverDistributionIndex);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  selection=new BinaryTournamentSelection<DoubleSolution>(new RankingAndCrowdingDistanceComparator<DoubleSolution>());
  algorithm=new MOMBI2<>(problem,400,crossover,mutation,selection,new SequentialSolutionListEvaluator<DoubleSolution>(),""String_Node_Str"");
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=algorithm.getResult();
  assertTrue(population.size() >= 98);
  randomGenerator.setSeed(System.currentTimeMillis());
}","@Test public void shouldTheAlgorithmReturnANumberOfSolutionsWhenSolvingASimpleProblem() throws Exception {
  DTLZ1 problem=new DTLZ1();
  CrossoverOperator<DoubleSolution> crossover;
  MutationOperator<DoubleSolution> mutation;
  SelectionOperator<List<DoubleSolution>,DoubleSolution> selection;
  JMetalRandom randomGenerator=JMetalRandom.getInstance();
  randomGenerator.setSeed(1450278534242L);
  double crossoverProbability=0.9;
  double crossoverDistributionIndex=20.0;
  crossover=new SBXCrossover(crossoverProbability,crossoverDistributionIndex);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  selection=new BinaryTournamentSelection<DoubleSolution>(new RankingAndCrowdingDistanceComparator<DoubleSolution>());
  algorithm=new MOMBI2<>(problem,400,crossover,mutation,selection,new SequentialSolutionListEvaluator<DoubleSolution>(),""String_Node_Str"");
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=algorithm.getResult();
  assertTrue(population.size() >= 91);
  randomGenerator.setSeed(System.currentTimeMillis());
}",0.9991935483870968
64555,"public GAWASFGA(Problem<S> problem,int populationSize,int maxIterations,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator,SolutionListEvaluator<S> evaluator){
  super(problem,populationSize,maxIterations,crossoverOperator,mutationOperator,selectionOperator,evaluator,null);
  this.populationSize=populationSize;
  double[][] weights=WeightVector.initUniformWeights2D(0.005,this.populationSize);
  int halfVectorSize=weights.length / 2;
  int evenVectorsSize=(weights.length % 2 == 0) ? halfVectorSize : (halfVectorSize + 1);
  int oddVectorsSize=halfVectorSize;
  double[][] evenVectors=new double[evenVectorsSize][getProblem().getNumberOfObjectives()];
  double[][] oddVectors=new double[oddVectorsSize][getProblem().getNumberOfObjectives()];
  int index=0;
  for (int i=0; i < weights.length; i=i + 2)   evenVectors[index++]=weights[i];
  index=0;
  for (int i=1; i < weights.length; i=i + 2)   oddVectors[index++]=weights[i];
  this.achievementScalarizingNadir=createUtilityFunction(this.getNadirPoint(),evenVectors);
  this.achievementScalarizingUtopia=createUtilityFunction(this.getReferencePoint(),oddVectors);
}","public GAWASFGA(Problem<S> problem,int populationSize,int maxIterations,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator,SolutionListEvaluator<S> evaluator){
  super(problem,populationSize,maxIterations,crossoverOperator,mutationOperator,selectionOperator,evaluator,null);
  setMaxPopulationSize(populationSize);
  double[][] weights=WeightVector.initUniformWeights2D(0.005,getMaxPopulationSize());
  int halfVectorSize=weights.length / 2;
  int evenVectorsSize=(weights.length % 2 == 0) ? halfVectorSize : (halfVectorSize + 1);
  int oddVectorsSize=halfVectorSize;
  double[][] evenVectors=new double[evenVectorsSize][getProblem().getNumberOfObjectives()];
  double[][] oddVectors=new double[oddVectorsSize][getProblem().getNumberOfObjectives()];
  int index=0;
  for (int i=0; i < weights.length; i=i + 2)   evenVectors[index++]=weights[i];
  index=0;
  for (int i=1; i < weights.length; i=i + 2)   oddVectors[index++]=weights[i];
  this.achievementScalarizingNadir=createUtilityFunction(this.getNadirPoint(),evenVectors);
  this.achievementScalarizingUtopia=createUtilityFunction(this.getReferencePoint(),oddVectors);
}",0.9534981147884374
64556,"/** 
 * Constructor
 */
public SMSEMOA(Problem<S> problem,int maxEvaluations,int populationSize,double offset,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator){
  super(problem);
  this.maxEvaluations=maxEvaluations;
  this.populationSize=populationSize;
  this.offset=offset;
  this.crossoverOperator=crossoverOperator;
  this.mutationOperator=mutationOperator;
  this.selectionOperator=selectionOperator;
  hypervolume=new Hypervolume<>();
}","/** 
 * Constructor
 */
public SMSEMOA(Problem<S> problem,int maxEvaluations,int populationSize,double offset,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator){
  super(problem);
  this.maxEvaluations=maxEvaluations;
  setMaxPopulationSize(populationSize);
  this.offset=offset;
  this.crossoverOperator=crossoverOperator;
  this.mutationOperator=mutationOperator;
  this.selectionOperator=selectionOperator;
  hypervolume=new Hypervolume<>();
}",0.9845559845559846
64557,"@Override protected void initProgress(){
  evaluations=populationSize;
}","@Override protected void initProgress(){
  evaluations=getMaxPopulationSize();
}",0.9342105263157896
64558,"/** 
 * Constructor
 * @param problem Problem to solve
 */
public WASFGA(Problem<S> problem,int populationSize,int maxIterations,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator,SolutionListEvaluator<S> evaluator,List<Double> referencePoint){
  super(problem,maxIterations,crossoverOperator,mutationOperator,selectionOperator,evaluator);
  this.populationSize=populationSize;
  this.referencePoint=referencePoint;
  this.achievementScalarizingFunction=createUtilityFunction();
}","/** 
 * Constructor
 * @param problem Problem to solve
 */
public WASFGA(Problem<S> problem,int populationSize,int maxIterations,CrossoverOperator<S> crossoverOperator,MutationOperator<S> mutationOperator,SelectionOperator<List<S>,S> selectionOperator,SolutionListEvaluator<S> evaluator,List<Double> referencePoint){
  super(problem,maxIterations,crossoverOperator,mutationOperator,selectionOperator,evaluator);
  setMaxPopulationSize(populationSize);
  this.referencePoint=referencePoint;
  this.achievementScalarizingFunction=createUtilityFunction();
}",0.9855334538878844
64559,"@Override public int getPopulationSize(){
  return this.populationSize;
}","@Override public int getPopulationSize(){
  return getMaxPopulationSize();
}",0.912751677852349
64560,"public AbstractUtilityFunctionsSet<S> createUtilityFunction(){
  double[][] weights=WeightVector.initUniformWeights2D(0.005,this.populationSize);
  weights=WeightVector.invertWeights(weights,true);
  ASFWASFGA<S> aux=new ASFWASFGA<>(weights,referencePoint);
  return aux;
}","public AbstractUtilityFunctionsSet<S> createUtilityFunction(){
  double[][] weights=WeightVector.initUniformWeights2D(0.005,getMaxPopulationSize());
  weights=WeightVector.invertWeights(weights,true);
  ASFWASFGA<S> aux=new ASFWASFGA<>(weights,referencePoint);
  return aux;
}",0.9690346083788708
64561,"@Override public void run(){
  JMetalLogger.logger.info(""String_Node_Str"");
  prepareOutputDirectory();
  MultithreadedExperimentExecutor<S,Result> parallelExecutor;
  parallelExecutor=new MultithreadedExperimentExecutor<S,Result>(configuration.getNumberOfCores());
  parallelExecutor.start(this);
  for (  TaggedAlgorithm<Result> algorithm : configuration.getAlgorithmList()) {
    for (int i=0; i < configuration.getIndependentRuns(); i++) {
      parallelExecutor.addTask(new Object[]{algorithm,i,configuration});
    }
  }
  parallelExecutor.parallelExecution();
  parallelExecutor.stop();
}","@Override public void run(){
  JMetalLogger.logger.info(""String_Node_Str"");
  prepareOutputDirectory();
  MultithreadedExperimentExecutor<S,Result> parallelExecutor;
  parallelExecutor=new MultithreadedExperimentExecutor<S,Result>(configuration.getNumberOfCores());
  parallelExecutor.start(this);
  for (  TaggedAlgorithm<Result> algorithm : configuration.getAlgorithmList()) {
    parallelExecutor.addTask(new Object[]{algorithm,algorithm.getRunId(),configuration});
  }
  parallelExecutor.parallelExecution();
  parallelExecutor.stop();
}",0.8028169014084507
64562,"public Integer call() throws Exception {
  JMetalLogger.logger.info(""String_Node_Str"" + algorithm.getTag() + ""String_Node_Str""+ algorithm.getProblem().getName()+ ""String_Node_Str""+ id);
  algorithm.run();
  Result population=algorithm.getResult();
  new SolutionSetOutput((List<? extends Solution<?>>)population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(outputDirectoryName + ""String_Node_Str"" + id+ ""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(outputDirectoryName + ""String_Node_Str"" + id+ ""String_Node_Str"")).print();
  return id;
}","public Integer call() throws Exception {
  String funFile=outputDirectoryName + ""String_Node_Str"" + id+ ""String_Node_Str"";
  String varFile=outputDirectoryName + ""String_Node_Str"" + id+ ""String_Node_Str"";
  JMetalLogger.logger.info(""String_Node_Str"" + algorithm.getTag() + ""String_Node_Str""+ algorithm.getProblem().getName()+ ""String_Node_Str""+ id+ ""String_Node_Str""+ funFile);
  algorithm.run();
  Result population=algorithm.getResult();
  new SolutionSetOutput((List<? extends Solution<?>>)population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(varFile)).setFunFileOutputContext(new DefaultFileOutputContext(funFile)).print();
  return id;
}",0.6873065015479877
64563,"public Object parallelExecution(){
  List<Future<Object>> future=null;
  try {
    future=executor.invokeAll(taskList);
  }
 catch (  InterruptedException e1) {
    JMetalLogger.logger.log(Level.SEVERE,""String_Node_Str"",e1);
  }
  List<Object> resultList=new Vector<Object>();
  taskList=null;
  return null;
}","public Object parallelExecution(){
  List<Future<Object>> future=null;
  try {
    future=executor.invokeAll(taskList);
  }
 catch (  InterruptedException e1) {
    JMetalLogger.logger.log(Level.SEVERE,""String_Node_Str"",e1);
  }
  List<Integer> resultList=new Vector<Integer>();
  for (  Future<Object> result : future) {
    Object returnValue=null;
    try {
      returnValue=result.get();
      resultList.add((Integer)returnValue);
    }
 catch (    InterruptedException e) {
      JMetalLogger.logger.log(Level.SEVERE,""String_Node_Str"",e);
    }
catch (    ExecutionException e) {
      JMetalLogger.logger.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
  taskList=null;
  return null;
}",0.5990049751243781
64564,"public TaggedAlgorithm(Algorithm<Result> algorithm,String tag,Problem<?> problem){
  this.algorithm=algorithm;
  this.tag=tag;
  this.problem=problem;
}","public TaggedAlgorithm(Algorithm<Result> algorithm,String tag,Problem<?> problem,int runId){
  this.algorithm=algorithm;
  this.tag=tag;
  this.problem=problem;
  this.runId=runId;
}",0.9101796407185628
64565,"public void print(){
  printObjectivesToFile(funFileContext,solutionSet);
  printVariablesToFile(varFileContext,solutionSet);
}","public void print(){
  System.out.println(""String_Node_Str"" + funFileContext.getFileName());
  printObjectivesToFile(funFileContext,solutionSet);
  printVariablesToFile(varFileContext,solutionSet);
}",0.7791411042944786
64566,"static List<TaggedAlgorithm<List<DoubleSolution>>> configureAlgorithmList(List<Problem<DoubleSolution>> problemList){
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithms=new ArrayList<>();
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<>(problemList.get(i),new SBXCrossover(1.0,20.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).setMaxEvaluations(25000).setPopulationSize(100).build();
    algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,""String_Node_Str"",problemList.get(i)));
  }
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<>(problemList.get(i),new SBXCrossover(1.0,10.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).setMaxEvaluations(25000).setPopulationSize(100).build();
    algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,""String_Node_Str"",problemList.get(i)));
  }
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<>(problemList.get(i),new SBXCrossover(1.0,50.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).setMaxEvaluations(25000).setPopulationSize(100).build();
    algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,""String_Node_Str"",problemList.get(i)));
  }
  return algorithms;
}","static List<TaggedAlgorithm<List<DoubleSolution>>> configureAlgorithmList(List<Problem<DoubleSolution>> problemList){
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithms=new ArrayList<>();
  for (int run=0; run < 4; run++) {
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<>(problemList.get(i),new SBXCrossover(1.0,20.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).setMaxEvaluations(25000).setPopulationSize(100).build();
      algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,""String_Node_Str"",problemList.get(i),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<>(problemList.get(i),new SBXCrossover(1.0,10.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).setMaxEvaluations(25000).setPopulationSize(100).build();
      algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,""String_Node_Str"",problemList.get(i),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<>(problemList.get(i),new SBXCrossover(1.0,50.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).setMaxEvaluations(25000).setPopulationSize(100).build();
      algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,""String_Node_Str"",problemList.get(i),run));
    }
  }
  return algorithms;
}",0.9581363943281568
64567,"public static void main(String[] args){
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  ExperimentConfiguration<DoubleSolution,List<DoubleSolution>> configuration=new ExperimentConfigurationBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setExperimentBaseDirectory(""String_Node_Str"").setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setIndependentRuns(4).setNumberOfCores(4).build();
  AlgorithmExecution<DoubleSolution,List<DoubleSolution>> algorithmExecution=new AlgorithmExecution<DoubleSolution,List<DoubleSolution>>(configuration);
  ExperimentalStudy study=new ExperimentalStudy.Builder(configuration).addExperiment(algorithmExecution).build();
  study.run();
}","public static void main(String[] args){
  List<Problem<DoubleSolution>> problemList=Arrays.<Problem<DoubleSolution>>asList(new ZDT1(),new ZDT2(),new ZDT3(),new ZDT4(),new ZDT6());
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithmList=configureAlgorithmList(problemList);
  ExperimentConfiguration<DoubleSolution,List<DoubleSolution>> configuration=new ExperimentConfigurationBuilder<DoubleSolution,List<DoubleSolution>>(""String_Node_Str"").setAlgorithmList(algorithmList).setProblemList(problemList).setExperimentBaseDirectory(""String_Node_Str"").setOutputParetoFrontFileName(""String_Node_Str"").setOutputParetoSetFileName(""String_Node_Str"").setIndependentRuns(2).setNumberOfCores(8).build();
  AlgorithmExecution<DoubleSolution,List<DoubleSolution>> algorithmExecution=new AlgorithmExecution<DoubleSolution,List<DoubleSolution>>(configuration);
  ExperimentalStudy study=new ExperimentalStudy.Builder(configuration).addExperiment(algorithmExecution).build();
  study.run();
}",0.9979570990806946
64568,"static List<TaggedAlgorithm<List<DoubleSolution>>> configureAlgorithmList(List<Problem<DoubleSolution>> problemList){
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithms=new ArrayList<>();
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<DoubleSolution>(problemList.get(i),new SBXCrossover(1.0,20.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).build();
    algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,problemList.get(i)));
  }
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<DoubleSolution>> algorithm=new SPEA2Builder<DoubleSolution>(problemList.get(i),new SBXCrossover(1.0,10.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).build();
    algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,problemList.get(i)));
  }
  for (int i=0; i < problemList.size(); i++) {
    Algorithm<List<DoubleSolution>> algorithm=new SMPSOBuilder((DoubleProblem)problemList.get(i),new CrowdingDistanceArchive<DoubleSolution>(100)).build();
    algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,problemList.get(i)));
  }
  return algorithms;
}","static List<TaggedAlgorithm<List<DoubleSolution>>> configureAlgorithmList(List<Problem<DoubleSolution>> problemList){
  List<TaggedAlgorithm<List<DoubleSolution>>> algorithms=new ArrayList<>();
  for (int run=0; run < 4; run++) {
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<DoubleSolution>> algorithm=new NSGAIIBuilder<DoubleSolution>(problemList.get(i),new SBXCrossover(1.0,20.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).build();
      algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,problemList.get(i),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<DoubleSolution>> algorithm=new SPEA2Builder<DoubleSolution>(problemList.get(i),new SBXCrossover(1.0,10.0),new PolynomialMutation(1.0 / problemList.get(i).getNumberOfVariables(),20.0)).build();
      algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,problemList.get(i),run));
    }
    for (int i=0; i < problemList.size(); i++) {
      Algorithm<List<DoubleSolution>> algorithm=new SMPSOBuilder((DoubleProblem)problemList.get(i),new CrowdingDistanceArchive<DoubleSolution>(100)).build();
      algorithms.add(new TaggedAlgorithm<List<DoubleSolution>>(algorithm,problemList.get(i),run));
    }
  }
  return algorithms;
}",0.925019731649566
64569,"/** 
 * Run method
 */
@Override public void run(){
  population=createInitialPopulation();
  evaluatePopulation(population);
  evaluations=populationSize;
  while (evaluations < maxEvaluations) {
    List<S> offspringPopulation=new ArrayList<>(populationSize);
    for (int i=0; i < populationSize; i+=2) {
      List<S> parents=new ArrayList<>(2);
      parents.add(selectionOperator.execute(population));
      parents.add(selectionOperator.execute(population));
      List<S> offspring=crossoverOperator.execute(parents);
      mutationOperator.execute(offspring.get(0));
      mutationOperator.execute(offspring.get(1));
      offspringPopulation.add(offspring.get(0));
      offspringPopulation.add(offspring.get(1));
    }
    List<S> jointPopulation=new ArrayList<>();
    jointPopulation.addAll(population);
    jointPopulation.addAll(offspringPopulation);
    Ranking<S> ranking=computeRanking(jointPopulation);
    population=crowdingDistanceSelection(ranking);
    evaluations+=populationSize;
  }
}","/** 
 * Run method
 */
@Override public void run(){
  population=createInitialPopulation();
  evaluatePopulation(population);
  evaluations=populationSize;
  while (evaluations < maxEvaluations) {
    List<S> offspringPopulation=new ArrayList<>(populationSize);
    for (int i=0; i < populationSize; i+=2) {
      List<S> parents=new ArrayList<>(2);
      parents.add(selectionOperator.execute(population));
      parents.add(selectionOperator.execute(population));
      List<S> offspring=crossoverOperator.execute(parents);
      mutationOperator.execute(offspring.get(0));
      mutationOperator.execute(offspring.get(1));
      offspringPopulation.add(offspring.get(0));
      offspringPopulation.add(offspring.get(1));
    }
    evaluatePopulation(offspringPopulation);
    List<S> jointPopulation=new ArrayList<>();
    jointPopulation.addAll(population);
    jointPopulation.addAll(offspringPopulation);
    Ranking<S> ranking=computeRanking(jointPopulation);
    population=crowdingDistanceSelection(ranking);
    evaluations+=populationSize;
  }
}",0.9782293178519592
64570,"@Override public void run(){
  swarm=createInitialSwarm();
  evaluateSwarm(swarm);
  initializeVelocity(getSwarm());
  initUniformWeight();
  initIdealPoint();
  initializeLeaders(getSwarm());
  initializeParticlesMemory(getSwarm());
  updateGlobalBest();
  initProgress();
  while (!isStoppingConditionReached()) {
    System.out.println(""String_Node_Str"" + iterations);
    shuffleGlobalBest();
    for (int i=0; i < getSwarm().size(); i++) {
      if (age[i] < maxAge) {
        updateVelocity(i);
      }
 else {
        resetParticle(i);
      }
      repairBounds(i);
      problem.evaluate(swarm.get(i));
      updateReference(swarm.get(i));
      updateLocalBest(i);
    }
    updateGlobalBest();
    updateProgress();
  }
}","@Override public void run(){
  swarm=createInitialSwarm();
  evaluateSwarm(swarm);
  initializeVelocity(getSwarm());
  initUniformWeight();
  initIdealPoint();
  initializeLeaders(getSwarm());
  initializeParticlesMemory(getSwarm());
  updateGlobalBest();
  initProgress();
  while (!isStoppingConditionReached()) {
    System.out.println(""String_Node_Str"" + iterations);
    shuffleGlobalBest();
    for (int i=0; i < getSwarm().size(); i++) {
      if (age[i] < maxAge) {
        updateVelocity(i);
        computeNewPositions(i);
      }
 else {
        resetParticle(i);
      }
      repairBounds(i);
      problem.evaluate(swarm.get(i));
      updateReference(swarm.get(i));
      updateLocalBest(i);
    }
    updateGlobalBest();
    updateProgress();
  }
}",0.9786096256684492
64571,"@Override public List<DoubleSolution> getResult(){
  return this.leaderArchive.getSolutionList();
}","@Override public List<DoubleSolution> getResult(){
  return this.epsilonArchive.getSolutionList();
}",0.9447236180904522
64572,"private int dominanceTest(Solution<?> solution1,Solution<?> solution2){
  int result;
  boolean solution1Dominates=false;
  boolean solution2Dominates=false;
  int flag;
  double value1, value2;
  for (int i=0; i < solution1.getNumberOfObjectives(); i++) {
    value1=solution1.getObjective(i);
    value2=solution2.getObjective(i);
    if (value1 / (1 + epsilon) < value2) {
      flag=-1;
    }
 else     if (value1 / (1 + epsilon) > value2) {
      flag=1;
    }
 else {
      flag=0;
    }
    if (flag == -1) {
      solution1Dominates=true;
    }
    if (flag == 1) {
      solution2Dominates=true;
    }
  }
  if (solution1Dominates == solution2Dominates) {
    result=0;
  }
 else   if (solution1Dominates) {
    result=-1;
  }
 else {
    result=1;
  }
  return result;
}","private int dominanceTest(Solution<?> solution1,Solution<?> solution2){
  int result;
  boolean solution1Dominates=false;
  boolean solution2Dominates=false;
  int flag;
  double value1, value2;
  for (int i=0; i < solution1.getNumberOfObjectives(); i++) {
    value1=solution1.getObjective(i);
    value2=solution2.getObjective(i);
    if (value1 / (1 + epsilon) < value2) {
      flag=-1;
    }
 else     if (value2 / (1 + epsilon) < value1) {
      flag=1;
    }
 else {
      flag=0;
    }
    if (flag == -1) {
      solution1Dominates=true;
    }
    if (flag == 1) {
      solution2Dominates=true;
    }
  }
  if (solution1Dominates == solution2Dominates) {
    result=0;
  }
 else   if (solution1Dominates) {
    result=-1;
  }
 else {
    result=1;
  }
  return result;
}",0.9884615384615384
64573,"protected void updatePosition(List<List<DoubleSolution>> swarm){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).updatePosition(swarm.get(i));
  }
}","protected void updatePosition(List<List<DoubleSolution>> swarmList){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).updatePosition(swarmList.get(i));
  }
}",0.976470588235294
64574,"protected void updateParticlesMemory(List<List<DoubleSolution>> swarm){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).updateParticlesMemory(swarm.get(i));
  }
}","protected void updateParticlesMemory(List<List<DoubleSolution>> swarmList){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).updateParticlesMemory(swarmList.get(i));
  }
}",0.9782608695652174
64575,"protected void perturbation(List<List<DoubleSolution>> swarm){
}","protected void perturbation(List<List<DoubleSolution>> swarmList){
}",0.9696969696969696
64576,"protected void initializeVelocity(List<List<DoubleSolution>> swarm){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).initializeVelocity(swarm.get(i));
  }
}","protected void initializeVelocity(List<List<DoubleSolution>> swarmList){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).initializeVelocity(swarmList.get(i));
  }
}",0.9775280898876404
64577,"protected void updateVelocity(List<List<DoubleSolution>> swarm){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).updateVelocity(swarm.get(i));
  }
}","protected void updateVelocity(List<List<DoubleSolution>> swarmList){
  updateSwarmVelocity(swarmList);
}",0.6814814814814815
64578,"protected void updateLeaders(List<List<DoubleSolution>> swarm){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).updateLeaders(swarm.get(i));
  }
}","protected void updateLeaders(List<List<DoubleSolution>> swarmList){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).updateLeaders(swarmList.get(i));
  }
}",0.9761904761904762
64579,"public Vepso(DoubleProblem problem,int swarmSize,int maxIterations,int numberOfParticlesToInform,Archive<DoubleSolution> archive){
  this.problem=problem;
  this.swarmSize=swarmSize;
  this.maxIterations=maxIterations;
  this.numberOfParticlesToInform=numberOfParticlesToInform;
  this.archive=archive;
  psoIsland=new ArrayList<StandardPSO2007>();
  for (int i=0; i < problem.getNumberOfObjectives(); i++) {
    psoIsland.add(new StandardPSO2007(problem,i,swarmSize,maxIterations,numberOfParticlesToInform,new SequentialSolutionListEvaluator<DoubleSolution>()));
  }
}","public Vepso(DoubleProblem problem,int swarmSize,int maxIterations,int numberOfParticlesToInform,Archive<DoubleSolution> archive){
  this.problem=problem;
  this.swarmSize=swarmSize;
  this.maxIterations=maxIterations;
  this.numberOfParticlesToInform=numberOfParticlesToInform;
  this.archive=archive;
  weight=1.0 / (2.0 * Math.log(2));
  c=1.0 / 2.0 + Math.log(2);
  speed=new GenericSolutionAttribute<DoubleSolution,double[]>();
  localBest=new LocalBestAttribute();
  neighborhoodBest=new NeighborhoodBestAttribute();
  psoIsland=new ArrayList<StandardPSO2007>();
  for (int i=0; i < problem.getNumberOfObjectives(); i++) {
    psoIsland.add(new StandardPSO2007(problem,i,swarmSize,maxIterations / problem.getNumberOfObjectives(),numberOfParticlesToInform,new SequentialSolutionListEvaluator<DoubleSolution>()));
  }
}",0.8175287356321839
64580,"protected void initializeLeaders(List<List<DoubleSolution>> swarm){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).initializeLeaders(swarm.get(i));
  }
}","protected void initializeLeaders(List<List<DoubleSolution>> swarmList){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).initializeLeaders(swarmList.get(i));
  }
}",0.9772727272727272
64581,"protected List<List<DoubleSolution>> evaluateSwarm(List<List<DoubleSolution>> swarm){
  List<List<DoubleSolution>> swarms=new ArrayList<>(problem.getNumberOfObjectives());
  for (int i=0; i < psoIsland.size(); i++) {
    swarms.add(i,psoIsland.get(i).evaluateSwarm(swarm.get(i)));
    updateArchive(swarm.get(i));
  }
  return swarms;
}","protected List<List<DoubleSolution>> evaluateSwarm(List<List<DoubleSolution>> swarmList){
  List<List<DoubleSolution>> swarms=new ArrayList<>(problem.getNumberOfObjectives());
  for (int i=0; i < psoIsland.size(); i++) {
    swarms.add(i,psoIsland.get(i).evaluateSwarm(swarmList.get(i)));
    updateArchive(swarmList.get(i));
  }
  return swarms;
}",0.9824561403508772
64582,"protected void initializeParticlesMemory(List<List<DoubleSolution>> swarm){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).initializeParticlesMemory(swarm.get(i));
    psoIsland.get(i).setSwarm(swarm.get(i));
  }
}","protected void initializeParticlesMemory(List<List<DoubleSolution>> swarmList){
  for (int i=0; i < psoIsland.size(); i++) {
    psoIsland.get(i).initializeParticlesMemory(swarmList.get(i));
    psoIsland.get(i).setSwarm(swarmList.get(i));
  }
}",0.9748953974895398
64583,"/** 
 * Constructor
 * @param solutionListSize The expected size of the list of solutions
 * @param numberOfRandomNeighbours The number of neighbors per solution
 */
public AdaptiveRandomNeighborhood(int solutionListSize,int numberOfRandomNeighbours){
  if (numberOfRandomNeighbours < 0) {
    throw new JMetalException(""String_Node_Str"" + numberOfRandomNeighbours);
  }
 else   if (solutionListSize <= numberOfRandomNeighbours) {
    throw new JMetalException(""String_Node_Str"" + solutionListSize + ""String_Node_Str""+ ""String_Node_Str""+ numberOfRandomNeighbours);
  }
  this.solutionListSize=solutionListSize;
  this.numberOfRandomNeighbours=numberOfRandomNeighbours;
  createNeighborhoods();
  addRandomNeighbors();
}","/** 
 * Constructor
 * @param solutionListSize The expected size of the list of solutions
 * @param numberOfRandomNeighbours The number of neighbors per solution
 */
public AdaptiveRandomNeighborhood(int solutionListSize,int numberOfRandomNeighbours){
  if (numberOfRandomNeighbours < 0) {
    throw new JMetalException(""String_Node_Str"" + numberOfRandomNeighbours);
  }
 else   if (solutionListSize <= numberOfRandomNeighbours) {
    throw new JMetalException(""String_Node_Str"" + solutionListSize + ""String_Node_Str""+ ""String_Node_Str""+ numberOfRandomNeighbours);
  }
  this.solutionListSize=solutionListSize;
  this.numberOfRandomNeighbours=numberOfRandomNeighbours;
  this.randomGenerator=JMetalRandom.getInstance();
  createNeighborhoods();
  addRandomNeighbors();
}",0.9187374076561452
64584,"/** 
 * Case 1 Solution list size: 4 Number of neighbors: 3
 */
@Test public void shouldGetNeighborsReturnThreeNeighborsPlusTheCurrentSolution(){
  int solutionListSize=3;
  int numberOfNeighbors=1;
  AdaptiveRandomNeighborhood<IntegerSolution> neighborhood=new AdaptiveRandomNeighborhood<IntegerSolution>(solutionListSize,numberOfNeighbors);
  JMetalRandom randomGenerator=mock(JMetalRandom.class);
  when(randomGenerator.nextInt(0,solutionListSize - 1)).thenReturn(2,0,1);
  ReflectionTestUtils.setField(neighborhood,""String_Node_Str"",randomGenerator);
  List<IntegerSolution> list=new ArrayList<>(solutionListSize);
  for (int i=0; i < solutionListSize; i++) {
    list.add(mock(IntegerSolution.class));
  }
  List<IntegerSolution> result=neighborhood.getNeighbors(list,0);
  assertEquals(numberOfNeighbors + 1,result.size());
  assertEquals(list.get(0),result.get(0));
  ;
  assertEquals(list.get(2),result.get(1));
  ;
}","/** 
 * Case 1 Solution list size: 3 Number of neighbors: 1 Neighbors: - solution 0: 0, 2 - solution 1: 1, 0 - solution 2: 2, 0
 */
@Test public void shouldGetNeighborsReturnThreeNeighborsPlusTheCurrentSolution(){
  int solutionListSize=3;
  int numberOfNeighbors=1;
  AdaptiveRandomNeighborhood<IntegerSolution> neighborhood=new AdaptiveRandomNeighborhood<IntegerSolution>(solutionListSize,numberOfNeighbors);
  JMetalRandom randomGenerator=mock(JMetalRandom.class);
  when(randomGenerator.nextInt(0,solutionListSize - 1)).thenReturn(2,0,0);
  ReflectionTestUtils.setField(neighborhood,""String_Node_Str"",randomGenerator);
  List<IntegerSolution> list=new ArrayList<>(solutionListSize);
  for (int i=0; i < solutionListSize; i++) {
    list.add(mock(IntegerSolution.class));
  }
  neighborhood.recompute();
  List<IntegerSolution> result;
  result=neighborhood.getNeighbors(list,0);
  assertEquals(numberOfNeighbors + 1,result.size());
  assertEquals(list.get(0),result.get(0));
  assertEquals(list.get(2),result.get(1));
  result=neighborhood.getNeighbors(list,1);
  assertEquals(numberOfNeighbors + 1,result.size());
  assertEquals(list.get(1),result.get(0));
  assertEquals(list.get(0),result.get(1));
  result=neighborhood.getNeighbors(list,2);
  assertEquals(numberOfNeighbors + 1,result.size());
  assertEquals(list.get(2),result.get(0));
  assertEquals(list.get(0),result.get(1));
}",0.7934312878133103
64585,"/** 
 * Calculate distance of the reference point to the point of the front point according to Pareto dominance
 * @param point
 * @param referencePoint
 * @return
 */
private double calculateDistance(Point point,Point referencePoint){
  double result=0.0;
  for (int i=0; i < point.getNumberOfDimensions(); i++) {
    double value=referencePoint.getDimensionValue(i) - point.getDimensionValue(i);
    if (value > 0.0) {
      result+=value;
    }
  }
  return Math.sqrt(result);
}","/** 
 * Calculate distance of the reference point to the point of the front point according to Pareto dominance
 * @param point
 * @param referencePoint
 * @return
 */
private double calculateDistance(Point point,Point referencePoint){
  double result=0.0;
  for (int i=0; i < point.getNumberOfDimensions(); i++) {
    double value=referencePoint.getDimensionValue(i) - point.getDimensionValue(i);
    if (value > 0.0) {
      result+=Math.pow(value,2.0);
    }
  }
  return Math.sqrt(result);
}",0.985655737704918
64586,"@Override public ABYSS build(){
  return new ABYSS(problem,populationSize,refSet1Size,refSet2Size,archiveSize,maxEvaluations,archive,improvementOperator,crossoverOperator,numberOfSubranges);
}","@Override public ABYSS build(){
  return new ABYSS(problem,maxEvaluations,populationSize,refSet1Size,refSet2Size,archiveSize,archive,improvementOperator,crossoverOperator,numberOfSubranges);
}",0.921875
64587,"@Override public void restart(){
  getPopulation().clear();
  addReferenceSet1ToPopulation();
  updatePopulationWithArchive();
  fillPopulationWithRandomSolutions();
}","@Override public void restart(){
  System.out.println(""String_Node_Str"");
  getPopulation().clear();
  addReferenceSet1ToPopulation();
  updatePopulationWithArchive();
  fillPopulationWithRandomSolutions();
}",0.8906666666666667
64588,"/** 
 * @return
 */
@Override public List<List<DoubleSolution>> subsetGeneration(){
  List<List<DoubleSolution>> solutionGroupsList;
  solutionGroupsList=generatePairsFromSolutionList(referenceSet1);
  solutionGroupsList.addAll(generatePairsFromSolutionList(referenceSet2));
  for (  List<DoubleSolution> pair : solutionGroupsList) {
    marked.setAttribute(pair.get(0),true);
    marked.setAttribute(pair.get(1),true);
  }
  return solutionGroupsList;
}","/** 
 * @return
 */
@Override public List<List<DoubleSolution>> subsetGeneration(){
  List<List<DoubleSolution>> solutionGroupsList;
  solutionGroupsList=generatePairsFromSolutionList(referenceSet1);
  System.out.println(""String_Node_Str"" + solutionGroupsList.size());
  solutionGroupsList.addAll(generatePairsFromSolutionList(referenceSet2));
  System.out.println(""String_Node_Str"" + solutionGroupsList.size());
  for (  List<DoubleSolution> pair : solutionGroupsList) {
  }
  return solutionGroupsList;
}",0.70625
64589,"/** 
 * Generate all pair combinations of the referenceSet1
 */
public List<List<DoubleSolution>> generatePairsFromSolutionList(List<DoubleSolution> solutionList){
  List<List<DoubleSolution>> subset=new ArrayList<>();
  for (int i=0; i < solutionList.size(); i++) {
    DoubleSolution solution1=solutionList.get(i);
    for (int j=i + 1; j < solutionList.size(); j++) {
      DoubleSolution solution2=solutionList.get(j);
      List<DoubleSolution> pair=new ArrayList<>(2);
      pair.add(solution1);
      pair.add(solution2);
      subset.add(pair);
    }
  }
  return subset;
}","/** 
 * Generate all pair combinations of the referenceSet1
 */
public List<List<DoubleSolution>> generatePairsFromSolutionList(List<DoubleSolution> solutionList){
  List<List<DoubleSolution>> subset=new ArrayList<>();
  for (int i=0; i < solutionList.size(); i++) {
    DoubleSolution solution1=solutionList.get(i);
    for (int j=i + 1; j < solutionList.size(); j++) {
      DoubleSolution solution2=solutionList.get(j);
      if (!marked.getAttribute(solution1) || !marked.getAttribute(solution2)) {
        List<DoubleSolution> pair=new ArrayList<>(2);
        pair.add(solution1);
        pair.add(solution2);
        subset.add(pair);
        marked.setAttribute(solutionList.get(i),true);
        marked.setAttribute(solutionList.get(j),true);
      }
    }
  }
  return subset;
}",0.827485380116959
64590,"@Override public boolean restartConditionIsFulfilled(){
  boolean allTheSolutionsAreMarked=true;
  int i=0;
  while ((i < referenceSet1.size()) && allTheSolutionsAreMarked) {
    if (marked.getAttribute(referenceSet1.get(i))) {
      i++;
    }
 else {
      allTheSolutionsAreMarked=false;
    }
  }
  i=0;
  while ((i < referenceSet2.size()) && allTheSolutionsAreMarked) {
    if (marked.getAttribute(referenceSet2.get(i))) {
      i++;
    }
 else {
      allTheSolutionsAreMarked=false;
    }
  }
  return allTheSolutionsAreMarked;
}","@Override public boolean restartConditionIsFulfilled(List<DoubleSolution> combinedSolutions){
  if (combinedSolutions.isEmpty()) {
    return true;
  }
 else {
    return false;
  }
}",0.3694444444444444
64591,"@Override public List<DoubleSolution> solutionCombination(List<List<DoubleSolution>> solutionList){
  List<DoubleSolution> resultList=new ArrayList<>();
  for (  List<DoubleSolution> pair : solutionList) {
    List<DoubleSolution> offspring=(List<DoubleSolution>)crossover.execute(pair);
    if (problem instanceof ConstrainedProblem) {
      ((ConstrainedProblem)problem).evaluateConstraints(offspring.get(0));
      ((ConstrainedProblem)problem).evaluateConstraints(offspring.get(1));
    }
    problem.evaluate(offspring.get(0));
    problem.evaluate(offspring.get(1));
    evaluations+=2;
    resultList.add(offspring.get(0));
    resultList.add(offspring.get(1));
  }
  return resultList;
}","@Override public List<DoubleSolution> solutionCombination(List<List<DoubleSolution>> solutionList){
  List<DoubleSolution> resultList=new ArrayList<>();
  for (  List<DoubleSolution> pair : solutionList) {
    List<DoubleSolution> offspring=(List<DoubleSolution>)crossover.execute(pair);
    if (problem instanceof ConstrainedProblem) {
      ((ConstrainedProblem)problem).evaluateConstraints(offspring.get(0));
      ((ConstrainedProblem)problem).evaluateConstraints(offspring.get(1));
    }
    problem.evaluate(offspring.get(0));
    problem.evaluate(offspring.get(1));
    evaluations+=2;
    resultList.add(offspring.get(0));
    resultList.add(offspring.get(1));
  }
  System.out.println(""String_Node_Str"" + resultList.size());
  return resultList;
}",0.957960027567195
64592,"@Override public void referenceSetUpdate(DoubleSolution solution){
  if (refSet1Test(solution)) {
    for (int indSet2=0; indSet2 < referenceSet2.size(); indSet2++) {
      double aux=SolutionUtils.distanceBetweenSolutions(solution,referenceSet2.get(indSet2));
      DoubleSolution auxSolution=referenceSet2.get(indSet2);
      if (aux < distanceToSolutionListAttribute.getAttribute(auxSolution)) {
        distanceToSolutionListAttribute.setAttribute(auxSolution,aux);
      }
    }
  }
 else {
    refSet2Test(solution);
  }
}","/** 
 * Update the reference set with a new solution
 * @param solution
 */
@Override public void referenceSetUpdate(DoubleSolution solution){
  if (refSet1Test(solution)) {
    for (int indSet2=0; indSet2 < referenceSet2.size(); indSet2++) {
      double aux=SolutionUtils.distanceBetweenSolutions(solution,referenceSet2.get(indSet2));
      DoubleSolution auxSolution=referenceSet2.get(indSet2);
      if (aux < distanceToSolutionListAttribute.getAttribute(auxSolution)) {
        distanceToSolutionListAttribute.setAttribute(auxSolution,aux);
      }
    }
  }
 else {
    refSet2Test(solution);
  }
}",0.9328621908127208
64593,"/** 
 * Runs of the AbYSS algorithm. as a result of the algorithm execution
 */
@Override public void run(){
  try {
    DoubleSolution solution;
    initialListSolution();
    int newSolutions=0;
    boolean exit=false;
    while ((evaluations < maxEvaluations) && !exit) {
      referenceSetUpdate(true);
      newSolutions=subSetGeneration();
      while ((newSolutions > 0) && !exit) {
        referenceSetUpdate(false);
        if (evaluations >= maxEvaluations) {
          exit=true;
        }
        if (!exit) {
          newSolutions=subSetGeneration();
        }
      }
      if (evaluations < maxEvaluations) {
        solutionSet.clear();
        for (int i=0; i < refSet1.size(); i++) {
          solution=refSet1.get(i);
          marked.setAttribute(solution,false);
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          solutionSet.add(solution);
        }
        refSet1.clear();
        refSet2.clear();
        archive.computeDistance();
        Collections.sort(archive.getSolutionList(),crowdingDistanceComparator);
        int insert=solutionSetSize / 2;
        if (insert > archive.getSolutionList().size())         insert=archive.getSolutionList().size();
        if (insert > (solutionSetSize - solutionSet.size()))         insert=solutionSetSize - solutionSet.size();
        for (int i=0; i < insert; i++) {
          solution=(DoubleSolution)archive.getSolutionList().get(i).copy();
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
        while (solutionSet.size() < solutionSetSize) {
          solution=diversificationGeneration();
          if (problem instanceof ConstrainedProblem) {
            ((ConstrainedProblem)problem).evaluateConstraints(solution);
          }
          problem.evaluate(solution);
          evaluations++;
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Runs of the AbYSS algorithm. as a result of the algorithm execution
 */
@Override public void run(){
  try {
    DoubleSolution solution;
    initialListSolution();
    int newSolutions=0;
    boolean exit=false;
    while ((evaluations < maxEvaluations) && !exit) {
      referenceSetUpdate(true);
      newSolutions=subSetGeneration();
      while ((newSolutions > 0) && !exit) {
        referenceSetUpdate(false);
        if (evaluations >= maxEvaluations) {
          exit=true;
        }
        if (!exit) {
          newSolutions=subSetGeneration();
        }
      }
      if (evaluations < maxEvaluations) {
        System.out.println(""String_Node_Str"");
        solutionSet.clear();
        for (int i=0; i < refSet1.size(); i++) {
          solution=refSet1.get(i);
          marked.setAttribute(solution,false);
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          solutionSet.add(solution);
        }
        refSet1.clear();
        refSet2.clear();
        archive.computeDistance();
        Collections.sort(archive.getSolutionList(),crowdingDistanceComparator);
        int insert=solutionSetSize / 2;
        if (insert > archive.getSolutionList().size())         insert=archive.getSolutionList().size();
        if (insert > (solutionSetSize - solutionSet.size()))         insert=solutionSetSize - solutionSet.size();
        for (int i=0; i < insert; i++) {
          solution=(DoubleSolution)archive.getSolutionList().get(i).copy();
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
        while (solutionSet.size() < solutionSetSize) {
          solution=diversificationGeneration();
          if (problem instanceof ConstrainedProblem) {
            ((ConstrainedProblem)problem).evaluateConstraints(solution);
          }
          problem.evaluate(solution);
          evaluations++;
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9894736842105264
64594,"/** 
 * Implements the subset generation method described in the scatter search template
 * @return Number of solutions created by the method
 * @throws JMException
 */
public int subSetGeneration() throws JMException {
  List<DoubleSolution> parents=new ArrayList<DoubleSolution>(2);
  parents.add(problem.createSolution());
  parents.add(problem.createSolution());
  List<DoubleSolution> offSpring;
  subSet.clear();
  for (int i=0; i < refSet1.size(); i++) {
    parents.set(0,refSet1.get(i));
    for (int j=i + 1; j < refSet1.size(); j++) {
      parents.set(1,refSet1.get(j));
      if (!marked.getAttribute(parents.get(0)) || !marked.getAttribute(parents.get(1))) {
        offSpring=(List<DoubleSolution>)crossoverOperator.execute(parents);
        problem.evaluate(offSpring.get(0));
        problem.evaluate(offSpring.get(1));
        if (problem instanceof ConstrainedProblem) {
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(0));
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(1));
        }
        evaluations+=2;
        if (evaluations < maxEvaluations) {
          subSet.add(offSpring.get(0));
          subSet.add(offSpring.get(1));
        }
        marked.setAttribute(parents.get(0),true);
        marked.setAttribute(parents.get(1),true);
      }
    }
  }
  for (int i=0; i < refSet2.size(); i++) {
    parents.set(0,refSet2.get(i));
    for (int j=i + 1; j < refSet2.size(); j++) {
      parents.set(1,refSet2.get(j));
      if (!marked.getAttribute(parents.get(0)) || !marked.getAttribute(parents.get(1))) {
        offSpring=(List<DoubleSolution>)crossoverOperator.execute(parents);
        if (problem instanceof ConstrainedProblem) {
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(0));
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(1));
        }
        problem.evaluate(offSpring.get(0));
        problem.evaluate(offSpring.get(1));
        evaluations+=2;
        if (evaluations < maxEvaluations) {
          subSet.add(offSpring.get(0));
          subSet.add(offSpring.get(1));
        }
        marked.setAttribute(parents.get(0),true);
        marked.setAttribute(parents.get(1),true);
      }
    }
  }
  return subSet.size();
}","/** 
 * Implements the subset generation method described in the scatter search template
 * @return Number of solutions created by the method
 * @throws JMException
 */
public int subSetGeneration() throws JMException {
  List<DoubleSolution> parents=new ArrayList<DoubleSolution>(2);
  parents.add(problem.createSolution());
  parents.add(problem.createSolution());
  List<DoubleSolution> offSpring;
  subSet.clear();
  for (int i=0; i < refSet1.size(); i++) {
    parents.set(0,refSet1.get(i));
    for (int j=i + 1; j < refSet1.size(); j++) {
      parents.set(1,refSet1.get(j));
      if (!marked.getAttribute(parents.get(0)) || !marked.getAttribute(parents.get(1))) {
        offSpring=(List<DoubleSolution>)crossoverOperator.execute(parents);
        problem.evaluate(offSpring.get(0));
        problem.evaluate(offSpring.get(1));
        if (problem instanceof ConstrainedProblem) {
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(0));
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(1));
        }
        evaluations+=2;
        if (evaluations < maxEvaluations) {
          subSet.add(offSpring.get(0));
          subSet.add(offSpring.get(1));
        }
        marked.setAttribute(parents.get(0),true);
        marked.setAttribute(parents.get(1),true);
      }
    }
  }
  System.out.println(""String_Node_Str"" + subSet.size());
  for (int i=0; i < refSet2.size(); i++) {
    parents.set(0,refSet2.get(i));
    for (int j=i + 1; j < refSet2.size(); j++) {
      parents.set(1,refSet2.get(j));
      if (!marked.getAttribute(parents.get(0)) || !marked.getAttribute(parents.get(1))) {
        offSpring=(List<DoubleSolution>)crossoverOperator.execute(parents);
        if (problem instanceof ConstrainedProblem) {
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(0));
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(1));
        }
        problem.evaluate(offSpring.get(0));
        problem.evaluate(offSpring.get(1));
        evaluations+=2;
        if (evaluations < maxEvaluations) {
          subSet.add(offSpring.get(0));
          subSet.add(offSpring.get(1));
        }
        marked.setAttribute(parents.get(0),true);
        marked.setAttribute(parents.get(1),true);
      }
    }
  }
  System.out.println(""String_Node_Str"" + subSet.size());
  return subSet.size();
}",0.972972972972973
64595,"@Override public void run(){
  initializationPhase();
  referenceSetUpdate();
  while (!isStoppingConditionReached()) {
    if (restartConditionIsFulfilled()) {
      restart();
    }
 else {
      List<List<S>> subset=subsetGeneration();
      List<S> combinedSolutions=solutionCombination(subset);
      for (      S solution : combinedSolutions) {
        S improvedSolution=improvement(solution);
        referenceSetUpdate(improvedSolution);
      }
    }
  }
}","@Override public void run(){
  initializationPhase();
  referenceSetUpdate();
  while (!isStoppingConditionReached()) {
    List<List<S>> subset=subsetGeneration();
    List<S> combinedSolutions=solutionCombination(subset);
    for (    S solution : combinedSolutions) {
      S improvedSolution=improvement(solution);
      referenceSetUpdate(improvedSolution);
    }
    if (restartConditionIsFulfilled(combinedSolutions)) {
      restart();
      referenceSetUpdate();
    }
  }
}",0.7903055848261328
64596,public abstract boolean restartConditionIsFulfilled();,public abstract boolean restartConditionIsFulfilled(List<S> solutionList);,0.84375
64597,"/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  DoubleProblem problem;
  Algorithm algorithm;
  String problemName;
  if (args != null && args.length == 1) {
    problemName=args[0];
  }
 else {
    problemName=""String_Node_Str"";
  }
  problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  Archive archive=new CrowdingDistanceArchive(100);
  algorithm=new ABYSSBuilder(problem,archive).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=(List<DoubleSolution>)((ABYSS)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"" + JMetalRandom.getInstance().getSeed());
}","/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  DoubleProblem problem;
  Algorithm algorithm;
  String problemName;
  if (args != null && args.length == 1) {
    problemName=args[0];
  }
 else {
    problemName=""String_Node_Str"";
  }
  JMetalRandom.getInstance().setSeed(1);
  problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  Archive archive=new CrowdingDistanceArchive(100);
  algorithm=new ABYSSBuilder(problem,archive).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=(List<DoubleSolution>)((ABYSS)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"" + JMetalRandom.getInstance().getSeed());
}",0.98712715855573
64598,"/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  DoubleProblem problem;
  Algorithm algorithm;
  String problemName;
  if (args != null && args.length == 1) {
    problemName=args[0];
  }
 else {
    problemName=""String_Node_Str"";
  }
  problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  Archive archive=new CrowdingDistanceArchive(100);
  algorithm=new ABYSSBuilder(problem,archive).setMaxEvaluations(25000).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=(List<DoubleSolution>)((ABYSS)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"" + JMetalRandom.getInstance().getSeed());
}","/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  DoubleProblem problem;
  Algorithm algorithm;
  String problemName;
  if (args != null && args.length == 1) {
    problemName=args[0];
  }
 else {
    problemName=""String_Node_Str"";
  }
  JMetalRandom.getInstance().setSeed(1);
  problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  Archive archive=new CrowdingDistanceArchive(100);
  algorithm=new ABYSSBuilder(problem,archive).setMaxEvaluations(25000).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=(List<DoubleSolution>)((ABYSS)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"" + JMetalRandom.getInstance().getSeed());
}",0.9873261205564142
64599,"@Test public void shouldDefaultConstructorSetTheNumberOfSolutionsToBeReturnedEqualsToTwo(){
  selection=new NaryTournamentSelection<Solution<?>>();
  assertEquals(2,ReflectionTestUtils.getField(selection,""String_Node_Str""));
}","@Test public void shouldDefaultConstructorSetTheNumberOfSolutionsToBeReturnedEqualsToTwo(){
  NaryTournamentSelection<IntegerSolution> selection=new NaryTournamentSelection<>();
  assertEquals(2,ReflectionTestUtils.getField(selection,""String_Node_Str""));
}",0.8921161825726142
64600,"@Test public void shouldExecuteReturnAValidSolutionIsWithCorrectParameters(){
  selection=new NaryTournamentSelection<Solution<?>>();
  Solution<Object> solution=mock(Solution.class);
  Problem<Solution<Object>> problem=mock(Problem.class);
  Mockito.when(problem.createSolution()).thenReturn(solution);
  population=new ArrayList<>(POPULATION_SIZE);
  for (int i=0; i < POPULATION_SIZE; i++) {
    population.add(problem.createSolution());
  }
  assertNotNull(selection.execute(population));
  verify(problem,times(POPULATION_SIZE)).createSolution();
}","@Test public void shouldExecuteReturnAValidSolutionIsWithCorrectParameters(){
  NaryTournamentSelection<BinarySolution> selection=new NaryTournamentSelection<>();
  BinarySolution solution=mock(BinarySolution.class);
  Problem<BinarySolution> problem=mock(Problem.class);
  Mockito.when(problem.createSolution()).thenReturn(solution);
  List<BinarySolution> population=new ArrayList<>(POPULATION_SIZE);
  for (int i=0; i < POPULATION_SIZE; i++) {
    population.add(problem.createSolution());
  }
  assertNotNull(selection.execute(population));
  verify(problem,times(POPULATION_SIZE)).createSolution();
}",0.7979274611398963
64601,"@Test public void shouldExecuteRaiseAnExceptionIfTheListOfSolutionsIsNull(){
  exception.expect(JMetalException.class);
  exception.expectMessage(containsString(""String_Node_Str""));
  selection=new NaryTournamentSelection<Solution<?>>();
  population=null;
  selection.execute(population);
}","@Test public void shouldExecuteRaiseAnExceptionIfTheListOfSolutionsIsNull(){
  exception.expect(JMetalException.class);
  exception.expectMessage(containsString(""String_Node_Str""));
  NaryTournamentSelection<IntegerSolution> selection=new NaryTournamentSelection<>();
  List<IntegerSolution> population;
  population=null;
  selection.execute(population);
}",0.8333333333333334
64602,"@Test public void shouldExecuteRaiseAnExceptionIfTheListSizeIsOneAndTwoSolutionsAreRequested(){
  exception.expect(JMetalException.class);
  exception.expectMessage(containsString(""String_Node_Str"" + ""String_Node_Str""));
  selection=new NaryTournamentSelection<Solution<?>>(4,mock(Comparator.class));
  List<Solution<?>> list=new ArrayList<>(1);
  list.add(mock(Solution.class));
  selection.execute(list);
}","@Test public void shouldExecuteRaiseAnExceptionIfTheListSizeIsOneAndTwoSolutionsAreRequested(){
  exception.expect(JMetalException.class);
  exception.expectMessage(containsString(""String_Node_Str"" + ""String_Node_Str""));
  NaryTournamentSelection<IntegerSolution> selection=new NaryTournamentSelection<>(4,mock(Comparator.class));
  List<IntegerSolution> list=new ArrayList<>(1);
  list.add(mock(IntegerSolution.class));
  selection.execute(list);
}",0.8798133022170361
64603,"@Test public void shouldExecuteReturnTwoSolutionsIfTheListContainsTwoSolutions(){
  selection=new NaryTournamentSelection<Solution<?>>(2,mock(Comparator.class));
  Solution<?> solution1=mock(Solution.class);
  Solution<?> solution2=mock(Solution.class);
  population=Arrays.asList(solution1,solution2);
  assertEquals(2,population.size());
}","@Test public void shouldExecuteReturnTwoSolutionsIfTheListContainsTwoSolutions(){
  NaryTournamentSelection<IntegerSolution> selection=new NaryTournamentSelection<>(2,mock(Comparator.class));
  IntegerSolution solution1=mock(IntegerSolution.class);
  IntegerSolution solution2=mock(IntegerSolution.class);
  List<IntegerSolution> population=Arrays.asList(solution1,solution2);
  assertEquals(2,population.size());
}",0.8148148148148148
64604,"@Test public void shouldExecuteReturnTheSameSolutionIfTheListContainsOneSolution(){
  selection=new NaryTournamentSelection<Solution<?>>(1,mock(Comparator.class));
  Solution<?> solution=mock(Solution.class);
  population=new ArrayList<>(1);
  population.add(solution);
  assertSame(solution,selection.execute(population));
}","@Test public void shouldExecuteReturnTheSameSolutionIfTheListContainsOneSolution(){
  NaryTournamentSelection<DoubleSolution> selection=new NaryTournamentSelection<DoubleSolution>(1,mock(Comparator.class));
  DoubleSolution solution=mock(DoubleSolution.class);
  List<DoubleSolution> population=new ArrayList<>(1);
  population.add(solution);
  assertSame(solution,selection.execute(population));
}",0.7524204702627939
64605,"@Test(expected=JMetalException.class) public void shouldExecuteRaiseAnExceptionIfTheListOfSolutionsIsEmpty(){
  selection=new NaryTournamentSelection<Solution<?>>();
  population=new ArrayList<>(0);
  selection.execute(population);
}","@Test(expected=JMetalException.class) public void shouldExecuteRaiseAnExceptionIfTheListOfSolutionsIsEmpty(){
  NaryTournamentSelection<IntegerSolution> selection=new NaryTournamentSelection<>();
  List<IntegerSolution> population=new ArrayList<>(0);
  selection.execute(population);
}",0.8571428571428571
64606,"/** 
 * Execute() method 
 */
@Override public Result execute(Source source){
  if (null == source) {
    throw new JMetalException(""String_Node_Str"");
  }
 else   if (source.size() != 2) {
    throw new JMetalException(""String_Node_Str"" + source.size());
  }
  return (Result)source;
}","/** 
 * Execute() method 
 */
@Override public Result execute(Source source){
  if (null == source) {
    throw new JMetalException(""String_Node_Str"");
  }
 else   if (source.size() != 2) {
    throw new JMetalException(""String_Node_Str"" + source.size());
  }
  List<Solution> list=new ArrayList<>();
  list.add(source.get(0).copy());
  list.add(source.get(1).copy());
  return (Result)list;
}",0.8247422680412371
64607,"@Test(expected=JMetalException.class) public void shouldExecuteRaiseAnExceptionIfTheListOfSolutionsIsNull(){
  selection=new NaryTournamentSelection();
  population=null;
  selection.execute(population);
}","@Test public void shouldExecuteRaiseAnExceptionIfTheListOfSolutionsIsNull(){
  exception.expect(JMetalException.class);
  exception.expectMessage(containsString(""String_Node_Str""));
  selection=new NaryTournamentSelection();
  population=null;
  selection.execute(population);
}",0.7163561076604554
64608,"@Override public Object getAttributeID(){
  return this;
}","@Override public Object getAttributeID(){
  return this.getClass().getName();
}",0.8467153284671532
64609,"/** 
 * @param args Command line arguments.
 * @throws java.io.IOException
 * @throws SecurityException
 * @throws ClassNotFoundException Usage: three options - org.uma.jmetal.runner.multiobjective.NSGAIIRunner - org.uma.jmetal.runner.multiobjective.NSGAIIRunner problemName - org.uma.jmetal.runner.multiobjective.NSGAIIRunner problemName paretoFrontFile
 */
public static void main(String[] args) throws JMetalException, InterruptedException {
  DoubleProblem problem;
  Algorithm<List<DoubleSolution>> algorithm;
  CrossoverOperator<List<DoubleSolution>,List<DoubleSolution>> crossover;
  MutationOperator<DoubleSolution> mutation;
  SelectionOperator selection;
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
    problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  }
 else {
    problem=new Binh2();
  }
  double crossoverProbability=0.9;
  double crossoverDistributionIndex=20.0;
  crossover=new SBXCrossover(crossoverProbability,crossoverDistributionIndex);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  selection=new BinaryTournamentSelection(new RankingAndCrowdingDistanceComparator());
  int maxIterations=250;
  int populationSize=100;
  algorithm=new NSGAIIBuilder<DoubleSolution>(problem,crossover,mutation,NSGAIIBuilder.NSGAIIVariant.Measures).setSelectionOperator(selection).setMaxIterations(maxIterations).setPopulationSize(populationSize).build();
  MeasureManager measureManager=((NSGAIIMeasures)algorithm).getMeasureManager();
  CountingMeasure iteration=(CountingMeasure)measureManager.<Long>getPullMeasure(""String_Node_Str"");
  DurationMeasure currentComputingTime=(DurationMeasure)measureManager.<Long>getPullMeasure(""String_Node_Str"");
  BasicMeasure<Integer> nonDominatedSolutions=(BasicMeasure<Integer>)measureManager.<Integer>getPullMeasure(""String_Node_Str"");
  BasicMeasure<List<Solution>> solutionListMeasure=(BasicMeasure)measureManager.getPushMeasure(""String_Node_Str"");
  CountingMeasure iteration2=(CountingMeasure)measureManager.<Long>getPushMeasure(""String_Node_Str"");
  BasicMeasure<Integer> numberOfFeasibleSolutions=(BasicMeasure)measureManager.getPushMeasure(""String_Node_Str"");
  solutionListMeasure.register(new Listener());
  iteration2.register(new Listener2());
  numberOfFeasibleSolutions.register(new feasibleSolutionsListener());
  Thread algorithmThread=new Thread(algorithm);
  algorithmThread.start();
  int i=0;
  while (iteration.get() < maxIterations) {
    TimeUnit.SECONDS.sleep(5);
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ iteration.get());
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ currentComputingTime.get());
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ nonDominatedSolutions.get());
    i++;
  }
  algorithmThread.join();
  List<DoubleSolution> population=algorithm.getResult();
  long computingTime=currentComputingTime.get();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}","/** 
 * @param args Command line arguments.
 * @throws java.io.IOException
 * @throws SecurityException
 * @throws ClassNotFoundException Usage: three options - org.uma.jmetal.runner.multiobjective.NSGAIIRunner - org.uma.jmetal.runner.multiobjective.NSGAIIRunner problemName - org.uma.jmetal.runner.multiobjective.NSGAIIRunner problemName paretoFrontFile
 */
public static void main(String[] args) throws JMetalException, InterruptedException {
  DoubleProblem problem;
  Algorithm<List<DoubleSolution>> algorithm;
  CrossoverOperator<List<DoubleSolution>,List<DoubleSolution>> crossover;
  MutationOperator<DoubleSolution> mutation;
  SelectionOperator selection;
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
    problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  }
 else {
    problem=new Golinski();
  }
  double crossoverProbability=0.9;
  double crossoverDistributionIndex=20.0;
  crossover=new SBXCrossover(crossoverProbability,crossoverDistributionIndex);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  selection=new BinaryTournamentSelection(new RankingAndCrowdingDistanceComparator());
  int maxIterations=250;
  int populationSize=100;
  algorithm=new NSGAIIBuilder<DoubleSolution>(problem,crossover,mutation,NSGAIIBuilder.NSGAIIVariant.Measures).setSelectionOperator(selection).setMaxIterations(maxIterations).setPopulationSize(populationSize).build();
  MeasureManager measureManager=((NSGAIIMeasures)algorithm).getMeasureManager();
  CountingMeasure iteration=(CountingMeasure)measureManager.<Long>getPullMeasure(""String_Node_Str"");
  DurationMeasure currentComputingTime=(DurationMeasure)measureManager.<Long>getPullMeasure(""String_Node_Str"");
  BasicMeasure<Integer> nonDominatedSolutions=(BasicMeasure<Integer>)measureManager.<Integer>getPullMeasure(""String_Node_Str"");
  BasicMeasure<List<Solution>> solutionListMeasure=(BasicMeasure)measureManager.getPushMeasure(""String_Node_Str"");
  CountingMeasure iteration2=(CountingMeasure)measureManager.<Long>getPushMeasure(""String_Node_Str"");
  BasicMeasure<Integer> numberOfFeasibleSolutions=(BasicMeasure)measureManager.getPushMeasure(""String_Node_Str"");
  solutionListMeasure.register(new Listener());
  iteration2.register(new Listener2());
  numberOfFeasibleSolutions.register(new feasibleSolutionsListener());
  Thread algorithmThread=new Thread(algorithm);
  algorithmThread.start();
  int i=0;
  while (iteration.get() < maxIterations) {
    TimeUnit.SECONDS.sleep(5);
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ iteration.get());
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ currentComputingTime.get());
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ nonDominatedSolutions.get());
    i++;
  }
  algorithmThread.join();
  List<DoubleSolution> population=algorithm.getResult();
  long computingTime=currentComputingTime.get();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}",0.9981162150412984
64610,"private void doRealMutation(double probability,IntegerSolution solution){
  Double rnd, delta1, delta2, mutPow, deltaq;
  Double y, yl, yu, val, xy;
  for (int i=0; i < solution.getNumberOfVariables(); i++) {
    if (randomGenerator.nextDouble() <= probability) {
      y=(double)solution.getVariableValue(i);
      yl=(double)solution.getLowerBound(i);
      yu=(double)solution.getUpperBound(i);
      delta1=(y - yl) / (yu - yl);
      delta2=(yu - y) / (yu - yl);
      rnd=randomGenerator.nextDouble();
      mutPow=1.0 / (distributionIndex + 1.0);
      if (rnd <= 0.5) {
        xy=1.0 - delta1;
        val=2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.pow(xy,distributionIndex + 1.0));
        deltaq=Math.pow(val,mutPow) - 1.0;
      }
 else {
        xy=1.0 - delta2;
        val=2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.pow(xy,distributionIndex + 1.0));
        deltaq=1.0 - Math.pow(val,mutPow);
      }
      y=y + deltaq * (yu - yl);
      if (y < yl) {
        y=yl;
      }
      if (y > yu) {
        y=yu;
      }
      solution.setVariableValue(i,y.intValue());
    }
  }
}","private void doRealMutation(double probability,IntegerSolution solution){
  Double rnd, delta1, delta2, mutPow, deltaq;
  Double y, yl, yu, val, xy;
  for (int i=0; i < solution.getNumberOfVariables(); i++) {
    if (randomGenerator.nextDouble() <= probability) {
      y=(double)solution.getVariableValue(i);
      yl=(double)solution.getLowerBound(i);
      yu=(double)solution.getUpperBound(i);
      if (yl == yu) {
        throw new JMetalException(""String_Node_Str"" + yl);
      }
      delta1=(y - yl) / (yu - yl);
      delta2=(yu - y) / (yu - yl);
      rnd=randomGenerator.nextDouble();
      mutPow=1.0 / (distributionIndex + 1.0);
      if (rnd <= 0.5) {
        xy=1.0 - delta1;
        val=2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.pow(xy,distributionIndex + 1.0));
        deltaq=Math.pow(val,mutPow) - 1.0;
      }
 else {
        xy=1.0 - delta2;
        val=2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.pow(xy,distributionIndex + 1.0));
        deltaq=1.0 - Math.pow(val,mutPow);
      }
      y=y + deltaq * (yu - yl);
      if (y < yl) {
        y=yl;
      }
      if (y > yu) {
        y=yu;
      }
      solution.setVariableValue(i,y.intValue());
    }
  }
}",0.9607756721022476
64611,"/** 
 * Perform the mutation operation 
 */
private void doMutation(double probability,DoubleSolution solution){
  double rnd, delta1, delta2, mutPow, deltaq;
  double y, yl, yu, val, xy;
  for (int i=0; i < solution.getNumberOfVariables(); i++) {
    if (randomGenerator.nextDouble() <= probability) {
      y=solution.getVariableValue(i);
      yl=solution.getLowerBound(i);
      yu=solution.getUpperBound(i);
      delta1=(y - yl) / (yu - yl);
      delta2=(yu - y) / (yu - yl);
      rnd=randomGenerator.nextDouble();
      mutPow=1.0 / (distributionIndex + 1.0);
      if (rnd <= 0.5) {
        xy=1.0 - delta1;
        val=2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.pow(xy,distributionIndex + 1.0));
        deltaq=Math.pow(val,mutPow) - 1.0;
      }
 else {
        xy=1.0 - delta2;
        val=2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.pow(xy,distributionIndex + 1.0));
        deltaq=1.0 - Math.pow(val,mutPow);
      }
      y=y + deltaq * (yu - yl);
      y=solutionRepair.repairSolutionVariableValue(y,yl,yu);
      solution.setVariableValue(i,y);
    }
  }
}","/** 
 * Perform the mutation operation 
 */
private void doMutation(double probability,DoubleSolution solution){
  double rnd, delta1, delta2, mutPow, deltaq;
  double y, yl, yu, val, xy;
  for (int i=0; i < solution.getNumberOfVariables(); i++) {
    if (randomGenerator.nextDouble() <= probability) {
      y=solution.getVariableValue(i);
      yl=solution.getLowerBound(i);
      yu=solution.getUpperBound(i);
      if (yl == yu) {
        throw new JMetalException(""String_Node_Str"" + yl);
      }
      delta1=(y - yl) / (yu - yl);
      delta2=(yu - y) / (yu - yl);
      rnd=randomGenerator.nextDouble();
      mutPow=1.0 / (distributionIndex + 1.0);
      if (rnd <= 0.5) {
        xy=1.0 - delta1;
        val=2.0 * rnd + (1.0 - 2.0 * rnd) * (Math.pow(xy,distributionIndex + 1.0));
        deltaq=Math.pow(val,mutPow) - 1.0;
      }
 else {
        xy=1.0 - delta2;
        val=2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (Math.pow(xy,distributionIndex + 1.0));
        deltaq=1.0 - Math.pow(val,mutPow);
      }
      y=y + deltaq * (yu - yl);
      y=solutionRepair.repairSolutionVariableValue(y,yl,yu);
      solution.setVariableValue(i,y);
    }
  }
}",0.96010757507844
64612,"@Test public void shouldExecuteReturnTheSecondSelectedSolutionIsIsDominatedByTheFirstOne(){
  Comparator<Solution> comparator=mock(Comparator.class);
  Solution solution1=mock(Solution.class);
  Mockito.when(solution1.getNumberOfObjectives()).thenReturn(2);
  Mockito.when(solution1.getObjective(0)).thenReturn(1.0);
  Mockito.when(solution1.getObjective(1)).thenReturn(2.0);
  Solution solution2=mock(Solution.class);
  Mockito.when(solution2.getNumberOfObjectives()).thenReturn(1);
  Mockito.when(solution2.getObjective(0)).thenReturn(2.0);
  Mockito.when(solution2.getObjective(1)).thenReturn(3.0);
  Mockito.when(comparator.compare(solution1,solution2)).thenReturn(-1);
  Mockito.when(comparator.compare(solution2,solution1)).thenReturn(1);
  List<Solution> population=Arrays.asList(solution1,solution2);
  selection=new BinaryTournamentSelection(comparator);
  Solution result=selection.execute(population);
  assertEquals(solution1,result);
  assertNotEquals(solution2,result);
  verify(comparator).compare(any(Solution.class),any(Solution.class));
}","@Test public void shouldExecuteReturnTheSecondSelectedSolutionIsIsDominatedByTheFirstOne(){
  Comparator<Solution> comparator=mock(Comparator.class);
  Solution solution1=mock(Solution.class);
  Mockito.when(solution1.getNumberOfObjectives()).thenReturn(2);
  Mockito.when(solution1.getObjective(0)).thenReturn(1.0);
  Mockito.when(solution1.getObjective(1)).thenReturn(2.0);
  Solution solution2=mock(Solution.class);
  Mockito.when(solution2.getNumberOfObjectives()).thenReturn(2);
  Mockito.when(solution2.getObjective(0)).thenReturn(2.0);
  Mockito.when(solution2.getObjective(1)).thenReturn(3.0);
  Mockito.when(comparator.compare(solution1,solution2)).thenReturn(-1);
  Mockito.when(comparator.compare(solution2,solution1)).thenReturn(1);
  List<Solution> population=Arrays.asList(solution1,solution2);
  selection=new BinaryTournamentSelection(comparator);
  Solution result=selection.execute(population);
  assertEquals(solution1,result);
  assertNotEquals(solution2,result);
  verify(comparator).compare(any(Solution.class),any(Solution.class));
}",0.9990530303030304
64613,"/** 
 * Runs of the AbYSS algorithm. as a result of the algorithm execution
 */
@Override public void run(){
  try {
    DoubleSolution solution;
    initialListSolution();
    int newSolutions=0;
    while (evaluations < maxEvaluations) {
      referenceSetUpdate(true);
      newSolutions=subSetGeneration();
      while (newSolutions > 0) {
        referenceSetUpdate(false);
        if (evaluations < maxEvaluations) {
          newSolutions=subSetGeneration();
        }
 else {
          newSolutions=0;
        }
      }
      if (evaluations < maxEvaluations) {
        solutionSet.clear();
        for (int i=0; i < refSet1.size(); i++) {
          solution=refSet1.get(i);
          marked.setAttribute(solution,false);
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          solutionSet.add(solution);
        }
        refSet1.clear();
        refSet2.clear();
        archive.computeDistance();
        Collections.sort(archive.getSolutionList(),crowdingDistanceComparator);
        int insert=solutionSetSize / 2;
        if (insert > archive.getSolutionList().size())         insert=archive.getSolutionList().size();
        if (insert > (solutionSetSize - solutionSet.size()))         insert=solutionSetSize - solutionSet.size();
        for (int i=0; i < insert; i++) {
          solution=archive.getSolutionList().get(i);
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
        while (solutionSet.size() < solutionSetSize) {
          solution=diversificationGeneration();
          if (problem instanceof ConstrainedProblem) {
            ((ConstrainedProblem)problem).evaluateConstraints(solution);
          }
          problem.evaluate(solution);
          evaluations++;
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Runs of the AbYSS algorithm. as a result of the algorithm execution
 */
@Override public void run(){
  try {
    DoubleSolution solution;
    initialListSolution();
    int newSolutions=0;
    boolean exit=false;
    while ((evaluations < maxEvaluations) && !exit) {
      referenceSetUpdate(true);
      newSolutions=subSetGeneration();
      while ((newSolutions > 0) && !exit) {
        referenceSetUpdate(false);
        if (evaluations >= maxEvaluations) {
          exit=true;
        }
        if (!exit) {
          newSolutions=subSetGeneration();
        }
      }
      if (evaluations < maxEvaluations) {
        solutionSet.clear();
        for (int i=0; i < refSet1.size(); i++) {
          solution=refSet1.get(i);
          marked.setAttribute(solution,false);
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          solutionSet.add(solution);
        }
        refSet1.clear();
        refSet2.clear();
        archive.computeDistance();
        Collections.sort(archive.getSolutionList(),crowdingDistanceComparator);
        int insert=solutionSetSize / 2;
        if (insert > archive.getSolutionList().size())         insert=archive.getSolutionList().size();
        if (insert > (solutionSetSize - solutionSet.size()))         insert=solutionSetSize - solutionSet.size();
        for (int i=0; i < insert; i++) {
          solution=(DoubleSolution)archive.getSolutionList().get(i).copy();
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
        while (solutionSet.size() < solutionSetSize) {
          solution=diversificationGeneration();
          if (problem instanceof ConstrainedProblem) {
            ((ConstrainedProblem)problem).evaluateConstraints(solution);
          }
          problem.evaluate(solution);
          evaluations++;
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.4036866359447004
64614,"private void initialListSolution(){
  try {
    DoubleSolution solution;
    for (int i=0; i < this.solutionSetSize; i++) {
      solution=super.diversificationGeneration();
      problem.evaluate(solution);
      if (problem instanceof ConstrainedProblem) {
        ((ConstrainedProblem)problem).evaluateConstraints(solution);
      }
      evaluations++;
      solution=(DoubleSolution)improvementOperator.execute(solution);
      marked.setAttribute(solution,false);
      if (strenghtRawFitness.getAttribute(solution) == null) {
        strenghtRawFitness.setAttribute(solution,0.0);
      }
      evaluations+=improvementOperator.getEvaluations();
      solutionSet.add(solution);
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","private void initialListSolution(){
  try {
    DoubleSolution solution;
    for (int i=0; i < this.solutionSetSize; i++) {
      solution=super.diversificationGeneration();
      problem.evaluate(solution);
      if (problem instanceof ConstrainedProblem) {
        ((ConstrainedProblem)problem).evaluateConstraints(solution);
      }
      evaluations++;
      solution=(DoubleSolution)improvementOperator.execute(solution);
      marked.setAttribute(solution,false);
      evaluations+=improvementOperator.getEvaluations();
      solutionSet.add(solution);
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}",0.908695652173913
64615,"/** 
 * Implements the subset generation method described in the scatter search template
 * @return Number of solutions created by the method
 * @throws JMException
 */
public int subSetGeneration() throws JMException {
  List<DoubleSolution> parents=new ArrayList<DoubleSolution>(2);
  parents.add(problem.createSolution());
  parents.add(problem.createSolution());
  marked.setAttribute(parents.get(0),false);
  marked.setAttribute(parents.get(1),false);
  strenghtRawFitness.setAttribute(parents.get(0),0.0);
  strenghtRawFitness.setAttribute(parents.get(1),0.0);
  List<DoubleSolution> offSpring;
  subSet.clear();
  for (int i=0; i < refSet1.size(); i++) {
    parents.set(0,refSet1.get(i));
    for (int j=i + 1; j < refSet1.size(); j++) {
      parents.set(1,refSet1.get(i));
      if (!marked.getAttribute(parents.get(0)) || !marked.getAttribute(parents.get(1))) {
        offSpring=(List<DoubleSolution>)crossoverOperator.execute(parents);
        problem.evaluate(offSpring.get(0));
        problem.evaluate(offSpring.get(1));
        if (problem instanceof ConstrainedProblem) {
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(0));
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(1));
        }
        evaluations+=2;
        if (evaluations < maxEvaluations) {
          subSet.add(offSpring.get(0));
          subSet.add(offSpring.get(1));
        }
        marked.setAttribute(parents.get(0),true);
        marked.setAttribute(parents.get(1),true);
      }
    }
  }
  for (int i=0; i < refSet2.size(); i++) {
    parents.set(0,refSet2.get(i));
    for (int j=i + 1; j < refSet2.size(); j++) {
      parents.set(1,refSet2.get(j));
      if (!marked.getAttribute(parents.get(0)) || !marked.getAttribute(parents.get(1))) {
        offSpring=(List<DoubleSolution>)crossoverOperator.execute(parents);
        if (problem instanceof ConstrainedProblem) {
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(0));
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(1));
        }
        problem.evaluate(offSpring.get(0));
        problem.evaluate(offSpring.get(1));
        evaluations+=2;
        if (evaluations < maxEvaluations) {
          subSet.add(offSpring.get(0));
          subSet.add(offSpring.get(1));
        }
        marked.setAttribute(parents.get(0),true);
        marked.setAttribute(parents.get(1),true);
      }
    }
  }
  return subSet.size();
}","/** 
 * Implements the subset generation method described in the scatter search template
 * @return Number of solutions created by the method
 * @throws JMException
 */
public int subSetGeneration() throws JMException {
  List<DoubleSolution> parents=new ArrayList<DoubleSolution>(2);
  parents.add(problem.createSolution());
  parents.add(problem.createSolution());
  List<DoubleSolution> offSpring;
  subSet.clear();
  for (int i=0; i < refSet1.size(); i++) {
    parents.set(0,refSet1.get(i));
    for (int j=i + 1; j < refSet1.size(); j++) {
      parents.set(1,refSet1.get(j));
      if (!marked.getAttribute(parents.get(0)) || !marked.getAttribute(parents.get(1))) {
        offSpring=(List<DoubleSolution>)crossoverOperator.execute(parents);
        problem.evaluate(offSpring.get(0));
        problem.evaluate(offSpring.get(1));
        if (problem instanceof ConstrainedProblem) {
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(0));
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(1));
        }
        evaluations+=2;
        if (evaluations < maxEvaluations) {
          subSet.add(offSpring.get(0));
          subSet.add(offSpring.get(1));
        }
        marked.setAttribute(parents.get(0),true);
        marked.setAttribute(parents.get(1),true);
      }
    }
  }
  for (int i=0; i < refSet2.size(); i++) {
    parents.set(0,refSet2.get(i));
    for (int j=i + 1; j < refSet2.size(); j++) {
      parents.set(1,refSet2.get(j));
      if (!marked.getAttribute(parents.get(0)) || !marked.getAttribute(parents.get(1))) {
        offSpring=(List<DoubleSolution>)crossoverOperator.execute(parents);
        if (problem instanceof ConstrainedProblem) {
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(0));
          ((ConstrainedProblem)problem).evaluateConstraints(offSpring.get(1));
        }
        problem.evaluate(offSpring.get(0));
        problem.evaluate(offSpring.get(1));
        evaluations+=2;
        if (evaluations < maxEvaluations) {
          subSet.add(offSpring.get(0));
          subSet.add(offSpring.get(1));
        }
        marked.setAttribute(parents.get(0),true);
        marked.setAttribute(parents.get(1),true);
      }
    }
  }
  return subSet.size();
}",0.9574557708508846
64616,"/** 
 * Returns a <code>Solution</code> using the diversification generation method described in the scatter search template.
 * @throws javax.management.JMException
 * @throws ClassNotFoundException
 */
public DoubleSolution diversificationGeneration() throws JMException, ClassNotFoundException {
  DoubleSolution solution=problem.createSolution();
  marked.setAttribute(solution,false);
  strenghtRawFitness.setAttribute(solution,0.0);
  double value;
  int range;
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    sumOfReverseFrequencyValues[i]=0;
    for (int j=0; j < numberOfSubranges; j++) {
      reverseFrequency[j][i]=sumOfFrequencyValues[i] - frequency[j][i];
      sumOfReverseFrequencyValues[i]+=reverseFrequency[j][i];
    }
    if (sumOfReverseFrequencyValues[i] == 0) {
      range=randomGenerator.nextInt(0,numberOfSubranges - 1);
    }
 else {
      value=randomGenerator.nextInt(0,sumOfReverseFrequencyValues[i] - 1);
      range=0;
      while (value > reverseFrequency[range][i]) {
        value-=reverseFrequency[range][i];
        range++;
      }
    }
    frequency[range][i]++;
    sumOfFrequencyValues[i]++;
    double low=problem.getLowerBound(i) + range * (problem.getUpperBound(i) - problem.getLowerBound(i)) / numberOfSubranges;
    double high=low + (problem.getUpperBound(i) - problem.getLowerBound(i)) / numberOfSubranges;
    value=randomGenerator.nextDouble(low,high);
    solution.setVariableValue(i,value);
  }
  return solution;
}","/** 
 * Returns a <code>Solution</code> using the diversification generation method described in the scatter search template.
 * @throws javax.management.JMException
 * @throws ClassNotFoundException
 */
public DoubleSolution diversificationGeneration() throws JMException, ClassNotFoundException {
  DoubleSolution solution=problem.createSolution();
  double value;
  int range;
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    sumOfReverseFrequencyValues[i]=0;
    for (int j=0; j < numberOfSubranges; j++) {
      reverseFrequency[j][i]=sumOfFrequencyValues[i] - frequency[j][i];
      sumOfReverseFrequencyValues[i]+=reverseFrequency[j][i];
    }
    if (sumOfReverseFrequencyValues[i] == 0) {
      range=randomGenerator.nextInt(0,numberOfSubranges - 1);
    }
 else {
      value=randomGenerator.nextInt(0,sumOfReverseFrequencyValues[i] - 1);
      range=0;
      while (value > reverseFrequency[range][i]) {
        value-=reverseFrequency[range][i];
        range++;
      }
    }
    frequency[range][i]++;
    sumOfFrequencyValues[i]++;
    double low=problem.getLowerBound(i) + range * (problem.getUpperBound(i) - problem.getLowerBound(i)) / numberOfSubranges;
    double high=low + (problem.getUpperBound(i) - problem.getLowerBound(i)) / numberOfSubranges;
    value=randomGenerator.nextDouble(low,high);
    solution.setVariableValue(i,value);
  }
  return solution;
}",0.9694232105628908
64617,"/** 
 * Runs of the AbYSS algorithm. as a result of the algorithm execution
 */
@Override public void run(){
  try {
    DoubleSolution solution;
    initialListSolution();
    int newSolutions=0;
    while (evaluations < maxEvaluations) {
      referenceSetUpdate(true);
      newSolutions=subSetGeneration();
      while (newSolutions > 0 && evaluations < maxEvaluations) {
        referenceSetUpdate(false);
        newSolutions=subSetGeneration();
      }
      if (evaluations < maxEvaluations) {
        solutionSet.clear();
        for (int i=0; i < refSet1.size(); i++) {
          solution=refSet1.get(i);
          marked.setAttribute(solution,false);
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          solutionSet.add(solution);
        }
        refSet1.clear();
        refSet2.clear();
        archive.computeDistance();
        Collections.sort(archive.getSolutionList(),crowdingDistanceComparator);
        int insert=solutionSetSize / 2;
        if (insert > archive.getMaxSize())         insert=archive.getMaxSize();
        if (insert > (solutionSetSize - solutionSet.size()))         insert=solutionSetSize - solutionSet.size();
        for (int i=0; i < insert; i++) {
          solution=archive.getSolutionList().get(i);
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
        while (solutionSet.size() < solutionSetSize) {
          solution=diversificationGeneration();
          if (problem instanceof ConstrainedProblem) {
            ((ConstrainedProblem)problem).evaluateConstraints(solution);
          }
          problem.evaluate(solution);
          evaluations++;
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Runs of the AbYSS algorithm. as a result of the algorithm execution
 */
@Override public void run(){
  try {
    DoubleSolution solution;
    initialListSolution();
    int newSolutions=0;
    while (evaluations < maxEvaluations) {
      referenceSetUpdate(true);
      newSolutions=subSetGeneration();
      while (newSolutions > 0) {
        referenceSetUpdate(false);
        if (evaluations < maxEvaluations) {
          newSolutions=subSetGeneration();
        }
 else {
          newSolutions=0;
        }
      }
      if (evaluations < maxEvaluations) {
        solutionSet.clear();
        for (int i=0; i < refSet1.size(); i++) {
          solution=refSet1.get(i);
          marked.setAttribute(solution,false);
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          solutionSet.add(solution);
        }
        refSet1.clear();
        refSet2.clear();
        archive.computeDistance();
        Collections.sort(archive.getSolutionList(),crowdingDistanceComparator);
        int insert=solutionSetSize / 2;
        if (insert > archive.getSolutionList().size())         insert=archive.getSolutionList().size();
        if (insert > (solutionSetSize - solutionSet.size()))         insert=solutionSetSize - solutionSet.size();
        for (int i=0; i < insert; i++) {
          solution=archive.getSolutionList().get(i);
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
        while (solutionSet.size() < solutionSetSize) {
          solution=diversificationGeneration();
          if (problem instanceof ConstrainedProblem) {
            ((ConstrainedProblem)problem).evaluateConstraints(solution);
          }
          problem.evaluate(solution);
          evaluations++;
          solution=(DoubleSolution)improvementOperator.execute(solution);
          evaluations+=improvementOperator.getEvaluations();
          marked.setAttribute(solution,false);
          solutionSet.add(solution);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9175059952038368
64618,"private void initialListSolution(){
  try {
    DoubleSolution solution;
    for (int i=0; i < this.solutionSetSize; i++) {
      solution=super.diversificationGeneration();
      problem.evaluate(solution);
      if (problem instanceof ConstrainedProblem) {
        ((ConstrainedProblem)problem).evaluateConstraints(solution);
      }
      evaluations++;
      solution=(DoubleSolution)improvementOperator.execute(solution);
      marked.setAttribute(solution,false);
      strenghtRawFitness.setAttribute(solution,0.0);
      evaluations+=improvementOperator.getEvaluations();
      solutionSet.add(solution);
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","private void initialListSolution(){
  try {
    DoubleSolution solution;
    for (int i=0; i < this.solutionSetSize; i++) {
      solution=super.diversificationGeneration();
      problem.evaluate(solution);
      if (problem instanceof ConstrainedProblem) {
        ((ConstrainedProblem)problem).evaluateConstraints(solution);
      }
      evaluations++;
      solution=(DoubleSolution)improvementOperator.execute(solution);
      marked.setAttribute(solution,false);
      if (strenghtRawFitness.getAttribute(solution) == null) {
        strenghtRawFitness.setAttribute(solution,0.0);
      }
      evaluations+=improvementOperator.getEvaluations();
      solutionSet.add(solution);
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}",0.9490579204466156
64619,"public ABYSSBuilder(DoubleProblem problem,Archive archive){
  this.populationSize=20;
  this.maxEvaluations=25000;
  this.archiveSize=100;
  this.refSet1Size=10;
  this.refSet2Size=10;
  this.numberOfSubranges=4;
  this.problem=problem;
  double crossoverProbability=0.9;
  double distributionIndex=20.0;
  this.crossoverOperator=new SBXCrossover(crossoverProbability,distributionIndex);
  double mutationProbability=1 / problem.getNumberOfVariables();
  this.mutationOperator=new PolynomialMutation(mutationProbability,distributionIndex);
  int improvementRounds=1;
  this.improvementOperator=new MutationLocalSearch(improvementRounds,mutationOperator,archive.getSolutionList(),problem);
  this.archive=(CrowdingDistanceArchive)archive;
}","public ABYSSBuilder(DoubleProblem problem,Archive archive){
  this.populationSize=20;
  this.maxEvaluations=25000;
  this.archiveSize=100;
  this.refSet1Size=10;
  this.refSet2Size=10;
  this.numberOfSubranges=4;
  this.problem=problem;
  double crossoverProbability=0.9;
  double distributionIndex=20.0;
  this.crossoverOperator=new SBXCrossover(crossoverProbability,distributionIndex);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  this.mutationOperator=new PolynomialMutation(mutationProbability,distributionIndex);
  int improvementRounds=1;
  this.archive=(CrowdingDistanceArchive)archive;
  this.improvementOperator=new MutationLocalSearch(improvementRounds,mutationOperator,this.archive,problem);
}",0.8411724608043627
64620,"/** 
 * Returns a <code>Solution</code> using the diversification generation method described in the scatter search template.
 * @throws javax.management.JMException
 * @throws ClassNotFoundException
 */
public DoubleSolution diversificationGeneration() throws JMException, ClassNotFoundException {
  DoubleSolution solution=problem.createSolution();
  marked.setAttribute(solution,false);
  double value;
  int range;
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    sumOfReverseFrequencyValues[i]=0;
    for (int j=0; j < numberOfSubranges; j++) {
      reverseFrequency[j][i]=sumOfFrequencyValues[i] - frequency[j][i];
      sumOfReverseFrequencyValues[i]+=reverseFrequency[j][i];
    }
    if (sumOfReverseFrequencyValues[i] == 0) {
      range=randomGenerator.nextInt(0,numberOfSubranges - 1);
    }
 else {
      value=randomGenerator.nextInt(0,sumOfReverseFrequencyValues[i] - 1);
      range=0;
      while (value > reverseFrequency[range][i]) {
        value-=reverseFrequency[range][i];
        range++;
      }
    }
    frequency[range][i]++;
    sumOfFrequencyValues[i]++;
    double low=problem.getLowerBound(i) + range * (problem.getUpperBound(i) - problem.getLowerBound(i)) / numberOfSubranges;
    double high=low + (problem.getUpperBound(i) - problem.getLowerBound(i)) / numberOfSubranges;
    value=randomGenerator.nextDouble(low,high);
    solution.setVariableValue(i,value);
  }
  return solution;
}","/** 
 * Returns a <code>Solution</code> using the diversification generation method described in the scatter search template.
 * @throws javax.management.JMException
 * @throws ClassNotFoundException
 */
public DoubleSolution diversificationGeneration() throws JMException, ClassNotFoundException {
  DoubleSolution solution=problem.createSolution();
  marked.setAttribute(solution,false);
  strenghtRawFitness.setAttribute(solution,0.0);
  double value;
  int range;
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    sumOfReverseFrequencyValues[i]=0;
    for (int j=0; j < numberOfSubranges; j++) {
      reverseFrequency[j][i]=sumOfFrequencyValues[i] - frequency[j][i];
      sumOfReverseFrequencyValues[i]+=reverseFrequency[j][i];
    }
    if (sumOfReverseFrequencyValues[i] == 0) {
      range=randomGenerator.nextInt(0,numberOfSubranges - 1);
    }
 else {
      value=randomGenerator.nextInt(0,sumOfReverseFrequencyValues[i] - 1);
      range=0;
      while (value > reverseFrequency[range][i]) {
        value-=reverseFrequency[range][i];
        range++;
      }
    }
    frequency[range][i]++;
    sumOfFrequencyValues[i]++;
    double low=problem.getLowerBound(i) + range * (problem.getUpperBound(i) - problem.getLowerBound(i)) / numberOfSubranges;
    double high=low + (problem.getUpperBound(i) - problem.getLowerBound(i)) / numberOfSubranges;
    value=randomGenerator.nextDouble(low,high);
    solution.setVariableValue(i,value);
  }
  return solution;
}",0.9832019197805963
64621,"@Override public String getName(){
  return getName();
}","@Override public String getName(){
  return super.getName();
}",0.9491525423728814
64622,"@Override public String getName(){
  return getName();
}","@Override public String getName(){
  return super.getName();
}",0.9491525423728814
64623,"@Override public String getName(){
  return getName();
}","@Override public String getName(){
  return super.getName();
}",0.9491525423728814
64624,"@Override public String getName(){
  return getName();
}","@Override public String getName(){
  return super.getName();
}",0.9491525423728814
64625,"@Override public String getName(){
  return getName();
}","@Override public String getName(){
  return super.getName();
}",0.9491525423728814
64626,"@Override public String getName(){
  return getName();
}","@Override public String getName(){
  return super.getName();
}",0.9491525423728814
64627,"@Override public String getName(){
  return getName();
}","@Override public String getName(){
  return super.getName();
}",0.9491525423728814
64628,"@Override public String getName(){
  return getName();
}","@Override public String getName(){
  return super.getName();
}",0.9491525423728814
64629,"@Override public String getName(){
  return getName();
}","@Override public String getName(){
  return super.getName();
}",0.9491525423728814
64630,"@Override public int getNumberOfPoints(){
  return points.length;
}","@Override public int getNumberOfPoints(){
  return numberOfPoints;
}",0.8740740740740741
64631,"@Override public void sort(Comparator<Point> comparator){
  Arrays.sort(points,comparator);
}","@Override public void sort(Comparator<Point> comparator){
  Arrays.sort(points,0,numberOfPoints,comparator);
}",0.916256157635468
64632,"@Test(expected=NullPointerException.class) public void shouldCreateInputStreamThrownAnExceptionIfFileDoesNotExist() throws FileNotFoundException {
  String fileName=""String_Node_Str"";
  Front front=new ArrayFront();
  front.readFrontFromFile(fileName);
}","@Test(expected=FileNotFoundException.class) public void shouldCreateInputStreamThrownAnExceptionIfFileDoesNotExist() throws FileNotFoundException {
  String fileName=""String_Node_Str"";
  Front front=new ArrayFront();
  front.readFrontFromFile(fileName);
}",0.9548133595284872
64633,"/** 
 * Initialize weight vectors
 */
protected void initializeUniformWeight(){
  if ((problem.getNumberOfObjectives() == 2) && (populationSize <= 300)) {
    for (int n=0; n < populationSize; n++) {
      double a=1.0 * n / (populationSize - 1);
      lambda[n][0]=a;
      lambda[n][1]=1 - a;
    }
  }
 else {
    String dataFileName;
    dataFileName=""String_Node_Str"" + problem.getNumberOfObjectives() + ""String_Node_Str""+ populationSize+ ""String_Node_Str"";
    try {
      FileInputStream fis=new FileInputStream(this.getClass().getClassLoader().getResource(dataDirectory + ""String_Node_Str"" + dataFileName).getPath());
      InputStreamReader isr=new InputStreamReader(fis);
      BufferedReader br=new BufferedReader(isr);
      int i=0;
      int j=0;
      String aux=br.readLine();
      while (aux != null) {
        StringTokenizer st=new StringTokenizer(aux);
        j=0;
        while (st.hasMoreTokens()) {
          double value=new Double(st.nextToken());
          lambda[i][j]=value;
          j++;
        }
        aux=br.readLine();
        i++;
      }
      br.close();
    }
 catch (    Exception e) {
      throw new JMetalException(""String_Node_Str"" + dataDirectory + ""String_Node_Str""+ dataFileName,e);
    }
  }
}","/** 
 * Initialize weight vectors
 */
protected void initializeUniformWeight(){
  if ((problem.getNumberOfObjectives() == 2) && (populationSize <= 300)) {
    for (int n=0; n < populationSize; n++) {
      double a=1.0 * n / (populationSize - 1);
      lambda[n][0]=a;
      lambda[n][1]=1 - a;
    }
  }
 else {
    String dataFileName;
    dataFileName=""String_Node_Str"" + problem.getNumberOfObjectives() + ""String_Node_Str""+ populationSize+ ""String_Node_Str"";
    try {
      InputStream in=getClass().getResourceAsStream(""String_Node_Str"" + dataDirectory + ""String_Node_Str""+ dataFileName);
      InputStreamReader isr=new InputStreamReader(in);
      BufferedReader br=new BufferedReader(isr);
      int i=0;
      int j=0;
      String aux=br.readLine();
      while (aux != null) {
        StringTokenizer st=new StringTokenizer(aux);
        j=0;
        while (st.hasMoreTokens()) {
          double value=new Double(st.nextToken());
          lambda[i][j]=value;
          j++;
        }
        aux=br.readLine();
        i++;
      }
      br.close();
    }
 catch (    Exception e) {
      throw new JMetalException(""String_Node_Str"" + dataDirectory + ""String_Node_Str""+ dataFileName,e);
    }
  }
}",0.8770358306188925
64634,"public AbstractMOEAD(Problem problem,int populationSize,int resultPopulationSize,int maxEvaluations,CrossoverOperator crossoverOperator,MutationOperator mutation,FunctionType functionType,String dataDirectory,double neighborhoodSelectionProbability,int maximumNumberOfReplacedSolutions,int neighborSize){
  this.problem=problem;
  this.populationSize=populationSize;
  this.resultPopulationSize=resultPopulationSize;
  this.maxEvaluations=maxEvaluations;
  this.mutationOperator=mutation;
  this.crossoverOperator=crossoverOperator;
  this.functionType=functionType;
  this.neighborhoodSelectionProbability=neighborhoodSelectionProbability;
  this.maximumNumberOfReplacedSolutions=maximumNumberOfReplacedSolutions;
  this.neighborSize=neighborSize;
  randomGenerator=JMetalRandom.getInstance();
  population=new ArrayList<>(populationSize);
  indArray=new Solution[problem.getNumberOfObjectives()];
  neighborhood=new int[populationSize][neighborSize];
  idealPoint=new double[problem.getNumberOfObjectives()];
  lambda=new double[populationSize][problem.getNumberOfObjectives()];
}","public AbstractMOEAD(Problem problem,int populationSize,int resultPopulationSize,int maxEvaluations,CrossoverOperator crossoverOperator,MutationOperator mutation,FunctionType functionType,String dataDirectory,double neighborhoodSelectionProbability,int maximumNumberOfReplacedSolutions,int neighborSize){
  this.problem=problem;
  this.populationSize=populationSize;
  this.resultPopulationSize=resultPopulationSize;
  this.maxEvaluations=maxEvaluations;
  this.mutationOperator=mutation;
  this.crossoverOperator=crossoverOperator;
  this.functionType=functionType;
  this.dataDirectory=dataDirectory;
  this.neighborhoodSelectionProbability=neighborhoodSelectionProbability;
  this.maximumNumberOfReplacedSolutions=maximumNumberOfReplacedSolutions;
  this.neighborSize=neighborSize;
  randomGenerator=JMetalRandom.getInstance();
  population=new ArrayList<>(populationSize);
  indArray=new Solution[problem.getNumberOfObjectives()];
  neighborhood=new int[populationSize][neighborSize];
  idealPoint=new double[problem.getNumberOfObjectives()];
  lambda=new double[populationSize][problem.getNumberOfObjectives()];
}",0.9836363636363636
64635,"protected void matingSelection(Vector<Integer> listOfSolutions,int subproblemId,NeighborType neighbourType){
  int neighbourSize;
  int selectedSolution;
  int numberOfSolutionsToSelect=2;
  neighbourSize=neighborhood[subproblemId].length;
  while (listOfSolutions.size() < numberOfSolutionsToSelect) {
    int random;
    if (neighbourType == NeighborType.NEIGHBOR) {
      random=randomGenerator.nextInt(0,neighbourSize - 1);
      selectedSolution=neighborhood[subproblemId][random];
    }
 else {
      selectedSolution=randomGenerator.nextInt(0,populationSize - 1);
    }
    boolean flag=true;
    for (    Integer individualId : listOfSolutions) {
      if (individualId == selectedSolution) {
        flag=false;
        break;
      }
    }
    if (flag) {
      listOfSolutions.addElement(selectedSolution);
    }
  }
}","/** 
 * @param listOfSolutions The set of the indexes of selected mating parents
 * @param subproblemId the id of current subproblem
 * @param neighbourType neighbour type
 */
protected void matingSelection(Vector<Integer> listOfSolutions,int subproblemId,NeighborType neighbourType){
  int neighbourSize;
  int selectedSolution;
  int numberOfSolutionsToSelect=2;
  neighbourSize=neighborhood[subproblemId].length;
  while (listOfSolutions.size() < numberOfSolutionsToSelect) {
    int random;
    if (neighbourType == NeighborType.NEIGHBOR) {
      random=randomGenerator.nextInt(0,neighbourSize - 1);
      selectedSolution=neighborhood[subproblemId][random];
    }
 else {
      selectedSolution=randomGenerator.nextInt(0,populationSize - 1);
    }
    boolean flag=true;
    for (    Integer individualId : listOfSolutions) {
      if (individualId == selectedSolution) {
        flag=false;
        break;
      }
    }
    if (flag) {
      listOfSolutions.addElement(selectedSolution);
    }
  }
}",0.9040348964013086
64636,"/** 
 * @param args Command line arguments.
 * @throws java.io.IOException
 * @throws SecurityException
 * @throws ClassNotFoundException Usage: three choices - org.uma.jmetal45.runner.MOEADRunner.GDE3Runner - org.uma.jmetal45.runner.MOEADRunner.GDE3Runner problemName - org.uma.jmetal45.runner.MOEADRunner.GDE3Runner problemName paretoFrontFile
 */
public static void main(String[] args){
  DoubleProblem problem;
  Algorithm algorithm;
  MutationOperator mutation;
  DifferentialEvolutionCrossover crossover;
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
  }
 else {
    problemName=""String_Node_Str"";
  }
  problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  double cr=1.0;
  double f=0.5;
  crossover=new DifferentialEvolutionCrossover(cr,f,""String_Node_Str"");
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  algorithm=new MOEADBuilder(problem).setCrossover(crossover).setMutation(mutation).setMaxEvaluations(150000).setPopulationSize(300).setResultPopulationSize(300).setNeighborhoodSelectionProbability(0.9).setMaximumNumberOfReplacedSolutions(2).setNeighborSize(20).setFunctionType(AbstractMOEAD.FunctionType.TCHE).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=((MOEAD)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}","/** 
 * @param args Command line arguments.
 * @throws java.io.IOException
 * @throws SecurityException
 * @throws ClassNotFoundException Usage: three choices - org.uma.jmetal45.runner.MOEADRunner.GDE3Runner - org.uma.jmetal45.runner.MOEADRunner.GDE3Runner problemName - org.uma.jmetal45.runner.MOEADRunner.GDE3Runner problemName paretoFrontFile
 */
public static void main(String[] args){
  DoubleProblem problem;
  Algorithm algorithm;
  MutationOperator mutation;
  DifferentialEvolutionCrossover crossover;
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
  }
 else {
    problemName=""String_Node_Str"";
  }
  problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  double cr=1.0;
  double f=0.5;
  crossover=new DifferentialEvolutionCrossover(cr,f,""String_Node_Str"");
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  algorithm=new MOEADBuilder(problem).setCrossover(crossover).setMutation(mutation).setMaxEvaluations(150000).setPopulationSize(300).setResultPopulationSize(300).setNeighborhoodSelectionProbability(0.9).setMaximumNumberOfReplacedSolutions(2).setNeighborSize(20).setFunctionType(AbstractMOEAD.FunctionType.TCHE).setDataDirectory(""String_Node_Str"").build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=((MOEAD)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}",0.9907644946126218
64637,"/** 
 * Copy constructor 
 */
public GenericBinarySolution(GenericBinarySolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (int i=0; i < problem.getNumberOfObjectives(); i++) {
    objectives.add(solution.getObjective(i));
  }
  variables=new ArrayList<>();
  for (  BinarySet var : solution.variables) {
    variables.add((BinarySet)var.clone());
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  attributes=new HashMap(solution.attributes);
}","/** 
 * Copy constructor 
 */
public GenericBinarySolution(GenericBinarySolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (int i=0; i < problem.getNumberOfObjectives(); i++) {
    objectives.add(solution.getObjective(i));
  }
  variables=new ArrayList<>();
  for (  BinarySet var : solution.variables) {
    variables.add((BinarySet)var.clone());
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  numberOfViolatedConstraints=solution.numberOfViolatedConstraints;
  attributes=new HashMap(solution.attributes);
}",0.9378427787934186
64638,"/** 
 * Copy constructor 
 */
public GenericDoubleBinarySolution(GenericDoubleBinarySolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  copyDoubleVariables(solution);
  copyBitSet(solution);
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  attributes=new HashMap(solution.attributes);
}","/** 
 * Copy constructor 
 */
public GenericDoubleBinarySolution(GenericDoubleBinarySolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  copyDoubleVariables(solution);
  copyBitSet(solution);
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  numberOfViolatedConstraints=solution.numberOfViolatedConstraints;
  attributes=new HashMap(solution.attributes);
}",0.9271948608137044
64639,"/** 
 * Copy constructor 
 */
public GenericDoubleSolution(GenericDoubleSolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  variables=new ArrayList<>();
  for (  Double var : solution.variables) {
    variables.add(new Double(var));
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  attributes=new HashMap(solution.attributes);
}","/** 
 * Copy constructor 
 */
public GenericDoubleSolution(GenericDoubleSolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  variables=new ArrayList<>();
  for (  Double var : solution.variables) {
    variables.add(new Double(var));
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  numberOfViolatedConstraints=solution.numberOfViolatedConstraints;
  attributes=new HashMap(solution.attributes);
}",0.9337231968810916
64640,"/** 
 * Copy constructor 
 */
public GenericIntegerDoubleSolution(GenericIntegerDoubleSolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  variables=new ArrayList<>();
  for (int i=0; i < numberOfIntegerVariables; i++) {
    variables.add(new Integer((Integer)solution.getVariableValue(i)));
  }
  variables=new ArrayList<>();
  for (int i=numberOfIntegerVariables; i < (numberOfIntegerVariables + numberOfDoubleVariables); i++) {
    variables.add(new Double((Double)solution.getVariableValue(i)));
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  attributes=new HashMap(solution.attributes);
}","/** 
 * Copy constructor 
 */
public GenericIntegerDoubleSolution(GenericIntegerDoubleSolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  variables=new ArrayList<>();
  for (int i=0; i < numberOfIntegerVariables; i++) {
    variables.add(new Integer((Integer)solution.getVariableValue(i)));
  }
  variables=new ArrayList<>();
  for (int i=numberOfIntegerVariables; i < (numberOfIntegerVariables + numberOfDoubleVariables); i++) {
    variables.add(new Double((Double)solution.getVariableValue(i)));
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  numberOfViolatedConstraints=solution.numberOfViolatedConstraints;
  attributes=new HashMap(solution.attributes);
}",0.9563543003851092
64641,"/** 
 * Copy Constructor 
 */
public GenericIntegerPermutationSolution(GenericIntegerPermutationSolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  variables=new ArrayList<>();
  for (  List<Integer> var : solution.variables) {
    List<Integer> list=new ArrayList<>();
    for (    Integer element : var) {
      var.add(new Integer(element));
    }
    variables.add(list);
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  attributes=new HashMap(solution.attributes);
}","/** 
 * Copy Constructor 
 */
public GenericIntegerPermutationSolution(GenericIntegerPermutationSolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  variables=new ArrayList<>();
  for (  List<Integer> var : solution.variables) {
    List<Integer> list=new ArrayList<>();
    for (    Integer element : var) {
      var.add(new Integer(element));
    }
    variables.add(list);
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  numberOfViolatedConstraints=solution.numberOfViolatedConstraints;
  attributes=new HashMap(solution.attributes);
}",0.948170731707317
64642,"/** 
 * Copy constructor 
 */
public GenericIntegerSolution(GenericIntegerSolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  variables=new ArrayList<>();
  for (  Integer var : solution.variables) {
    variables.add(new Integer(var));
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  attributes=new HashMap(solution.attributes);
}","/** 
 * Copy constructor 
 */
public GenericIntegerSolution(GenericIntegerSolution solution){
  problem=solution.problem;
  objectives=new ArrayList<>();
  for (  Double obj : solution.objectives) {
    objectives.add(new Double(obj));
  }
  variables=new ArrayList<>();
  for (  Integer var : solution.variables) {
    variables.add(new Integer(var));
  }
  overallConstraintViolationDegree=solution.overallConstraintViolationDegree;
  numberOfViolatedConstraints=solution.numberOfViolatedConstraints;
  attributes=new HashMap(solution.attributes);
}",0.9342359767891684
64643,"/** 
 * Constructor 
 */
public Srinivas(){
  setNumberOfVariables(2);
  setNumberOfObjectives(2);
  setNumberOfConstraints(2);
  setName(""String_Node_Str"");
  List<Double> lowerLimit=new ArrayList<>(getNumberOfVariables());
  List<Double> upperLimit=new ArrayList<>(getNumberOfVariables());
  for (int i=0; i < getNumberOfVariables(); i++) {
    lowerLimit.add(-4.0);
    upperLimit.add(4.0);
  }
  setLowerLimit(lowerLimit);
  setUpperLimit(upperLimit);
}","/** 
 * Constructor 
 */
public Srinivas(){
  setNumberOfVariables(2);
  setNumberOfObjectives(2);
  setNumberOfConstraints(2);
  setName(""String_Node_Str"");
  List<Double> lowerLimit=new ArrayList<>(getNumberOfVariables());
  List<Double> upperLimit=new ArrayList<>(getNumberOfVariables());
  for (int i=0; i < getNumberOfVariables(); i++) {
    lowerLimit.add(-20.0);
    upperLimit.add(20.0);
  }
  setLowerLimit(lowerLimit);
  setUpperLimit(upperLimit);
}",0.9934497816593888
64644,"/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  DoubleProblem problem;
  Algorithm algorithm;
  MutationOperator mutation;
  String problemName=""String_Node_Str"";
  problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  Archive archive=new CrowdingDistanceArchive(100);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  algorithm=new SMPSO.Builder(problem,archive).setMutation(mutation).setMaxIterations(250).setSwarmSize(100).setRandomGenerator(new MersenneTwisterGenerator()).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=((SMPSO)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"" + JMetalRandom.getInstance().getSeed());
}","/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  DoubleProblem problem;
  Algorithm algorithm;
  MutationOperator mutation;
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
  }
 else {
    problemName=""String_Node_Str"";
  }
  problem=(DoubleProblem)ProblemUtils.loadProblem(problemName);
  Archive archive=new CrowdingDistanceArchive(100);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  algorithm=new SMPSO.Builder(problem,archive).setMutation(mutation).setMaxIterations(250).setSwarmSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<DoubleSolution> population=((SMPSO)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"" + JMetalRandom.getInstance().getSeed());
}",0.9624895804390108
64645,"public void EBEsInitialize(){
  setName(""String_Node_Str"");
  numberOfEval_=1;
  String file=EBEsReadProblems() + ""String_Node_Str"";
  try {
    EBEsReadDataFile(file);
  }
 catch (  JMetalException ex) {
    Logger.getLogger(Ebes.class.getName()).log(Level.SEVERE,null,ex);
  }
  Variable_Position();
  int numberOfConstraints=numberOfConstraintsGeometric_;
  numberOfConstraints+=numberOfGroupElements_ * 3;
  numberOfConstraints+=numberOfConstraintsNodes_;
  setNumberOfConstraints(numberOfConstraints);
  setNumberOfObjectives(OF_.length);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + file);
  System.out.println(""String_Node_Str"" + numberOfNodes);
  System.out.println(""String_Node_Str"" + numberOfElements_);
  System.out.println(""String_Node_Str"" + numberOfGroupElements_);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + getNumberOfObjectives());
  String txt=""String_Node_Str"";
  for (int i=0; i < getNumberOfObjectives(); i++) {
    txt=txt + OF_[i] + ""String_Node_Str"";
  }
  System.out.println(""String_Node_Str"" + txt);
  System.out.println(""String_Node_Str"" + getNumberOfVariables());
  System.out.println(""String_Node_Str"" + numberOfConstraintsGeometric_);
  System.out.println(""String_Node_Str"" + (numberOfGroupElements_ * 3));
  System.out.println(""String_Node_Str"" + numberOfConstraintsNodes_);
  System.out.println(""String_Node_Str"" + getNumberOfConstraints());
  System.out.println(""String_Node_Str"");
  double[] lowerLimit=new double[getNumberOfVariables()];
  double[] upperLimit=new double[getNumberOfVariables()];
  int var=0;
  for (int gr=0; gr < numberOfGroupElements_; gr++) {
    var+=Groups_[gr][VARIABLES];
    if (Groups_[gr][SHAPE] == CIRCLE) {
      lowerLimit[var - 1]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_Y_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == HOLE_CIRCLE) {
      lowerLimit[var - 2]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eY_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == RECTANGLE) {
      lowerLimit[var - 2]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_Z_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == HOLE_RECTANGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == I_SINGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == I_DOUBLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == H_SINGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == H_DOUBLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == L_SINGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == L_DOUBLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == T_SINGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == T_DOUBLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else {
      System.out.println(""String_Node_Str"" + gr + ""String_Node_Str"");
    }
  }
  elementsBetweenDiffGreat_=0;
  for (int ba=0; ba < numberOfElements_; ba++) {
    int i=(int)Element_[ba][i_];
    int j=(int)Element_[ba][j_];
    if (Math.abs(j - i) > elementsBetweenDiffGreat_) {
      elementsBetweenDiffGreat_=Math.abs(j - i);
    }
  }
  matrixWidthBand_=(elementsBetweenDiffGreat_ + 1) * numberOfLibertyDegree_;
}","public void EBEsInitialize(){
  setName(""String_Node_Str"");
  numberOfEval_=1;
  String file=EBEsReadProblems() + ""String_Node_Str"";
  try {
    EBEsReadDataFile(file);
  }
 catch (  JMetalException ex) {
    Logger.getLogger(Ebes.class.getName()).log(Level.SEVERE,null,ex);
  }
  Variable_Position();
  int numberOfConstraints=numberOfConstraintsGeometric_;
  numberOfConstraints+=numberOfGroupElements_ * 3;
  numberOfConstraints+=numberOfConstraintsNodes_;
  setNumberOfConstraints(numberOfConstraints);
  setNumberOfObjectives(OF_.length);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + file);
  System.out.println(""String_Node_Str"" + numberOfNodes);
  System.out.println(""String_Node_Str"" + numberOfElements_);
  System.out.println(""String_Node_Str"" + numberOfGroupElements_);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + getNumberOfObjectives());
  String txt=""String_Node_Str"";
  for (int i=0; i < getNumberOfObjectives(); i++) {
    txt=txt + OF_[i] + ""String_Node_Str"";
  }
  System.out.println(""String_Node_Str"" + txt);
  System.out.println(""String_Node_Str"" + getNumberOfVariables());
  System.out.println(""String_Node_Str"" + numberOfConstraintsGeometric_);
  System.out.println(""String_Node_Str"" + (numberOfGroupElements_ * 3));
  System.out.println(""String_Node_Str"" + numberOfConstraintsNodes_);
  System.out.println(""String_Node_Str"" + getNumberOfConstraints());
  System.out.println(""String_Node_Str"");
  Double[] lowerLimit=new Double[getNumberOfVariables()];
  Double[] upperLimit=new Double[getNumberOfVariables()];
  int var=0;
  for (int gr=0; gr < numberOfGroupElements_; gr++) {
    var+=Groups_[gr][VARIABLES];
    if (Groups_[gr][SHAPE] == CIRCLE) {
      lowerLimit[var - 1]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_Y_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == HOLE_CIRCLE) {
      lowerLimit[var - 2]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eY_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == RECTANGLE) {
      lowerLimit[var - 2]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_Z_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == HOLE_RECTANGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == I_SINGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == I_DOUBLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == H_SINGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == H_DOUBLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == L_SINGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == L_DOUBLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == T_SINGLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else     if (Groups_[gr][SHAPE] == T_DOUBLE) {
      lowerLimit[var - 4]=Groups_[gr][VAR_Y_LOWER_LIMIT];
      lowerLimit[var - 3]=Groups_[gr][VAR_Z_LOWER_LIMIT];
      lowerLimit[var - 2]=Groups_[gr][VAR_eY_LOWER_LIMIT];
      lowerLimit[var - 1]=Groups_[gr][VAR_eZ_LOWER_LIMIT];
      upperLimit[var - 4]=Groups_[gr][VAR_Y_UPPER_LIMIT];
      upperLimit[var - 3]=Groups_[gr][VAR_Z_UPPER_LIMIT];
      upperLimit[var - 2]=Groups_[gr][VAR_eY_UPPER_LIMIT];
      upperLimit[var - 1]=Groups_[gr][VAR_eZ_UPPER_LIMIT];
    }
 else {
      System.out.println(""String_Node_Str"" + gr + ""String_Node_Str"");
    }
  }
  setLowerLimit(new ArrayList(Arrays.<Double>asList(lowerLimit)));
  setUpperLimit(new ArrayList(Arrays.<Double>asList(upperLimit)));
  elementsBetweenDiffGreat_=0;
  for (int ba=0; ba < numberOfElements_; ba++) {
    int i=(int)Element_[ba][i_];
    int j=(int)Element_[ba][j_];
    if (Math.abs(j - i) > elementsBetweenDiffGreat_) {
      elementsBetweenDiffGreat_=Math.abs(j - i);
    }
  }
  matrixWidthBand_=(elementsBetweenDiffGreat_ + 1) * numberOfLibertyDegree_;
}",0.9907116692830978
64646,"protected List<Solution> crowdingDistanceSelection(Ranking ranking){
  CrowdingDistance crowdingDistance=new CrowdingDistance();
  List<Solution> population=new ArrayList<>(solutionsToSelect);
  int rankingIndex=0;
  while (population.size() <= solutionsToSelect) {
    if (subfrontFillsIntoThePopulation(ranking,rankingIndex,population)) {
      addRankedSolutionsToPopulation(ranking,rankingIndex,population);
      rankingIndex++;
    }
 else {
      crowdingDistance.computeDensityEstimator(ranking.getSubfront(rankingIndex));
      addLastRankedSolutionsToPopulation(ranking,rankingIndex,population);
    }
  }
  return population;
}","protected List<Solution> crowdingDistanceSelection(Ranking ranking){
  CrowdingDistance crowdingDistance=new CrowdingDistance();
  List<Solution> population=new ArrayList<>(solutionsToSelect);
  int rankingIndex=0;
  while (population.size() < solutionsToSelect) {
    if (subfrontFillsIntoThePopulation(ranking,rankingIndex,population)) {
      addRankedSolutionsToPopulation(ranking,rankingIndex,population);
      rankingIndex++;
    }
 else {
      crowdingDistance.computeDensityEstimator(ranking.getSubfront(rankingIndex));
      addLastRankedSolutionsToPopulation(ranking,rankingIndex,population);
    }
  }
  return population;
}",0.99921568627451
64647,"/** 
 * Constructor 
 */
public DominanceComparator(){
  constraintViolationComparator=new OverallConstraintViolationComparator();
}","/** 
 * Constructor 
 */
public DominanceComparator(ConstraintViolationComparator constraintComparator){
  constraintViolationComparator=constraintComparator;
}",0.7465753424657534
64648,"@Override public List<S> evaluate(List<S> solutionList,Problem problem) throws JMetalException {
  try {
    for (int i=0; i < solutionList.size(); i++) {
      problem.evaluate(solutionList.get(i));
    }
  }
 catch (  JMetalException e) {
    JMetalLogger.logger.log(Level.SEVERE,""String_Node_Str"",e);
    throw new JMetalException(""String_Node_Str"");
  }
  return solutionList;
}","@Override public List<S> evaluate(List<S> solutionList,Problem problem) throws JMetalException {
  try {
    if (problem instanceof ConstrainedProblem) {
      for (int i=0; i < solutionList.size(); i++) {
        problem.evaluate(solutionList.get(i));
        ((ConstrainedProblem)problem).evaluateConstraints(solutionList.get(i));
      }
    }
 else {
      for (int i=0; i < solutionList.size(); i++) {
        problem.evaluate(solutionList.get(i));
      }
    }
  }
 catch (  JMetalException e) {
    JMetalLogger.logger.log(Level.SEVERE,""String_Node_Str"",e);
    throw new JMetalException(""String_Node_Str"");
  }
  return solutionList;
}",0.7446393762183235
64649,"/** 
 * @param args Command line arguments.
 * @throws java.io.IOException
 * @throws SecurityException
 * @throws ClassNotFoundException Usage: three options - org.uma.jmetal.runner.multiobjective.NSGAIIRunner - org.uma.jmetal.runner.multiobjective.NSGAIIRunner problemName - org.uma.jmetal.runner.multiobjective.NSGAIIRunner problemName paretoFrontFile
 */
public static void main(String[] args) throws JMetalException {
  Problem problem;
  Algorithm algorithm;
  CrossoverOperator crossover;
  MutationOperator mutation;
  SelectionOperator selection;
  String problemName=""String_Node_Str"";
  problem=ProblemUtils.loadProblem(problemName);
  double crossoverProbability=0.9;
  double crossoverDistributionIndex=20.0;
  crossover=new SBXCrossover(crossoverProbability,crossoverDistributionIndex);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  selection=new BinaryTournamentSelection();
  algorithm=new NSGAIIBuilder(problem).setCrossoverOperator(crossover).setMutationOperator(mutation).setSelectionOperator(selection).setMaxIterations(250).setPopulationSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<Solution> population=((NSGAII)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}","/** 
 * @param args Command line arguments.
 * @throws java.io.IOException
 * @throws SecurityException
 * @throws ClassNotFoundException Usage: three options - org.uma.jmetal.runner.multiobjective.NSGAIIRunner - org.uma.jmetal.runner.multiobjective.NSGAIIRunner problemName - org.uma.jmetal.runner.multiobjective.NSGAIIRunner problemName paretoFrontFile
 */
public static void main(String[] args) throws JMetalException {
  Problem problem;
  Algorithm algorithm;
  CrossoverOperator crossover;
  MutationOperator mutation;
  SelectionOperator selection;
  String problemName;
  if (args.length == 1) {
    problemName=args[0];
  }
 else {
    problemName=""String_Node_Str"";
  }
  problem=ProblemUtils.loadProblem(problemName);
  double crossoverProbability=0.9;
  double crossoverDistributionIndex=20.0;
  crossover=new SBXCrossover(crossoverProbability,crossoverDistributionIndex);
  double mutationProbability=1.0 / problem.getNumberOfVariables();
  double mutationDistributionIndex=20.0;
  mutation=new PolynomialMutation(mutationProbability,mutationDistributionIndex);
  selection=new BinaryTournamentSelection();
  algorithm=new NSGAIIBuilder(problem).setCrossoverOperator(crossover).setMutationOperator(mutation).setSelectionOperator(selection).setMaxIterations(250).setPopulationSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<Solution> population=((NSGAII)algorithm).getResult();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}",0.9776238678742676
64650,"/** 
 * Perform the crossover operation.
 * @param probability Crossover setProbability
 * @param parent1     The first parent
 * @param parent2     The second parent
 * @return An array containing the two offspring
 */
public List<BinarySolution> doCrossover(double probability,BinarySolution parent1,BinarySolution parent2){
  List<BinarySolution> offspring=new ArrayList<>(2);
  offspring.add((BinarySolution)parent1.copy());
  offspring.add((BinarySolution)parent2.copy());
  if (randomGenerator.nextDouble() < probability) {
    int totalNumberOfBits=parent1.getTotalNumberOfBits();
    int crossoverPoint=randomGenerator.nextInt(0,totalNumberOfBits - 1);
    int variable=0;
    int bitsAccount=parent1.getVariableValue(variable).getBinarySetLength();
    while (bitsAccount < (crossoverPoint + 1)) {
      variable++;
      bitsAccount+=parent1.getVariableValue(variable).getBinarySetLength();
    }
    int diff=bitsAccount - crossoverPoint;
    int intoVariableCrossoverPoint=parent1.getVariableValue(variable).getBinarySetLength() - diff;
    BinarySet offspring1, offspring2;
    offspring1=(BinarySet)parent1.getVariableValue(variable).clone();
    offspring2=(BinarySet)parent1.getVariableValue(variable).clone();
    for (int i=intoVariableCrossoverPoint; i < offspring1.getBinarySetLength(); i++) {
      boolean swap=offspring1.get(i);
      offspring1.set(i,offspring2.get(i));
      offspring2.set(i,swap);
    }
    offspring.get(0).setVariableValue(variable,offspring1);
    offspring.get(1).setVariableValue(variable,offspring2);
    for (int i=0; i < variable; i++) {
      offspring.get(0).setVariableValue(i,parent2.getVariableValue(i));
      offspring.get(1).setVariableValue(i,parent1.getVariableValue(i));
    }
  }
  return offspring;
}","/** 
 * Perform the crossover operation.
 * @param probability Crossover setProbability
 * @param parent1     The first parent
 * @param parent2     The second parent
 * @return An array containing the two offspring
 */
public List<BinarySolution> doCrossover(double probability,BinarySolution parent1,BinarySolution parent2){
  List<BinarySolution> offspring=new ArrayList<>(2);
  offspring.add((BinarySolution)parent1.copy());
  offspring.add((BinarySolution)parent2.copy());
  if (randomGenerator.nextDouble() < probability) {
    int totalNumberOfBits=parent1.getTotalNumberOfBits();
    int crossoverPoint=randomGenerator.nextInt(0,totalNumberOfBits - 1);
    int variable=0;
    int bitsAccount=parent1.getVariableValue(variable).getBinarySetLength();
    while (bitsAccount < (crossoverPoint + 1)) {
      variable++;
      bitsAccount+=parent1.getVariableValue(variable).getBinarySetLength();
    }
    int diff=bitsAccount - crossoverPoint;
    int intoVariableCrossoverPoint=parent1.getVariableValue(variable).getBinarySetLength() - diff;
    BinarySet offspring1, offspring2;
    offspring1=(BinarySet)parent1.getVariableValue(variable).clone();
    offspring2=(BinarySet)parent2.getVariableValue(variable).clone();
    for (int i=intoVariableCrossoverPoint; i < offspring1.getBinarySetLength(); i++) {
      boolean swap=offspring1.get(i);
      offspring1.set(i,offspring2.get(i));
      offspring2.set(i,swap);
    }
    offspring.get(0).setVariableValue(variable,offspring1);
    offspring.get(1).setVariableValue(variable,offspring2);
    for (int i=variable + 1; i < parent1.getNumberOfVariables(); i++) {
      offspring.get(0).setVariableValue(i,parent2.getVariableValue(i));
      offspring.get(1).setVariableValue(i,parent1.getVariableValue(i));
    }
  }
  return offspring;
}",0.9851248947516138
64651,"@Override public int nextInt(int lowerBound,int upperBound){
  return lowerBound + rnd.nextInt((upperBound - lowerBound));
}","@Override public int nextInt(int lowerBound,int upperBound){
  return lowerBound + rnd.nextInt((upperBound - lowerBound) + 1);
}",0.984126984126984
64652,"@Override public int nextInt(int lowerBound,int upperBound){
  return lowerBound + rnd.nextInt((upperBound - lowerBound));
}","@Override public int nextInt(int lowerBound,int upperBound){
  return lowerBound + rnd.nextInt((upperBound - lowerBound) + 1);
}",0.984126984126984
64653,"@Override public int nextInt(int lowerBound,int upperBound){
  return lowerBound + rnd.nextInt((upperBound - lowerBound));
}","@Override public int nextInt(int lowerBound,int upperBound){
  return lowerBound + rnd.nextInt((upperBound - lowerBound) + 1);
}",0.984126984126984
64654,"@Override protected List<Solution> replacement(List<Solution> population,List<Solution> offspringPopulation){
  List<Solution> jointPopulation=new ArrayList<>();
  jointPopulation.addAll(population);
  jointPopulation.addAll(offspringPopulation);
  Ranking ranking=computeRanking(jointPopulation);
  List<Solution> pop=new ArrayList<>();
  List<List<Solution>> fronts=new ArrayList<>();
  int rankingIndex=0;
  int candidateSolutions=0;
  while (candidateSolutions < populationSize) {
    fronts.add(ranking.getSubfront(rankingIndex));
    candidateSolutions+=ranking.getSubfront(rankingIndex).size();
    if ((pop.size() + ranking.getSubfront(rankingIndex).size()) <= populationSize)     addRankedSolutionsToPopulation(ranking,rankingIndex,population);
    rankingIndex++;
  }
  EnvironmentalSelection selection=new EnvironmentalSelection.Builder().setNumberOfObjectives(problem.getNumberOfObjectives()).setFronts(fronts).setSolutionsToSelect(populationSize).setReferencePoints(getReferencePointsCopy()).build();
  pop=selection.execute(pop);
  return pop;
}","@Override protected List<Solution> replacement(List<Solution> population,List<Solution> offspringPopulation){
  List<Solution> jointPopulation=new ArrayList<>();
  jointPopulation.addAll(population);
  jointPopulation.addAll(offspringPopulation);
  Ranking ranking=computeRanking(jointPopulation);
  List<Solution> pop=new ArrayList<>();
  List<List<Solution>> fronts=new ArrayList<>();
  int rankingIndex=0;
  int candidateSolutions=0;
  while (candidateSolutions < populationSize) {
    fronts.add(ranking.getSubfront(rankingIndex));
    candidateSolutions+=ranking.getSubfront(rankingIndex).size();
    if ((pop.size() + ranking.getSubfront(rankingIndex).size()) <= populationSize)     addRankedSolutionsToPopulation(ranking,rankingIndex,pop);
    rankingIndex++;
  }
  EnvironmentalSelection selection=new EnvironmentalSelection.Builder().setNumberOfObjectives(problem.getNumberOfObjectives()).setFronts(fronts).setSolutionsToSelect(populationSize).setReferencePoints(getReferencePointsCopy()).build();
  pop=selection.execute(pop);
  return pop;
}",0.9966840360018948
64655,"int FindNicheReferencePoint(){
  int min_size=Integer.MAX_VALUE;
  System.out.println(this.referencePoints.size());
  for (int r=0; r < this.referencePoints.size(); r+=1) {
    min_size=Math.min(min_size,this.referencePoints.get(r).MemberSize());
  }
  List<Integer> min_rps=new ArrayList<>();
  for (int r=0; r < this.referencePoints.size(); r+=1) {
    if (this.referencePoints.get(r).MemberSize() == min_size) {
      min_rps.add(r);
    }
  }
  System.out.println(min_rps.size());
  return min_rps.get(min_rps.size() > 1 ? JMetalRandom.getInstance().nextInt(0,min_rps.size() - 1) : 0);
}","int FindNicheReferencePoint(){
  int min_size=Integer.MAX_VALUE;
  for (int r=0; r < this.referencePoints.size(); r+=1) {
    min_size=Math.min(min_size,this.referencePoints.get(r).MemberSize());
  }
  List<Integer> min_rps=new ArrayList<>();
  for (int r=0; r < this.referencePoints.size(); r+=1) {
    if (this.referencePoints.get(r).MemberSize() == min_size) {
      min_rps.add(r);
    }
  }
  return min_rps.get(min_rps.size() > 1 ? JMetalRandom.getInstance().nextInt(0,min_rps.size() - 1) : 0);
}",0.918572735590119
64656,"/** 
 * Evaluate() method 
 */
public void evaluate(DoubleSolution solution){
  double[] f=new double[getNumberOfObjectives()];
  double[] x=new double[getNumberOfVariables()];
  int k=getNumberOfVariables() - getNumberOfObjectives() + 1;
  double g=0.0;
  for (int i=getNumberOfVariables() - k; i < getNumberOfVariables(); i++) {
    g+=(x[i] - 0.5) * (x[i] - 0.5) - Math.cos(20.0 * Math.PI * (x[i] - 0.5));
  }
  g=100 * (k + g);
  for (int i=0; i < getNumberOfObjectives(); i++) {
    f[i]=(1.0 + g) * 0.5;
  }
  for (int i=0; i < getNumberOfObjectives(); i++) {
    for (int j=0; j < getNumberOfObjectives() - (i + 1); j++) {
      f[i]*=x[j];
    }
    if (i != 0) {
      int aux=getNumberOfObjectives() - (i + 1);
      f[i]*=1 - x[aux];
    }
  }
  for (int i=0; i < getNumberOfObjectives(); i++) {
    solution.setObjective(i,f[i]);
  }
}","/** 
 * Evaluate() method 
 */
public void evaluate(DoubleSolution solution){
  int numberOfVariables=getNumberOfVariables();
  int numberOfObjectives=getNumberOfObjectives();
  double[] f=new double[numberOfObjectives];
  double[] x=new double[numberOfVariables];
  int k=getNumberOfVariables() - getNumberOfObjectives() + 1;
  for (int i=0; i < numberOfVariables; i++) {
    x[i]=solution.getVariableValue(i);
  }
  double g=0.0;
  for (int i=numberOfVariables - k; i < numberOfVariables; i++) {
    g+=(x[i] - 0.5) * (x[i] - 0.5) - Math.cos(20.0 * Math.PI * (x[i] - 0.5));
  }
  g=100 * (k + g);
  for (int i=0; i < numberOfObjectives; i++) {
    f[i]=(1.0 + g) * 0.5;
  }
  for (int i=0; i < numberOfObjectives; i++) {
    for (int j=0; j < numberOfObjectives - (i + 1); j++) {
      f[i]*=x[j];
    }
    if (i != 0) {
      int aux=numberOfObjectives - (i + 1);
      f[i]*=1 - x[aux];
    }
  }
  for (int i=0; i < numberOfObjectives; i++) {
    solution.setObjective(i,f[i]);
  }
}",0.3758169934640523
64657,"/** 
 * Evaluate() method 
 */
public void evaluate(DoubleSolution solution){
  int numberOfVariables=getNumberOfVariables();
  int numberOfObjectives=getNumberOfObjectives();
  double[] f=new double[numberOfObjectives];
  double[] x=new double[numberOfVariables];
  int k=getNumberOfVariables() - getNumberOfObjectives() + 1;
  double g=0.0;
  for (int i=numberOfVariables - k; i < numberOfVariables; i++) {
    g+=(x[i] - 0.5) * (x[i] - 0.5);
  }
  for (int i=0; i < numberOfObjectives; i++) {
    f[i]=1.0 + g;
  }
  for (int i=0; i < numberOfObjectives; i++) {
    for (int j=0; j < numberOfObjectives - (i + 1); j++) {
      f[i]*=Math.cos(x[j] * 0.5 * Math.PI);
    }
    if (i != 0) {
      int aux=numberOfObjectives - (i + 1);
      f[i]*=Math.sin(x[aux] * 0.5 * Math.PI);
    }
  }
  for (int i=0; i < numberOfObjectives; i++) {
    solution.setObjective(i,f[i]);
  }
}","/** 
 * Evaluate() method 
 */
public void evaluate(DoubleSolution solution){
  int numberOfVariables=getNumberOfVariables();
  int numberOfObjectives=getNumberOfObjectives();
  double[] f=new double[numberOfObjectives];
  double[] x=new double[numberOfVariables];
  for (int i=0; i < numberOfVariables; i++) {
    x[i]=solution.getVariableValue(i);
  }
  int k=getNumberOfVariables() - getNumberOfObjectives() + 1;
  double g=0.0;
  for (int i=numberOfVariables - k; i < numberOfVariables; i++) {
    g+=(x[i] - 0.5) * (x[i] - 0.5);
  }
  for (int i=0; i < numberOfObjectives; i++) {
    f[i]=1.0 + g;
  }
  for (int i=0; i < numberOfObjectives; i++) {
    for (int j=0; j < numberOfObjectives - (i + 1); j++) {
      f[i]*=Math.cos(x[j] * 0.5 * Math.PI);
    }
    if (i != 0) {
      int aux=numberOfObjectives - (i + 1);
      f[i]*=Math.sin(x[aux] * 0.5 * Math.PI);
    }
  }
  for (int i=0; i < numberOfObjectives; i++) {
    solution.setObjective(i,f[i]);
  }
}",0.9518137520303196
64658,"/** 
 * Evaluate() method 
 */
public void evaluate(DoubleSolution solution){
  int numberOfVariables=getNumberOfVariables();
  int numberOfObjectives=getNumberOfObjectives();
  double[] f=new double[numberOfObjectives];
  double[] x=new double[numberOfVariables];
  int k=getNumberOfVariables() - getNumberOfObjectives() + 1;
  double g=0.0;
  for (int i=numberOfVariables - k; i < numberOfVariables; i++) {
    g+=(x[i] - 0.5) * (x[i] - 0.5) - Math.cos(20.0 * Math.PI * (x[i] - 0.5));
  }
  g=100.0 * (k + g);
  for (int i=0; i < numberOfObjectives; i++) {
    f[i]=1.0 + g;
  }
  for (int i=0; i < numberOfObjectives; i++) {
    for (int j=0; j < numberOfObjectives - (i + 1); j++) {
      f[i]*=java.lang.Math.cos(x[j] * 0.5 * java.lang.Math.PI);
    }
    if (i != 0) {
      int aux=numberOfObjectives - (i + 1);
      f[i]*=java.lang.Math.sin(x[aux] * 0.5 * java.lang.Math.PI);
    }
  }
  for (int i=0; i < numberOfObjectives; i++) {
    solution.setObjective(i,f[i]);
  }
}","/** 
 * Evaluate() method 
 */
public void evaluate(DoubleSolution solution){
  int numberOfVariables=getNumberOfVariables();
  int numberOfObjectives=getNumberOfObjectives();
  double[] f=new double[numberOfObjectives];
  double[] x=new double[numberOfVariables];
  for (int i=0; i < numberOfVariables; i++) {
    x[i]=solution.getVariableValue(i);
  }
  int k=getNumberOfVariables() - getNumberOfObjectives() + 1;
  double g=0.0;
  for (int i=numberOfVariables - k; i < numberOfVariables; i++) {
    g+=(x[i] - 0.5) * (x[i] - 0.5) - Math.cos(20.0 * Math.PI * (x[i] - 0.5));
  }
  g=100.0 * (k + g);
  for (int i=0; i < numberOfObjectives; i++) {
    f[i]=1.0 + g;
  }
  for (int i=0; i < numberOfObjectives; i++) {
    for (int j=0; j < numberOfObjectives - (i + 1); j++) {
      f[i]*=java.lang.Math.cos(x[j] * 0.5 * java.lang.Math.PI);
    }
    if (i != 0) {
      int aux=numberOfObjectives - (i + 1);
      f[i]*=java.lang.Math.sin(x[aux] * 0.5 * java.lang.Math.PI);
    }
  }
  for (int i=0; i < numberOfObjectives; i++) {
    solution.setObjective(i,f[i]);
  }
}",0.956648806624452
64659,"@Override public String getVariableValueString(int index){
  String result=""String_Node_Str"";
  for (  BitSet var : variables) {
    for (int i=0; i < var.size(); i++) {
      if (var.get(i)) {
        result+=""String_Node_Str"";
      }
 else {
        result+=""String_Node_Str"";
      }
    }
    result+=""String_Node_Str"";
  }
  return result;
}","@Override public String getVariableValueString(int index){
  String result=""String_Node_Str"";
  for (  BitSet var : variables) {
    for (int i=0; i < problem.getNumberOfBits(i); i++) {
      if (var.get(i)) {
        result+=""String_Node_Str"";
      }
 else {
        result+=""String_Node_Str"";
      }
    }
    result+=""String_Node_Str"";
  }
  return result;
}",0.4366197183098591
64660,"/** 
 * Constructor 
 */
private NSGAIII(Builder builder){
  problem=builder.problem;
  maxIterations=builder.maxIterations;
  populationSize=builder.populationSize;
  crossoverOperator=builder.crossoverOperator;
  mutationOperator=builder.mutationOperator;
  selectionOperator=builder.selectionOperator;
  evaluator=builder.evaluator;
  numberOfDivisions=new Vector<>(1);
  numberOfDivisions.add(12);
  Vector<ReferencePoint> referencePoints=new Vector<>();
  ReferencePoint.generateReferencePoints(referencePoints,3,numberOfDivisions);
  System.out.println(""String_Node_Str"" + referencePoints.size());
  System.out.println(""String_Node_Str"" + referencePoints.size());
  for (int i=0; i < referencePoints.size(); i++) {
    System.out.println(referencePoints.get(i).position.size());
    for (int j=0; j < referencePoints.get(i).position.size(); j++) {
      System.out.println(""String_Node_Str"" + referencePoints.get(i).position.get(j));
    }
  }
}","/** 
 * Constructor 
 */
private NSGAIII(Builder builder){
  problem=builder.problem;
  maxIterations=builder.maxIterations;
  populationSize=builder.populationSize;
  crossoverOperator=builder.crossoverOperator;
  mutationOperator=builder.mutationOperator;
  selectionOperator=builder.selectionOperator;
  evaluator=builder.evaluator;
  numberOfDivisions=new Vector<>(1);
  numberOfDivisions.add(12);
  Vector<ReferencePoint> referencePoints=new Vector<>();
  ReferencePoint.generateReferencePoints(referencePoints,3,numberOfDivisions);
  System.out.println(""String_Node_Str"" + referencePoints.size());
  System.out.println(""String_Node_Str"" + referencePoints.size());
  for (int i=0; i < referencePoints.size(); i++) {
    System.out.println(referencePoints.get(i).position.length);
    for (int j=0; j < referencePoints.get(i).position.length; j++) {
      System.out.println(""String_Node_Str"" + referencePoints.get(i).position[j]);
    }
  }
}",0.9831401475237092
64661,"private static void generateRecursive(Vector<ReferencePoint> referencePoints,ReferencePoint refPoint,int numberOfObjectives,int left,int total,int element){
  if (element == (numberOfObjectives - 1)) {
    refPoint.position.add(element,0.0);
    refPoint.position.add(element,(double)left / total);
    referencePoints.add(refPoint);
  }
 else {
    for (int i=0; i <= left; i+=1) {
      refPoint.position.add(element,0.0);
      refPoint.position.set(element,(double)i / total);
      generateRecursive(referencePoints,refPoint,numberOfObjectives,left - i,total,element + 1);
    }
  }
}","private static void generateRecursive(Vector<ReferencePoint> referencePoints,ReferencePoint refPoint,int numberOfObjectives,int left,int total,int element){
  if (element == (numberOfObjectives - 1)) {
    refPoint.position[element]=(double)left / total;
    referencePoints.add(new ReferencePoint(refPoint));
  }
 else {
    for (int i=0; i <= left; i+=1) {
      refPoint.position[element]=(double)i / total;
      generateRecursive(referencePoints,refPoint,numberOfObjectives,left - i,total,element + 1);
    }
  }
}",0.5018050541516246
64662,"/** 
 * Constructor 
 */
public ReferencePoint(int size){
  position=new Vector<>(size);
  memberSize=0;
}","public ReferencePoint(ReferencePoint point){
  position=Arrays.copyOfRange(point.position,0,point.position.length);
}",0.4663677130044843
64663,"private JMetalRandom(){
  randomGenerator=new JavaRandomGenerator();
}","private JMetalRandom(){
  randomGenerator=new ApacheRandomUtilsGenerator();
}",0.91156462585034
64664,"@Override public int nextInt(int lowerBound,int upperBound){
  return RandomUtils.nextInt(lowerBound,upperBound);
}","@Override public int nextInt(int lowerBound,int upperBound){
  int randomValue=RandomUtils.nextInt(0,upperBound - lowerBound);
  return lowerBound + randomValue;
}",0.7194244604316546
64665,"@Override public int nextInt(int lowerBound,int upperBound){
  return lowerBound + rnd.nextInt() * (upperBound - lowerBound);
}","@Override public int nextInt(int lowerBound,int upperBound){
  return lowerBound + rnd.nextInt((upperBound - lowerBound));
}",0.9800796812749004
64666,"/** 
 * calculates the hypervolume of that portion of the objective space that is dominated by individual a but not by individual b
 */
double calculateHypervolumeIndicator(Solution solutionA,Solution solutionB,int d,double maximumValues[],double minimumValues[]){
  double a, b, r, max;
  double volume=0;
  double rho=2.0;
  r=rho * (maximumValues[d - 1] - minimumValues[d - 1]);
  max=minimumValues[d - 1] + r;
  a=solutionA.getObjective(d - 1);
  if (solutionB == null) {
    b=max;
  }
 else {
    b=solutionB.getObjective(d - 1);
  }
  if (d == 1) {
    if (a < b) {
      volume=(b - a) / r;
    }
 else {
      volume=0;
    }
  }
 else {
    if (a < b) {
      volume=calculateHypervolumeIndicator(solutionA,null,d - 1,maximumValues,minimumValues) * (b - a) / r;
      volume+=calculateHypervolumeIndicator(solutionA,solutionB,d - 1,maximumValues,minimumValues) * (max - b) / r;
    }
 else {
      volume=calculateHypervolumeIndicator(solutionA,solutionB,d - 1,maximumValues,minimumValues) * (max - b) / r;
    }
  }
  return (volume);
}","/** 
 * calculates the hypervolume of that portion of the objective space that is dominated by individual a but not by individual b
 */
double calculateHypervolumeIndicator(Solution solutionA,Solution solutionB,int d,double maximumValues[],double minimumValues[]){
  double a, b, r, max;
  double volume=0;
  double rho=2.0;
  r=rho * (maximumValues[d - 1] - minimumValues[d - 1]);
  max=minimumValues[d - 1] + r;
  a=solutionA.getObjective(d - 1);
  if (solutionB == null) {
    b=max;
  }
 else {
    b=solutionB.getObjective(d - 1);
  }
  if (d == 1) {
    if (a < b) {
      volume=(b - a) / r;
    }
 else {
      volume=0;
    }
  }
 else {
    if (a < b) {
      volume=calculateHypervolumeIndicator(solutionA,null,d - 1,maximumValues,minimumValues) * (b - a) / r;
      volume+=calculateHypervolumeIndicator(solutionA,solutionB,d - 1,maximumValues,minimumValues) * (max - b) / r;
    }
 else {
      volume=calculateHypervolumeIndicator(solutionA,solutionB,d - 1,maximumValues,minimumValues) * (max - a) / r;
    }
  }
  return (volume);
}",0.9990448901623686
64667,"@Override public boolean add(Solution<?> solution){
  int flag;
  int i=0;
  Solution aux;
  while (i < solutionSet.size()) {
    aux=solutionSet.get(i);
    flag=dominanceComparator.compare(solution,aux);
    if (flag == 1) {
      return false;
    }
 else     if (flag == -1) {
      solutionSet.remove(i);
    }
 else {
      return false;
    }
    i++;
  }
  solutionSet.add(solution);
  if (solutionSet.size() > maxSize) {
    crowdingDistance.computeCrowdingDistance(solutionSet);
    int index=FindWorstSolution.find(solutionSet,crowdingDistanceComparator);
    solutionSet.remove(index);
  }
  return true;
}","@Override public boolean add(Solution<?> solution){
  int flag;
  int i=0;
  Solution aux;
  while (i < solutionSet.size()) {
    aux=solutionSet.get(i);
    flag=dominanceComparator.compare(solution,aux);
    if (flag == 1) {
      return false;
    }
 else     if (flag == -1) {
      solutionSet.remove(i);
    }
 else {
      if (equalsComparator.compare(aux,solution) == 0) {
        return false;
      }
    }
    i++;
  }
  solutionSet.add(solution);
  if (solutionSet.size() > maxSize) {
    crowdingDistance.computeCrowdingDistance(solutionSet);
    int index=FindWorstSolution.find(solutionSet,crowdingDistanceComparator);
    solutionSet.remove(index);
  }
  return true;
}",0.928626247122026
64668,"public CrowdingDistanceArchive(int maxSize){
  this.maxSize=maxSize;
  solutionSet=new ArrayList<>(maxSize + 1);
  dominanceComparator=new DominanceComparator();
  crowdingDistanceComparator=new CrowdingDistanceComparator();
  crowdingDistance=new CrowdingDistanceImpl();
}","public CrowdingDistanceArchive(int maxSize){
  this.maxSize=maxSize;
  solutionSet=new ArrayList<>(maxSize + 1);
  dominanceComparator=new DominanceComparator();
  crowdingDistanceComparator=new CrowdingDistanceComparator();
  crowdingDistance=new CrowdingDistanceImpl();
  equalsComparator=new EqualSolutionsComparator();
}",0.914572864321608
64669,"/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  ContinuousProblem problem;
  Algorithm algorithm;
  MutationOperator mutation;
  problem=new Kursawe(3);
  Archive archive=new CrowdingDistanceArchive(100);
  mutation=new PolynomialMutation.Builder().setDistributionIndex(20.0).setProbability(1.0 / problem.getNumberOfVariables()).build();
  algorithm=new SMPSO.Builder(problem,archive).setMutation(mutation).setMaxIterations(250).setSwarmSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<Solution> population=algorithmRunner.getSolutionSet();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}","/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  ContinuousProblem problem;
  Algorithm algorithm;
  MutationOperator mutation;
  problem=new Fonseca();
  Archive archive=new CrowdingDistanceArchive(100);
  mutation=new PolynomialMutation.Builder().setDistributionIndex(20.0).setProbability(1.0 / problem.getNumberOfVariables()).build();
  algorithm=new SMPSO.Builder(problem,archive).setMutation(mutation).setMaxIterations(250).setSwarmSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<Solution> population=algorithmRunner.getSolutionSet();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}",0.9943727242634888
64670,"/** 
 * Execute() method  
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException, IOException {
  initialization();
  createInitialSwarm();
  evaluateSwarm();
  initializeLeaders();
  initializeParticlesMemory();
  updateLeadersDensityEstimator();
  while (!stoppingCondition()) {
    computeSpeed(iterations,maxIterations);
    computeNewPositions();
    perturbation();
    evaluateSwarm();
    updateLeaders();
    updateParticleMemory();
    updateLeadersDensityEstimator();
    iterations++;
  }
  tearDown();
  return paretoFrontApproximation();
}","/** 
 * Execute() method  
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException, IOException {
  initialization();
  createInitialSwarm();
  evaluateSwarm();
  initializeLeaders();
  initializeParticlesMemory();
  updateLeadersDensityEstimator();
  while (!stoppingCondition()) {
    computeSpeed(iterations,maxIterations);
    computeNewPositions();
    evaluateSwarm();
    updateLeaders();
    updateParticleMemory();
    updateLeadersDensityEstimator();
    iterations++;
  }
  tearDown();
  return paretoFrontApproximation();
}",0.9824253075571178
64671,"protected void computeNewPositions(){
  for (int i=0; i < swarmSize; i++) {
    XReal particle=new XReal(swarm.get(i));
    for (int var=0; var < particle.getNumberOfDecisionVariables(); var++) {
      particle.setValue(var,particle.getValue(var) + speed[i][var]);
      if (particle.getValue(var) < problem.getLowerLimit(var)) {
        particle.setValue(var,problem.getLowerLimit(var));
        speed[i][var]=speed[i][var] * changeVelocity1;
      }
      if (particle.getValue(var) > problem.getUpperLimit(var)) {
        particle.setValue(var,problem.getUpperLimit(var));
        speed[i][var]=speed[i][var] * changeVelocity2;
      }
    }
  }
}","protected void computeNewPositions(){
  for (int i=0; i < swarmSize; i++) {
    XReal particle=new XReal(swarm.get(i));
    for (int j=0; j < particle.getNumberOfDecisionVariables(); j++) {
      double v=particle.getValue(j);
      particle.setValue(j,particle.getValue(j) + speed[i][j]);
      if (particle.getValue(j) < problem.getLowerLimit(j)) {
        particle.setValue(j,problem.getLowerLimit(j));
        speed[i][j]=speed[i][j] * changeVelocity1;
      }
      if (particle.getValue(j) > problem.getUpperLimit(j)) {
        particle.setValue(j,problem.getUpperLimit(j));
        speed[i][j]=speed[i][j] * changeVelocity2;
      }
    }
  }
}",0.8255188316679477
64672,"@Deprecated public SMPSO(){
  super();
  r1Max=1.0;
  r1Min=0.0;
  r2Max=1.0;
  r2Min=0.0;
  c1Max=2.5;
  c1Min=1.5;
  c2Max=2.5;
  c2Min=1.5;
  weightMax=0.1;
  weightMin=0.1;
  changeVelocity1=-1;
  changeVelocity2=-1;
}","/** 
 * Constructor 
 */
public SMPSO(Builder builder){
  problem=builder.problem;
  swarmSize=builder.swarmSize;
  leaders=builder.leaders;
  mutation=builder.mutationOperator;
  maxIterations=builder.maxIterations;
  r1Max=builder.r1Max;
  r1Min=builder.r1Min;
  r2Max=builder.r2Max;
  r2Min=builder.r2Min;
  c1Max=builder.c1Max;
  c1Min=builder.c1Min;
  c2Max=builder.c2Max;
  c2Min=builder.c2Min;
  weightMax=builder.weightMax;
  weightMin=builder.weightMin;
  changeVelocity1=builder.changeVelocity1;
  changeVelocity2=builder.changeVelocity2;
}",0.1502590673575129
64673,"protected void computeNewPositions(){
  for (int i=0; i < swarmSize; i++) {
    DoubleSolution particle=(DoubleSolution)swarm.get(i).copy();
    for (int var=0; var < particle.getNumberOfVariables(); var++) {
      particle.setVariableValue(var,particle.getVariableValue(var) + speed[i][var]);
      if (particle.getVariableValue(var) < problem.getLowerBound(var)) {
        particle.setVariableValue(var,problem.getLowerBound(var));
        speed[i][var]=speed[i][var] * changeVelocity1;
      }
      if (particle.getVariableValue(var) > problem.getUpperBound(var)) {
        particle.setVariableValue(var,problem.getUpperBound(var));
        speed[i][var]=speed[i][var] * changeVelocity2;
      }
    }
  }
}","protected void computeNewPositions(){
  for (int i=0; i < swarmSize; i++) {
    DoubleSolution particle=swarm.get(i);
    for (int j=0; j < particle.getNumberOfVariables(); j++) {
      double v=particle.getVariableValue(j);
      particle.setVariableValue(j,particle.getVariableValue(j) + speed[i][j]);
      if (particle.getVariableValue(j) < problem.getLowerBound(j)) {
        particle.setVariableValue(j,problem.getLowerBound(j));
        speed[i][j]=speed[i][j] * changeVelocity1;
      }
      if (particle.getVariableValue(j) > problem.getUpperBound(j)) {
        particle.setVariableValue(j,problem.getUpperBound(j));
        speed[i][j]=speed[i][j] * changeVelocity2;
      }
    }
  }
}",0.8053977272727273
64674,"/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  ContinuousProblem problem;
  Algorithm algorithm;
  MutationOperator mutation;
  problem=new Fonseca();
  Archive archive=new CrowdingDistanceArchive(100);
  mutation=new PolynomialMutation.Builder().setDistributionIndex(20.0).setProbability(1.0 / problem.getNumberOfVariables()).build();
  algorithm=new SMPSO.Builder(problem,archive).setMutation(mutation).setMaxIterations(250).setSwarmSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<Solution> population=algorithmRunner.getSolutionSet();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}","/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  ContinuousProblem problem;
  Algorithm algorithm;
  MutationOperator mutation;
  problem=new Kursawe();
  Archive archive=new CrowdingDistanceArchive(100);
  mutation=new PolynomialMutation.Builder().setDistributionIndex(20.0).setProbability(1.0 / problem.getNumberOfVariables()).build();
  algorithm=new SMPSO.Builder(problem,archive).setMutation(mutation).setMaxIterations(250).setSwarmSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  List<Solution> population=algorithmRunner.getSolutionSet();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
}",0.995364238410596
64675,"/** 
 * Compares two solutions.
 * @param object1 Object representing the first <code>Solution</code>.
 * @param object2 Object representing the second <code>Solution</code>.
 * @return -1, or 0, or 1, or 2 if solution1 is dominates solution2, solution1and solution2 are equals, or solution1 is greater than solution2, respectively.
 */
@Override public int compare(Solution object1,Solution object2){
  if (object1 == null) {
    return 1;
  }
 else   if (object2 == null) {
    return -1;
  }
  int dominate1;
  int dominate2;
  dominate1=0;
  dominate2=0;
  Solution solution1=(Solution)object1;
  Solution solution2=(Solution)object2;
  int flag;
  double value1, value2;
  for (int i=0; i < solution1.getNumberOfObjectives(); i++) {
    flag=(new ObjectiveComparator(i)).compare(solution1,solution2);
    value1=solution1.getObjective(i);
    value2=solution2.getObjective(i);
    if (value1 < value2) {
      flag=-1;
    }
 else     if (value1 > value2) {
      flag=1;
    }
 else {
      flag=0;
    }
    if (flag == -1) {
      dominate1=1;
    }
    if (flag == 1) {
      dominate2=1;
    }
  }
  if (dominate1 == 0 && dominate2 == 0) {
    return 0;
  }
  if (dominate1 == 1) {
    return -1;
  }
 else   if (dominate2 == 1) {
    return 1;
  }
  return 2;
}","/** 
 * Compares two solutions.
 * @param object1 Object representing the first <code>Solution</code>.
 * @param object2 Object representing the second <code>Solution</code>.
 * @return -1, or 0, or 1, or 2 if solution1 is dominates solution2, solution1and solution2 are equals, or solution1 is greater than solution2, respectively.
 */
@Override public int compare(Solution object1,Solution object2){
  if (object1 == null) {
    return 1;
  }
 else   if (object2 == null) {
    return -1;
  }
  int dominate1;
  int dominate2;
  dominate1=0;
  dominate2=0;
  Solution solution1=(Solution)object1;
  Solution solution2=(Solution)object2;
  int flag;
  double value1, value2;
  for (int i=0; i < solution1.getNumberOfObjectives(); i++) {
    value1=solution1.getObjective(i);
    value2=solution2.getObjective(i);
    if (value1 < value2) {
      flag=-1;
    }
 else     if (value1 > value2) {
      flag=1;
    }
 else {
      flag=0;
    }
    if (flag == -1) {
      dominate1=1;
    }
    if (flag == 1) {
      dominate2=1;
    }
  }
  if (dominate1 == 0 && dominate2 == 0) {
    return 0;
  }
  if (dominate1 == 1) {
    return -1;
  }
 else   if (dominate2 == 1) {
    return 1;
  }
  return 2;
}",0.9725363489499192
64676,"/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException       Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  Problem problem;
  Algorithm algorithm;
  Mutation mutation;
  QualityIndicatorGetter indicators;
  indicators=null;
  if (args.length == 1) {
    Object[] params={""String_Node_Str""};
    problem=(new ProblemFactory()).getProblem(args[0],params);
  }
 else   if (args.length == 2) {
    Object[] params={""String_Node_Str""};
    problem=(new ProblemFactory()).getProblem(args[0],params);
    indicators=new QualityIndicatorGetter(problem,args[1]);
  }
 else {
    problem=new Kursawe(""String_Node_Str"",3);
  }
  SolutionSetEvaluator evaluator=new SequentialSolutionSetEvaluator();
  Archive archive=new CrowdingArchive(100,problem.getNumberOfObjectives());
  mutation=new PolynomialMutation.Builder().setDistributionIndex(20.0).setProbability(1.0 / problem.getNumberOfVariables()).build();
  algorithm=new SMPSO.Builder(problem,archive,evaluator).setMutation(mutation).setMaxIterations(250).setSwarmSize(100).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  SolutionSet population=algorithmRunner.getSolutionSet();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  if (indicators != null) {
    JMetalLogger.logger.info(""String_Node_Str"");
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getHypervolume(population));
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getGD(population));
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getIGD(population));
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getSpread(population));
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getEpsilon(population));
  }
}","/** 
 * @param args Command line arguments. The first (optional) argument specifiesthe problem to solve.
 * @throws org.uma.jmetal.util.JMetalException
 * @throws java.io.IOException
 * @throws SecurityException       Usage: three options - org.uma.jmetal.runner.multiobjective.SMPSORunner - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName - org.uma.jmetal.runner.multiobjective.SMPSORunner problemName ParetoFrontFile
 */
public static void main(String[] args) throws Exception {
  Problem problem;
  Algorithm algorithm;
  Mutation mutation;
  QualityIndicatorGetter indicators;
  indicators=null;
  if (args.length == 1) {
    Object[] params={""String_Node_Str""};
    problem=(new ProblemFactory()).getProblem(args[0],params);
  }
 else   if (args.length == 2) {
    Object[] params={""String_Node_Str""};
    problem=(new ProblemFactory()).getProblem(args[0],params);
    indicators=new QualityIndicatorGetter(problem,args[1]);
  }
 else {
    problem=new Fonseca(""String_Node_Str"");
  }
  SolutionSetEvaluator evaluator=new SequentialSolutionSetEvaluator();
  Archive archive=new CrowdingArchive(10,problem.getNumberOfObjectives());
  mutation=new PolynomialMutation.Builder().setDistributionIndex(20.0).setProbability(1.0 / problem.getNumberOfVariables()).build();
  algorithm=new SMPSO.Builder(problem,archive,evaluator).setMutation(mutation).setMaxIterations(2).setSwarmSize(10).build();
  AlgorithmRunner algorithmRunner=new AlgorithmRunner.Executor(algorithm).execute();
  SolutionSet population=algorithmRunner.getSolutionSet();
  long computingTime=algorithmRunner.getComputingTime();
  new SolutionSetOutput.Printer(population).setSeparator(""String_Node_Str"").setVarFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).setFunFileOutputContext(new DefaultFileOutputContext(""String_Node_Str"")).print();
  JMetalLogger.logger.info(""String_Node_Str"" + computingTime + ""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  JMetalLogger.logger.info(""String_Node_Str"");
  if (indicators != null) {
    JMetalLogger.logger.info(""String_Node_Str"");
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getHypervolume(population));
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getGD(population));
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getIGD(population));
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getSpread(population));
    JMetalLogger.logger.info(""String_Node_Str"" + indicators.getEpsilon(population));
  }
}",0.996031746031746
64677,"public void setRank(int ranking){
  this.ranking=ranking;
}","@Override public void setRank(int ranking){
  this.ranking=ranking;
}",0.921875
64678,"public void setCrowdingDistance(double crowdingDistance){
  this.crowdingDistance=crowdingDistance;
}","@Override public void setCrowdingDistance(double crowdingDistance){
  this.crowdingDistance=crowdingDistance;
}",0.9528301886792452
64679,"/** 
 * Constructor 
 */
public BinarySolutionImpl(BinaryProblem problem){
  this.problem=problem;
  objectives=new ArrayList<>(problem.getNumberOfVariables());
  variables=new ArrayList<>(problem.getNumberOfObjectives());
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    variables.add(createNewBitSet(problem.getNumberOfBits(i)));
  }
}","/** 
 * Constructor 
 */
public BinarySolutionImpl(BinaryProblem problem){
  this.problem=problem;
  objectives=new ArrayList<>(problem.getNumberOfObjectives());
  variables=new ArrayList<>(problem.getNumberOfVariables());
  for (int i=0; i < problem.getNumberOfVariables(); i++) {
    variables.add(createNewBitSet(problem.getNumberOfBits(i)));
  }
}",0.9572649572649572
64680,"/** 
 * Constructor 
 */
public Fonseca(){
  setNumberOfVariables(3);
  setNumberOfObjectives(2);
  setName(""String_Node_Str"");
  ArrayList<Double> lowerLimit=new ArrayList<>(getNumberOfVariables());
  ArrayList<Double> upperLimit=new ArrayList<>(getNumberOfVariables());
  for (int i=0; i < getNumberOfVariables(); i++) {
    lowerLimit.set(i,-4.0);
    upperLimit.set(i,4.0);
  }
  setLowerLimit(lowerLimit);
  setUpperLimit(upperLimit);
}","/** 
 * Constructor 
 */
public Fonseca(){
  setNumberOfVariables(3);
  setNumberOfObjectives(2);
  setName(""String_Node_Str"");
  ArrayList<Double> lowerLimit=new ArrayList<>(getNumberOfVariables());
  ArrayList<Double> upperLimit=new ArrayList<>(getNumberOfVariables());
  for (int i=0; i < getNumberOfVariables(); i++) {
    lowerLimit.add(-4.0);
    upperLimit.add(4.0);
  }
  setLowerLimit(lowerLimit);
  setUpperLimit(upperLimit);
}",0.9772209567198178
64681,"/** 
 * Evaluate() method 
 */
public void evaluate(Solution solution){
  int numberOfVariables=getNumberOfVariables();
  double[] f=new double[getNumberOfObjectives()];
  double[] x=new double[numberOfVariables];
  for (int i=0; i < numberOfVariables; i++) {
    x[i]=(double)solution.getVariableValue(i);
  }
  double sum1=0.0;
  for (int i=0; i < numberOfVariables; i++) {
    sum1+=StrictMath.pow(x[i] - (1.0 / StrictMath.sqrt((double)numberOfVariables)),2.0);
  }
  double exp1=StrictMath.exp((-1.0) * sum1);
  f[0]=1 - exp1;
  double sum2=0.0;
  for (int i=0; i < numberOfVariables; i++) {
    sum2+=StrictMath.pow(x[i] + (1.0 / StrictMath.sqrt((double)numberOfVariables)),2.0);
  }
  double exp2=StrictMath.exp((-1.0) * sum2);
  f[1]=1 - exp2;
  solution.setObjective(0,f[0]);
  solution.setObjective(1,f[1]);
}","/** 
 * Evaluate() method 
 */
@Override public void evaluate(Solution solution){
  int numberOfVariables=getNumberOfVariables();
  double[] f=new double[getNumberOfObjectives()];
  double[] x=new double[numberOfVariables];
  for (int i=0; i < numberOfVariables; i++) {
    x[i]=(double)solution.getVariableValue(i);
  }
  double sum1=0.0;
  for (int i=0; i < numberOfVariables; i++) {
    sum1+=StrictMath.pow(x[i] - (1.0 / StrictMath.sqrt((double)numberOfVariables)),2.0);
  }
  double exp1=StrictMath.exp((-1.0) * sum1);
  f[0]=1 - exp1;
  double sum2=0.0;
  for (int i=0; i < numberOfVariables; i++) {
    sum2+=StrictMath.pow(x[i] + (1.0 / StrictMath.sqrt((double)numberOfVariables)),2.0);
  }
  double exp2=StrictMath.exp((-1.0) * sum2);
  f[1]=1 - exp2;
  solution.setObjective(0,f[0]);
  solution.setObjective(1,f[1]);
}",0.993924665856622
64682,"@Override public Double getUpperBound(int index){
  return 0.0;
}","@Override public Number getUpperBound(int index){
  return 0.0;
}",0.953846153846154
64683,"public AsyncMOCell1(Builder builder){
  super(builder);
}","/** 
 * Constructor 
 */
public AsyncMOCell1(Builder builder){
  super(builder);
}",0.8201438848920863
64684,"/** 
 * Runs of the AsyncMOCell1 algorithm.
 * @return a SolutionSet that is a set of non dominated solutionsas a experimentoutput of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  population=new SolutionSet(populationSize);
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  evaluations=0;
  createInitialPopulation();
  population=evaluatePopulation(population);
  evaluations+=population.size();
  while (!stoppingCondition()) {
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        population.replace(offSpring[0].getLocation(),offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        int compareResult=densityEstimatorComparator.compare(individual,offSpring[0]);
        if (compareResult == 1) {
          offSpring[0].setLocation(individual.getLocation());
          population.replace(offSpring[0].getLocation(),offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
 else {
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
    archiveFeedback();
  }
  return archive;
}","/** 
 * execute() method 
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  createInitialPopulation();
  population=evaluatePopulation(population);
  evaluations=population.size();
  while (!stoppingCondition()) {
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        population.replace(offSpring[0].getLocation(),offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        int compareResult=densityEstimatorComparator.compare(individual,offSpring[0]);
        if (compareResult == 1) {
          offSpring[0].setLocation(individual.getLocation());
          population.replace(offSpring[0].getLocation(),offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
 else {
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
    archiveFeedback();
  }
  return archive;
}",0.8547249647390691
64685,"/** 
 * Constructor
 */
public AsyncMOCell2(Builder builder){
  super(builder);
}","/** 
 * Constructor 
 */
public AsyncMOCell2(Builder builder){
  super(builder);
}",0.9938650306748468
64686,"/** 
 * Runs of the AsyncMOCell2 algorithm.
 * @return a SolutionSet that is a set of non dominated solutionsas a experimentoutput of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws ClassNotFoundException {
  population=new SolutionSet(populationSize);
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  evaluations=0;
  createInitialPopulation();
  population=evaluatePopulation(population);
  evaluations+=population.size();
  while (!stoppingCondition()) {
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      if (archive.size() > 0) {
        parents[1]=(Solution)selectionOperator.execute(archive);
      }
 else {
        parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      }
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        population.replace(offSpring[0].getLocation(),offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        int compareResult=densityEstimatorComparator.compare(individual,offSpring[0]);
        if (compareResult == 1) {
          offSpring[0].setLocation(individual.getLocation());
          population.replace(offSpring[0].getLocation(),offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
 else {
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
  }
  return archive;
}","/** 
 * execute() method 
 */
public SolutionSet execute() throws ClassNotFoundException {
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  createInitialPopulation();
  population=evaluatePopulation(population);
  evaluations=population.size();
  while (!stoppingCondition()) {
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      if (archive.size() > 0) {
        parents[1]=(Solution)selectionOperator.execute(archive);
      }
 else {
        parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      }
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        population.replace(offSpring[0].getLocation(),offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        int compareResult=densityEstimatorComparator.compare(individual,offSpring[0]);
        if (compareResult == 1) {
          offSpring[0].setLocation(individual.getLocation());
          population.replace(offSpring[0].getLocation(),offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
 else {
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
  }
  return archive;
}",0.8565610859728506
64687,"public AsyncMOCell3(Builder builder){
  super(builder);
}","/** 
 * Constructor 
 */
public AsyncMOCell3(Builder builder){
  super(builder);
}",0.8201438848920863
64688,"public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  population=new SolutionSet(populationSize);
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  evaluations=0;
  createInitialPopulation();
  while (!stoppingCondition()) {
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        population.replace(offSpring[0].getLocation(),offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        offSpring[0].setLocation(-1);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        Solution worst=neighbors[ind].worst(densityEstimatorComparator);
        if (worst.getLocation() == -1) {
          archive.add(new Solution(offSpring[0]));
        }
 else {
          offSpring[0].setLocation(worst.getLocation());
          population.replace(offSpring[0].getLocation(),offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
    archiveFeedback();
  }
  return archive;
}","/** 
 * execute() method 
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  createInitialPopulation();
  population=evaluatePopulation(population);
  evaluations=population.size();
  while (!stoppingCondition()) {
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        population.replace(offSpring[0].getLocation(),offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        offSpring[0].setLocation(-1);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        Solution worst=neighbors[ind].worst(densityEstimatorComparator);
        if (worst.getLocation() == -1) {
          archive.add(new Solution(offSpring[0]));
        }
 else {
          offSpring[0].setLocation(worst.getLocation());
          population.replace(offSpring[0].getLocation(),offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
    archiveFeedback();
  }
  return archive;
}",0.9553113553113554
64689,"public AsyncMOCell4(Builder builder){
  super(builder);
}","/** 
 * Constructor 
 */
public AsyncMOCell4(Builder builder){
  super(builder);
}",0.8201438848920863
64690,"/** 
 * Execute the algorithm
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  population=new SolutionSet(populationSize);
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  evaluations=0;
  createInitialPopulation();
  while (!stoppingCondition()) {
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      if (archive.size() > 0) {
        parents[1]=(Solution)selectionOperator.execute(archive);
      }
 else {
        parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      }
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        population.replace(offSpring[0].getLocation(),offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        offSpring[0].setLocation(-1);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        Solution worst=neighbors[ind].worst(densityEstimatorComparator);
        if (worst.getLocation() == -1) {
          archive.add(new Solution(offSpring[0]));
        }
 else {
          offSpring[0].setLocation(worst.getLocation());
          population.replace(offSpring[0].getLocation(),offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
  }
  return archive;
}","/** 
 * execute() method 
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  createInitialPopulation();
  population=evaluatePopulation(population);
  evaluations=population.size();
  while (!stoppingCondition()) {
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      if (archive.size() > 0) {
        parents[1]=(Solution)selectionOperator.execute(archive);
      }
 else {
        parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      }
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        population.replace(offSpring[0].getLocation(),offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        offSpring[0].setLocation(-1);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        Solution worst=neighbors[ind].worst(densityEstimatorComparator);
        if (worst.getLocation() == -1) {
          archive.add(new Solution(offSpring[0]));
        }
 else {
          offSpring[0].setLocation(worst.getLocation());
          population.replace(offSpring[0].getLocation(),offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
  }
  return archive;
}",0.9140767824497258
64691,"public Builder(Problem problem){
  this.problem=problem;
  dominanceComparator=new DominanceComparator();
  densityEstimatorComparator=new CrowdingComparator();
  archiveSize=100;
  archive=new CrowdingArchive(archiveSize,problem.getNumberOfObjectives());
}","/** 
 * Builder class 
 */
public Builder(Problem problem){
  this.problem=problem;
  dominanceComparator=new DominanceComparator();
  densityEstimatorComparator=new CrowdingComparator();
  archiveSize=DEFAULT_ARCHIVE_SIZE;
  numberOfFeedbackSolutionsFromArchive=0;
}",0.7251908396946565
64692,"public SyncMOCell1(Builder builder){
  super(builder);
}","/** 
 * Constructor 
 */
public SyncMOCell1(Builder builder){
  super(builder);
}",0.8175182481751825
64693,"public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  SolutionSet newSolutionSet;
  population=new SolutionSet(populationSize);
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  evaluations=0;
  createInitialPopulation();
  while (evaluations < maxEvaluations) {
    newSolutionSet=new SolutionSet(populationSize);
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == -1) {
        newSolutionSet.add(new Solution(population.get(ind)));
      }
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        newSolutionSet.add(offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        boolean deleteMutant=true;
        int compareResult=densityEstimatorComparator.compare(individual,offSpring[0]);
        if (compareResult == 1) {
          deleteMutant=false;
        }
        if (!deleteMutant) {
          offSpring[0].setLocation(individual.getLocation());
          newSolutionSet.add(offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
 else {
          newSolutionSet.add(new Solution(population.get(ind)));
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
    Distance.crowdingDistance(archive);
    for (int j=0; j < numberOfFeedbackSolutionsFromArchive; j++) {
      if (archive.size() > j) {
        int r=PseudoRandom.randInt(0,population.size() - 1);
        if (r < population.size()) {
          Solution individual=archive.get(j);
          individual.setLocation(r);
          newSolutionSet.replace(r,new Solution(individual));
        }
      }
    }
    population=newSolutionSet;
  }
  return archive;
}","/** 
 * execute() method 
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  SolutionSet newSolutionSet;
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  createInitialPopulation();
  population=evaluatePopulation(population);
  evaluations=population.size();
  while (evaluations < maxEvaluations) {
    newSolutionSet=new SolutionSet(populationSize);
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == -1) {
        newSolutionSet.add(new Solution(population.get(ind)));
      }
 else       if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        newSolutionSet.add(offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        boolean deleteMutant=true;
        int compareResult=densityEstimatorComparator.compare(individual,offSpring[0]);
        if (compareResult == 1) {
          deleteMutant=false;
        }
        if (!deleteMutant) {
          offSpring[0].setLocation(individual.getLocation());
          newSolutionSet.add(offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
 else {
          newSolutionSet.add(new Solution(population.get(ind)));
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
    Distance.crowdingDistance(archive);
    for (int j=0; j < numberOfFeedbackSolutionsFromArchive; j++) {
      if (archive.size() > j) {
        int r=PseudoRandom.randInt(0,population.size() - 1);
        if (r < population.size()) {
          Solution individual=archive.get(j);
          individual.setLocation(r);
          newSolutionSet.replace(r,new Solution(individual));
        }
      }
    }
    population=newSolutionSet;
  }
  return archive;
}",0.9676830381595763
64694,"/** 
 * Constructor
 */
public SyncMOCell2(Builder builder){
  super(builder);
}","/** 
 * Constructor 
 */
public SyncMOCell2(Builder builder){
  super(builder);
}",0.9937888198757764
64695,"/** 
 * Runs of the sMOCell2 algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a experimentoutput of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  SolutionSet newSolutionSet;
  population=new SolutionSet(populationSize);
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  evaluations=0;
  createInitialPopulation();
  while (!stoppingCondition()) {
    newSolutionSet=new SolutionSet(populationSize);
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      if (archive.size() > 0) {
        parents[1]=(Solution)selectionOperator.execute(archive);
      }
 else {
        parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      }
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == -1) {
        newSolutionSet.add(new Solution(population.get(ind)));
      }
      if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        newSolutionSet.add(offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        boolean deleteMutant=true;
        int compareResult=densityEstimatorComparator.compare(individual,offSpring[0]);
        if (compareResult == 1) {
          deleteMutant=false;
        }
        if (!deleteMutant) {
          offSpring[0].setLocation(individual.getLocation());
          newSolutionSet.add(offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
 else {
          newSolutionSet.add(new Solution(population.get(ind)));
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
    population=newSolutionSet;
  }
  return archive;
}","/** 
 * execute() method 
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  SolutionSet newSolutionSet;
  archive=new CrowdingArchive(archiveSize,problem_.getNumberOfObjectives());
  neighborhood=new Neighborhood(populationSize);
  neighbors=new SolutionSet[populationSize];
  createInitialPopulation();
  population=evaluatePopulation(population);
  evaluations=population.size();
  while (!stoppingCondition()) {
    newSolutionSet=new SolutionSet(populationSize);
    for (int ind=0; ind < population.size(); ind++) {
      Solution individual=new Solution(population.get(ind));
      Solution[] parents=new Solution[2];
      Solution[] offSpring;
      neighbors[ind]=neighborhood.getEightNeighbors(population,ind);
      neighbors[ind].add(individual);
      parents[0]=(Solution)selectionOperator.execute(neighbors[ind]);
      if (archive.size() > 0) {
        parents[1]=(Solution)selectionOperator.execute(archive);
      }
 else {
        parents[1]=(Solution)selectionOperator.execute(neighbors[ind]);
      }
      offSpring=(Solution[])crossoverOperator.execute(parents);
      mutationOperator.execute(offSpring[0]);
      problem_.evaluate(offSpring[0]);
      problem_.evaluateConstraints(offSpring[0]);
      evaluations++;
      int flag=dominanceComparator.compare(individual,offSpring[0]);
      if (flag == -1) {
        newSolutionSet.add(new Solution(population.get(ind)));
      }
 else       if (flag == 1) {
        offSpring[0].setLocation(individual.getLocation());
        newSolutionSet.add(offSpring[0]);
        archive.add(new Solution(offSpring[0]));
      }
 else       if (flag == 0) {
        neighbors[ind].add(offSpring[0]);
        Ranking rank=new Ranking(neighbors[ind]);
        for (int j=0; j < rank.getNumberOfSubfronts(); j++) {
          Distance.crowdingDistance(rank.getSubfront(j));
        }
        boolean deleteMutant=true;
        int compareResult=densityEstimatorComparator.compare(individual,offSpring[0]);
        if (compareResult == 1) {
          deleteMutant=false;
        }
        if (!deleteMutant) {
          offSpring[0].setLocation(individual.getLocation());
          newSolutionSet.add(offSpring[0]);
          archive.add(new Solution(offSpring[0]));
        }
 else {
          newSolutionSet.add(new Solution(population.get(ind)));
          archive.add(new Solution(offSpring[0]));
        }
      }
    }
    population=newSolutionSet;
  }
  return archive;
}",0.9094465088988852
64696,"/** 
 * Returns the epsilon indicator.
 * @param a Solution front
 * @param b True Pareto front
 * @return the value of the epsilon indicator
 * @throws org.uma.jmetal.util.JMetalException
 */
public double epsilon(double[][] a,double[][] b) throws JMetalException {
  int i, j, k;
  double eps, epsJ=0.0, epsK=0.0, epsTemp;
  this.numberOfObjectives=a[0].length;
  setParams();
  if (method == 0) {
    eps=Double.MIN_VALUE;
  }
 else {
    eps=0;
  }
  for (i=0; i < a.length; i++) {
    for (j=0; j < b.length; j++) {
      for (k=0; k < this.numberOfObjectives; k++) {
switch (method) {
case 0:
          if (obj[k] == 0) {
            epsTemp=b[j][k] - a[i][k];
          }
 else {
            epsTemp=a[i][k] - b[j][k];
          }
        break;
default :
      if ((a[i][k] < 0 && b[j][k] > 0) || (a[i][k] > 0 && b[j][k] < 0) || (a[i][k] == 0 || b[j][k] == 0)) {
        throw new JMetalException(""String_Node_Str"");
      }
    if (obj[k] == 0) {
      epsTemp=b[j][k] / a[i][k];
    }
 else {
      epsTemp=a[i][k] / b[j][k];
    }
  break;
}
if (k == 0) {
epsK=epsTemp;
}
 else if (epsK < epsTemp) {
epsK=epsTemp;
}
}
if (j == 0) {
epsJ=epsK;
}
 else if (epsJ > epsK) {
epsJ=epsK;
}
}
if (i == 0) {
eps=epsJ;
}
 else if (eps < epsJ) {
eps=epsJ;
}
}
return eps;
}","/** 
 * Returns the epsilon indicator.
 * @param front Solution front
 * @param referenceFront True Pareto front
 * @return the value of the epsilon indicator
 * @throws org.uma.jmetal.util.JMetalException
 */
public double epsilon(double[][] front,double[][] referenceFront) throws JMetalException {
  int i, j, k;
  double eps, epsJ=0.0, epsK=0.0, epsTemp;
  this.numberOfObjectives=front[0].length;
  setParams();
  if (method == 0) {
    eps=Double.MIN_VALUE;
  }
 else {
    eps=0;
  }
  for (i=0; i < referenceFront.length; i++) {
    for (j=0; j < front.length; j++) {
      for (k=0; k < this.numberOfObjectives; k++) {
switch (method) {
case 0:
          if (obj[k] == 0) {
            epsTemp=front[j][k] - referenceFront[i][k];
          }
 else {
            epsTemp=referenceFront[i][k] - front[j][k];
          }
        break;
default :
      if ((referenceFront[i][k] < 0 && front[j][k] > 0) || (referenceFront[i][k] > 0 && front[j][k] < 0) || (referenceFront[i][k] == 0 || front[j][k] == 0)) {
        throw new JMetalException(""String_Node_Str"");
      }
    if (obj[k] == 0) {
      epsTemp=front[j][k] / referenceFront[i][k];
    }
 else {
      epsTemp=referenceFront[i][k] / front[j][k];
    }
  break;
}
if (k == 0) {
epsK=epsTemp;
}
 else if (epsK < epsTemp) {
epsK=epsTemp;
}
}
if (j == 0) {
epsJ=epsK;
}
 else if (epsJ > epsK) {
epsJ=epsK;
}
}
if (i == 0) {
eps=epsJ;
}
 else if (eps < epsJ) {
eps=epsJ;
}
}
return eps;
}",0.6566176470588235
64697,"public static void main(String[] args) throws JMetalException, IOException {
  ExperimentData experimentData=new ExperimentData.Builder(""String_Node_Str"").algorithmNameList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}).problemList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}).experimentBaseDirectory(""String_Node_Str"").outputParetoFrontFileName(""String_Node_Str"").outputParetoSetFileName(""String_Node_Str"").independentRuns(20).build();
  AlgorithmExecution algorithmExecution=new AlgorithmExecution.Builder(experimentData).numberOfThreads(8).paretoSetFileName(""String_Node_Str"").paretoFrontFileName(""String_Node_Str"").build();
  ParetoFrontsGeneration paretoFrontsGeneration=new ParetoFrontsGeneration.Builder(experimentData).build();
  String[] indicatorList=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  QualityIndicatorGeneration qualityIndicatorGeneration=new QualityIndicatorGeneration.Builder(experimentData).paretoFrontDirectory(""String_Node_Str"").paretoFrontFiles(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}).qualityIndicatorList(indicatorList).build();
  SetCoverageTableGeneration setCoverageTables=new SetCoverageTableGeneration.Builder(experimentData).build();
  BoxplotGeneration boxplotGeneration=new BoxplotGeneration.Builder(experimentData).indicatorList(indicatorList).numberOfRows(2).numberOfColumns(2).build();
  WilcoxonTestTableGeneration wilcoxonTestTableGeneration=new WilcoxonTestTableGeneration.Builder(experimentData).indicatorList(indicatorList).build();
  QualityIndicatorLatexTableGeneration qualityIndicatorLatexTableGeneration=new QualityIndicatorLatexTableGeneration.Builder(experimentData).indicatorList(indicatorList).build();
  FriedmanTableGeneration friedmanTableGeneration=new FriedmanTableGeneration.Builder(experimentData).indicatorList(indicatorList).build();
  Experiment experiment=new Experiment.Builder(experimentData).addExperimentOutput(algorithmExecution).addExperimentOutput(paretoFrontsGeneration).addExperimentOutput(qualityIndicatorGeneration).addExperimentOutput(setCoverageTables).addExperimentOutput(boxplotGeneration).addExperimentOutput(wilcoxonTestTableGeneration).addExperimentOutput(qualityIndicatorLatexTableGeneration).addExperimentOutput(friedmanTableGeneration).build();
  experiment.run();
}","public static void main(String[] args) throws JMetalException, IOException {
  ExperimentData experimentData=new ExperimentData.Builder(""String_Node_Str"").algorithmNameList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}).problemList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}).experimentBaseDirectory(""String_Node_Str"").outputParetoFrontFileName(""String_Node_Str"").outputParetoSetFileName(""String_Node_Str"").independentRuns(30).build();
  AlgorithmExecution algorithmExecution=new AlgorithmExecution.Builder(experimentData).numberOfThreads(8).paretoSetFileName(""String_Node_Str"").paretoFrontFileName(""String_Node_Str"").build();
  ParetoFrontsGeneration paretoFrontsGeneration=new ParetoFrontsGeneration.Builder(experimentData).build();
  String[] indicatorList=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  QualityIndicatorGeneration qualityIndicatorGeneration=new QualityIndicatorGeneration.Builder(experimentData).paretoFrontDirectory(""String_Node_Str"").paretoFrontFiles(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}).qualityIndicatorList(indicatorList).build();
  SetCoverageTableGeneration setCoverageTables=new SetCoverageTableGeneration.Builder(experimentData).build();
  BoxplotGeneration boxplotGeneration=new BoxplotGeneration.Builder(experimentData).indicatorList(indicatorList).numberOfRows(2).numberOfColumns(2).build();
  WilcoxonTestTableGeneration wilcoxonTestTableGeneration=new WilcoxonTestTableGeneration.Builder(experimentData).indicatorList(indicatorList).build();
  QualityIndicatorLatexTableGeneration qualityIndicatorLatexTableGeneration=new QualityIndicatorLatexTableGeneration.Builder(experimentData).indicatorList(indicatorList).build();
  FriedmanTableGeneration friedmanTableGeneration=new FriedmanTableGeneration.Builder(experimentData).indicatorList(indicatorList).build();
  Experiment experiment=new Experiment.Builder(experimentData).addExperimentOutput(qualityIndicatorGeneration).addExperimentOutput(setCoverageTables).addExperimentOutput(boxplotGeneration).addExperimentOutput(qualityIndicatorLatexTableGeneration).build();
  experiment.run();
}",0.9504657070279424
64698,"/** 
 * Runs the NSGA-II algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  createInitialPopulation();
  evaluatePopulation(population_);
  evaluations_+=population_.size();
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(populationSize_);
    for (int i=0; i < (populationSize_ / 2); i++) {
      if (!stoppingCondition()) {
        Solution[] parents=new Solution[2];
        parents[0]=(Solution)selectionOperator_.execute(population_);
        parents[1]=(Solution)selectionOperator_.execute(population_);
        Solution[] offSpring=(Solution[])crossoverOperator_.execute(parents);
        mutationOperator_.execute(offSpring[0]);
        mutationOperator_.execute(offSpring[1]);
        offspringPopulation_.add(offSpring[0]);
        offspringPopulation_.add(offSpring[1]);
      }
    }
    evaluatePopulation(offspringPopulation_);
    evaluations_+=offspringPopulation_.size();
    Ranking ranking=new Ranking(population_.union(offspringPopulation_));
    population_.clear();
    int rankingIndex=0;
    while (populationIsNotFull()) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
  }
  tearDown();
  return getNonDominatedSolutions();
}","/** 
 * Runs the NSGA-II algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  createInitialPopulation();
  population_=evaluatePopulation(population_);
  evaluations_+=population_.size();
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(populationSize_);
    for (int i=0; i < (populationSize_ / 2); i++) {
      if (!stoppingCondition()) {
        Solution[] parents=new Solution[2];
        parents[0]=(Solution)selectionOperator_.execute(population_);
        parents[1]=(Solution)selectionOperator_.execute(population_);
        Solution[] offSpring=(Solution[])crossoverOperator_.execute(parents);
        mutationOperator_.execute(offSpring[0]);
        mutationOperator_.execute(offSpring[1]);
        offspringPopulation_.add(offSpring[0]);
        offspringPopulation_.add(offSpring[1]);
      }
    }
    offspringPopulation_=evaluatePopulation(offspringPopulation_);
    evaluations_+=offspringPopulation_.size();
    Ranking ranking=new Ranking(population_.union(offspringPopulation_));
    population_.clear();
    int rankingIndex=0;
    while (populationIsNotFull()) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
  }
  tearDown();
  return getNonDominatedSolutions();
}",0.9899726526891522
64699,"protected void evaluatePopulation(SolutionSet population) throws JMetalException {
  evaluator_.evaluate(population,problem_);
}","protected SolutionSet evaluatePopulation(SolutionSet population) throws JMetalException {
  return evaluator_.evaluate(population,problem_);
}",0.9333333333333332
64700,"/** 
 * Runs the ssNSGA-II algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  createInitialPopulation();
  evaluatePopulation(population_);
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(1);
    Solution[] parents=new Solution[2];
    parents[0]=(Solution)selectionOperator_.execute(population_);
    parents[1]=(Solution)selectionOperator_.execute(population_);
    Solution[] offSpring=(Solution[])crossoverOperator_.execute(parents);
    mutationOperator_.execute(offSpring[0]);
    problem_.evaluate(offSpring[0]);
    problem_.evaluateConstraints(offSpring[0]);
    offspringPopulation_.add(offSpring[0]);
    evaluations_++;
    Ranking ranking=new Ranking(population_.union(offspringPopulation_));
    population_.clear();
    int rankingIndex=0;
    while (populationIsNotFull()) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
  }
  tearDown();
  return getNonDominatedSolutions();
}","/** 
 * Runs the ssNSGA-II algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  createInitialPopulation();
  population_=evaluatePopulation(population_);
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(1);
    Solution[] parents=new Solution[2];
    parents[0]=(Solution)selectionOperator_.execute(population_);
    parents[1]=(Solution)selectionOperator_.execute(population_);
    Solution[] offSpring=(Solution[])crossoverOperator_.execute(parents);
    mutationOperator_.execute(offSpring[0]);
    problem_.evaluate(offSpring[0]);
    problem_.evaluateConstraints(offSpring[0]);
    offspringPopulation_.add(offSpring[0]);
    evaluations_++;
    Ranking ranking=new Ranking(population_.union(offspringPopulation_));
    population_.clear();
    int rankingIndex=0;
    while (populationIsNotFull()) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
  }
  tearDown();
  return getNonDominatedSolutions();
}",0.995645863570392
64701,"/** 
 * Constructor
 * @throws org.uma.jmetal.util.JMetalException
 */
public NSGAIISettings(String problem) throws JMetalException {
  super(problem);
  Object[] problemParams={""String_Node_Str""};
  problem_=(new ProblemFactory()).getProblem(problemName_,problemParams);
  populationSize_=100;
  maxEvaluations_=25000;
  mutationProbability_=1.0 / problem_.getNumberOfVariables();
  crossoverProbability_=0.9;
  mutationDistributionIndex_=20.0;
  crossoverDistributionIndex_=20.0;
  evaluator_=new SequentialSolutionSetEvaluator();
}","/** 
 * Constructor
 * @throws org.uma.jmetal.util.JMetalException
 */
public NSGAIISettings(String problem) throws JMetalException {
  super(problem);
  Object[] problemParams={""String_Node_Str""};
  problem_=(new ProblemFactory()).getProblem(problemName_,problemParams);
  populationSize_=100;
  maxEvaluations=25000;
  mutationProbability=1.0 / problem_.getNumberOfVariables();
  crossoverProbability=0.9;
  mutationDistributionIndex=20.0;
  crossoverDistributionIndex=20.0;
  evaluator=new SequentialSolutionSetEvaluator();
}",0.9943502824858758
64702,"/** 
 * Configure NSGAII with user-defined parameter experiment.settings
 * @return A NSGAII algorithm object
 */
@Override public Algorithm configure(Properties configuration) throws JMetalException {
  populationSize_=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(populationSize_)));
  maxEvaluations_=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(maxEvaluations_)));
  crossoverProbability_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(crossoverProbability_)));
  crossoverDistributionIndex_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(crossoverDistributionIndex_)));
  mutationProbability_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationProbability_)));
  mutationDistributionIndex_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationDistributionIndex_)));
  return configure();
}","/** 
 * Configure NSGAII with user-defined parameter experiment.settings
 * @return A NSGAII algorithm object
 */
@Override public Algorithm configure(Properties configuration) throws JMetalException {
  populationSize_=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(populationSize_)));
  maxEvaluations=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(maxEvaluations)));
  crossoverProbability=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(crossoverProbability)));
  crossoverDistributionIndex=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(crossoverDistributionIndex)));
  mutationProbability=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationProbability)));
  mutationDistributionIndex=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationDistributionIndex)));
  return configure();
}",0.9948979591836736
64703,"/** 
 * Runs the NSGA-II algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  createInitialPopulation();
  evaluatePopulation(population_);
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(populationSize_);
    for (int i=0; i < (populationSize_ / 2); i++) {
      if (!stoppingCondition()) {
        Solution[] parents=new Solution[2];
        parents[0]=(Solution)selectionOperator_.execute(population_);
        parents[1]=(Solution)selectionOperator_.execute(population_);
        Solution[] offSpring=(Solution[])crossoverOperator_.execute(parents);
        mutationOperator_.execute(offSpring[0]);
        mutationOperator_.execute(offSpring[1]);
        offspringPopulation_.add(offSpring[0]);
        offspringPopulation_.add(offSpring[1]);
      }
    }
    evaluatePopulation(offspringPopulation_);
    evaluations_+=offspringPopulation_.size();
    Ranking ranking=new Ranking(population_.union(offspringPopulation_));
    population_.clear();
    int rankingIndex=0;
    while (populationIsNotFull()) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
  }
  tearDown();
  return getNonDominatedSolutions();
}","/** 
 * Runs the NSGA-II algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  createInitialPopulation();
  evaluatePopulation(population_);
  evaluations_+=population_.size();
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(populationSize_);
    for (int i=0; i < (populationSize_ / 2); i++) {
      if (!stoppingCondition()) {
        Solution[] parents=new Solution[2];
        parents[0]=(Solution)selectionOperator_.execute(population_);
        parents[1]=(Solution)selectionOperator_.execute(population_);
        Solution[] offSpring=(Solution[])crossoverOperator_.execute(parents);
        mutationOperator_.execute(offSpring[0]);
        mutationOperator_.execute(offSpring[1]);
        offspringPopulation_.add(offSpring[0]);
        offspringPopulation_.add(offSpring[1]);
      }
    }
    evaluatePopulation(offspringPopulation_);
    evaluations_+=offspringPopulation_.size();
    Ranking ranking=new Ranking(population_.union(offspringPopulation_));
    population_.clear();
    int rankingIndex=0;
    while (populationIsNotFull()) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
  }
  tearDown();
  return getNonDominatedSolutions();
}",0.988826815642458
64704,"protected boolean stoppingCondition(){
  return evaluations_ == maxEvaluations_;
}","protected boolean stoppingCondition(){
  return evaluations_ >= maxEvaluations_;
}",0.9878048780487804
64705,"protected void evaluatePopulation(SolutionSet population) throws JMetalException {
  evaluator_.evaluate(population,problem_);
}","protected SolutionSet evaluatePopulation(SolutionSet population) throws JMetalException {
  return evaluator_.evaluate(population,problem_);
}",0.9333333333333332
64706,"/** 
 * Runs of the GDE3 algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  createInitialPopulation();
  evaluatePopulation(population_);
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(populationSize_ * 2);
    SolutionSet tmpSolutionSet=new SolutionSet(populationSize_);
    for (int i=0; i < populationSize_; i++) {
      Solution[] parent=(Solution[])selectionOperator_.execute(new Object[]{population_,i});
      Solution child;
      child=(Solution)crossoverOperator_.execute(new Object[]{population_.get(i),parent});
      tmpSolutionSet.add(child);
    }
    evaluatePopulation(tmpSolutionSet);
    for (int i=0; i < populationSize_; i++) {
      Solution child=tmpSolutionSet.get(i);
      int result;
      result=dominance_.compare(population_.get(i),child);
      if (result == -1) {
        offspringPopulation_.add(population_.get(i));
      }
 else       if (result == 1) {
        offspringPopulation_.add(child);
      }
 else {
        offspringPopulation_.add(child);
        offspringPopulation_.add(population_.get(i));
      }
    }
    Ranking ranking=new Ranking(offspringPopulation_);
    population_.clear();
    int rankingIndex=0;
    while (populationIsNotFull()) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
    iterations_++;
  }
  tearDown();
  return getNonDominatedSolutions();
}","/** 
 * Runs of the GDE3 algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws org.uma.jmetal.util.JMetalException
 */
public SolutionSet execute() throws JMetalException, ClassNotFoundException {
  createInitialPopulation();
  population_=evaluatePopulation(population_);
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(populationSize_ * 2);
    SolutionSet tmpSolutionSet=new SolutionSet(populationSize_);
    for (int i=0; i < populationSize_; i++) {
      Solution[] parent=(Solution[])selectionOperator_.execute(new Object[]{population_,i});
      Solution child;
      child=(Solution)crossoverOperator_.execute(new Object[]{population_.get(i),parent});
      tmpSolutionSet.add(child);
    }
    tmpSolutionSet=evaluatePopulation(tmpSolutionSet);
    for (int i=0; i < populationSize_; i++) {
      Solution child=tmpSolutionSet.get(i);
      int result;
      result=dominance_.compare(population_.get(i),child);
      if (result == -1) {
        offspringPopulation_.add(population_.get(i));
      }
 else       if (result == 1) {
        offspringPopulation_.add(child);
      }
 else {
        offspringPopulation_.add(child);
        offspringPopulation_.add(population_.get(i));
      }
    }
    Ranking ranking=new Ranking(offspringPopulation_);
    population_.clear();
    int rankingIndex=0;
    while (populationIsNotFull()) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
    iterations_++;
  }
  tearDown();
  return getNonDominatedSolutions();
}",0.9925393755180988
64707,"protected void evaluateSwarm() throws JMetalException {
  evaluator_.evaluate(swarm_,problem_);
}","protected void evaluateSwarm() throws JMetalException {
  swarm_=evaluator_.evaluate(swarm_,problem_);
}",0.965174129353234
64708,"/** 
 * Constructor
 * @param problem Problem to solve
 */
public SMPSO(String trueParetoFront) throws FileNotFoundException {
  super();
  hy_=new Hypervolume();
  jmetal.qualityIndicator.util.MetricsUtil mu=new jmetal.qualityIndicator.util.MetricsUtil();
  trueFront_=mu.readNonDominatedSolutionSet(trueParetoFront);
  trueHypervolume_=hy_.hypervolume(trueFront_.writeObjectivesToMatrix(),trueFront_.writeObjectivesToMatrix(),problem_.getNumberOfObjectives());
  r1Max_=1.0;
  r1Min_=0.0;
  r2Max_=1.0;
  r2Min_=0.0;
  c1Max_=2.5;
  c1Min_=1.5;
  c2Max_=2.5;
  c2Min_=1.5;
  weightMax_=0.1;
  weightMin_=0.1;
  changeVelocity1_=-1;
  changeVelocity2_=-1;
}","/** 
 * Constructor
 */
public SMPSO(String trueParetoFront) throws FileNotFoundException {
  super();
  hy_=new Hypervolume();
  jmetal.qualityIndicator.util.MetricsUtil mu=new jmetal.qualityIndicator.util.MetricsUtil();
  trueFront_=mu.readNonDominatedSolutionSet(trueParetoFront);
  trueHypervolume_=hy_.hypervolume(trueFront_.writeObjectivesToMatrix(),trueFront_.writeObjectivesToMatrix(),problem_.getNumberOfObjectives());
  r1Max_=1.0;
  r1Min_=0.0;
  r2Max_=1.0;
  r2Min_=0.0;
  c1Max_=2.5;
  c1Min_=1.5;
  c2Max_=2.5;
  c2Min_=1.5;
  weightMax_=0.1;
  weightMin_=0.1;
  changeVelocity1_=-1;
  changeVelocity2_=-1;
}",0.9726775956284152
64709,"public Mutation(HashMap<String,Object> parameters){
  super(parameters);
}","public Mutation(){
  super();
}",0.5904761904761905
64710,"private PolynomialMutation(Builder builder){
  super(new HashMap<String,Object>());
  mutationProbability_=builder.mutationProbability_;
  distributionIndex_=builder.distributionIndex_;
}","private PolynomialMutation(Builder builder){
  addValidSolutionType(RealSolutionType.class);
  addValidSolutionType(ArrayRealSolutionType.class);
  mutationProbability_=builder.mutationProbability_;
  distributionIndex_=builder.distributionIndex_;
}",0.7155963302752294
64711,"/** 
 * Executes the operation
 * @param object An object containing a solution
 * @return An object containing the mutated solution
 * @throws JMException
 */
public Object execute(Object object) throws JMException {
  Solution solution=(Solution)object;
  if (!VALID_TYPES.contains(solution.getType().getClass())) {
    Configuration.logger_.severe(""String_Node_Str"" + ""String_Node_Str"" + solution.getType() + ""String_Node_Str"");
    Class cls=java.lang.String.class;
    String name=cls.getName();
    throw new JMException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  doMutation(mutationProbability_,solution);
  return solution;
}","/** 
 * Executes the operation
 * @param object An object containing a solution
 * @return An object containing the mutated solution
 * @throws JMException
 */
public Object execute(Object object) throws JMException {
  Solution solution=(Solution)object;
  if (!solutionTypeIsValid(solution)) {
    Configuration.logger_.severe(""String_Node_Str"" + ""String_Node_Str"" + solution.getType() + ""String_Node_Str"");
    Class cls=java.lang.String.class;
    String name=cls.getName();
    throw new JMException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  doMutation(mutationProbability_,solution);
  return solution;
}",0.944620253164557
64712,"public RStudy(){
  experimentName_=""String_Node_Str"";
  independentRuns_=30;
  algorithmNameList_=new String[]{""String_Node_Str"",""String_Node_Str""};
  problemList_=new String[]{""String_Node_Str""};
  paretoFrontFileList_=new String[]{""String_Node_Str""};
  indicatorList_=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  experimentBaseDirectory_=""String_Node_Str"";
  paretoFrontDirectory_=""String_Node_Str"";
  numberOfExecutionThreads_=6;
  generateReferenceParetoFronts_=false;
  runTheAlgorithms_=false;
  generateBoxplots_=false;
  boxplotRows_=2;
  boxplotColumns_=2;
  boxplotNotch_=true;
  generateFriedmanTables_=false;
  generateLatexTables_=false;
  generateWilcoxonTables_=false;
  generateSetCoverageTables_=true;
  generateQualityIndicators_=false;
}","public RStudy(){
  experimentName_=""String_Node_Str"";
  independentRuns_=30;
  algorithmNameList_=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  problemList_=new String[]{""String_Node_Str""};
  paretoFrontFileList_=new String[]{""String_Node_Str""};
  indicatorList_=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  experimentBaseDirectory_=""String_Node_Str"";
  paretoFrontDirectory_=""String_Node_Str"";
  numberOfExecutionThreads_=6;
  generateReferenceParetoFronts_=false;
  runTheAlgorithms_=false;
  generateBoxplots_=false;
  boxplotRows_=2;
  boxplotColumns_=2;
  boxplotNotch_=true;
  generateFriedmanTables_=false;
  generateLatexTables_=false;
  generateWilcoxonTables_=false;
  generateSetCoverageTables_=true;
  generateQualityIndicators_=false;
}",0.988621997471555
64713,"private void writeTableHeader(String problem) throws IOException {
  fileWriter_.write(""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + problem + ""String_Node_Str""+ ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + problem + ""String_Node_Str""+ ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"");
  for (int i=0; i < experiment_.getProblemList().length; i++) {
    fileWriter_.write(""String_Node_Str"");
  }
  fileWriter_.write(""String_Node_Str"");
  for (int i=-1; i < experiment_.getAlgorithmNameList().length; i++) {
    if (i == -1) {
      fileWriter_.write(""String_Node_Str"");
    }
 else     if (i == (experiment_.getAlgorithmNameList().length - 1)) {
      fileWriter_.write(""String_Node_Str"" + experiment_.getAlgorithmNameList()[i] + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      fileWriter_.write(""String_Node_Str"" + experiment_.getAlgorithmNameList()[i] + ""String_Node_Str"");
    }
  }
  fileWriter_.write(""String_Node_Str"" + ""String_Node_Str"");
}","private void writeTableHeader(String problem) throws IOException {
  fileWriter_.write(""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + problem + ""String_Node_Str""+ ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + problem + ""String_Node_Str""+ ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"" + ""String_Node_Str"");
  fileWriter_.write(""String_Node_Str"");
  for (int i=0; i < experiment_.getAlgorithmNameList().length; i++) {
    fileWriter_.write(""String_Node_Str"");
  }
  fileWriter_.write(""String_Node_Str"");
  for (int i=-1; i < experiment_.getAlgorithmNameList().length; i++) {
    if (i == -1) {
      fileWriter_.write(""String_Node_Str"");
    }
 else     if (i == (experiment_.getAlgorithmNameList().length - 1)) {
      fileWriter_.write(""String_Node_Str"" + experiment_.getAlgorithmNameList()[i] + ""String_Node_Str""+ ""String_Node_Str"");
    }
 else {
      fileWriter_.write(""String_Node_Str"" + experiment_.getAlgorithmNameList()[i] + ""String_Node_Str"");
    }
  }
  fileWriter_.write(""String_Node_Str"" + ""String_Node_Str"");
}",0.9915254237288136
64714,"private void writeTableRow(int algorithmIndex,String problem) throws IOException {
  fileWriter_.write(""String_Node_Str"" + experiment_.getAlgorithmNameList()[algorithmIndex] + ""String_Node_Str"");
  for (int i=0; i < experiment_.getAlgorithmNameList().length; i++) {
    if (i != algorithmIndex) {
      double setCoverageValueAB=calculateSetCoverage(problem,experiment_.getAlgorithmNameList()[algorithmIndex],experiment_.getAlgorithmNameList()[i]);
      double setCoverageValueBA=calculateSetCoverage(problem,experiment_.getAlgorithmNameList()[i],experiment_.getAlgorithmNameList()[algorithmIndex]);
      String setCoverageAB=String.format(Locale.ENGLISH,""String_Node_Str"",setCoverageValueAB);
      fileWriter_.write(""String_Node_Str"" + setCoverageAB + ""String_Node_Str"");
    }
 else     fileWriter_.write(""String_Node_Str"" + ""String_Node_Str"");
  }
  fileWriter_.write(""String_Node_Str"");
}","private void writeTableRow(int algorithmIndex,String problem) throws IOException {
  fileWriter_.write(""String_Node_Str"" + experiment_.getAlgorithmNameList()[algorithmIndex] + ""String_Node_Str"");
  for (int i=0; i < experiment_.getAlgorithmNameList().length; i++) {
    if (i != algorithmIndex) {
      double setCoverageValueAB=calculateSetCoverage(problem,experiment_.getAlgorithmNameList()[algorithmIndex],experiment_.getAlgorithmNameList()[i]);
      String setCoverageAB=String.format(Locale.ENGLISH,""String_Node_Str"",setCoverageValueAB);
      fileWriter_.write(""String_Node_Str"" + setCoverageAB);
    }
 else     fileWriter_.write(""String_Node_Str"");
    if (i < (experiment_.getAlgorithmNameList().length - 1)) {
      fileWriter_.write(""String_Node_Str"");
    }
  }
  fileWriter_.write(""String_Node_Str"");
}",0.8217416715371128
64715,"private double calculateSetCoverage(String problem,String algorithmA,String algorithmB){
  double result=5.5;
  SetCoverage setCoverageMetric=new SetCoverage();
  Vector<Double> values=new Vector<Double>(experiment_.getIndependentRuns());
  for (int i=0; i < experiment_.getIndependentRuns(); i++) {
    String front1=experiment_.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmA+ ""String_Node_Str""+ problem+ ""String_Node_Str""+ i;
    String front2=experiment_.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmB+ ""String_Node_Str""+ problem+ ""String_Node_Str""+ i;
    result=setCoverageMetric.setCoverage(front1,front2);
    values.add(i,result);
  }
  return result;
}","private double calculateSetCoverage(String problem,String algorithmA,String algorithmB){
  double result=5.5;
  SetCoverage setCoverageMetric=new SetCoverage();
  Vector<Double> values=new Vector<Double>(experiment_.getIndependentRuns());
  for (int i=0; i < experiment_.getIndependentRuns(); i++) {
    String front1=experiment_.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmA+ ""String_Node_Str""+ problem+ ""String_Node_Str""+ i;
    String front2=experiment_.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmB+ ""String_Node_Str""+ problem+ ""String_Node_Str""+ i;
    result=setCoverageMetric.setCoverage(front1,front2);
    values.add(i,result);
  }
  return Statistics.calculateMean(values);
}",0.9730113636363636
64716,"/** 
 * Constructor Create a new ElitistES instance.
 * @param problem Problem to solve.
 * @mu Mu
 * @lambda Lambda
 */
public ElitistES(Problem problem,int mu,int lambda){
  super(problem);
  mu_=mu;
  lambda_=lambda;
}","/** 
 * Constructor Create a new ElitistES instance.
 * @param problem Problem to solve.
 * @param mu
 * @param lambda
 */
public ElitistES(Problem problem,int mu,int lambda){
  super(problem);
  mu_=mu;
  lambda_=lambda;
}",0.9414414414414416
64717,"/** 
 * Constructor Create a new NonElitistES instance.
 * @param problem Problem to solve.
 * @mu Mu
 * @lambda Lambda
 */
public NonElitistES(Problem problem,int mu,int lambda){
  super(problem);
  mu_=mu;
  lambda_=lambda;
}","/** 
 * Constructor Create a new NonElitistES instance.
 * @param problem Problem to solve.
 * @param mu
 * @param lambda
 */
public NonElitistES(Problem problem,int mu,int lambda){
  super(problem);
  mu_=mu;
  lambda_=lambda;
}",0.9429824561403508
64718,"/** 
 * @param weights: a vector containing the weights for the aggregative approach
 * @author Juan J. DurilloThis methods creates a single-objective instance using a weighted aggregative approach and write all the information to file
 */
public void createSingleObjectiveInstance(int[] weights){
  if (weights.length != objectives_) {
    Logger.getLogger(ReadInstance.class.getName()).log(Level.SEVERE,""String_Node_Str"");
  }
  try {
    String name=""String_Node_Str"";
    for (int k=0; k < objectives_; k++) {
      name+=""String_Node_Str"" + weights[k];
    }
    Configuration.logger_.info(name);
    Configuration.logger_.info(fileName_ + name);
    FileOutputStream fos=new FileOutputStream(fileName_ + name);
    OutputStreamWriter osw=new OutputStreamWriter(fos);
    BufferedWriter bw=new BufferedWriter(osw);
    bw.write(facilities_ + ""String_Node_Str"");
    bw.newLine();
    bw.newLine();
    String line;
    for (int i=0; i < facilities_; i++) {
      line=""String_Node_Str"";
      for (int j=0; j < facilities_; j++) {
        line+=a_matrix[i][j] + ""String_Node_Str"";
      }
      bw.write(line);
      bw.newLine();
    }
    bw.newLine();
    for (int i=0; i < facilities_; i++) {
      line=""String_Node_Str"";
      for (int j=0; j < facilities_; j++) {
        int aggregateValue=0;
        for (int k=0; k < objectives_; k++) {
          aggregateValue+=weights[k] * b_matrixs[k][i][j];
        }
        line+=aggregateValue + ""String_Node_Str"";
      }
      bw.write(line);
      bw.newLine();
    }
    bw.close();
  }
 catch (  FileNotFoundException ex) {
    Logger.getLogger(ReadInstance.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
  }
catch (  IOException ex1) {
    Logger.getLogger(ReadInstance.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex1);
  }
}","/** 
 * @param a vector containing the weights for the aggregative approach
 * @author Juan J. DurilloThis methods creates a single-objective instance using a weighted aggregative approach and write all the information to file
 */
public void createSingleObjectiveInstance(int[] weights){
  if (weights.length != objectives_) {
    Logger.getLogger(ReadInstance.class.getName()).log(Level.SEVERE,""String_Node_Str"");
  }
  try {
    String name=""String_Node_Str"";
    for (int k=0; k < objectives_; k++) {
      name+=""String_Node_Str"" + weights[k];
    }
    Configuration.logger_.info(name);
    Configuration.logger_.info(fileName_ + name);
    FileOutputStream fos=new FileOutputStream(fileName_ + name);
    OutputStreamWriter osw=new OutputStreamWriter(fos);
    BufferedWriter bw=new BufferedWriter(osw);
    bw.write(facilities_ + ""String_Node_Str"");
    bw.newLine();
    bw.newLine();
    String line;
    for (int i=0; i < facilities_; i++) {
      line=""String_Node_Str"";
      for (int j=0; j < facilities_; j++) {
        line+=a_matrix[i][j] + ""String_Node_Str"";
      }
      bw.write(line);
      bw.newLine();
    }
    bw.newLine();
    for (int i=0; i < facilities_; i++) {
      line=""String_Node_Str"";
      for (int j=0; j < facilities_; j++) {
        int aggregateValue=0;
        for (int k=0; k < objectives_; k++) {
          aggregateValue+=weights[k] * b_matrixs[k][i][j];
        }
        line+=aggregateValue + ""String_Node_Str"";
      }
      bw.write(line);
      bw.newLine();
    }
    bw.close();
  }
 catch (  FileNotFoundException ex) {
    Logger.getLogger(ReadInstance.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex);
  }
catch (  IOException ex1) {
    Logger.getLogger(ReadInstance.class.getName()).log(Level.SEVERE,""String_Node_Str"",ex1);
  }
}",0.9975006942515968
64719,"/** 
 * @param name: the name of the file
 * @author Juan J. DurilloCreates a new ReadInstance for the mQAP problem
 */
public ReadInstance(String name){
  fileName_=name;
}","/** 
 * @param name the name of the file
 * @author Juan J. DurilloCreates a new ReadInstance for the mQAP problem
 */
public ReadInstance(String name){
  fileName_=name;
}",0.9971014492753624
64720,"/** 
 * Creates a new instance of problem mQAP.
 * @param fileName: name of the file containing the instance
 */
public mQAP(String solutionType,String fileName) throws JMException {
  ReadInstance ri=new ReadInstance(fileName);
  ri.loadInstance();
  numberOfVariables_=1;
  numberOfObjectives_=ri.getNumberOfObjectives();
  numberOfConstraints_=0;
  problemName_=""String_Node_Str"";
  a_matrix=ri.get_a_Matrix();
  b_matrixs=ri.get_b_Matrixs();
  upperLimit_=new double[numberOfVariables_];
  lowerLimit_=new double[numberOfVariables_];
  for (int var=0; var < numberOfVariables_; var++) {
    lowerLimit_[var]=0.0;
    upperLimit_[var]=ri.getNumberOfFacilities() - 1;
  }
  length_=new int[numberOfVariables_];
  for (int var=0; var < numberOfVariables_; var++) {
    length_[var]=ri.getNumberOfFacilities();
  }
  if (solutionType.compareTo(""String_Node_Str"") == 0) {
    solutionType_=new PermutationSolutionType(this);
  }
 else {
    throw new JMException(""String_Node_Str"" + solutionType + ""String_Node_Str"");
  }
}","/** 
 * Creates a new instance of problem mQAP.
 */
public mQAP(String solutionType,String fileName) throws JMException {
  ReadInstance ri=new ReadInstance(fileName);
  ri.loadInstance();
  numberOfVariables_=1;
  numberOfObjectives_=ri.getNumberOfObjectives();
  numberOfConstraints_=0;
  problemName_=""String_Node_Str"";
  a_matrix=ri.get_a_Matrix();
  b_matrixs=ri.get_b_Matrixs();
  upperLimit_=new double[numberOfVariables_];
  lowerLimit_=new double[numberOfVariables_];
  for (int var=0; var < numberOfVariables_; var++) {
    lowerLimit_[var]=0.0;
    upperLimit_[var]=ri.getNumberOfFacilities() - 1;
  }
  length_=new int[numberOfVariables_];
  for (int var=0; var < numberOfVariables_; var++) {
    length_[var]=ri.getNumberOfFacilities();
  }
  if (solutionType.compareTo(""String_Node_Str"") == 0) {
    solutionType_=new PermutationSolutionType(this);
  }
 else {
    throw new JMException(""String_Node_Str"" + solutionType + ""String_Node_Str"");
  }
}",0.9692385274836108
64721,"public CEC2005Problem(String solutionType,int problemID,int numberOfVariables) throws JMException {
  numberOfVariables_=numberOfVariables;
  numberOfObjectives_=1;
  numberOfConstraints_=0;
  problemName_=""String_Node_Str"";
  Benchmark cec2005ProblemFactory=new Benchmark();
  testFunction_=cec2005ProblemFactory.testFunctionFactory(problemID,numberOfVariables);
  upperLimit_=new double[numberOfVariables_];
  lowerLimit_=new double[numberOfVariables_];
  double ulimit=0;
  double llimit=0;
switch (problemID) {
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 14:
    ulimit=100;
  llimit=-100;
break;
case 7:
case 25:
ulimit=Double.MAX_VALUE;
llimit=Double.MIN_VALUE;
break;
case 8:
ulimit=32;
llimit=-32;
break;
case 9:
case 10:
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
case 23:
case 24:
ulimit=5;
llimit=-5;
break;
case 11:
ulimit=0.5;
llimit=-0.5;
break;
case 12:
ulimit=Math.PI;
llimit=-Math.PI;
break;
case 13:
ulimit=3;
llimit=1;
break;
default :
throw new JMException(""String_Node_Str"");
}
for (int var=0; var < numberOfVariables_; var++) {
lowerLimit_[var]=llimit;
upperLimit_[var]=ulimit;
}
if (solutionType.compareTo(""String_Node_Str"") == 0) {
solutionType_=new BinaryRealSolutionType(this);
}
 else if (solutionType.compareTo(""String_Node_Str"") == 0) {
solutionType_=new RealSolutionType(this);
}
 else {
throw new JMException(""String_Node_Str"" + solutionType + ""String_Node_Str"");
}
}","/** 
 * Constructor Creates a default instance of the Sphere problem
 * @param numberOfVariables Number of variables of the problem
 * @param solutionType The solution type must ""Real"" or ""BinaryReal"".
 */
public CEC2005Problem(String solutionType,int problemID,int numberOfVariables) throws JMException {
  numberOfVariables_=numberOfVariables;
  numberOfObjectives_=1;
  numberOfConstraints_=0;
  problemName_=""String_Node_Str"";
  Benchmark cec2005ProblemFactory=new Benchmark();
  testFunction_=cec2005ProblemFactory.testFunctionFactory(problemID,numberOfVariables);
  upperLimit_=new double[numberOfVariables_];
  lowerLimit_=new double[numberOfVariables_];
  double ulimit=0;
  double llimit=0;
switch (problemID) {
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 14:
    ulimit=100;
  llimit=-100;
break;
case 7:
case 25:
ulimit=Double.MAX_VALUE;
llimit=Double.MIN_VALUE;
break;
case 8:
ulimit=32;
llimit=-32;
break;
case 9:
case 10:
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
case 23:
case 24:
ulimit=5;
llimit=-5;
break;
case 11:
ulimit=0.5;
llimit=-0.5;
break;
case 12:
ulimit=Math.PI;
llimit=-Math.PI;
break;
case 13:
ulimit=3;
llimit=1;
break;
default :
throw new JMException(""String_Node_Str"");
}
for (int var=0; var < numberOfVariables_; var++) {
lowerLimit_[var]=llimit;
upperLimit_[var]=ulimit;
}
if (solutionType.compareTo(""String_Node_Str"") == 0) {
solutionType_=new BinaryRealSolutionType(this);
}
 else if (solutionType.compareTo(""String_Node_Str"") == 0) {
solutionType_=new RealSolutionType(this);
}
 else {
throw new JMException(""String_Node_Str"" + solutionType + ""String_Node_Str"");
}
}",0.9330734243014944
64722,"/** 
 * Returns the R2 indicator of a given population, using as a reference point 0, 0. Normalization is using taking into account the population itself
 * @param set
 * @return
 */
public double r2(SolutionSet set){
  double[][] approximationFront=set.writeObjectivesToMatrix();
  double[][] trueFront=set.writeObjectivesToMatrix();
  return this.r2(approximationFront,trueFront);
}","/** 
 * Returns the R2 indicator of a given population, using as a reference point 0, 0. Normalization is using taking into account the population itself
 */
public double r2(SolutionSet set){
  double[][] approximationFront=set.writeObjectivesToMatrix();
  double[][] trueFront=set.writeObjectivesToMatrix();
  return this.r2(approximationFront,trueFront);
}",0.9663526244952894
64723,"/** 
 * Calculates the set coverage of the front stored in file1 over the front stored in file2
 * @param file1
 * @param file2
 * @return
 */
public double setCoverage(String file1,String file2){
  MetricsUtil utils=new MetricsUtil();
  double[][] front1=utils.readFront(file1);
  double[][] front2=utils.readFront(file2);
  SolutionSet solutionSet1=transformArraysToSolutionSet(front1);
  SolutionSet solutionSet2=transformArraysToSolutionSet(front2);
  return setCoverage(solutionSet1,solutionSet2);
}","/** 
 * Calculates the set coverage of the front stored in file1 over the front stored in file2
 * @param file1
 * @param file2
 * @return The value of the set coverage
 */
public double setCoverage(String file1,String file2){
  MetricsUtil utils=new MetricsUtil();
  double[][] front1=utils.readFront(file1);
  double[][] front2=utils.readFront(file2);
  SolutionSet solutionSet1=transformArraysToSolutionSet(front1);
  SolutionSet solutionSet2=transformArraysToSolutionSet(front2);
  return setCoverage(solutionSet1,solutionSet2);
}",0.9710982658959536
64724,"/** 
 * The compare method compare the objects o1 and o2.
 * @param o1 An object that reference a double[]
 * @param o2 An object that reference a double[]
 * @return -1 if o1 < o1, 1 if o1 > o2 or 0 in other case.
 */
public int compare(Object o1,Object o2){
  double[] pointOne=(double[])o1;
  double[] pointTwo=(double[])o2;
  int index=0;
  while ((index < pointOne.length) && (index < pointTwo.length) && pointOne[index] == pointTwo[index]) {
    index++;
  }
  if ((index >= pointOne.length) || (index >= pointTwo.length)) {
    return 0;
  }
 else   if (pointOne[index] < pointTwo[index]) {
    return -1;
  }
 else   if (pointOne[index] > pointTwo[index]) {
    return 1;
  }
  return 0;
}","/** 
 * The compare method compare the objects o1 and o2.
 * @param o1 An object that reference a double[]
 * @param o2 An object that reference a double[]
 * @return The following value: -1 if o1 < o1, 1 if o1 > o2 or 0 in other case.
 */
public int compare(Object o1,Object o2){
  double[] pointOne=(double[])o1;
  double[] pointTwo=(double[])o2;
  int index=0;
  while ((index < pointOne.length) && (index < pointTwo.length) && pointOne[index] == pointTwo[index]) {
    index++;
  }
  if ((index >= pointOne.length) || (index >= pointTwo.length)) {
    return 0;
  }
 else   if (pointOne[index] < pointTwo[index]) {
    return -1;
  }
 else   if (pointOne[index] > pointTwo[index]) {
    return 1;
  }
  return 0;
}",0.9851590106007068
64725,"/** 
 * Reads a set of non dominated solutions from a file and store it in a existing non dominated solution set
 * @param path The path of the file containing the data
 * @return A solution set
 */
public void readNonDominatedSolutionSet(String path,NonDominatedSolutionList solutionSet){
  try {
    FileInputStream fis=new FileInputStream(path);
    InputStreamReader isr=new InputStreamReader(fis);
    BufferedReader br=new BufferedReader(isr);
    String aux=br.readLine();
    while (aux != null) {
      StringTokenizer st=new StringTokenizer(aux);
      int i=0;
      Solution solution=new Solution(st.countTokens());
      while (st.hasMoreTokens()) {
        double value=new Double(st.nextToken());
        solution.setObjective(i,value);
        i++;
      }
      solutionSet.add(solution);
      aux=br.readLine();
    }
    br.close();
  }
 catch (  Exception e) {
    Configuration.logger_.log(Level.SEVERE,""String_Node_Str"" + path,e);
  }
}","/** 
 * Reads a set of non dominated solutions from a file and store it in a existing non dominated solution set
 */
public void readNonDominatedSolutionSet(String path,NonDominatedSolutionList solutionSet){
  try {
    FileInputStream fis=new FileInputStream(path);
    InputStreamReader isr=new InputStreamReader(fis);
    BufferedReader br=new BufferedReader(isr);
    String aux=br.readLine();
    while (aux != null) {
      StringTokenizer st=new StringTokenizer(aux);
      int i=0;
      Solution solution=new Solution(st.countTokens());
      while (st.hasMoreTokens()) {
        double value=new Double(st.nextToken());
        solution.setObjective(i,value);
        i++;
      }
      solutionSet.add(solution);
      aux=br.readLine();
    }
    br.close();
  }
 catch (  Exception e) {
    Configuration.logger_.log(Level.SEVERE,""String_Node_Str"" + path,e);
  }
}",0.9553376906318084
64726,"/** 
 * @param name: the name of the file
 * @author Juan J. DurilloCreates a new instance
 * @throws IOException 
 */
public ExtractParetoFront(String name,int dimensions) throws IOException {
  fileName_=name;
  dimensions_=dimensions;
  loadInstance();
}","/** 
 * @param name the name of the file
 * @author Juan J. DurilloCreates a new instance
 * @throws IOException 
 */
public ExtractParetoFront(String name,int dimensions) throws IOException {
  fileName_=name;
  dimensions_=dimensions;
  loadInstance();
}",0.9980506822612084
64727,"/** 
 * Adds a <code>Solution</code> to the archive. If the <code>Solution</code> is dominated by any member of the archive then it is discarded. If the <code>Solution</code> dominates some members of the archive, these are removed. If the archive is full and the <code>Solution</code> has to be inserted, all the solutions are ordered by his strengthRawFitness value and the one having the worst value is removed.
 * @param solution The <code>Solution</code>
 * @return true if the <code>Solution</code> has been inserted, falseotherwise.
 */
public boolean add(Solution solution){
  int flag=0;
  int i=0;
  Solution aux;
  while (i < solutionsList_.size()) {
    aux=solutionsList_.get(i);
    flag=dominance_.compare(solution,aux);
    if (flag == 1) {
      return false;
    }
 else     if (flag == -1) {
      solutionsList_.remove(i);
    }
 else {
      if (equals_.compare(aux,solution) == 0) {
        return false;
      }
      i++;
    }
  }
  solutionsList_.add(solution);
  if (size() > maxSize_) {
    (new Spea2Fitness(this)).fitnessAssign();
    remove(indexWorst(fitnessComparator_));
  }
  return true;
}","/** 
 * Adds a Solution to the archive. If the <code>Solution</code> is dominated by any member of the archive then it is discarded. If the <code>Solution</code> dominates some members of the archive, these are removed. If the archive is full and the <code>Solution</code> has to be inserted, all the solutions are ordered by his strengthRawFitness value and the one having the worst value is removed.
 * @param solution The <code>Solution</code>
 * @return true if the <code>Solution</code> has been inserted, falseotherwise.
 */
public boolean add(Solution solution){
  int flag=0;
  int i=0;
  Solution aux;
  while (i < solutionsList_.size()) {
    aux=solutionsList_.get(i);
    flag=dominance_.compare(solution,aux);
    if (flag == 1) {
      return false;
    }
 else     if (flag == -1) {
      solutionsList_.remove(i);
    }
 else {
      if (equals_.compare(aux,solution) == 0) {
        return false;
      }
      i++;
    }
  }
  solutionsList_.add(solution);
  if (size() > maxSize_) {
    (new Spea2Fitness(this)).fitnessAssign();
    remove(indexWorst(fitnessComparator_));
  }
  return true;
}",0.994188645507376
64728,"/** 
 * Comparator
 * @param node1
 * @param node2
 * @return -1 if node1 < node2, +1 if node1 > node2; 0 if node1 == node2
 */
public int compareNodes(AvlNode<T> node1,AvlNode<T> node2){
  return comparator_.compare(node1.getItem(),node2.getItem());
}","/** 
 * Comparator
 * @param node1
 * @param node2
 * @return The result of the comparison according to the comparators
 */
public int compareNodes(AvlNode<T> node1,AvlNode<T> node2){
  return comparator_.compare(node1.getItem(),node2.getItem());
}",0.772
64729,"/** 
 * Compares two solutions.
 * @param o1 Object representing the first <code>Solution</code>.
 * @param o2 Object representing the second <code>Solution</code>.
 * @return 0, if both solutions are equals with a certain dissimilarity, -1otherwise.
 * @throws JMException
 * @throws JMException
 */
@Override public int compare(Solution o1,Solution o2){
  Solution solution1, solution2;
  solution1=(Solution)o1;
  solution2=(Solution)o2;
  if ((solution1.getDecisionVariables() != null) && (solution2.getDecisionVariables() != null)) {
    if (solution1.numberOfVariables() != solution2.numberOfVariables()) {
      return -1;
    }
  }
  try {
    if ((new Distance()).distanceBetweenSolutions(solution1,solution2) < EPSILON) {
      return 0;
    }
  }
 catch (  JMException e) {
    Configuration.logger_.log(Level.SEVERE,""String_Node_Str"",e);
  }
  return -1;
}","/** 
 * Compares two solutions.
 * @param o1 Object representing the first solution.
 * @param o2 Object representing the second solution.
 * @return 0, if both solutions are equals with a certain dissimilarity, -1otherwise.
 * @throws JMException
 * @throws JMException
 */
@Override public int compare(Solution o1,Solution o2){
  Solution solution1, solution2;
  solution1=(Solution)o1;
  solution2=(Solution)o2;
  if ((solution1.getDecisionVariables() != null) && (solution2.getDecisionVariables() != null)) {
    if (solution1.numberOfVariables() != solution2.numberOfVariables()) {
      return -1;
    }
  }
  try {
    if ((new Distance()).distanceBetweenSolutions(solution1,solution2) < EPSILON) {
      return 0;
    }
  }
 catch (  JMException e) {
    Configuration.logger_.log(Level.SEVERE,""String_Node_Str"",e);
  }
  return -1;
}",0.9134502923976608
64730,"private void generateTable(String problem) throws IOException {
  writeTableHeader(problem);
  for (int i=0; i < experiment_.getAlgorithmNameList().length; i++) {
    writeTableRow(i,problem);
  }
  writeTableTail();
}","private void generateTable(String problem) throws IOException, JMException {
  writeTableHeader(problem);
  for (int i=0; i < experiment_.getAlgorithmNameList().length; i++) {
    writeTableRow(i,problem);
  }
  writeTableTail();
}",0.9710467706013364
64731,"private void writeTableRow(int algorithmIndex,String problem) throws IOException {
  fileWriter_.write(""String_Node_Str"" + experiment_.getAlgorithmNameList()[algorithmIndex] + ""String_Node_Str"");
  for (int i=0; i < experiment_.getAlgorithmNameList().length; i++) {
    if (i != algorithmIndex) {
      double setCoverageValueAB=calculateSetCoverage(problem,experiment_.getAlgorithmNameList()[algorithmIndex],experiment_.getAlgorithmNameList()[i]);
      String setCoverageAB=String.format(Locale.ENGLISH,""String_Node_Str"",setCoverageValueAB);
      fileWriter_.write(""String_Node_Str"" + setCoverageAB);
    }
 else     fileWriter_.write(""String_Node_Str"");
    if (i < (experiment_.getAlgorithmNameList().length - 1)) {
      fileWriter_.write(""String_Node_Str"");
    }
  }
  fileWriter_.write(""String_Node_Str"");
}","private void writeTableRow(int algorithmIndex,String problem) throws IOException, JMException {
  fileWriter_.write(""String_Node_Str"" + experiment_.getAlgorithmNameList()[algorithmIndex] + ""String_Node_Str"");
  for (int i=0; i < experiment_.getAlgorithmNameList().length; i++) {
    if (i != algorithmIndex) {
      double setCoverageValueAB=calculateSetCoverage(problem,experiment_.getAlgorithmNameList()[algorithmIndex],experiment_.getAlgorithmNameList()[i]);
      String setCoverageAB=String.format(Locale.ENGLISH,""String_Node_Str"",setCoverageValueAB);
      fileWriter_.write(""String_Node_Str"" + setCoverageAB);
    }
 else     fileWriter_.write(""String_Node_Str"");
    if (i < (experiment_.getAlgorithmNameList().length - 1)) {
      fileWriter_.write(""String_Node_Str"");
    }
  }
  fileWriter_.write(""String_Node_Str"");
}",0.99209726443769
64732,"private double calculateSetCoverage(String problem,String algorithmA,String algorithmB){
  double result=5.5;
  SetCoverage setCoverageMetric=new SetCoverage();
  Vector<Double> values=new Vector<Double>(experiment_.getIndependentRuns());
  for (int i=0; i < experiment_.getIndependentRuns(); i++) {
    String front1=experiment_.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmA+ ""String_Node_Str""+ problem+ ""String_Node_Str""+ i;
    String front2=experiment_.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmB+ ""String_Node_Str""+ problem+ ""String_Node_Str""+ i;
    result=setCoverageMetric.setCoverage(front1,front2);
    values.add(i,result);
  }
  return Statistics.calculateMean(values);
}","private double calculateSetCoverage(String problem,String algorithmA,String algorithmB) throws JMException {
  double result=5.5;
  SetCoverage setCoverageMetric=new SetCoverage();
  Vector<Double> values=new Vector<Double>(experiment_.getIndependentRuns());
  for (int i=0; i < experiment_.getIndependentRuns(); i++) {
    String front1=experiment_.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmA+ ""String_Node_Str""+ problem+ ""String_Node_Str""+ i;
    String front2=experiment_.getExperimentBaseDirectory() + ""String_Node_Str"" + algorithmB+ ""String_Node_Str""+ problem+ ""String_Node_Str""+ i;
    result=setCoverageMetric.setCoverage(front1,front2);
    values.add(i,result);
  }
  return Statistics.calculateMean(values);
}",0.9862448418156808
64733,"@Override public void generate() throws IOException {
  createOutputDirectory();
  String outputTexFile=outputDirectoryName_ + ""String_Node_Str"" + ""String_Node_Str"";
  fileWriter_=new FileWriter(outputTexFile,false);
  generateLatexHeader();
  for (  String problem : experiment_.getProblemList()) {
    generateTable(problem);
  }
  generateLatexTail();
  fileWriter_.close();
}","@Override public void generate() throws IOException, JMException {
  createOutputDirectory();
  String outputTexFile=outputDirectoryName_ + ""String_Node_Str"" + ""String_Node_Str"";
  fileWriter_=new FileWriter(outputTexFile,false);
  generateLatexHeader();
  for (  String problem : experiment_.getProblemList()) {
    generateTable(problem);
  }
  generateLatexTail();
  fileWriter_.close();
}",0.9831387808041504
64734,"/** 
 * Runs the NSGA-II algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws jmetal.util.JMException
 */
public SolutionSet execute() throws JMException, ClassNotFoundException {
  readParameterSettings();
  population_=createInitialPopulation(populationSize_);
  evaluatePopulation(population_);
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(populationSize_);
    for (int i=0; i < (populationSize_ / 2); i++) {
      if (!stoppingCondition()) {
        Solution[] parents=new Solution[2];
        parents[0]=(Solution)selectionOperator_.execute(population_);
        parents[1]=(Solution)selectionOperator_.execute(population_);
        Solution[] offSpring=(Solution[])crossoverOperator_.execute(parents);
        mutationOperator_.execute(offSpring[0]);
        mutationOperator_.execute(offSpring[1]);
        offspringPopulation_.add(offSpring[0]);
        offspringPopulation_.add(offSpring[1]);
      }
    }
    evaluatePopulation(offspringPopulation_);
    Ranking ranking=rankPopulation();
    population_.clear();
    int rankingIndex=0;
    while (population_.size() < populationSize_) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
  }
  Ranking ranking=new Ranking(population_);
  return ranking.getSubfront(0);
}","/** 
 * Runs the NSGA-II algorithm.
 * @return a <code>SolutionSet</code> that is a set of non dominated solutionsas a result of the algorithm execution
 * @throws jmetal.util.JMException
 */
public SolutionSet execute() throws JMException, ClassNotFoundException {
  readParameterSettings();
  population_=createInitialPopulation(populationSize_);
  evaluatePopulation(population_);
  while (!stoppingCondition()) {
    offspringPopulation_=new SolutionSet(populationSize_);
    for (int i=0; i < (populationSize_ / 2); i++) {
      if (!stoppingCondition()) {
        Solution[] parents=new Solution[2];
        parents[0]=(Solution)selectionOperator_.execute(population_);
        parents[1]=(Solution)selectionOperator_.execute(population_);
        Solution[] offSpring=(Solution[])crossoverOperator_.execute(parents);
        mutationOperator_.execute(offSpring[0]);
        mutationOperator_.execute(offSpring[1]);
        offspringPopulation_.add(offSpring[0]);
        offspringPopulation_.add(offSpring[1]);
      }
    }
    evaluatePopulation(offspringPopulation_);
    Ranking ranking=rankPopulation();
    population_.clear();
    int rankingIndex=0;
    while (populationIsNotFull()) {
      if (subfrontFillsIntoThePopulation(ranking,rankingIndex)) {
        addRankedSolutionsToPopulation(ranking,rankingIndex);
        rankingIndex++;
      }
 else {
        computeCrowdingDistance(ranking,rankingIndex);
        addLastRankedSolutions(ranking,rankingIndex);
      }
    }
  }
  Ranking ranking=new Ranking(population_);
  evaluator_.shutdown();
  return ranking.getSubfront(0);
}",0.9717691342534504
64735,"/** 
 * Writes the decision encodings.variable values of the <code>Solution</code> solutions objects into the set in a file.
 * @param path The output file name
 */
public void printVariablesToFile(String path) throws IOException {
  FileOutputStream fos=new FileOutputStream(path);
  OutputStreamWriter osw=new OutputStreamWriter(fos);
  BufferedWriter bw=new BufferedWriter(osw);
  if (isEmtpy()) {
    int numberOfVariables=solutionsList_.get(0).getDecisionVariables().length;
    for (    Solution aSolutionsList : solutionsList_) {
      for (int j=0; j < numberOfVariables; j++) {
        bw.write(aSolutionsList.getDecisionVariables()[j].toString() + ""String_Node_Str"");
      }
      bw.newLine();
    }
  }
  bw.close();
}","/** 
 * Writes the decision encodings.variable values of the <code>Solution</code> solutions objects into the set in a file.
 * @param path The output file name
 */
public void printVariablesToFile(String path) throws IOException {
  FileOutputStream fos=new FileOutputStream(path);
  OutputStreamWriter osw=new OutputStreamWriter(fos);
  BufferedWriter bw=new BufferedWriter(osw);
  if (!isEmtpy()) {
    int numberOfVariables=solutionsList_.get(0).getDecisionVariables().length;
    for (    Solution aSolutionsList : solutionsList_) {
      for (int j=0; j < numberOfVariables; j++) {
        bw.write(aSolutionsList.getDecisionVariables()[j].toString() + ""String_Node_Str"");
      }
      bw.newLine();
    }
  }
  bw.close();
}",0.9993164730006836
64736,"/** 
 * Constructor
 */
public SMPSO_Settings(String problem){
  super(problem);
  Object[] problemParams={""String_Node_Str""};
  try {
    problem_=(new ProblemFactory()).getProblem(problemName_,problemParams);
  }
 catch (  JMException e) {
    Configuration.logger_.log(Level.SEVERE,""String_Node_Str"",e);
  }
  swarmSize_=100;
  maxIterations_=250;
  archiveSize_=100;
  mutationDistributionIndex_=20.0;
  mutationProbability_=1.0 / problem_.getNumberOfVariables();
  c1Max_=2.5;
  c1Min_=1.5;
  c2Max_=2.5;
  c2Min_=1.5;
  weightMax_=0.1;
  weightMin_=0.1;
  changeVelocity1=-1;
  changeVelocity2=-1;
}","/** 
 * Constructor
 */
public SMPSO_Settings(String problem){
  super(problem);
  Object[] problemParams={""String_Node_Str""};
  try {
    problem_=(new ProblemFactory()).getProblem(problemName_,problemParams);
  }
 catch (  JMException e) {
    Configuration.logger_.log(Level.SEVERE,""String_Node_Str"",e);
  }
  swarmSize_=100;
  maxIterations_=250;
  archiveSize_=100;
  mutationDistributionIndex_=20.0;
  mutationProbability_=1.0 / problem_.getNumberOfVariables();
  c1Max_=2.5;
  c1Min_=1.5;
  c2Max_=2.5;
  c2Min_=1.5;
  weightMax_=0.1;
  weightMin_=0.1;
  changeVelocity1_=-1;
  changeVelocity2_=-1;
}",0.9983498349834984
64737,"/** 
 * Configure SMPSO with user-defined parameter experiments.settings
 * @return A SMPSO algorithm object
 */
@Override public Algorithm configure(Properties configuration) throws JMException {
  Algorithm algorithm;
  Mutation mutation;
  algorithm=new SMPSO(problem_);
  swarmSize_=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(swarmSize_)));
  maxIterations_=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(maxIterations_)));
  archiveSize_=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(archiveSize_)));
  c1Min_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(c1Min_)));
  c1Max_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(c1Max_)));
  c2Min_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(c2Min_)));
  c2Min_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(c2Max_)));
  weightMin_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(weightMin_)));
  weightMax_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(weightMax_)));
  algorithm.setInputParameter(""String_Node_Str"",swarmSize_);
  algorithm.setInputParameter(""String_Node_Str"",maxIterations_);
  algorithm.setInputParameter(""String_Node_Str"",archiveSize_);
  algorithm.setInputParameter(""String_Node_Str"",c1Min_);
  algorithm.setInputParameter(""String_Node_Str"",c1Max_);
  algorithm.setInputParameter(""String_Node_Str"",c2Min_);
  algorithm.setInputParameter(""String_Node_Str"",c2Max_);
  algorithm.setInputParameter(""String_Node_Str"",weightMin_);
  algorithm.setInputParameter(""String_Node_Str"",weightMax_);
  algorithm.setInputParameter(""String_Node_Str"",changeVelocity1);
  algorithm.setInputParameter(""String_Node_Str"",changeVelocity2);
  mutationProbability_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationProbability_)));
  mutationDistributionIndex_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationDistributionIndex_)));
  mutationProbability_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationProbability_)));
  mutationDistributionIndex_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationDistributionIndex_)));
  HashMap<String,Object> parameters=new HashMap<String,Object>();
  parameters.put(""String_Node_Str"",mutationProbability_);
  parameters.put(""String_Node_Str"",mutationDistributionIndex_);
  mutation=MutationFactory.getMutationOperator(""String_Node_Str"",parameters);
  algorithm.addOperator(""String_Node_Str"",mutation);
  return algorithm;
}","/** 
 * Configure SMPSO with user-defined parameter experiments.settings
 * @return A SMPSO algorithm object
 */
@Override public Algorithm configure(Properties configuration) throws JMException {
  Algorithm algorithm;
  Mutation mutation;
  algorithm=new SMPSO(problem_);
  swarmSize_=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(swarmSize_)));
  maxIterations_=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(maxIterations_)));
  archiveSize_=Integer.parseInt(configuration.getProperty(""String_Node_Str"",String.valueOf(archiveSize_)));
  c1Min_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(c1Min_)));
  c1Max_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(c1Max_)));
  c2Min_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(c2Min_)));
  c2Min_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(c2Max_)));
  weightMin_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(weightMin_)));
  weightMax_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(weightMax_)));
  algorithm.setInputParameter(""String_Node_Str"",swarmSize_);
  algorithm.setInputParameter(""String_Node_Str"",maxIterations_);
  algorithm.setInputParameter(""String_Node_Str"",archiveSize_);
  algorithm.setInputParameter(""String_Node_Str"",c1Min_);
  algorithm.setInputParameter(""String_Node_Str"",c1Max_);
  algorithm.setInputParameter(""String_Node_Str"",c2Min_);
  algorithm.setInputParameter(""String_Node_Str"",c2Max_);
  algorithm.setInputParameter(""String_Node_Str"",weightMin_);
  algorithm.setInputParameter(""String_Node_Str"",weightMax_);
  algorithm.setInputParameter(""String_Node_Str"",changeVelocity1_);
  algorithm.setInputParameter(""String_Node_Str"",changeVelocity2_);
  mutationProbability_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationProbability_)));
  mutationDistributionIndex_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationDistributionIndex_)));
  mutationProbability_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationProbability_)));
  mutationDistributionIndex_=Double.parseDouble(configuration.getProperty(""String_Node_Str"",String.valueOf(mutationDistributionIndex_)));
  HashMap<String,Object> parameters=new HashMap<String,Object>();
  parameters.put(""String_Node_Str"",mutationProbability_);
  parameters.put(""String_Node_Str"",mutationDistributionIndex_);
  mutation=MutationFactory.getMutationOperator(""String_Node_Str"",parameters);
  algorithm.addOperator(""String_Node_Str"",mutation);
  return algorithm;
}",0.99963530269876
64738,"@Test public void testDeletingNodesWithTwoLeaves() throws Exception {
  AvlNode<Integer> node;
  node=new AvlNode<Integer>(20);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(8);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(22);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(4);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(12);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(24);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(10);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(14);
  avlTree_.insertAvlNode(node);
  String expected=""String_Node_Str"";
  assertEquals(""String_Node_Str"",expected,avlTree_.toString());
  avlTree_.delete(12);
  node=avlTree_.search(8);
  assertEquals(""String_Node_Str"",14,node.getRight().getItem());
  assertEquals(""String_Node_Str"",""String_Node_Str"",avlTree_.toString());
  avlTree_.delete(8);
  assertEquals(""String_Node_Str"",10,avlTree_.getTop().getLeft().getItem());
  assertEquals(""String_Node_Str"",""String_Node_Str"",avlTree_.toString());
}","@Test public void testDeletingNodesWithTwoLeaves() throws Exception {
  AvlNode<Integer> node;
  node=new AvlNode<Integer>(20);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(8);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(22);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(4);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(12);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(24);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(10);
  avlTree_.insertAvlNode(node);
  node=new AvlNode<Integer>(14);
  avlTree_.insertAvlNode(node);
  String expected=""String_Node_Str"";
  assertEquals(""String_Node_Str"",expected,avlTree_.toString());
  avlTree_.delete(12);
  node=avlTree_.search(8);
  assertEquals(""String_Node_Str"",14,(int)node.getRight().getItem());
  assertEquals(""String_Node_Str"",""String_Node_Str"",avlTree_.toString());
  avlTree_.delete(8);
  assertEquals(""String_Node_Str"",10,(int)avlTree_.getTop().getLeft().getItem());
  assertEquals(""String_Node_Str"",""String_Node_Str"",avlTree_.toString());
}",0.9953617810760668
64739,"/** 
 * Constructor
 */
public dMOPSO_Settings(String problem){
  super(problem);
  Object[] problemParams={""String_Node_Str""};
  try {
    problem_=(new ProblemFactory()).getProblem(problemName_,problemParams);
  }
 catch (  JMException e) {
    e.printStackTrace();
  }
  swarmSize_=300;
  maxIterations_=250;
  maxAge_=2;
  functionType_=""String_Node_Str"";
  dataDirectory_=""String_Node_Str"";
}","/** 
 * Constructor
 */
public dMOPSO_Settings(String problem){
  super(problem);
  Object[] problemParams={""String_Node_Str""};
  try {
    problem_=(new ProblemFactory()).getProblem(problemName_,problemParams);
  }
 catch (  JMException e) {
    e.printStackTrace();
  }
  swarmSize_=100;
  maxIterations_=250;
  maxAge_=2;
  functionType_=""String_Node_Str"";
  dataDirectory_=""String_Node_Str"";
}",0.9974811083123426
64740,"/** 
 * Evaluates a solution
 * @param solution The solution to evaluate
 * @throws jmetal.util.JMException
 */
public void evaluate(Solution solution) throws JMException {
  Variable[] decisionVariables=solution.getDecisionVariables();
  double[] x=new double[decisionVariables.length];
  double[] f=new double[10];
  for (int i=0; i < decisionVariables.length; i++) {
    x[i]=decisionVariables[i].getValue();
  }
  try {
    testFunc_.test_func(x,f,numberOfVariables_,populationSize_,problemID_);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  solution.setObjective(0,f[0]);
}","/** 
 * Evaluates a solution
 * @param solution The solution to evaluate
 * @throws jmetal.util.JMException
 */
public void evaluate(Solution solution) throws JMException {
  Variable[] decisionVariables=solution.getDecisionVariables();
  double[] x=new double[decisionVariables.length];
  double[] f=new double[10];
  for (int i=0; i < decisionVariables.length; i++) {
    x[i]=decisionVariables[i].getValue();
  }
  try {
    testFunc_.test_func(x,f,numberOfVariables_,3,problemID_);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  solution.setObjective(0,f[0]);
}",0.9863247863247864
64741,"public void test_func(double[] x,double[] f,int nx,int mx,int func_num) throws Exception {
  int cf_num=10, i, j;
  if (ini_flag == 1) {
    if ((n_flag != nx) || (func_flag != func_num)) {
      ini_flag=0;
    }
  }
  if (ini_flag == 0) {
    y=new double[nx];
    z=new double[nx];
    x_bound=new double[nx];
    for (i=0; i < nx; i++)     x_bound[i]=100.0;
    if (!(nx == 2 || nx == 10 || nx == 20 || nx == 30 || nx == 50 || nx == 100)) {
      System.out.println(""String_Node_Str"");
    }
    if (nx == 2 && ((func_num >= 17 && func_num <= 22) || (func_num >= 29 && func_num <= 30))) {
      System.out.println(""String_Node_Str"");
    }
    File fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str""+ nx+ ""String_Node_Str"");
    Scanner input=new Scanner(fpt);
    if (!fpt.exists()) {
      System.out.println(""String_Node_Str"");
    }
    if (func_num < 23) {
      M=new double[nx * nx];
      for (i=0; i < nx * nx; i++) {
        M[i]=input.nextDouble();
      }
    }
 else {
      M=new double[cf_num * nx * nx];
      for (i=0; i < cf_num * nx * nx; i++) {
        M[i]=input.nextDouble();
      }
    }
    input.close();
    if (func_num < 23) {
      fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str"");
      input=new Scanner(fpt);
      if (!fpt.exists()) {
        System.out.println(""String_Node_Str"");
      }
      OShift=new double[nx];
      for (i=0; i < nx; i++) {
        OShift[i]=input.nextDouble();
        if (OShift == null) {
          System.out.println(""String_Node_Str"");
        }
      }
      input.close();
    }
 else {
      OShift=new double[nx * cf_num];
      fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str"");
      FileReader reader=new FileReader(fpt);
      BufferedReader br=new BufferedReader(reader);
      String[] s=new String[100];
      for (i=0; i < cf_num; i++) {
        s[i]=br.readLine();
        String[] array=s[i].split(""String_Node_Str"");
        double[] temp=new double[array.length - 1];
        for (int k=0; k < array.length - 1; k++) {
          temp[k]=Double.parseDouble(array[k + 1]);
        }
        for (j=0; j < nx; j++) {
          OShift[i * nx + j]=temp[j];
        }
      }
      br.close();
      reader.close();
      input.close();
    }
    input.close();
    if (func_num >= 17 && func_num <= 22) {
      fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str""+ nx+ ""String_Node_Str"");
      input=new Scanner(fpt);
      if (!fpt.exists()) {
        System.out.println(""String_Node_Str"");
      }
      SS=new int[nx];
      for (i=0; i < nx; i++) {
        SS[i]=input.nextInt();
      }
    }
 else     if (func_num == 29 || func_num == 30) {
      fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str""+ nx+ ""String_Node_Str"");
      input=new Scanner(fpt);
      if (!fpt.exists()) {
        System.out.println(""String_Node_Str"");
      }
      SS=new int[nx * cf_num];
      for (i=0; i < nx * cf_num; i++) {
        SS[i]=input.nextInt();
      }
    }
    input.close();
    n_flag=nx;
    func_flag=func_num;
    ini_flag=1;
  }
  double[] t=new double[nx];
  for (i=0; i < mx; i++) {
    for (j=0; j < nx; j++) {
      t[j]=x[i * nx + j];
    }
switch (func_num) {
case 1:
      f[i]=ellips_func(t,f[i],nx,OShift,M,1,1);
    f[i]+=100.0;
  break;
case 2:
f[i]=bent_cigar_func(t,f[i],nx,OShift,M,1,1);
f[i]+=200.0;
break;
case 3:
f[i]=discus_func(t,f[i],nx,OShift,M,1,1);
f[i]+=300.0;
break;
case 4:
f[i]=rosenbrock_func(t,f[i],nx,OShift,M,1,1);
f[i]+=400.0;
break;
case 5:
f[i]=ackley_func(t,f[i],nx,OShift,M,1,1);
f[i]+=500.0;
break;
case 6:
f[i]=weierstrass_func(t,f[i],nx,OShift,M,1,1);
f[i]+=600.0;
break;
case 7:
f[i]=griewank_func(t,f[i],nx,OShift,M,1,1);
f[i]+=700.0;
break;
case 8:
f[i]=rastrigin_func(t,f[i],nx,OShift,M,1,0);
f[i]+=800.0;
break;
case 9:
f[i]=rastrigin_func(t,f[i],nx,OShift,M,1,1);
f[i]+=900.0;
break;
case 10:
f[i]=schwefel_func(t,f[i],nx,OShift,M,1,0);
f[i]+=1000.0;
break;
case 11:
f[i]=schwefel_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1100.0;
break;
case 12:
f[i]=katsuura_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1200.0;
break;
case 13:
f[i]=happycat_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1300.0;
break;
case 14:
f[i]=hgbat_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1400.0;
break;
case 15:
f[i]=grie_rosen_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1500.0;
break;
case 16:
f[i]=escaffer6_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1600.0;
break;
case 17:
f[i]=hf01(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=1700.0;
break;
case 18:
f[i]=hf02(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=1800.0;
break;
case 19:
f[i]=hf03(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=1900.0;
break;
case 20:
f[i]=hf04(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=2000.0;
break;
case 21:
f[i]=hf05(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=2100.0;
break;
case 22:
f[i]=hf06(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=2200.0;
break;
case 23:
f[i]=cf01(t,f[i],nx,OShift,M,1);
f[i]+=2300.0;
break;
case 24:
f[i]=cf02(t,f[i],nx,OShift,M,1);
f[i]+=2400.0;
break;
case 25:
f[i]=cf03(t,f[i],nx,OShift,M,1);
f[i]+=2500.0;
break;
case 26:
f[i]=cf04(t,f[i],nx,OShift,M,1);
f[i]+=2600.0;
break;
case 27:
f[i]=cf05(t,f[i],nx,OShift,M,1);
f[i]+=2700.0;
break;
case 28:
f[i]=cf06(t,f[i],nx,OShift,M,1);
f[i]+=2800.0;
break;
case 29:
f[i]=cf07(t,f[i],nx,OShift,M,SS,1);
f[i]+=2900.0;
break;
case 30:
f[i]=cf08(t,f[i],nx,OShift,M,SS,1);
f[i]+=3000.0;
break;
default :
System.out.println(""String_Node_Str"");
f[i]=0.0;
break;
}
}
}","public void test_func(double[] x,double[] f,int nx,int mx,int func_num) throws Exception {
  int cf_num=10, i, j;
  if (ini_flag == 1) {
    if ((n_flag != nx) || (func_flag != func_num)) {
      ini_flag=0;
    }
  }
  if (ini_flag == 0) {
    y=new double[nx];
    z=new double[nx];
    x_bound=new double[nx];
    for (i=0; i < nx; i++)     x_bound[i]=100.0;
    if (!(nx == 2 || nx == 10 || nx == 20 || nx == 30 || nx == 50 || nx == 100)) {
      System.out.println(""String_Node_Str"");
    }
    if (nx == 2 && ((func_num >= 17 && func_num <= 22) || (func_num >= 29 && func_num <= 30))) {
      System.out.println(""String_Node_Str"");
    }
    java.util.Locale locale=Locale.ENGLISH;
    File fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str""+ nx+ ""String_Node_Str"");
    Scanner input=new Scanner(fpt);
    if (!fpt.exists()) {
      System.out.println(""String_Node_Str"");
    }
    input.useLocale(locale);
    if (func_num < 23) {
      M=new double[nx * nx];
      for (i=0; i < nx * nx; i++) {
        M[i]=input.nextDouble();
      }
    }
 else {
      M=new double[cf_num * nx * nx];
      for (i=0; i < cf_num * nx * nx; i++) {
        M[i]=input.nextDouble();
      }
    }
    input.close();
    if (func_num < 23) {
      fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str"");
      input=new Scanner(fpt);
      if (!fpt.exists()) {
        System.out.println(""String_Node_Str"");
      }
      input.useLocale(locale);
      OShift=new double[nx];
      for (i=0; i < nx; i++) {
        OShift[i]=input.nextDouble();
        if (OShift == null) {
          System.out.println(""String_Node_Str"");
        }
      }
      input.close();
    }
 else {
      OShift=new double[nx * cf_num];
      fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str"");
      FileReader reader=new FileReader(fpt);
      BufferedReader br=new BufferedReader(reader);
      String[] s=new String[100];
      for (i=0; i < cf_num; i++) {
        s[i]=br.readLine();
        String[] array=s[i].split(""String_Node_Str"");
        double[] temp=new double[array.length - 1];
        for (int k=0; k < array.length - 1; k++) {
          temp[k]=Double.parseDouble(array[k + 1]);
        }
        for (j=0; j < nx; j++) {
          OShift[i * nx + j]=temp[j];
        }
      }
      br.close();
      reader.close();
      input.close();
    }
    input.close();
    if (func_num >= 17 && func_num <= 22) {
      fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str""+ nx+ ""String_Node_Str"");
      input=new Scanner(fpt);
      if (!fpt.exists()) {
        System.out.println(""String_Node_Str"");
      }
      input.useLocale(locale);
      SS=new int[nx];
      for (i=0; i < nx; i++) {
        SS[i]=input.nextInt();
      }
    }
 else     if (func_num == 29 || func_num == 30) {
      fpt=new File(Configuration.cec2014SupportDataDirectory + ""String_Node_Str"" + func_num+ ""String_Node_Str""+ nx+ ""String_Node_Str"");
      input=new Scanner(fpt);
      if (!fpt.exists()) {
        System.out.println(""String_Node_Str"");
      }
      input.useLocale(locale);
      SS=new int[nx * cf_num];
      for (i=0; i < nx * cf_num; i++) {
        SS[i]=input.nextInt();
      }
    }
    input.close();
    n_flag=nx;
    func_flag=func_num;
    ini_flag=1;
  }
  double[] t=new double[nx];
  for (i=0; i < mx; i++) {
    for (j=0; j < nx; j++) {
      t[j]=x[i * nx + j];
    }
switch (func_num) {
case 1:
      f[i]=ellips_func(t,f[i],nx,OShift,M,1,1);
    f[i]+=100.0;
  break;
case 2:
f[i]=bent_cigar_func(t,f[i],nx,OShift,M,1,1);
f[i]+=200.0;
break;
case 3:
f[i]=discus_func(t,f[i],nx,OShift,M,1,1);
f[i]+=300.0;
break;
case 4:
f[i]=rosenbrock_func(t,f[i],nx,OShift,M,1,1);
f[i]+=400.0;
break;
case 5:
f[i]=ackley_func(t,f[i],nx,OShift,M,1,1);
f[i]+=500.0;
break;
case 6:
f[i]=weierstrass_func(t,f[i],nx,OShift,M,1,1);
f[i]+=600.0;
break;
case 7:
f[i]=griewank_func(t,f[i],nx,OShift,M,1,1);
f[i]+=700.0;
break;
case 8:
f[i]=rastrigin_func(t,f[i],nx,OShift,M,1,0);
f[i]+=800.0;
break;
case 9:
f[i]=rastrigin_func(t,f[i],nx,OShift,M,1,1);
f[i]+=900.0;
break;
case 10:
f[i]=schwefel_func(t,f[i],nx,OShift,M,1,0);
f[i]+=1000.0;
break;
case 11:
f[i]=schwefel_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1100.0;
break;
case 12:
f[i]=katsuura_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1200.0;
break;
case 13:
f[i]=happycat_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1300.0;
break;
case 14:
f[i]=hgbat_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1400.0;
break;
case 15:
f[i]=grie_rosen_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1500.0;
break;
case 16:
f[i]=escaffer6_func(t,f[i],nx,OShift,M,1,1);
f[i]+=1600.0;
break;
case 17:
f[i]=hf01(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=1700.0;
break;
case 18:
f[i]=hf02(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=1800.0;
break;
case 19:
f[i]=hf03(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=1900.0;
break;
case 20:
f[i]=hf04(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=2000.0;
break;
case 21:
f[i]=hf05(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=2100.0;
break;
case 22:
f[i]=hf06(t,f[i],nx,OShift,M,SS,1,1);
f[i]+=2200.0;
break;
case 23:
f[i]=cf01(t,f[i],nx,OShift,M,1);
f[i]+=2300.0;
break;
case 24:
f[i]=cf02(t,f[i],nx,OShift,M,1);
f[i]+=2400.0;
break;
case 25:
f[i]=cf03(t,f[i],nx,OShift,M,1);
f[i]+=2500.0;
break;
case 26:
f[i]=cf04(t,f[i],nx,OShift,M,1);
f[i]+=2600.0;
break;
case 27:
f[i]=cf05(t,f[i],nx,OShift,M,1);
f[i]+=2700.0;
break;
case 28:
f[i]=cf06(t,f[i],nx,OShift,M,1);
f[i]+=2800.0;
break;
case 29:
f[i]=cf07(t,f[i],nx,OShift,M,SS,1);
f[i]+=2900.0;
break;
case 30:
f[i]=cf08(t,f[i],nx,OShift,M,SS,1);
f[i]+=3000.0;
break;
default :
System.out.println(""String_Node_Str"");
f[i]=0.0;
break;
}
}
}",0.985387323943662
64742,"@Test public void initParamsTest(){
  assertEquals(""String_Node_Str"",40,(int)standardPSO_.getInputParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",5000,(int)standardPSO_.getInputParameter(""String_Node_Str""));
  assertEquals(""String_Node_Str"",3,(int)standardPSO_.getInputParameter(""String_Node_Str""));
}","@Test public void initParamsTest(){
  assertEquals(""String_Node_Str"",40,((Integer)standardPSO_.getInputParameter(""String_Node_Str"")).intValue());
  assertEquals(""String_Node_Str"",5000,((Integer)standardPSO_.getInputParameter(""String_Node_Str"")).intValue());
  assertEquals(""String_Node_Str"",3,((Integer)standardPSO_.getInputParameter(""String_Node_Str"")).intValue());
}",0.8992700729927007
64743,"public Problem getProblem(String name,Properties params) throws JMException {
  String base=""String_Node_Str"";
  if (name.substring(0,name.length() - 1).startsWith(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 1).startsWith(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 1).startsWith(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 3).startsWith(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 3).startsWith(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 4).startsWith(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 3).startsWith(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 4).startsWith(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 5).startsWith(""String_Node_Str""))   base+=""String_Node_Str"";
  try {
    Class problemClass=Class.forName(base + name);
    Constructor constructors=problemClass.getConstructor(Properties.class);
    Problem problem=(Problem)constructors.newInstance(params);
    return problem;
  }
 catch (  Exception e) {
    e.printStackTrace();
    Configuration.logger_.severe(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
    throw new JMException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
}","/** 
 * Creates an object representing a problem
 * @param name Name of the problem
 * @param params Parameters characterizing the problem
 * @return The object representing the problem
 * @throws JMException 
 */
public Problem getProblem(String name,Object[] params) throws JMException {
  String base=""String_Node_Str"";
  if (name.substring(0,name.length() - 1).equalsIgnoreCase(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 1).equalsIgnoreCase(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if (name.substring(0,name.length() - 1).equalsIgnoreCase(""String_Node_Str""))   base+=""String_Node_Str"";
 else   if ((name.length() > 3) && (name.substring(0,name.length() - 3).equalsIgnoreCase(""String_Node_Str"")))   base+=""String_Node_Str"";
 else   if ((name.length() > 3) && (name.substring(0,name.length() - 3).equalsIgnoreCase(""String_Node_Str"")))   base+=""String_Node_Str"";
 else   if ((name.length() > 4) && (name.substring(0,name.length() - 4).equalsIgnoreCase(""String_Node_Str"")))   base+=""String_Node_Str"";
 else   if ((name.length() > 3) && (name.substring(0,name.length() - 3).equalsIgnoreCase(""String_Node_Str"")))   base+=""String_Node_Str"";
 else   if ((name.length() > 4) && (name.substring(0,name.length() - 4).equalsIgnoreCase(""String_Node_Str"")))   base+=""String_Node_Str"";
 else   if ((name.length() > 5) && (name.substring(0,name.length() - 5)).equalsIgnoreCase(""String_Node_Str""))   base+=""String_Node_Str"";
  try {
    Class problemClass=Class.forName(base + name);
    Constructor[] constructors=problemClass.getConstructors();
    int i=0;
    while ((i < constructors.length) && (constructors[i].getParameterTypes().length != params.length)) {
      i++;
    }
    Problem problem=(Problem)constructors[i].newInstance(params);
    return problem;
  }
 catch (  Exception e) {
    Configuration.logger_.severe(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
    throw new JMException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
}",0.024636058230683
64744,"/** 
 * Writes the decision variable values of the <code>Solution</code> solutions objects into the set in a file.
 * @param path The output file name
 */
public void printVariablesToFile(String path){
  try {
    FileOutputStream fos=new FileOutputStream(path);
    OutputStreamWriter osw=new OutputStreamWriter(fos);
    BufferedWriter bw=new BufferedWriter(osw);
    int numberOfVariables=solutionsList_.get(0).getDecisionVariables().length;
    for (int i=0; i < solutionsList_.size(); i++) {
      for (int j=0; j < numberOfVariables; j++)       bw.write(solutionsList_.get(i).getDecisionVariables()[j].toString() + ""String_Node_Str"");
      bw.newLine();
    }
    bw.close();
  }
 catch (  IOException e) {
    Configuration.logger_.severe(""String_Node_Str"");
    e.printStackTrace();
  }
}","/** 
 * Writes the decision variable values of the <code>Solution</code> solutions objects into the set in a file.
 * @param path The output file name
 */
public void printVariablesToFile(String path){
  try {
    FileOutputStream fos=new FileOutputStream(path);
    OutputStreamWriter osw=new OutputStreamWriter(fos);
    BufferedWriter bw=new BufferedWriter(osw);
    if (size() > 0) {
      int numberOfVariables=solutionsList_.get(0).getDecisionVariables().length;
      for (int i=0; i < solutionsList_.size(); i++) {
        for (int j=0; j < numberOfVariables; j++)         bw.write(solutionsList_.get(i).getDecisionVariables()[j].toString() + ""String_Node_Str"");
        bw.newLine();
      }
    }
    bw.close();
  }
 catch (  IOException e) {
    Configuration.logger_.severe(""String_Node_Str"");
    e.printStackTrace();
  }
}",0.9755201958384332
64745,"/** 
 * Creates a new OneZeroMax problem instance
 * @param numberOfBits Length of the problem
 */
public OneZeroMax(String solutionType,Integer numberOfBits) throws ClassNotFoundException {
  numberOfVariables_=1;
  numberOfObjectives_=2;
  numberOfConstraints_=0;
  problemName_=""String_Node_Str"";
  solutionType_=new BinarySolutionType(this);
  length_=new int[numberOfVariables_];
  length_[0]=numberOfBits;
  if (solutionType.compareTo(""String_Node_Str"") == 0)   solutionType_=new BinarySolutionType(this);
 else {
    System.out.println(""String_Node_Str"" + solutionType + ""String_Node_Str"");
    System.exit(-1);
  }
}","/** 
 * Creates a new OneZeroMax problem instance
 * @param solutionType Solution type
 * @param numberOfBits Length of the problem
 */
public OneZeroMax(String solutionType,Integer numberOfBits) throws ClassNotFoundException {
  numberOfVariables_=1;
  numberOfObjectives_=2;
  numberOfConstraints_=0;
  problemName_=""String_Node_Str"";
  solutionType_=new BinarySolutionType(this);
  length_=new int[numberOfVariables_];
  length_[0]=numberOfBits;
  if (solutionType.compareTo(""String_Node_Str"") == 0)   solutionType_=new BinarySolutionType(this);
 else {
    System.out.println(""String_Node_Str"" + solutionType + ""String_Node_Str"");
    System.exit(-1);
  }
}",0.9712062256809338
64746,"/** 
 * Evaluates a solution 
 * @param solution The solution to evaluate
 */
public void evaluate(Solution solution){
  Binary variable;
  int counterOnes;
  int counterZeroes;
  variable=((Binary)solution.getDecisionVariables()[0]);
  counterOnes=0;
  counterZeroes=0;
  for (int i=0; i < variable.getNumberOfBits(); i++)   if (variable.bits_.get(i) == true)   counterOnes++;
 else   counterZeroes++;
  solution.setObjective(0,-1.0 * counterOnes);
  solution.setObjective(0,-1.0 * counterZeroes);
}","/** 
 * Evaluates a solution 
 * @param solution The solution to evaluate
 */
public void evaluate(Solution solution){
  Binary variable;
  int counterOnes;
  int counterZeroes;
  variable=((Binary)solution.getDecisionVariables()[0]);
  counterOnes=0;
  counterZeroes=0;
  for (int i=0; i < variable.getNumberOfBits(); i++)   if (variable.bits_.get(i) == true)   counterOnes++;
 else   counterZeroes++;
  solution.setObjective(0,-1.0 * counterOnes);
  solution.setObjective(1,-1.0 * counterZeroes);
}",0.998
64747,"private static void extractAccountDetails(String smsMsg,String transType){
  String[] reqMatch=new String[]{""String_Node_Str"",""String_Node_Str""};
  fromAccountDetails=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  toAccountDetails=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] mIndx;
  if (transType == ""String_Node_Str"") {
    mIndx=new int[]{1,2};
  }
 else {
    mIndx=new int[]{1};
  }
  try {
    boolean isUPI=smsMsg.contains(""String_Node_Str"");
switch (String.valueOf(isUPI)) {
case ""String_Node_Str"":
      for (int j=0; j <= mIndx.length - 1; j++) {
        reqMatch[j]=searchForAccountNum(smsMsg,mIndx[j]);
      }
    break;
case ""String_Node_Str"":
  String fromACNum=""String_Node_Str"";
String toACNum=""String_Node_Str"";
int fromIndex=smsMsg.indexOf(""String_Node_Str"");
int toIndex=smsMsg.indexOf(""String_Node_Str"");
if (fromIndex > 0) {
reqMatch[0]=searchForAccountNum(smsMsg.substring(smsMsg.indexOf(""String_Node_Str"")),1);
}
if (toIndex > 0) {
reqMatch[1]=searchForAccountNum(smsMsg.substring(smsMsg.indexOf(""String_Node_Str"")),1);
}
if (fromIndex == -1) {
reqMatch[0]=searchForAccountNum(smsMsg,1);
}
if (toIndex == -1) {
reqMatch[1]=searchForAccountNum(smsMsg,1);
}
if (reqMatch[0].contains(reqMatch[1])) {
reqMatch[1]=""String_Node_Str"";
}
break;
}
getAccountDetails(reqMatch);
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
}","private static void extractAccountDetails(String smsMsg,String transType){
  String[] reqMatch=new String[]{""String_Node_Str"",""String_Node_Str""};
  fromAccountDetails=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  toAccountDetails=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] mIndx;
  if (transType == ""String_Node_Str"") {
    mIndx=new int[]{1,2};
  }
 else {
    mIndx=new int[]{1};
  }
  try {
    boolean isUPI=smsMsg.contains(""String_Node_Str"");
switch (String.valueOf(isUPI)) {
case ""String_Node_Str"":
      for (int j=0; j <= mIndx.length - 1; j++) {
        reqMatch[j]=searchForAccountNum(smsMsg,mIndx[j]);
      }
    break;
case ""String_Node_Str"":
  String fromString=""String_Node_Str"";
String toString=""String_Node_Str"";
String nonUPIMsg=smsMsg;
int fromIndex=smsMsg.indexOf(fromString);
int toIndex=smsMsg.indexOf(toString);
if (toIndex == -1) {
toString=""String_Node_Str"";
toIndex=smsMsg.indexOf(toString);
}
if (fromIndex > 0) {
if (fromIndex > toIndex) {
reqMatch[0]=searchForAccountNum(smsMsg.substring(fromIndex),1);
if (toIndex == -1) {
nonUPIMsg=smsMsg.substring(0,fromIndex);
}
}
 else {
reqMatch[0]=searchForAccountNum(smsMsg.substring(fromIndex,toIndex),1);
nonUPIMsg=smsMsg.substring(0,fromIndex);
}
}
if (toIndex > 0) {
if (toIndex > fromIndex) {
reqMatch[1]=searchForAccountNum(smsMsg.substring(toIndex),1);
if (toIndex == -1) {
nonUPIMsg=smsMsg.substring(0,toIndex);
}
}
 else {
reqMatch[1]=searchForAccountNum(smsMsg.substring(toIndex,fromIndex),1);
nonUPIMsg=smsMsg.substring(0,toIndex);
}
}
if (fromIndex == -1) {
reqMatch[0]=searchForAccountNum(nonUPIMsg,1);
}
if (toIndex == -1) {
reqMatch[1]=searchForAccountNum(nonUPIMsg,1);
}
if (reqMatch[0].contains(reqMatch[1])) {
reqMatch[1]=""String_Node_Str"";
}
break;
}
getAccountDetails(reqMatch);
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
}",0.7795758928571429
64748,"@Override public void onReceive(Context context,Intent intent){
  mContext=context.getApplicationContext();
  final BehaviourSettings behav_settings=new BehaviourSettings(mContext);
  final GeneralSettings gen_settings=new GeneralSettings(mContext);
  final AppSettings app_settings=new AppSettings(mContext);
  final PreferenceConstants prf_const=new PreferenceConstants();
  int baseCurencyID, fromCurrencyID, toCurrencyID;
  int baseAccountID, fromAccountID, toAccountID;
  String baseCurrencySymbl, fromAccCurrencySymbl, toAccCurrencySymbl;
  String baseAccountName, fromAccountName, toAccountName;
  Boolean autoTransactionStatus=false;
  Boolean skipSaveTrans=false;
  try {
    if (behav_settings.getBankSmsTrans() == true) {
      Bundle bundle=intent.getExtras();
      SmsMessage[] msgs=null;
      String msgBody=""String_Node_Str"";
      String msgSender=""String_Node_Str"";
      if (bundle != null) {
        Object[] pdus=(Object[])bundle.get(""String_Node_Str"");
        msgs=new SmsMessage[pdus.length];
        for (int i=0; i < msgs.length; i++) {
          msgs[i]=SmsMessage.createFromPdu((byte[])pdus[i]);
          msgSender=msgs[i].getOriginatingAddress();
          msgBody+=msgs[i].getMessageBody().toString();
        }
        ITransactionEntity model=AccountTransaction.create();
        mCommon=new EditTransactionCommonFunctions(null,model,database);
        String[] key_credit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String[] key_debit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String transType=""String_Node_Str"";
        Boolean isDeposit=validateTransType(key_credit_search,msgBody.toLowerCase());
        Boolean isWithdrawal=validateTransType(key_debit_search,msgBody.toLowerCase());
        if (isDeposit == true) {
          if (isWithdrawal == true) {
            transType=""String_Node_Str"";
            String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!transCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
            }
            if (!transCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
          }
 else {
            transType=""String_Node_Str"";
            String[] incomeCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!incomeCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(incomeCategory[0]));
            }
            if (!incomeCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(incomeCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Deposit);
          }
        }
 else         if (isWithdrawal == true) {
          transType=""String_Node_Str"";
          mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
        }
        mCommon.transactionEntity.setStatus(""String_Node_Str"");
        mCommon.payeeName=""String_Node_Str"";
        if (transType != ""String_Node_Str"" && msgBody.toLowerCase().contains(""String_Node_Str"") == false) {
          Intent t_intent=new Intent(mContext,CheckingTransactionEditActivity.class);
          MmxHelper=new MmxOpenHelper(mContext,app_settings.getDatabaseSettings().getDatabasePath());
          db=MmxHelper.getReadableDatabase();
          baseCurencyID=gen_settings.getBaseCurrencytId();
          baseAccountID=gen_settings.getDefaultAccountId();
          baseAccountName=""String_Node_Str"";
          fromAccountID=-1;
          fromCurrencyID=-1;
          fromAccountName=""String_Node_Str"";
          if (baseAccountID > 0) {
            fromAccountID=baseAccountID;
            fromAccountName=baseAccountName;
            fromCurrencyID=baseCurencyID;
          }
          baseCurrencySymbl=getCurrencySymbl(baseCurencyID);
          fromAccCurrencySymbl=baseCurrencySymbl;
          extractAccountDetails(msgBody,transType);
          if (!fromAccountDetails[0].isEmpty()) {
            fromAccountID=parseInt(fromAccountDetails[0]);
            fromAccountName=fromAccountDetails[1];
            fromCurrencyID=parseInt(fromAccountDetails[2]);
            fromAccCurrencySymbl=fromAccountDetails[3];
            mCommon.transactionEntity.setAccountId(fromAccountID);
          }
          mCommon.transactionEntity.setNotes(msgBody);
          mCommon.transactionEntity.setDate(new MmxDate().toDate());
          String transAmount=extractTransAmount(msgBody,fromAccCurrencySymbl);
          String[] transPayee=extractTransPayee(msgBody);
          if ((!fromAccountDetails[6].isEmpty() || !toAccountDetails[6].isEmpty() || !transPayee[1].isEmpty()) && !transAmount.isEmpty()) {
            mCommon.transactionEntity.setAmount(MoneyFactory.fromString(transAmount));
            String transRefNo=extractTransRefNo(msgBody);
            if (!transRefNo.isEmpty()) {
              mCommon.transactionEntity.setTransactionNumber(transRefNo);
            }
            int txnId=getTxnId(transRefNo.trim(),mCommon.transactionEntity.getDateString());
switch (txnId) {
case 0:
              if (transType == ""String_Node_Str"") {
                if (!toAccountDetails[0].isEmpty()) {
                  toAccountID=parseInt(toAccountDetails[0]);
                  toAccountName=toAccountDetails[1];
                  toCurrencyID=parseInt(toAccountDetails[2]);
                  toAccCurrencySymbl=toAccountDetails[3];
                  mCommon.transactionEntity.setAccountToId(toAccountID);
                  CurrencyService currencyService=new CurrencyService(mContext);
                  mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
                  mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
                }
 else {
                  transType=""String_Node_Str"";
                  mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
                  mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                  mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
                  if (!toAccountDetails[6].isEmpty() && transPayee[0].isEmpty()) {
                    transPayee=getPayeeDetails(toAccountDetails[6].trim());
                  }
                }
              }
 else {
                mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
              }
            if (!transPayee[0].isEmpty()) {
              mCommon.transactionEntity.setPayeeId(parseInt(transPayee[0]));
              mCommon.payeeName=transPayee[1];
              mCommon.transactionEntity.setCategoryId(parseInt(transPayee[2]));
              mCommon.transactionEntity.setSubcategoryId(parseInt(transPayee[3]));
            }
          t_intent.setAction(Intent.ACTION_INSERT);
        break;
default :
      transType=""String_Node_Str"";
    AccountTransactionRepository repo=new AccountTransactionRepository(mContext);
  AccountTransaction txn=repo.load(txnId);
if (txn != null) {
  if (txn.getTransactionType() != TransactionTypes.Transfer) {
    AccountRepository accountRepository=new AccountRepository(mContext);
    if (txn.getTransactionType() == TransactionTypes.Deposit) {
      toAccountID=txn.getAccountId();
      toCurrencyID=accountRepository.loadCurrencyIdFor(txn.getAccountId());
    }
 else {
      toAccountID=fromAccountID;
      toCurrencyID=fromCurrencyID;
      fromCurrencyID=accountRepository.loadCurrencyIdFor(txn.getAccountId());
    }
    mCommon.transactionEntity=txn;
    mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
    mCommon.transactionEntity.setAccountId(fromAccountID);
    mCommon.transactionEntity.setAccountToId(toAccountID);
    CurrencyService currencyService=new CurrencyService(mContext);
    mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
    mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
    String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
    if (!transCategory[0].isEmpty()) {
      mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
      mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
    }
    mCommon.transactionEntity.setNotes(mCommon.transactionEntity.getNotes() + ""String_Node_Str"" + msgBody);
    t_intent.setAction(Intent.ACTION_EDIT);
  }
 else {
    skipSaveTrans=true;
  }
}
}
String strExtracted=""String_Node_Str"" + fromAccountName + ""String_Node_Str""+ fromAccountDetails[6]+ ""String_Node_Str""+ ""String_Node_Str""+ fromAccCurrencySymbl+ ""String_Node_Str""+ transAmount+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[1]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[2]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[3]+ ""String_Node_Str""+ ""String_Node_Str""+ transRefNo+ ""String_Node_Str""+ ""String_Node_Str""+ transType+ ""String_Node_Str"";
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,mCommon.transactionEntity.getId());
t_intent.putExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountToId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_CODE,mCommon.getTransactionType());
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_ID,String.valueOf(mCommon.transactionEntity.getPayeeId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_NAME,mCommon.payeeName);
t_intent.putExtra(EditTransactionActivityConstants.KEY_CATEGORY_ID,String.valueOf(mCommon.transactionEntity.getCategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID,String.valueOf(mCommon.transactionEntity.getSubcategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_AMOUNT,String.valueOf(mCommon.transactionEntity.getAmount()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_NOTES,mCommon.transactionEntity.getNotes());
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_DATE,new MmxDate().toDate());
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_NUMBER,mCommon.transactionEntity.getTransactionNumber());
if (skipSaveTrans == false) {
if (validateData()) {
if (saveTransaction()) {
  Toast.makeText(context,""String_Node_Str"" + strExtracted,Toast.LENGTH_LONG).show();
  autoTransactionStatus=true;
}
}
if (autoTransactionStatus == false) {
startActivity(mContext,t_intent,null);
}
}
 else {
Toast.makeText(context,""String_Node_Str"" + transRefNo,Toast.LENGTH_LONG).show();
}
msgBody=""String_Node_Str"";
msgSender=""String_Node_Str"";
bundle=null;
msgs=null;
mCommon=null;
skipSaveTrans=false;
}
}
}
}
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
}","@Override public void onReceive(Context context,Intent intent){
  mContext=context.getApplicationContext();
  final BehaviourSettings behav_settings=new BehaviourSettings(mContext);
  final GeneralSettings gen_settings=new GeneralSettings(mContext);
  final AppSettings app_settings=new AppSettings(mContext);
  final PreferenceConstants prf_const=new PreferenceConstants();
  int baseCurencyID, fromCurrencyID, toCurrencyID;
  int baseAccountID, fromAccountID, toAccountID;
  String baseCurrencySymbl, fromAccCurrencySymbl, toAccCurrencySymbl;
  String baseAccountName, fromAccountName, toAccountName;
  Boolean autoTransactionStatus=false;
  Boolean skipSaveTrans=false;
  try {
    if (behav_settings.getBankSmsTrans() == true) {
      Bundle bundle=intent.getExtras();
      SmsMessage[] msgs=null;
      String msgBody=""String_Node_Str"";
      String msgSender=""String_Node_Str"";
      if (bundle != null) {
        Object[] pdus=(Object[])bundle.get(""String_Node_Str"");
        msgs=new SmsMessage[pdus.length];
        for (int i=0; i < msgs.length; i++) {
          msgs[i]=SmsMessage.createFromPdu((byte[])pdus[i]);
          msgSender=msgs[i].getOriginatingAddress();
          msgBody+=msgs[i].getMessageBody().toString();
        }
        ITransactionEntity model=AccountTransaction.create();
        mCommon=new EditTransactionCommonFunctions(null,model,database);
        String[] key_credit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String[] key_debit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String transType=""String_Node_Str"";
        Boolean isDeposit=validateTransType(key_credit_search,msgBody.toLowerCase());
        Boolean isWithdrawal=validateTransType(key_debit_search,msgBody.toLowerCase());
        if (isDeposit == true) {
          if (isWithdrawal == true) {
            transType=""String_Node_Str"";
            String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!transCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
            }
            if (!transCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
          }
 else {
            transType=""String_Node_Str"";
            String[] incomeCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!incomeCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(incomeCategory[0]));
            }
            if (!incomeCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(incomeCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Deposit);
          }
        }
 else         if (isWithdrawal == true) {
          transType=""String_Node_Str"";
          mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
        }
        mCommon.transactionEntity.setStatus(""String_Node_Str"");
        mCommon.payeeName=""String_Node_Str"";
        if (transType != ""String_Node_Str"" && msgBody.toLowerCase().contains(""String_Node_Str"") == false) {
          Intent t_intent=new Intent(mContext,CheckingTransactionEditActivity.class);
          MmxHelper=new MmxOpenHelper(mContext,app_settings.getDatabaseSettings().getDatabasePath());
          db=MmxHelper.getReadableDatabase();
          baseCurencyID=gen_settings.getBaseCurrencytId();
          baseAccountID=gen_settings.getDefaultAccountId();
          baseAccountName=""String_Node_Str"";
          fromAccountID=-1;
          fromCurrencyID=-1;
          fromAccountName=""String_Node_Str"";
          if (baseAccountID > 0) {
            fromAccountID=baseAccountID;
            fromAccountName=baseAccountName;
            fromCurrencyID=baseCurencyID;
          }
          baseCurrencySymbl=getCurrencySymbl(baseCurencyID);
          fromAccCurrencySymbl=baseCurrencySymbl;
          extractAccountDetails(msgBody,transType);
          if (!fromAccountDetails[0].isEmpty()) {
            fromAccountID=parseInt(fromAccountDetails[0]);
            fromAccountName=fromAccountDetails[1];
            fromCurrencyID=parseInt(fromAccountDetails[2]);
            fromAccCurrencySymbl=fromAccountDetails[3];
            mCommon.transactionEntity.setAccountId(fromAccountID);
          }
          mCommon.transactionEntity.setNotes(msgBody);
          mCommon.transactionEntity.setDate(new MmxDate().toDate());
          String transAmount=extractTransAmount(msgBody,fromAccCurrencySymbl);
          String[] transPayee=extractTransPayee(msgBody);
          if ((!fromAccountDetails[6].isEmpty() || !toAccountDetails[6].isEmpty() || !transPayee[0].isEmpty()) && !transAmount.isEmpty()) {
            mCommon.transactionEntity.setAmount(MoneyFactory.fromString(transAmount));
            String transRefNo=extractTransRefNo(msgBody);
            if (!transRefNo.isEmpty()) {
              mCommon.transactionEntity.setTransactionNumber(transRefNo);
            }
            int txnId=getTxnId(transRefNo.trim(),mCommon.transactionEntity.getDateString());
switch (txnId) {
case 0:
              if (transType == ""String_Node_Str"") {
                if (!toAccountDetails[0].isEmpty()) {
                  toAccountID=parseInt(toAccountDetails[0]);
                  toAccountName=toAccountDetails[1];
                  toCurrencyID=parseInt(toAccountDetails[2]);
                  toAccCurrencySymbl=toAccountDetails[3];
                  mCommon.transactionEntity.setAccountToId(toAccountID);
                  CurrencyService currencyService=new CurrencyService(mContext);
                  mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
                  mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
                }
 else {
                  transType=""String_Node_Str"";
                  mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
                  mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                  mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
                  if (!toAccountDetails[6].isEmpty() && transPayee[0].isEmpty()) {
                    transPayee=getPayeeDetails(toAccountDetails[6].trim());
                  }
                }
              }
 else {
                mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
              }
            if (!transPayee[0].isEmpty()) {
              mCommon.transactionEntity.setPayeeId(parseInt(transPayee[0]));
              mCommon.payeeName=transPayee[1];
              mCommon.transactionEntity.setCategoryId(parseInt(transPayee[2]));
              mCommon.transactionEntity.setSubcategoryId(parseInt(transPayee[3]));
            }
          t_intent.setAction(Intent.ACTION_INSERT);
        break;
default :
      transType=""String_Node_Str"";
    AccountTransactionRepository repo=new AccountTransactionRepository(mContext);
  AccountTransaction txn=repo.load(txnId);
if (txn != null) {
  if (txn.getTransactionType() != TransactionTypes.Transfer) {
    AccountRepository accountRepository=new AccountRepository(mContext);
    if (txn.getTransactionType() == TransactionTypes.Deposit) {
      toAccountID=txn.getAccountId();
      toCurrencyID=accountRepository.loadCurrencyIdFor(txn.getAccountId());
    }
 else {
      toAccountID=fromAccountID;
      toCurrencyID=fromCurrencyID;
      fromCurrencyID=accountRepository.loadCurrencyIdFor(txn.getAccountId());
    }
    mCommon.transactionEntity=txn;
    mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
    mCommon.transactionEntity.setAccountId(fromAccountID);
    mCommon.transactionEntity.setAccountToId(toAccountID);
    CurrencyService currencyService=new CurrencyService(mContext);
    mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
    mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
    String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
    if (!transCategory[0].isEmpty()) {
      mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
      mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
    }
    mCommon.transactionEntity.setNotes(mCommon.transactionEntity.getNotes() + ""String_Node_Str"" + msgBody);
    t_intent.setAction(Intent.ACTION_EDIT);
  }
 else {
    skipSaveTrans=true;
  }
}
}
String strExtracted=""String_Node_Str"" + fromAccountName + ""String_Node_Str""+ fromAccountDetails[6]+ ""String_Node_Str""+ ""String_Node_Str""+ fromAccCurrencySymbl+ ""String_Node_Str""+ transAmount+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[1]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[2]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[3]+ ""String_Node_Str""+ ""String_Node_Str""+ transRefNo+ ""String_Node_Str""+ ""String_Node_Str""+ transType+ ""String_Node_Str"";
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,mCommon.transactionEntity.getId());
t_intent.putExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountToId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_CODE,mCommon.getTransactionType());
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_ID,String.valueOf(mCommon.transactionEntity.getPayeeId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_NAME,mCommon.payeeName);
t_intent.putExtra(EditTransactionActivityConstants.KEY_CATEGORY_ID,String.valueOf(mCommon.transactionEntity.getCategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID,String.valueOf(mCommon.transactionEntity.getSubcategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_AMOUNT,String.valueOf(mCommon.transactionEntity.getAmount()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_NOTES,mCommon.transactionEntity.getNotes());
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_DATE,new MmxDate().toDate());
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_NUMBER,mCommon.transactionEntity.getTransactionNumber());
if (skipSaveTrans == false) {
if (validateData()) {
if (saveTransaction()) {
  Toast.makeText(context,""String_Node_Str"" + strExtracted,Toast.LENGTH_LONG).show();
  autoTransactionStatus=true;
}
}
if (autoTransactionStatus == false) {
showNotification(t_intent,strExtracted);
}
}
 else {
Toast.makeText(context,""String_Node_Str"" + transRefNo,Toast.LENGTH_LONG).show();
}
msgBody=""String_Node_Str"";
msgSender=""String_Node_Str"";
bundle=null;
msgs=null;
mCommon=null;
skipSaveTrans=false;
}
}
}
}
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
}",0.9930331794827136
64749,"private static String[] extractAccountDetails(String smsMsg,int mIndx){
  String reqMatch=""String_Node_Str"";
  String[] searchFor={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] getGroup={4,4,3,1};
  int mFound=1;
  String[] accountDetails=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  try {
    for (int i=0; i <= searchFor.length - 1; i++) {
      mFound=1;
      Pattern p=Pattern.compile(searchFor[i]);
      Matcher m=p.matcher(smsMsg);
      if (m != null && reqMatch.isEmpty()) {
        while (m.find()) {
          if (mFound == mIndx) {
            reqMatch=m.group(getGroup[i]).trim();
            break;
          }
 else {
            mFound=mFound + 1;
          }
        }
      }
    }
    if (reqMatch != ""String_Node_Str"") {
      accountDetails=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",reqMatch};
      String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + reqMatch + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      Cursor accountCursor=db.rawQuery(sql,null);
      if (accountCursor.getCount() > 0) {
        accountCursor.moveToFirst();
        accountDetails=new String[]{accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),reqMatch};
      }
    }
  }
 catch (  Exception e) {
  }
  return accountDetails;
}","private static String[] extractAccountDetails(String smsMsg,int mIndx){
  String reqMatch=""String_Node_Str"";
  String[] searchFor={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] getGroup={4,4,1,1};
  int mFound=1;
  String[] accountDetails=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  try {
    for (int i=0; i <= searchFor.length - 1; i++) {
      mFound=1;
      Pattern p=Pattern.compile(searchFor[i]);
      Matcher m=p.matcher(smsMsg);
      if (m != null && reqMatch.isEmpty()) {
        while (m.find()) {
          if (mFound == mIndx) {
            reqMatch=m.group(getGroup[i]).trim();
            break;
          }
 else {
            mFound=mFound + 1;
          }
        }
      }
    }
    if (reqMatch != ""String_Node_Str"") {
      accountDetails=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",reqMatch};
      String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + reqMatch + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      Cursor accountCursor=db.rawQuery(sql,null);
      if (accountCursor.getCount() > 0) {
        accountCursor.moveToFirst();
        accountDetails=new String[]{accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),accountCursor.getString(accountCursor.getColumnIndex(""String_Node_Str"")),reqMatch};
      }
    }
  }
 catch (  Exception e) {
  }
  return accountDetails;
}",0.9947089947089948
64750,"public boolean validateData(){
  boolean isTransfer=mCommon.transactionEntity.getTransactionType().equals(TransactionTypes.Transfer);
  Core core=new Core(mContext);
  if (isTransfer) {
    if (mCommon.transactionEntity.getAccountToId() == Constants.NOT_SET) {
      return false;
    }
    if (mCommon.transactionEntity.getAccountToId().equals(mCommon.transactionEntity.getAccountId())) {
      return false;
    }
    if (this.mCommon.transactionEntity.getAmountTo().toDouble() <= 0) {
      return false;
    }
  }
 else {
    if (!mCommon.transactionEntity.hasPayee()) {
      return false;
    }
  }
  if (mCommon.transactionEntity.getAmount().toDouble() <= 0) {
    return false;
  }
  boolean hasCategory=mCommon.transactionEntity.hasCategory();
  if (!hasCategory && !isTransfer) {
    return false;
  }
  return true;
}","public boolean validateData(){
  boolean isTransfer=mCommon.transactionEntity.getTransactionType().equals(TransactionTypes.Transfer);
  Core core=new Core(mContext);
  if (mCommon.transactionEntity.getAccountId() == Constants.NOT_SET) {
    return false;
  }
  if (isTransfer) {
    if (mCommon.transactionEntity.getAccountToId() == Constants.NOT_SET) {
      return false;
    }
    if (mCommon.transactionEntity.getAccountToId().equals(mCommon.transactionEntity.getAccountId())) {
      return false;
    }
    if (this.mCommon.transactionEntity.getAmountTo().toDouble() <= 0) {
      return false;
    }
  }
 else {
    if (!mCommon.transactionEntity.hasPayee()) {
      return false;
    }
  }
  if (mCommon.transactionEntity.getAmount().toDouble() <= 0) {
    return false;
  }
  boolean hasCategory=mCommon.transactionEntity.hasCategory();
  if (!hasCategory && !isTransfer) {
    return false;
  }
  return true;
}",0.8907947398513436
64751,"@Override public void onReceive(Context context,Intent intent){
  mContext=context.getApplicationContext();
  final BehaviourSettings behav_settings=new BehaviourSettings(mContext);
  final GeneralSettings gen_settings=new GeneralSettings(mContext);
  final AppSettings app_settings=new AppSettings(mContext);
  final PreferenceConstants prf_const=new PreferenceConstants();
  int baseCurencyID, fromCurrencyID, toCurrencyID;
  int baseAccountID, fromAccountID, toAccountID;
  String baseCurrencySymbl, fromAccCurrencySymbl, toAccCurrencySymbl;
  String baseAccountName, fromAccountName, toAccountName;
  try {
    if (behav_settings.getBankSmsTrans() == true) {
      Bundle bundle=intent.getExtras();
      SmsMessage[] msgs=null;
      String msgBody=""String_Node_Str"";
      String msgSender=""String_Node_Str"";
      if (bundle != null) {
        Object[] pdus=(Object[])bundle.get(""String_Node_Str"");
        msgs=new SmsMessage[pdus.length];
        for (int i=0; i < msgs.length; i++) {
          msgs[i]=SmsMessage.createFromPdu((byte[])pdus[i]);
          msgSender=msgs[i].getOriginatingAddress();
          msgBody+=msgs[i].getMessageBody().toString();
        }
        ITransactionEntity model=AccountTransaction.create();
        mCommon=new EditTransactionCommonFunctions(null,model,database);
        String[] key_credit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String[] key_debit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String transType=""String_Node_Str"";
        Boolean isDeposit=validateTransType(key_credit_search,msgBody.toLowerCase());
        Boolean isWithdrawal=validateTransType(key_debit_search,msgBody.toLowerCase());
        if (isDeposit == true) {
          if (isWithdrawal == true) {
            transType=""String_Node_Str"";
            String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!transCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
            }
            if (!transCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
          }
 else {
            transType=""String_Node_Str"";
            String[] incomeCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!incomeCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(incomeCategory[0]));
            }
            if (!incomeCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(incomeCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Deposit);
          }
          mCommon.payeeName=""String_Node_Str"";
        }
 else         if (isWithdrawal == true) {
          transType=""String_Node_Str"";
          mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
        }
        mCommon.transactionEntity.setStatus(""String_Node_Str"");
        if (transType != ""String_Node_Str"" && msgBody.toLowerCase().contains(""String_Node_Str"") == false) {
          Intent t_intent=new Intent(mContext,CheckingTransactionEditActivity.class);
          MmxHelper=new MmxOpenHelper(mContext,app_settings.getDatabaseSettings().getDatabasePath());
          db=MmxHelper.getReadableDatabase();
          baseCurencyID=gen_settings.getBaseCurrencytId();
          baseAccountID=gen_settings.getDefaultAccountId();
          baseAccountName=""String_Node_Str"";
          fromAccountID=-1;
          fromCurrencyID=-1;
          fromAccountName=""String_Node_Str"";
          if (baseAccountID > 0) {
            fromAccountID=baseAccountID;
            fromAccountName=baseAccountName;
            fromCurrencyID=baseCurencyID;
          }
          baseCurrencySymbl=getCurrencySymbl(baseCurencyID);
          fromAccCurrencySymbl=baseCurrencySymbl;
          String[] fromAccountDetails=extractAccountDetails(msgBody,1);
          if (!fromAccountDetails[0].isEmpty()) {
            fromAccountID=parseInt(fromAccountDetails[0]);
            fromAccountName=fromAccountDetails[1];
            fromCurrencyID=parseInt(fromAccountDetails[2]);
            fromAccCurrencySymbl=fromAccountDetails[3];
            mCommon.transactionEntity.setAccountId(fromAccountID);
          }
          mCommon.transactionEntity.setNotes(msgBody);
          mCommon.transactionEntity.setDate(new MmxDate().toDate());
          String transAmount=extractTransAmount(msgBody,fromAccCurrencySymbl);
          if (!fromAccountDetails[6].isEmpty() && !transAmount.isEmpty()) {
            mCommon.transactionEntity.setAmount(MoneyFactory.fromString(transAmount));
            String[] transPayee=extractTransPayee(msgBody);
            String transRefNo=extractTransRefNo(msgBody);
            int txnId=getTxnId(transRefNo.trim(),transType,mCommon.transactionEntity.getDateString());
switch (txnId) {
case 0:
              if (transType == ""String_Node_Str"") {
                String[] toAccountDetails=extractAccountDetails(msgBody,2);
                if (!toAccountDetails[0].isEmpty()) {
                  toAccountID=parseInt(toAccountDetails[0]);
                  toAccountName=toAccountDetails[1];
                  toCurrencyID=parseInt(toAccountDetails[2]);
                  toAccCurrencySymbl=toAccountDetails[3];
                  mCommon.transactionEntity.setAccountToId(toAccountID);
                  CurrencyService currencyService=new CurrencyService(mContext);
                  mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
                  mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
                }
 else {
                  transType=""String_Node_Str"";
                  mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
                  mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                  mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
                  if (!toAccountDetails[6].isEmpty() && transPayee[0].isEmpty()) {
                    transPayee=getPayeeDetails(toAccountDetails[6].trim());
                  }
                }
              }
 else {
                mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
              }
            if (!transPayee[0].isEmpty()) {
              mCommon.transactionEntity.setPayeeId(parseInt(transPayee[0]));
              mCommon.payeeName=transPayee[1];
              mCommon.transactionEntity.setCategoryId(parseInt(transPayee[2]));
              mCommon.transactionEntity.setSubcategoryId(parseInt(transPayee[3]));
            }
 else {
              mCommon.payeeName=""String_Node_Str"";
            }
          t_intent.setAction(Intent.ACTION_INSERT);
        break;
default :
      transType=""String_Node_Str"";
    AccountTransactionRepository repo=new AccountTransactionRepository(mContext);
  AccountTransaction txn=repo.load(txnId);
if (txn != null) {
  if (txn.getTransactionType() != TransactionTypes.Transfer) {
    AccountRepository accountRepository=new AccountRepository(mContext);
    toAccountID=fromAccountID;
    toCurrencyID=fromCurrencyID;
    fromCurrencyID=accountRepository.loadCurrencyIdFor(txn.getAccountId());
    mCommon.transactionEntity=txn;
    mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
    mCommon.transactionEntity.setAccountToId(toAccountID);
    CurrencyService currencyService=new CurrencyService(mContext);
    mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
    mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
    String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
    if (!transCategory[0].isEmpty()) {
      mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
      mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
    }
    mCommon.transactionEntity.setNotes(mCommon.transactionEntity.getNotes() + ""String_Node_Str"" + msgBody);
  }
}
t_intent.setAction(Intent.ACTION_EDIT);
}
String strExtracted=""String_Node_Str"" + fromAccountName + ""String_Node_Str""+ fromAccountDetails[6]+ ""String_Node_Str""+ ""String_Node_Str""+ fromAccCurrencySymbl+ ""String_Node_Str""+ transAmount+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[1]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[2]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[3]+ ""String_Node_Str""+ ""String_Node_Str""+ transRefNo+ ""String_Node_Str""+ ""String_Node_Str""+ transType+ ""String_Node_Str"";
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,mCommon.transactionEntity.getId());
t_intent.putExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountToId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_CODE,mCommon.getTransactionType());
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_ID,String.valueOf(mCommon.transactionEntity.getPayeeId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_NAME,mCommon.payeeName);
t_intent.putExtra(EditTransactionActivityConstants.KEY_CATEGORY_ID,String.valueOf(mCommon.transactionEntity.getCategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID,String.valueOf(mCommon.transactionEntity.getSubcategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_AMOUNT,String.valueOf(mCommon.transactionEntity.getAmount()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_NOTES,mCommon.transactionEntity.getNotes());
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_DATE,new MmxDate().toDate());
if (validateData()) {
if (saveTransaction()) {
Toast.makeText(context,""String_Node_Str"" + strExtracted,Toast.LENGTH_LONG).show();
}
 else {
startActivity(mContext,t_intent,null);
}
}
 else {
startActivity(mContext,t_intent,null);
}
bundle=null;
msgs=null;
msgBody=""String_Node_Str"";
msgSender=""String_Node_Str"";
mCommon=null;
}
}
}
}
}
 catch (Exception e) {
Toast.makeText(context,""String_Node_Str"" + e,Toast.LENGTH_LONG).show();
}
}","@Override public void onReceive(Context context,Intent intent){
  mContext=context.getApplicationContext();
  final BehaviourSettings behav_settings=new BehaviourSettings(mContext);
  final GeneralSettings gen_settings=new GeneralSettings(mContext);
  final AppSettings app_settings=new AppSettings(mContext);
  final PreferenceConstants prf_const=new PreferenceConstants();
  int baseCurencyID, fromCurrencyID, toCurrencyID;
  int baseAccountID, fromAccountID, toAccountID;
  String baseCurrencySymbl, fromAccCurrencySymbl, toAccCurrencySymbl;
  String baseAccountName, fromAccountName, toAccountName;
  try {
    if (behav_settings.getBankSmsTrans() == true) {
      Bundle bundle=intent.getExtras();
      SmsMessage[] msgs=null;
      String msgBody=""String_Node_Str"";
      String msgSender=""String_Node_Str"";
      if (bundle != null) {
        Object[] pdus=(Object[])bundle.get(""String_Node_Str"");
        msgs=new SmsMessage[pdus.length];
        for (int i=0; i < msgs.length; i++) {
          msgs[i]=SmsMessage.createFromPdu((byte[])pdus[i]);
          msgSender=msgs[i].getOriginatingAddress();
          msgBody+=msgs[i].getMessageBody().toString();
        }
        ITransactionEntity model=AccountTransaction.create();
        mCommon=new EditTransactionCommonFunctions(null,model,database);
        String[] key_credit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String[] key_debit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String transType=""String_Node_Str"";
        Boolean isDeposit=validateTransType(key_credit_search,msgBody.toLowerCase());
        Boolean isWithdrawal=validateTransType(key_debit_search,msgBody.toLowerCase());
        if (isDeposit == true) {
          if (isWithdrawal == true) {
            transType=""String_Node_Str"";
            String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!transCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
            }
            if (!transCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
          }
 else {
            transType=""String_Node_Str"";
            String[] incomeCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!incomeCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(incomeCategory[0]));
            }
            if (!incomeCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(incomeCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Deposit);
          }
          mCommon.payeeName=""String_Node_Str"";
        }
 else         if (isWithdrawal == true) {
          transType=""String_Node_Str"";
          mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
        }
        mCommon.transactionEntity.setStatus(""String_Node_Str"");
        if (transType != ""String_Node_Str"" && msgBody.toLowerCase().contains(""String_Node_Str"") == false) {
          Intent t_intent=new Intent(mContext,CheckingTransactionEditActivity.class);
          MmxHelper=new MmxOpenHelper(mContext,app_settings.getDatabaseSettings().getDatabasePath());
          db=MmxHelper.getReadableDatabase();
          baseCurencyID=gen_settings.getBaseCurrencytId();
          baseAccountID=gen_settings.getDefaultAccountId();
          baseAccountName=""String_Node_Str"";
          fromAccountID=-1;
          fromCurrencyID=-1;
          fromAccountName=""String_Node_Str"";
          if (baseAccountID > 0) {
            fromAccountID=baseAccountID;
            fromAccountName=baseAccountName;
            fromCurrencyID=baseCurencyID;
          }
          baseCurrencySymbl=getCurrencySymbl(baseCurencyID);
          fromAccCurrencySymbl=baseCurrencySymbl;
          String[] fromAccountDetails=extractAccountDetails(msgBody,1);
          if (!fromAccountDetails[0].isEmpty()) {
            fromAccountID=parseInt(fromAccountDetails[0]);
            fromAccountName=fromAccountDetails[1];
            fromCurrencyID=parseInt(fromAccountDetails[2]);
            fromAccCurrencySymbl=fromAccountDetails[3];
            mCommon.transactionEntity.setAccountId(fromAccountID);
          }
          mCommon.transactionEntity.setNotes(msgBody);
          mCommon.transactionEntity.setDate(new MmxDate().toDate());
          String transAmount=extractTransAmount(msgBody,fromAccCurrencySymbl);
          if (!fromAccountDetails[6].isEmpty() && !transAmount.isEmpty()) {
            mCommon.transactionEntity.setAmount(MoneyFactory.fromString(transAmount));
            String[] transPayee=extractTransPayee(msgBody);
            String transRefNo=extractTransRefNo(msgBody);
            int txnId=getTxnId(transRefNo.trim(),transType,mCommon.transactionEntity.getDateString());
switch (txnId) {
case 0:
              if (transType == ""String_Node_Str"") {
                String[] toAccountDetails=extractAccountDetails(msgBody,2);
                if (!toAccountDetails[0].isEmpty()) {
                  toAccountID=parseInt(toAccountDetails[0]);
                  toAccountName=toAccountDetails[1];
                  toCurrencyID=parseInt(toAccountDetails[2]);
                  toAccCurrencySymbl=toAccountDetails[3];
                  mCommon.transactionEntity.setAccountToId(toAccountID);
                  CurrencyService currencyService=new CurrencyService(mContext);
                  mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
                  mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
                }
 else {
                  transType=""String_Node_Str"";
                  mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
                  mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                  mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
                  if (!toAccountDetails[6].isEmpty() && transPayee[0].isEmpty()) {
                    transPayee=getPayeeDetails(toAccountDetails[6].trim());
                  }
                }
              }
 else {
                mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
              }
            if (!transPayee[0].isEmpty()) {
              mCommon.transactionEntity.setPayeeId(parseInt(transPayee[0]));
              mCommon.payeeName=transPayee[1];
              mCommon.transactionEntity.setCategoryId(parseInt(transPayee[2]));
              mCommon.transactionEntity.setSubcategoryId(parseInt(transPayee[3]));
            }
 else {
              mCommon.payeeName=""String_Node_Str"";
            }
          t_intent.setAction(Intent.ACTION_INSERT);
        break;
default :
      transType=""String_Node_Str"";
    AccountTransactionRepository repo=new AccountTransactionRepository(mContext);
  AccountTransaction txn=repo.load(txnId);
if (txn != null) {
  if (txn.getTransactionType() != TransactionTypes.Transfer) {
    AccountRepository accountRepository=new AccountRepository(mContext);
    toAccountID=fromAccountID;
    toCurrencyID=fromCurrencyID;
    fromCurrencyID=accountRepository.loadCurrencyIdFor(txn.getAccountId());
    mCommon.transactionEntity=txn;
    mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
    mCommon.transactionEntity.setAccountToId(toAccountID);
    CurrencyService currencyService=new CurrencyService(mContext);
    mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
    mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
    String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
    if (!transCategory[0].isEmpty()) {
      mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
      mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
    }
    mCommon.transactionEntity.setNotes(mCommon.transactionEntity.getNotes() + ""String_Node_Str"" + msgBody);
  }
}
t_intent.setAction(Intent.ACTION_EDIT);
}
String strExtracted=""String_Node_Str"" + fromAccountName + ""String_Node_Str""+ fromAccountDetails[6]+ ""String_Node_Str""+ ""String_Node_Str""+ fromAccCurrencySymbl+ ""String_Node_Str""+ transAmount+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[1]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[2]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[3]+ ""String_Node_Str""+ ""String_Node_Str""+ transRefNo+ ""String_Node_Str""+ ""String_Node_Str""+ transType+ ""String_Node_Str"";
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,mCommon.transactionEntity.getId());
t_intent.putExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountToId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_CODE,mCommon.getTransactionType());
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_ID,String.valueOf(mCommon.transactionEntity.getPayeeId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_NAME,mCommon.payeeName);
t_intent.putExtra(EditTransactionActivityConstants.KEY_CATEGORY_ID,String.valueOf(mCommon.transactionEntity.getCategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID,String.valueOf(mCommon.transactionEntity.getSubcategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_AMOUNT,String.valueOf(mCommon.transactionEntity.getAmount()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_NOTES,strExtracted + ""String_Node_Str"" + mCommon.transactionEntity.getNotes());
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_DATE,new MmxDate().toDate());
if (validateData()) {
if (saveTransaction()) {
Toast.makeText(context,""String_Node_Str"" + strExtracted,Toast.LENGTH_LONG).show();
}
 else {
startActivity(mContext,t_intent,null);
}
}
 else {
startActivity(mContext,t_intent,null);
}
bundle=null;
msgs=null;
msgBody=""String_Node_Str"";
msgSender=""String_Node_Str"";
mCommon=null;
}
}
}
}
}
 catch (Exception e) {
Toast.makeText(context,""String_Node_Str"" + e,Toast.LENGTH_LONG).show();
}
}",0.9983608860581652
64752,"/** 
 * Get the parameters from the intent (parameters sent from the caller). Also used for Tasker integration, for example.
 * @param savedInstanceState parameters
 */
private boolean handleIntent(Bundle savedInstanceState){
  Intent intent=getIntent();
  mIntentAction=intent.getAction();
  if (mIntentAction == null) {
    Timber.w(""String_Node_Str"");
    return false;
  }
  if (savedInstanceState == null) {
    int accountId=intent.getIntExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,Constants.NOT_SET);
    if (accountId != Constants.NOT_SET) {
      mCommon.transactionEntity.setAccountId(accountId);
    }
    if (mIntentAction != null) {
      int transactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_TRANS_ID,Constants.NOT_SET);
switch (mIntentAction) {
case Intent.ACTION_EDIT:
        loadTransaction(transactionId);
      break;
case Intent.ACTION_PASTE:
    loadTransaction(transactionId);
  duplicateTransaction();
break;
case Intent.ACTION_INSERT:
mRecurringTransactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_BDID_ID,Constants.NOT_SET);
if (mRecurringTransactionId > Constants.NOT_SET) {
loadRecurringTransaction(mRecurringTransactionId);
}
}
}
}
if (mIntentAction.equals(Intent.ACTION_INSERT)) {
if (mCommon.transactionEntity.getStatus() == null) {
String defaultStatus=PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_STATUS),""String_Node_Str"");
mCommon.transactionEntity.setStatus(defaultStatus);
}
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
AsyncTask<Void,Void,Boolean> task=new AsyncTask<Void,Void,Boolean>(){
@Override protected Boolean doInBackground(Void... params){
try {
Core core=new Core(getApplicationContext());
Payee payee=core.getLastPayeeUsed();
if (payee != null && mCommon.transactionEntity.getPayeeId() == Constants.NOT_SET) {
mCommon.transactionEntity.setPayeeId(payee.getId());
mCommon.payeeName=payee.getName();
mCommon.transactionEntity.setCategoryId(payee.getCategoryId());
mCommon.transactionEntity.setSubcategoryId(payee.getSubcategoryId());
mCommon.loadCategoryName();
return Boolean.TRUE;
}
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
return Boolean.FALSE;
}
@Override protected void onPostExecute(Boolean result){
super.onPostExecute(result);
if (result) {
try {
mCommon.showPayeeName();
mCommon.displayCategoryName();
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
}
}
}
;
task.execute();
}
if (intent.getData() != null) {
externalIntegration(intent);
}
 else {
try {
Bundle extras=intent.getExtras();
if (extras != null) {
AccountRepository accountRepository=new AccountRepository(this);
if (Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_ACCOUNT_ID)) > 0) {
mCommon.transactionEntity.setAccountId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_ACCOUNT_ID)));
mCommon.transactionEntity.setAccountToId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID)));
CurrencyService currencyService=new CurrencyService(this);
mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(accountRepository.loadCurrencyIdFor(mCommon.transactionEntity.getAccountId()),mCommon.transactionEntity.getAmount(),accountRepository.loadCurrencyIdFor(mCommon.transactionEntity.getAccountToId())));
}
mCommon.transactionEntity.setTransactionType(TransactionTypes.valueOf(extras.getString(EditTransactionActivityConstants.KEY_TRANS_CODE)));
mCommon.transactionEntity.setAmount(MoneyFactory.fromString(extras.getString(EditTransactionActivityConstants.KEY_TRANS_AMOUNT)));
mCommon.transactionEntity.setNotes(extras.getString(EditTransactionActivityConstants.KEY_NOTES));
mCommon.transactionEntity.setDate(new MmxDate().toDate());
if (extras.getString(EditTransactionActivityConstants.KEY_PAYEE_NAME).isEmpty()) {
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
Core core=new Core(this);
Payee payee=core.getLastPayeeUsed();
if (payee != null) {
  mCommon.transactionEntity.setPayeeId(payee.getId());
  mCommon.payeeName=payee.getName();
  mCommon.setCategoryFromPayee(mCommon.transactionEntity.getPayeeId());
}
}
}
 else {
mCommon.transactionEntity.setPayeeId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_PAYEE_ID)));
mCommon.payeeName=extras.getString(EditTransactionActivityConstants.KEY_PAYEE_NAME);
mCommon.setCategoryFromPayee(mCommon.transactionEntity.getPayeeId());
}
if (extras.getString(EditTransactionActivityConstants.KEY_PAYEE_NAME).isEmpty()) {
String catID=extras.getString(EditTransactionActivityConstants.KEY_CATEGORY_ID);
String subCatID=extras.getString(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID);
if (!catID.isEmpty()) {
mCommon.transactionEntity.setCategoryId(parseInt(catID));
}
if (!subCatID.isEmpty()) {
mCommon.transactionEntity.setSubcategoryId(parseInt(subCatID));
}
}
mCommon.mToAccountName=accountRepository.loadName(mCommon.transactionEntity.getAccountToId());
extras=null;
}
}
 catch (Exception e) {
Toast.makeText(this,""String_Node_Str"" + e,Toast.LENGTH_LONG).show();
}
}
Integer account=mCommon.transactionEntity.getAccountId();
if (account == null || account == Constants.NOT_SET) {
AppSettings settings=new AppSettings(this);
Integer defaultAccountId=settings.getGeneralSettings().getDefaultAccountId();
if (defaultAccountId == null) {
new UIHelper(this).showToast(getString(R.string.default_account_not_set));
return false;
}
 else {
mCommon.transactionEntity.setAccountId(defaultAccountId);
}
}
}
if (getSupportActionBar() != null) {
getSupportActionBar().setTitle(Intent.ACTION_INSERT.equals(mIntentAction) ? R.string.new_transaction : R.string.edit_transaction);
}
return true;
}","/** 
 * Get the parameters from the intent (parameters sent from the caller). Also used for Tasker integration, for example.
 * @param savedInstanceState parameters
 */
private boolean handleIntent(Bundle savedInstanceState){
  Intent intent=getIntent();
  mIntentAction=intent.getAction();
  if (mIntentAction == null) {
    Timber.w(""String_Node_Str"");
    return false;
  }
  if (savedInstanceState == null) {
    int accountId=intent.getIntExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,Constants.NOT_SET);
    if (accountId != Constants.NOT_SET) {
      mCommon.transactionEntity.setAccountId(accountId);
    }
    if (mIntentAction != null) {
      int transactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_TRANS_ID,Constants.NOT_SET);
switch (mIntentAction) {
case Intent.ACTION_EDIT:
        loadTransaction(transactionId);
      break;
case Intent.ACTION_PASTE:
    loadTransaction(transactionId);
  duplicateTransaction();
break;
case Intent.ACTION_INSERT:
mRecurringTransactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_BDID_ID,Constants.NOT_SET);
if (mRecurringTransactionId > Constants.NOT_SET) {
loadRecurringTransaction(mRecurringTransactionId);
}
}
}
}
if (mIntentAction.equals(Intent.ACTION_INSERT)) {
if (mCommon.transactionEntity.getStatus() == null) {
String defaultStatus=PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_STATUS),""String_Node_Str"");
mCommon.transactionEntity.setStatus(defaultStatus);
}
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
AsyncTask<Void,Void,Boolean> task=new AsyncTask<Void,Void,Boolean>(){
@Override protected Boolean doInBackground(Void... params){
try {
Core core=new Core(getApplicationContext());
Payee payee=core.getLastPayeeUsed();
if (payee != null && mCommon.transactionEntity.getPayeeId() == Constants.NOT_SET) {
mCommon.transactionEntity.setPayeeId(payee.getId());
mCommon.payeeName=payee.getName();
mCommon.transactionEntity.setCategoryId(payee.getCategoryId());
mCommon.transactionEntity.setSubcategoryId(payee.getSubcategoryId());
mCommon.loadCategoryName();
return Boolean.TRUE;
}
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
return Boolean.FALSE;
}
@Override protected void onPostExecute(Boolean result){
super.onPostExecute(result);
if (result) {
try {
mCommon.showPayeeName();
mCommon.displayCategoryName();
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
}
}
}
;
task.execute();
}
if (intent.getData() != null) {
externalIntegration(intent);
}
 else {
try {
Bundle extras=intent.getExtras();
if (extras != null) {
AccountRepository accountRepository=new AccountRepository(this);
if (Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_ACCOUNT_ID)) > 0) {
mCommon.transactionEntity.setAccountId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_ACCOUNT_ID)));
mCommon.transactionEntity.setAccountToId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID)));
CurrencyService currencyService=new CurrencyService(this);
mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(accountRepository.loadCurrencyIdFor(mCommon.transactionEntity.getAccountId()),mCommon.transactionEntity.getAmount(),accountRepository.loadCurrencyIdFor(mCommon.transactionEntity.getAccountToId())));
}
mCommon.transactionEntity.setTransactionType(TransactionTypes.valueOf(extras.getString(EditTransactionActivityConstants.KEY_TRANS_CODE)));
mCommon.transactionEntity.setAmount(MoneyFactory.fromString(extras.getString(EditTransactionActivityConstants.KEY_TRANS_AMOUNT)));
mCommon.transactionEntity.setNotes(extras.getString(EditTransactionActivityConstants.KEY_NOTES));
mCommon.transactionEntity.setDate(new MmxDate().toDate());
if (extras.getString(EditTransactionActivityConstants.KEY_PAYEE_NAME).isEmpty()) {
mCommon.payeeName=""String_Node_Str"";
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
Core core=new Core(this);
Payee payee=core.getLastPayeeUsed();
if (payee != null) {
  mCommon.transactionEntity.setPayeeId(payee.getId());
  mCommon.payeeName=payee.getName();
  mCommon.setCategoryFromPayee(mCommon.transactionEntity.getPayeeId());
}
}
}
 else {
mCommon.transactionEntity.setPayeeId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_PAYEE_ID)));
mCommon.payeeName=extras.getString(EditTransactionActivityConstants.KEY_PAYEE_NAME);
mCommon.setCategoryFromPayee(mCommon.transactionEntity.getPayeeId());
}
if (mCommon.payeeName.isEmpty()) {
String catID=extras.getString(EditTransactionActivityConstants.KEY_CATEGORY_ID);
String subCatID=extras.getString(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID);
if (!catID.isEmpty()) {
mCommon.transactionEntity.setCategoryId(parseInt(catID));
}
if (!subCatID.isEmpty()) {
mCommon.transactionEntity.setSubcategoryId(parseInt(subCatID));
}
mCommon.loadCategoryName();
}
mCommon.mToAccountName=accountRepository.loadName(mCommon.transactionEntity.getAccountToId());
extras=null;
}
}
 catch (Exception e) {
Toast.makeText(this,""String_Node_Str"" + e,Toast.LENGTH_LONG).show();
}
}
Integer account=mCommon.transactionEntity.getAccountId();
if (account == null || account == Constants.NOT_SET) {
AppSettings settings=new AppSettings(this);
Integer defaultAccountId=settings.getGeneralSettings().getDefaultAccountId();
if (defaultAccountId == null) {
new UIHelper(this).showToast(getString(R.string.default_account_not_set));
return false;
}
 else {
mCommon.transactionEntity.setAccountId(defaultAccountId);
}
}
}
if (getSupportActionBar() != null) {
getSupportActionBar().setTitle(Intent.ACTION_INSERT.equals(mIntentAction) ? R.string.new_transaction : R.string.edit_transaction);
}
return true;
}",0.9879116298457692
64753,"private void showDuplicateTransactionView(ArrayList<Integer> transIds){
  int transactionCount=transIds.size();
  if (transactionCount <= 0)   return;
  int[] ids=convertArrayListToArray(transIds);
  Intent[] intents=new Intent[transactionCount];
  for (int i=0; i < transactionCount; i++) {
    intents[i]=new Intent(getActivity(),CheckingTransactionEditActivity.class);
    intents[i].putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,ids[i]);
    intents[i].setAction(Intent.ACTION_PASTE);
  }
  getActivity().startActivities(intents);
}","private void showDuplicateTransactionView(ArrayList<Integer> transIds){
  int transactionCount=transIds.size();
  if (transactionCount <= 0)   return;
  int[] ids=convertArrayListToArray(transIds);
  Intent[] intents=new Intent[transactionCount];
  for (int i=0; i < transactionCount; i++) {
    intents[i]=new Intent(getActivity(),CheckingTransactionEditActivity.class);
    intents[i].putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,ids[i]);
    intents[i].setAction(Intent.ACTION_PASTE);
    intents[i].putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
  }
  getActivity().startActivities(intents);
}",0.920608108108108
64754,"/** 
 * start the activity of transaction management
 * @param transId null set if you want to do a new transaction, or transaction id
 */
private void startEditAccountTransactionActivity(Integer transId){
  Intent intent=new Intent(getActivity(),CheckingTransactionEditActivity.class);
  if (transId != null) {
    intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,transId);
    intent.setAction(Intent.ACTION_EDIT);
  }
 else {
    intent.putExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,this.AccountId);
    intent.setAction(Intent.ACTION_INSERT);
  }
  startActivity(intent);
}","/** 
 * start the activity of transaction management
 * @param transId null set if you want to do a new transaction, or transaction id
 */
private void startEditAccountTransactionActivity(Integer transId){
  Intent intent=new Intent(getActivity(),CheckingTransactionEditActivity.class);
  intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
  if (transId != null) {
    intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,transId);
    intent.setAction(Intent.ACTION_EDIT);
  }
 else {
    intent.putExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,this.AccountId);
    intent.setAction(Intent.ACTION_INSERT);
  }
  startActivity(intent);
}",0.931782945736434
64755,"@Subscribe public void onEvent(AmountEnteredEvent event){
  QueryAccountBills account=this.getAccountBeingBalanced();
  Money currentBalance=MoneyFactory.fromDouble(account.getTotal());
  Money newBalance=event.amount;
  if (newBalance.compareTo(currentBalance) == 0)   return;
  Money difference;
  TransactionTypes transactionType;
  if (newBalance.compareTo(currentBalance) > 0) {
    difference=newBalance.subtract(currentBalance);
    transactionType=TransactionTypes.Deposit;
  }
 else {
    difference=currentBalance.subtract(newBalance);
    transactionType=TransactionTypes.Withdrawal;
  }
  Intent intent=new Intent(getContext(),CheckingTransactionEditActivity.class);
  intent.setAction(Intent.ACTION_INSERT);
  IntentDataParameters params=new IntentDataParameters();
  params.accountName=account.getAccountName();
  params.transactionType=transactionType;
  params.payeeName=getContext().getString(R.string.balance_adjustment);
  params.amount=difference;
  params.categoryName=getContext().getString(R.string.cash);
  intent.setData(params.toUri());
  getContext().startActivity(intent);
}","@Subscribe public void onEvent(AmountEnteredEvent event){
  QueryAccountBills account=this.getAccountBeingBalanced();
  Money currentBalance=MoneyFactory.fromDouble(account.getTotal());
  Money newBalance=event.amount;
  if (newBalance.compareTo(currentBalance) == 0)   return;
  Money difference;
  TransactionTypes transactionType;
  if (newBalance.compareTo(currentBalance) > 0) {
    difference=newBalance.subtract(currentBalance);
    transactionType=TransactionTypes.Deposit;
  }
 else {
    difference=currentBalance.subtract(newBalance);
    transactionType=TransactionTypes.Withdrawal;
  }
  Intent intent=new Intent(getContext(),CheckingTransactionEditActivity.class);
  intent.setAction(Intent.ACTION_INSERT);
  intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
  IntentDataParameters params=new IntentDataParameters();
  params.accountName=account.getAccountName();
  params.transactionType=transactionType;
  params.payeeName=getContext().getString(R.string.balance_adjustment);
  params.amount=difference;
  params.categoryName=getContext().getString(R.string.cash);
  intent.setData(params.toUri());
  getContext().startActivity(intent);
}",0.961605584642234
64756,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  if (container == null)   return null;
  View view=inflater.inflate(R.layout.home_fragment,container,false);
  linearHome=(FrameLayout)view.findViewById(R.id.linearLayoutHome);
  txtTotalAccounts=(TextView)view.findViewById(R.id.textViewTotalAccounts);
  createWelcomeView(view);
  setUpAccountsList(view);
  prgAccountBills=(ProgressBar)view.findViewById(R.id.progressAccountBills);
  mFloatingActionButton=(FloatingActionButton)view.findViewById(R.id.fab);
  mFloatingActionButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Intent intent=new Intent(getActivity(),CheckingTransactionEditActivity.class);
      intent.setAction(Intent.ACTION_INSERT);
      startActivity(intent);
    }
  }
);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  if (container == null)   return null;
  View view=inflater.inflate(R.layout.home_fragment,container,false);
  linearHome=(FrameLayout)view.findViewById(R.id.linearLayoutHome);
  txtTotalAccounts=(TextView)view.findViewById(R.id.textViewTotalAccounts);
  createWelcomeView(view);
  setUpAccountsList(view);
  prgAccountBills=(ProgressBar)view.findViewById(R.id.progressAccountBills);
  mFloatingActionButton=(FloatingActionButton)view.findViewById(R.id.fab);
  mFloatingActionButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Intent intent=new Intent(getActivity(),CheckingTransactionEditActivity.class);
      intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
      intent.setAction(Intent.ACTION_INSERT);
      startActivity(intent);
    }
  }
);
  return view;
}",0.9497267759562842
64757,"@Override public void onReceive(Context context,Intent intent){
  mContext=context.getApplicationContext();
  final BehaviourSettings behav_settings=new BehaviourSettings(mContext);
  final GeneralSettings gen_settings=new GeneralSettings(mContext);
  final AppSettings app_settings=new AppSettings(mContext);
  final PreferenceConstants prf_const=new PreferenceConstants();
  int baseCurencyID, fromCurrencyID, toCurrencyID;
  int baseAccountID, fromAccountID, toAccountID;
  String baseCurrencySymbl, fromAccCurrencySymbl, toAccCurrencySymbl;
  String baseAccountName, fromAccountName, toAccountName;
  try {
    if (behav_settings.getBankSmsTrans() == true) {
      Bundle bundle=intent.getExtras();
      SmsMessage[] msgs=null;
      String msgBody=""String_Node_Str"";
      String msgSender=""String_Node_Str"";
      if (bundle != null) {
        Object[] pdus=(Object[])bundle.get(""String_Node_Str"");
        msgs=new SmsMessage[pdus.length];
        for (int i=0; i < msgs.length; i++) {
          msgs[i]=SmsMessage.createFromPdu((byte[])pdus[i]);
          msgSender=msgs[i].getOriginatingAddress();
          msgBody+=msgs[i].getMessageBody().toString();
        }
        ITransactionEntity model=AccountTransaction.create();
        mCommon=new EditTransactionCommonFunctions(null,model,database);
        String[] key_credit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String[] key_debit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String transType=""String_Node_Str"";
        Boolean isDeposit=validateTransType(key_credit_search,msgBody.toLowerCase());
        Boolean isWithdrawal=validateTransType(key_debit_search,msgBody.toLowerCase());
        if (isDeposit == true) {
          if (isWithdrawal == true) {
            transType=""String_Node_Str"";
            String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!transCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
            }
            if (!transCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
          }
 else {
            transType=""String_Node_Str"";
            String[] incomeCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!incomeCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(incomeCategory[0]));
            }
            if (!incomeCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(incomeCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Deposit);
          }
          mCommon.payeeName=""String_Node_Str"";
        }
 else         if (isWithdrawal == true) {
          transType=""String_Node_Str"";
          mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
        }
        mCommon.transactionEntity.setStatus(""String_Node_Str"");
        if (transType != ""String_Node_Str"" && msgBody.toLowerCase().contains(""String_Node_Str"") == false) {
          Intent t_intent=new Intent(mContext,CheckingTransactionEditActivity.class);
          MmxHelper=new MmxOpenHelper(mContext,app_settings.getDatabaseSettings().getDatabasePath());
          db=MmxHelper.getReadableDatabase();
          baseCurencyID=gen_settings.getBaseCurrencytId();
          baseAccountID=gen_settings.getDefaultAccountId();
          baseAccountName=""String_Node_Str"";
          fromAccountID=-1;
          fromCurrencyID=-1;
          fromAccountName=""String_Node_Str"";
          if (baseAccountID > 0) {
            fromAccountID=baseAccountID;
            fromAccountName=baseAccountName;
            fromCurrencyID=baseCurencyID;
          }
          baseCurrencySymbl=getCurrencySymbl(baseCurencyID);
          fromAccCurrencySymbl=baseCurrencySymbl;
          String[] fromAccountDetails=extractAccountDetails(msgBody,1);
          if (!fromAccountDetails[0].isEmpty()) {
            fromAccountID=parseInt(fromAccountDetails[0]);
            fromAccountName=fromAccountDetails[1];
            fromCurrencyID=parseInt(fromAccountDetails[2]);
            fromAccCurrencySymbl=fromAccountDetails[3];
            mCommon.transactionEntity.setAccountId(fromAccountID);
          }
          mCommon.transactionEntity.setNotes(msgBody);
          mCommon.transactionEntity.setDate(new MmxDate().toDate());
          String transAmount=extractTransAmount(msgBody,fromAccCurrencySymbl);
          if (!transAmount.isEmpty()) {
            mCommon.transactionEntity.setAmount(MoneyFactory.fromString(transAmount));
            String[] transPayee=extractTransPayee(msgBody);
            String transRefNo=extractTransRefNo(msgBody);
            int txnId=getTxnId(transRefNo.trim(),transType,mCommon.transactionEntity.getDateString());
switch (txnId) {
case 0:
              if (transType == ""String_Node_Str"") {
                String[] toAccountDetails=extractAccountDetails(msgBody,2);
                if (!toAccountDetails[0].isEmpty()) {
                  toAccountID=parseInt(toAccountDetails[0]);
                  toAccountName=toAccountDetails[1];
                  toCurrencyID=parseInt(toAccountDetails[2]);
                  toAccCurrencySymbl=toAccountDetails[3];
                  mCommon.transactionEntity.setAccountToId(toAccountID);
                  CurrencyService currencyService=new CurrencyService(mContext);
                  mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
                  mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
                }
 else {
                  transType=""String_Node_Str"";
                  mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
                  mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                  mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
                  if (!toAccountDetails[6].isEmpty() && transPayee[0].isEmpty()) {
                    transPayee=getPayeeDetails(toAccountDetails[6].trim());
                  }
                }
              }
 else {
                mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
              }
            if (!transPayee[0].isEmpty()) {
              mCommon.transactionEntity.setPayeeId(parseInt(transPayee[0]));
              mCommon.payeeName=transPayee[1];
              mCommon.transactionEntity.setCategoryId(parseInt(transPayee[2]));
              mCommon.transactionEntity.setSubcategoryId(parseInt(transPayee[3]));
            }
 else {
              mCommon.payeeName=""String_Node_Str"";
            }
          t_intent.setAction(Intent.ACTION_INSERT);
        break;
default :
      transType=""String_Node_Str"";
    AccountTransactionRepository repo=new AccountTransactionRepository(mContext);
  AccountTransaction txn=repo.load(txnId);
if (txn != null) {
  if (txn.getTransactionType() != TransactionTypes.Transfer) {
    AccountRepository accountRepository=new AccountRepository(mContext);
    toAccountID=fromAccountID;
    toCurrencyID=fromCurrencyID;
    fromCurrencyID=accountRepository.loadCurrencyIdFor(txn.getAccountId());
    mCommon.transactionEntity=txn;
    mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
    mCommon.transactionEntity.setAccountToId(toAccountID);
    CurrencyService currencyService=new CurrencyService(mContext);
    mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
    mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
    String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
    if (!transCategory[0].isEmpty()) {
      mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
      mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
    }
    mCommon.transactionEntity.setNotes(mCommon.transactionEntity.getNotes() + ""String_Node_Str"" + msgBody);
  }
}
t_intent.setAction(Intent.ACTION_EDIT);
}
String strExtracted=""String_Node_Str"" + fromAccountName + ""String_Node_Str""+ fromAccountDetails[6]+ ""String_Node_Str""+ ""String_Node_Str""+ fromAccCurrencySymbl+ ""String_Node_Str""+ transAmount+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[1]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[2]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[3]+ ""String_Node_Str""+ ""String_Node_Str""+ transRefNo+ ""String_Node_Str""+ ""String_Node_Str""+ transType+ ""String_Node_Str"";
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,mCommon.transactionEntity.getId());
t_intent.putExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountToId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_CODE,mCommon.getTransactionType());
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_ID,String.valueOf(mCommon.transactionEntity.getPayeeId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_NAME,mCommon.payeeName);
t_intent.putExtra(EditTransactionActivityConstants.KEY_CATEGORY_ID,String.valueOf(mCommon.transactionEntity.getCategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID,String.valueOf(mCommon.transactionEntity.getSubcategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_AMOUNT,String.valueOf(mCommon.transactionEntity.getAmount()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_NOTES,mCommon.transactionEntity.getNotes());
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_DATE,new MmxDate().toDate());
if (validateData()) {
if (saveTransaction()) {
Toast.makeText(context,""String_Node_Str"" + strExtracted,Toast.LENGTH_LONG).show();
}
 else {
startActivity(mContext,t_intent,null);
}
}
 else {
startActivity(mContext,t_intent,null);
}
bundle=null;
msgs=null;
msgBody=""String_Node_Str"";
msgSender=""String_Node_Str"";
mCommon=null;
}
}
}
}
}
 catch (Exception e) {
Toast.makeText(context,""String_Node_Str"" + e,Toast.LENGTH_LONG).show();
}
}","@Override public void onReceive(Context context,Intent intent){
  mContext=context.getApplicationContext();
  final BehaviourSettings behav_settings=new BehaviourSettings(mContext);
  final GeneralSettings gen_settings=new GeneralSettings(mContext);
  final AppSettings app_settings=new AppSettings(mContext);
  final PreferenceConstants prf_const=new PreferenceConstants();
  int baseCurencyID, fromCurrencyID, toCurrencyID;
  int baseAccountID, fromAccountID, toAccountID;
  String baseCurrencySymbl, fromAccCurrencySymbl, toAccCurrencySymbl;
  String baseAccountName, fromAccountName, toAccountName;
  try {
    if (behav_settings.getBankSmsTrans() == true) {
      Bundle bundle=intent.getExtras();
      SmsMessage[] msgs=null;
      String msgBody=""String_Node_Str"";
      String msgSender=""String_Node_Str"";
      if (bundle != null) {
        Object[] pdus=(Object[])bundle.get(""String_Node_Str"");
        msgs=new SmsMessage[pdus.length];
        for (int i=0; i < msgs.length; i++) {
          msgs[i]=SmsMessage.createFromPdu((byte[])pdus[i]);
          msgSender=msgs[i].getOriginatingAddress();
          msgBody+=msgs[i].getMessageBody().toString();
        }
        ITransactionEntity model=AccountTransaction.create();
        mCommon=new EditTransactionCommonFunctions(null,model,database);
        String[] key_credit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String[] key_debit_search={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        String transType=""String_Node_Str"";
        Boolean isDeposit=validateTransType(key_credit_search,msgBody.toLowerCase());
        Boolean isWithdrawal=validateTransType(key_debit_search,msgBody.toLowerCase());
        if (isDeposit == true) {
          if (isWithdrawal == true) {
            transType=""String_Node_Str"";
            String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!transCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
            }
            if (!transCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
          }
 else {
            transType=""String_Node_Str"";
            String[] incomeCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
            if (!incomeCategory[0].isEmpty()) {
              mCommon.transactionEntity.setCategoryId(parseInt(incomeCategory[0]));
            }
            if (!incomeCategory[1].isEmpty()) {
              mCommon.transactionEntity.setSubcategoryId(parseInt(incomeCategory[1]));
            }
            mCommon.transactionEntity.setTransactionType(TransactionTypes.Deposit);
          }
          mCommon.payeeName=""String_Node_Str"";
        }
 else         if (isWithdrawal == true) {
          transType=""String_Node_Str"";
          mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
        }
        mCommon.transactionEntity.setStatus(""String_Node_Str"");
        if (transType != ""String_Node_Str"" && msgBody.toLowerCase().contains(""String_Node_Str"") == false) {
          Intent t_intent=new Intent(mContext,CheckingTransactionEditActivity.class);
          MmxHelper=new MmxOpenHelper(mContext,app_settings.getDatabaseSettings().getDatabasePath());
          db=MmxHelper.getReadableDatabase();
          baseCurencyID=gen_settings.getBaseCurrencytId();
          baseAccountID=gen_settings.getDefaultAccountId();
          baseAccountName=""String_Node_Str"";
          fromAccountID=-1;
          fromCurrencyID=-1;
          fromAccountName=""String_Node_Str"";
          if (baseAccountID > 0) {
            fromAccountID=baseAccountID;
            fromAccountName=baseAccountName;
            fromCurrencyID=baseCurencyID;
          }
          baseCurrencySymbl=getCurrencySymbl(baseCurencyID);
          fromAccCurrencySymbl=baseCurrencySymbl;
          String[] fromAccountDetails=extractAccountDetails(msgBody,1);
          if (!fromAccountDetails[0].isEmpty()) {
            fromAccountID=parseInt(fromAccountDetails[0]);
            fromAccountName=fromAccountDetails[1];
            fromCurrencyID=parseInt(fromAccountDetails[2]);
            fromAccCurrencySymbl=fromAccountDetails[3];
            mCommon.transactionEntity.setAccountId(fromAccountID);
          }
          mCommon.transactionEntity.setNotes(msgBody);
          mCommon.transactionEntity.setDate(new MmxDate().toDate());
          String transAmount=extractTransAmount(msgBody,fromAccCurrencySymbl);
          if (!fromAccountDetails[6].isEmpty() && !transAmount.isEmpty()) {
            mCommon.transactionEntity.setAmount(MoneyFactory.fromString(transAmount));
            String[] transPayee=extractTransPayee(msgBody);
            String transRefNo=extractTransRefNo(msgBody);
            int txnId=getTxnId(transRefNo.trim(),transType,mCommon.transactionEntity.getDateString());
switch (txnId) {
case 0:
              if (transType == ""String_Node_Str"") {
                String[] toAccountDetails=extractAccountDetails(msgBody,2);
                if (!toAccountDetails[0].isEmpty()) {
                  toAccountID=parseInt(toAccountDetails[0]);
                  toAccountName=toAccountDetails[1];
                  toCurrencyID=parseInt(toAccountDetails[2]);
                  toAccCurrencySymbl=toAccountDetails[3];
                  mCommon.transactionEntity.setAccountToId(toAccountID);
                  CurrencyService currencyService=new CurrencyService(mContext);
                  mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
                  mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
                }
 else {
                  transType=""String_Node_Str"";
                  mCommon.transactionEntity.setTransactionType(TransactionTypes.Withdrawal);
                  mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                  mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
                  if (!toAccountDetails[6].isEmpty() && transPayee[0].isEmpty()) {
                    transPayee=getPayeeDetails(toAccountDetails[6].trim());
                  }
                }
              }
 else {
                mCommon.transactionEntity.setAccountToId(Constants.NOT_SET);
                mCommon.transactionEntity.setAmountTo(MoneyFactory.fromString(transAmount));
              }
            if (!transPayee[0].isEmpty()) {
              mCommon.transactionEntity.setPayeeId(parseInt(transPayee[0]));
              mCommon.payeeName=transPayee[1];
              mCommon.transactionEntity.setCategoryId(parseInt(transPayee[2]));
              mCommon.transactionEntity.setSubcategoryId(parseInt(transPayee[3]));
            }
 else {
              mCommon.payeeName=""String_Node_Str"";
            }
          t_intent.setAction(Intent.ACTION_INSERT);
        break;
default :
      transType=""String_Node_Str"";
    AccountTransactionRepository repo=new AccountTransactionRepository(mContext);
  AccountTransaction txn=repo.load(txnId);
if (txn != null) {
  if (txn.getTransactionType() != TransactionTypes.Transfer) {
    AccountRepository accountRepository=new AccountRepository(mContext);
    toAccountID=fromAccountID;
    toCurrencyID=fromCurrencyID;
    fromCurrencyID=accountRepository.loadCurrencyIdFor(txn.getAccountId());
    mCommon.transactionEntity=txn;
    mCommon.transactionEntity.setTransactionType(TransactionTypes.Transfer);
    mCommon.transactionEntity.setAccountToId(toAccountID);
    CurrencyService currencyService=new CurrencyService(mContext);
    mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(fromCurrencyID,mCommon.transactionEntity.getAmount(),toCurrencyID));
    mCommon.transactionEntity.setPayeeId(Constants.NOT_SET);
    String[] transCategory=getCategoryOrSubCategoryByName(""String_Node_Str"");
    if (!transCategory[0].isEmpty()) {
      mCommon.transactionEntity.setCategoryId(parseInt(transCategory[0]));
      mCommon.transactionEntity.setSubcategoryId(parseInt(transCategory[1]));
    }
    mCommon.transactionEntity.setNotes(mCommon.transactionEntity.getNotes() + ""String_Node_Str"" + msgBody);
  }
}
t_intent.setAction(Intent.ACTION_EDIT);
}
String strExtracted=""String_Node_Str"" + fromAccountName + ""String_Node_Str""+ fromAccountDetails[6]+ ""String_Node_Str""+ ""String_Node_Str""+ fromAccCurrencySymbl+ ""String_Node_Str""+ transAmount+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[1]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[2]+ ""String_Node_Str""+ ""String_Node_Str""+ transPayee[3]+ ""String_Node_Str""+ ""String_Node_Str""+ transRefNo+ ""String_Node_Str""+ ""String_Node_Str""+ transType+ ""String_Node_Str"";
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_ID,mCommon.transactionEntity.getId());
t_intent.putExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID,String.valueOf(mCommon.transactionEntity.getAccountToId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_CODE,mCommon.getTransactionType());
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_ID,String.valueOf(mCommon.transactionEntity.getPayeeId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_PAYEE_NAME,mCommon.payeeName);
t_intent.putExtra(EditTransactionActivityConstants.KEY_CATEGORY_ID,String.valueOf(mCommon.transactionEntity.getCategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID,String.valueOf(mCommon.transactionEntity.getSubcategoryId()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_AMOUNT,String.valueOf(mCommon.transactionEntity.getAmount()));
t_intent.putExtra(EditTransactionActivityConstants.KEY_NOTES,mCommon.transactionEntity.getNotes());
t_intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_DATE,new MmxDate().toDate());
if (validateData()) {
if (saveTransaction()) {
Toast.makeText(context,""String_Node_Str"" + strExtracted,Toast.LENGTH_LONG).show();
}
 else {
startActivity(mContext,t_intent,null);
}
}
 else {
startActivity(mContext,t_intent,null);
}
bundle=null;
msgs=null;
msgBody=""String_Node_Str"";
msgSender=""String_Node_Str"";
mCommon=null;
}
}
}
}
}
 catch (Exception e) {
Toast.makeText(context,""String_Node_Str"" + e,Toast.LENGTH_LONG).show();
}
}",0.9941974730931212
64758,"private void showCreateTransactionActivity(int recurringTransactionId){
  RecurringTransactionRepository repo=new RecurringTransactionRepository(getActivity());
  RecurringTransaction tx=repo.load(recurringTransactionId);
  if (tx == null)   return;
  Intent intent=new Intent(getActivity(),CheckingTransactionEditActivity.class);
  intent.setAction(Intent.ACTION_INSERT);
  intent.putExtra(EditTransactionActivityConstants.KEY_BDID_ID,recurringTransactionId);
  startActivityForResult(intent,REQUEST_ADD_TRANSACTION);
}","private void showCreateTransactionActivity(int recurringTransactionId){
  RecurringTransactionRepository repo=new RecurringTransactionRepository(getActivity());
  RecurringTransaction tx=repo.load(recurringTransactionId);
  if (tx == null)   return;
  Intent intent=new Intent(getActivity(),CheckingTransactionEditActivity.class);
  intent.setAction(Intent.ACTION_INSERT);
  intent.putExtra(EditTransactionActivityConstants.KEY_BDID_ID,recurringTransactionId);
  intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
  startActivityForResult(intent,REQUEST_ADD_TRANSACTION);
}",0.9219858156028368
64759,"/** 
 * Get the parameters from the intent (parameters sent from the caller). Also used for Tasker integration, for example.
 * @param savedInstanceState parameters
 */
private boolean handleIntent(Bundle savedInstanceState){
  Intent intent=getIntent();
  mIntentAction=intent.getAction();
  if (mIntentAction == null) {
    Timber.w(""String_Node_Str"");
    return false;
  }
  if (savedInstanceState == null) {
    int accountId=intent.getIntExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,Constants.NOT_SET);
    if (accountId != Constants.NOT_SET) {
      mCommon.transactionEntity.setAccountId(accountId);
    }
    if (mIntentAction != null) {
      int transactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_TRANS_ID,Constants.NOT_SET);
switch (mIntentAction) {
case Intent.ACTION_EDIT:
        loadTransaction(transactionId);
      break;
case Intent.ACTION_PASTE:
    loadTransaction(transactionId);
  duplicateTransaction();
break;
case Intent.ACTION_INSERT:
mRecurringTransactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_BDID_ID,Constants.NOT_SET);
if (mRecurringTransactionId > Constants.NOT_SET) {
loadRecurringTransaction(mRecurringTransactionId);
}
}
}
}
if (mIntentAction.equals(Intent.ACTION_INSERT)) {
if (mCommon.transactionEntity.getStatus() == null) {
String defaultStatus=PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_STATUS),""String_Node_Str"");
mCommon.transactionEntity.setStatus(defaultStatus);
}
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
AsyncTask<Void,Void,Boolean> task=new AsyncTask<Void,Void,Boolean>(){
@Override protected Boolean doInBackground(Void... params){
try {
Core core=new Core(getApplicationContext());
Payee payee=core.getLastPayeeUsed();
if (payee != null && mCommon.transactionEntity.getPayeeId() == Constants.NOT_SET) {
mCommon.transactionEntity.setPayeeId(payee.getId());
mCommon.payeeName=payee.getName();
mCommon.transactionEntity.setCategoryId(payee.getCategoryId());
mCommon.transactionEntity.setSubcategoryId(payee.getSubcategoryId());
mCommon.loadCategoryName();
return Boolean.TRUE;
}
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
return Boolean.FALSE;
}
@Override protected void onPostExecute(Boolean result){
super.onPostExecute(result);
if (result) {
try {
mCommon.showPayeeName();
mCommon.displayCategoryName();
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
}
}
}
;
task.execute();
}
if (intent.getData() != null) {
externalIntegration(intent);
}
 else {
try {
Bundle extras=intent.getExtras();
if (extras != null) {
AccountRepository accountRepository=new AccountRepository(this);
if (Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_ACCOUNT_ID)) > 0) {
mCommon.transactionEntity.setAccountId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_ACCOUNT_ID)));
mCommon.transactionEntity.setAccountToId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID)));
CurrencyService currencyService=new CurrencyService(this);
mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(accountRepository.loadCurrencyIdFor(mCommon.transactionEntity.getAccountId()),mCommon.transactionEntity.getAmount(),accountRepository.loadCurrencyIdFor(mCommon.transactionEntity.getAccountToId())));
}
mCommon.transactionEntity.setTransactionType(TransactionTypes.valueOf(extras.getString(EditTransactionActivityConstants.KEY_TRANS_CODE)));
mCommon.transactionEntity.setAmount(MoneyFactory.fromString(extras.getString(EditTransactionActivityConstants.KEY_TRANS_AMOUNT)));
mCommon.transactionEntity.setNotes(extras.getString(EditTransactionActivityConstants.KEY_NOTES));
mCommon.transactionEntity.setDate(new MmxDate().toDate());
if (extras.getString(EditTransactionActivityConstants.KEY_PAYEE_NAME).isEmpty()) {
mCommon.payeeName=""String_Node_Str"";
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
Core core=new Core(this);
Payee payee=core.getLastPayeeUsed();
if (payee != null) {
  mCommon.transactionEntity.setPayeeId(payee.getId());
  mCommon.payeeName=payee.getName();
  mCommon.setCategoryFromPayee(mCommon.transactionEntity.getPayeeId());
}
}
}
 else {
mCommon.transactionEntity.setPayeeId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_PAYEE_ID)));
mCommon.payeeName=extras.getString(EditTransactionActivityConstants.KEY_PAYEE_NAME);
mCommon.setCategoryFromPayee(mCommon.transactionEntity.getPayeeId());
}
if (mCommon.payeeName.isEmpty()) {
String catID=extras.getString(EditTransactionActivityConstants.KEY_CATEGORY_ID);
String subCatID=extras.getString(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID);
if (!catID.isEmpty()) {
mCommon.transactionEntity.setCategoryId(parseInt(catID));
}
if (!subCatID.isEmpty()) {
mCommon.transactionEntity.setSubcategoryId(parseInt(subCatID));
}
mCommon.loadCategoryName();
}
mCommon.mToAccountName=accountRepository.loadName(mCommon.transactionEntity.getAccountToId());
extras=null;
}
}
 catch (Exception e) {
Toast.makeText(this,""String_Node_Str"" + e,Toast.LENGTH_LONG).show();
}
}
Integer account=mCommon.transactionEntity.getAccountId();
if (account == null || account == Constants.NOT_SET) {
AppSettings settings=new AppSettings(this);
Integer defaultAccountId=settings.getGeneralSettings().getDefaultAccountId();
if (defaultAccountId == null) {
new UIHelper(this).showToast(getString(R.string.default_account_not_set));
return false;
}
 else {
mCommon.transactionEntity.setAccountId(defaultAccountId);
}
}
}
if (getSupportActionBar() != null) {
getSupportActionBar().setTitle(Intent.ACTION_INSERT.equals(mIntentAction) ? R.string.new_transaction : R.string.edit_transaction);
}
return true;
}","/** 
 * Get the parameters from the intent (parameters sent from the caller). Also used for Tasker integration, for example.
 * @param savedInstanceState parameters
 */
private boolean handleIntent(Bundle savedInstanceState){
  Intent intent=getIntent();
  mIntentAction=intent.getAction();
  if (mIntentAction == null) {
    Timber.w(""String_Node_Str"");
    return false;
  }
  if (savedInstanceState == null) {
    int accountId=intent.getIntExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,Constants.NOT_SET);
    if (accountId != Constants.NOT_SET) {
      mCommon.transactionEntity.setAccountId(accountId);
    }
    if (mIntentAction != null) {
      int transactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_TRANS_ID,Constants.NOT_SET);
switch (mIntentAction) {
case Intent.ACTION_EDIT:
        loadTransaction(transactionId);
      break;
case Intent.ACTION_PASTE:
    loadTransaction(transactionId);
  duplicateTransaction();
break;
case Intent.ACTION_INSERT:
mRecurringTransactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_BDID_ID,Constants.NOT_SET);
if (mRecurringTransactionId > Constants.NOT_SET) {
loadRecurringTransaction(mRecurringTransactionId);
}
}
}
}
if (mIntentAction.equals(Intent.ACTION_INSERT)) {
if (mCommon.transactionEntity.getStatus() == null) {
String defaultStatus=PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_STATUS),""String_Node_Str"");
mCommon.transactionEntity.setStatus(defaultStatus);
}
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
AsyncTask<Void,Void,Boolean> task=new AsyncTask<Void,Void,Boolean>(){
@Override protected Boolean doInBackground(Void... params){
try {
Core core=new Core(getApplicationContext());
Payee payee=core.getLastPayeeUsed();
if (payee != null && mCommon.transactionEntity.getPayeeId() == Constants.NOT_SET) {
mCommon.transactionEntity.setPayeeId(payee.getId());
mCommon.payeeName=payee.getName();
mCommon.transactionEntity.setCategoryId(payee.getCategoryId());
mCommon.transactionEntity.setSubcategoryId(payee.getSubcategoryId());
mCommon.loadCategoryName();
return Boolean.TRUE;
}
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
return Boolean.FALSE;
}
@Override protected void onPostExecute(Boolean result){
super.onPostExecute(result);
if (result) {
try {
mCommon.showPayeeName();
mCommon.displayCategoryName();
}
 catch (Exception e) {
Timber.e(e,""String_Node_Str"");
}
}
}
}
;
task.execute();
}
if (intent.getData() != null) {
externalIntegration(intent);
}
 else {
try {
Bundle extras=intent.getExtras();
if (extras != null && extras.getString(EditTransactionActivityConstants.KEY_TRANS_SOURCE).contentEquals(""String_Node_Str"")) {
AccountRepository accountRepository=new AccountRepository(this);
if (Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_ACCOUNT_ID)) > 0) {
mCommon.transactionEntity.setAccountId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_ACCOUNT_ID)));
mCommon.transactionEntity.setAccountToId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_TO_ACCOUNT_ID)));
CurrencyService currencyService=new CurrencyService(this);
mCommon.transactionEntity.setAmountTo(currencyService.doCurrencyExchange(accountRepository.loadCurrencyIdFor(mCommon.transactionEntity.getAccountId()),mCommon.transactionEntity.getAmount(),accountRepository.loadCurrencyIdFor(mCommon.transactionEntity.getAccountToId())));
}
mCommon.transactionEntity.setTransactionType(TransactionTypes.valueOf(extras.getString(EditTransactionActivityConstants.KEY_TRANS_CODE)));
mCommon.transactionEntity.setAmount(MoneyFactory.fromString(extras.getString(EditTransactionActivityConstants.KEY_TRANS_AMOUNT)));
mCommon.transactionEntity.setNotes(extras.getString(EditTransactionActivityConstants.KEY_NOTES));
mCommon.transactionEntity.setDate(new MmxDate().toDate());
if (extras.getString(EditTransactionActivityConstants.KEY_PAYEE_NAME).isEmpty()) {
mCommon.payeeName=""String_Node_Str"";
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
Core core=new Core(this);
Payee payee=core.getLastPayeeUsed();
if (payee != null) {
  mCommon.transactionEntity.setPayeeId(payee.getId());
  mCommon.payeeName=payee.getName();
  mCommon.setCategoryFromPayee(mCommon.transactionEntity.getPayeeId());
}
}
}
 else {
mCommon.transactionEntity.setPayeeId(Integer.parseInt(extras.getString(EditTransactionActivityConstants.KEY_PAYEE_ID)));
mCommon.payeeName=extras.getString(EditTransactionActivityConstants.KEY_PAYEE_NAME);
mCommon.setCategoryFromPayee(mCommon.transactionEntity.getPayeeId());
}
if (mCommon.payeeName.isEmpty()) {
String catID=extras.getString(EditTransactionActivityConstants.KEY_CATEGORY_ID);
String subCatID=extras.getString(EditTransactionActivityConstants.KEY_SUBCATEGORY_ID);
if (!catID.isEmpty()) {
mCommon.transactionEntity.setCategoryId(parseInt(catID));
}
if (!subCatID.isEmpty()) {
mCommon.transactionEntity.setSubcategoryId(parseInt(subCatID));
}
mCommon.loadCategoryName();
}
mCommon.mToAccountName=accountRepository.loadName(mCommon.transactionEntity.getAccountToId());
extras=null;
}
}
 catch (Exception e) {
Toast.makeText(this,""String_Node_Str"" + e,Toast.LENGTH_LONG).show();
}
}
Integer account=mCommon.transactionEntity.getAccountId();
if (account == null || account == Constants.NOT_SET) {
AppSettings settings=new AppSettings(this);
Integer defaultAccountId=settings.getGeneralSettings().getDefaultAccountId();
if (defaultAccountId == null) {
new UIHelper(this).showToast(getString(R.string.default_account_not_set));
return false;
}
 else {
mCommon.transactionEntity.setAccountId(defaultAccountId);
}
}
}
if (getSupportActionBar() != null) {
getSupportActionBar().setTitle(Intent.ACTION_INSERT.equals(mIntentAction) ? R.string.new_transaction : R.string.edit_transaction);
}
return true;
}",0.9914163090128756
64760,"@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  for (int i=0; i < appWidgetIds.length; ++i) {
    RemoteViews remoteViews=new RemoteViews(context.getPackageName(),R.layout.widget_button_add_transaction);
    Intent intent=new Intent(context,CheckingTransactionEditActivity.class);
    intent.setAction(Intent.ACTION_INSERT);
    PendingIntent pendingIntent=PendingIntent.getActivity(context,0,intent,0);
    remoteViews.setOnClickPendingIntent(R.id.buttonNewOperation,pendingIntent);
    appWidgetManager.updateAppWidget(appWidgetIds[i],remoteViews);
  }
  super.onUpdate(context,appWidgetManager,appWidgetIds);
}","@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  for (int i=0; i < appWidgetIds.length; ++i) {
    RemoteViews remoteViews=new RemoteViews(context.getPackageName(),R.layout.widget_button_add_transaction);
    Intent intent=new Intent(context,CheckingTransactionEditActivity.class);
    intent.setAction(Intent.ACTION_INSERT);
    intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
    PendingIntent pendingIntent=PendingIntent.getActivity(context,0,intent,0);
    remoteViews.setOnClickPendingIntent(R.id.buttonNewOperation,pendingIntent);
    appWidgetManager.updateAppWidget(appWidgetIds[i],remoteViews);
  }
  super.onUpdate(context,appWidgetManager,appWidgetIds);
}",0.9369747899159664
64761,"private void initializeNewTransactionCommand(Context context,RemoteViews views){
  Intent intent=new Intent(context,CheckingTransactionEditActivity.class);
  intent.setAction(Intent.ACTION_INSERT);
  intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
  intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
  intent.addCategory(Intent.CATEGORY_LAUNCHER);
  PendingIntent pendingIntent=PendingIntent.getActivity(context,0,intent,0);
  views.setOnClickPendingIntent(R.id.newTransactionPanel,pendingIntent);
  views.setOnClickPendingIntent(R.id.newTransactionButton,pendingIntent);
}","private void initializeNewTransactionCommand(Context context,RemoteViews views){
  Intent intent=new Intent(context,CheckingTransactionEditActivity.class);
  intent.setAction(Intent.ACTION_INSERT);
  intent.putExtra(EditTransactionActivityConstants.KEY_TRANS_SOURCE,""String_Node_Str"");
  intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
  intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
  intent.addCategory(Intent.CATEGORY_LAUNCHER);
  PendingIntent pendingIntent=PendingIntent.getActivity(context,0,intent,0);
  views.setOnClickPendingIntent(R.id.newTransactionPanel,pendingIntent);
  views.setOnClickPendingIntent(R.id.newTransactionButton,pendingIntent);
}",0.9388888888888888
64762,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_edit_recurring_transaction);
  initializeModel();
  mCommonFunctions=new EditTransactionCommonFunctions(this,mRecurringTransaction);
  showStandardToolbarActions();
  if (savedInstanceState != null) {
    restoreInstanceState(savedInstanceState);
  }
  if (getIntent() != null) {
    if (savedInstanceState == null) {
      String action=getIntent().getAction();
      if (action != null && action.equals(Intent.ACTION_EDIT)) {
        int id=getIntent().getIntExtra(KEY_BILL_DEPOSITS_ID,Constants.NOT_SET);
        loadRecurringTransaction(id);
      }
 else {
        mRecurringTransaction.setAccountId(getIntent().getIntExtra(KEY_ACCOUNT_ID,Constants.NOT_SET));
      }
    }
    mIntentAction=getIntent().getAction();
    if (getSupportActionBar() != null) {
      getSupportActionBar().setTitle(Intent.ACTION_INSERT.equals(mIntentAction) ? R.string.new_repeating_transaction : R.string.edit_repeating_transaction);
    }
  }
  initializeViewHolder();
  initializeControls();
  mCommonFunctions.onTransactionTypeChanged(mCommonFunctions.transactionEntity.getTransactionType());
  mCommonFunctions.refreshPayeeName();
  mCommonFunctions.displayCategoryName();
  showPaymentsLeft();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_edit_recurring_transaction);
  initializeModel();
  mCommonFunctions=new EditTransactionCommonFunctions(this,mRecurringTransaction);
  showStandardToolbarActions();
  if (savedInstanceState != null) {
    restoreInstanceState(savedInstanceState);
  }
  if (getIntent() != null) {
    if (savedInstanceState == null) {
      String action=getIntent().getAction();
      if (action != null && action.equals(Intent.ACTION_EDIT)) {
        int id=getIntent().getIntExtra(KEY_BILL_DEPOSITS_ID,Constants.NOT_SET);
        loadRecurringTransaction(id);
      }
 else {
        mRecurringTransaction.setAccountId(getIntent().getIntExtra(KEY_ACCOUNT_ID,Constants.NOT_SET));
      }
    }
    mIntentAction=getIntent().getAction();
    if (getSupportActionBar() != null) {
      getSupportActionBar().setTitle(Intent.ACTION_INSERT.equals(mIntentAction) ? R.string.new_repeating_transaction : R.string.edit_repeating_transaction);
    }
  }
  initializeViewHolder();
  initializeControls();
  mCommonFunctions.onTransactionTypeChanged(mCommonFunctions.transactionEntity.getTransactionType());
  mCommonFunctions.showPayeeName();
  mCommonFunctions.displayCategoryName();
  showPaymentsLeft();
}",0.9973474801061007
64763,"/** 
 * this method allows you to search the transaction data
 * @param recurringTransactionId transaction id
 * @return true if data selected, false nothing
 */
private boolean loadRecurringTransaction(int recurringTransactionId){
  RecurringTransactionRepository repo=new RecurringTransactionRepository(this);
  mRecurringTransaction=repo.load(recurringTransactionId);
  if (mRecurringTransaction == null)   return false;
  mCommonFunctions.transactionEntity=mRecurringTransaction;
  String transCode=mRecurringTransaction.getTransactionCode();
  mCommonFunctions.transactionEntity.setTransactionType(TransactionTypes.valueOf(transCode));
  if (!mCommonFunctions.transactionEntity.hasCategory() && mCommonFunctions.mSplitTransactions == null) {
    RecurringTransactionService recurringTransaction=new RecurringTransactionService(recurringTransactionId,this);
    mCommonFunctions.mSplitTransactions=recurringTransaction.loadSplitTransactions();
  }
  AccountRepository accountRepository=new AccountRepository(this);
  mCommonFunctions.mToAccountName=accountRepository.loadName(mCommonFunctions.transactionEntity.getAccountToId());
  mCommonFunctions.selectPayeeName(mCommonFunctions.transactionEntity.getPayeeId());
  mCommonFunctions.loadCategoryName();
  return true;
}","/** 
 * this method allows you to search the transaction data
 * @param recurringTransactionId transaction id
 * @return true if data selected, false nothing
 */
private boolean loadRecurringTransaction(int recurringTransactionId){
  RecurringTransactionRepository repo=new RecurringTransactionRepository(this);
  mRecurringTransaction=repo.load(recurringTransactionId);
  if (mRecurringTransaction == null)   return false;
  mCommonFunctions.transactionEntity=mRecurringTransaction;
  String transCode=mRecurringTransaction.getTransactionCode();
  mCommonFunctions.transactionEntity.setTransactionType(TransactionTypes.valueOf(transCode));
  if (!mCommonFunctions.transactionEntity.hasCategory() && mCommonFunctions.mSplitTransactions == null) {
    RecurringTransactionService recurringTransaction=new RecurringTransactionService(recurringTransactionId,this);
    mCommonFunctions.mSplitTransactions=recurringTransaction.loadSplitTransactions();
  }
  AccountRepository accountRepository=new AccountRepository(this);
  mCommonFunctions.mToAccountName=accountRepository.loadName(mCommonFunctions.transactionEntity.getAccountToId());
  mCommonFunctions.loadPayeeName(mCommonFunctions.transactionEntity.getPayeeId());
  mCommonFunctions.loadCategoryName();
  return true;
}",0.9960722702278084
64764,"/** 
 * update data into database
 * @return true if update data successful
 */
private boolean saveData(){
  collectDataFromUI();
  if (!validateData())   return false;
  boolean isTransfer=mCommonFunctions.transactionEntity.getTransactionType().equals(TransactionTypes.Transfer);
  if (!isTransfer) {
    mCommonFunctions.resetTransfer();
  }
  if (!saveTransaction())   return false;
  if (mCommonFunctions.handleOneSplit()) {
    saveTransaction();
  }
  if (!mCommonFunctions.isSplitSelected()) {
    mCommonFunctions.removeAllSplitCategories();
  }
  if (!saveSplitCategories())   return false;
  return true;
}","/** 
 * update data into database
 * @return true if update data successful
 */
private boolean saveData(){
  collectDataFromUI();
  if (!validateData())   return false;
  boolean isTransfer=mCommonFunctions.transactionEntity.getTransactionType().equals(TransactionTypes.Transfer);
  if (!isTransfer) {
    mCommonFunctions.resetTransfer();
  }
  if (!saveTransaction())   return false;
  if (mCommonFunctions.convertOneSplitIntoRegularTransaction()) {
    saveTransaction();
  }
  if (!mCommonFunctions.isSplitSelected()) {
    mCommonFunctions.removeAllSplitCategories();
  }
  if (!saveSplitCategories())   return false;
  return true;
}",0.7064439140811456
64765,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_edit_checking_account_transaction);
  showStandardToolbarActions();
  ITransactionEntity model=AccountTransaction.create();
  mCommonFunctions=new EditTransactionCommonFunctions(this,model);
  if ((savedInstanceState != null)) {
    restoreInstanceState(savedInstanceState);
  }
  mCommonFunctions.findControls(this);
  if (getIntent() != null) {
    boolean handled=handleIntent(savedInstanceState);
    if (!handled) {
      finish();
      return;
    }
  }
  initializeInputControls();
  mCommonFunctions.onTransactionTypeChanged(mCommonFunctions.transactionEntity.getTransactionType());
  mCommonFunctions.refreshPayeeName();
  mCommonFunctions.displayCategoryName();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_edit_checking_account_transaction);
  showStandardToolbarActions();
  ITransactionEntity model=AccountTransaction.create();
  mCommonFunctions=new EditTransactionCommonFunctions(this,model);
  if ((savedInstanceState != null)) {
    restoreInstanceState(savedInstanceState);
  }
  mCommonFunctions.findControls(this);
  if (getIntent() != null) {
    boolean handled=handleIntent(savedInstanceState);
    if (!handled) {
      finish();
      return;
    }
  }
  initializeInputControls();
  mCommonFunctions.onTransactionTypeChanged(mCommonFunctions.transactionEntity.getTransactionType());
  mCommonFunctions.showPayeeName();
  mCommonFunctions.displayCategoryName();
}",0.993188854489164
64766,"/** 
 * Loads a recurring transaction data when entering a recurring transaction.
 * @param recurringTransactionId Id of the recurring transaction.
 * @return A boolean indicating whether the operation was successful.
 */
private boolean loadRecurringTransactionInternal(int recurringTransactionId){
  RecurringTransactionRepository repo=new RecurringTransactionRepository(this);
  RecurringTransaction recurringTx=repo.load(recurringTransactionId);
  if (recurringTx == null)   return false;
  mCommonFunctions.transactionEntity.setDate(recurringTx.getPaymentDate());
  mCommonFunctions.transactionEntity.setAccountId(recurringTx.getAccountId());
  mCommonFunctions.transactionEntity.setAccountToId(recurringTx.getToAccountId());
  String transCode=recurringTx.getTransactionCode();
  mCommonFunctions.transactionEntity.setTransactionType(TransactionTypes.valueOf(transCode));
  mCommonFunctions.transactionEntity.setStatus(recurringTx.getStatus());
  mCommonFunctions.transactionEntity.setAmount(recurringTx.getAmount());
  mCommonFunctions.transactionEntity.setAmountTo(recurringTx.getAmountTo());
  mCommonFunctions.transactionEntity.setPayeeId(recurringTx.getPayeeId());
  mCommonFunctions.transactionEntity.setCategoryId(recurringTx.getCategoryId());
  mCommonFunctions.transactionEntity.setSubcategoryId(recurringTx.getSubcategoryId());
  mCommonFunctions.transactionEntity.setTransactionNumber(recurringTx.getTransactionNumber());
  mCommonFunctions.transactionEntity.setNotes(recurringTx.getNotes());
  AccountRepository accountRepository=new AccountRepository(this);
  mCommonFunctions.mToAccountName=accountRepository.loadName(mCommonFunctions.transactionEntity.getAccountToId());
  mCommonFunctions.selectPayeeName(mCommonFunctions.transactionEntity.getPayeeId());
  mCommonFunctions.loadCategoryName();
  createSplitCategoriesFromRecurringTransaction();
  return true;
}","/** 
 * Loads a recurring transaction data when entering a recurring transaction.
 * @param recurringTransactionId Id of the recurring transaction.
 * @return A boolean indicating whether the operation was successful.
 */
private boolean loadRecurringTransactionInternal(int recurringTransactionId){
  RecurringTransactionRepository repo=new RecurringTransactionRepository(this);
  RecurringTransaction recurringTx=repo.load(recurringTransactionId);
  if (recurringTx == null)   return false;
  mCommonFunctions.transactionEntity.setDate(recurringTx.getPaymentDate());
  mCommonFunctions.transactionEntity.setAccountId(recurringTx.getAccountId());
  mCommonFunctions.transactionEntity.setAccountToId(recurringTx.getToAccountId());
  String transCode=recurringTx.getTransactionCode();
  mCommonFunctions.transactionEntity.setTransactionType(TransactionTypes.valueOf(transCode));
  mCommonFunctions.transactionEntity.setStatus(recurringTx.getStatus());
  mCommonFunctions.transactionEntity.setAmount(recurringTx.getAmount());
  mCommonFunctions.transactionEntity.setAmountTo(recurringTx.getAmountTo());
  mCommonFunctions.transactionEntity.setPayeeId(recurringTx.getPayeeId());
  mCommonFunctions.transactionEntity.setCategoryId(recurringTx.getCategoryId());
  mCommonFunctions.transactionEntity.setSubcategoryId(recurringTx.getSubcategoryId());
  mCommonFunctions.transactionEntity.setTransactionNumber(recurringTx.getTransactionNumber());
  mCommonFunctions.transactionEntity.setNotes(recurringTx.getNotes());
  AccountRepository accountRepository=new AccountRepository(this);
  mCommonFunctions.mToAccountName=accountRepository.loadName(mCommonFunctions.transactionEntity.getAccountToId());
  mCommonFunctions.loadPayeeName(mCommonFunctions.transactionEntity.getPayeeId());
  mCommonFunctions.loadCategoryName();
  createSplitCategoriesFromRecurringTransaction();
  return true;
}",0.997874601487779
64767,"/** 
 * Get the parameters from the intent (parameters sent from the caller). Also used for Tasker integration, for example.
 * @param savedInstanceState parameters
 */
private boolean handleIntent(Bundle savedInstanceState){
  Intent intent=getIntent();
  mIntentAction=intent.getAction();
  if (savedInstanceState == null) {
    int accountId=intent.getIntExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,Constants.NOT_SET);
    if (accountId != Constants.NOT_SET) {
      mCommonFunctions.transactionEntity.setAccountId(accountId);
    }
    if (mIntentAction != null) {
      int transactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_TRANS_ID,Constants.NOT_SET);
switch (mIntentAction) {
case Intent.ACTION_EDIT:
        loadCheckingAccount(transactionId);
      break;
case Intent.ACTION_PASTE:
    loadCheckingAccount(transactionId);
  duplicateTransaction();
break;
case Intent.ACTION_INSERT:
mRecurringTransactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_BDID_ID,Constants.NOT_SET);
if (mRecurringTransactionId > Constants.NOT_SET) {
loadRecurringTransaction(mRecurringTransactionId);
}
}
}
}
if (mIntentAction.equals(Intent.ACTION_INSERT)) {
if (mCommonFunctions.transactionEntity.getStatus() == null) {
String defaultStatus=PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_STATUS),""String_Node_Str"");
mCommonFunctions.transactionEntity.setStatus(defaultStatus);
}
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
AsyncTask<Void,Void,Boolean> task=new AsyncTask<Void,Void,Boolean>(){
@Override protected Boolean doInBackground(Void... params){
try {
Core core=new Core(getApplicationContext());
Payee payee=core.getLastPayeeUsed();
if (payee != null && mCommonFunctions.transactionEntity.getPayeeId() == Constants.NOT_SET) {
mCommonFunctions.transactionEntity.setPayeeId(payee.getId());
mCommonFunctions.payeeName=payee.getName();
mCommonFunctions.transactionEntity.setCategoryId(payee.getCategoryId());
mCommonFunctions.transactionEntity.setSubcategoryId(payee.getSubcategoryId());
mCommonFunctions.loadCategoryName();
return Boolean.TRUE;
}
}
 catch (Exception e) {
ExceptionHandler handler=new ExceptionHandler(CheckingTransactionEditActivity.this,CheckingTransactionEditActivity.this);
handler.handle(e,""String_Node_Str"");
}
return Boolean.FALSE;
}
@Override protected void onPostExecute(Boolean result){
super.onPostExecute(result);
if (result) {
try {
mCommonFunctions.refreshPayeeName();
mCommonFunctions.displayCategoryName();
}
 catch (Exception e) {
Log.e(EditTransactionActivityConstants.LOGCAT,e.getMessage());
}
}
}
}
;
task.execute();
}
externalIntegration(intent);
Integer account=mCommonFunctions.transactionEntity.getAccountId();
if (account == null || account == Constants.NOT_SET) {
AppSettings settings=new AppSettings(this);
Integer defaultAccountId=settings.getGeneralSettings().getDefaultAccountId();
if (defaultAccountId == null) {
new ExceptionHandler(this).showMessage(getString(R.string.default_account_not_set));
return false;
}
 else {
mCommonFunctions.transactionEntity.setAccountId(defaultAccountId);
}
}
}
if (getSupportActionBar() != null) {
getSupportActionBar().setTitle(Intent.ACTION_INSERT.equals(mIntentAction) ? R.string.new_transaction : R.string.edit_transaction);
}
return true;
}","/** 
 * Get the parameters from the intent (parameters sent from the caller). Also used for Tasker integration, for example.
 * @param savedInstanceState parameters
 */
private boolean handleIntent(Bundle savedInstanceState){
  Intent intent=getIntent();
  mIntentAction=intent.getAction();
  if (savedInstanceState == null) {
    int accountId=intent.getIntExtra(EditTransactionActivityConstants.KEY_ACCOUNT_ID,Constants.NOT_SET);
    if (accountId != Constants.NOT_SET) {
      mCommonFunctions.transactionEntity.setAccountId(accountId);
    }
    if (mIntentAction != null) {
      int transactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_TRANS_ID,Constants.NOT_SET);
switch (mIntentAction) {
case Intent.ACTION_EDIT:
        loadCheckingAccount(transactionId);
      break;
case Intent.ACTION_PASTE:
    loadCheckingAccount(transactionId);
  duplicateTransaction();
break;
case Intent.ACTION_INSERT:
mRecurringTransactionId=intent.getIntExtra(EditTransactionActivityConstants.KEY_BDID_ID,Constants.NOT_SET);
if (mRecurringTransactionId > Constants.NOT_SET) {
loadRecurringTransaction(mRecurringTransactionId);
}
}
}
}
if (mIntentAction.equals(Intent.ACTION_INSERT)) {
if (mCommonFunctions.transactionEntity.getStatus() == null) {
String defaultStatus=PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_STATUS),""String_Node_Str"");
mCommonFunctions.transactionEntity.setStatus(defaultStatus);
}
if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString(getString(PreferenceConstants.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
AsyncTask<Void,Void,Boolean> task=new AsyncTask<Void,Void,Boolean>(){
@Override protected Boolean doInBackground(Void... params){
try {
Core core=new Core(getApplicationContext());
Payee payee=core.getLastPayeeUsed();
if (payee != null && mCommonFunctions.transactionEntity.getPayeeId() == Constants.NOT_SET) {
mCommonFunctions.transactionEntity.setPayeeId(payee.getId());
mCommonFunctions.payeeName=payee.getName();
mCommonFunctions.transactionEntity.setCategoryId(payee.getCategoryId());
mCommonFunctions.transactionEntity.setSubcategoryId(payee.getSubcategoryId());
mCommonFunctions.loadCategoryName();
return Boolean.TRUE;
}
}
 catch (Exception e) {
ExceptionHandler handler=new ExceptionHandler(CheckingTransactionEditActivity.this,CheckingTransactionEditActivity.this);
handler.handle(e,""String_Node_Str"");
}
return Boolean.FALSE;
}
@Override protected void onPostExecute(Boolean result){
super.onPostExecute(result);
if (result) {
try {
mCommonFunctions.showPayeeName();
mCommonFunctions.displayCategoryName();
}
 catch (Exception e) {
Log.e(EditTransactionActivityConstants.LOGCAT,e.getMessage());
}
}
}
}
;
task.execute();
}
externalIntegration(intent);
Integer account=mCommonFunctions.transactionEntity.getAccountId();
if (account == null || account == Constants.NOT_SET) {
AppSettings settings=new AppSettings(this);
Integer defaultAccountId=settings.getGeneralSettings().getDefaultAccountId();
if (defaultAccountId == null) {
new ExceptionHandler(this).showMessage(getString(R.string.default_account_not_set));
return false;
}
 else {
mCommonFunctions.transactionEntity.setAccountId(defaultAccountId);
}
}
}
if (getSupportActionBar() != null) {
getSupportActionBar().setTitle(Intent.ACTION_INSERT.equals(mIntentAction) ? R.string.new_transaction : R.string.edit_transaction);
}
return true;
}",0.998993240327916
64768,"private boolean loadCheckingAccount(int transId){
  AccountTransactionRepository repo=new AccountTransactionRepository(this);
  AccountTransaction tx=repo.load(transId);
  if (tx == null)   return false;
  mCommonFunctions.transactionEntity=tx;
  if (mCommonFunctions.mSplitTransactions == null) {
    SplitCategoriesRepository splitRepo=new SplitCategoriesRepository(this);
    mCommonFunctions.mSplitTransactions=splitRepo.loadSplitCategoriesFor(transId);
  }
  AccountRepository accountRepository=new AccountRepository(this);
  mCommonFunctions.mToAccountName=accountRepository.loadName(mCommonFunctions.transactionEntity.getAccountToId());
  mCommonFunctions.selectPayeeName(mCommonFunctions.transactionEntity.getPayeeId());
  mCommonFunctions.loadCategoryName();
  return true;
}","private boolean loadCheckingAccount(int transId){
  AccountTransactionRepository repo=new AccountTransactionRepository(this);
  AccountTransaction tx=repo.load(transId);
  if (tx == null)   return false;
  mCommonFunctions.transactionEntity=tx;
  if (mCommonFunctions.mSplitTransactions == null) {
    SplitCategoriesRepository splitRepo=new SplitCategoriesRepository(this);
    mCommonFunctions.mSplitTransactions=splitRepo.loadSplitCategoriesFor(transId);
  }
  AccountRepository accountRepository=new AccountRepository(this);
  mCommonFunctions.mToAccountName=accountRepository.loadName(mCommonFunctions.transactionEntity.getAccountToId());
  mCommonFunctions.loadPayeeName(mCommonFunctions.transactionEntity.getPayeeId());
  mCommonFunctions.loadCategoryName();
  return true;
}",0.9936143039591316
64769,"/** 
 * Save data to the database.
 * @return true if update data successful
 */
private boolean saveData(){
  if (!mCommonFunctions.validateData())   return false;
  boolean isTransfer=mCommonFunctions.transactionEntity.getTransactionType().equals(TransactionTypes.Transfer);
  if (!isTransfer) {
    mCommonFunctions.resetTransfer();
  }
  if (!saveTransaction())   return false;
  if (mCommonFunctions.handleOneSplit()) {
    saveTransaction();
  }
  if (!mCommonFunctions.isSplitSelected()) {
    mCommonFunctions.removeAllSplitCategories();
  }
  if (!saveSplitCategories())   return false;
  saveDefaultPayee(isTransfer);
  if (mRecurringTransactionId != Constants.NOT_SET) {
    RecurringTransactionService service=new RecurringTransactionService(mRecurringTransactionId,this);
    service.moveNextOccurrence();
  }
  return true;
}","/** 
 * Save data to the database.
 * @return true if update data successful
 */
private boolean saveData(){
  if (!mCommonFunctions.validateData())   return false;
  boolean isTransfer=mCommonFunctions.transactionEntity.getTransactionType().equals(TransactionTypes.Transfer);
  if (!isTransfer) {
    mCommonFunctions.resetTransfer();
  }
  if (!saveTransaction())   return false;
  if (mCommonFunctions.convertOneSplitIntoRegularTransaction()) {
    saveTransaction();
  }
  if (!mCommonFunctions.isSplitSelected()) {
    mCommonFunctions.removeAllSplitCategories();
  }
  if (!saveSplitCategories())   return false;
  saveDefaultPayee(isTransfer);
  if (mRecurringTransactionId != Constants.NOT_SET) {
    RecurringTransactionService service=new RecurringTransactionService(mRecurringTransactionId,this);
    service.moveNextOccurrence();
  }
  return true;
}",0.9794238683127572
64770,"@Override protected void onPostExecute(Boolean result){
  super.onPostExecute(result);
  if (result) {
    try {
      mCommonFunctions.refreshPayeeName();
      mCommonFunctions.displayCategoryName();
    }
 catch (    Exception e) {
      Log.e(EditTransactionActivityConstants.LOGCAT,e.getMessage());
    }
  }
}","@Override protected void onPostExecute(Boolean result){
  super.onPostExecute(result);
  if (result) {
    try {
      mCommonFunctions.showPayeeName();
      mCommonFunctions.displayCategoryName();
    }
 catch (    Exception e) {
      Log.e(EditTransactionActivityConstants.LOGCAT,e.getMessage());
    }
  }
}",0.988835725677831
64771,"/** 
 * Fast single pass parser, should correctly process most of positive/negative values fitting into <code>long</code>
 * @param str Floating point number to parse
 * @return Money object or null (if can't parse)
 * @throws java.lang.IllegalArgumentException If a value has more than one decimal digit
 */
private static Money parseFast(final CharSequence str){
  if (str.length() >= MAX_LONG_LENGTH)   return null;
  long res=0;
  int start=0;
  long sign=1;
  int precision=0;
  if (str.charAt(0) == '-') {
    sign=-1;
    start=1;
  }
 else   if (str.charAt(0) == '+') {
    sign=1;
    start=1;
  }
  for (int i=start; i < str.length(); ++i) {
    final char c=str.charAt(i);
    if (c == '.') {
      if (precision > 0)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      precision=str.length() - i - 1;
    }
 else     if (c >= '0' && c <= '9')     res=res * 10 + (c - '0');
 else     return null;
  }
  return new MoneyLong(res * sign,precision).normalize();
}","/** 
 * Fast single pass parser, should correctly process most of positive/negative values fitting into <code>long</code>
 * @param str Floating point number to parse
 * @return Money object or null (if can't parse)
 * @throws java.lang.IllegalArgumentException If a value has more than one decimal digit
 */
private static Money parseFast(final CharSequence str){
  if (str.length() >= MAX_LONG_LENGTH)   return null;
  long res=0;
  int start=0;
  long sign=1;
  int precision=0;
  if (str.charAt(0) == '-') {
    sign=-1;
    start=1;
  }
 else   if (str.charAt(0) == '+') {
    sign=1;
    start=1;
  }
  for (int i=start; i < str.length(); ++i) {
    final char c=str.charAt(i);
    if (c == '.') {
      if (precision > 0)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      precision=str.length() - i - 1;
    }
 else     if (c >= '0' && c <= '9')     res=res * 10 + (c - '0');
 else     return null;
  }
  if (precision >= 0 && precision <= MAX_ALLOWED_PRECISION)   return new MoneyLong(res * sign,precision).normalize();
 else   return new MoneyBigDecimal(str.toString());
}",0.9465648854961832
64772,"/** 
 * Divide the current object by the given <code>long</code> divider.
 * @param divider   Divider
 * @param precision Maximal precision to keep. We will round the next digit.
 * @return A new Money object normalized to the efficient representation if possible
 */
public Money divide(final double divider,final int precision){
  final double unscaledRes=m_units / divider;
  final long destRes;
  if (m_precision < precision) {
    destRes=Math.round(unscaledRes * MoneyFactory.MULTIPLIERS[precision - m_precision]);
  }
 else   if (m_precision == precision) {
    destRes=Math.round(unscaledRes);
  }
 else {
    destRes=Math.round(unscaledRes * MoneyFactory.MULTIPLIERS_NEG[m_precision - precision]);
  }
  return new MoneyLong(destRes,precision).normalize();
}","/** 
 * Divide the current object by the given <code>long</code> divider.
 * @param divider   Divider
 * @param precision Maximal precision to keep. We will round the next digit.
 * @return A new Money object normalized to the efficient representation if possible
 */
public Money divide(final double divider,final int precision){
  if (precision > MoneyFactory.MAX_ALLOWED_PRECISION)   return new MoneyBigDecimal(toBigDecimal()).divide(divider,precision);
  final double unscaledRes=m_units / divider;
  final long destRes;
  if (m_precision < precision) {
    destRes=Math.round(unscaledRes * MoneyFactory.MULTIPLIERS[precision - m_precision]);
  }
 else   if (m_precision == precision) {
    destRes=Math.round(unscaledRes);
  }
 else {
    destRes=Math.round(unscaledRes * MoneyFactory.MULTIPLIERS_NEG[m_precision - precision]);
  }
  return new MoneyLong(destRes,precision).normalize();
}",0.9240963855421688
64773,"@Override protected void onStart(){
  super.onStart();
  if (!isAuthenticated) {
    Passcode passcode=new Passcode(this);
    if (passcode.hasPasscode() && !isInAuthentication) {
      Intent intent=new Intent(this,PasscodeActivity.class);
      intent.setAction(PasscodeActivity.INTENT_REQUEST_PASSWORD);
      intent.putExtra(PasscodeActivity.INTENT_MESSAGE_TEXT,getString(R.string.enter_your_passcode));
      startActivityForResult(intent,REQUEST_PASSCODE);
      isInAuthentication=true;
    }
  }
}","@Override protected void onStart(){
  super.onStart();
  if (!isAuthenticated) {
    Passcode passcode=new Passcode(getApplicationContext());
    if (passcode.hasPasscode() && !isInAuthentication) {
      Intent intent=new Intent(this,PasscodeActivity.class);
      intent.setAction(PasscodeActivity.INTENT_REQUEST_PASSWORD);
      intent.putExtra(PasscodeActivity.INTENT_MESSAGE_TEXT,getString(R.string.enter_your_passcode));
      startActivityForResult(intent,REQUEST_PASSCODE);
      isInAuthentication=true;
    }
  }
}",0.9737609329446064
64774,"@Override public void onRemoveItem(ISplitTransactionsDataset object){
  if (mSplitDeleted == null) {
    mSplitDeleted=new ArrayList<>();
  }
  if (object.getSplitTransId() != -1)   mSplitDeleted.add(object);
}","@Override public void onRemoveItem(ISplitTransactionsDataset object){
  if (mSplitDeleted == null) {
    mSplitDeleted=new ArrayList<>();
  }
  if (object.getSplitTransId() != -1) {
    mSplitDeleted.add(object);
  }
}",0.9813084112149532
64775,"@Override public boolean onActionDoneClick(){
  ArrayList<ISplitTransactionsDataset> allSplitTransactions=getAllTableSplitTransaction();
  for (int i=0; i < allSplitTransactions.size(); i++) {
    ISplitTransactionsDataset splitTransactions=allSplitTransactions.get(i);
    if (splitTransactions.getCategId() == -1 && splitTransactions.getCategId() == -1) {
      Core.alertDialog(SplitTransactionsActivity.this,R.string.error_category_not_selected).show();
      return false;
    }
  }
  Intent result=new Intent();
  result.putParcelableArrayListExtra(INTENT_RESULT_SPLIT_TRANSACTION,allSplitTransactions);
  result.putParcelableArrayListExtra(INTENT_RESULT_SPLIT_TRANSACTION_DELETED,mSplitDeleted);
  setResult(RESULT_OK,result);
  finish();
  return true;
}","@Override public boolean onActionDoneClick(){
  ArrayList<ISplitTransactionsDataset> allSplitTransactions=getAllSplitCategories();
  for (int i=0; i < allSplitTransactions.size(); i++) {
    ISplitTransactionsDataset splitTransactions=allSplitTransactions.get(i);
    if (splitTransactions.getCategId() == -1 && splitTransactions.getSubCategId() == -1) {
      Core.alertDialog(SplitTransactionsActivity.this,R.string.error_category_not_selected).show();
      return false;
    }
  }
  Intent result=new Intent();
  result.putParcelableArrayListExtra(INTENT_RESULT_SPLIT_TRANSACTION,allSplitTransactions);
  result.putParcelableArrayListExtra(INTENT_RESULT_SPLIT_TRANSACTION_DELETED,mSplitDeleted);
  setResult(RESULT_OK,result);
  finish();
  return true;
}",0.9743589743589745
64776,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  Core core=new Core(getActivity().getApplicationContext());
  BaseFragmentActivity activity=(BaseFragmentActivity)getActivity();
  if (activity != null)   activity.getSupportActionBar().setSubtitle(null);
  if (!(core.isTablet() || Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH)) {
    activity.getSupportActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM,ActionBar.DISPLAY_HOME_AS_UP | ActionBar.DISPLAY_SHOW_HOME | ActionBar.DISPLAY_SHOW_TITLE| ActionBar.DISPLAY_SHOW_CUSTOM);
    LayoutInflater inflater=(LayoutInflater)getActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View actionBarButtons=inflater.inflate(R.layout.actionbar_button_cancel_done,new LinearLayout(getActivity()),false);
    View cancelActionView=actionBarButtons.findViewById(R.id.action_cancel);
    cancelActionView.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        onDoneClick();
      }
    }
);
    View doneActionView=actionBarButtons.findViewById(R.id.action_done);
    ImageView doneImageView=(ImageView)doneActionView.findViewById(R.id.image_done);
    doneImageView.setImageDrawable(getActivity().getResources().getDrawable(core.resolveIdAttribute(R.attr.ic_action_search)));
    TextView doneTextView=(TextView)doneActionView.findViewById(R.id.text_done);
    doneTextView.setText(R.string.search);
    doneActionView.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        onSearchClick();
      }
    }
);
    activity.getSupportActionBar().setCustomView(actionBarButtons);
  }
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  Core core=new Core(getActivity());
  BaseFragmentActivity activity=(BaseFragmentActivity)getActivity();
  if (activity != null)   activity.getSupportActionBar().setSubtitle(null);
  if (!(core.isTablet() || Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH)) {
    activity.getSupportActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM,ActionBar.DISPLAY_HOME_AS_UP | ActionBar.DISPLAY_SHOW_HOME | ActionBar.DISPLAY_SHOW_TITLE| ActionBar.DISPLAY_SHOW_CUSTOM);
    LayoutInflater inflater=(LayoutInflater)getActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View actionBarButtons=inflater.inflate(R.layout.actionbar_button_cancel_done,new LinearLayout(getActivity()),false);
    View cancelActionView=actionBarButtons.findViewById(R.id.action_cancel);
    cancelActionView.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        onDoneClick();
      }
    }
);
    View doneActionView=actionBarButtons.findViewById(R.id.action_done);
    ImageView doneImageView=(ImageView)doneActionView.findViewById(R.id.image_done);
    doneImageView.setImageDrawable(getActivity().getResources().getDrawable(core.resolveIdAttribute(R.attr.ic_action_search)));
    TextView doneTextView=(TextView)doneActionView.findViewById(R.id.text_done);
    doneTextView.setText(R.string.search);
    doneActionView.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        onSearchClick();
      }
    }
);
    activity.getSupportActionBar().setCustomView(actionBarButtons);
  }
}",0.9929701230228472
64777,"@Override public void onCreateOptionsMenu(Menu menu,MenuInflater inflater){
  super.onCreateOptionsMenu(menu,inflater);
  Core core=new Core(getActivity().getApplicationContext());
  MenuItem itemOption=menu.findItem(R.id.menu_option1);
  if (itemOption != null) {
    itemOption.setVisible(true);
    itemOption.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
    itemOption.setIcon(getActivity().getResources().getDrawable(core.resolveIdAttribute(R.attr.ic_action_list)));
    itemOption.setTitle(R.string.categories);
    SubMenu subMenu=itemOption.getSubMenu();
    if (subMenu != null) {
      MoneyManagerOpenHelper helper=MoneyManagerOpenHelper.getInstance(getActivity().getApplicationContext());
      SQLiteDatabase database=helper.getReadableDatabase();
      TableCategory category=new TableCategory();
      Cursor cursor=database.query(category.getSource(),new String[]{TableCategory.CATEGID,TableCategory.CATEGNAME},null,null,null,null,TableCategory.CATEGNAME);
      if (cursor != null && cursor.moveToFirst()) {
        int order=0;
        while (!cursor.isAfterLast()) {
          subMenu.add(GROUP_ID_CATEGORY,-cursor.getInt(cursor.getColumnIndex(TableCategory.CATEGID)),order++,cursor.getString(cursor.getColumnIndex(TableCategory.CATEGNAME)));
          cursor.moveToNext();
        }
      }
    }
  }
  MenuItem itemChart=menu.findItem(R.id.menu_chart);
  if (itemChart != null) {
    itemChart.setVisible(!(((CategoriesReportActivity)getActivity()).mIsDualPanel));
    itemChart.setIcon(core.resolveIdAttribute(R.attr.ic_action_pie_chart));
  }
}","@Override public void onCreateOptionsMenu(Menu menu,MenuInflater inflater){
  super.onCreateOptionsMenu(menu,inflater);
  Core core=new Core(getActivity());
  MenuItem itemOption=menu.findItem(R.id.menu_option1);
  if (itemOption != null) {
    itemOption.setVisible(true);
    itemOption.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
    itemOption.setIcon(getActivity().getResources().getDrawable(core.resolveIdAttribute(R.attr.ic_action_list)));
    itemOption.setTitle(R.string.categories);
    SubMenu subMenu=itemOption.getSubMenu();
    if (subMenu != null) {
      MoneyManagerOpenHelper helper=MoneyManagerOpenHelper.getInstance(getActivity().getApplicationContext());
      SQLiteDatabase database=helper.getReadableDatabase();
      TableCategory category=new TableCategory();
      Cursor cursor=database.query(category.getSource(),new String[]{TableCategory.CATEGID,TableCategory.CATEGNAME},null,null,null,null,TableCategory.CATEGNAME);
      if (cursor != null && cursor.moveToFirst()) {
        int order=0;
        while (!cursor.isAfterLast()) {
          subMenu.add(GROUP_ID_CATEGORY,-cursor.getInt(cursor.getColumnIndex(TableCategory.CATEGID)),order++,cursor.getString(cursor.getColumnIndex(TableCategory.CATEGNAME)));
          cursor.moveToNext();
        }
      }
    }
  }
  MenuItem itemChart=menu.findItem(R.id.menu_chart);
  if (itemChart != null) {
    itemChart.setVisible(!(((CategoriesReportActivity)getActivity()).mIsDualPanel));
    itemChart.setIcon(core.resolveIdAttribute(R.attr.ic_action_pie_chart));
  }
}",0.9923076923076924
64778,"/** 
 * update View of footer with income, expenses and difference
 * @param footer
 * @param income
 * @param expenses
 */
private void updateListViewFooter(View footer,double income,double expenses){
  if (footer == null) {
    return;
  }
  TextView txtIncome=(TextView)footer.findViewById(R.id.textViewIncome);
  TextView txtExpenses=(TextView)footer.findViewById(R.id.textViewExpenses);
  TextView txtDifference=(TextView)footer.findViewById(R.id.textViewDifference);
  txtIncome.setText(currencyUtils.getCurrencyFormatted(currencyUtils.getBaseCurrencyId(),income));
  txtIncome.setTypeface(null,Typeface.BOLD_ITALIC);
  txtExpenses.setText(currencyUtils.getCurrencyFormatted(currencyUtils.getBaseCurrencyId(),Math.abs(expenses)));
  txtExpenses.setTypeface(null,Typeface.BOLD_ITALIC);
  txtDifference.setText(currencyUtils.getCurrencyFormatted(currencyUtils.getBaseCurrencyId(),income - Math.abs(expenses)));
  txtDifference.setTypeface(null,Typeface.BOLD_ITALIC);
  Core core=new Core(getActivity().getApplicationContext());
  if (income - Math.abs(expenses) < 0) {
    txtDifference.setTextColor(getResources().getColor(core.resolveIdAttribute(R.attr.holo_red_color_theme)));
  }
 else {
    txtDifference.setTextColor(getResources().getColor(core.resolveIdAttribute(R.attr.holo_green_color_theme)));
  }
}","/** 
 * update View of footer with income, expenses and difference
 * @param footer
 * @param income
 * @param expenses
 */
private void updateListViewFooter(View footer,double income,double expenses){
  if (footer == null) {
    return;
  }
  TextView txtIncome=(TextView)footer.findViewById(R.id.textViewIncome);
  TextView txtExpenses=(TextView)footer.findViewById(R.id.textViewExpenses);
  TextView txtDifference=(TextView)footer.findViewById(R.id.textViewDifference);
  txtIncome.setText(currencyUtils.getCurrencyFormatted(currencyUtils.getBaseCurrencyId(),income));
  txtIncome.setTypeface(null,Typeface.BOLD_ITALIC);
  txtExpenses.setText(currencyUtils.getCurrencyFormatted(currencyUtils.getBaseCurrencyId(),Math.abs(expenses)));
  txtExpenses.setTypeface(null,Typeface.BOLD_ITALIC);
  txtDifference.setText(currencyUtils.getCurrencyFormatted(currencyUtils.getBaseCurrencyId(),income - Math.abs(expenses)));
  txtDifference.setTypeface(null,Typeface.BOLD_ITALIC);
  Core core=new Core(getActivity());
  if (income - Math.abs(expenses) < 0) {
    txtDifference.setTextColor(getResources().getColor(core.resolveIdAttribute(R.attr.holo_red_color_theme)));
  }
 else {
    txtDifference.setTextColor(getResources().getColor(core.resolveIdAttribute(R.attr.holo_green_color_theme)));
  }
}",0.9907834101382488
64779,"public void startServiceSyncDropbox(){
  if (mDropboxHelper != null && mDropboxHelper.isLinked()) {
    Intent service=new Intent(getApplicationContext(),DropboxServiceIntent.class);
    service.setAction(DropboxServiceIntent.INTENT_ACTION_SYNC);
    service.putExtra(DropboxServiceIntent.INTENT_EXTRA_LOCAL_FILE,MoneyManagerApplication.getDatabasePath(getApplicationContext()));
    service.putExtra(DropboxServiceIntent.INTENT_EXTRA_REMOTE_FILE,mDropboxHelper.getLinkedRemoteFile());
    final ProgressDialog progressDialog=new ProgressDialog(getApplicationContext());
    progressDialog.setCancelable(false);
    progressDialog.setMessage(getString(R.string.dropbox_syncProgress));
    progressDialog.setIndeterminate(true);
    progressDialog.show();
    Messenger messenger=new Messenger(new Handler(){
      @Override public void handleMessage(      Message msg){
        if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_NOT_CHANGE) {
          if (progressDialog != null && progressDialog.isShowing())           progressDialog.hide();
          runOnUiThread(new Runnable(){
            @Override public void run(){
              Toast.makeText(MainActivity.this,R.string.dropbox_database_is_synchronized,Toast.LENGTH_LONG).show();
            }
          }
);
        }
 else         if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_START_DOWNLOAD) {
          runOnUiThread(new Runnable(){
            @Override public void run(){
              Toast.makeText(MainActivity.this,R.string.dropbox_download_is_starting,Toast.LENGTH_LONG).show();
            }
          }
);
        }
 else         if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_DOWNLOAD) {
          if (progressDialog != null && progressDialog.isShowing())           progressDialog.hide();
          reloadAllFragment();
        }
 else         if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_START_UPLOAD) {
          runOnUiThread(new Runnable(){
            @Override public void run(){
              Toast.makeText(MainActivity.this,R.string.dropbox_upload_is_starting,Toast.LENGTH_LONG).show();
            }
          }
);
        }
 else         if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_UPLOAD) {
          if (progressDialog != null && progressDialog.isShowing())           progressDialog.hide();
          runOnUiThread(new Runnable(){
            @Override public void run(){
              Toast.makeText(MainActivity.this,R.string.upload_file_to_dropbox_complete,Toast.LENGTH_LONG).show();
            }
          }
);
        }
      }
    }
);
    service.putExtra(DropboxServiceIntent.INTENT_EXTRA_MESSENGER,messenger);
    this.startService(service);
  }
}","public void startServiceSyncDropbox(){
  if (mDropboxHelper != null && mDropboxHelper.isLinked()) {
    Intent service=new Intent(getApplicationContext(),DropboxServiceIntent.class);
    service.setAction(DropboxServiceIntent.INTENT_ACTION_SYNC);
    service.putExtra(DropboxServiceIntent.INTENT_EXTRA_LOCAL_FILE,MoneyManagerApplication.getDatabasePath(getApplicationContext()));
    service.putExtra(DropboxServiceIntent.INTENT_EXTRA_REMOTE_FILE,mDropboxHelper.getLinkedRemoteFile());
    final ProgressDialog progressDialog=new ProgressDialog(this);
    progressDialog.setCancelable(false);
    progressDialog.setMessage(getString(R.string.dropbox_syncProgress));
    progressDialog.setIndeterminate(true);
    progressDialog.show();
    Messenger messenger=new Messenger(new Handler(){
      @Override public void handleMessage(      Message msg){
        if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_NOT_CHANGE) {
          if (progressDialog != null && progressDialog.isShowing())           progressDialog.hide();
          runOnUiThread(new Runnable(){
            @Override public void run(){
              Toast.makeText(MainActivity.this,R.string.dropbox_database_is_synchronized,Toast.LENGTH_LONG).show();
            }
          }
);
        }
 else         if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_START_DOWNLOAD) {
          runOnUiThread(new Runnable(){
            @Override public void run(){
              Toast.makeText(MainActivity.this,R.string.dropbox_download_is_starting,Toast.LENGTH_LONG).show();
            }
          }
);
        }
 else         if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_DOWNLOAD) {
          if (progressDialog != null && progressDialog.isShowing())           progressDialog.hide();
          reloadAllFragment();
        }
 else         if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_START_UPLOAD) {
          runOnUiThread(new Runnable(){
            @Override public void run(){
              Toast.makeText(MainActivity.this,R.string.dropbox_upload_is_starting,Toast.LENGTH_LONG).show();
            }
          }
);
        }
 else         if (msg.what == DropboxServiceIntent.INTENT_EXTRA_MESSENGER_UPLOAD) {
          if (progressDialog != null && progressDialog.isShowing())           progressDialog.hide();
          runOnUiThread(new Runnable(){
            @Override public void run(){
              Toast.makeText(MainActivity.this,R.string.upload_file_to_dropbox_complete,Toast.LENGTH_LONG).show();
            }
          }
);
        }
      }
    }
);
    service.putExtra(DropboxServiceIntent.INTENT_EXTRA_MESSENGER,messenger);
    this.startService(service);
  }
}",0.995004625346901
64780,"@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
  if (getSearResultFragmentLoaderCallbacks() != null) {
    getSearResultFragmentLoaderCallbacks().onCallbackLoaderFinished(loader,data);
  }
switch (loader.getId()) {
case ID_LOADER_ALL_DATA_DETAIL:
    ((CursorAdapter)getListAdapter()).swapCursor(data);
  if (isResumed()) {
    setListShown(true);
  }
 else {
    setListShownNoAnimation(true);
  }
}
}","@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
  if (getSearResultFragmentLoaderCallbacks() != null) {
    getSearResultFragmentLoaderCallbacks().onCallbackLoaderFinished(loader,data);
  }
switch (loader.getId()) {
case ID_LOADER_ALL_DATA_DETAIL:
    AllDataAdapter adapter=(AllDataAdapter)getListAdapter();
  if (isShownBalance()) {
    adapter.setDatabase(MoneyManagerOpenHelper.getInstance(getActivity().getApplicationContext()).getReadableDatabase());
  }
adapter.swapCursor(data);
if (isResumed()) {
setListShown(true);
}
 else {
setListShownNoAnimation(true);
}
}
}",0.6614634146341464
64781,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setEmptyText(getString(R.string.no_data));
  setListShown(false);
  setHasOptionsMenu(Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB);
  AllDataAdapter adapter=new AllDataAdapter(getActivity(),null,TypeCursor.ALLDATA);
  adapter.setAccountId(mAccountId);
  adapter.setShowAccountName(isShownHeader());
  adapter.setShowBalanceAmount(isShownBalance());
  if (isShownBalance()) {
    adapter.setDatabase(MoneyManagerOpenHelper.getInstance(getActivity().getApplicationContext()).getReadableDatabase());
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    mMultiChoiceModeListener=new AllDataMultiChoiceModeListener();
    getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
    getListView().setMultiChoiceModeListener(mMultiChoiceModeListener);
  }
  getListView().setOnItemClickListener(new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      if (getListAdapter() != null && getListAdapter() instanceof AllDataAdapter) {
        Cursor cursor=((AllDataAdapter)getListAdapter()).getCursor();
        if (cursor.moveToPosition(position - (mListHeader != null ? 1 : 0))) {
          startCheckingAccountActivity(cursor.getInt(cursor.getColumnIndex(QueryAllData.ID)));
        }
      }
    }
  }
);
  if (mListHeader != null)   getListView().addHeaderView(mListHeader);
  setListAdapter(adapter);
  registerForContextMenu(getListView());
  setListShown(false);
  setFloatingActionButtonVisbile(true);
  setFloatingActionButtonAttachListView(true);
  if (isAutoStarLoader()) {
    startLoaderData();
  }
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setEmptyText(getString(R.string.no_data));
  setListShown(false);
  setHasOptionsMenu(Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB);
  AllDataAdapter adapter=new AllDataAdapter(getActivity(),null,TypeCursor.ALLDATA);
  adapter.setAccountId(mAccountId);
  adapter.setShowAccountName(isShownHeader());
  adapter.setShowBalanceAmount(isShownBalance());
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    mMultiChoiceModeListener=new AllDataMultiChoiceModeListener();
    getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
    getListView().setMultiChoiceModeListener(mMultiChoiceModeListener);
  }
  getListView().setOnItemClickListener(new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      if (getListAdapter() != null && getListAdapter() instanceof AllDataAdapter) {
        Cursor cursor=((AllDataAdapter)getListAdapter()).getCursor();
        if (cursor.moveToPosition(position - (mListHeader != null ? 1 : 0))) {
          startCheckingAccountActivity(cursor.getInt(cursor.getColumnIndex(QueryAllData.ID)));
        }
      }
    }
  }
);
  if (mListHeader != null)   getListView().addHeaderView(mListHeader);
  setListAdapter(adapter);
  registerForContextMenu(getListView());
  setListShown(false);
  setFloatingActionButtonVisbile(true);
  setFloatingActionButtonAttachListView(true);
  if (isAutoStarLoader()) {
    startLoaderData();
  }
}",0.9544364508393284
64782,"@Override public void onItemCheckedStateChanged(ActionMode mode,int position,long id,boolean checked){
  if (getListAdapter() != null && getListAdapter() instanceof AllDataAdapter) {
    AllDataAdapter adapter=(AllDataAdapter)getListAdapter();
    adapter.setPositionChecked(position,checked);
    adapter.notifyDataSetChanged();
  }
}","@Override public void onItemCheckedStateChanged(ActionMode mode,int position,long id,boolean checked){
  if (getListHeader() != null)   position--;
  if (getListAdapter() != null && getListAdapter() instanceof AllDataAdapter) {
    AllDataAdapter adapter=(AllDataAdapter)getListAdapter();
    adapter.setPositionChecked(position,checked);
    adapter.notifyDataSetChanged();
  }
}",0.9370629370629372
64783,"@Override public boolean onActionItemClicked(ActionMode mode,android.view.MenuItem item){
  final ArrayList<Integer> transIds=new ArrayList<Integer>();
  if (getListAdapter() != null && getListAdapter() instanceof AllDataAdapter) {
    AllDataAdapter adapter=(AllDataAdapter)getListAdapter();
    Cursor cursor=adapter.getCursor();
    if (cursor != null) {
      SparseBooleanArray positionChecked=getListView().getCheckedItemPositions();
      for (int i=0; i < getListView().getCheckedItemCount(); i++) {
        int position=positionChecked.keyAt(i);
        if (cursor.moveToPosition(position)) {
          transIds.add(cursor.getInt(cursor.getColumnIndex(QueryAllData.ID)));
        }
      }
    }
  }
switch (item.getItemId()) {
case R.id.menu_change_status:
    final DrawerMenuItemAdapter adapter=new DrawerMenuItemAdapter(getActivity());
  final Core core=new Core(getActivity());
final Boolean isDarkTheme=core.getThemeApplication() == R.style.Theme_Money_Manager;
adapter.add(new DrawerMenuItem(R.id.menu_none,getString(R.string.status_none),isDarkTheme ? R.drawable.ic_action_help_dark : R.drawable.ic_action_help_light,""String_Node_Str""));
adapter.add(new DrawerMenuItem(R.id.menu_reconciled,getString(R.string.status_reconciled),isDarkTheme ? R.drawable.ic_action_done_dark : R.drawable.ic_action_done_light,""String_Node_Str""));
adapter.add(new DrawerMenuItem(R.id.menu_follow_up,getString(R.string.status_follow_up),isDarkTheme ? R.drawable.ic_action_alarm_on_dark : R.drawable.ic_action_alarm_on_light,""String_Node_Str""));
adapter.add(new DrawerMenuItem(R.id.menu_duplicate,getString(R.string.status_duplicate),isDarkTheme ? R.drawable.ic_action_copy_dark : R.drawable.ic_action_copy_light,""String_Node_Str""));
adapter.add(new DrawerMenuItem(R.id.menu_void,getString(R.string.status_void),isDarkTheme ? R.drawable.ic_action_halt_dark : R.drawable.ic_action_halt_light,""String_Node_Str""));
final MaterialDialog dialog=new MaterialDialog.Builder(getActivity()).title(getString(R.string.change_status)).adapter(adapter).theme(core.getThemeApplication() == R.style.Theme_Money_Manager ? Theme.DARK : Theme.LIGHT).build();
ListView listView=dialog.getListView();
if (listView != null) listView.setOnItemClickListener(new OnItemClickListener(){
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
DrawerMenuItem item=adapter.getItem(position);
switch (item.getId()) {
case R.id.menu_none:
case R.id.menu_reconciled:
case R.id.menu_follow_up:
case R.id.menu_duplicate:
case R.id.menu_void:
String status=item.getAlphabeticShortcut();
if (setStatusCheckingAccount(convertArraryListToArray(transIds),status)) {
((AllDataAdapter)getListAdapter()).clearPositionChecked();
startLoaderData();
}
}
dialog.dismiss();
}
}
);
dialog.show();
mode.finish();
break;
case R.id.menu_duplicate_transactions:
int[] ids=convertArraryListToArray(transIds);
Intent[] intents=new Intent[ids.length];
for (int i=0; i < ids.length; i++) {
intents[i]=new Intent(getActivity(),CheckingAccountActivity.class);
intents[i].putExtra(CheckingAccountActivity.KEY_TRANS_ID,ids[i]);
intents[i].setAction(Intent.ACTION_PASTE);
}
getActivity().startActivities(intents);
mode.finish();
break;
case R.id.menu_delete:
showDialogDeleteCheckingAccount(convertArraryListToArray(transIds));
return true;
case R.id.menu_none:
case R.id.menu_reconciled:
case R.id.menu_follow_up:
case R.id.menu_duplicate:
case R.id.menu_void:
String status=Character.toString(item.getAlphabeticShortcut());
if (setStatusCheckingAccount(convertArraryListToArray(transIds),status)) {
((AllDataAdapter)getListAdapter()).clearPositionChecked();
startLoaderData();
mode.finish();
return true;
}
}
return false;
}","@Override public boolean onActionItemClicked(ActionMode mode,android.view.MenuItem item){
  final ArrayList<Integer> transIds=new ArrayList<Integer>();
  if (getListAdapter() != null && getListAdapter() instanceof AllDataAdapter) {
    AllDataAdapter adapter=(AllDataAdapter)getListAdapter();
    Cursor cursor=adapter.getCursor();
    if (cursor != null) {
      SparseBooleanArray positionChecked=getListView().getCheckedItemPositions();
      for (int i=0; i < getListView().getCheckedItemCount(); i++) {
        int position=positionChecked.keyAt(i);
        if (getListHeader() != null)         position--;
        if (cursor.moveToPosition(position)) {
          transIds.add(cursor.getInt(cursor.getColumnIndex(QueryAllData.ID)));
        }
      }
    }
  }
switch (item.getItemId()) {
case R.id.menu_change_status:
    final DrawerMenuItemAdapter adapter=new DrawerMenuItemAdapter(getActivity());
  final Core core=new Core(getActivity());
final Boolean isDarkTheme=core.getThemeApplication() == R.style.Theme_Money_Manager;
adapter.add(new DrawerMenuItem(R.id.menu_none,getString(R.string.status_none),isDarkTheme ? R.drawable.ic_action_help_dark : R.drawable.ic_action_help_light,""String_Node_Str""));
adapter.add(new DrawerMenuItem(R.id.menu_reconciled,getString(R.string.status_reconciled),isDarkTheme ? R.drawable.ic_action_done_dark : R.drawable.ic_action_done_light,""String_Node_Str""));
adapter.add(new DrawerMenuItem(R.id.menu_follow_up,getString(R.string.status_follow_up),isDarkTheme ? R.drawable.ic_action_alarm_on_dark : R.drawable.ic_action_alarm_on_light,""String_Node_Str""));
adapter.add(new DrawerMenuItem(R.id.menu_duplicate,getString(R.string.status_duplicate),isDarkTheme ? R.drawable.ic_action_copy_dark : R.drawable.ic_action_copy_light,""String_Node_Str""));
adapter.add(new DrawerMenuItem(R.id.menu_void,getString(R.string.status_void),isDarkTheme ? R.drawable.ic_action_halt_dark : R.drawable.ic_action_halt_light,""String_Node_Str""));
final MaterialDialog dialog=new MaterialDialog.Builder(getActivity()).title(getString(R.string.change_status)).adapter(adapter).theme(core.getThemeApplication() == R.style.Theme_Money_Manager ? Theme.DARK : Theme.LIGHT).build();
ListView listView=dialog.getListView();
if (listView != null) listView.setOnItemClickListener(new OnItemClickListener(){
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
DrawerMenuItem item=adapter.getItem(position);
switch (item.getId()) {
case R.id.menu_none:
case R.id.menu_reconciled:
case R.id.menu_follow_up:
case R.id.menu_duplicate:
case R.id.menu_void:
String status=item.getAlphabeticShortcut();
if (setStatusCheckingAccount(convertArraryListToArray(transIds),status)) {
((AllDataAdapter)getListAdapter()).clearPositionChecked();
startLoaderData();
}
}
dialog.dismiss();
}
}
);
dialog.show();
mode.finish();
break;
case R.id.menu_duplicate_transactions:
int[] ids=convertArraryListToArray(transIds);
Intent[] intents=new Intent[ids.length];
for (int i=0; i < ids.length; i++) {
intents[i]=new Intent(getActivity(),CheckingAccountActivity.class);
intents[i].putExtra(CheckingAccountActivity.KEY_TRANS_ID,ids[i]);
intents[i].setAction(Intent.ACTION_PASTE);
}
getActivity().startActivities(intents);
mode.finish();
break;
case R.id.menu_delete:
showDialogDeleteCheckingAccount(convertArraryListToArray(transIds));
return true;
case R.id.menu_none:
case R.id.menu_reconciled:
case R.id.menu_follow_up:
case R.id.menu_duplicate:
case R.id.menu_void:
String status=Character.toString(item.getAlphabeticShortcut());
if (setStatusCheckingAccount(convertArraryListToArray(transIds),status)) {
((AllDataAdapter)getListAdapter()).clearPositionChecked();
startLoaderData();
mode.finish();
return true;
}
}
return false;
}",0.992345911105143
64784,"/** 
 * start the activity of transaction management
 * @param transId null set if you want to do a new transaction, or transaction id
 */
private void startCheckingAccountActivity(Integer transId){
  Intent intent=new Intent(getActivity(),CheckingAccountActivity.class);
  if (transId != null) {
    intent.putExtra(CheckingAccountActivity.KEY_TRANS_ID,transId);
    intent.setAction(Intent.ACTION_EDIT);
  }
 else {
    intent.setAction(Intent.ACTION_INSERT);
  }
  startActivity(intent);
}","/** 
 * start the activity of transaction management
 * @param transId null set if you want to do a new transaction, or transaction id
 */
private void startCheckingAccountActivity(Integer transId){
  Intent intent=new Intent(getActivity(),CheckingAccountActivity.class);
  if (transId != null) {
    intent.putExtra(CheckingAccountActivity.KEY_TRANS_ID,transId);
    intent.setAction(Intent.ACTION_EDIT);
  }
 else {
    intent.putExtra(CheckingAccountActivity.KEY_ACCOUNT_ID,mAccountId);
    intent.setAction(Intent.ACTION_INSERT);
  }
  startActivity(intent);
}",0.9318181818181818
64785,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setDialogMode(true);
  if ((savedInstanceState != null)) {
    mTransId=savedInstanceState.getInt(KEY_TRANS_ID);
    mAccountId=savedInstanceState.getInt(KEY_ACCOUNT_ID);
    mToAccountId=savedInstanceState.getInt(KEY_TO_ACCOUNT_ID);
    mToAccountName=savedInstanceState.getString(KEY_TO_ACCOUNT_NAME);
    mDate=savedInstanceState.getString(KEY_TRANS_DATE);
    mTransCode=savedInstanceState.getString(KEY_TRANS_CODE);
    mStatus=savedInstanceState.getString(KEY_TRANS_STATUS);
    mAmount=savedInstanceState.getDouble(KEY_TRANS_AMOUNT);
    mTotAmount=savedInstanceState.getDouble(KEY_TRANS_TOTAMOUNT);
    mPayeeId=savedInstanceState.getInt(KEY_PAYEE_ID);
    mPayeeName=savedInstanceState.getString(KEY_PAYEE_NAME);
    mCategoryId=savedInstanceState.getInt(KEY_CATEGORY_ID);
    mCategoryName=savedInstanceState.getString(KEY_CATEGORY_NAME);
    mSubCategoryId=savedInstanceState.getInt(KEY_SUBCATEGORY_ID);
    mSubCategoryName=savedInstanceState.getString(KEY_SUBCATEGORY_NAME);
    mNotes=savedInstanceState.getString(KEY_NOTES);
    mTransNumber=savedInstanceState.getString(KEY_TRANS_NUMBER);
    mSplitTransaction=savedInstanceState.getParcelableArrayList(KEY_SPLIT_TRANSACTION);
    mSplitTransactionDeleted=savedInstanceState.getParcelableArrayList(KEY_SPLIT_TRANSACTION_DELETED);
    mBdId=savedInstanceState.getInt(KEY_BDID_ID);
    mNextOccurrence=savedInstanceState.getString(KEY_NEXT_OCCURRENCE);
    mIntentAction=savedInstanceState.getString(KEY_ACTION);
  }
  if (getIntent() != null) {
    if (savedInstanceState == null) {
      mAccountId=getIntent().getIntExtra(KEY_ACCOUNT_ID,-1);
      if (getIntent().getAction() != null && Intent.ACTION_EDIT.equals(getIntent().getAction())) {
        mTransId=getIntent().getIntExtra(KEY_TRANS_ID,-1);
        getCheckingAccount(mTransId,false);
      }
 else       if (getIntent().getAction() != null && Intent.ACTION_PASTE.equals(getIntent().getAction())) {
        getCheckingAccount(getIntent().getIntExtra(KEY_TRANS_ID,-1),true);
      }
 else {
        if (getIntent().getIntExtra(KEY_BDID_ID,-1) > -1) {
          mBdId=getIntent().getIntExtra(KEY_BDID_ID,-1);
          mNextOccurrence=getIntent().getStringExtra(KEY_NEXT_OCCURRENCE);
          getRepeatingTransaction(mBdId);
        }
      }
    }
    mIntentAction=getIntent().getAction();
    if (Constants.INTENT_ACTION_INSERT.equals(mIntentAction)) {
      if (mStatus == null)       mStatus=PreferenceManager.getDefaultSharedPreferences(this).getString(getString(PreferencesConstant.PREF_DEFAULT_STATUS),""String_Node_Str"");
      if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(this).getString(getString(PreferencesConstant.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
        AsyncTask<Void,Void,Boolean> task=new AsyncTask<Void,Void,Boolean>(){
          @Override protected Boolean doInBackground(          Void... params){
            try {
              Core core=new Core(CheckingAccountActivity.this);
              TablePayee payee=core.getLastPayeeUsed();
              if (payee != null && mPayeeId == -1) {
                mPayeeId=payee.getPayeeId();
                mPayeeName=payee.getPayeeName();
                mCategoryId=payee.getCategId();
                mSubCategoryId=payee.getSubCategId();
                getCategSubName(mCategoryId,mSubCategoryId);
                return Boolean.TRUE;
              }
            }
 catch (            Exception e) {
              Log.e(LOGCAT,e.getMessage());
            }
            return Boolean.FALSE;
          }
          @Override protected void onPostExecute(          Boolean result){
            super.onPostExecute(result);
            if (result) {
              try {
                refreshPayeeName();
                refreshCategoryName();
              }
 catch (              Exception e) {
                Log.e(LOGCAT,e.getMessage());
              }
            }
          }
        }
;
        task.execute();
      }
    }
    getSupportActionBar().setTitle(Constants.INTENT_ACTION_INSERT.equals(mIntentAction) ? R.string.new_transaction : R.string.edit_transaction);
  }
  setContentView(R.layout.checkingaccount_activity);
  spinAccount=(Spinner)findViewById(R.id.spinnerAccount);
  mAccountList=MoneyManagerOpenHelper.getInstance(this).getListAccounts(MoneyManagerApplication.getInstanceApp().getAccountsOpenVisible(),MoneyManagerApplication.getInstanceApp().getAccountFavoriteVisible());
  for (int i=0; i <= mAccountList.size() - 1; i++) {
    mAccountNameList.add(mAccountList.get(i).getAccountName());
    mAccountIdList.add(mAccountList.get(i).getAccountId());
  }
  ArrayAdapter<String> adapterAccount=new ArrayAdapter<String>(this,android.R.layout.simple_spinner_item,mAccountNameList);
  adapterAccount.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  spinAccount.setAdapter(adapterAccount);
  if (mAccountIdList.indexOf(mAccountId) >= 0) {
    spinAccount.setSelection(mAccountIdList.indexOf(mAccountId),true);
  }
  spinAccount.setOnItemSelectedListener(new OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if ((position >= 0) && (position <= mAccountIdList.size())) {
        mAccountId=mAccountIdList.get(position);
        if (Constants.TRANSACTION_TYPE_TRANSFER.equals(mTransCode)) {
          formatAmount(txtAmount,(Double)txtAmount.getTag(),mAccountId);
        }
 else {
          formatAmount(txtTotAmount,(Double)txtTotAmount.getTag(),mAccountId);
        }
        refreshHeaderAmount();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  spinToAccount=(Spinner)findViewById(R.id.spinnerToAccount);
  adapterAccount.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  spinToAccount.setAdapter(adapterAccount);
  if (mToAccountId != -1) {
    if (mAccountIdList.indexOf(mToAccountId) >= 0) {
      spinToAccount.setSelection(mAccountIdList.indexOf(mToAccountId),true);
    }
  }
  spinToAccount.setOnItemSelectedListener(new OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if ((position >= 0) && (position <= mAccountIdList.size())) {
        mToAccountId=mAccountIdList.get(position);
        formatAmount(txtAmount,(Double)txtAmount.getTag(),mAccountId);
        formatAmount(txtTotAmount,(Double)txtTotAmount.getTag(),mToAccountId);
        refreshHeaderAmount();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  spinTransCode=(Spinner)findViewById(R.id.spinnerTransCode);
  mTransCodeItems=getResources().getStringArray(R.array.transcode_items);
  mTransCodeValues=getResources().getStringArray(R.array.transcode_values);
  ArrayAdapter<String> adapterTrans=new ArrayAdapter<String>(this,android.R.layout.simple_spinner_item,mTransCodeItems);
  adapterTrans.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  spinTransCode.setAdapter(adapterTrans);
  if (TextUtils.isEmpty(mTransCode) == false) {
    if (Arrays.asList(mTransCodeValues).indexOf(mTransCode) >= 0) {
      spinTransCode.setSelection(Arrays.asList(mTransCodeValues).indexOf(mTransCode),true);
    }
  }
 else {
    mTransCode=(String)spinTransCode.getSelectedItem();
  }
  spinTransCode.setOnItemSelectedListener(new OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if ((position >= 0) && (position <= mTransCodeValues.length)) {
        mTransCode=mTransCodeValues[position];
      }
      refreshTransCode();
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  spinStatus=(Spinner)findViewById(R.id.spinnerStatus);
  mStatusItems=getResources().getStringArray(R.array.status_items);
  mStatusValues=getResources().getStringArray(R.array.status_values);
  ArrayAdapter<String> adapterStatus=new ArrayAdapter<String>(this,android.R.layout.simple_spinner_item,mStatusItems);
  adapterStatus.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  spinStatus.setAdapter(adapterStatus);
  if (!(TextUtils.isEmpty(mStatus))) {
    if (Arrays.asList(mStatusValues).indexOf(mStatus) >= 0) {
      spinStatus.setSelection(Arrays.asList(mStatusValues).indexOf(mStatus),true);
    }
  }
 else {
    mStatus=(String)spinStatus.getSelectedItem();
  }
  spinStatus.setOnItemSelectedListener(new OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if ((position >= 0) && (position <= mStatusValues.length)) {
        mStatus=mStatusValues[position];
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  txtSelectDate=(TextView)findViewById(R.id.textViewDate);
  if (!(TextUtils.isEmpty(mDate))) {
    try {
      txtSelectDate.setTag(new SimpleDateFormat(""String_Node_Str"").parse(mDate));
    }
 catch (    ParseException e) {
      Log.e(LOGCAT,e.getMessage());
    }
  }
 else {
    txtSelectDate.setTag((Date)Calendar.getInstance().getTime());
  }
  formatExtendedDate(txtSelectDate);
  txtSelectDate.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Calendar date=Calendar.getInstance();
      date.setTime((Date)txtSelectDate.getTag());
      DatePickerDialog dialog=new DatePickerDialog(CheckingAccountActivity.this,mDateSetListener,date.get(Calendar.YEAR),date.get(Calendar.MONTH),date.get(Calendar.DATE));
      dialog.show();
    }
    public DatePickerDialog.OnDateSetListener mDateSetListener=new DatePickerDialog.OnDateSetListener(){
      @Override public void onDateSet(      DatePicker view,      int year,      int monthOfYear,      int dayOfMonth){
        try {
          Date date=new SimpleDateFormat(""String_Node_Str"").parse(Integer.toString(year) + ""String_Node_Str"" + Integer.toString(monthOfYear + 1)+ ""String_Node_Str""+ Integer.toString(dayOfMonth));
          txtSelectDate.setTag(date);
          formatExtendedDate(txtSelectDate);
        }
 catch (        Exception e) {
          Log.e(LOGCAT,e.getMessage());
        }
      }
    }
;
  }
);
  txtSelectPayee=(TextView)findViewById(R.id.textViewPayee);
  txtSelectPayee.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Intent intent=new Intent(CheckingAccountActivity.this,PayeeActivity.class);
      intent.setAction(Intent.ACTION_PICK);
      startActivityForResult(intent,REQUEST_PICK_PAYEE);
    }
  }
);
  txtSelectCategory=(TextView)findViewById(R.id.textViewCategory);
  txtSelectCategory.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (!chbSplitTransaction.isChecked()) {
        Intent intent=new Intent(CheckingAccountActivity.this,CategorySubCategoryExpandableListActivity.class);
        intent.setAction(Intent.ACTION_PICK);
        startActivityForResult(intent,REQUEST_PICK_CATEGORY);
      }
 else {
        Intent intent=new Intent(CheckingAccountActivity.this,SplitTransactionsActivity.class);
        intent.putParcelableArrayListExtra(SplitTransactionsActivity.KEY_SPLIT_TRANSACTION,mSplitTransaction);
        intent.putParcelableArrayListExtra(SplitTransactionsActivity.KEY_SPLIT_TRANSACTION_DELETED,mSplitTransactionDeleted);
        startActivityForResult(intent,REQUEST_PICK_SPLIT_TRANSACTION);
      }
    }
  }
);
  chbSplitTransaction=(CheckBox)findViewById(R.id.checkBoxSplitTransaction);
  chbSplitTransaction.setChecked(mSplitTransaction != null && mSplitTransaction.size() >= 0);
  chbSplitTransaction.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      CheckingAccountActivity.this.refreshCategoryName();
    }
  }
);
  OnClickListener onClickAmount=new OnClickListener(){
    @Override public void onClick(    View v){
      Integer currencyId=null;
      if (txtTotAmount.equals(v)) {
        if (spinAccount.getSelectedItemPosition() >= 0 && spinAccount.getSelectedItemPosition() < mAccountList.size()) {
          if (Constants.TRANSACTION_TYPE_TRANSFER.equals(mTransCode)) {
            currencyId=mAccountList.get(spinToAccount.getSelectedItemPosition()).getCurrencyId();
          }
 else {
            currencyId=mAccountList.get(spinAccount.getSelectedItemPosition()).getCurrencyId();
          }
        }
      }
 else {
        if (spinToAccount.getSelectedItemPosition() >= 0 && spinToAccount.getSelectedItemPosition() < mAccountList.size()) {
          currencyId=mAccountList.get(spinAccount.getSelectedItemPosition()).getCurrencyId();
        }
      }
      double amount=(Double)((TextView)v).getTag();
      InputAmountDialog dialog=InputAmountDialog.getInstance(v.getId(),amount,currencyId);
      dialog.show(getSupportFragmentManager(),dialog.getClass().getSimpleName());
    }
  }
;
  txtTotAmount=(TextView)findViewById(R.id.textViewTotAmount);
  formatAmount(txtTotAmount,mTotAmount,!Constants.TRANSACTION_TYPE_TRANSFER.equals(mTransCode) ? mAccountId : mToAccountId);
  txtTotAmount.setOnClickListener(onClickAmount);
  txtAmount=(TextView)findViewById(R.id.textViewAmount);
  formatAmount(txtAmount,mAmount,!Constants.TRANSACTION_TYPE_TRANSFER.equals(mTransCode) ? mToAccountId : mAccountId);
  txtAmount.setOnClickListener(onClickAmount);
  edtTransNumber=(EditText)findViewById(R.id.editTextTransNumber);
  if (!TextUtils.isEmpty(mTransNumber)) {
    edtTransNumber.setText(mTransNumber);
  }
  btnTransNumber=(ImageButton)findViewById(R.id.buttonTransNumber);
  btnTransNumber.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      MoneyManagerOpenHelper helper=MoneyManagerOpenHelper.getInstance(CheckingAccountActivity.this);
      String query=""String_Node_Str"" + TableCheckingAccount.TRANSACTIONNUMBER + ""String_Node_Str""+ new TableCheckingAccount().getSource()+ ""String_Node_Str""+ TableCheckingAccount.ACCOUNTID+ ""String_Node_Str"";
      Cursor cursor=helper.getReadableDatabase().rawQuery(query,new String[]{Integer.toString(mAccountId)});
      if (cursor != null && cursor.moveToFirst()) {
        String transNumber=cursor.getString(0);
        if (TextUtils.isEmpty(transNumber)) {
          transNumber=""String_Node_Str"";
        }
        if ((!TextUtils.isEmpty(transNumber)) && TextUtils.isDigitsOnly(transNumber)) {
          try {
            edtTransNumber.setText(Long.toString(Long.parseLong(transNumber) + 1));
          }
 catch (          Exception e) {
            Log.e(LOGCAT,e.getMessage());
          }
        }
        cursor.close();
      }
    }
  }
);
  edtNotes=(EditText)findViewById(R.id.editTextNotes);
  if (!(TextUtils.isEmpty(mNotes))) {
    edtNotes.setText(mNotes);
  }
  refreshTransCode();
  refreshPayeeName();
  refreshCategoryName();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  try {
    DropboxHelper.getInstance();
  }
 catch (  Exception e) {
    Log.e(LOGCAT,e.getMessage());
    DropboxHelper.getInstance(getApplicationContext());
  }
  setDialogMode(true);
  if ((savedInstanceState != null)) {
    mTransId=savedInstanceState.getInt(KEY_TRANS_ID);
    mAccountId=savedInstanceState.getInt(KEY_ACCOUNT_ID);
    mToAccountId=savedInstanceState.getInt(KEY_TO_ACCOUNT_ID);
    mToAccountName=savedInstanceState.getString(KEY_TO_ACCOUNT_NAME);
    mDate=savedInstanceState.getString(KEY_TRANS_DATE);
    mTransCode=savedInstanceState.getString(KEY_TRANS_CODE);
    mStatus=savedInstanceState.getString(KEY_TRANS_STATUS);
    mAmount=savedInstanceState.getDouble(KEY_TRANS_AMOUNT);
    mTotAmount=savedInstanceState.getDouble(KEY_TRANS_TOTAMOUNT);
    mPayeeId=savedInstanceState.getInt(KEY_PAYEE_ID);
    mPayeeName=savedInstanceState.getString(KEY_PAYEE_NAME);
    mCategoryId=savedInstanceState.getInt(KEY_CATEGORY_ID);
    mCategoryName=savedInstanceState.getString(KEY_CATEGORY_NAME);
    mSubCategoryId=savedInstanceState.getInt(KEY_SUBCATEGORY_ID);
    mSubCategoryName=savedInstanceState.getString(KEY_SUBCATEGORY_NAME);
    mNotes=savedInstanceState.getString(KEY_NOTES);
    mTransNumber=savedInstanceState.getString(KEY_TRANS_NUMBER);
    mSplitTransaction=savedInstanceState.getParcelableArrayList(KEY_SPLIT_TRANSACTION);
    mSplitTransactionDeleted=savedInstanceState.getParcelableArrayList(KEY_SPLIT_TRANSACTION_DELETED);
    mBdId=savedInstanceState.getInt(KEY_BDID_ID);
    mNextOccurrence=savedInstanceState.getString(KEY_NEXT_OCCURRENCE);
    mIntentAction=savedInstanceState.getString(KEY_ACTION);
  }
  if (getIntent() != null) {
    if (savedInstanceState == null) {
      mAccountId=getIntent().getIntExtra(KEY_ACCOUNT_ID,-1);
      if (getIntent().getAction() != null && Intent.ACTION_EDIT.equals(getIntent().getAction())) {
        mTransId=getIntent().getIntExtra(KEY_TRANS_ID,-1);
        getCheckingAccount(mTransId,false);
      }
 else       if (getIntent().getAction() != null && Intent.ACTION_PASTE.equals(getIntent().getAction())) {
        getCheckingAccount(getIntent().getIntExtra(KEY_TRANS_ID,-1),true);
      }
 else {
        if (getIntent().getIntExtra(KEY_BDID_ID,-1) > -1) {
          mBdId=getIntent().getIntExtra(KEY_BDID_ID,-1);
          mNextOccurrence=getIntent().getStringExtra(KEY_NEXT_OCCURRENCE);
          getRepeatingTransaction(mBdId);
        }
      }
    }
    mIntentAction=getIntent().getAction();
    if (Constants.INTENT_ACTION_INSERT.equals(mIntentAction)) {
      if (mStatus == null)       mStatus=PreferenceManager.getDefaultSharedPreferences(this).getString(getString(PreferencesConstant.PREF_DEFAULT_STATUS),""String_Node_Str"");
      if (""String_Node_Str"".equals(PreferenceManager.getDefaultSharedPreferences(this).getString(getString(PreferencesConstant.PREF_DEFAULT_PAYEE),""String_Node_Str""))) {
        AsyncTask<Void,Void,Boolean> task=new AsyncTask<Void,Void,Boolean>(){
          @Override protected Boolean doInBackground(          Void... params){
            try {
              Core core=new Core(CheckingAccountActivity.this);
              TablePayee payee=core.getLastPayeeUsed();
              if (payee != null && mPayeeId == -1) {
                mPayeeId=payee.getPayeeId();
                mPayeeName=payee.getPayeeName();
                mCategoryId=payee.getCategId();
                mSubCategoryId=payee.getSubCategId();
                getCategSubName(mCategoryId,mSubCategoryId);
                return Boolean.TRUE;
              }
            }
 catch (            Exception e) {
              Log.e(LOGCAT,e.getMessage());
            }
            return Boolean.FALSE;
          }
          @Override protected void onPostExecute(          Boolean result){
            super.onPostExecute(result);
            if (result) {
              try {
                refreshPayeeName();
                refreshCategoryName();
              }
 catch (              Exception e) {
                Log.e(LOGCAT,e.getMessage());
              }
            }
          }
        }
;
        task.execute();
      }
    }
    getSupportActionBar().setTitle(Constants.INTENT_ACTION_INSERT.equals(mIntentAction) ? R.string.new_transaction : R.string.edit_transaction);
  }
  setContentView(R.layout.checkingaccount_activity);
  spinAccount=(Spinner)findViewById(R.id.spinnerAccount);
  mAccountList=MoneyManagerOpenHelper.getInstance(this).getListAccounts(MoneyManagerApplication.getInstanceApp().getAccountsOpenVisible(),MoneyManagerApplication.getInstanceApp().getAccountFavoriteVisible());
  for (int i=0; i <= mAccountList.size() - 1; i++) {
    mAccountNameList.add(mAccountList.get(i).getAccountName());
    mAccountIdList.add(mAccountList.get(i).getAccountId());
  }
  ArrayAdapter<String> adapterAccount=new ArrayAdapter<String>(this,android.R.layout.simple_spinner_item,mAccountNameList);
  adapterAccount.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  spinAccount.setAdapter(adapterAccount);
  if (mAccountIdList.indexOf(mAccountId) >= 0) {
    spinAccount.setSelection(mAccountIdList.indexOf(mAccountId),true);
  }
  spinAccount.setOnItemSelectedListener(new OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if ((position >= 0) && (position <= mAccountIdList.size())) {
        mAccountId=mAccountIdList.get(position);
        if (Constants.TRANSACTION_TYPE_TRANSFER.equals(mTransCode)) {
          formatAmount(txtAmount,(Double)txtAmount.getTag(),mAccountId);
        }
 else {
          formatAmount(txtTotAmount,(Double)txtTotAmount.getTag(),mAccountId);
        }
        refreshHeaderAmount();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  spinToAccount=(Spinner)findViewById(R.id.spinnerToAccount);
  adapterAccount.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  spinToAccount.setAdapter(adapterAccount);
  if (mToAccountId != -1) {
    if (mAccountIdList.indexOf(mToAccountId) >= 0) {
      spinToAccount.setSelection(mAccountIdList.indexOf(mToAccountId),true);
    }
  }
  spinToAccount.setOnItemSelectedListener(new OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if ((position >= 0) && (position <= mAccountIdList.size())) {
        mToAccountId=mAccountIdList.get(position);
        formatAmount(txtAmount,(Double)txtAmount.getTag(),mAccountId);
        formatAmount(txtTotAmount,(Double)txtTotAmount.getTag(),mToAccountId);
        refreshHeaderAmount();
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  spinTransCode=(Spinner)findViewById(R.id.spinnerTransCode);
  mTransCodeItems=getResources().getStringArray(R.array.transcode_items);
  mTransCodeValues=getResources().getStringArray(R.array.transcode_values);
  ArrayAdapter<String> adapterTrans=new ArrayAdapter<String>(this,android.R.layout.simple_spinner_item,mTransCodeItems);
  adapterTrans.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  spinTransCode.setAdapter(adapterTrans);
  if (TextUtils.isEmpty(mTransCode) == false) {
    if (Arrays.asList(mTransCodeValues).indexOf(mTransCode) >= 0) {
      spinTransCode.setSelection(Arrays.asList(mTransCodeValues).indexOf(mTransCode),true);
    }
  }
 else {
    mTransCode=(String)spinTransCode.getSelectedItem();
  }
  spinTransCode.setOnItemSelectedListener(new OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if ((position >= 0) && (position <= mTransCodeValues.length)) {
        mTransCode=mTransCodeValues[position];
      }
      refreshTransCode();
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  spinStatus=(Spinner)findViewById(R.id.spinnerStatus);
  mStatusItems=getResources().getStringArray(R.array.status_items);
  mStatusValues=getResources().getStringArray(R.array.status_values);
  ArrayAdapter<String> adapterStatus=new ArrayAdapter<String>(this,android.R.layout.simple_spinner_item,mStatusItems);
  adapterStatus.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  spinStatus.setAdapter(adapterStatus);
  if (!(TextUtils.isEmpty(mStatus))) {
    if (Arrays.asList(mStatusValues).indexOf(mStatus) >= 0) {
      spinStatus.setSelection(Arrays.asList(mStatusValues).indexOf(mStatus),true);
    }
  }
 else {
    mStatus=(String)spinStatus.getSelectedItem();
  }
  spinStatus.setOnItemSelectedListener(new OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      if ((position >= 0) && (position <= mStatusValues.length)) {
        mStatus=mStatusValues[position];
      }
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  txtSelectDate=(TextView)findViewById(R.id.textViewDate);
  if (!(TextUtils.isEmpty(mDate))) {
    try {
      txtSelectDate.setTag(new SimpleDateFormat(""String_Node_Str"").parse(mDate));
    }
 catch (    ParseException e) {
      Log.e(LOGCAT,e.getMessage());
    }
  }
 else {
    txtSelectDate.setTag((Date)Calendar.getInstance().getTime());
  }
  formatExtendedDate(txtSelectDate);
  txtSelectDate.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Calendar date=Calendar.getInstance();
      date.setTime((Date)txtSelectDate.getTag());
      DatePickerDialog dialog=new DatePickerDialog(CheckingAccountActivity.this,mDateSetListener,date.get(Calendar.YEAR),date.get(Calendar.MONTH),date.get(Calendar.DATE));
      dialog.show();
    }
    public DatePickerDialog.OnDateSetListener mDateSetListener=new DatePickerDialog.OnDateSetListener(){
      @Override public void onDateSet(      DatePicker view,      int year,      int monthOfYear,      int dayOfMonth){
        try {
          Date date=new SimpleDateFormat(""String_Node_Str"").parse(Integer.toString(year) + ""String_Node_Str"" + Integer.toString(monthOfYear + 1)+ ""String_Node_Str""+ Integer.toString(dayOfMonth));
          txtSelectDate.setTag(date);
          formatExtendedDate(txtSelectDate);
        }
 catch (        Exception e) {
          Log.e(LOGCAT,e.getMessage());
        }
      }
    }
;
  }
);
  txtSelectPayee=(TextView)findViewById(R.id.textViewPayee);
  txtSelectPayee.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Intent intent=new Intent(CheckingAccountActivity.this,PayeeActivity.class);
      intent.setAction(Intent.ACTION_PICK);
      startActivityForResult(intent,REQUEST_PICK_PAYEE);
    }
  }
);
  txtSelectCategory=(TextView)findViewById(R.id.textViewCategory);
  txtSelectCategory.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (!chbSplitTransaction.isChecked()) {
        Intent intent=new Intent(CheckingAccountActivity.this,CategorySubCategoryExpandableListActivity.class);
        intent.setAction(Intent.ACTION_PICK);
        startActivityForResult(intent,REQUEST_PICK_CATEGORY);
      }
 else {
        Intent intent=new Intent(CheckingAccountActivity.this,SplitTransactionsActivity.class);
        intent.putParcelableArrayListExtra(SplitTransactionsActivity.KEY_SPLIT_TRANSACTION,mSplitTransaction);
        intent.putParcelableArrayListExtra(SplitTransactionsActivity.KEY_SPLIT_TRANSACTION_DELETED,mSplitTransactionDeleted);
        startActivityForResult(intent,REQUEST_PICK_SPLIT_TRANSACTION);
      }
    }
  }
);
  chbSplitTransaction=(CheckBox)findViewById(R.id.checkBoxSplitTransaction);
  chbSplitTransaction.setChecked(mSplitTransaction != null && mSplitTransaction.size() >= 0);
  chbSplitTransaction.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      CheckingAccountActivity.this.refreshCategoryName();
    }
  }
);
  OnClickListener onClickAmount=new OnClickListener(){
    @Override public void onClick(    View v){
      Integer currencyId=null;
      if (txtTotAmount.equals(v)) {
        if (spinAccount.getSelectedItemPosition() >= 0 && spinAccount.getSelectedItemPosition() < mAccountList.size()) {
          if (Constants.TRANSACTION_TYPE_TRANSFER.equals(mTransCode)) {
            currencyId=mAccountList.get(spinToAccount.getSelectedItemPosition()).getCurrencyId();
          }
 else {
            currencyId=mAccountList.get(spinAccount.getSelectedItemPosition()).getCurrencyId();
          }
        }
      }
 else {
        if (spinToAccount.getSelectedItemPosition() >= 0 && spinToAccount.getSelectedItemPosition() < mAccountList.size()) {
          currencyId=mAccountList.get(spinAccount.getSelectedItemPosition()).getCurrencyId();
        }
      }
      double amount=(Double)((TextView)v).getTag();
      InputAmountDialog dialog=InputAmountDialog.getInstance(v.getId(),amount,currencyId);
      dialog.show(getSupportFragmentManager(),dialog.getClass().getSimpleName());
    }
  }
;
  txtTotAmount=(TextView)findViewById(R.id.textViewTotAmount);
  formatAmount(txtTotAmount,mTotAmount,!Constants.TRANSACTION_TYPE_TRANSFER.equals(mTransCode) ? mAccountId : mToAccountId);
  txtTotAmount.setOnClickListener(onClickAmount);
  txtAmount=(TextView)findViewById(R.id.textViewAmount);
  formatAmount(txtAmount,mAmount,!Constants.TRANSACTION_TYPE_TRANSFER.equals(mTransCode) ? mToAccountId : mAccountId);
  txtAmount.setOnClickListener(onClickAmount);
  edtTransNumber=(EditText)findViewById(R.id.editTextTransNumber);
  if (!TextUtils.isEmpty(mTransNumber)) {
    edtTransNumber.setText(mTransNumber);
  }
  btnTransNumber=(ImageButton)findViewById(R.id.buttonTransNumber);
  btnTransNumber.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      MoneyManagerOpenHelper helper=MoneyManagerOpenHelper.getInstance(CheckingAccountActivity.this);
      String query=""String_Node_Str"" + TableCheckingAccount.TRANSACTIONNUMBER + ""String_Node_Str""+ new TableCheckingAccount().getSource()+ ""String_Node_Str""+ TableCheckingAccount.ACCOUNTID+ ""String_Node_Str"";
      Cursor cursor=helper.getReadableDatabase().rawQuery(query,new String[]{Integer.toString(mAccountId)});
      if (cursor != null && cursor.moveToFirst()) {
        String transNumber=cursor.getString(0);
        if (TextUtils.isEmpty(transNumber)) {
          transNumber=""String_Node_Str"";
        }
        if ((!TextUtils.isEmpty(transNumber)) && TextUtils.isDigitsOnly(transNumber)) {
          try {
            edtTransNumber.setText(Long.toString(Long.parseLong(transNumber) + 1));
          }
 catch (          Exception e) {
            Log.e(LOGCAT,e.getMessage());
          }
        }
        cursor.close();
      }
    }
  }
);
  edtNotes=(EditText)findViewById(R.id.editTextNotes);
  if (!(TextUtils.isEmpty(mNotes))) {
    edtNotes.setText(mNotes);
  }
  refreshTransCode();
  refreshPayeeName();
  refreshCategoryName();
}",0.9945977995915408
64786,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Core core=new Core(this);
  NotificationManager notificationManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  notificationManager.cancel(DropboxServiceIntent.NOTIFICATION_DROPBOX_OPEN_FILE);
  if (getIntent() != null && getIntent().getData() != null) {
    String pathFile=getIntent().getData().getEncodedPath();
    try {
      pathFile=URLDecoder.decode(pathFile,""String_Node_Str"");
      if (BuildConfig.DEBUG)       Log.d(LOGCAT,""String_Node_Str"" + pathFile);
      if (!core.changeDatabase(pathFile)) {
        Log.w(LOGCAT,""String_Node_Str"" + pathFile + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      Log.e(LOGCAT,e.getMessage());
    }
  }
  if (savedInstanceState != null) {
    if (savedInstanceState.containsKey(KEY_IS_AUTHENTICATED))     isAuthenticated=savedInstanceState.getBoolean(KEY_IS_AUTHENTICATED);
    if (savedInstanceState.containsKey(KEY_IN_AUTHENTICATION))     isInAuthentication=savedInstanceState.getBoolean(KEY_IN_AUTHENTICATION);
  }
  try {
    core.initDatabase();
  }
 catch (  Exception e) {
    Log.e(LOGCAT,!TextUtils.isEmpty(e.getMessage()) ? e.getMessage() : ""String_Node_Str"");
  }
  CurrencyUtils currencyUtils=new CurrencyUtils(this);
  if (!currencyUtils.isInit())   currencyUtils.reInit();
  mDropboxHelper=DropboxHelper.getInstance(getApplicationContext());
  onCreateFragments(savedInstanceState);
  showTipsDialog(savedInstanceState);
  if (TextUtils.isEmpty(core.getInfoValue(Constants.INFOTABLE_SKU_ORDER_ID)))   MoneyManagerApplication.showDonateDialog(this,false);
  MoneyManagerApplication.showChangeLog(this,false);
  MoneyManagerApplication.showDatabasePathWork(this);
  Intent serviceRepeatingTransaction=new Intent(getApplicationContext(),MoneyManagerBootReceiver.class);
  getApplicationContext().sendBroadcast(serviceRepeatingTransaction);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Core core=new Core(this);
  NotificationManager notificationManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  notificationManager.cancel(DropboxServiceIntent.NOTIFICATION_DROPBOX_OPEN_FILE);
  if (getIntent() != null && getIntent().getData() != null) {
    String pathFile=getIntent().getData().getEncodedPath();
    try {
      pathFile=URLDecoder.decode(pathFile,""String_Node_Str"");
      if (BuildConfig.DEBUG)       Log.d(LOGCAT,""String_Node_Str"" + pathFile);
      if (!core.changeDatabase(pathFile)) {
        Log.w(LOGCAT,""String_Node_Str"" + pathFile + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      Log.e(LOGCAT,e.getMessage());
    }
  }
  if (savedInstanceState != null) {
    if (savedInstanceState.containsKey(KEY_IS_AUTHENTICATED))     isAuthenticated=savedInstanceState.getBoolean(KEY_IS_AUTHENTICATED);
    if (savedInstanceState.containsKey(KEY_IN_AUTHENTICATION))     isInAuthentication=savedInstanceState.getBoolean(KEY_IN_AUTHENTICATION);
    if (savedInstanceState.containsKey(KEY_ORIENTATION)) {
      if (core.isTablet()) {
        if (savedInstanceState.getInt(KEY_ORIENTATION) != getResources().getConfiguration().orientation) {
          for (int i=0; i < getSupportFragmentManager().getBackStackEntryCount(); ++i) {
            getSupportFragmentManager().popBackStack();
          }
        }
      }
    }
  }
  try {
    core.initDatabase();
  }
 catch (  Exception e) {
    Log.e(LOGCAT,!TextUtils.isEmpty(e.getMessage()) ? e.getMessage() : ""String_Node_Str"");
  }
  CurrencyUtils currencyUtils=new CurrencyUtils(this);
  if (!currencyUtils.isInit())   currencyUtils.reInit();
  mDropboxHelper=DropboxHelper.getInstance(getApplicationContext());
  onCreateFragments(savedInstanceState);
  showTipsDialog(savedInstanceState);
  if (TextUtils.isEmpty(core.getInfoValue(Constants.INFOTABLE_SKU_ORDER_ID)))   MoneyManagerApplication.showDonateDialog(this,false);
  MoneyManagerApplication.showChangeLog(this,false);
  MoneyManagerApplication.showDatabasePathWork(this);
  Intent serviceRepeatingTransaction=new Intent(getApplicationContext(),MoneyManagerBootReceiver.class);
  getApplicationContext().sendBroadcast(serviceRepeatingTransaction);
}",0.911943793911007
64787,"@Override protected void onSaveInstanceState(Bundle outState){
  Core core=new Core(this);
  if (core.isTablet()) {
    Fragment fragment=getSupportFragmentManager().findFragmentById(getResIdLayoutContent());
    if (fragment != null) {
      if (fragment instanceof AccountFragment) {
        outState.putString(KEY_CLASS_FRAGMENT_CONTENT,((AccountFragment)fragment).getNameFragment());
      }
 else       if ((!(fragment instanceof DashboardFragment)) && (!(fragment instanceof HomeFragment))) {
        outState.putString(KEY_CLASS_FRAGMENT_CONTENT,fragment.getClass().getName());
      }
      for (int i=0; i < getSupportFragmentManager().getBackStackEntryCount(); ++i) {
        getSupportFragmentManager().popBackStack();
      }
    }
  }
  outState.putBoolean(KEY_IS_AUTHENTICATED,isAuthenticated);
  outState.putBoolean(KEY_IN_AUTHENTICATION,isInAuthentication);
  outState.putBoolean(KEY_IS_SHOW_TIPS_DROPBOX2,isShowTipsDropbox2);
  super.onSaveInstanceState(outState);
}","@Override protected void onSaveInstanceState(Bundle outState){
  Core core=new Core(this);
  if (core.isTablet()) {
    Fragment fragment=getSupportFragmentManager().findFragmentById(getResIdLayoutContent());
    if (fragment != null) {
      if (fragment instanceof AccountFragment) {
        outState.putString(KEY_CLASS_FRAGMENT_CONTENT,((AccountFragment)fragment).getNameFragment());
      }
 else       if ((!(fragment instanceof DashboardFragment)) && (!(fragment instanceof HomeFragment))) {
        outState.putString(KEY_CLASS_FRAGMENT_CONTENT,fragment.getClass().getName());
      }
    }
  }
  outState.putBoolean(KEY_IS_AUTHENTICATED,isAuthenticated);
  outState.putBoolean(KEY_IN_AUTHENTICATION,isInAuthentication);
  outState.putBoolean(KEY_IS_SHOW_TIPS_DROPBOX2,isShowTipsDropbox2);
  outState.putInt(KEY_ORIENTATION,getResources().getConfiguration().orientation);
  super.onSaveInstanceState(outState);
}",0.8807146610614819
64788,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  mCategorySub=new QueryCategorySubCategory(getActivity());
  mCategories=new ArrayList<TableCategory>();
  mSubCategories=new HashMap<TableCategory,List<QueryCategorySubCategory>>();
  if (savedInstanceState != null) {
    if (savedInstanceState.containsKey(KEY_ID_GROUP))     mIdGroupChecked=savedInstanceState.getInt(KEY_ID_GROUP);
    if (savedInstanceState.containsKey(KEY_ID_CHILD))     mIdChildChecked=savedInstanceState.getInt(KEY_ID_CHILD);
  }
  setShowMenuItemSearch(true);
  setEmptyText(getActivity().getResources().getString(R.string.category_empty_list));
  setHasOptionsMenu(true);
  mLayout=Intent.ACTION_PICK.equals(mAction) ? R.layout.simple_expandable_list_item_multiple_choice_2 : android.R.layout.simple_expandable_list_item_2;
  registerForContextMenu(getExpandableListView());
  getExpandableListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  setListShown(false);
  getExpandableListView().setOnChildClickListener(new OnChildClickListener(){
    @Override public boolean onChildClick(    ExpandableListView parent,    View v,    int groupPosition,    int childPosition,    long id){
      if (getExpandableListAdapter() != null && getExpandableListAdapter() instanceof CategoryExpandableListAdapter) {
        CategoryExpandableListAdapter adapter=(CategoryExpandableListAdapter)getExpandableListAdapter();
        QueryCategorySubCategory data=mSubCategories.get(mCategories.get(groupPosition)).get(childPosition);
        adapter.setIdChildChecked(data.getCategId(),data.getSubCategId());
        adapter.notifyDataSetChanged();
      }
      return false;
    }
  }
);
  getExpandableListView().setOnGroupClickListener(new OnGroupClickListener(){
    @Override public boolean onGroupClick(    ExpandableListView parent,    View v,    int groupPosition,    long id){
      if (getExpandableListAdapter() != null && getExpandableListAdapter() instanceof CategoryExpandableListAdapter) {
        CategoryExpandableListAdapter adapter=(CategoryExpandableListAdapter)getExpandableListAdapter();
        adapter.setIdGroupChecked(mCategories.get(groupPosition).getCategId());
        adapter.notifyDataSetChanged();
      }
      return false;
    }
  }
);
  getLoaderManager().initLoader(ID_LOADER_CATEGORYSUB,null,this);
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  mCategorySub=new QueryCategorySubCategory(getActivity());
  mCategories=new ArrayList<TableCategory>();
  mSubCategories=new HashMap<TableCategory,List<QueryCategorySubCategory>>();
  if (savedInstanceState != null) {
    if (savedInstanceState.containsKey(KEY_ID_GROUP))     mIdGroupChecked=savedInstanceState.getInt(KEY_ID_GROUP);
    if (savedInstanceState.containsKey(KEY_ID_CHILD))     mIdChildChecked=savedInstanceState.getInt(KEY_ID_CHILD);
  }
  setShowMenuItemSearch(true);
  setEmptyText(getActivity().getResources().getString(R.string.category_empty_list));
  setHasOptionsMenu(true);
  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
    mLayout=android.R.layout.simple_expandable_list_item_2;
  }
 else {
    mLayout=Intent.ACTION_PICK.equals(mAction) ? R.layout.simple_expandable_list_item_multiple_choice_2 : android.R.layout.simple_expandable_list_item_2;
  }
  registerForContextMenu(getExpandableListView());
  getExpandableListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  setListShown(false);
  if (Intent.ACTION_PICK.equals(mAction)) {
    getExpandableListView().setOnChildClickListener(new OnChildClickListener(){
      @Override public boolean onChildClick(      ExpandableListView parent,      View v,      int groupPosition,      int childPosition,      long id){
        if (getExpandableListAdapter() != null && getExpandableListAdapter() instanceof CategoryExpandableListAdapter) {
          CategoryExpandableListAdapter adapter=(CategoryExpandableListAdapter)getExpandableListAdapter();
          QueryCategorySubCategory data=mSubCategories.get(mCategories.get(groupPosition)).get(childPosition);
          adapter.setIdChildChecked(data.getCategId(),data.getSubCategId());
          adapter.notifyDataSetChanged();
        }
        return false;
      }
    }
);
    getExpandableListView().setOnGroupClickListener(new OnGroupClickListener(){
      @Override public boolean onGroupClick(      ExpandableListView parent,      View v,      int groupPosition,      long id){
        if (getExpandableListAdapter() != null && getExpandableListAdapter() instanceof CategoryExpandableListAdapter) {
          CategoryExpandableListAdapter adapter=(CategoryExpandableListAdapter)getExpandableListAdapter();
          adapter.setIdGroupChecked(mCategories.get(groupPosition).getCategId());
          adapter.notifyDataSetChanged();
        }
        return false;
      }
    }
);
  }
  getLoaderManager().initLoader(ID_LOADER_CATEGORYSUB,null,this);
}",0.9410821643286572
64789,"@Override public View getGroupView(int groupPosition,boolean isExpanded,View convertView,ViewGroup parent){
  ViewHolderGroup holder;
  if (convertView == null) {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    convertView=inflater.inflate(mLayout,null);
    holder=new ViewHolderGroup();
    holder.text1=(TextView)convertView.findViewById(android.R.id.text1);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolderGroup)convertView.getTag();
  }
  holder.text1.setText(((TableCategory)mCategories.get(groupPosition)).getCategName());
  if (holder.text1 instanceof CheckedTextView) {
    boolean isGroupChecked=mIdGroupChecked == ((TableCategory)mCategories.get(groupPosition)).getCategId();
    ((CheckedTextView)holder.text1).setChecked(isGroupChecked && mIdChildChecked == ListView.INVALID_POSITION);
    if (isGroupChecked) {
      ((ExpandableListView)parent).expandGroup(groupPosition,true);
    }
  }
  return convertView;
}","@Override public View getGroupView(int groupPosition,boolean isExpanded,View convertView,ViewGroup parent){
  ViewHolderGroup holder;
  if (convertView == null) {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    convertView=inflater.inflate(mLayout,null);
    holder=new ViewHolderGroup();
    holder.text1=(TextView)convertView.findViewById(android.R.id.text1);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolderGroup)convertView.getTag();
  }
  holder.text1.setText(((TableCategory)mCategories.get(groupPosition)).getCategName());
  boolean isGroupChecked=mIdGroupChecked == ((TableCategory)mCategories.get(groupPosition)).getCategId();
  if (holder.text1 instanceof CheckedTextView) {
    ((CheckedTextView)holder.text1).setChecked(isGroupChecked && mIdChildChecked == ListView.INVALID_POSITION);
    if (isGroupChecked) {
      ((ExpandableListView)parent).expandGroup(groupPosition,true);
    }
  }
 else   if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
    convertView.setBackgroundColor(mContext.getResources().getColor(isGroupChecked && mIdChildChecked == ExpandableListView.INVALID_POSITION ? R.color.holo_blue_light : android.R.color.transparent));
  }
  return convertView;
}",0.7770979020979021
64790,"@Override public View getChildView(int groupPosition,int childPosition,boolean isLastChild,View convertView,ViewGroup parent){
  ViewHolderChild holder;
  if (convertView == null) {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    convertView=inflater.inflate(mLayout,null);
    holder=new ViewHolderChild();
    holder.text1=(TextView)convertView.findViewById(android.R.id.text1);
    holder.text2=(TextView)convertView.findViewById(android.R.id.text2);
    convertView.setTag(holder);
  }
  holder=(ViewHolderChild)convertView.getTag();
  holder.text1.setText(((QueryCategorySubCategory)getChild(groupPosition,childPosition)).getSubCategName());
  holder.text2.setText(((QueryCategorySubCategory)getChild(groupPosition,childPosition)).getCategName());
  holder.text2.setTextColor(mContext.getResources().getColor(android.R.color.darker_gray));
  if (holder.text1 instanceof CheckedTextView) {
    ((CheckedTextView)holder.text1).setChecked(mIdChildChecked == ((QueryCategorySubCategory)getChild(groupPosition,childPosition)).getSubCategId());
  }
  return convertView;
}","@Override public View getChildView(int groupPosition,int childPosition,boolean isLastChild,View convertView,ViewGroup parent){
  ViewHolderChild holder;
  if (convertView == null) {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    convertView=inflater.inflate(mLayout,null);
    holder=new ViewHolderChild();
    holder.text1=(TextView)convertView.findViewById(android.R.id.text1);
    holder.text2=(TextView)convertView.findViewById(android.R.id.text2);
    convertView.setTag(holder);
  }
  holder=(ViewHolderChild)convertView.getTag();
  holder.text1.setText(((QueryCategorySubCategory)getChild(groupPosition,childPosition)).getSubCategName());
  holder.text2.setText(((QueryCategorySubCategory)getChild(groupPosition,childPosition)).getCategName());
  holder.text2.setTextColor(mContext.getResources().getColor(android.R.color.darker_gray));
  boolean isChildSelected=mIdChildChecked == ((QueryCategorySubCategory)getChild(groupPosition,childPosition)).getSubCategId();
  if (holder.text1 instanceof CheckedTextView) {
    ((CheckedTextView)holder.text1).setChecked(isChildSelected);
  }
 else   if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
    convertView.setBackgroundColor(mContext.getResources().getColor(isChildSelected ? R.color.holo_blue_light : android.R.color.transparent));
  }
  return convertView;
}",0.8126482213438735
64791,"@Override protected Boolean doInBackground(Void... params){
  AllDataAdapter allDataAdapter=(AllDataAdapter)getListAdapter();
  if (allDataAdapter == null || allDataAdapter.getCursor() == null)   return false;
  Cursor data=allDataAdapter.getCursor();
  try {
    CSVWriter csvWriter=new CSVWriter(new FileWriter(mFileName),CSVWriter.DEFAULT_SEPARATOR,CSVWriter.NO_QUOTE_CHARACTER);
    data.moveToFirst();
    while (!data.isAfterLast()) {
      String[] record=new String[7];
      record[0]=data.getString(data.getColumnIndex(QueryAllData.UserDate));
      record[1]=data.getString(data.getColumnIndex(QueryAllData.Payee));
      record[2]=Float.toString(data.getFloat(data.getColumnIndex(QueryAllData.UserDate)));
      record[3]=data.getString(data.getColumnIndex(QueryAllData.Category));
      record[4]=data.getString(data.getColumnIndex(QueryAllData.Subcategory));
      record[5]=Integer.toString(data.getInt(data.getColumnIndex(QueryAllData.TransactionNumber)));
      record[6]=data.getString(data.getColumnIndex(QueryAllData.Notes));
      csvWriter.writeNext(record);
      data.moveToNext();
    }
    csvWriter.close();
  }
 catch (  Exception e) {
    Log.e(LOGCAT,e.getMessage());
    return false;
  }
  return true;
}","@Override protected Boolean doInBackground(Void... params){
  AllDataAdapter allDataAdapter=(AllDataAdapter)getListAdapter();
  if (allDataAdapter == null || allDataAdapter.getCursor() == null)   return false;
  Cursor data=allDataAdapter.getCursor();
  try {
    CSVWriter csvWriter=new CSVWriter(new FileWriter(mFileName),CSVWriter.DEFAULT_SEPARATOR,CSVWriter.NO_QUOTE_CHARACTER);
    data.moveToFirst();
    while (!data.isAfterLast()) {
      String[] record=new String[7];
      record[0]=data.getString(data.getColumnIndex(QueryAllData.UserDate));
      if (!TextUtils.isEmpty(data.getString(data.getColumnIndex(QueryAllData.Payee)))) {
        record[1]=data.getString(data.getColumnIndex(QueryAllData.Payee));
      }
 else {
        record[1]=data.getString(data.getColumnIndex(QueryAllData.ToAccountName));
      }
      record[2]=Float.toString(data.getFloat(data.getColumnIndex(QueryAllData.Amount)));
      record[3]=data.getString(data.getColumnIndex(QueryAllData.Category));
      record[4]=data.getString(data.getColumnIndex(QueryAllData.Subcategory));
      record[5]=Integer.toString(data.getInt(data.getColumnIndex(QueryAllData.TransactionNumber)));
      record[6]=data.getString(data.getColumnIndex(QueryAllData.Notes));
      csvWriter.writeNext(record);
      data.moveToNext();
    }
    csvWriter.close();
  }
 catch (  Exception e) {
    Log.e(LOGCAT,e.getMessage());
    return false;
  }
  return true;
}",0.9205397301349324
64792,"/** 
 * update data into database
 * @return true if update data successful 
 */
private boolean updateData(){
  if (validateData() == false) {
    return false;
  }
  ContentValues values=new ContentValues();
  values.put(TableCheckingAccount.ACCOUNTID,mAccountId);
  if (mTransCode.equals(""String_Node_Str"")) {
    values.put(TableCheckingAccount.TOACCOUNTID,mToAccountId);
    values.put(TableCheckingAccount.PAYEEID,-1);
  }
 else {
    values.put(TableCheckingAccount.PAYEEID,mPayeeId);
  }
  values.put(TableCheckingAccount.TRANSCODE,mTransCode);
  if (TextUtils.isEmpty(edtAmount.getText().toString()) == false) {
    values.put(TableCheckingAccount.TRANSAMOUNT,Float.valueOf(edtAmount.getText().toString()));
  }
 else {
    values.put(TableCheckingAccount.TRANSAMOUNT,Float.valueOf(edtTotAmount.getText().toString()));
  }
  values.put(TableCheckingAccount.STATUS,mStatus);
  values.put(TableCheckingAccount.CATEGID,mCategoryId);
  values.put(TableCheckingAccount.SUBCATEGID,mSubCategoryId);
  values.put(TableCheckingAccount.TRANSDATE,this.getDate());
  values.put(TableCheckingAccount.FOLLOWUPID,-1);
  values.put(TableCheckingAccount.TOTRANSAMOUNT,Float.valueOf(edtTotAmount.getText().toString()));
  values.put(TableCheckingAccount.NOTES,edtNotes.getText().toString());
  if (mIntentAction.equals(INTENT_ACTION_INSERT)) {
    if (getContentResolver().insert(mCheckingAccount.getUri(),values) == null) {
      Toast.makeText(this,R.string.db_checking_insert_failed,Toast.LENGTH_SHORT).show();
      Log.w(LOGCAT,""String_Node_Str"");
      return false;
    }
  }
 else {
    if (getContentResolver().update(mCheckingAccount.getUri(),values,TableCheckingAccount.TRANSID + ""String_Node_Str"",new String[]{Integer.toString(mTransId)}) <= 0) {
      Toast.makeText(this,R.string.db_checking_update_failed,Toast.LENGTH_SHORT).show();
      Log.w(LOGCAT,""String_Node_Str"");
      return false;
    }
  }
  if (mPayeeId > 0) {
    values.clear();
    values.put(TablePayee.CATEGID,mCategoryId);
    values.put(TablePayee.SUBCATEGID,mSubCategoryId);
    TablePayee payee=new TablePayee();
    if (getContentResolver().update(payee.getUri(),values,TablePayee.PAYEEID + ""String_Node_Str"" + Integer.toString(mPayeeId),null) <= 0) {
      Toast.makeText(this,R.string.db_payee_update_failed,Toast.LENGTH_SHORT).show();
      Log.w(LOGCAT,""String_Node_Str"" + Integer.toString(mPayeeId) + ""String_Node_Str"");
    }
  }
  return true;
}","/** 
 * update data into database
 * @return true if update data successful 
 */
private boolean updateData(){
  if (validateData() == false) {
    return false;
  }
  ContentValues values=new ContentValues();
  values.put(TableCheckingAccount.ACCOUNTID,mAccountId);
  if (mTransCode.equals(""String_Node_Str"")) {
    values.put(TableCheckingAccount.TOACCOUNTID,mToAccountId);
    values.put(TableCheckingAccount.PAYEEID,-1);
  }
 else {
    values.put(TableCheckingAccount.PAYEEID,mPayeeId);
  }
  values.put(TableCheckingAccount.TRANSCODE,mTransCode);
  if (TextUtils.isEmpty(edtAmount.getText().toString()) || (!(mTransCode.equalsIgnoreCase(""String_Node_Str"")))) {
    values.put(TableCheckingAccount.TRANSAMOUNT,Float.valueOf(edtTotAmount.getText().toString()));
  }
 else {
    values.put(TableCheckingAccount.TRANSAMOUNT,Float.valueOf(edtAmount.getText().toString()));
  }
  values.put(TableCheckingAccount.STATUS,mStatus);
  values.put(TableCheckingAccount.CATEGID,mCategoryId);
  values.put(TableCheckingAccount.SUBCATEGID,mSubCategoryId);
  values.put(TableCheckingAccount.TRANSDATE,this.getDate());
  values.put(TableCheckingAccount.FOLLOWUPID,-1);
  values.put(TableCheckingAccount.TOTRANSAMOUNT,Float.valueOf(edtTotAmount.getText().toString()));
  values.put(TableCheckingAccount.NOTES,edtNotes.getText().toString());
  if (mIntentAction.equals(INTENT_ACTION_INSERT)) {
    if (getContentResolver().insert(mCheckingAccount.getUri(),values) == null) {
      Toast.makeText(this,R.string.db_checking_insert_failed,Toast.LENGTH_SHORT).show();
      Log.w(LOGCAT,""String_Node_Str"");
      return false;
    }
  }
 else {
    if (getContentResolver().update(mCheckingAccount.getUri(),values,TableCheckingAccount.TRANSID + ""String_Node_Str"",new String[]{Integer.toString(mTransId)}) <= 0) {
      Toast.makeText(this,R.string.db_checking_update_failed,Toast.LENGTH_SHORT).show();
      Log.w(LOGCAT,""String_Node_Str"");
      return false;
    }
  }
  if ((!(mTransCode.equalsIgnoreCase(""String_Node_Str""))) && (mPayeeId > 0)) {
    values.clear();
    values.put(TablePayee.CATEGID,mCategoryId);
    values.put(TablePayee.SUBCATEGID,mSubCategoryId);
    TablePayee payee=new TablePayee();
    if (getContentResolver().update(payee.getUri(),values,TablePayee.PAYEEID + ""String_Node_Str"" + Integer.toString(mPayeeId),null) <= 0) {
      Toast.makeText(this,R.string.db_payee_update_failed,Toast.LENGTH_SHORT).show();
      Log.w(LOGCAT,""String_Node_Str"" + Integer.toString(mPayeeId) + ""String_Node_Str"");
    }
  }
  return true;
}",0.9748237663645518
64793,"@Override protected void setResult(){
  if (mAction.equals(Intent.ACTION_PICK)) {
    Intent result=new Intent();
    Cursor cursor=((SimpleCursorAdapter)getListView().getAdapter()).getCursor();
    for (int i=0; i < getListView().getCount(); i++) {
      if (getListView().isItemChecked(i)) {
        cursor.moveToPosition(i);
        result.putExtra(INTENT_RESULT_ACCOUNTID,cursor.getInt(cursor.getColumnIndex(TableAccountList.ACCOUNTID)));
        result.putExtra(INTENT_RESULT_ACCOUNTNAME,cursor.getString(cursor.getColumnIndex(TableAccountList.ACCOUNTNAME)));
        break;
      }
    }
    getActivity().setResult(Activity.RESULT_OK,result);
  }
  return;
}","@Override protected void setResult(){
  if (mAction.equals(Intent.ACTION_PICK)) {
    Intent result=new Intent();
    Cursor cursor=((SimpleCursorAdapter)getListAdapter()).getCursor();
    for (int i=0; i < getListView().getCount(); i++) {
      if (getListView().isItemChecked(i)) {
        cursor.moveToPosition(i);
        result.putExtra(INTENT_RESULT_ACCOUNTID,cursor.getInt(cursor.getColumnIndex(TableAccountList.ACCOUNTID)));
        result.putExtra(INTENT_RESULT_ACCOUNTNAME,cursor.getString(cursor.getColumnIndex(TableAccountList.ACCOUNTNAME)));
        break;
      }
    }
    getActivity().setResult(Activity.RESULT_OK,result);
  }
  return;
}",0.9924242424242424
64794,"@Override public boolean onContextItemSelected(MenuItem item){
  AdapterView.AdapterContextMenuInfo info=(AdapterView.AdapterContextMenuInfo)item.getMenuInfo();
  Cursor cursor=((SimpleCursorAdapter)getListView().getAdapter()).getCursor();
  cursor.moveToPosition(info.position);
switch (item.getItemId()) {
case 0:
    startAccountListEditActivity(cursor.getInt(cursor.getColumnIndex(TableAccountList.ACCOUNTID)));
  break;
case 1:
showDialogDeleteAccount(cursor.getInt(cursor.getColumnIndex(TableAccountList.ACCOUNTID)));
break;
}
return false;
}","@Override public boolean onContextItemSelected(MenuItem item){
  AdapterView.AdapterContextMenuInfo info=(AdapterView.AdapterContextMenuInfo)item.getMenuInfo();
  Cursor cursor=((SimpleCursorAdapter)getListAdapter()).getCursor();
  cursor.moveToPosition(info.position);
switch (item.getItemId()) {
case 0:
    startAccountListEditActivity(cursor.getInt(cursor.getColumnIndex(TableAccountList.ACCOUNTID)));
  break;
case 1:
showDialogDeleteAccount(cursor.getInt(cursor.getColumnIndex(TableAccountList.ACCOUNTID)));
break;
}
return false;
}",0.990791896869245
64795,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setShowMenuItemSearch(true);
  setEmptyText(getActivity().getResources().getString(R.string.account_empty_list));
  setHasOptionsMenu(true);
  mLayout=mAction.equals(Intent.ACTION_PICK) ? android.R.layout.simple_list_item_multiple_choice : android.R.layout.simple_list_item_1;
  registerForContextMenu(getListView());
  getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  setListShown(false);
  getLoaderManager().initLoader(ID_LOADER_ACCOUNT,null,this);
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setShowMenuItemSearch(true);
  setEmptyText(getActivity().getResources().getString(R.string.account_empty_list));
  setHasOptionsMenu(true);
  mLayout=mAction.equals(Intent.ACTION_PICK) ? android.R.layout.simple_list_item_multiple_choice : android.R.layout.simple_list_item_1;
  SimpleCursorAdapter adapter=new SimpleCursorAdapter(getActivity(),mLayout,null,new String[]{TableAccountList.ACCOUNTNAME},new int[]{android.R.id.text1},0);
  setListAdapter(adapter);
  registerForContextMenu(getListView());
  getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  setListShown(false);
  getLoaderManager().initLoader(ID_LOADER_ACCOUNT,null,this);
}",0.8626577579806979
64796,"@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
switch (loader.getId()) {
case ID_LOADER_ACCOUNT:
    SimpleCursorAdapter adapter=new SimpleCursorAdapter(getActivity(),mLayout,data,new String[]{TableAccountList.ACCOUNTNAME},new int[]{android.R.id.text1},0);
  getListView().setAdapter(adapter);
if (isResumed()) {
  setListShown(true);
}
 else {
  setListShownNoAnimation(true);
}
}
}","@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
switch (loader.getId()) {
case ID_LOADER_ACCOUNT:
    ((SimpleCursorAdapter)getListAdapter()).swapCursor(data);
  if (isResumed()) {
    setListShown(true);
  }
 else {
    setListShownNoAnimation(true);
  }
}
}",0.4444444444444444
64797,"@Override public void onCreateContextMenu(ContextMenu menu,View v,ContextMenuInfo menuInfo){
  AdapterView.AdapterContextMenuInfo info=(AdapterView.AdapterContextMenuInfo)menuInfo;
  Cursor cursor=((SimpleCursorAdapter)getListView().getAdapter()).getCursor();
  cursor.moveToPosition(info.position);
  menu.setHeaderTitle(cursor.getString(cursor.getColumnIndex(TableAccountList.ACCOUNTNAME)));
  String[] menuItems=getResources().getStringArray(R.array.context_menu);
  for (int i=0; i < menuItems.length; i++) {
    menu.add(Menu.NONE,i,i,menuItems[i]);
  }
}","@Override public void onCreateContextMenu(ContextMenu menu,View v,ContextMenuInfo menuInfo){
  AdapterView.AdapterContextMenuInfo info=(AdapterView.AdapterContextMenuInfo)menuInfo;
  Cursor cursor=((SimpleCursorAdapter)getListAdapter()).getCursor();
  cursor.moveToPosition(info.position);
  menu.setHeaderTitle(cursor.getString(cursor.getColumnIndex(TableAccountList.ACCOUNTNAME)));
  String[] menuItems=getResources().getStringArray(R.array.context_menu);
  for (int i=0; i < menuItems.length; i++) {
    menu.add(Menu.NONE,i,i,menuItems[i]);
  }
}",0.990990990990991
64798,"/** 
 * {@inheritDoc}
 */
@Override public void initialize(GraphDatabaseService database){
  if (!configuration.isAutoAttach()) {
    return;
  }
  new IterableInputBatchTransactionExecutor<>(database,1000,new AllNodes(database,1000),new UnitOfWork<Node>(){
    @Override public void execute(    GraphDatabaseService database,    Node input,    int batchNumber,    int stepNumber){
      if (stepNumber == 1) {
        LOG.info(""String_Node_Str"" + batchNumber);
      }
      if (configuration.getInclusionPolicies().getNodeInclusionPolicy().include(input)) {
        deleteTimeTreeRelationship(input);
        createTimeTreeRelationship(input);
      }
    }
  }
).execute();
}","/** 
 * {@inheritDoc}
 */
@Override public void initialize(GraphDatabaseService database){
  if (!configuration.isAutoAttach()) {
    return;
  }
  new IterableInputBatchTransactionExecutor<>(database,1000,new TransactionalInput<>(database,1000,new TransactionCallback<Iterable<Node>>(){
    @Override public Iterable<Node> doInTransaction(    GraphDatabaseService database) throws Exception {
      return configuration.getInclusionPolicies().getNodeInclusionPolicy().getAll(database);
    }
  }
),new UnitOfWork<Node>(){
    @Override public void execute(    GraphDatabaseService database,    Node input,    int batchNumber,    int stepNumber){
      if (stepNumber == 1) {
        LOG.info(""String_Node_Str"" + batchNumber);
      }
      if (configuration.getInclusionPolicies().getNodeInclusionPolicy().include(input)) {
        deleteTimeTreeRelationship(input);
        createTimeTreeRelationship(input);
      }
    }
  }
).execute();
}",0.8266502159161012
64799,"/** 
 * {@inheritDoc}
 */
@Override public Void beforeCommit(ImprovedTransactionData transactionData) throws DeliberateTransactionRollbackException {
  for (  Node created : transactionData.getAllCreatedNodes()) {
    createTimeTreeRelationship(created);
  }
  for (  Change<Node> change : transactionData.getAllChangedNodes()) {
    if (transactionData.hasPropertyBeenChanged(change.getPrevious(),configuration.getTimestampProperty()) || transactionData.hasPropertyBeenChanged(change.getPrevious(),configuration.getCustomTimeTreeRootProperty()) || transactionData.hasPropertyBeenDeleted(change.getPrevious(),configuration.getTimestampProperty())|| transactionData.hasPropertyBeenDeleted(change.getPrevious(),configuration.getCustomTimeTreeRootProperty())) {
      deleteTimeTreeRelationship(change.getPrevious());
      createTimeTreeRelationship(change.getCurrent());
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public Void beforeCommit(ImprovedTransactionData transactionData) throws DeliberateTransactionRollbackException {
  for (  Node created : transactionData.getAllCreatedNodes()) {
    createTimeTreeRelationship(created);
  }
  for (  Change<Node> change : transactionData.getAllChangedNodes()) {
    if (shouldReattach(transactionData,change)) {
      deleteTimeTreeRelationship(change.getPrevious());
      createTimeTreeRelationship(change.getCurrent());
    }
  }
  return null;
}",0.4996461429582449
64800,"/** 
 * {@inheritDoc}
 */
@Override public Void beforeCommit(ImprovedTransactionData transactionData) throws DeliberateTransactionRollbackException {
  for (  Node created : transactionData.getAllCreatedNodes()) {
    createTimeTreeRelationship(created);
  }
  for (  Change<Node> change : transactionData.getAllChangedNodes()) {
    if (transactionData.hasPropertyBeenChanged(change.getPrevious(),configuration.getTimestampProperty())) {
      deleteTimeTreeRelationship(change.getPrevious());
      createTimeTreeRelationship(change.getCurrent());
    }
    if (transactionData.hasPropertyBeenChanged(change.getPrevious(),configuration.getCustomTimeTreeRootProperty())) {
      deleteTimeTreeRelationship(change.getPrevious());
      createTimeTreeRelationship(change.getCurrent());
    }
    if (transactionData.hasPropertyBeenDeleted(change.getPrevious(),configuration.getTimestampProperty())) {
      deleteTimeTreeRelationship(change.getPrevious());
    }
    if (transactionData.hasPropertyBeenDeleted(change.getPrevious(),configuration.getCustomTimeTreeRootProperty())) {
      deleteTimeTreeRelationship(change.getPrevious());
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public Void beforeCommit(ImprovedTransactionData transactionData) throws DeliberateTransactionRollbackException {
  for (  Node created : transactionData.getAllCreatedNodes()) {
    createTimeTreeRelationship(created);
  }
  for (  Change<Node> change : transactionData.getAllChangedNodes()) {
    if (transactionData.hasPropertyBeenChanged(change.getPrevious(),configuration.getTimestampProperty()) || transactionData.hasPropertyBeenChanged(change.getPrevious(),configuration.getCustomTimeTreeRootProperty()) || transactionData.hasPropertyBeenDeleted(change.getPrevious(),configuration.getTimestampProperty())|| transactionData.hasPropertyBeenDeleted(change.getPrevious(),configuration.getCustomTimeTreeRootProperty())) {
      deleteTimeTreeRelationship(change.getPrevious());
      createTimeTreeRelationship(change.getCurrent());
    }
  }
  return null;
}",0.8066083576287658
64801,"/** 
 * {@inheritDoc}
 */
@Override public void initialize(GraphDatabaseService database){
  if (!configuration.isAutoAttach()) {
    return;
  }
  new IterableInputBatchTransactionExecutor<>(database,1000,new TransactionCallback<Iterable<Node>>(){
    @Override public Iterable<Node> doInTransaction(    GraphDatabaseService database) throws Exception {
      return GlobalGraphOperations.at(database).getAllNodes();
    }
  }
,new UnitOfWork<Node>(){
    @Override public void execute(    GraphDatabaseService database,    Node input,    int batchNumber,    int stepNumber){
      if (stepNumber == 1) {
        LOG.info(""String_Node_Str"" + batchNumber);
      }
      if (configuration.getInclusionPolicies().getNodeInclusionPolicy().include(input)) {
        createTimeTreeRelationship(input);
      }
    }
  }
).execute();
}","/** 
 * {@inheritDoc}
 */
@Override public void initialize(GraphDatabaseService database){
  if (!configuration.isAutoAttach()) {
    return;
  }
  new IterableInputBatchTransactionExecutor<>(database,1000,new TransactionCallback<Iterable<Node>>(){
    @Override public Iterable<Node> doInTransaction(    GraphDatabaseService database) throws Exception {
      return GlobalGraphOperations.at(database).getAllNodes();
    }
  }
,new UnitOfWork<Node>(){
    @Override public void execute(    GraphDatabaseService database,    Node input,    int batchNumber,    int stepNumber){
      if (stepNumber == 1) {
        LOG.info(""String_Node_Str"" + batchNumber);
      }
      if (configuration.getInclusionPolicies().getNodeInclusionPolicy().include(input)) {
        deleteTimeTreeRelationship(input);
        createTimeTreeRelationship(input);
      }
    }
  }
).execute();
}",0.9700528479154432
64802,"@Override public void execute(GraphDatabaseService database,Node input,int batchNumber,int stepNumber){
  if (stepNumber == 1) {
    LOG.info(""String_Node_Str"" + batchNumber);
  }
  if (configuration.getInclusionPolicies().getNodeInclusionPolicy().include(input)) {
    createTimeTreeRelationship(input);
  }
}","@Override public void execute(GraphDatabaseService database,Node input,int batchNumber,int stepNumber){
  if (stepNumber == 1) {
    LOG.info(""String_Node_Str"" + batchNumber);
  }
  if (configuration.getInclusionPolicies().getNodeInclusionPolicy().include(input)) {
    deleteTimeTreeRelationship(input);
    createTimeTreeRelationship(input);
  }
}",0.928679817905918
64803,"/** 
 * Find a child node with value equal to the given value. If no such child exists, return <code>null</code>.
 * @param parent parent of the node to be found.
 * @param value  value of the node to be found.
 * @return child node, <code>null</code> of none exists.
 */
private Node findChild(Node parent,int value,ChildNotFoundPolicy childNotFoundPolicy){
  Relationship firstRelationship=parent.getSingleRelationship(FIRST,OUTGOING);
  if (firstRelationship == null) {
    return null;
  }
  Node existingChild=firstRelationship.getEndNode();
  while (getInt(existingChild,VALUE_PROPERTY) < value && parent(existingChild).equals(parent)) {
    Relationship nextRelationship=existingChild.getSingleRelationship(NEXT,OUTGOING);
    if (nextRelationship == null) {
switch (childNotFoundPolicy) {
case RETURN_NULL:
        return null;
case RETURN_NEXT:
      return null;
case RETURN_PREVIOUS:
    return existingChild;
}
}
if (!parent(nextRelationship.getEndNode()).equals(parent)) {
switch (childNotFoundPolicy) {
case RETURN_NULL:
  return null;
case RETURN_NEXT:
return nextRelationship.getEndNode();
case RETURN_PREVIOUS:
return existingChild;
}
}
existingChild=nextRelationship.getEndNode();
}
if (getInt(existingChild,VALUE_PROPERTY) == value) {
return existingChild;
}
switch (childNotFoundPolicy) {
case RETURN_NULL:
return null;
case RETURN_NEXT:
return existingChild;
case RETURN_PREVIOUS:
return existingChild.getSingleRelationship(NEXT,INCOMING).getStartNode();
default :
throw new IllegalStateException(""String_Node_Str"" + childNotFoundPolicy);
}
}","/** 
 * Find a child node with value equal to the given value. If no such child exists, return <code>null</code>.
 * @param parent parent of the node to be found.
 * @param value  value of the node to be found.
 * @return child node, <code>null</code> of none exists.
 */
private Node findChild(Node parent,int value,ChildNotFoundPolicy childNotFoundPolicy){
  Relationship firstRelationship=parent.getSingleRelationship(FIRST,OUTGOING);
  if (firstRelationship == null) {
    return null;
  }
  Node existingChild=firstRelationship.getEndNode();
  while (getInt(existingChild,VALUE_PROPERTY) < value && parent(existingChild).equals(parent)) {
    Relationship nextRelationship=existingChild.getSingleRelationship(NEXT,OUTGOING);
    if (nextRelationship == null) {
switch (childNotFoundPolicy) {
case RETURN_NULL:
        return null;
case RETURN_NEXT:
      return null;
case RETURN_PREVIOUS:
    return existingChild;
}
}
if (!parent(nextRelationship.getEndNode()).equals(parent)) {
switch (childNotFoundPolicy) {
case RETURN_NULL:
  return null;
case RETURN_NEXT:
return nextRelationship.getEndNode();
case RETURN_PREVIOUS:
return existingChild;
}
}
existingChild=nextRelationship.getEndNode();
}
if (getInt(existingChild,VALUE_PROPERTY) == value) {
return existingChild;
}
switch (childNotFoundPolicy) {
case RETURN_NULL:
return null;
case RETURN_NEXT:
return existingChild;
case RETURN_PREVIOUS:
return existingChild.getSingleRelationship(NEXT,INCOMING) == null ? null : existingChild.getSingleRelationship(NEXT,INCOMING).getStartNode();
default :
throw new IllegalStateException(""String_Node_Str"" + childNotFoundPolicy);
}
}",0.97871008140263
64804,"@Test public void multipleEventsShouldBeFetchedForATimeInstant(){
  DateTime now=DateTime.now(UTC);
  TimeInstant timeInstant=TimeInstant.now();
  Node event1, event2;
  try (Transaction tx=getDatabase().beginTx()){
    event1=getDatabase().createNode();
    event1.setProperty(""String_Node_Str"",""String_Node_Str"");
    event2=getDatabase().createNode();
    event2.setProperty(""String_Node_Str"",""String_Node_Str"");
    tx.success();
  }
   try (Transaction tx=getDatabase().beginTx()){
    timedEvents.attachEvent(event1,AT_TIME,timeInstant);
    timedEvents.attachEvent(event2,AT_TIME,timeInstant);
    tx.success();
  }
   try (Transaction tx=getDatabase().beginTx()){
    List<String> eventNames=new ArrayList<>();
    List<Event> events=timedEvents.getEvents(timeInstant);
    assertEquals(2,events.size());
    eventNames.add((String)events.get(0).getNode().getProperty(""String_Node_Str""));
    eventNames.add((String)events.get(1).getNode().getProperty(""String_Node_Str""));
    assertTrue(eventNames.contains(""String_Node_Str""));
    assertTrue(eventNames.contains(""String_Node_Str""));
    tx.success();
  }
 }","@Test public void multipleEventsShouldBeFetchedForATimeInstant(){
  TimeInstant timeInstant=TimeInstant.now();
  Node event1, event2;
  try (Transaction tx=getDatabase().beginTx()){
    event1=getDatabase().createNode();
    event1.setProperty(""String_Node_Str"",""String_Node_Str"");
    event2=getDatabase().createNode();
    event2.setProperty(""String_Node_Str"",""String_Node_Str"");
    tx.success();
  }
   try (Transaction tx=getDatabase().beginTx()){
    timedEvents.attachEvent(event1,AT_TIME,timeInstant);
    timedEvents.attachEvent(event2,AT_TIME,timeInstant);
    tx.success();
  }
   try (Transaction tx=getDatabase().beginTx()){
    List<String> eventNames=new ArrayList<>();
    List<Event> events=timedEvents.getEvents(timeInstant);
    assertEquals(2,events.size());
    eventNames.add((String)events.get(0).getNode().getProperty(""String_Node_Str""));
    eventNames.add((String)events.get(1).getNode().getProperty(""String_Node_Str""));
    assertTrue(eventNames.contains(""String_Node_Str""));
    assertTrue(eventNames.contains(""String_Node_Str""));
    tx.success();
  }
 }",0.9845454545454544
64805,"@Test public void eventShouldBeFetchedForATimeInstant(){
  DateTime now=DateTime.now(UTC);
  TimeInstant timeInstant=TimeInstant.now();
  Node event;
  try (Transaction tx=getDatabase().beginTx()){
    event=getDatabase().createNode();
    event.setProperty(""String_Node_Str"",""String_Node_Str"");
    tx.success();
  }
   try (Transaction tx=getDatabase().beginTx()){
    timedEvents.attachEvent(event,AT_TIME,timeInstant);
    tx.success();
  }
   try (Transaction tx=getDatabase().beginTx()){
    List<Event> events=timedEvents.getEvents(timeInstant);
    assertEquals(1,events.size());
    assertEquals(""String_Node_Str"",events.get(0).getNode().getProperty(""String_Node_Str""));
    assertEquals(""String_Node_Str"",events.get(0).getRelationshipType().name());
    tx.success();
  }
 }","@Test public void eventShouldBeFetchedForATimeInstant(){
  TimeInstant timeInstant=TimeInstant.now();
  Node event;
  try (Transaction tx=getDatabase().beginTx()){
    event=getDatabase().createNode();
    event.setProperty(""String_Node_Str"",""String_Node_Str"");
    tx.success();
  }
   try (Transaction tx=getDatabase().beginTx()){
    timedEvents.attachEvent(event,AT_TIME,timeInstant);
    tx.success();
  }
   try (Transaction tx=getDatabase().beginTx()){
    List<Event> events=timedEvents.getEvents(timeInstant);
    assertEquals(1,events.size());
    assertEquals(""String_Node_Str"",events.get(0).getNode().getProperty(""String_Node_Str""));
    assertEquals(""String_Node_Str"",events.get(0).getRelationshipType().name());
    tx.success();
  }
 }",0.9778357235984356
64806,"private Node getInstant(Node parent,DateTime dateTime,Resolution targetResolution,ChildNotFoundPolicy childNotFoundPolicy){
  Resolution currentResolution=currentResolution(parent);
  if (targetResolution.equals(currentResolution)) {
    return parent;
  }
  Resolution newCurrentResolution=childResolution(parent);
  Node child=findChild(parent,dateTime.get(newCurrentResolution.getDateTimeFieldType()),RETURN_NULL);
  if (child == null) {
    if (currentResolution == null) {
      return null;
    }
switch (childNotFoundPolicy) {
case RETURN_NULL:
      return null;
case RETURN_NEXT:
    return getInstantViaClosestChild(parent,dateTime,targetResolution,childNotFoundPolicy,newCurrentResolution,FIRST);
case RETURN_PREVIOUS:
  return getInstantViaClosestChild(parent,dateTime,targetResolution,childNotFoundPolicy,newCurrentResolution,LAST);
}
}
return getInstant(child,dateTime,targetResolution,childNotFoundPolicy);
}","private Node getInstant(Node parent,DateTime dateTime,Resolution targetResolution,ChildNotFoundPolicy childNotFoundPolicy){
  Resolution currentResolution=currentResolution(parent);
  if (targetResolution.equals(currentResolution)) {
    return parent;
  }
  Resolution newCurrentResolution=childResolution(parent);
  Node child=findChild(parent,dateTime.get(newCurrentResolution.getDateTimeFieldType()),RETURN_NULL);
  if (child == null) {
switch (childNotFoundPolicy) {
case RETURN_NULL:
      return null;
case RETURN_NEXT:
    return getInstantViaClosestChild(parent,dateTime,targetResolution,childNotFoundPolicy,newCurrentResolution,FIRST);
case RETURN_PREVIOUS:
  return getInstantViaClosestChild(parent,dateTime,targetResolution,childNotFoundPolicy,newCurrentResolution,LAST);
}
}
return getInstant(child,dateTime,targetResolution,childNotFoundPolicy);
}",0.9652466367713004
64807,"/** 
 * {@inheritDoc}
 */
@Override public List<Event> getEvents(TimeInstant startTime,TimeInstant endTime,RelationshipType type){
  List<Event> events=new ArrayList<>();
  for (  TimeInstant instant : TimeInstant.getInstants(startTime,endTime)) {
    events.addAll(getEvents(instant,type));
  }
  return events;
}","/** 
 * {@inheritDoc}
 */
@Override public List<Event> getEvents(TimeInstant startTime,TimeInstant endTime,RelationshipType type){
  if (startTime.isAfter(endTime)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!startTime.compatibleWith(endTime)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Event> events=new ArrayList<>();
  Node startTimeNode=timeTree.getOrCreateInstant(startTime);
  Node endTimeNode=timeTree.getOrCreateInstant(endTime);
  events.addAll(getEventsAttachedToNodeAndChildren(startTimeNode,type));
  Relationship next=startTimeNode.getSingleRelationship(NEXT,OUTGOING);
  while (next != null && !(next.getEndNode().equals(endTimeNode))) {
    Node timeInstant=next.getEndNode();
    events.addAll(getEventsAttachedToNodeAndChildren(timeInstant,type));
    next=timeInstant.getSingleRelationship(NEXT,OUTGOING);
  }
  events.addAll(getEventsAttachedToNodeAndChildren(endTimeNode,type));
  return events;
}",0.343167701863354
64808,"/** 
 * Get the root of the time tree. Create it if it does not exist.
 * @return root of the time tree.
 */
protected Node getTimeRoot(){
  Node result;
  Iterator<Node> nodeIterator=GlobalGraphOperations.at(database).getAllNodesWithLabel(TimeTreeRoot).iterator();
  if (nodeIterator.hasNext()) {
    result=nodeIterator.next();
    if (nodeIterator.hasNext()) {
      LOG.error(""String_Node_Str"");
      throw new IllegalStateException(""String_Node_Str"");
    }
    return result;
  }
  LOG.info(""String_Node_Str"");
  return database.createNode(TimeTreeRoot);
}","/** 
 * Get the root of the time tree. Create it if it does not exist.
 * @return root of the time tree.
 */
protected Node getTimeRoot(){
  if (timeTreeRoot != null) {
    return timeTreeRoot;
  }
synchronized (this) {
    if (timeTreeRoot != null) {
      return timeTreeRoot;
    }
    Node result;
    Iterator<Node> nodeIterator=GlobalGraphOperations.at(database).getAllNodesWithLabel(TimeTreeRoot).iterator();
    if (nodeIterator.hasNext()) {
      result=nodeIterator.next();
      if (nodeIterator.hasNext()) {
        LOG.error(""String_Node_Str"");
        throw new IllegalStateException(""String_Node_Str"");
      }
      return result;
    }
    LOG.info(""String_Node_Str"");
    timeTreeRoot=database.createNode(TimeTreeRoot);
    return timeTreeRoot;
  }
}",0.7933884297520661
64809,"/** 
 * {@inheritDoc}
 */
@Override public Node getNow(DateTimeZone timeZone,Resolution resolution){
  return getInstant(DateTime.now().getMillis(),timeZone,resolution);
}","/** 
 * {@inheritDoc}
 */
@Override public Node getNow(DateTimeZone timeZone,Resolution resolution,Transaction tx){
  return getInstant(DateTime.now().getMillis(),timeZone,resolution,tx);
}",0.95
64810,"/** 
 * {@inheritDoc}
 */
@Override public List<Node> getInstants(long startTime,long endTime,DateTimeZone timeZone,Resolution resolution){
  if (timeZone == null) {
    timeZone=this.timeZone;
  }
  if (resolution == null) {
    resolution=this.resolution;
  }
  List<Node> result=new LinkedList<>();
  MutableDateTime time=new MutableDateTime(startTime);
  while (!time.isAfter(endTime)) {
    result.add(getInstant(time.getMillis(),timeZone,resolution));
    time.add(resolution.getDateTimeFieldType().getDurationType(),1);
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override public List<Node> getInstants(long startTime,long endTime,DateTimeZone timeZone,Resolution resolution,Transaction tx){
  if (timeZone == null) {
    timeZone=this.timeZone;
  }
  if (resolution == null) {
    resolution=this.resolution;
  }
  List<Node> result=new LinkedList<>();
  MutableDateTime time=new MutableDateTime(startTime);
  while (!time.isAfter(endTime)) {
    result.add(getInstant(time.getMillis(),timeZone,resolution,tx));
    time.add(resolution.getDateTimeFieldType().getDurationType(),1);
  }
  return result;
}",0.9838709677419356
64811,"/** 
 * Get a node representing a specific time instant. If one doesn't exist, it will be created.
 * @param time       UTC time in ms from 1/1/1970.
 * @param timeZone   specific time zone.
 * @param resolution specific resolution.
 * @return node representing a specific time instant.
 */
Node getInstant(long time,DateTimeZone timeZone,Resolution resolution);","/** 
 * Get a node representing a specific time instant. If one doesn't exist, it will be created.
 * @param time       UTC time in ms from 1/1/1970.
 * @param timeZone   specific time zone.
 * @param resolution specific resolution.
 * @param tx         currently running transaction.
 * @return node representing a specific time instant.
 */
Node getInstant(long time,DateTimeZone timeZone,Resolution resolution,Transaction tx);",0.9152970922882429
64812,"/** 
 * Get a node representing this time instant. If one doesn't exist, it will be created.
 * @param timeZone   specific time zone.
 * @param resolution specific resolution.
 * @return node representing the time instant when this method was called.
 */
Node getNow(DateTimeZone timeZone,Resolution resolution);","/** 
 * Get a node representing this time instant. If one doesn't exist, it will be created.
 * @param timeZone   specific time zone.
 * @param resolution specific resolution.
 * @param tx         currently running transaction.
 * @return node representing the time instant when this method was called.
 */
Node getNow(DateTimeZone timeZone,Resolution resolution,Transaction tx);",0.9030390738060782
64813,"/** 
 * Get nodes representing all time instants in the specified range (inclusive). The ones that don't exist will be created.
 * @param startTime  UTC time in ms from 1/1/1970 of the start of the interval (inclusive).
 * @param endTime    UTC time in ms from 1/1/1970 of the end of the interval (inclusive).
 * @param timeZone   specific time zone.
 * @param resolution specific resolution.
 * @return nodes representing all time instants in the interval, ordered chronologically.
 */
List<Node> getInstants(long startTime,long endTime,DateTimeZone timeZone,Resolution resolution);","/** 
 * Get nodes representing all time instants in the specified range (inclusive). The ones that don't exist will be created.
 * @param startTime  UTC time in ms from 1/1/1970 of the start of the interval (inclusive).
 * @param endTime    UTC time in ms from 1/1/1970 of the end of the interval (inclusive).
 * @param timeZone   specific time zone.
 * @param resolution specific resolution.
 * @param tx         currently running transaction.
 * @return nodes representing all time instants in the interval, ordered chronologically.
 */
List<Node> getInstants(long startTime,long endTime,DateTimeZone timeZone,Resolution resolution,Transaction tx);",0.94566098945661
64814,"public String formInfoMessage(boolean formLink,String addition,int hearts,PpMessageBuilder ppMessageBuilder) throws UserException {
  if (beatmap.getMaxCombo() <= 0) {
    throw new UserException(format(""String_Node_Str"",beatmap.getBeatmapId()));
  }
  String beatmapName=String.format(""String_Node_Str"",getBeatmap().getArtist(),getBeatmap().getTitle(),getBeatmap().getVersion());
  if (formLink) {
    beatmapName=String.format(""String_Node_Str"",getBeatmap().getBeatmapId(),beatmapName);
  }
  PercentageEstimates percentageEstimates=getEstimates();
  long mods=percentageEstimates.getMods();
  if (percentageEstimates.getMods() != 0) {
    StringBuilder modsString=new StringBuilder();
    for (    Mods mod : Mods.getMods(percentageEstimates.getMods())) {
      if (mod.isEffective()) {
        modsString.append(mod.getShortName());
      }
    }
    beatmapName+=""String_Node_Str"" + modsString;
  }
  String estimateMessage=""String_Node_Str"";
  Integer future=getPersonalPP();
  if (future != null && future >= getPpForAcc(.9) && future < getPpForAcc(1) * 1.05) {
    future=(int)Math.floor(Math.min(future,getPpForAcc(1)));
    estimateMessage+=""String_Node_Str"" + future + ""String_Node_Str"";
  }
  estimateMessage+=ppMessageBuilder.buildMessage(percentageEstimates);
  if (percentageEstimates.isShaky()) {
    estimateMessage+=""String_Node_Str"";
  }
  estimateMessage+=""String_Node_Str"" + secondsToMinuteColonSecond(getBeatmap().getTotalLength(mods));
  Double starDiff=null;
  if (mods == 0) {
    starDiff=beatmap.getStarDifficulty();
  }
 else {
    starDiff=estimates.getStarDiff();
  }
  if (starDiff != null) {
    estimateMessage+=""String_Node_Str"" + format.format(starDiff);
  }
  estimateMessage+=""String_Node_Str"" + format.format(getBeatmap().getBpm(mods));
  estimateMessage+=""String_Node_Str"" + format.format(getBeatmap().getApproachRate(mods));
  estimateMessage+=""String_Node_Str"" + format.format(getBeatmap().getOverallDifficulty(mods));
  if (estimates.isOppaiOnly()) {
    estimateMessage+=""String_Node_Str"";
    if (!estimates.isRanked()) {
      estimateMessage+=""String_Node_Str"";
    }
    estimateMessage+=""String_Node_Str"";
  }
  String heartString=hearts > 0 ? ""String_Node_Str"" + StringUtils.repeat('',hearts) : ""String_Node_Str"";
  return beatmapName + ""String_Node_Str"" + estimateMessage+ (addition != null ? ""String_Node_Str"" + addition : ""String_Node_Str"")+ heartString;
}","public String formInfoMessage(boolean formLink,String addition,int hearts,PpMessageBuilder ppMessageBuilder) throws UserException {
  if (beatmap.getMaxCombo() <= 0) {
    throw new UserException(format(""String_Node_Str"",beatmap.getBeatmapId()));
  }
  String beatmapName=String.format(""String_Node_Str"",getBeatmap().getArtist(),getBeatmap().getTitle(),getBeatmap().getVersion());
  if (formLink) {
    beatmapName=String.format(""String_Node_Str"",getBeatmap().getBeatmapId(),beatmapName);
  }
  beatmapName+=formModsSuffix();
  String estimateMessage=""String_Node_Str"";
  Integer future=getPersonalPP();
  if (future != null && future >= getPpForAcc(.9) && future < getPpForAcc(1) * 1.05) {
    future=(int)Math.floor(Math.min(future,getPpForAcc(1)));
    estimateMessage+=""String_Node_Str"" + future + ""String_Node_Str"";
  }
  estimateMessage+=ppMessageBuilder.buildMessage(getEstimates());
  if (getEstimates().isShaky()) {
    estimateMessage+=""String_Node_Str"";
  }
  estimateMessage+=""String_Node_Str"" + secondsToMinuteColonSecond(getBeatmap().getTotalLength(getMods()));
  Double starDiff=null;
  if (getMods() == 0) {
    starDiff=beatmap.getStarDifficulty();
  }
 else {
    starDiff=estimates.getStarDiff();
  }
  if (starDiff != null) {
    estimateMessage+=""String_Node_Str"" + format.format(starDiff);
  }
  estimateMessage+=""String_Node_Str"" + format.format(getBeatmap().getBpm(getMods()));
  estimateMessage+=""String_Node_Str"" + format.format(getBeatmap().getApproachRate(getMods()));
  estimateMessage+=""String_Node_Str"" + format.format(getBeatmap().getOverallDifficulty(getMods()));
  if (estimates.isOppaiOnly()) {
    estimateMessage+=""String_Node_Str"";
    if (!estimates.isRanked()) {
      estimateMessage+=""String_Node_Str"";
    }
    estimateMessage+=""String_Node_Str"";
  }
  String heartString=hearts > 0 ? ""String_Node_Str"" + StringUtils.repeat('',hearts) : ""String_Node_Str"";
  return beatmapName + ""String_Node_Str"" + estimateMessage+ (addition != null ? ""String_Node_Str"" + addition : ""String_Node_Str"")+ heartString;
}",0.8821548821548821
64815,"public BeatmapWithMods getBeatmapWithMods(){
  return new BeatmapWithMods(beatmap.getBeatmapId(),estimates.getMods());
}","public BeatmapWithMods getBeatmapWithMods(){
  return new BeatmapWithMods(beatmap.getBeatmapId(),getMods());
}",0.9565217391304348
64816,"@Override public final Response handle(String originalCommand,OsuApiUser apiUser,UserData userData) throws UserException, IOException, SQLException, InterruptedException {
  String lowerCase=originalCommand.toLowerCase();
  final String remaining;
  searchCommand: {
    if (lowerCase.equals(alias)) {
      remaining=""String_Node_Str"";
      break searchCommand;
    }
    if (getLevenshteinDistance(lowerCase,command) <= 2) {
      remaining=""String_Node_Str"";
      break searchCommand;
    }
    if (lowerCase.startsWith(aliasWithSpace)) {
      remaining=originalCommand.substring(2);
      break searchCommand;
    }
    if (lowerCase.contains(""String_Node_Str"")) {
      int pos=lowerCase.indexOf(' ');
      if (getLevenshteinDistance(lowerCase.substring(0,pos),command) <= 2) {
        remaining=originalCommand.substring(pos + 1);
        break searchCommand;
      }
    }
    return null;
  }
  return handleArgument(remaining,apiUser,userData);
}","@Override public final Response handle(String originalCommand,OsuApiUser apiUser,UserData userData) throws UserException, IOException, SQLException, InterruptedException {
  String lowerCase=originalCommand.toLowerCase();
  if (lowerCase.equals(alias)) {
    return handleArgument(""String_Node_Str"",apiUser,userData);
  }
  if (getLevenshteinDistance(lowerCase,command) <= 2) {
    return handleArgument(""String_Node_Str"",apiUser,userData);
  }
  if (lowerCase.startsWith(aliasWithSpace)) {
    return handleArgument(originalCommand.substring(2),apiUser,userData);
  }
  int pos=lowerCase.indexOf(' ');
  if (pos > 0 && getLevenshteinDistance(lowerCase.substring(0,pos),command) <= 2) {
    return handleArgument(originalCommand.substring(pos + 1),apiUser,userData);
  }
  return null;
}",0.5670103092783505
64817,"IRCBotUser fromIRC(final User user,final Event<PircBotX> event){
  return new IRCBotUser(){
    @Override public boolean message(    String msg,    boolean success){
      try {
        senderSemaphore.acquire();
      }
 catch (      InterruptedException e) {
        return false;
      }
      try {
        pinger.ping((CloseableBot)user.getBot());
        user.send().message(msg);
        MDC.put(MDC_STATE,""String_Node_Str"");
        if (success) {
          MDC.put(MDC_DURATION,System.currentTimeMillis() - event.getTimestamp() + ""String_Node_Str"");
          MDC.put(MDC_SUCCESS,""String_Node_Str"");
          MDC.put(MCD_OSU_API_RATE_BLOCKED_TIME,String.valueOf(rateLimiter.blockedTime()));
          if (Objects.equals(MDC.get(MDC_HANDLER),RecommendHandler.MDC_FLAG)) {
            botInfo.setLastRecommendation(System.currentTimeMillis());
          }
        }
        log.debug(""String_Node_Str"" + msg);
        botInfo.setLastSentMessage(System.currentTimeMillis());
        return true;
      }
 catch (      IOException|InterruptedException e) {
        log.error(""String_Node_Str"" + e.getMessage());
        return false;
      }
 finally {
        MDC.remove(MDC_DURATION);
        MDC.remove(MDC_SUCCESS);
        MDC.remove(MCD_OSU_API_RATE_BLOCKED_TIME);
        senderSemaphore.release();
      }
    }
    @Override public boolean action(    String msg){
      try {
        senderSemaphore.acquire();
      }
 catch (      InterruptedException e) {
        return false;
      }
      try {
        pinger.ping((CloseableBot)user.getBot());
        user.send().action(msg);
        MDC.put(MDC_STATE,""String_Node_Str"");
        log.debug(""String_Node_Str"" + msg);
        return true;
      }
 catch (      IOException|InterruptedException e) {
        log.error(""String_Node_Str"" + e.getMessage());
        return false;
      }
 finally {
        senderSemaphore.release();
      }
    }
    @Override @IRCName @SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public String getNick(){
      return user.getNick();
    }
  }
;
}","IRCBotUser fromIRC(final User user,final Event<PircBotX> event){
  return new IRCBotUser(){
    @Override public boolean message(    String msg,    boolean success){
      try {
        senderSemaphore.acquire();
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        return false;
      }
      try {
        pinger.ping((CloseableBot)user.getBot());
        user.send().message(msg);
        MDC.put(MDC_STATE,""String_Node_Str"");
        if (success) {
          MDC.put(MDC_DURATION,System.currentTimeMillis() - event.getTimestamp() + ""String_Node_Str"");
          MDC.put(MDC_SUCCESS,""String_Node_Str"");
          MDC.put(MCD_OSU_API_RATE_BLOCKED_TIME,String.valueOf(rateLimiter.blockedTime()));
          if (Objects.equals(MDC.get(MDC_HANDLER),RecommendHandler.MDC_FLAG)) {
            botInfo.setLastRecommendation(System.currentTimeMillis());
          }
        }
        log.debug(""String_Node_Str"" + msg);
        botInfo.setLastSentMessage(System.currentTimeMillis());
        return true;
      }
 catch (      IOException|InterruptedException e) {
        log.error(""String_Node_Str"" + e.getMessage());
        return false;
      }
 finally {
        MDC.remove(MDC_DURATION);
        MDC.remove(MDC_SUCCESS);
        MDC.remove(MCD_OSU_API_RATE_BLOCKED_TIME);
        senderSemaphore.release();
      }
    }
    @Override public boolean action(    String msg){
      try {
        senderSemaphore.acquire();
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        return false;
      }
      try {
        pinger.ping((CloseableBot)user.getBot());
        user.send().action(msg);
        MDC.put(MDC_STATE,""String_Node_Str"");
        log.debug(""String_Node_Str"" + msg);
        return true;
      }
 catch (      IOException|InterruptedException e) {
        log.error(""String_Node_Str"" + e.getMessage());
        return false;
      }
 finally {
        senderSemaphore.release();
      }
    }
    @Override @IRCName @SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public String getNick(){
      return user.getNick();
    }
  }
;
}",0.9793038570084666
64818,"@Nonnull OsuApiUser getUserOrThrow(IRCBotUser user) throws UserException, SQLException, IOException, InterruptedException {
  Integer userId=resolver.resolveIRCName(user.getNick());
  if (userId != null) {
    OsuApiUser apiUser=backend.getUser(userId,60 * 60 * 1000);
    if (apiUser != null) {
      String apiUserIrcName=IrcNameResolver.getIrcUserName(apiUser);
      if (!user.getNick().equals(apiUserIrcName)) {
        resolver.setMapping(apiUserIrcName,apiUser.getUserId());
        apiUser=resolver.redownloadUser(user.getNick());
      }
    }
    if (apiUser != null) {
      return apiUser;
    }
  }
  String string=IRCBot.getRandomString(8);
  log.error(""String_Node_Str"" + string + ""String_Node_Str""+ user.getNick());
  throw new UserException(""String_Node_Str"" + ""String_Node_Str"" + string + ""String_Node_Str"");
}","@Nonnull OsuApiUser getUserOrThrow(IRCBotUser user) throws UserException, SQLException, IOException, InterruptedException {
  Integer userId=resolver.resolveIRCName(user.getNick());
  if (userId != null) {
    OsuApiUser apiUser=backend.getUser(userId,60 * 60 * 1000L);
    if (apiUser != null) {
      String apiUserIrcName=IrcNameResolver.getIrcUserName(apiUser);
      if (!user.getNick().equals(apiUserIrcName)) {
        resolver.setMapping(apiUserIrcName,apiUser.getUserId());
        apiUser=resolver.redownloadUser(user.getNick());
      }
    }
    if (apiUser != null) {
      return apiUser;
    }
  }
  String string=IRCBot.getRandomString(8);
  log.error(""String_Node_Str"" + string + ""String_Node_Str""+ user.getNick());
  throw new UserException(""String_Node_Str"" + ""String_Node_Str"" + string + ""String_Node_Str"");
}",0.9993964996982498
64819,"private void checkVersionInfo(final IRCBotUser user) throws SQLException, UserException {
  int userVersion=backend.getLastVisitedVersion(user.getNick());
  if (userVersion < CURRENT_VERSION) {
    if (VERSION_MESSAGE == null || user.message(VERSION_MESSAGE,false)) {
      backend.setLastVisitedVersion(user.getNick(),CURRENT_VERSION);
    }
  }
}","private void checkVersionInfo(final IRCBotUser user) throws SQLException, UserException {
  int userVersion=backend.getLastVisitedVersion(user.getNick());
  if (userVersion < CURRENT_VERSION && (VERSION_MESSAGE == null || user.message(VERSION_MESSAGE,false))) {
    backend.setLastVisitedVersion(user.getNick(),CURRENT_VERSION);
  }
}",0.967741935483871
64820,"@Override public boolean action(String msg){
  try {
    senderSemaphore.acquire();
  }
 catch (  InterruptedException e) {
    return false;
  }
  try {
    pinger.ping((CloseableBot)user.getBot());
    user.send().action(msg);
    MDC.put(MDC_STATE,""String_Node_Str"");
    log.debug(""String_Node_Str"" + msg);
    return true;
  }
 catch (  IOException|InterruptedException e) {
    log.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
 finally {
    senderSemaphore.release();
  }
}","@Override public boolean action(String msg){
  try {
    senderSemaphore.acquire();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    return false;
  }
  try {
    pinger.ping((CloseableBot)user.getBot());
    user.send().action(msg);
    MDC.put(MDC_STATE,""String_Node_Str"");
    log.debug(""String_Node_Str"" + msg);
    return true;
  }
 catch (  IOException|InterruptedException e) {
    log.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
 finally {
    senderSemaphore.release();
  }
}",0.9615384615384616
64821,"@Inject public IRCBot(BotBackend backend,RecommendationsManager manager,BotInfo botInfo,UserDataManager userDataManager,Pinger pinger,@Named(""String_Node_Str"") boolean silent,ThreadLocalAutoCommittingEntityManager em,EntityManagerFactory emf,IrcNameResolver resolver,OsutrackDownloader osutrackDownloader,@Named(""String_Node_Str"") ExecutorService exec,RateLimiter rateLimiter){
  this.backend=backend;
  this.botInfo=botInfo;
  this.userDataManager=userDataManager;
  this.pinger=pinger;
  this.silent=silent;
  this.em=em;
  this.emf=emf;
  this.resolver=resolver;
  this.osutrackDownloader=osutrackDownloader;
  this.exec=exec;
  this.rateLimiter=rateLimiter;
  commandHandlers.add(new ResetHandler(manager));
  commandHandlers.add(new OptionsHandler(manager));
  commandHandlers.add(new AccHandler(backend));
  commandHandlers.add(new WithHandler(backend));
  commandHandlers.add(new RecommendHandler(manager));
  commandHandlers.add(new RecentHandler(backend));
  commandHandlers.add(new DebugHandler(backend,resolver));
  commandHandlers.add(new HelpHandler());
  commandHandlers.add(new ComplaintHandler(manager));
  commandHandlers.add(new OsuTrackHandler(osutrackDownloader));
}","@Inject public IRCBot(BotBackend backend,RecommendationsManager manager,BotInfo botInfo,UserDataManager userDataManager,Pinger pinger,@Named(""String_Node_Str"") boolean silent,ThreadLocalAutoCommittingEntityManager em,EntityManagerFactory emf,IrcNameResolver resolver,OsutrackDownloader osutrackDownloader,@Named(""String_Node_Str"") ExecutorService exec,RateLimiter rateLimiter){
  this.backend=backend;
  this.botInfo=botInfo;
  this.userDataManager=userDataManager;
  this.pinger=pinger;
  this.silent=silent;
  this.em=em;
  this.emf=emf;
  this.resolver=resolver;
  this.osutrackDownloader=osutrackDownloader;
  this.exec=exec;
  this.rateLimiter=rateLimiter;
  commandHandlers.add(new ResetHandler(manager));
  commandHandlers.add(new OptionsHandler(new RecommendationRequestParser(backend)));
  commandHandlers.add(new AccHandler(backend));
  commandHandlers.add(new WithHandler(backend));
  commandHandlers.add(new RecommendHandler(manager));
  commandHandlers.add(new RecentHandler(backend));
  commandHandlers.add(new DebugHandler(backend,resolver));
  commandHandlers.add(new HelpHandler());
  commandHandlers.add(new ComplaintHandler(manager));
  commandHandlers.add(new OsuTrackHandler(osutrackDownloader));
}",0.9804573804573804
64822,"@Override public boolean message(String msg,boolean success){
  try {
    senderSemaphore.acquire();
  }
 catch (  InterruptedException e) {
    return false;
  }
  try {
    pinger.ping((CloseableBot)user.getBot());
    user.send().message(msg);
    MDC.put(MDC_STATE,""String_Node_Str"");
    if (success) {
      MDC.put(MDC_DURATION,System.currentTimeMillis() - event.getTimestamp() + ""String_Node_Str"");
      MDC.put(MDC_SUCCESS,""String_Node_Str"");
      MDC.put(MCD_OSU_API_RATE_BLOCKED_TIME,String.valueOf(rateLimiter.blockedTime()));
      if (Objects.equals(MDC.get(MDC_HANDLER),RecommendHandler.MDC_FLAG)) {
        botInfo.setLastRecommendation(System.currentTimeMillis());
      }
    }
    log.debug(""String_Node_Str"" + msg);
    botInfo.setLastSentMessage(System.currentTimeMillis());
    return true;
  }
 catch (  IOException|InterruptedException e) {
    log.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
 finally {
    MDC.remove(MDC_DURATION);
    MDC.remove(MDC_SUCCESS);
    MDC.remove(MCD_OSU_API_RATE_BLOCKED_TIME);
    senderSemaphore.release();
  }
}","@Override public boolean message(String msg,boolean success){
  try {
    senderSemaphore.acquire();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    return false;
  }
  try {
    pinger.ping((CloseableBot)user.getBot());
    user.send().message(msg);
    MDC.put(MDC_STATE,""String_Node_Str"");
    if (success) {
      MDC.put(MDC_DURATION,System.currentTimeMillis() - event.getTimestamp() + ""String_Node_Str"");
      MDC.put(MDC_SUCCESS,""String_Node_Str"");
      MDC.put(MCD_OSU_API_RATE_BLOCKED_TIME,String.valueOf(rateLimiter.blockedTime()));
      if (Objects.equals(MDC.get(MDC_HANDLER),RecommendHandler.MDC_FLAG)) {
        botInfo.setLastRecommendation(System.currentTimeMillis());
      }
    }
    log.debug(""String_Node_Str"" + msg);
    botInfo.setLastSentMessage(System.currentTimeMillis());
    return true;
  }
 catch (  IOException|InterruptedException e) {
    log.error(""String_Node_Str"" + e.getMessage());
    return false;
  }
 finally {
    MDC.remove(MDC_DURATION);
    MDC.remove(MDC_SUCCESS);
    MDC.remove(MCD_OSU_API_RATE_BLOCKED_TIME);
    senderSemaphore.release();
  }
}",0.982030548068284
64823,"@Override public void onJoin(JoinEvent event) throws Exception {
  if (silent) {
    return;
  }
  IRCBotUser user=fromIRC(event.getUser(),event);
  welcomeIfDonator(user);
}","@Override public void onJoin(JoinEvent event) throws Exception {
  if (silent) {
    return;
  }
  IRCBotUser user=fromIRC(event.getUser(),event);
  try {
    welcomeIfDonator(user);
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
}",0.6837944664031621
64824,"void welcomeIfDonator(IRCBotUser user){
  try {
    Integer userid;
    try {
      userid=resolver.resolveIRCName(user.getNick());
    }
 catch (    IOException e) {
      if (isTimeout(e)) {
        log.debug(""String_Node_Str"",user.getNick());
        return;
      }
      throw e;
    }
    if (userid == null)     return;
    OsuApiUser apiUser;
    try {
      apiUser=backend.getUser(userid,0);
    }
 catch (    IOException e) {
      if (isTimeout(e)) {
        log.debug(""String_Node_Str"",userid);
        return;
      }
      throw e;
    }
    if (apiUser == null)     return;
    if (backend.getDonator(apiUser) > 0) {
      UserData data=userDataManager.getData(userid);
      if (!data.isShowWelcomeMessage())       return;
      long inactiveTime=System.currentTimeMillis() - backend.getLastActivity(apiUser);
      Response welcome=data.getLanguage().welcomeUser(apiUser,inactiveTime);
      sendResponse(welcome,user);
      if (data.isOsuTrackWelcomeEnabled()) {
        UpdateResult update=osutrackDownloader.getUpdate(user.getNick());
        Response updateResponse=OsuTrackHandler.updateResultToResponse(update);
        sendResponse(updateResponse,user);
      }
      checkVersionInfo(user);
    }
  }
 catch (  InterruptedException e) {
  }
catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
}","void welcomeIfDonator(IRCBotUser user) throws SQLException, InterruptedException, IOException, UserException {
  Integer userid;
  try {
    userid=resolver.resolveIRCName(user.getNick());
  }
 catch (  IOException e) {
    if (isTimeout(e)) {
      log.debug(""String_Node_Str"",user.getNick());
      return;
    }
    throw e;
  }
  if (userid == null)   return;
  OsuApiUser apiUser;
  try {
    apiUser=backend.getUser(userid,0);
  }
 catch (  IOException e) {
    if (isTimeout(e)) {
      log.debug(""String_Node_Str"",userid);
      return;
    }
    throw e;
  }
  if (apiUser == null)   return;
  if (backend.getDonator(apiUser) > 0) {
    UserData data=userDataManager.getData(userid);
    if (!data.isShowWelcomeMessage())     return;
    long inactiveTime=System.currentTimeMillis() - backend.getLastActivity(apiUser);
    Response welcome=data.getLanguage().welcomeUser(apiUser,inactiveTime);
    sendResponse(welcome,user);
    if (data.isOsuTrackWelcomeEnabled()) {
      UpdateResult update=osutrackDownloader.getUpdate(user.getNick());
      Response updateResponse=OsuTrackHandler.updateResultToResponse(update);
      sendResponse(updateResponse,user);
    }
    checkVersionInfo(user);
  }
}",0.8492719401810311
64825,"@Override public JsonElement get(String command,String... parameters) throws IOException {
  try {
    limiter.limitRate();
  }
 catch (  InterruptedException e) {
    throw new ServiceUnavailableException();
  }
  return super.get(command,parameters);
}","@Override public JsonElement get(String command,String... parameters) throws IOException {
  try {
    limiter.limitRate();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new ServiceUnavailableException();
  }
  return super.get(command,parameters);
}",0.927007299270073
64826,"@Override public void onEvent(Event event) throws Exception {
  MDC.put(""String_Node_Str"",""String_Node_Str"" + lastSerial.incrementAndGet());
  em.setThreadLocalEntityManager(emf.createEntityManager());
  try {
    botInfo.setLastInteraction(System.currentTimeMillis());
    if (lastListTime < System.currentTimeMillis() - 60 * 60 * 1000) {
      lastListTime=System.currentTimeMillis();
      event.getBot().sendRaw().rawLine(""String_Node_Str"");
    }
    if (event instanceof GenericUserEvent<?>) {
      String nick=((GenericUserEvent)event).getUser().getNick();
      MDC.put(""String_Node_Str"",nick);
      scheduleRegisterActivity(nick);
    }
    super.onEvent(event);
  }
  finally {
    em.close();
    MDC.clear();
  }
}","@Override public void onEvent(Event event) throws Exception {
  MDC.put(""String_Node_Str"",""String_Node_Str"" + lastSerial.incrementAndGet());
  em.setThreadLocalEntityManager(emf.createEntityManager());
  try {
    botInfo.setLastInteraction(System.currentTimeMillis());
    if (lastListTime < System.currentTimeMillis() - 60 * 60 * 1000) {
      lastListTime=System.currentTimeMillis();
      event.getBot().sendRaw().rawLine(""String_Node_Str"");
    }
    if (event instanceof GenericUserEvent<?>) {
      User user=((GenericUserEvent)event).getUser();
      if (user != null) {
        String nick=user.getNick();
        MDC.put(""String_Node_Str"",nick);
        scheduleRegisterActivity(nick);
      }
    }
    super.onEvent(event);
  }
  finally {
    em.close();
    MDC.clear();
  }
}",0.9130434782608696
64827,"/** 
 * The user's IRC nick name could not be resolved to an osu user id. The message should suggest to contact @Tillerinobot or /u/Tillerino.
 * @param exceptionMarker a marker to reference the created log entry. six or eight characters.
 * @param name the irc nick which could not be resolved
 * @return
 */
public String unresolvableName(String exceptionMarker,String name){
  return ""String_Node_Str"" + exceptionMarker + ""String_Node_Str"";
}","/** 
 * The user's IRC nick name could not be resolved to an osu user id. The message should suggest to contact @Tillerinobot or /u/Tillerino.
 * @param exceptionMarker a marker to reference the created log entry. six or eight characters.
 * @param name the irc nick which could not be resolved
 * @return
 */
public String unresolvableName(String exceptionMarker,String name){
  return ""String_Node_Str"" + ""String_Node_Str"" + exceptionMarker + ""String_Node_Str"";
}",0.978021978021978
64828,"public Settings parseSamplerSettings(OsuApiUser apiUser,@Nonnull String message,Language lang) throws UserException, SQLException, IOException {
  String[] remaining=message.split(""String_Node_Str"");
  Settings settings=new Settings();
  settings.model=Model.GAMMA;
  for (int i=0; i < remaining.length; i++) {
    String param=remaining[i];
    String lowerCase=param.toLowerCase();
    if (lowerCase.length() == 0)     continue;
    if (getLevenshteinDistance(lowerCase,""String_Node_Str"") <= 2) {
      settings.nomod=true;
      continue;
    }
    if (getLevenshteinDistance(lowerCase,""String_Node_Str"") <= 2) {
      settings.model=Model.ALPHA;
      continue;
    }
    if (getLevenshteinDistance(lowerCase,""String_Node_Str"") <= 1) {
      settings.model=Model.BETA;
      continue;
    }
    if (getLevenshteinDistance(lowerCase,""String_Node_Str"") <= 2) {
      settings.model=Model.GAMMA;
      continue;
    }
    if (settings.model == Model.GAMMA && (lowerCase.equals(""String_Node_Str"") || lowerCase.equals(""String_Node_Str""))) {
      settings.requestedMods=Mods.add(settings.requestedMods,Mods.DoubleTime);
      continue;
    }
    if (settings.model == Model.GAMMA && lowerCase.equals(""String_Node_Str"")) {
      settings.requestedMods=Mods.add(settings.requestedMods,Mods.HardRock);
      continue;
    }
    if (settings.model == Model.GAMMA && lowerCase.equals(""String_Node_Str"")) {
      settings.requestedMods=Mods.add(settings.requestedMods,Mods.Hidden);
      continue;
    }
    if (settings.model == Model.GAMMA) {
      Long mods=Mods.fromShortNamesContinuous(lowerCase);
      if (mods != null) {
        mods=Mods.fixNC(mods);
        if (mods == (mods & Mods.getMask(Mods.DoubleTime,Mods.HardRock,Mods.Hidden))) {
          settings.requestedMods|=mods;
          continue;
        }
      }
    }
    if (backend.getDonator(apiUser) > 0) {
      RecommendationPredicate predicate=parser.tryParse(param,lang);
      if (predicate != null) {
        for (        RecommendationPredicate existingPredicate : settings.predicates) {
          if (existingPredicate.contradicts(predicate)) {
            throw new UserException(lang.invalidChoice(existingPredicate.getOriginalArgument() + ""String_Node_Str"" + predicate.getOriginalArgument(),""String_Node_Str"" + existingPredicate.getOriginalArgument() + ""String_Node_Str""+ predicate.getOriginalArgument()));
          }
        }
        settings.predicates.add(predicate);
        continue;
      }
    }
    throw new UserException(lang.invalidChoice(param,""String_Node_Str""));
  }
  if (settings.nomod && settings.requestedMods != 0) {
    throw new UserException(lang.mixedNomodAndMods());
  }
  return settings;
}","public Settings parseSamplerSettings(OsuApiUser apiUser,@Nonnull String message,Language lang) throws UserException, SQLException, IOException {
  String[] remaining=message.split(""String_Node_Str"");
  Settings settings=new Settings();
  settings.model=Model.GAMMA;
  for (int i=0; i < remaining.length; i++) {
    String param=remaining[i];
    String lowerCase=param.toLowerCase();
    if (lowerCase.length() == 0)     continue;
    if (getLevenshteinDistance(lowerCase,""String_Node_Str"") <= 2) {
      settings.nomod=true;
      continue;
    }
    if (getLevenshteinDistance(lowerCase,""String_Node_Str"") <= 2) {
      settings.model=Model.ALPHA;
      continue;
    }
    if (getLevenshteinDistance(lowerCase,""String_Node_Str"") <= 1) {
      settings.model=Model.BETA;
      continue;
    }
    if (getLevenshteinDistance(lowerCase,""String_Node_Str"") <= 2) {
      settings.model=Model.GAMMA;
      continue;
    }
    if (settings.model == Model.GAMMA && (lowerCase.equals(""String_Node_Str"") || lowerCase.equals(""String_Node_Str""))) {
      settings.requestedMods=Mods.add(settings.requestedMods,Mods.DoubleTime);
      continue;
    }
    if (settings.model == Model.GAMMA && lowerCase.equals(""String_Node_Str"")) {
      settings.requestedMods=Mods.add(settings.requestedMods,Mods.HardRock);
      continue;
    }
    if (settings.model == Model.GAMMA && lowerCase.equals(""String_Node_Str"")) {
      settings.requestedMods=Mods.add(settings.requestedMods,Mods.Hidden);
      continue;
    }
    if (settings.model == Model.GAMMA) {
      Long mods=Mods.fromShortNamesContinuous(lowerCase);
      if (mods != null) {
        mods=Mods.fixNC(mods);
        if (mods == (mods & Mods.getMask(Mods.DoubleTime,Mods.HardRock,Mods.Hidden))) {
          for (          Mods mod : Mods.getMods(mods)) {
            settings.requestedMods=Mods.add(settings.requestedMods,mod);
          }
          continue;
        }
      }
    }
    if (backend.getDonator(apiUser) > 0) {
      RecommendationPredicate predicate=parser.tryParse(param,lang);
      if (predicate != null) {
        for (        RecommendationPredicate existingPredicate : settings.predicates) {
          if (existingPredicate.contradicts(predicate)) {
            throw new UserException(lang.invalidChoice(existingPredicate.getOriginalArgument() + ""String_Node_Str"" + predicate.getOriginalArgument(),""String_Node_Str"" + existingPredicate.getOriginalArgument() + ""String_Node_Str""+ predicate.getOriginalArgument()));
          }
        }
        settings.predicates.add(predicate);
        continue;
      }
    }
    throw new UserException(lang.invalidChoice(param,""String_Node_Str""));
  }
  if (settings.nomod && settings.requestedMods != 0) {
    throw new UserException(lang.mixedNomodAndMods());
  }
  return settings;
}",0.9786535303776684
64829,"public void pageActivated(){
  getContainer().setMessage(Messages.getString(""String_Node_Str""),IMessageProvider.NONE);
  if (modelChanged) {
    modelChanged=false;
    dataSetHandle=((DataSetEditor)getContainer()).getHandle();
    int maxRow=this.getMaxRowPreference();
    if (dataSetHandle.getRowFetchLimit() <= 0 || dataSetHandle.getRowFetchLimit() > maxRow) {
      ModuleHandle moduleHandle=((Module)dataSetHandle.getRoot().copy()).getModuleHandle();
      SlotHandle dataSets=moduleHandle.getDataSets();
      for (int i=0; i < dataSets.getCount(); i++) {
        if (dataSetHandle.getName().equals(dataSets.get(i).getName())) {
          dataSetHandle=(DataSetHandle)dataSets.get(i);
          try {
            dataSetHandle.setRowFetchLimit(maxRow);
          }
 catch (          SemanticException e) {
          }
          break;
        }
      }
    }
    new UIJob(""String_Node_Str""){
      public IStatus runInUIThread(      IProgressMonitor monitor){
        updateResultsProcess();
        return Status.OK_STATUS;
      }
    }
.schedule();
  }
}","public void pageActivated(){
  getContainer().setMessage(Messages.getString(""String_Node_Str""),IMessageProvider.NONE);
  if (modelChanged) {
    modelChanged=false;
    dataSetHandle=((DataSetEditor)getContainer()).getHandle();
    int maxRow=this.getMaxRowPreference();
    if (dataSetHandle.getRowFetchLimit() <= 0) {
      ModuleHandle moduleHandle=((Module)dataSetHandle.getRoot().copy()).getModuleHandle();
      SlotHandle dataSets=moduleHandle.getDataSets();
      for (int i=0; i < dataSets.getCount(); i++) {
        if (dataSetHandle.getName().equals(dataSets.get(i).getName())) {
          dataSetHandle=(DataSetHandle)dataSets.get(i);
          try {
            dataSetHandle.setRowFetchLimit(maxRow);
          }
 catch (          SemanticException e) {
          }
          break;
        }
      }
    }
    new UIJob(""String_Node_Str""){
      public IStatus runInUIThread(      IProgressMonitor monitor){
        updateResultsProcess();
        return Status.OK_STATUS;
      }
    }
.schedule();
  }
}",0.9784172661870504
64830,"/** 
 * @return the test
 */
public static Test suite(){
  TestSuite test=new TestSuite();
  test.addTestSuite(CoreJavaScriptWrapperTest.class);
  test.addTestSuite(NativeDateTimeSpanTest.class);
  test.addTestSuite(NativeFinanceTest.class);
  test.addTestSuite(NativeJavaMapTest.class);
  test.addTestSuite(NativeNamedListTest.class);
  test.addTestSuite(ScriptableParametersTest.class);
  test.addTestSuite(ScriptContextTest.class);
  test.addTestSuite(BirtCompTest.class);
  test.addTestSuite(BirtDateTimeTest.class);
  test.addTestSuite(BirtDurationTest.class);
  test.addTestSuite(BirtMathTest.class);
  test.addTestSuite(BirtStrTest.class);
  return test;
}","/** 
 * @return the test
 */
public static Test suite(){
  TestSuite test=new TestSuite();
  test.addTestSuite(CoreJavaScriptWrapperTest.class);
  test.addTestSuite(NativeDateTimeSpanTest.class);
  test.addTestSuite(NativeFinanceTest.class);
  test.addTestSuite(NativeJavaMapTest.class);
  test.addTestSuite(NativeNamedListTest.class);
  test.addTestSuite(ScriptableParametersTest.class);
  test.addTestSuite(ScriptContextTest.class);
  test.addTestSuite(BirtCompTest.class);
  test.addTestSuite(BirtDateTimeTest.class);
  test.addTestSuite(BirtDurationTest.class);
  test.addTestSuite(BirtMathTest.class);
  test.addTestSuite(BirtStrTest.class);
  test.addTestSuite(LocalFileTest.class);
  return test;
}",0.9692982456140352
64831,"@Override public boolean delete(){
  return file.delete();
}","@Override public boolean delete(){
  return deleteFile(file);
}",0.8943089430894309
64832,"/** 
 * Gets the cell handle copy to support row/column insert.
 * @param cellHandle
 * @return
 * @throws SemanticException
 */
public CellHandle getCellHandleCopy(CellHandle cellHandle) throws SemanticException {
  if (cellHandle == null) {
    return null;
  }
  CellHandle cell=cellHandle.getElementFactory().newCell();
  Iterator iter=cellHandle.getPropertyIterator();
  while (iter.hasNext()) {
    PropertyHandle handle=(PropertyHandle)iter.next();
    String key=handle.getDefn().getName();
    if (handle.isLocal() && (!(CellHandle.COL_SPAN_PROP.equals(key) || CellHandle.ROW_SPAN_PROP.equals(key)))) {
      cellHandle.copyPropertyTo(key,cell);
    }
  }
  return cell;
}","/** 
 * Gets the cell handle copy to support row/column insert.
 * @param cellHandle
 * @return
 * @throws SemanticException
 */
public CellHandle getCellHandleCopy(CellHandle cellHandle) throws SemanticException {
  if (cellHandle == null) {
    return null;
  }
  CellHandle cell=cellHandle.getElementFactory().newCell();
  Iterator iter=cellHandle.getPropertyIterator();
  while (iter.hasNext()) {
    PropertyHandle handle=(PropertyHandle)iter.next();
    if (handle.getDefn().getValueType() == IPropertyDefn.USER_PROPERTY) {
      continue;
    }
    String key=handle.getDefn().getName();
    if (handle.isLocal() && (!(CellHandle.COL_SPAN_PROP.equals(key) || CellHandle.ROW_SPAN_PROP.equals(key)))) {
      cellHandle.copyPropertyTo(key,cell);
    }
  }
  return cell;
}",0.934156378600823
64833,"public Object execute(Object[] arguments,IScriptFunctionContext context) throws BirtException {
  scriptContext=context;
  if (scriptContext != null) {
    Object locale=scriptContext.findProperty(org.eclipse.birt.core.script.functionservice.IScriptFunctionContext.LOCALE);
    if (!(locale instanceof ULocale)) {
      locale=ULocale.getDefault();
    }
    if (threadLocale.get() != locale) {
      threadLocale.set((ULocale)locale);
      List<SimpleDateFormat> sdfList=new ArrayList<SimpleDateFormat>();
      sdfList.add(new SimpleDateFormat(""String_Node_Str"",threadLocale.get()));
      sdfList.add(new SimpleDateFormat(""String_Node_Str"",threadLocale.get()));
      sdfList.add(new SimpleDateFormat(""String_Node_Str"",threadLocale.get()));
      sdfList.add(new SimpleDateFormat(""String_Node_Str"",threadLocale.get()));
      threadSDFArray.set(sdfList);
    }
    Object timeZone=scriptContext.findProperty(org.eclipse.birt.core.script.functionservice.IScriptFunctionContext.TIMEZONE);
    if (!(timeZone instanceof TimeZone)) {
      timeZone=TimeZone.getDefault();
    }
    if (threadTimeZone.get() != timeZone) {
      threadTimeZone.set((TimeZone)timeZone);
    }
  }
  return this.executor.execute(arguments,context);
}","public Object execute(Object[] arguments,IScriptFunctionContext scriptContext) throws BirtException {
  if (scriptContext != null) {
    Object locale=scriptContext.findProperty(org.eclipse.birt.core.script.functionservice.IScriptFunctionContext.LOCALE);
    if (!(locale instanceof ULocale)) {
      locale=ULocale.getDefault();
    }
    if (threadLocale.get() != locale) {
      threadLocale.set((ULocale)locale);
      List<SimpleDateFormat> sdfList=new ArrayList<SimpleDateFormat>();
      sdfList.add(new SimpleDateFormat(""String_Node_Str"",threadLocale.get()));
      sdfList.add(new SimpleDateFormat(""String_Node_Str"",threadLocale.get()));
      sdfList.add(new SimpleDateFormat(""String_Node_Str"",threadLocale.get()));
      sdfList.add(new SimpleDateFormat(""String_Node_Str"",threadLocale.get()));
      threadSDFArray.set(sdfList);
    }
    Object timeZone=scriptContext.findProperty(org.eclipse.birt.core.script.functionservice.IScriptFunctionContext.TIMEZONE);
    if (!(timeZone instanceof TimeZone)) {
      timeZone=TimeZone.getDefault();
    }
    if (threadTimeZone.get() != timeZone) {
      threadTimeZone.set((TimeZone)timeZone);
    }
  }
  return this.executor.execute(arguments,scriptContext);
}",0.98324478953821
64834,"/** 
 * save the design into the stream.
 * @param design design handler
 */
public ReportRunnable saveDesign(ReportRunnable runnable,ReportRunnable originalRunnable) throws EngineException {
  RAOutputStream out=null;
  ReportRunnable newRunnable=runnable;
  try {
    ReportDesignHandle design=runnable.getReport();
    if (DesignChoiceConstants.REPORT_LAYOUT_PREFERENCE_FIXED_LAYOUT.equals(design.getLayoutPreference())) {
      designType=FIXED_LAYOUT_DESIGN;
    }
    out=archive.createRandomAccessStream(DESIGN_STREAM);
    ReportDesignHandle newDesign=DocumentUtil.serialize(design,out);
    designName=design.getFileName();
    newRunnable=new ReportRunnable(engine,newDesign);
    newRunnable.setReportName(runnable.getReportName());
    newRunnable.cachedScripts=runnable.cachedScripts;
  }
 catch (  Exception ex) {
    logger.log(Level.SEVERE,""String_Node_Str"",ex);
    throw new EngineException(MessageConstants.SAVE_DESIGN_ERROR,ex);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      Exception ex) {
      }
    }
    out=null;
  }
  return newRunnable;
}","/** 
 * save the design into the stream.
 * @param design design handler
 */
public ReportRunnable saveDesign(ReportRunnable runnable,ReportRunnable originalRunnable) throws EngineException {
  RAOutputStream out=null;
  ReportRunnable newRunnable=runnable;
  try {
    ReportDesignHandle design=runnable.getReport();
    if (DesignChoiceConstants.REPORT_LAYOUT_PREFERENCE_FIXED_LAYOUT.equals(design.getLayoutPreference())) {
      designType=FIXED_LAYOUT_DESIGN;
    }
    out=archive.createRandomAccessStream(DESIGN_STREAM);
    ReportDesignHandle newDesign=DocumentUtil.serialize(design,out);
    designName=design.getFileName();
    newRunnable=new ReportRunnable(engine,newDesign);
    newRunnable.setReportName(runnable.getReportName());
    newRunnable.cachedScripts=runnable.cachedScripts;
    newDesign.getModule().close();
  }
 catch (  Exception ex) {
    logger.log(Level.SEVERE,""String_Node_Str"",ex);
    throw new EngineException(MessageConstants.SAVE_DESIGN_ERROR,ex);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      Exception ex) {
      }
    }
    out=null;
  }
  return newRunnable;
}",0.9845201238390092
64835,"public void close(){
  if (designClassLoader != null) {
    designClassLoader.close();
    designClassLoader=null;
  }
}","public void close(){
  if (this.appContext != null) {
    this.appContext.clear();
    this.appContext=null;
  }
  if (designClassLoader != null) {
    designClassLoader.close();
    designClassLoader=null;
  }
}",0.7228915662650602
64836,"/** 
 * Clean up the execution context before finishing using it
 */
public void close(){
  if (extendedItemManager != null) {
    extendedItemManager.close();
    extendedItemManager=null;
  }
  if (engineExtensionManager != null) {
    engineExtensionManager.close();
    engineExtensionManager=null;
  }
  if (bookmarkManager != null) {
    bookmarkManager.close();
    bookmarkManager=null;
  }
  if (dataEngine != null) {
    unRegisterDataObject();
    dataEngine.shutdown();
    dataEngine=null;
  }
  if (scriptContext != null) {
    scriptContext.close();
    scriptContext=null;
  }
  if (dataSource != null) {
    try {
      dataSource.close();
    }
 catch (    IOException e) {
      log.log(Level.SEVERE,""String_Node_Str"",e);
    }
    dataSource=null;
  }
  if (closeClassLoader && applicationClassLoader instanceof ApplicationClassLoader) {
    ((ApplicationClassLoader)applicationClassLoader).close();
  }
  IStatusHandler handler=task.getStatusHandler();
  if (handler != null) {
    handler.finish();
  }
  applicationClassLoader=null;
  engine=null;
  executor=null;
  tocBuilder=null;
  configs=null;
  params=null;
  persistentBeans=null;
  transientBeans=null;
  pageVariables=null;
  docWriter=null;
  reportIR=null;
  appContext=null;
  reportContext=null;
  renderOption=null;
  reportDoc=null;
  reportContent=null;
  design=null;
  content=null;
  rsets=null;
  reportHandles=null;
  errors.clear();
  stringFormatters=null;
  numberFormatters=null;
  dateFormatters=null;
  pageBreakListeners=null;
  eventHandlerManager=null;
  progressMonitor=null;
  element=null;
}","/** 
 * Clean up the execution context before finishing using it
 */
public void close(){
  if (extendedItemManager != null) {
    extendedItemManager.close();
    extendedItemManager=null;
  }
  if (engineExtensionManager != null) {
    engineExtensionManager.close();
    engineExtensionManager=null;
  }
  if (bookmarkManager != null) {
    bookmarkManager.close();
    bookmarkManager=null;
  }
  if (dataEngine != null) {
    unRegisterDataObject();
    dataEngine.shutdown();
    dataEngine=null;
  }
  if (scriptContext != null) {
    scriptContext.close();
    scriptContext=null;
  }
  if (dataSource != null) {
    try {
      dataSource.close();
    }
 catch (    IOException e) {
      log.log(Level.SEVERE,""String_Node_Str"",e);
    }
    dataSource=null;
  }
  if (closeClassLoader && applicationClassLoader instanceof ApplicationClassLoader) {
    ((ApplicationClassLoader)applicationClassLoader).close();
  }
  IStatusHandler handler=task.getStatusHandler();
  if (handler != null) {
    handler.finish();
  }
  applicationClassLoader=null;
  engine=null;
  executor=null;
  tocBuilder=null;
  runnable=null;
  originalRunnable=null;
  configs=null;
  params=null;
  persistentBeans=null;
  transientBeans=null;
  pageVariables=null;
  docWriter=null;
  reportIR=null;
  appContext=null;
  reportContext=null;
  renderOption=null;
  reportDoc=null;
  reportContent=null;
  design=null;
  content=null;
  rsets=null;
  reportHandles=null;
  errors.clear();
  stringFormatters=null;
  numberFormatters=null;
  dateFormatters=null;
  pageBreakListeners=null;
  eventHandlerManager=null;
  progressMonitor=null;
  element=null;
}",0.987029030265596
64837,"/** 
 * Close this module.
 */
public final void close(){
  isValid=false;
  if (!isReadOnly()) {
    saveState=activityStack.getCurrentTransNo();
    session.drop(getModule());
  }
}","/** 
 * Close this module.
 */
public void close(){
  isValid=false;
  if (options != null) {
    options.close();
  }
  if (!isReadOnly()) {
    saveState=activityStack.getCurrentTransNo();
    session.drop(getModule());
  }
}",0.8634146341463415
64838,"public Object wrap(Context cx,Scriptable scope,Object javaObject,Class staticType){
  if (javaObject instanceof LinkedHashMap) {
    return new NativeJavaLinkedHashMap(scope,javaObject,staticType);
  }
  if (javaObject instanceof BirtHashMap) {
    return new NativeJavaMap(scope,javaObject,staticType);
  }
  if (javaObject instanceof List) {
    return new NativeJavaList(scope,javaObject,staticType);
  }
  return javaObject;
}","public Object wrap(Context cx,Scriptable scope,Object javaObject,Class staticType){
  if (javaObject instanceof LinkedHashMap) {
    return new NativeJavaLinkedHashMap(scope,javaObject,staticType);
  }
  if (javaObject instanceof BirtHashMap) {
    return new NativeJavaMap(scope,javaObject,staticType);
  }
  if (javaObject instanceof List) {
    if (!(javaObject instanceof org.mozilla.javascript.NativeArray)) {
      return new NativeJavaList(scope,javaObject,staticType);
    }
  }
  return javaObject;
}",0.9158679446219382
64839,"public String getNodeDisplayName(Object element){
  PropertyHandle handle=((CrosstabPropertyHandleWrapper)element).getModel();
  String propertyName=handle.getPropertyDefn().getName();
  if (propertyName.equals(ICrosstabReportItemConstants.COLUMNS_PROP))   return Messages.getString(""String_Node_Str"");
  if (propertyName.equals(ICrosstabReportItemConstants.ROWS_PROP))   return Messages.getString(""String_Node_Str"");
  if (propertyName.equals(ICrosstabReportItemConstants.MEASURES_PROP))   return Messages.getString(""String_Node_Str"");
  if (propertyName.equals(ICrosstabReportItemConstants.HEADER_PROP))   return ""String_Node_Str"";
  return null;
}","public String getNodeDisplayName(Object element){
  PropertyHandle handle=((CrosstabPropertyHandleWrapper)element).getModel();
  String propertyName=handle.getPropertyDefn().getName();
  if (propertyName.equals(ICrosstabReportItemConstants.COLUMNS_PROP))   return Messages.getString(""String_Node_Str"");
  if (propertyName.equals(ICrosstabReportItemConstants.ROWS_PROP))   return Messages.getString(""String_Node_Str"");
  if (propertyName.equals(ICrosstabReportItemConstants.MEASURES_PROP))   return Messages.getString(""String_Node_Str"");
  if (propertyName.equals(ICrosstabReportItemConstants.HEADER_PROP))   return Messages.getString(""String_Node_Str"");
  return null;
}",0.9590909090909092
64840,"public Object getAggregatedValue(){
switch (getDataType()) {
case NUMBER:
    return new Double(((double)max) - (double)min);
case BIGDECIMAL:
  return ((BigDecimal)max).subtract((BigDecimal)min);
default :
return null;
}
}","public Object getAggregatedValue(){
switch (getDataType()) {
case NUMBER:
    return new Double(((Number)max).doubleValue() - ((Number)min).doubleValue());
case BIGDECIMAL:
  return ((BigDecimal)max).subtract((BigDecimal)min);
default :
return null;
}
}",0.9033613445378152
64841,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(org.eclipse.birt.report.engine.emitter.prototype.excel.DateSymbolTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(org.eclipse.birt.report.engine.emitter.prototype.excel.DateSymbolTest.class);
  suite.addTestSuite(org.eclipse.birt.report.engine.emitter.prototype.excel.ExcelWriterTest.class);
  return suite;
}",0.7967479674796748
64842,"public void testParse(){
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,null,ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
}","@SuppressWarnings(""String_Node_Str"") public void testParse(){
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,null,ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
  assertEquals(""String_Node_Str"",ExcelUtil.parse(null,""String_Node_Str"",ULocale.US));
}",0.974287699791522
64843,"public void testStartSheet() throws IOException {
  ExcelContext context=new ExcelContext();
  ExcelWriter writer=new ExcelWriter(context);
  writer.start(null,new HashMap<StyleEntry,Integer>(),new HashMap<String,BookmarkDef>());
  writer.startSheet(""String_Node_Str"");
  writer.startRow();
  writer.outputData(1,1,SheetData.NUMBER,1);
  writer.endRow();
  writer.endSheet();
  writer.end();
}","public void testStartSheet(){
  try {
    ExcelEmitter emitter=new ExcelEmitter();
    EXCELRenderOption renderOption=new EXCELRenderOption();
    new File(""String_Node_Str"").mkdir();
    renderOption.setOutputFileName(""String_Node_Str"");
    EngineEmitterServices services=new EngineEmitterServices(null,renderOption,null);
    ExcelContext context=new ExcelContext();
    context.initialize(services);
    ExcelWriter writer=new ExcelWriter(context);
    writer.start(null,new HashMap<StyleEntry,Integer>(),new HashMap<String,BookmarkDef>());
    writer.startSheet(""String_Node_Str"");
    writer.startRow();
    writer.outputData(1,1,SheetData.NUMBER,1);
    writer.endRow();
    writer.endSheet();
    writer.end();
  }
 catch (  Exception ex) {
    fail(""String_Node_Str"" + ex.toString());
  }
}",0.5587248322147651
64844,"public void initialize(IEmitterServices service) throws EngineException {
  if (service == null) {
    return;
  }
  out=EmitterUtil.getOuputStream(service,""String_Node_Str"");
  this.tempFileDir=service.getReportEngine().getConfig().getTempDir();
  IReportContext reportContext=service.getReportContext();
  if (reportContext != null) {
    Locale locale=reportContext.getLocale();
    this.locale=locale == null ? ULocale.getDefault() : ULocale.forLocale(locale);
    this.timeZone=reportContext.getTimeZone();
    if (timeZone == null) {
      timeZone=TimeZone.getDefault();
    }
  }
  IRenderOption renderOption=service.getRenderOption();
  Object option=renderOption.getOption(IExcelRenderOption.OPTION_MULTIPLE_SHEET);
  if (option instanceof Boolean)   enableMultipleSheet=(Boolean)option;
  this.reportContext=service.getReportContext();
}","public void initialize(IEmitterServices service) throws EngineException {
  if (service == null) {
    return;
  }
  out=EmitterUtil.getOuputStream(service,""String_Node_Str"");
  if (service.getReportEngine() != null) {
    this.tempFileDir=service.getReportEngine().getConfig().getTempDir();
  }
  IReportContext reportContext=service.getReportContext();
  if (reportContext != null) {
    Locale locale=reportContext.getLocale();
    this.locale=locale == null ? ULocale.getDefault() : ULocale.forLocale(locale);
    this.timeZone=reportContext.getTimeZone();
    if (timeZone == null) {
      timeZone=TimeZone.getDefault();
    }
  }
  IRenderOption renderOption=service.getRenderOption();
  Object option=renderOption.getOption(IExcelRenderOption.OPTION_MULTIPLE_SHEET);
  if (option instanceof Boolean)   enableMultipleSheet=(Boolean)option;
  this.reportContext=service.getReportContext();
}",0.971919770773639
64845,"/** 
 * Defines the initial layout for a page.
 */
private void defineLayout(IPageLayout layout){
  String editorArea=layout.getEditorArea();
  IFolderLayout topLeft=layout.createFolder(""String_Node_Str"",IPageLayout.LEFT,(float)0.26,editorArea);
  addLayoutView(topLeft,IReportPerspectiveExtra.LAYOUT_TOP_LEFT,PaletteView.ID);
  addLayoutView(topLeft,IReportPerspectiveExtra.LAYOUT_TOP_LEFT,DataView.ID);
  addLayoutView(topLeft,IReportPerspectiveExtra.LAYOUT_TOP_LEFT,LibraryExplorerView.ID);
  IFolderLayout bottomLeft=layout.createFolder(""String_Node_Str"",IPageLayout.BOTTOM,(float)0.50,""String_Node_Str"");
  addLayoutView(bottomLeft,IReportPerspectiveExtra.LAYOUT_BOTTOM_LEFT,IPageLayout.ID_RES_NAV);
  addLayoutView(bottomLeft,IReportPerspectiveExtra.LAYOUT_BOTTOM_LEFT,IPageLayout.ID_OUTLINE);
  IFolderLayout bottomRight=layout.createFolder(""String_Node_Str"",IPageLayout.BOTTOM,(float)0.66,editorArea);
  addLayoutView(bottomRight,IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT,AttributeView.ID);
  addLayoutView(bottomRight,IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT,IPageLayout.ID_PROBLEM_VIEW);
  addLayoutView(bottomRight,IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT,""String_Node_Str"");
  if (extra != null) {
    String[] ids=extra.getExtraLayoutView(IReportPerspectiveExtra.LAYOUT_TOP_LEFT);
    if (ids != null) {
      for (      String id : ids) {
        topLeft.addView(id);
      }
    }
    ids=extra.getExtraLayoutView(IReportPerspectiveExtra.LAYOUT_BOTTOM_LEFT);
    if (ids != null) {
      for (      String id : ids) {
        bottomLeft.addView(id);
      }
    }
    ids=extra.getExtraLayoutView(IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT);
    if (ids != null) {
      for (      String id : ids) {
        bottomRight.addView(id);
      }
    }
    ids=extra.getExtraLayoutPlaceholder(IReportPerspectiveExtra.LAYOUT_TOP_LEFT);
    if (ids != null) {
      for (      String id : ids) {
        topLeft.addPlaceholder(id);
      }
    }
    ids=extra.getExtraLayoutPlaceholder(IReportPerspectiveExtra.LAYOUT_BOTTOM_LEFT);
    if (ids != null) {
      for (      String id : ids) {
        bottomLeft.addPlaceholder(id);
      }
    }
    ids=extra.getExtraLayoutPlaceholder(IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT);
    if (ids != null) {
      for (      String id : ids) {
        bottomRight.addPlaceholder(id);
      }
    }
  }
  Preferences instancePrefs=(InstanceScope.INSTANCE).getNode(""String_Node_Str"");
  instancePrefs.putBoolean(""String_Node_Str"",false);
  try {
    instancePrefs.flush();
  }
 catch (  BackingStoreException e) {
  }
  IDialogSettings settings=((AbstractUIPlugin)Platform.getPlugin(""String_Node_Str"")).getDialogSettings();
  String className=""String_Node_Str"";
  if (settings.getSection(className) == null) {
    settings=settings.addNewSection(className);
  }
 else {
    settings=settings.getSection(className);
  }
  settings.put(""String_Node_Str"",false);
  settings.put(""String_Node_Str"",false);
  settings.put(""String_Node_Str"",true);
  settings.put(""String_Node_Str"",true);
}","/** 
 * Defines the initial layout for a page.
 */
private void defineLayout(IPageLayout layout){
  String editorArea=layout.getEditorArea();
  IFolderLayout topLeft=layout.createFolder(""String_Node_Str"",IPageLayout.LEFT,(float)0.26,editorArea);
  addLayoutView(topLeft,IReportPerspectiveExtra.LAYOUT_TOP_LEFT,PaletteView.ID);
  addLayoutView(topLeft,IReportPerspectiveExtra.LAYOUT_TOP_LEFT,DataView.ID);
  addLayoutView(topLeft,IReportPerspectiveExtra.LAYOUT_TOP_LEFT,LibraryExplorerView.ID);
  IFolderLayout bottomLeft=layout.createFolder(""String_Node_Str"",IPageLayout.BOTTOM,(float)0.50,""String_Node_Str"");
  addLayoutView(bottomLeft,IReportPerspectiveExtra.LAYOUT_BOTTOM_LEFT,IPageLayout.ID_RES_NAV);
  addLayoutView(bottomLeft,IReportPerspectiveExtra.LAYOUT_BOTTOM_LEFT,IPageLayout.ID_OUTLINE);
  IFolderLayout bottomRight=layout.createFolder(""String_Node_Str"",IPageLayout.BOTTOM,(float)0.66,editorArea);
  addLayoutView(bottomRight,IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT,AttributeView.ID);
  addLayoutView(bottomRight,IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT,IPageLayout.ID_PROBLEM_VIEW);
  addLayoutView(bottomRight,IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT,""String_Node_Str"");
  if (extra != null) {
    String[] ids=extra.getExtraLayoutView(IReportPerspectiveExtra.LAYOUT_TOP_LEFT);
    if (ids != null) {
      for (      String id : ids) {
        topLeft.addView(id);
      }
    }
    ids=extra.getExtraLayoutView(IReportPerspectiveExtra.LAYOUT_BOTTOM_LEFT);
    if (ids != null) {
      for (      String id : ids) {
        bottomLeft.addView(id);
      }
    }
    ids=extra.getExtraLayoutView(IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT);
    if (ids != null) {
      for (      String id : ids) {
        bottomRight.addView(id);
      }
    }
    ids=extra.getExtraLayoutPlaceholder(IReportPerspectiveExtra.LAYOUT_TOP_LEFT);
    if (ids != null) {
      for (      String id : ids) {
        topLeft.addPlaceholder(id);
      }
    }
    ids=extra.getExtraLayoutPlaceholder(IReportPerspectiveExtra.LAYOUT_BOTTOM_LEFT);
    if (ids != null) {
      for (      String id : ids) {
        bottomLeft.addPlaceholder(id);
      }
    }
    ids=extra.getExtraLayoutPlaceholder(IReportPerspectiveExtra.LAYOUT_BOTTOM_RIGHT);
    if (ids != null) {
      for (      String id : ids) {
        bottomRight.addPlaceholder(id);
      }
    }
  }
  Preferences instancePrefs=(InstanceScope.INSTANCE).getNode(""String_Node_Str"");
  instancePrefs.putBoolean(""String_Node_Str"",false);
  try {
    instancePrefs.flush();
  }
 catch (  BackingStoreException e) {
  }
  Plugin plugin=Platform.getPlugin(""String_Node_Str"");
  if (plugin != null) {
    IDialogSettings settings=((AbstractUIPlugin)plugin).getDialogSettings();
    String className=""String_Node_Str"";
    if (settings.getSection(className) == null) {
      settings=settings.addNewSection(className);
    }
 else {
      settings=settings.getSection(className);
    }
    settings.put(""String_Node_Str"",false);
    settings.put(""String_Node_Str"",false);
    settings.put(""String_Node_Str"",true);
    settings.put(""String_Node_Str"",true);
  }
}",0.9759584145549056
64846,"public void start(){
  super.start();
  sum=0D;
}","public void start(){
  super.start();
  sum=BigDecimal.ZERO;
}",0.8648648648648649
64847,"public Object getSummaryValue(){
  return new BigDecimal(sum.toString());
}","public Object getSummaryValue(){
  return sum;
}",0.7804878048780488
64848,"public void start(){
  super.start();
  sum=new BigDecimal(new char[]{'0'},0,1);
}","public void start(){
  super.start();
  sum=0D;
}",0.732824427480916
64849,"public Object getSummaryValue(){
  return sum;
}","public Object getSummaryValue(){
  return new BigDecimal(sum.toString());
}",0.7804878048780488
64850,"public void testTotalSum() throws Exception {
  IAggrFunction ag=buildInAggrFactory.getAggregation(""String_Node_Str"");
  Accumulator ac=ag.newAccumulator();
  assertEquals(IBuildInAggregation.TOTAL_SUM_FUNC,ag.getName());
  assertEquals(IAggrFunction.SUMMARY_AGGR,ag.getType());
  assertEquals(1,ag.getParameterDefn().length);
  assertTrue(!ag.getParameterDefn()[0].isOptional());
  ac.start();
  for (int i=0; i < doubleArray1.length; i++) {
    ac.onRow(new Double[]{new Double(doubleArray1[i])});
  }
  ac.finish();
  assertEquals(new Double(82.0),ac.getValue());
  ac.start();
  for (int i=0; i < doubleArray2.length; i++) {
    ac.onRow(new Double[]{new Double(doubleArray2[i])});
  }
  ac.finish();
  assertEquals(new Double(69.0),ac.getValue());
  ac.start();
  for (int i=0; i < str1.length; i++) {
    ac.onRow(new Object[]{str1[i]});
  }
  ac.finish();
  assertEquals(new Double(69.0),ac.getValue());
  ac.start();
  ac.finish();
  assertEquals(new BigDecimal(""String_Node_Str""),ac.getValue());
  ac.start();
  try {
    ac.getValue();
    assertTrue(false);
  }
 catch (  RuntimeException e) {
    assertTrue(true);
  }
  ac.start();
  try {
    for (int i=0; i < str2.length; i++) {
      ac.onRow(new Object[]{str2[i]});
    }
    fail();
  }
 catch (  DataException e) {
    assertTrue(true);
  }
  ac.finish();
  ac.start();
  for (int i=0; i < bigDecimalArray.length; i++) {
    ac.onRow(new Object[]{bigDecimalArray[i]});
  }
  ac.finish();
  assertEquals(new BigDecimal(""String_Node_Str""),ac.getValue());
}","public void testTotalSum() throws Exception {
  IAggrFunction ag=buildInAggrFactory.getAggregation(""String_Node_Str"");
  Accumulator ac=ag.newAccumulator();
  assertEquals(IBuildInAggregation.TOTAL_SUM_FUNC,ag.getName());
  assertEquals(IAggrFunction.SUMMARY_AGGR,ag.getType());
  assertEquals(1,ag.getParameterDefn().length);
  assertTrue(!ag.getParameterDefn()[0].isOptional());
  ac.start();
  for (int i=0; i < doubleArray1.length; i++) {
    ac.onRow(new Double[]{new Double(doubleArray1[i])});
  }
  ac.finish();
  assertEquals(new Double(82.0),ac.getValue());
  ac.start();
  for (int i=0; i < doubleArray2.length; i++) {
    ac.onRow(new Double[]{new Double(doubleArray2[i])});
  }
  ac.finish();
  assertEquals(new Double(69.0),ac.getValue());
  ac.start();
  for (int i=0; i < str1.length; i++) {
    ac.onRow(new Object[]{str1[i]});
  }
  ac.finish();
  assertEquals(new Double(69.0),ac.getValue());
  ac.start();
  ac.finish();
  assertEquals(new Double(0.0),ac.getValue());
  ac.start();
  try {
    ac.getValue();
    assertTrue(false);
  }
 catch (  RuntimeException e) {
    assertTrue(true);
  }
  ac.start();
  try {
    for (int i=0; i < str2.length; i++) {
      ac.onRow(new Object[]{str2[i]});
    }
    fail();
  }
 catch (  DataException e) {
    assertTrue(true);
  }
  ac.finish();
  ac.start();
  for (int i=0; i < bigDecimalArray.length; i++) {
    ac.onRow(new Object[]{bigDecimalArray[i]});
  }
  ac.finish();
  assertEquals(new BigDecimal(""String_Node_Str""),ac.getValue());
}",0.988118811881188
64851,"public void start(){
  super.start();
  sum=0D;
}","public void start(){
  super.start();
  sum=new BigDecimal(new char[]{'0'},0,1);
}",0.732824427480916
64852,"public Object getSummaryValue(){
  return new BigDecimal(sum.toString());
}","public Object getSummaryValue(){
  return sum;
}",0.7804878048780488
64853,"public void testTotalSum() throws Exception {
  IAggrFunction ag=buildInAggrFactory.getAggregation(""String_Node_Str"");
  Accumulator ac=ag.newAccumulator();
  assertEquals(IBuildInAggregation.TOTAL_SUM_FUNC,ag.getName());
  assertEquals(IAggrFunction.SUMMARY_AGGR,ag.getType());
  assertEquals(1,ag.getParameterDefn().length);
  assertTrue(!ag.getParameterDefn()[0].isOptional());
  ac.start();
  for (int i=0; i < doubleArray1.length; i++) {
    ac.onRow(new Double[]{new Double(doubleArray1[i])});
  }
  ac.finish();
  assertEquals(new Double(82.0),ac.getValue());
  ac.start();
  for (int i=0; i < doubleArray2.length; i++) {
    ac.onRow(new Double[]{new Double(doubleArray2[i])});
  }
  ac.finish();
  assertEquals(new Double(69.0),ac.getValue());
  ac.start();
  for (int i=0; i < str1.length; i++) {
    ac.onRow(new Object[]{str1[i]});
  }
  ac.finish();
  assertEquals(new Double(69.0),ac.getValue());
  ac.start();
  ac.finish();
  assertEquals(new Double(0.0),ac.getValue());
  ac.start();
  try {
    ac.getValue();
    assertTrue(false);
  }
 catch (  RuntimeException e) {
    assertTrue(true);
  }
  ac.start();
  try {
    for (int i=0; i < str2.length; i++) {
      ac.onRow(new Object[]{str2[i]});
    }
    fail();
  }
 catch (  DataException e) {
    assertTrue(true);
  }
  ac.finish();
  ac.start();
  for (int i=0; i < bigDecimalArray.length; i++) {
    ac.onRow(new Object[]{bigDecimalArray[i]});
  }
  ac.finish();
  assertEquals(new BigDecimal(""String_Node_Str""),ac.getValue());
}","public void testTotalSum() throws Exception {
  IAggrFunction ag=buildInAggrFactory.getAggregation(""String_Node_Str"");
  Accumulator ac=ag.newAccumulator();
  assertEquals(IBuildInAggregation.TOTAL_SUM_FUNC,ag.getName());
  assertEquals(IAggrFunction.SUMMARY_AGGR,ag.getType());
  assertEquals(1,ag.getParameterDefn().length);
  assertTrue(!ag.getParameterDefn()[0].isOptional());
  ac.start();
  for (int i=0; i < doubleArray1.length; i++) {
    ac.onRow(new Double[]{new Double(doubleArray1[i])});
  }
  ac.finish();
  assertEquals(new Double(82.0),ac.getValue());
  ac.start();
  for (int i=0; i < doubleArray2.length; i++) {
    ac.onRow(new Double[]{new Double(doubleArray2[i])});
  }
  ac.finish();
  assertEquals(new Double(69.0),ac.getValue());
  ac.start();
  for (int i=0; i < str1.length; i++) {
    ac.onRow(new Object[]{str1[i]});
  }
  ac.finish();
  assertEquals(new Double(69.0),ac.getValue());
  ac.start();
  ac.finish();
  assertEquals(new BigDecimal(""String_Node_Str""),ac.getValue());
  ac.start();
  try {
    ac.getValue();
    assertTrue(false);
  }
 catch (  RuntimeException e) {
    assertTrue(true);
  }
  ac.start();
  try {
    for (int i=0; i < str2.length; i++) {
      ac.onRow(new Object[]{str2[i]});
    }
    fail();
  }
 catch (  DataException e) {
    assertTrue(true);
  }
  ac.finish();
  ac.start();
  for (int i=0; i < bigDecimalArray.length; i++) {
    ac.onRow(new Object[]{bigDecimalArray[i]});
  }
  ac.finish();
  assertEquals(new BigDecimal(""String_Node_Str""),ac.getValue());
}",0.988118811881188
64854,"/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FirstDayOfFiscalQuarter</code>
 */
public void testFirstDayOfFiscalQuarter() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Calendar c=Calendar.getInstance();
  c.clear();
  Date[] values=new Date[]{date(c,2015,3,1),date(c,2015,3,1),date(c,2015,0,15),date(c,2015,6,10),date(c,2015,3,10),date(c,2013,10,10),date(c,2014,8,30)};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}","/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FirstDayOfFiscalQuarter</code>
 */
public void testFirstDayOfFiscalQuarter() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Calendar c=Calendar.getInstance();
  c.clear();
  Date[] values=new Date[]{date(c,2015,3,1),date(c,CURRENT_YEAR,9,1),date(c,2015,3,1),date(c,2015,0,15),date(c,2015,6,10),date(c,2015,3,10),date(c,2013,10,10),date(c,2014,8,30)};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}",0.9717291255752796
64855,"/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FirstDayOfFiscalMonth</code>
 */
public void testFirstDayOfFiscalMonth() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Calendar c=Calendar.getInstance();
  c.clear();
  Date[] values=new Date[]{date(c,2015,5,1),date(c,2015,5,1),date(c,2014,7,15),date(c,2015,6,10),date(c,2015,5,10),date(c,2013,11,10),date(c,2014,0,31),date(c,2014,8,30)};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}","/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FirstDayOfFiscalMonth</code>
 */
public void testFirstDayOfFiscalMonth() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Calendar c=Calendar.getInstance();
  c.clear();
  Date[] values=new Date[]{date(c,2015,5,1),date(c,CURRENT_YEAR,9,1),date(c,2015,5,1),date(c,2014,7,15),date(c,2015,6,10),date(c,2015,5,10),date(c,2013,11,10),date(c,2014,0,31),date(c,2014,8,30)};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}",0.972870662460568
64856,"protected Object getValue(Object[] args,IScriptFunctionContext context) throws BirtException {
  if (existNullValue(args)) {
    return null;
  }
  Calendar current=null;
  if (args[0] instanceof Integer) {
    current=getFiscalYearStateDate(context,args);
    current.set(Calendar.YEAR,(Integer)args[0]);
    if (current.get(Calendar.DAY_OF_YEAR) > 1) {
      current.add(Calendar.YEAR,-1);
    }
  }
 else {
    current=getCalendar(DataTypeUtil.toDate(args[0]));
    Calendar start=getFiscalYearStateDate(context,args);
    adjustFiscalYear(current,start);
    current.set(Calendar.MONTH,start.get(Calendar.MONTH));
    current.set(Calendar.DATE,Math.min(start.get(Calendar.DATE),current.getActualMaximum(Calendar.DATE)));
  }
  return current.getTime();
}","protected Object getValue(Object[] args,IScriptFunctionContext context) throws BirtException {
  if (existNullValue(args)) {
    return null;
  }
  Calendar current=null;
  if (args[0] instanceof Number) {
    current=getFiscalYearStateDate(context,args);
    current.set(Calendar.YEAR,((Number)args[0]).intValue());
    if (current.get(Calendar.DAY_OF_YEAR) > 1) {
      current.add(Calendar.YEAR,-1);
    }
  }
 else {
    current=getCalendar(DataTypeUtil.toDate(args[0]));
    Calendar start=getFiscalYearStateDate(context,args);
    adjustFiscalYear(current,start);
    current.set(Calendar.MONTH,start.get(Calendar.MONTH));
    current.set(Calendar.DATE,Math.min(start.get(Calendar.DATE),current.getActualMaximum(Calendar.DATE)));
  }
  return current.getTime();
}",0.97969875573019
64857,"private static String encode(String location){
  try {
    return new File(location).toURI().toASCIIString().replace(new File(""String_Node_Str"").toURI().toASCIIString(),""String_Node_Str"");
  }
 catch (  Exception e) {
    return location;
  }
}","private static String encode(String location){
  try {
    return new File(location).toURI().toASCIIString();
  }
 catch (  Exception e) {
    return location;
  }
}",0.8068459657701712
64858,"IConnection openConnection() throws OdaException {
  if (connection != null) {
    return connection;
  }
  IDriver jdbcDriver=JDBCDriverManager.getInstance().getDriver(dataSourceDesign.getEffectiveOdaExtensionId());
  try {
    connection=jdbcDriver.getConnection(dataSourceDesign.getEffectiveOdaExtensionId());
    Properties prop=DesignSessionUtil.getEffectiveDataSourceProperties(dataSourceDesign);
    connection.open(prop);
  }
 catch (  OdaException e) {
    connection=null;
    throw e;
  }
  return connection;
}","IConnection openConnection() throws OdaException {
  if (connection != null) {
    return connection;
  }
  IDriver jdbcDriver=JDBCDriverManager.getInstance().getDriver(dataSourceDesign.getEffectiveOdaExtensionId());
  try {
    connection=jdbcDriver.getConnection(dataSourceDesign.getEffectiveOdaExtensionId());
    Map appContext=new HashMap();
    ResourceIdentifiers resourceIdentifiers=dataSourceDesign.getHostResourceIdentifiers();
    if (resourceIdentifiers != null) {
      appContext.put(org.eclipse.datatools.connectivity.oda.util.ResourceIdentifiers.ODA_APP_CONTEXT_KEY_CONSUMER_RESOURCE_IDS,DesignSessionUtil.createRuntimeResourceIdentifiers(resourceIdentifiers));
    }
    connection.setAppContext(appContext);
    Properties prop=DesignSessionUtil.getEffectiveDataSourceProperties(dataSourceDesign);
    connection.open(prop);
  }
 catch (  OdaException e) {
    connection=null;
    throw e;
  }
  return connection;
}",0.7165408373369938
64859,"/** 
 * Tests to extends for the oda datasource <ul> <li>dataSource1 has extendsion id, dataSource1 hasn't. Exception is thrown. <li>if both have extension id, no exception. </ul>
 * @throws Exception
 */
public void testSetExtends() throws Exception {
  sessionHandle=DesignEngine.newSession(ULocale.ENGLISH);
  designHandle=sessionHandle.createDesign();
  OdaDataSourceHandle dataSource1=designHandle.getElementFactory().newOdaDataSource(""String_Node_Str"",DATASOURCE_EXTENSION_ID);
  designHandle.getDataSources().add(dataSource1);
  OdaDataSourceHandle dataSource2=designHandle.getElementFactory().newOdaDataSource(""String_Node_Str"",null);
  designHandle.getDataSources().add(dataSource2);
  try {
    dataSource2.setExtends(dataSource1);
    fail();
  }
 catch (  ExtendsException e) {
    assertEquals(ExtendsException.DESIGN_EXCEPTION_WRONG_EXTENSION_TYPE,e.getErrorCode());
  }
  try {
    dataSource1.setExtends(dataSource2);
    fail();
  }
 catch (  ExtendsException e) {
    assertEquals(ExtendsException.DESIGN_EXCEPTION_WRONG_EXTENSION_TYPE,e.getErrorCode());
  }
  dataSource2.getElement().setProperty(IOdaExtendableElementModel.EXTENSION_ID_PROP,DATASOURCE_EXTENSION_ID);
  dataSource2.setExtends(dataSource1);
}","/** 
 * Tests to extends for the oda datasource <ul> <li>dataSource1 has extendsion id, dataSource1 hasn't. Exception is thrown. <li>if both have extension id, no exception. </ul>
 * @throws Exception
 */
public void testSetExtends() throws Exception {
  sessionHandle=DesignEngine.newSession(ULocale.ENGLISH);
  designHandle=sessionHandle.createDesign();
  OdaDataSourceHandle dataSource1=designHandle.getElementFactory().newOdaDataSource(""String_Node_Str"",DATASOURCE_EXTENSION_ID);
  designHandle.getDataSources().add(dataSource1);
  OdaDataSourceHandle dataSource2=designHandle.getElementFactory().newOdaDataSource(""String_Node_Str"",null);
  designHandle.getDataSources().add(dataSource2);
  try {
    dataSource2.setExtends(dataSource1);
    fail();
  }
 catch (  ExtendsException e) {
    assertEquals(ExtendsException.DESIGN_EXCEPTION_WRONG_TYPE,e.getErrorCode());
  }
  try {
    dataSource1.setExtends(dataSource2);
    fail();
  }
 catch (  ExtendsException e) {
    assertEquals(ExtendsException.DESIGN_EXCEPTION_WRONG_TYPE,e.getErrorCode());
  }
  dataSource2.getElement().setProperty(IOdaExtendableElementModel.EXTENSION_ID_PROP,DATASOURCE_EXTENSION_ID);
  dataSource2.setExtends(dataSource1);
}",0.9917830731306492
64860,"private void doAddContent(IContent content){
  if (contents.size() == CONTENTS_CONVERTION_THRESHOLD) {
    contents=new TreeSet<IContent>(contents);
  }
  contents.add(content);
}","private void doAddContent(IContent content){
  if (contents.size() == CONTENTS_CONVERTION_THRESHOLD) {
    contents=new LinkedHashSet<IContent>(contents);
  }
  contents.add(content);
}",0.967032967032967
64861,"@Override public Set<IBaseLinkDefinition> getLinks(){
  return this.links;
}","public Set<IBaseLinkDefinition> getLinks(){
  return this.links;
}",0.9295774647887324
64862,"@Override public void addLink(IBaseLinkDefinition link){
  this.links.add(link);
}","public void addLink(IBaseLinkDefinition link){
  this.links.add(link);
}",0.935064935064935
64863,"protected void cloneFields(CubeQueryDefinition cloned){
  cloned.bindingList.addAll(this.bindingList);
  cloned.breakHierarchyOption=this.breakHierarchyOption;
  cloned.cacheQueryResults=this.cacheQueryResults;
  cloned.columnEdge=this.columnEdge != null ? this.columnEdge.clone() : null;
  cloned.computedMeasureList.addAll(this.computedMeasureList);
  cloned.cubeOperations.addAll(this.cubeOperations);
  cloned.derivedMeasureList.addAll(this.derivedMeasureList);
  cloned.filterList.addAll(this.filterList);
  cloned.ID=this.ID;
  cloned.measureList.addAll(this.measureList);
  cloned.needAccessFactTable=this.needAccessFactTable;
  cloned.pageEdge=this.pageEdge != null ? this.pageEdge.clone() : null;
  cloned.queryResultsID=this.queryResultsID;
  cloned.rowEdge=this.rowEdge != null ? this.rowEdge.clone() : null;
  cloned.sortList.addAll(this.sortList);
}","protected void cloneFields(CubeQueryDefinition cloned){
  cloned.bindingList.addAll(this.bindingList);
  cloned.breakHierarchyOption=this.breakHierarchyOption;
  cloned.cacheQueryResults=this.cacheQueryResults;
  cloned.columnEdge=this.columnEdge != null ? this.columnEdge.clone() : null;
  cloned.computedMeasureList.addAll(this.computedMeasureList);
  cloned.cubeOperations.addAll(this.cubeOperations);
  cloned.derivedMeasureList.addAll(this.derivedMeasureList);
  cloned.filterList.addAll(this.filterList);
  cloned.ID=this.ID;
  cloned.measureList.addAll(this.measureList);
  cloned.needAccessFactTable=this.needAccessFactTable;
  cloned.pageEdge=this.pageEdge != null ? this.pageEdge.clone() : null;
  cloned.queryResultsID=this.queryResultsID;
  cloned.rowEdge=this.rowEdge != null ? this.rowEdge.clone() : null;
  cloned.sortList.addAll(this.sortList);
  cloned.links.addAll(this.links);
}",0.9801023308698124
64864,"public static QueryDefinition cloneQuery(QueryDefinition query){
  if (query == null) {
    return null;
  }
  IBaseQueryDefinition parent=query.getParentQuery();
  QueryDefinition newQuery=null;
  if (parent instanceof BaseQueryDefinition) {
    newQuery=new QueryDefinition((BaseQueryDefinition)parent,query.needAutoBinding());
  }
 else {
    newQuery=new QueryDefinition(query.needAutoBinding());
  }
  newQuery.getBindings().putAll(query.getBindings());
  newQuery.getFilters().addAll(query.getFilters());
  newQuery.getSorts().addAll(query.getSorts());
  newQuery.getSubqueries().addAll(query.getSubqueries());
  newQuery.getGroups().addAll(query.getGroups());
  newQuery.setUsesDetails(query.usesDetails());
  newQuery.setMaxRows(query.getMaxRows());
  newQuery.setDataSetName(query.getDataSetName());
  newQuery.setColumnProjection(query.getColumnProjection());
  newQuery.setName(query.getName());
  newQuery.setIsSummaryQuery(query.isSummaryQuery());
  newQuery.setQueryExecutionHints(query.getQueryExecutionHints());
  return newQuery;
}","public static QueryDefinition cloneQuery(QueryDefinition query){
  if (query == null) {
    return null;
  }
  IBaseQueryDefinition parent=query.getParentQuery();
  QueryDefinition newQuery=null;
  if (parent instanceof BaseQueryDefinition) {
    newQuery=new QueryDefinition((BaseQueryDefinition)parent,query.needAutoBinding());
  }
 else {
    newQuery=new QueryDefinition(query.needAutoBinding());
  }
  newQuery.getBindings().putAll(query.getBindings());
  newQuery.getFilters().addAll(query.getFilters());
  newQuery.getSorts().addAll(query.getSorts());
  newQuery.getSubqueries().addAll(query.getSubqueries());
  newQuery.getGroups().addAll(query.getGroups());
  newQuery.setUsesDetails(query.usesDetails());
  newQuery.setMaxRows(query.getMaxRows());
  newQuery.setDataSetName(query.getDataSetName());
  newQuery.setColumnProjection(query.getColumnProjection());
  newQuery.setName(query.getName());
  newQuery.setIsSummaryQuery(query.isSummaryQuery());
  newQuery.setQueryExecutionHints(query.getQueryExecutionHints());
  newQuery.setLinks(query.getLinks());
  return newQuery;
}",0.9817330210772832
64865,"private void doAddContent(IContent content){
  if (contents.size() == CONTENTS_CONVERTION_THRESHOLD) {
    contents=new TreeSet<IContent>(contents);
  }
  contents.add(content);
}","private void doAddContent(IContent content){
  if (contents.size() == CONTENTS_CONVERTION_THRESHOLD) {
    contents=new LinkedHashSet<IContent>(contents);
  }
  contents.add(content);
}",0.967032967032967
64866,"/** 
 */
public void testLike(){
  String[] script=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  boolean[] result=new boolean[]{true,true,true,true,true,false,false,false,true,false,true,false,true};
  for (int i=0; i < script.length; i++) {
    assertEquals(result[i],((Boolean)cx.evaluateString(scope,script[i],""String_Node_Str"",1,null)).booleanValue());
  }
}","/** 
 */
public void testLike(){
  String[] script=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  boolean[] result=new boolean[]{true,true,true,true,true,false,false,false,true,false,true,false,true,true,false,true,true};
  for (int i=0; i < script.length; i++) {
    assertEquals(result[i],((Boolean)cx.evaluateString(scope,script[i],""String_Node_Str"",1,null)).booleanValue());
  }
}",0.9242053789731052
64867,"/** 
 * @param obj1
 * @param obj2
 * @return true x matches SQL pattern y
 * @throws BirtException
 * @throws DataException
 */
private static boolean like(Object source,Object pattern,boolean ignorecase) throws BirtException {
  String sourceStr=null;
  sourceStr=(source == null) ? ""String_Node_Str"" : DataTypeUtil.toLocaleNeutralString(source);
  String patternStr;
  patternStr=(pattern == null) ? ""String_Node_Str"" : DataTypeUtil.toLocaleNeutralString(pattern);
  final String reservedChars=""String_Node_Str"";
  int patternLen=patternStr.length();
  StringBuffer buffer=new StringBuffer(patternLen * 2);
  for (int i=0; i < patternLen; i++) {
    char c=patternStr.charAt(i);
    if (c == '\\') {
      ++i;
      if (i < patternLen) {
        c=patternStr.charAt(i);
        if (c == '%' || c == '_')         buffer.append(c);
 else         if (c == '\\')         buffer.append(""String_Node_Str"");
      }
 else {
        buffer.append(""String_Node_Str"");
      }
    }
 else     if (c == '%') {
      buffer.append(""String_Node_Str"");
    }
 else     if (c == '_') {
      buffer.append(""String_Node_Str"");
    }
 else {
      if (reservedChars.indexOf(c) >= 0) {
        buffer.append('\\');
      }
      buffer.append(c);
    }
  }
  try {
    String newPatternStr=buffer.toString();
    Pattern p=null;
    if (!ignorecase) {
      p=Pattern.compile(newPatternStr);
    }
 else {
      p=Pattern.compile(newPatternStr,Pattern.CASE_INSENSITIVE);
    }
    Matcher m=p.matcher(sourceStr.toString());
    return m.matches();
  }
 catch (  PatternSyntaxException e) {
    throw new BirtException(e.getMessage());
  }
}","/** 
 * @param obj1
 * @param obj2
 * @return true x matches SQL pattern y
 * @throws BirtException
 * @throws DataException
 */
private static boolean like(Object source,Object pattern,boolean ignorecase) throws BirtException {
  String sourceStr=null;
  sourceStr=(source == null) ? ""String_Node_Str"" : DataTypeUtil.toLocaleNeutralString(source);
  String patternStr;
  patternStr=(pattern == null) ? ""String_Node_Str"" : DataTypeUtil.toLocaleNeutralString(pattern);
  final String reservedChars=""String_Node_Str"";
  int patternLen=patternStr.length();
  StringBuffer buffer=new StringBuffer(patternLen * 2);
  for (int i=0; i < patternLen; i++) {
    char c=patternStr.charAt(i);
    if (c == '\\') {
      ++i;
      if (i < patternLen) {
        c=patternStr.charAt(i);
        if (c == '%' || c == '_')         buffer.append(c);
 else         if (c == '\\')         buffer.append(""String_Node_Str"");
      }
 else {
        buffer.append(""String_Node_Str"");
      }
    }
 else     if (c == '%') {
      buffer.append(""String_Node_Str"");
    }
 else     if (c == '_') {
      buffer.append(""String_Node_Str"");
    }
 else {
      if (reservedChars.indexOf(c) >= 0) {
        buffer.append('\\');
      }
      buffer.append(c);
    }
  }
  try {
    String newPatternStr=buffer.toString();
    Pattern p=null;
    if (!ignorecase) {
      p=Pattern.compile(newPatternStr,Pattern.DOTALL);
    }
 else {
      p=Pattern.compile(newPatternStr,Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
    }
    Matcher m=p.matcher(sourceStr.toString());
    return m.matches();
  }
 catch (  PatternSyntaxException e) {
    throw new BirtException(e.getMessage());
  }
}",0.9902557856272838
64868,"public String getQueryText() throws BirtException {
  return queryText;
}","public String getQueryText(){
  return queryText;
}",0.8225806451612904
64869,"public String getQueryText() throws ScriptException {
  try {
    return dataSet.getQueryText();
  }
 catch (  BirtException e) {
    throw new ScriptException(e.getLocalizedMessage());
  }
}","public String getQueryText() throws ScriptException {
  return dataSet.getQueryText();
}",0.6308243727598566
64870,"/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FiscalWeek</code>
 */
public void testFiscalWeek() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] values=new int[]{1,2,1,53,27,28,2,6};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}","/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FiscalWeek</code>
 */
public void testFiscalWeek() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] values=new int[]{1,2,1,52,27,28,2,6};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}",0.9982547993019196
64871,"/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FirstDayOfFiscalYear</code>
 */
public void testFirstDayOfFiscalYear() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Calendar c=Calendar.getInstance();
  c.clear();
  Date[] values=new Date[]{date(c,2015,0,1),date(c,2015,0,1),date(c,2015,6,1),date(c,2015,6,1),date(c,2014,6,1),date(c,2014,6,1)};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}","/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FirstDayOfFiscalYear</code>
 */
public void testFirstDayOfFiscalYear() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Calendar c=Calendar.getInstance();
  c.clear();
  Date[] values=new Date[]{date(c,2015,0,1),date(c,2015,0,1),date(c,2014,6,1),date(c,2015,6,1),date(c,2014,6,1),date(c,2014,6,1)};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}",0.9985549132947976
64872,"protected Object getValue(Object[] args) throws BirtException {
  if (existNullValue(args)) {
    return null;
  }
  Calendar current=getCalendar(null);
  if (args[0] instanceof Integer) {
    if (args.length > 1) {
      current=getCalendar(DataTypeUtil.toDate(args[1]));
    }
    current.set(Calendar.YEAR,(Integer)args[0]);
  }
 else {
    current.setTime(DataTypeUtil.toDate(args[0]));
    if (args.length > 1) {
      Calendar start=getCalendar(DataTypeUtil.toDate(args[1]));
      adjustFiscalYear(current,start);
      current.set(Calendar.MONTH,start.get(Calendar.MONTH));
      current.set(Calendar.DATE,start.get(Calendar.DATE));
    }
 else {
      current.set(Calendar.MONTH,0);
      current.set(Calendar.DATE,1);
    }
  }
  return current.getTime();
}","protected Object getValue(Object[] args) throws BirtException {
  if (existNullValue(args)) {
    return null;
  }
  Calendar current=getCalendar(null);
  if (args[0] instanceof Integer) {
    if (args.length > 1) {
      current=getCalendar(DataTypeUtil.toDate(args[1]));
    }
    current.set(Calendar.YEAR,(Integer)args[0]);
    if (current.get(Calendar.DAY_OF_YEAR) > 1) {
      current.add(Calendar.YEAR,-1);
    }
  }
 else {
    current.setTime(DataTypeUtil.toDate(args[0]));
    if (args.length > 1) {
      Calendar start=getCalendar(DataTypeUtil.toDate(args[1]));
      adjustFiscalYear(current,start);
      current.set(Calendar.MONTH,start.get(Calendar.MONTH));
      current.set(Calendar.DATE,start.get(Calendar.DATE));
    }
 else {
      current.set(Calendar.MONTH,0);
      current.set(Calendar.DATE,1);
    }
  }
  return current.getTime();
}",0.943419434194342
64873,"/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FiscalWeek</code>
 */
public void testFiscalWeek() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] values=new int[]{3,50,3,2,6};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}","/** 
 * Test method for <code>org.eclipse.birt.core.script.function.bre.BirtDateTime.Function_FiscalWeek</code>
 */
public void testFiscalWeek() throws BirtException {
  String[] scripts=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] values=new int[]{1,2,1,53,27,28,2,6};
  for (int i=0; i < values.length; i++) {
    Object result=cx.evaluateString(scope,scripts[i],""String_Node_Str"",1,null);
    assertEquals(String.valueOf(i),values[i],result);
  }
}",0.9354243542435424
64874,"protected void processGroup(ListingDesign listing,int groupLevel,boolean breakBefore){
  GroupDesign group=listing.getGroup(groupLevel);
  PolicyNode parent=parentNode;
  visitReportItem(group,Boolean.TRUE);
  parentNode=currentNode;
  if (group.getPageBreakAfter() != null) {
    currentNode.breakAfter=true;
  }
  if (breakBefore || group.getPageBreakBefore() != null) {
    currentNode.breakBefore=true;
  }
  BandDesign header=group.getHeader();
  if (header != null) {
    header.accept(this,null);
  }
  if (++groupLevel < listing.getGroupCount()) {
    processGroup(listing,groupLevel,header != null);
  }
 else {
    processDetail(listing,true);
    processDetail(listing,false);
  }
  BandDesign footer=group.getFooter();
  if (footer != null) {
    footer.accept(this,Boolean.TRUE);
  }
  parentNode=parent;
}","protected void processGroup(ListingDesign listing,int groupLevel,boolean breakBefore){
  GroupDesign group=listing.getGroup(groupLevel);
  PolicyNode parent=parentNode;
  visitReportItem(group,Boolean.TRUE);
  parentNode=currentNode;
  if (group.getPageBreakAfter() != null) {
    currentNode.breakAfter=true;
  }
  if (breakBefore || group.getPageBreakBefore() != null) {
    currentNode.breakBefore=true;
  }
  BandDesign header=group.getHeader();
  if (header != null) {
    header.accept(this,null);
  }
  if (++groupLevel < listing.getGroupCount()) {
    processGroup(listing,groupLevel,header != null);
    processGroup(listing,groupLevel,false);
  }
 else {
    processDetail(listing,true);
    processDetail(listing,false);
  }
  BandDesign footer=group.getFooter();
  if (footer != null) {
    footer.accept(this,Boolean.TRUE);
  }
  parentNode=parent;
}",0.9738406658739596
64875,"protected PolicyNode findNextNode(PolicyNode node){
  if (node.design instanceof GroupDesign)   return node;
  if (node == null || node.parent == null) {
    return null;
  }
  int index=node.parent.children.indexOf(node);
  int count=node.parent.children.size();
  if (index < count - 1) {
    return (PolicyNode)node.parent.children.get(index + 1);
  }
 else {
    return findNextNode(node.parent);
  }
}","protected PolicyNode findNextNode(PolicyNode node){
  if (node == null || node.parent == null) {
    return null;
  }
  int index=node.parent.children.indexOf(node);
  int count=node.parent.children.size();
  if (index < count - 1) {
    return (PolicyNode)node.parent.children.get(index + 1);
  }
 else {
    return findPreviousNode(node.parent);
  }
}",0.9090909090909092
64876,"protected PolicyNode findPreviousNode(PolicyNode node){
  if (node.design instanceof GroupDesign)   return node;
  if (node == null || node.parent == null) {
    return null;
  }
  int index=node.parent.children.indexOf(node);
  if (index < 1) {
    return findPreviousNode(node.parent);
  }
 else {
    return (PolicyNode)node.parent.children.get(index - 1);
  }
}","protected PolicyNode findPreviousNode(PolicyNode node){
  if (node == null || node.parent == null) {
    return null;
  }
  int index=node.parent.children.indexOf(node);
  if (index < 1) {
    return findPreviousNode(node.parent);
  }
 else {
    return (PolicyNode)node.parent.children.get(index - 1);
  }
}",0.9153046062407132
64877,"public void write(long pos,byte[] b,int off,int len) throws IOException {
  out.seek(pos);
  out.write(b,off,len);
}","public void write(long pos,byte[] b,int off,int len) throws IOException {
  out.seek(pos);
  out.write(b,off,len);
  out.flush();
}",0.9392712550607288
64878,"public RAStreamBufferMgr(RandomAccessFile randomFile) throws IOException {
  this.randomFile=randomFile;
  this.length=randomFile.length();
  this.totalBuffer=0;
  this.currentBuffer=getBuffer(0);
}","public RAStreamBufferMgr(RandomAccessFile randomFile) throws IOException {
  this.randomFile=randomFile;
  this.length=randomFile.length();
  this.totalBuffer=0;
  this.currentBuffer=null;
}",0.963917525773196
64879,"public long getFilePointer(){
  return currentBuffer.getOffset() + currentBuffer.getBufCur();
}","public long getFilePointer(){
  return currentBuffer == null ? 0 : currentBuffer.getOffset() + currentBuffer.getBufCur();
}",0.8715596330275229
64880,"public void write(byte b[],int off,int len) throws IOException {
  while (len > 0) {
    int ret=currentBuffer.write(b,off,len);
    len-=ret;
    off+=ret;
    if (len > 0) {
      currentBuffer=getBuffer(currentBuffer.getOffset() + IOUtil.RA_STREAM_BUFFER_LENGTH);
      currentBuffer.setBufCur(0);
    }
  }
  long fp=getFilePointer();
  if (fp > length) {
    length=fp;
  }
}","public void write(byte b[],int off,int len) throws IOException {
  if (currentBuffer == null) {
    currentBuffer=getBuffer(0);
  }
  while (len > 0) {
    int ret=currentBuffer.write(b,off,len);
    len-=ret;
    off+=ret;
    if (len > 0) {
      currentBuffer=getBuffer(currentBuffer.getOffset() + IOUtil.RA_STREAM_BUFFER_LENGTH);
      currentBuffer.setBufCur(0);
    }
  }
  long fp=getFilePointer();
  if (fp > length) {
    length=fp;
  }
}",0.9189842805320436
64881,"public void seek(long localPos) throws IOException {
  long offset=(localPos / IOUtil.RA_STREAM_BUFFER_LENGTH) * IOUtil.RA_STREAM_BUFFER_LENGTH;
  if (currentBuffer.getOffset() != offset)   currentBuffer=getBuffer(offset);
  currentBuffer.setBufCur((int)(localPos - offset));
  if (localPos > length) {
    length=localPos;
  }
}","public void seek(long localPos) throws IOException {
  long offset=(localPos / IOUtil.RA_STREAM_BUFFER_LENGTH) * IOUtil.RA_STREAM_BUFFER_LENGTH;
  if (currentBuffer == null || currentBuffer.getOffset() != offset)   currentBuffer=getBuffer(offset);
  currentBuffer.setBufCur((int)(localPos - offset));
  if (localPos > length) {
    length=localPos;
  }
}",0.9633967789165446
64882,"/** 
 * whether the expression is column reference
 * @param expression
 * @return
 */
public static boolean isColumnExpression(String expression,boolean mode){
  boolean isColumn=false;
  if (expression == null || expression.trim().length() == 0)   return isColumn;
  if (getCompiledExpCacheMap(mode).containsKey(expression)) {
    return ((Boolean)getCompiledExpCacheMap(mode).get(expression)).booleanValue();
  }
  Context context=Context.enter();
  AstRoot tree;
  try {
    CompilerEnvirons m_compilerEnv=new CompilerEnvirons();
    m_compilerEnv.initFromContext(context);
    Parser p=new Parser(m_compilerEnv,context.getErrorReporter());
    tree=p.parse(expression,null,0);
  }
 catch (  Exception e) {
    getCompiledExpCacheMap(mode).put(expression,Boolean.valueOf(false));
    return false;
  }
 finally {
    Context.exit();
  }
  if (tree.getFirstChild() == tree.getLastChild()) {
    if (tree.getFirstChild().getType() != Token.EXPR_RESULT && tree.getFirstChild().getType() != Token.EXPR_VOID && tree.getFirstChild().getType() != Token.BLOCK) {
      isColumn=false;
    }
    Node exprNode=tree.getFirstChild();
    Node child=exprNode.getFirstChild();
    assert(child != null);
    if (child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)     isColumn=getDirectColRefExpr(child,mode);
 else     isColumn=false;
  }
 else {
    isColumn=false;
  }
  getCompiledExpCacheMap(mode).put(expression,Boolean.valueOf(isColumn));
  return isColumn;
}","/** 
 * whether the expression is column reference
 * @param expression
 * @return
 */
public static boolean isColumnExpression(String expression,boolean mode){
  boolean isColumn=false;
  if (expression == null || expression.trim().length() == 0)   return isColumn;
  if (getCompiledExpCacheMap(mode).containsKey(expression)) {
    return ((Boolean)getCompiledExpCacheMap(mode).get(expression)).booleanValue();
  }
  Context context=Context.enter();
  ScriptNode tree;
  try {
    CompilerEnvirons m_compilerEnv=new CompilerEnvirons();
    m_compilerEnv.initFromContext(context);
    Parser p=new Parser(m_compilerEnv,context.getErrorReporter());
    AstRoot root=p.parse(expression,null,0);
    IRFactory ir=new IRFactory(m_compilerEnv);
    tree=ir.transformTree(root);
  }
 catch (  Exception e) {
    getCompiledExpCacheMap(mode).put(expression,Boolean.valueOf(false));
    return false;
  }
 finally {
    Context.exit();
  }
  if (tree.getFirstChild() == tree.getLastChild()) {
    if (tree.getFirstChild().getType() != Token.EXPR_RESULT && tree.getFirstChild().getType() != Token.EXPR_VOID && tree.getFirstChild().getType() != Token.BLOCK) {
      isColumn=false;
    }
    Node exprNode=tree.getFirstChild();
    Node child=exprNode.getFirstChild();
    assert(child != null);
    if (child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)     isColumn=getDirectColRefExpr(child,mode);
 else     isColumn=false;
  }
 else {
    isColumn=false;
  }
  getCompiledExpCacheMap(mode).put(expression,Boolean.valueOf(isColumn));
  return isColumn;
}",0.9628411706675436
64883,"/** 
 * whether the expression is column reference
 * @param expression
 * @return
 */
public static boolean isColumnExpression(String expression,boolean mode){
  boolean isColumn=false;
  if (expression == null || expression.trim().length() == 0)   return isColumn;
  if (getCompiledExpCacheMap(mode).containsKey(expression)) {
    return ((Boolean)getCompiledExpCacheMap(mode).get(expression)).booleanValue();
  }
  Context context=Context.enter();
  AstRoot tree;
  try {
    CompilerEnvirons m_compilerEnv=new CompilerEnvirons();
    m_compilerEnv.initFromContext(context);
    Parser p=new Parser(m_compilerEnv,context.getErrorReporter());
    tree=p.parse(expression,null,0);
  }
 catch (  Exception e) {
    getCompiledExpCacheMap(mode).put(expression,Boolean.valueOf(false));
    return false;
  }
 finally {
    Context.exit();
  }
  if (tree.getFirstChild() == tree.getLastChild()) {
    if (tree.getFirstChild().getType() != Token.EXPR_RESULT && tree.getFirstChild().getType() != Token.EXPR_VOID && tree.getFirstChild().getType() != Token.BLOCK) {
      isColumn=false;
    }
    Node exprNode=tree.getFirstChild();
    Node child=exprNode.getFirstChild();
    assert(child != null);
    if (child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)     isColumn=getDirectColRefExpr(child,mode);
 else     isColumn=false;
  }
 else {
    isColumn=false;
  }
  getCompiledExpCacheMap(mode).put(expression,Boolean.valueOf(isColumn));
  return isColumn;
}","/** 
 * whether the expression is column reference
 * @param expression
 * @return
 */
public static boolean isColumnExpression(String expression,boolean mode){
  boolean isColumn=false;
  if (expression == null || expression.trim().length() == 0)   return isColumn;
  if (getCompiledExpCacheMap(mode).containsKey(expression)) {
    return ((Boolean)getCompiledExpCacheMap(mode).get(expression)).booleanValue();
  }
  Context context=Context.enter();
  ScriptNode tree;
  try {
    CompilerEnvirons m_compilerEnv=new CompilerEnvirons();
    m_compilerEnv.initFromContext(context);
    Parser p=new Parser(m_compilerEnv,context.getErrorReporter());
    AstRoot root=p.parse(expression,null,0);
    IRFactory ir=new IRFactory(m_compilerEnv);
    tree=ir.transformTree(root);
  }
 catch (  Exception e) {
    getCompiledExpCacheMap(mode).put(expression,Boolean.valueOf(false));
    return false;
  }
 finally {
    Context.exit();
  }
  if (tree.getFirstChild() == tree.getLastChild()) {
    if (tree.getFirstChild().getType() != Token.EXPR_RESULT && tree.getFirstChild().getType() != Token.EXPR_VOID && tree.getFirstChild().getType() != Token.BLOCK) {
      isColumn=false;
    }
    Node exprNode=tree.getFirstChild();
    Node child=exprNode.getFirstChild();
    assert(child != null);
    if (child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)     isColumn=getDirectColRefExpr(child,mode);
 else     isColumn=false;
  }
 else {
    isColumn=false;
  }
  getCompiledExpCacheMap(mode).put(expression,Boolean.valueOf(isColumn));
  return isColumn;
}",0.9628411706675436
64884,"/** 
 * whether the expression is column reference
 * @param expression
 * @return
 */
public static boolean isColumnExpression(String expression){
  boolean isColumn=false;
  if (expression == null || expression.trim().length() == 0)   return isColumn;
  if (compiledExprCache.containsKey(expression))   return ((Boolean)compiledExprCache.get(expression)).booleanValue();
  Context context=Context.enter();
  AstRoot tree;
  try {
    CompilerEnvirons m_compilerEnv=new CompilerEnvirons();
    m_compilerEnv.initFromContext(context);
    Parser p=new Parser(m_compilerEnv,context.getErrorReporter());
    tree=p.parse(expression,null,0);
  }
 catch (  Exception e) {
    compiledExprCache.put(expression,Boolean.valueOf(false));
    return false;
  }
 finally {
    Context.exit();
  }
  if (tree.getFirstChild() == tree.getLastChild()) {
    if (tree.getFirstChild().getType() != Token.EXPR_RESULT && tree.getFirstChild().getType() != Token.EXPR_VOID && tree.getFirstChild().getType() != Token.BLOCK) {
      isColumn=false;
    }
    Node exprNode=tree.getFirstChild();
    Node child=exprNode.getFirstChild();
    assert(child != null);
    if (child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)     isColumn=getDirectColRefExpr(child);
 else     isColumn=false;
  }
 else {
    isColumn=false;
  }
  compiledExprCache.put(expression,Boolean.valueOf(isColumn));
  return isColumn;
}","/** 
 * whether the expression is column reference
 * @param expression
 * @return
 */
public static boolean isColumnExpression(String expression){
  boolean isColumn=false;
  if (expression == null || expression.trim().length() == 0)   return isColumn;
  if (compiledExprCache.containsKey(expression))   return ((Boolean)compiledExprCache.get(expression)).booleanValue();
  Context context=Context.enter();
  ScriptNode tree;
  try {
    CompilerEnvirons m_compilerEnv=new CompilerEnvirons();
    m_compilerEnv.initFromContext(context);
    Parser p=new Parser(m_compilerEnv,context.getErrorReporter());
    AstRoot root=p.parse(expression,null,0);
    IRFactory ir=new IRFactory(m_compilerEnv);
    tree=ir.transformTree(root);
  }
 catch (  Exception e) {
    compiledExprCache.put(expression,Boolean.valueOf(false));
    return false;
  }
 finally {
    Context.exit();
  }
  if (tree.getFirstChild() == tree.getLastChild()) {
    if (tree.getFirstChild().getType() != Token.EXPR_RESULT && tree.getFirstChild().getType() != Token.EXPR_VOID && tree.getFirstChild().getType() != Token.BLOCK) {
      isColumn=false;
    }
    Node exprNode=tree.getFirstChild();
    Node child=exprNode.getFirstChild();
    assert(child != null);
    if (child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)     isColumn=getDirectColRefExpr(child);
 else     isColumn=false;
  }
 else {
    isColumn=false;
  }
  compiledExprCache.put(expression,Boolean.valueOf(isColumn));
  return isColumn;
}",0.9610479145122371
64885,"/** 
 * @param expr
 * @param objectName
 * @return
 */
private static String getReferencedScriptObject(String expr,String objectName){
  if (expr == null)   return null;
  try {
    Context cx=Context.enter();
    CompilerEnvirons ce=new CompilerEnvirons();
    Parser p=new Parser(ce,cx.getErrorReporter());
    AstRoot tree=p.parse(expr,null,0);
    return getScriptObjectName(tree,objectName);
  }
  finally {
    Context.exit();
  }
}","/** 
 * @param expr
 * @param objectName
 * @return
 */
private static String getReferencedScriptObject(String expr,String objectName){
  if (expr == null)   return null;
  try {
    Context cx=Context.enter();
    CompilerEnvirons ce=new CompilerEnvirons();
    Parser p=new Parser(ce,cx.getErrorReporter());
    AstRoot tree=p.parse(expr,null,0);
    IRFactory ir=new IRFactory(ce);
    ScriptNode script=ir.transformTree(tree);
    return getScriptObjectName(script,objectName);
  }
  finally {
    Context.exit();
  }
}",0.9043659043659044
64886,"/** 
 * @param expr
 * @param objectName
 * @return
 */
public static Set<String> getReferencedMeasure(String expr){
  if (expr == null)   return Collections.EMPTY_SET;
  try {
    Set<String> result=new LinkedHashSet<String>();
    Context cx=Context.enter();
    CompilerEnvirons ce=new CompilerEnvirons();
    Parser p=new Parser(ce,cx.getErrorReporter());
    AstRoot tree=p.parse(expr,null,0);
    getScriptObjectName(tree,""String_Node_Str"",result);
    return result;
  }
 catch (  Exception e) {
    return Collections.EMPTY_SET;
  }
 finally {
    Context.exit();
  }
}","/** 
 * @param expr
 * @param objectName
 * @return
 */
public static Set<String> getReferencedMeasure(String expr){
  if (expr == null)   return Collections.emptySet();
  try {
    Set<String> result=new LinkedHashSet<String>();
    Context cx=Context.enter();
    CompilerEnvirons ce=new CompilerEnvirons();
    Parser p=new Parser(ce,cx.getErrorReporter());
    AstRoot tree=p.parse(expr,null,0);
    IRFactory ir=new IRFactory(ce);
    ScriptNode script=ir.transformTree(tree);
    getScriptObjectName(script,""String_Node_Str"",result);
    return result;
  }
 catch (  Exception e) {
    return Collections.emptySet();
  }
 finally {
    Context.exit();
  }
}",0.8951612903225806
64887,"/** 
 * @param expr
 * @param bindings
 * @param onlyFromDirectReferenceExpr
 * @return
 * @throws DataException
 */
public static Set<IDimLevel> getReferencedDimLevel(String expr) throws CoreException {
  if (expr == null)   return new HashSet<IDimLevel>();
  try {
    Set<IDimLevel> result=new HashSet<IDimLevel>();
    Context cx=Context.enter();
    CompilerEnvirons ce=new CompilerEnvirons();
    Parser p=new Parser(ce,cx.getErrorReporter());
    AstRoot tree=p.parse(expr,null,0);
    populateDimLevels(null,tree,result);
    return result;
  }
 catch (  Exception e) {
    return Collections.EMPTY_SET;
  }
 finally {
    Context.exit();
  }
}","/** 
 * @param expr
 * @param bindings
 * @param onlyFromDirectReferenceExpr
 * @return
 * @throws DataException
 */
public static Set<IDimLevel> getReferencedDimLevel(String expr) throws CoreException {
  if (expr == null)   return new HashSet<IDimLevel>();
  try {
    Set<IDimLevel> result=new HashSet<IDimLevel>();
    Context cx=Context.enter();
    CompilerEnvirons ce=new CompilerEnvirons();
    Parser p=new Parser(ce,cx.getErrorReporter());
    AstRoot tree=p.parse(expr,null,0);
    IRFactory ir=new IRFactory(ce);
    ScriptNode script=ir.transformTree(tree);
    populateDimLevels(null,script,result);
    return result;
  }
 catch (  Exception e) {
    return Collections.emptySet();
  }
 finally {
    Context.exit();
  }
}",0.9215262778977682
64888,"/** 
 * Tests <code>MasterPageSizeValidator</code>.
 * @throws Exception if any exception
 */
public void testTriggers() throws Exception {
  createDesign();
  MetaDataDictionary.getInstance().setUseValidationTrigger(true);
  SimpleMasterPageHandle pageHandle=designHandle.getElementFactory().newSimpleMasterPage(""String_Node_Str"");
  designHandle.getMasterPages().add(pageHandle);
  designHandle.addValidationListener(listener);
  DimensionHandle marginLeft=pageHandle.getLeftMargin();
  marginLeft.setStringValue(""String_Node_Str"");
  assertTrue(listener.hasError(pageHandle,MasterPageSizeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_INVALID_PAGE_MARGINS));
  marginLeft.setStringValue(""String_Node_Str"");
  assertFalse(listener.hasError(pageHandle,MasterPageSizeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_INVALID_PAGE_MARGINS));
  pageHandle.setPageType(DesignChoiceConstants.PAGE_SIZE_CUSTOM);
  assertTrue(listener.hasError(pageHandle,MasterPageTypeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_MISSING_PAGE_SIZE));
  DimensionHandle height=pageHandle.getHeight();
  height.setStringValue(""String_Node_Str"");
  assertTrue(listener.hasError(pageHandle,MasterPageTypeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_MISSING_PAGE_SIZE));
  DimensionHandle width=pageHandle.getWidth();
  width.setStringValue(""String_Node_Str"");
  assertFalse(listener.hasError(pageHandle,MasterPageTypeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_MISSING_PAGE_SIZE));
  DimensionHandle marginBottom=pageHandle.getBottomMargin();
  marginBottom.setStringValue(""String_Node_Str"");
  assertTrue(listener.hasError(pageHandle,MasterPageSizeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_INVALID_PAGE_MARGINS));
}","/** 
 * Tests <code>MasterPageSizeValidator</code>.
 * @throws Exception if any exception
 */
public void testTriggers() throws Exception {
  createDesign();
  MetaDataDictionary.getInstance().setUseValidationTrigger(true);
  SimpleMasterPageHandle pageHandle=designHandle.getElementFactory().newSimpleMasterPage(""String_Node_Str"");
  designHandle.getMasterPages().add(pageHandle);
  designHandle.addValidationListener(listener);
  DimensionHandle marginLeft=pageHandle.getLeftMargin();
  marginLeft.setStringValue(""String_Node_Str"");
  assertTrue(listener.hasError(pageHandle,MasterPageSizeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_INVALID_PAGE_MARGINS));
  marginLeft.setStringValue(""String_Node_Str"");
  assertFalse(listener.hasError(pageHandle,MasterPageSizeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_INVALID_PAGE_MARGINS));
  pageHandle.setPageType(DesignChoiceConstants.PAGE_SIZE_CUSTOM);
  assertTrue(listener.hasError(pageHandle,MasterPageTypeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_MISSING_PAGE_SIZE));
  DimensionHandle height=pageHandle.getHeight();
  height.setStringValue(""String_Node_Str"");
  DimensionHandle width=pageHandle.getWidth();
  width.setStringValue(""String_Node_Str"");
  DimensionHandle marginBottom=pageHandle.getBottomMargin();
  marginBottom.setStringValue(""String_Node_Str"");
  assertTrue(listener.hasError(pageHandle,MasterPageSizeValidator.getInstance().getName(),SemanticError.DESIGN_EXCEPTION_INVALID_PAGE_MARGINS));
}",0.914388705316912
64889,"/** 
 * Test localize element.
 * @throws DesignFileException
 * @throws IOException
 * @throws SemanticException
 */
public void testLocalizeElement() throws DesignFileException, IOException, SemanticException {
  openDesign(""String_Node_Str"");
  Module module=designHandle.getModule();
  LabelHandle label1Handle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  Label label1=(Label)label1Handle.getElement();
  assertEquals(""String_Node_Str"",label1Handle.getExtends().getName());
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Label.WIDTH_PROP).toString());
  assertEquals(null,label1.getLocalProperty(module,Label.TEXT_PROP));
  assertEquals(null,label1.getLocalProperty(module,Style.FONT_SIZE_PROP));
  assertEquals(null,label1.getLocalProperty(module,Style.BORDER_LEFT_COLOR_PROP));
  assertEquals(null,label1.getLocalProperty(module,Style.BACKGROUND_COLOR_PROP));
  assertEquals(""String_Node_Str"",label1.getStringProperty(module,Style.TEXT_ALIGN_PROP));
  label1Handle.localize();
  assertNull(label1Handle.getExtends());
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Label.WIDTH_PROP).toString());
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Label.TEXT_PROP));
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Style.FONT_SIZE_PROP).toString());
  assertEquals(null,label1.getLocalProperty(module,Style.BORDER_LEFT_COLOR_PROP));
  assertEquals(null,label1.getLocalProperty(module,Style.BACKGROUND_COLOR_PROP));
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Style.TEXT_ALIGN_PROP));
  GridHandle grid1Handle=(GridHandle)designHandle.findElement(""String_Node_Str"");
  GridItem grid1=(GridItem)grid1Handle.getElement();
  assertEquals(""String_Node_Str"",grid1.getExtendsName());
  assertEquals(""String_Node_Str"",grid1.getLocalProperty(module,GridItem.HEIGHT_PROP).toString());
  assertEquals(""String_Node_Str"",grid1.getProperty(module,GridItem.WIDTH_PROP).toString());
  RowHandle innerRow1=(RowHandle)grid1Handle.getRows().get(0);
  CellHandle innerCell1=(CellHandle)innerRow1.getCells().get(0);
  LabelHandle innerLabel1=(LabelHandle)innerCell1.getContent().get(0);
  GridHandle innerGrid1=(GridHandle)innerCell1.getContent().get(2);
  assertTrue(innerRow1.getElement().isVirtualElement());
  assertTrue(innerLabel1.getElement().isVirtualElement());
  assertEquals(9,innerLabel1.getElement().getBaseId());
  assertEquals(""String_Node_Str"",innerLabel1.getElement().getLocalProperty(module,Label.TEXT_PROP).toString());
  assertEquals(null,innerLabel1.getElement().getLocalProperty(module,Style.COLOR_PROP));
  assertEquals(null,innerLabel1.getElement().getLocalProperty(module,Style.FONT_SIZE_PROP));
  assertEquals(null,innerGrid1.getElement().getLocalProperty(module,Style.MAP_RULES_PROP));
  List mapRules=(List)innerGrid1.getProperty(Style.MAP_RULES_PROP);
  assertEquals(1,mapRules.size());
  grid1Handle.localize();
  assertNull(grid1.getExtendsElement());
  assertEquals(""String_Node_Str"",grid1.getLocalProperty(module,GridItem.HEIGHT_PROP).toString());
  assertEquals(""String_Node_Str"",grid1.getLocalProperty(module,GridItem.WIDTH_PROP).toString());
  List localMapRules=(List)grid1.getLocalProperty(module,Style.MAP_RULES_PROP);
  assertEquals(2,localMapRules.size());
  Structure numberFormat=(Structure)grid1.getLocalProperty(module,Style.NUMBER_FORMAT_PROP);
  assertEquals(""String_Node_Str"",numberFormat.getProperty(module,NumberFormatValue.CATEGORY_MEMBER));
  save();
  design.getActivityStack().undo();
  design.getActivityStack().undo();
  save();
}","/** 
 * Test localize element.
 * @throws DesignFileException
 * @throws IOException
 * @throws SemanticException
 */
public void testLocalizeElement() throws DesignFileException, IOException, SemanticException {
  openDesign(""String_Node_Str"");
  Module module=designHandle.getModule();
  LabelHandle label1Handle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  Label label1=(Label)label1Handle.getElement();
  assertEquals(""String_Node_Str"",label1Handle.getExtends().getName());
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Label.WIDTH_PROP).toString());
  assertEquals(null,label1.getLocalProperty(module,Label.TEXT_PROP));
  assertEquals(null,label1.getLocalProperty(module,Style.FONT_SIZE_PROP));
  assertEquals(null,label1.getLocalProperty(module,Style.BORDER_LEFT_COLOR_PROP));
  assertEquals(null,label1.getLocalProperty(module,Style.BACKGROUND_COLOR_PROP));
  assertEquals(""String_Node_Str"",label1.getStringProperty(module,Style.TEXT_ALIGN_PROP));
  label1Handle.localize();
  assertNull(label1Handle.getExtends());
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Label.WIDTH_PROP).toString());
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Label.TEXT_PROP));
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Style.FONT_SIZE_PROP).toString());
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Style.BORDER_LEFT_COLOR_PROP));
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Style.BACKGROUND_COLOR_PROP));
  assertEquals(""String_Node_Str"",label1.getLocalProperty(module,Style.TEXT_ALIGN_PROP));
  GridHandle grid1Handle=(GridHandle)designHandle.findElement(""String_Node_Str"");
  GridItem grid1=(GridItem)grid1Handle.getElement();
  assertEquals(""String_Node_Str"",grid1.getExtendsName());
  assertEquals(""String_Node_Str"",grid1.getLocalProperty(module,GridItem.HEIGHT_PROP).toString());
  assertEquals(""String_Node_Str"",grid1.getProperty(module,GridItem.WIDTH_PROP).toString());
  RowHandle innerRow1=(RowHandle)grid1Handle.getRows().get(0);
  CellHandle innerCell1=(CellHandle)innerRow1.getCells().get(0);
  LabelHandle innerLabel1=(LabelHandle)innerCell1.getContent().get(0);
  GridHandle innerGrid1=(GridHandle)innerCell1.getContent().get(2);
  assertTrue(innerRow1.getElement().isVirtualElement());
  assertTrue(innerLabel1.getElement().isVirtualElement());
  assertEquals(9,innerLabel1.getElement().getBaseId());
  assertEquals(""String_Node_Str"",innerLabel1.getElement().getLocalProperty(module,Label.TEXT_PROP).toString());
  assertEquals(null,innerLabel1.getElement().getLocalProperty(module,Style.COLOR_PROP));
  assertEquals(null,innerLabel1.getElement().getLocalProperty(module,Style.FONT_SIZE_PROP));
  assertEquals(null,innerGrid1.getElement().getLocalProperty(module,Style.MAP_RULES_PROP));
  List mapRules=(List)innerGrid1.getProperty(Style.MAP_RULES_PROP);
  assertEquals(1,mapRules.size());
  grid1Handle.localize();
  assertNull(grid1.getExtendsElement());
  assertEquals(""String_Node_Str"",grid1.getLocalProperty(module,GridItem.HEIGHT_PROP).toString());
  assertEquals(""String_Node_Str"",grid1.getLocalProperty(module,GridItem.WIDTH_PROP).toString());
  List localMapRules=(List)grid1.getLocalProperty(module,Style.MAP_RULES_PROP);
  assertEquals(2,localMapRules.size());
  Structure numberFormat=(Structure)grid1.getLocalProperty(module,Style.NUMBER_FORMAT_PROP);
  assertEquals(""String_Node_Str"",numberFormat.getProperty(module,NumberFormatValue.CATEGORY_MEMBER));
  save();
  design.getActivityStack().undo();
  design.getActivityStack().undo();
  save();
}",0.9941357162803686
64890,"/** 
 * Creates the dimension expression according to level attribute
 * @param level level handle
 * @param attributeName level attribute name
 * @return the dimension expression or null
 * @since 2.6
 */
public static String createDimensionExpression(LevelHandle level,String attributeName){
  if (level == null) {
    return null;
  }
  return ExpressionUtil.createJSDimensionExpression(level.getContainer().getContainer().getName(),level.getName(),attributeName);
}","/** 
 * Creates the dimension expression according to level attribute
 * @param level level handle
 * @param attributeName level attribute name
 * @return the dimension expression or null
 * @since 2.6
 */
public static String createDimensionExpression(LevelHandle level,String attributeName){
  if (level == null) {
    return null;
  }
  if (attributeName == null) {
    return createDimensionExpression(level);
  }
  return ExpressionUtil.createJSDimensionExpression(level.getContainer().getContainer().getName(),level.getName(),attributeName);
}",0.9214145383104124
64891,"public Object visitReportItem(ReportItemDesign item,Object value){
  PolicyNode node=new PolicyNode();
  node.parent=parentNode;
  node.design=item;
  boolean needExecute=value == Boolean.TRUE;
  if (needExecute) {
    node.execute=true;
  }
  setupPageBreak(node);
  parentNode.children.add(node);
  currentNode=node;
  return Boolean.valueOf(needExecute);
}","public Object visitReportItem(ReportItemDesign item,Object value){
  PolicyNode node=null;
  if (itemNodeMap.containsKey(item)) {
    node=itemNodeMap.get(item);
  }
 else {
    node=new PolicyNode();
    node.parent=parentNode;
    node.design=item;
    itemNodeMap.put(item,node);
    parentNode.children.add(node);
  }
  boolean needExecute=value == Boolean.TRUE;
  if (needExecute) {
    node.execute=true;
  }
  setupPageBreak(node);
  currentNode=node;
  return Boolean.valueOf(needExecute);
}",0.703962703962704
64892,"/** 
 * update DataSetHandle
 * @param response
 * @param dataSetHandle
 * @param isSourceChanged
 */
public void updateDataSetHandle(DesignSessionResponse response,DataSetDesign requestDesign,OdaDataSetHandle dataSetHandle,boolean isSourceChanged){
  initDesignSessionFields(response);
  if (isSessionOk()) {
    EcoreUtil.EqualityHelper equalityHelper=new EcoreUtil.EqualityHelper();
    if (equalityHelper.equals(response.getDataSetDesign(),requestDesign) && equalityHelper.equals(response.getDesignerState(),this.designerState))     return;
    try {
      DataSetDesign design=response.getDataSetDesign();
      if (ReportPlugin.getDefault().getPluginPreferences().getBoolean(DateSetPreferencePage.PROMPT_ENABLE) == true) {
        IAmbiguousOption ambiguousOption=modelOdaAdapter.getAmbiguousOption(design,dataSetHandle);
        if (ambiguousOption != null && !ambiguousOption.getAmbiguousParameters().isEmpty()) {
          PromptParameterDialog dialog=new PromptParameterDialog(Messages.getString(""String_Node_Str""));
          dialog.setInput(ambiguousOption);
          if (dialog.open() == Dialog.OK) {
            Object result=dialog.getResult();
            if (result instanceof List) {
              List<OdaDataSetParameter> selectedParameters=(List)result;
              updateROMDesignerState(dataSetHandle);
              modelOdaAdapter.updateDataSetHandle(design,dataSetHandle,selectedParameters,null,isSourceChanged);
              refreshCachedMetaData(dataSetHandle);
              return;
            }
          }
 else {
            updateROMDesignerState(dataSetHandle);
            modelOdaAdapter.updateDataSetHandle(design,dataSetHandle,isSourceChanged);
            refreshCachedMetaData(dataSetHandle);
            return;
          }
        }
      }
      updateROMDesignerState(dataSetHandle);
      modelOdaAdapter.updateDataSetHandle(design,dataSetHandle,isSourceChanged);
      refreshCachedMetaData(dataSetHandle);
    }
 catch (    SemanticException e) {
      ExceptionHandler.handle(e);
    }
  }
  return;
}","/** 
 * update DataSetHandle
 * @param response
 * @param dataSetHandle
 * @param isSourceChanged
 */
public void updateDataSetHandle(DesignSessionResponse response,DataSetDesign requestDesign,OdaDataSetHandle dataSetHandle,boolean isSourceChanged){
  initDesignSessionFields(response);
  if (isSessionOk()) {
    EcoreUtil.EqualityHelper equalityHelper=new EcoreUtil.EqualityHelper();
    if (equalityHelper.equals(response.getDataSetDesign(),requestDesign) && equalityHelper.equals(response.getDesignerState(),this.designerState))     return;
    try {
      DataSetDesign design=response.getDataSetDesign();
      if (design.getPrimaryResultSet() != null && design.getPrimaryResultSet().getResultSetColumns() != null) {
        List<ColumnDefinition> resultColumnDefinitions=design.getPrimaryResultSet().getResultSetColumns().getResultColumnDefinitions();
        if (resultColumnDefinitions != null && !resultColumnDefinitions.isEmpty()) {
          Object hint=resultColumnDefinitions.get(0).getUsageHints();
          if (hint == null) {
            design.setPrimaryResultSet(null);
            design.setResultSets(null);
          }
        }
      }
      if (ReportPlugin.getDefault().getPluginPreferences().getBoolean(DateSetPreferencePage.PROMPT_ENABLE) == true) {
        IAmbiguousOption ambiguousOption=modelOdaAdapter.getAmbiguousOption(design,dataSetHandle);
        if (ambiguousOption != null && !ambiguousOption.getAmbiguousParameters().isEmpty()) {
          PromptParameterDialog dialog=new PromptParameterDialog(Messages.getString(""String_Node_Str""));
          dialog.setInput(ambiguousOption);
          if (dialog.open() == Dialog.OK) {
            Object result=dialog.getResult();
            if (result instanceof List) {
              List<OdaDataSetParameter> selectedParameters=(List)result;
              updateROMDesignerState(dataSetHandle);
              modelOdaAdapter.updateDataSetHandle(design,dataSetHandle,selectedParameters,null,isSourceChanged);
              refreshCachedMetaData(dataSetHandle);
              return;
            }
          }
 else {
            updateROMDesignerState(dataSetHandle);
            modelOdaAdapter.updateDataSetHandle(design,dataSetHandle,isSourceChanged);
            refreshCachedMetaData(dataSetHandle);
            return;
          }
        }
      }
      updateROMDesignerState(dataSetHandle);
      modelOdaAdapter.updateDataSetHandle(design,dataSetHandle,isSourceChanged);
      refreshCachedMetaData(dataSetHandle);
    }
 catch (    SemanticException e) {
      ExceptionHandler.handle(e);
    }
  }
  return;
}",0.8821129482499463
64893,"private EngineConfig getEngineConfig(ModuleHandle handle){
  EngineConfig ec=new EngineConfig();
  ClassLoader parent=Thread.currentThread().getContextClassLoader();
  if (parent == null) {
    parent=this.getClass().getClassLoader();
  }
  ClassLoader customClassLoader=DataSetProvider.getCustomScriptClassLoader(parent,handle);
  ec.getAppContext().put(EngineConstants.APPCONTEXT_CLASSLOADER_KEY,customClassLoader);
  return ec;
}","private EngineConfig getEngineConfig(ModuleHandle handle){
  EngineConfig ec=new EngineConfig();
  ClassLoader parent=Thread.currentThread().getContextClassLoader();
  if (parent == null) {
    parent=this.getClass().getClassLoader();
  }
  ClassLoader customClassLoader=DataSetProvider.getCustomScriptClassLoader(parent,handle);
  return ec;
}",0.8865979381443299
64894,"public boolean hasNextChild(){
  if (currentElement < totalElements) {
    return true;
  }
  if (endOfGroup) {
    return false;
  }
  try {
    while (!endOfGroup) {
      IQueryResultSet rset=listingExecutor.getResultSet();
      GroupDesign groupDesign=(GroupDesign)getDesign();
      int endGroup=rset.getEndingGroupLevel();
      int groupLevel=groupDesign.getGroupLevel() + 1;
      if (endGroup <= groupLevel) {
        totalElements=0;
        currentElement=0;
        BandDesign footer=groupDesign.getFooter();
        if (footer != null) {
          executableElements[totalElements++]=footer;
        }
        endOfGroup=true;
        return currentElement < totalElements;
      }
      if (rset.next()) {
        collectExecutableElements();
        if (currentElement < totalElements) {
          return true;
        }
      }
    }
  }
 catch (  BirtException ex) {
    context.addException(this.getDesign(),ex);
  }
  return false;
}","public boolean hasNextChild(){
  if (currentElement < totalElements) {
    return true;
  }
  if (endOfGroup) {
    return false;
  }
  try {
    while (!endOfGroup) {
      IQueryResultSet rset=listingExecutor.getResultSet();
      GroupDesign groupDesign=(GroupDesign)getDesign();
      int endGroup=rset.getEndingGroupLevel();
      int groupLevel=groupDesign.getGroupLevel() + 1;
      if (endGroup <= groupLevel) {
        totalElements=0;
        currentElement=0;
        BandDesign footer=groupDesign.getFooter();
        if (footer != null) {
          executableElements[totalElements++]=footer;
        }
        endOfGroup=true;
        return currentElement < totalElements;
      }
      if (rset.next()) {
        collectExecutableElements();
        if (currentElement < totalElements) {
          return true;
        }
      }
 else       break;
    }
  }
 catch (  BirtException ex) {
    context.addException(this.getDesign(),ex);
  }
  return false;
}",0.99012987012987
64895,"protected boolean isIE7(String userAgent){
  if (userAgent != null) {
    if ((userAgent.contains(""String_Node_Str"") || userAgent.contains(""String_Node_Str"") || userAgent.contains(""String_Node_Str"")) && (!userAgent.contains(""String_Node_Str""))) {
      return true;
    }
  }
  return false;
}","protected boolean isIE7(String userAgent){
  if ((userAgent != null) && (!userAgent.contains(""String_Node_Str""))) {
    if (userAgent.contains(""String_Node_Str"") || userAgent.contains(""String_Node_Str"") || userAgent.contains(""String_Node_Str"")) {
      return true;
    }
  }
  return false;
}",0.5494880546075085
64896,"private IAggregationResultSet[] populateRs(BirtCubeView view,AggregationDefinition[] aggrDefns,CubeQueryExecutorHelper cubeQueryExcutorHelper2,StopSign stopSign,boolean saveToRD,IBindingValueFetcher fetcher) throws IOException, BirtException {
  IAggregationResultSet[] rs=null;
  String id=null;
  CubeQueryExecutor executor=view.getCubeQueryExecutor();
  if (executor.getCubeQueryDefinition().getQueryResultsID() == null) {
    if (saveToRD || executor.getCubeQueryDefinition().cacheQueryResults())     id=executor.getSession().getQueryResultIDUtil().nextID();
    rs=executeQuery(view,aggrDefns,saveToRD,id,fetcher);
  }
 else {
    id=executor.getCubeQueryDefinition().getQueryResultsID();
    if (executor.getCubeQueryDefinition().cacheQueryResults()) {
      rs=AggregationResultSetSaveUtil.load(id,new FileArchiveReader(executor.getSession().getTempDir() + ""String_Node_Str""),VersionManager.getLatestVersion(),cubeQueryExecutorHelper.getMemoryCacheSize());
      if (view.getCubeQueryExecutionHints() == null) {
        CubeQueryExecutorHints hints=new CubeQueryExecutorHints();
        view.getCubeQueryExecutionHints().executeCubeOperation(false);
      }
      QueryExecutorUtil.initLoadedAggregationResultSets(rs,getSavedAggregations());
    }
 else {
      if (executor.getContext().getDocReader() != null && executor.getContext().getMode() != DataEngineContext.MODE_GENERATION) {
        rs=AggregationResultSetSaveUtil.load(executor.getCubeQueryDefinition().getQueryResultsID(),executor.getContext().getDocReader(),new VersionManager(executor.getContext()).getVersion(id),cubeQueryExecutorHelper.getMemoryCacheSize());
        if (view.getCubeQueryExecutionHints() == null) {
          CubeQueryExecutorHints hints=new CubeQueryExecutorHints();
          view.getCubeQueryExecutionHints().executeCubeOperation(false);
        }
        QueryExecutorUtil.initLoadedAggregationResultSets(rs,getSavedAggregations());
      }
 else {
        rs=executeQuery(view,aggrDefns,saveToRD,id,fetcher);
      }
    }
  }
  executor.setQueryResultsId(id);
  return rs;
}","private IAggregationResultSet[] populateRs(BirtCubeView view,AggregationDefinition[] aggrDefns,CubeQueryExecutorHelper cubeQueryExcutorHelper2,StopSign stopSign,boolean saveToRD,IBindingValueFetcher fetcher) throws IOException, BirtException {
  IAggregationResultSet[] rs=null;
  String id=null;
  CubeQueryExecutor executor=view.getCubeQueryExecutor();
  if (executor.getCubeQueryDefinition().getQueryResultsID() == null) {
    if (saveToRD || executor.getCubeQueryDefinition().cacheQueryResults())     id=executor.getSession().getQueryResultIDUtil().nextID();
    rs=executeQuery(view,aggrDefns,saveToRD,id,fetcher);
  }
 else {
    id=executor.getCubeQueryDefinition().getQueryResultsID();
    if (executor.getCubeQueryDefinition().cacheQueryResults()) {
      FileArchiveReader far=new FileArchiveReader(executor.getSession().getTempDir() + ""String_Node_Str"");
      rs=AggregationResultSetSaveUtil.load(id,far,VersionManager.getLatestVersion(),cubeQueryExecutorHelper.getMemoryCacheSize());
      far.close();
      if (view.getCubeQueryExecutionHints() == null) {
        CubeQueryExecutorHints hints=new CubeQueryExecutorHints();
        view.getCubeQueryExecutionHints().executeCubeOperation(false);
      }
      QueryExecutorUtil.initLoadedAggregationResultSets(rs,getSavedAggregations());
    }
 else {
      if (executor.getContext().getDocReader() != null && executor.getContext().getMode() != DataEngineContext.MODE_GENERATION) {
        rs=AggregationResultSetSaveUtil.load(executor.getCubeQueryDefinition().getQueryResultsID(),executor.getContext().getDocReader(),new VersionManager(executor.getContext()).getVersion(id),cubeQueryExecutorHelper.getMemoryCacheSize());
        if (view.getCubeQueryExecutionHints() == null) {
          CubeQueryExecutorHints hints=new CubeQueryExecutorHints();
          view.getCubeQueryExecutionHints().executeCubeOperation(false);
        }
        QueryExecutorUtil.initLoadedAggregationResultSets(rs,getSavedAggregations());
      }
 else {
        rs=executeQuery(view,aggrDefns,saveToRD,id,fetcher);
      }
    }
  }
  executor.setQueryResultsId(id);
  return rs;
}",0.9508822126847878
64897,"private IAggregationResultSet[] executeQuery(BirtCubeView view,AggregationDefinition[] aggrDefns,boolean saveToRD,String queryResutID,IBindingValueFetcher fetcher) throws IOException, BirtException {
  IAggregationResultSet[] rs;
  CubeQueryExecutor executor=view.getCubeQueryExecutor();
  rs=cubeQueryExecutorHelper.execute(aggrDefns,executor.getSession().getStopSign());
  rs=QueryExecutorUtil.applyFilterOnOperation(view,cubeQueryExecutorHelper,executor,aggrDefns,rs,fetcher,executor.getSession().getStopSign());
  rs=noUpdateFilterHelper.applyNoAggrUpdateFilters(executor.getCubeQueryDefinition().getFilters(),executor,rs,view.getCube(),fetcher,false);
  MirrorOperationExecutor moe=new MirrorOperationExecutor();
  rs=moe.execute(rs,view,cubeQueryExecutorHelper);
  QueryExecutorUtil.validateLimitSetting(view,rs);
  rs=this.processNestedAggrOperation(executor,view,executor.getSession().getStopSign(),rs,fetcher);
  if (executor.getCubeQueryDefinition().cacheQueryResults()) {
    File tmpDir=new File(executor.getSession().getTempDir());
    if (!FileSecurity.fileExist(tmpDir) || !FileSecurity.fileIsDirectory(tmpDir)) {
      FileSecurity.fileMakeDirs(tmpDir);
    }
    ArchiveWriter writer=new ArchiveWriter(new ArchiveFile(executor.getSession().getTempDir() + ""String_Node_Str"",""String_Node_Str""));
    AggregationResultSetSaveUtil.save(queryResutID,rs,writer);
    writer.finish();
  }
  if (saveToRD) {
    CubeQueryDefinitionIOUtil.save(queryResutID,executor.getContext(),executor.getCubeQueryDefinition());
    AggregationResultSetSaveUtil.save(queryResutID,rs,executor.getContext().getDocWriter());
  }
  return rs;
}","private IAggregationResultSet[] executeQuery(BirtCubeView view,AggregationDefinition[] aggrDefns,boolean saveToRD,String queryResutID,IBindingValueFetcher fetcher) throws IOException, BirtException {
  IAggregationResultSet[] rs;
  CubeQueryExecutor executor=view.getCubeQueryExecutor();
  rs=cubeQueryExecutorHelper.execute(aggrDefns,executor.getSession().getStopSign());
  rs=QueryExecutorUtil.applyFilterOnOperation(view,cubeQueryExecutorHelper,executor,aggrDefns,rs,fetcher,executor.getSession().getStopSign());
  rs=noUpdateFilterHelper.applyNoAggrUpdateFilters(executor.getCubeQueryDefinition().getFilters(),executor,rs,view.getCube(),fetcher,false);
  MirrorOperationExecutor moe=new MirrorOperationExecutor();
  rs=moe.execute(rs,view,cubeQueryExecutorHelper);
  QueryExecutorUtil.validateLimitSetting(view,rs);
  rs=this.processNestedAggrOperation(executor,view,executor.getSession().getStopSign(),rs,fetcher);
  if (executor.getCubeQueryDefinition().cacheQueryResults()) {
    String tmpDirPath=executor.getSession().getTempDir();
    File tmpDir=new File(tmpDirPath);
    if (!FileSecurity.fileExist(tmpDir) || !FileSecurity.fileIsDirectory(tmpDir)) {
      FileSecurity.fileMakeDirs(tmpDir);
    }
    ArchiveFile aFile=new ArchiveFile(tmpDirPath + ""String_Node_Str"",""String_Node_Str"");
    ArchiveWriter writer=new ArchiveWriter(aFile);
    AggregationResultSetSaveUtil.save(queryResutID,rs,writer);
    writer.finish();
    aFile.close();
  }
  if (saveToRD) {
    CubeQueryDefinitionIOUtil.save(queryResutID,executor.getContext(),executor.getCubeQueryDefinition());
    AggregationResultSetSaveUtil.save(queryResutID,rs,executor.getContext().getDocWriter());
  }
  return rs;
}",0.9212266987372218
64898,"protected boolean isIE7(String userAgent){
  if (userAgent != null) {
    if (userAgent.contains(""String_Node_Str"") || userAgent.contains(""String_Node_Str"") || userAgent.contains(""String_Node_Str"")) {
      return true;
    }
  }
  return false;
}","protected boolean isIE7(String userAgent){
  if (userAgent != null) {
    if ((userAgent.contains(""String_Node_Str"") || userAgent.contains(""String_Node_Str"") || userAgent.contains(""String_Node_Str"")) && (!userAgent.contains(""String_Node_Str""))) {
      return true;
    }
  }
  return false;
}",0.4777777777777778
64899,"protected void startTable(ITableContent tableContent){
  LayoutStatus status=new LayoutStatus();
  status.table=table;
  status.cells=cells;
  status.columnCount=columnCount;
  status.hasHiddenColumn=hasHiddenColumn;
  status.currentCell=currentCell;
  statuses.push(status);
  table=tableContent;
  columnCount=tableContent.getColumnCount();
  cells=new int[columnCount];
  columnHiddens=new boolean[columnCount];
  for (int i=0; i < columnCount; i++) {
    IColumn column=tableContent.getColumn(i);
    boolean isHidden=column.getComputedStyle().getProperty(IStyle.STYLE_DISPLAY) == IStyle.NONE_VALUE;
    columnHiddens[i]=isHidden;
    if (isHidden) {
      hasHiddenColumn=true;
    }
  }
}","protected void startTable(ITableContent tableContent){
  LayoutStatus status=new LayoutStatus();
  status.table=table;
  status.cells=cells;
  status.columnCount=columnCount;
  status.columnHiddens=columnHiddens;
  status.hasHiddenColumn=hasHiddenColumn;
  status.currentCell=currentCell;
  statuses.push(status);
  table=tableContent;
  columnCount=tableContent.getColumnCount();
  cells=new int[columnCount];
  columnHiddens=new boolean[columnCount];
  for (int i=0; i < columnCount; i++) {
    IColumn column=tableContent.getColumn(i);
    boolean isHidden=column.getComputedStyle().getProperty(IStyle.STYLE_DISPLAY) == IStyle.NONE_VALUE;
    columnHiddens[i]=isHidden;
    if (isHidden) {
      hasHiddenColumn=true;
    }
  }
}",0.9733520336605892
64900,"public DesignElementHandle createElement(Object extendedData){
  boolean isTable=ReportDesignConstants.TABLE_ITEM.equals(getElementType());
  if (isTable) {
    TableOptionWizard wizard=new TableOptionWizard();
    WizardDialog dialog=new BaseWizardDialog(UIUtil.getDefaultShell(),wizard);
    if (dialog.open() == Window.OK) {
      Object[] result=(Object[])dialog.getResult();
      Object[] data=(Object[])result[0];
      boolean isSummaryTable=data.length > 2 && data[2] != null && ((Boolean)data[2]).booleanValue();
      Object[] datasetInfo=(Object[])result[1];
      int columnCount=((Integer)data[1]).intValue();
      int bindingCount=0;
      if (datasetInfo != null && datasetInfo[1] instanceof Object[]) {
        bindingCount=((Object[])datasetInfo[1]).length;
        if (bindingCount > 0) {
          columnCount=bindingCount;
        }
      }
      TableHandle table=DesignElementFactory.getInstance().newTableItem(null,columnCount,1,isSummaryTable ? 0 : ((Integer)data[0]).intValue(),1);
      InsertInLayoutUtil.setInitWidth(table);
      if (datasetInfo != null && datasetInfo[0] != null) {
        try {
          DataSetHandle dataSetHandle=(DataSetHandle)datasetInfo[0];
          ((ReportItemHandle)table).setDataSet(dataSetHandle);
          ((ReportItemHandle)table).setDataSet((DataSetHandle)datasetInfo[0]);
          DataSetColumnBindingsFormHandleProvider provider=new DataSetColumnBindingsFormHandleProvider();
          provider.setBindingObject(table);
          if (datasetInfo[1] instanceof Object[]) {
            Object[] selectedColumns=(Object[])datasetInfo[1];
            provider.generateBindingColumns(selectedColumns);
            if (bindingCount > 0) {
              ResultSetColumnHandle[] columns=new ResultSetColumnHandle[bindingCount];
              for (int i=0; i < selectedColumns.length; i++) {
                columns[i]=(ResultSetColumnHandle)selectedColumns[i];
              }
              InsertInLayoutUtil.insertToCell(dataSetHandle,table,table.getHeader(),columns,true);
              if (!isSummaryTable) {
                InsertInLayoutUtil.insertToCell(dataSetHandle,table,table.getDetail(),columns,false);
              }
            }
          }
        }
 catch (        Exception e) {
          ExceptionHandler.handle(e);
        }
      }
      if (isSummaryTable) {
        try {
          table.setIsSummaryTable(((Boolean)data[2]).booleanValue());
        }
 catch (        SemanticException e) {
          ExceptionHandler.handle(e);
        }
      }
      return table;
    }
  }
 else {
    TableOptionDialog dialog=new TableOptionDialog(UIUtil.getDefaultShell(),isTable);
    if (dialog.open() == Window.OK && dialog.getResult() instanceof Object[]) {
      Object[] data=(Object[])dialog.getResult();
      DesignElementHandle handle=DesignElementFactory.getInstance().newGridItem(getNewName(extendedData),((Integer)data[1]).intValue(),((Integer)data[0]).intValue());
      InsertInLayoutUtil.setInitWidth(handle);
      return handle;
    }
  }
  return null;
}","public DesignElementHandle createElement(Object extendedData){
  boolean isTable=ReportDesignConstants.TABLE_ITEM.equals(getElementType());
  if (isTable) {
    TableOptionBindingDialog dialog=new TableOptionBindingDialog(UIUtil.getDefaultShell());
    if (dialog.open() == Window.OK) {
      Object[] result=(Object[])dialog.getResult();
      Object[] data=(Object[])result[0];
      boolean isSummaryTable=data.length > 2 && data[2] != null && ((Boolean)data[2]).booleanValue();
      Object[] datasetInfo=(Object[])result[1];
      int columnCount=((Integer)data[1]).intValue();
      int bindingCount=0;
      if (datasetInfo != null && datasetInfo[1] instanceof Object[]) {
        bindingCount=((Object[])datasetInfo[1]).length;
        if (bindingCount > 0) {
          columnCount=bindingCount;
        }
      }
      TableHandle table=DesignElementFactory.getInstance().newTableItem(null,columnCount,1,isSummaryTable ? 0 : ((Integer)data[0]).intValue(),1);
      InsertInLayoutUtil.setInitWidth(table);
      if (datasetInfo != null && datasetInfo[0] != null) {
        try {
          DataSetHandle dataSetHandle=(DataSetHandle)datasetInfo[0];
          ((ReportItemHandle)table).setDataSet(dataSetHandle);
          ((ReportItemHandle)table).setDataSet((DataSetHandle)datasetInfo[0]);
          DataSetColumnBindingsFormHandleProvider provider=new DataSetColumnBindingsFormHandleProvider();
          provider.setBindingObject(table);
          if (datasetInfo[1] instanceof Object[]) {
            Object[] selectedColumns=(Object[])datasetInfo[1];
            provider.generateBindingColumns(selectedColumns);
            if (bindingCount > 0) {
              ResultSetColumnHandle[] columns=new ResultSetColumnHandle[bindingCount];
              for (int i=0; i < selectedColumns.length; i++) {
                columns[i]=(ResultSetColumnHandle)selectedColumns[i];
              }
              InsertInLayoutUtil.insertToCell(dataSetHandle,table,table.getHeader(),columns,true);
              if (!isSummaryTable) {
                InsertInLayoutUtil.insertToCell(dataSetHandle,table,table.getDetail(),columns,false);
              }
            }
          }
        }
 catch (        Exception e) {
          ExceptionHandler.handle(e);
        }
      }
      if (isSummaryTable) {
        try {
          table.setIsSummaryTable(((Boolean)data[2]).booleanValue());
        }
 catch (        SemanticException e) {
          ExceptionHandler.handle(e);
        }
      }
      return table;
    }
  }
 else {
    TableOptionDialog dialog=new TableOptionDialog(UIUtil.getDefaultShell(),isTable);
    if (dialog.open() == Window.OK && dialog.getResult() instanceof Object[]) {
      Object[] data=(Object[])dialog.getResult();
      DesignElementHandle handle=DesignElementFactory.getInstance().newGridItem(getNewName(extendedData),((Integer)data[1]).intValue(),((Integer)data[0]).intValue());
      InsertInLayoutUtil.setInitWidth(handle);
      return handle;
    }
  }
  return null;
}",0.9846357178258714
64901,"private void startBackgroundContainer(IStyle style,DimensionType pageWidth,DimensionType pageHeight){
  String backgroundHeight=parseBackgroundSize(style.getBackgroundHeight(),pageHeight);
  String backgroundWidth=parseBackgroundSize(style.getBackgroundWidth(),pageWidth);
  if (backgroundHeight == null && backgroundWidth == null) {
    return;
  }
 else {
    if (backgroundHeight == null) {
      backgroundHeight=""String_Node_Str"";
    }
    if (backgroundWidth == null) {
      backgroundWidth=""String_Node_Str"";
    }
  }
  String image=style.getBackgroundImage();
  if (image == null || ""String_Node_Str"".equalsIgnoreCase(image)) {
    return;
  }
  needOutputBackgroundSize=true;
  String backgroundPositionX=style.getBackgroundPositionX();
  if (backgroundPositionX == null) {
    backgroundPositionX=""String_Node_Str"";
  }
  String backgroundPositionY=style.getBackgroundPositionY();
  if (backgroundPositionY == null) {
    backgroundPositionY=""String_Node_Str"";
  }
  writer.openTag(HTMLTags.TAG_DIV);
  writer.attribute(HTMLTags.ATTR_STYLE,""String_Node_Str"" + pageWidth + ""String_Node_Str""+ pageHeight+ ""String_Node_Str"");
  writer.openTag(HTMLTags.TAG_IMAGE);
  writer.attributeAllowEmpty(HTMLTags.ATTR_ALT,""String_Node_Str"");
  image=handleStyleImage(image,true);
  if (image != null && image.length() > 0) {
    writer.attribute(HTMLTags.ATTR_SRC,image);
    writer.attribute(HTMLTags.ATTR_STYLE,""String_Node_Str"" + backgroundWidth + ""String_Node_Str""+ backgroundHeight+ ""String_Node_Str""+ backgroundPositionX+ ""String_Node_Str""+ backgroundPositionY+ ""String_Node_Str"");
  }
  writer.closeTag(HTMLTags.TAG_IMAGE);
}","private void startBackgroundContainer(IStyle style,DimensionType pageWidth,DimensionType pageHeight){
  String backgroundHeight=parseBackgroundSize(style.getBackgroundHeight(),pageHeight);
  String backgroundWidth=parseBackgroundSize(style.getBackgroundWidth(),pageWidth);
  if (backgroundHeight == null && backgroundWidth == null) {
    return;
  }
 else {
    if (backgroundHeight == null) {
      backgroundHeight=""String_Node_Str"";
    }
    if (backgroundWidth == null) {
      backgroundWidth=""String_Node_Str"";
    }
  }
  String image=style.getBackgroundImage();
  if (image == null || ""String_Node_Str"".equalsIgnoreCase(image)) {
    return;
  }
  needOutputBackgroundSize=true;
  writer.openTag(HTMLTags.TAG_DIV);
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(pageWidth).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(pageHeight).append(""String_Node_Str"");
  AttributeBuilder.buildBackground(sb,style,this);
  sb.append(""String_Node_Str"").append(backgroundWidth).append(""String_Node_Str"").append(backgroundHeight).append(""String_Node_Str"");
  writer.attribute(HTMLTags.ATTR_STYLE,sb.toString());
}",0.548456568557071
64902,"public void onPageBreak(boolean isHorizontalPageBreak,boolean isFixedlayoutPageBreak){
  if (!isHorizontalPageBreak) {
    pageRowCount=0;
    if (addAfterBreak) {
      next();
      addAfterBreak=false;
    }
 else     if (isFixedlayoutPageBreak) {
      next();
    }
 else {
      if (softBreakBefore) {
        softBreakBefore=false;
      }
    }
  }
}","public void onPageBreak(boolean isHorizontalPageBreak,boolean isFixedlayoutPageBreak){
  if (!isHorizontalPageBreak) {
    pageRowCount=0;
    if (addAfterBreak) {
      next();
      addAfterBreak=false;
    }
 else {
      if (isFixedlayoutPageBreak) {
        next();
      }
      if (softBreakBefore) {
        softBreakBefore=false;
      }
    }
  }
}",0.9748603351955308
64903,"public boolean needSave(){
  if (name != null) {
    return true;
  }
  if (x != null || y != null || width != null || height != null) {
    return true;
  }
  if (hyperlink != null || bookmark != null || toc != null) {
    return true;
  }
  if (helpText != null) {
    return true;
  }
  if (inlineStyle != null && !inlineStyle.isEmpty()) {
    return true;
  }
  if (acl != null) {
    return true;
  }
  if (userProperties != null && !userProperties.isEmpty()) {
    return true;
  }
  if (extProperties != null && !extProperties.isEmpty()) {
    return true;
  }
  return false;
}","public boolean needSave(){
  if (name != null) {
    return true;
  }
  if (x != null || y != null || width != null || height != null) {
    return true;
  }
  if (hyperlink != null || bookmark != null || toc != null) {
    return true;
  }
  if (helpText != null) {
    return true;
  }
  if (inlineStyle != null && !inlineStyle.isEmpty()) {
    return true;
  }
  if (acl != null) {
    return true;
  }
  if (userProperties != null && !userProperties.isEmpty()) {
    return true;
  }
  if (extProperties != null && !extProperties.isEmpty()) {
    return true;
  }
  if (altText != null || altTextKey != null) {
    return true;
  }
  return false;
}",0.9208400646203554
64904,"private String getImageCacheID(IContent content){
  StringBuffer buffer=new StringBuffer();
  buffer.append(content.getInstanceID().toUniqueString());
  buffer.append(getChartResolution(content));
  buffer.append(getChartFormats());
  buffer.append(locale);
  if (timeZone != null) {
    buffer.append(timeZone.getID());
  }
  return buffer.toString();
}","private String getImageCacheID(IContent content){
  StringBuffer buffer=new StringBuffer();
  buffer.append(content.getInstanceID().toUniqueString());
  buffer.append(getChartResolution(content));
  buffer.append(getChartFormats());
  buffer.append(locale);
  if (timeZone != null) {
    buffer.append(timeZone.getID());
  }
  DimensionType heightDimension=content.getHeight();
  String heightUnits=heightDimension == null ? ""String_Node_Str"" : heightDimension.getUnits();
  double heightValue=heightDimension == null ? 0 : heightDimension.getMeasure();
  DimensionType widthDimension=content.getWidth();
  String widthUnits=widthDimension == null ? ""String_Node_Str"" : widthDimension.getUnits();
  double widthValue=widthDimension == null ? 0 : widthDimension.getMeasure();
  buffer.append(heightValue);
  buffer.append(heightUnits);
  buffer.append(widthValue);
  buffer.append(widthUnits);
  return buffer.toString();
}",0.554858934169279
64905,"protected void createColumnBindingTableContents(Composite parent,Object input){
  columnTableViewer=CheckboxTableViewer.newCheckList(parent,SWT.CHECK | SWT.BORDER | SWT.FULL_SELECTION);
  GridData data=new GridData(GridData.FILL_BOTH);
  data.widthHint=450;
  data.heightHint=200;
  data.horizontalSpan=2;
  data.verticalIndent=5;
  columnTableViewer.getTable().setLayoutData(data);
  columnTableViewer.getTable().setHeaderVisible(true);
  columnTableViewer.getTable().setLinesVisible(true);
  new TableColumn(columnTableViewer.getTable(),SWT.NONE).setText(""String_Node_Str"");
  new TableColumn(columnTableViewer.getTable(),SWT.NONE).setText(Messages.getString(""String_Node_Str""));
  new TableColumn(columnTableViewer.getTable(),SWT.NONE).setText(Messages.getString(""String_Node_Str""));
  TableLayout layout=new AutoResizeTableLayout(columnTableViewer.getTable());
  layout.addColumnData(new ColumnWeightData(6,true));
  layout.addColumnData(new ColumnWeightData(47,true));
  layout.addColumnData(new ColumnWeightData(47,true));
  columnTableViewer.getTable().setLayout(layout);
  columnTableViewer.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      enableOKButton();
    }
  }
);
  DataSetColumnProvider provider=new DataSetColumnProvider();
  columnTableViewer.setLabelProvider(provider);
  columnTableViewer.setContentProvider(provider);
  Composite buttonContainer=new Composite(parent,SWT.NONE);
  data=new GridData(GridData.FILL_HORIZONTAL);
  data.horizontalSpan=2;
  buttonContainer.setLayoutData(data);
  GridLayout gdLayout=new GridLayout();
  gdLayout.numColumns=2;
  gdLayout.marginWidth=gdLayout.marginHeight=0;
  buttonContainer.setLayout(gdLayout);
  Button selectAllButton=new Button(buttonContainer,SWT.PUSH);
  selectAllButton.setText(Messages.getString(""String_Node_Str""));
  selectAllButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      columnTableViewer.setAllChecked(true);
      enableOKButton();
    }
  }
);
  Button deselectAllButton=new Button(buttonContainer,SWT.PUSH);
  deselectAllButton.setText(Messages.getString(""String_Node_Str""));
  deselectAllButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      columnTableViewer.setAllChecked(false);
      enableOKButton();
    }
  }
);
  handleDataSetComboSelectedEvent();
  if (columns != null) {
    int count=columnTableViewer.getTable().getItemCount();
    List columnList=Arrays.asList(columns);
    for (int i=0; i < count; i++) {
      ResultSetColumnHandle column=(ResultSetColumnHandle)columnTableViewer.getElementAt(i);
      if (columnList.contains(column.getColumnName())) {
        columnTableViewer.setChecked(column,true);
      }
    }
  }
}","protected void createColumnBindingTableContents(Composite parent,Object input){
  columnTableViewer=CheckboxTableViewer.newCheckList(parent,SWT.CHECK | SWT.BORDER | SWT.FULL_SELECTION);
  GridData data=new GridData(GridData.FILL_BOTH);
  data.widthHint=450;
  data.heightHint=200;
  data.horizontalSpan=2;
  data.verticalIndent=5;
  columnTableViewer.getTable().setLayoutData(data);
  columnTableViewer.getTable().setHeaderVisible(true);
  columnTableViewer.getTable().setLinesVisible(true);
  new TableColumn(columnTableViewer.getTable(),SWT.NONE).setText(""String_Node_Str"");
  new TableColumn(columnTableViewer.getTable(),SWT.NONE).setText(Messages.getString(""String_Node_Str""));
  new TableColumn(columnTableViewer.getTable(),SWT.NONE).setText(Messages.getString(""String_Node_Str""));
  TableLayout layout=new AutoResizeTableLayout(columnTableViewer.getTable());
  layout.addColumnData(new ColumnWeightData(6,true));
  layout.addColumnData(new ColumnWeightData(47,true));
  layout.addColumnData(new ColumnWeightData(47,true));
  columnTableViewer.getTable().setLayout(layout);
  columnTableViewer.addSelectionChangedListener(new ISelectionChangedListener(){
    public void selectionChanged(    SelectionChangedEvent event){
      enableOKButton();
    }
  }
);
  DataSetColumnProvider provider=new DataSetColumnProvider();
  columnTableViewer.setLabelProvider(provider);
  columnTableViewer.setContentProvider(provider);
  Composite buttonContainer=new Composite(parent,SWT.NONE);
  data=new GridData(GridData.FILL_HORIZONTAL);
  data.horizontalSpan=2;
  buttonContainer.setLayoutData(data);
  GridLayout gdLayout=new GridLayout();
  gdLayout.numColumns=2;
  gdLayout.marginWidth=gdLayout.marginHeight=0;
  buttonContainer.setLayout(gdLayout);
  Button selectAllButton=new Button(buttonContainer,SWT.PUSH);
  selectAllButton.setText(Messages.getString(""String_Node_Str""));
  selectAllButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      columnTableViewer.setAllChecked(true);
      enableOKButton();
    }
  }
);
  Button deselectAllButton=new Button(buttonContainer,SWT.PUSH);
  deselectAllButton.setText(Messages.getString(""String_Node_Str""));
  deselectAllButton.addSelectionListener(new SelectionAdapter(){
    public void widgetSelected(    SelectionEvent e){
      columnTableViewer.setAllChecked(false);
      enableOKButton();
    }
  }
);
  handleDataSetComboSelectedEvent(input);
  if (columns != null) {
    int count=columnTableViewer.getTable().getItemCount();
    List columnList=Arrays.asList(columns);
    for (int i=0; i < count; i++) {
      ResultSetColumnHandle column=(ResultSetColumnHandle)columnTableViewer.getElementAt(i);
      if (columnList.contains(column.getColumnName())) {
        columnTableViewer.setChecked(column,true);
      }
    }
  }
}",0.9991176989588848
64906,"protected void createDataSetContents(Composite parent){
  if (dataSetName != null) {
    Label lb=new Label(parent,SWT.NONE);
    lb.setText(Messages.getString(""String_Node_Str""));
    GridData data=new GridData(GridData.FILL_HORIZONTAL);
    data.horizontalSpan=2;
    lb.setLayoutData(data);
  }
 else {
    Label dateSetLabel=new Label(parent,SWT.NONE);
    dateSetLabel.setText(Messages.getString(""String_Node_Str""));
    dataSetCombo=new Combo(parent,SWT.BORDER | SWT.READ_ONLY);
    datasets=UIUtil.getVisibleDataSetHandles(SessionHandleAdapter.getInstance().getModule());
    dataSetCombo.setItems(getDataSetComboList());
    dataSetCombo.select(0);
    GridData data=new GridData(GridData.FILL_HORIZONTAL);
    dataSetCombo.setLayoutData(data);
    dataSetCombo.setVisibleItemCount(30);
    dataSetCombo.addSelectionListener(new SelectionAdapter(){
      public void widgetSelected(      SelectionEvent e){
        handleDataSetComboSelectedEvent();
      }
    }
);
  }
}","protected void createDataSetContents(Composite parent){
  if (dataSetName != null) {
    Label lb=new Label(parent,SWT.NONE);
    lb.setText(Messages.getString(""String_Node_Str""));
    GridData data=new GridData(GridData.FILL_HORIZONTAL);
    data.horizontalSpan=2;
    lb.setLayoutData(data);
  }
 else {
    Label dateSetLabel=new Label(parent,SWT.NONE);
    dateSetLabel.setText(Messages.getString(""String_Node_Str""));
    dataSetCombo=new Combo(parent,SWT.BORDER | SWT.READ_ONLY);
    datasets=UIUtil.getVisibleDataSetHandles(SessionHandleAdapter.getInstance().getModule());
    dataSetCombo.setItems(getDataSetComboList());
    dataSetCombo.select(0);
    GridData data=new GridData(GridData.FILL_HORIZONTAL);
    dataSetCombo.setLayoutData(data);
    dataSetCombo.setVisibleItemCount(30);
    dataSetCombo.addSelectionListener(new SelectionAdapter(){
      public void widgetSelected(      SelectionEvent e){
        Object input=populateInput();
        if (input instanceof Map) {
          if (columnTreeViewer == null) {
            disposeChildren(contentPane);
            columnTableViewer=null;
            createColumnBindingTreeContents(contentPane,input);
          }
        }
 else {
          if (columnTableViewer == null) {
            disposeChildren(contentPane);
            columnTreeViewer=null;
            createColumnBindingTableContents(contentPane,input);
          }
        }
        handleDataSetComboSelectedEvent(input);
      }
    }
);
  }
}",0.7967479674796748
64907,"public void widgetSelected(SelectionEvent e){
  handleDataSetComboSelectedEvent();
}","public void widgetSelected(SelectionEvent e){
  Object input=populateInput();
  if (input instanceof Map) {
    if (columnTreeViewer == null) {
      disposeChildren(contentPane);
      columnTableViewer=null;
      createColumnBindingTreeContents(contentPane,input);
    }
  }
 else {
    if (columnTableViewer == null) {
      disposeChildren(contentPane);
      columnTreeViewer=null;
      createColumnBindingTableContents(contentPane,input);
    }
  }
  handleDataSetComboSelectedEvent(input);
}",0.2876712328767123
64908,"/** 
 * Inserts dataset column into the target. Add label or group key if possible
 * @param model column item
 * @param target insert target like cell or ListBandProxy
 * @param targetParent target container like table or list
 * @return to be inserted data item
 * @throws SemanticException
 */
protected static DesignElementHandle performInsertDataSetColumn(ResultSetColumnHandle model,Object target,Object targetParent) throws SemanticException {
  DataItemHandle dataHandle=DesignElementFactory.getInstance().newDataItem(null);
  DataSetHandle dataSet=getDataSet(model);
  if (targetParent instanceof TableHandle) {
    TableHandle tableHandle=(TableHandle)targetParent;
    if (tableHandle.isSummaryTable()) {
      setDataSet(tableHandle,dataSet);
      setDataItemAction(model,dataHandle);
      if (DesignChoiceConstants.ANALYSIS_TYPE_DIMENSION.equals(UIUtil.getColumnAnalysis(model))) {
        ComputedColumn bindingColumn=StructureFactory.newComputedColumn(tableHandle,model.getColumnName());
        bindingColumn.setDataType(model.getDataType());
        ExpressionUtility.setBindingColumnExpression(model,bindingColumn);
        bindingColumn.setDisplayName(UIUtil.getColumnDisplayName(model));
        String displayKey=UIUtil.getColumnDisplayNameKey(model);
        if (displayKey != null)         bindingColumn.setDisplayNameID(displayKey);
        tableHandle.addColumnBinding(bindingColumn,false);
        dataHandle.setResultSetColumn(model.getColumnName());
        SlotHandle slotHandle=tableHandle.getGroups();
        for (        Object o : slotHandle.getContents()) {
          GroupHandle group=(GroupHandle)o;
          if (group.getName().equals(model.getColumnName())) {
            if (target instanceof CellHandle) {
              CellHandle cellTarget=(CellHandle)target;
              if (cellTarget.getContent().getCount() == 0) {
                return dataHandle;
              }
            }
            return null;
          }
        }
        int index=-1;
        if (target instanceof CellHandle) {
          CellHandle cellTarget=(CellHandle)target;
          CellHandleAdapter cellAdapter=HandleAdapterFactory.getInstance().getCellHandleAdapter(cellTarget);
          index=cellAdapter.getColumnNumber();
        }
        return addGroupHandle(tableHandle,model,dataHandle,index - 1);
      }
 else       if (DesignChoiceConstants.ANALYSIS_TYPE_ATTRIBUTE.equals(UIUtil.getColumnAnalysis(model))) {
        DataSetHandle dataset=getDataSet(model);
        String str=UIUtil.getAnalysisColumn(model);
        String type=""String_Node_Str"";
        ResultSetColumnHandle newResultColumn=null;
        if (str != null) {
          List<ColumnHintHandle> columnHints=DataUtil.getColumnHints(dataset);
          ColumnHintHandle temp=null;
          for (int i=0; i < columnHints.size(); i++) {
            ColumnHintHandle columnHintHandle=(ColumnHintHandle)columnHints.get(i);
            if (str.equals(columnHintHandle.getColumnName()) || str.equals(columnHintHandle.getAlias())) {
              temp=columnHintHandle;
              break;
            }
          }
          if (temp == null) {
            return dataHandle;
          }
          List columnList=DataUtil.getColumnList(dataset);
          for (int i=0; i < columnList.size(); i++) {
            ResultSetColumnHandle resultSetColumn=(ResultSetColumnHandle)columnList.get(i);
            if (temp != null && (temp.getAlias().equals(resultSetColumn.getColumnName()) || temp.getColumnName().equals((resultSetColumn.getColumnName())))) {
              newResultColumn=resultSetColumn;
              break;
            }
          }
          List<ColumnHintHandle> columnHints=DataUtil.getColumnHints(dataset);
          for (          ColumnHintHandle columnHint : columnHints) {
            if (str.equals(columnHint.getColumnName()) || str.equals(columnHint.getAlias())) {
              type=columnHint.getAnalysis();
              break;
            }
          }
          if (DesignChoiceConstants.ANALYSIS_TYPE_DIMENSION.equals(type)) {
            boolean hasGroup=false;
            SlotHandle slotHandle=tableHandle.getGroups();
            for (            Object o : slotHandle.getContents()) {
              GroupHandle group=(GroupHandle)o;
              if (group.getName().equals(temp.getColumnName()) || group.getName().equals(temp.getAlias()))               hasGroup=true;
            }
            if (!hasGroup) {
              ComputedColumn bindingColumn=StructureFactory.newComputedColumn(tableHandle,model.getColumnName());
              bindingColumn.setDataType(model.getDataType());
              ExpressionUtility.setBindingColumnExpression(model,bindingColumn);
              bindingColumn.setDisplayName(UIUtil.getColumnDisplayName(model));
              String displayKey=UIUtil.getColumnDisplayNameKey(model);
              if (displayKey != null)               bindingColumn.setDisplayNameID(displayKey);
              tableHandle.addColumnBinding(bindingColumn,false);
              dataHandle.setResultSetColumn(model.getColumnName());
              bindingColumn=StructureFactory.newComputedColumn(tableHandle,newResultColumn.getColumnName());
              bindingColumn.setDataType(newResultColumn.getDataType());
              ExpressionUtility.setBindingColumnExpression(newResultColumn,bindingColumn);
              bindingColumn.setDisplayName(UIUtil.getColumnDisplayName(newResultColumn));
              displayKey=UIUtil.getColumnDisplayNameKey(newResultColumn);
              if (displayKey != null)               bindingColumn.setDisplayNameID(displayKey);
              tableHandle.addColumnBinding(bindingColumn,false);
              int index=-1;
              if (target instanceof CellHandle) {
                CellHandle cellTarget=(CellHandle)target;
                CellHandleAdapter cellAdapter=HandleAdapterFactory.getInstance().getCellHandleAdapter(cellTarget);
                index=cellAdapter.getColumnNumber();
              }
              return addGroupHandle(tableHandle,newResultColumn,dataHandle,index - 1);
            }
          }
        }
        if (target instanceof CellHandle) {
          ComputedColumn column=StructureFactory.newComputedColumn(tableHandle,model.getColumnName());
          column.setDataType(model.getDataType());
          ExpressionUtility.setBindingColumnExpression(model,column);
          ComputedColumnHandle binding=DEUtil.addColumn(tableHandle,column,false);
          dataHandle.setResultSetColumn(binding.getName());
          InsertInLayoutRule rule=new LabelAddRule(target);
          if (rule.canInsert()) {
            LabelHandle label=DesignElementFactory.getInstance().newLabel(null);
            label.setText(UIUtil.getColumnDisplayName(model));
            rule.insert(label);
          }
          rule=new GroupKeySetRule(target,model);
          if (rule.canInsert()) {
            rule.insert(model);
          }
          return dataHandle;
        }
      }
 else       if (DesignChoiceConstants.ANALYSIS_TYPE_MEASURE.equals(UIUtil.getColumnAnalysis(model))) {
        CellHandle cellHandle=(CellHandle)target;
        ComputedColumn column=StructureFactory.newComputedColumn(tableHandle,model.getColumnName());
        ExpressionUtility.setBindingColumnExpression(model,column);
        column.setDataType(model.getDataType());
        ComputedColumnHandle binding=DEUtil.addColumn(tableHandle,column,false);
        DesignElementHandle group=cellHandle.getContainer().getContainer();
        if (group instanceof GroupHandle) {
          binding.setAggregateOn(((GroupHandle)group).getName());
        }
 else {
          binding.setAggregateOn(null);
        }
        if (DesignChoiceConstants.COLUMN_DATA_TYPE_INTEGER.equals(model.getDataType()) || DesignChoiceConstants.COLUMN_DATA_TYPE_FLOAT.equals(model.getDataType()) || DesignChoiceConstants.COLUMN_DATA_TYPE_DECIMAL.equals(model.getDataType())) {
          binding.setAggregateFunction(DesignChoiceConstants.MEASURE_FUNCTION_SUM);
        }
 else {
          binding.setAggregateFunction(DesignChoiceConstants.MEASURE_FUNCTION_MAX);
        }
        dataHandle.setResultSetColumn(binding.getName());
        InsertInLayoutRule rule=new LabelAddRule(target);
        if (rule.canInsert()) {
          LabelHandle label=DesignElementFactory.getInstance().newLabel(null);
          label.setText(UIUtil.getColumnDisplayName(model));
          rule.insert(label);
        }
        rule=new GroupKeySetRule(target,model);
        if (rule.canInsert()) {
          rule.insert(model);
        }
        return dataHandle;
      }
    }
  }
  dataHandle.setResultSetColumn(model.getColumnName());
  formatDataHandle(dataHandle,model);
  if (targetParent instanceof ReportItemHandle) {
    ReportItemHandle container=(ReportItemHandle)targetParent;
    ReportItemHandle root=DEUtil.getBindingRoot(container);
    if (root == null) {
      container=DEUtil.getListingContainer(container);
      if (container == null) {
        ComputedColumn bindingColumn=createBindingColumn(target,dataHandle,model);
        setDataSet(dataHandle,dataSet);
        dataHandle.addColumnBinding(bindingColumn,false);
      }
 else {
        ComputedColumn bindingColumn=createBindingColumn(target,container,model);
        setDataSet(container,dataSet);
        container.addColumnBinding(bindingColumn,false);
      }
    }
 else     if (root.getDataSet() == dataSet || (getAdapter() != null && root.getDataSet() != null && getAdapter().resolveExtendedData(root.getDataSet()).equals(getAdapter().resolveExtendedData(dataSet)))) {
      container=DEUtil.getBindingHolder(container);
      ComputedColumn bindingColumn=createBindingColumn(target,container,model);
      container.addColumnBinding(bindingColumn,false);
    }
 else {
      ReportItemHandle listingHandle=DEUtil.getListingContainer(container);
      if (listingHandle != null && DEUtil.getBindingRoot(listingHandle) == root && DEUtil.getBindingHolder(listingHandle) != listingHandle) {
        ComputedColumn bindingColumn=createBindingColumn(target,listingHandle,model);
        setDataSet(listingHandle,dataSet);
        listingHandle.addColumnBinding(bindingColumn,false);
      }
    }
  }
 else {
    ComputedColumn bindingColumn=StructureFactory.newComputedColumn(dataHandle,model.getColumnName());
    bindingColumn.setDataType(model.getDataType());
    ExpressionUtility.setBindingColumnExpression(model,bindingColumn);
    bindingColumn.setDisplayName(UIUtil.getColumnDisplayName(model));
    String displayKey=UIUtil.getColumnDisplayNameKey(model);
    if (displayKey != null)     bindingColumn.setDisplayNameID(displayKey);
    if (target instanceof DesignElementHandle) {
      if (ExpressionUtil.hasAggregation(bindingColumn.getExpression())) {
        String groupType=DEUtil.getGroupControlType((DesignElementHandle)target);
        if (groupType.equals(DEUtil.TYPE_GROUP_GROUP))         bindingColumn.setAggregateOn(((GroupHandle)DEUtil.getGroups((DesignElementHandle)target).get(0)).getName());
 else         if (groupType.equals(DEUtil.TYPE_GROUP_LISTING))         bindingColumn.setAggregateOn(null);
      }
    }
    dataHandle.addColumnBinding(bindingColumn,false);
    setDataSet(dataHandle,dataSet);
  }
  setDataItemAction(model,dataHandle);
  InsertInLayoutRule rule=new LabelAddRule(target);
  if (rule.canInsert()) {
    LabelHandle label=DesignElementFactory.getInstance().newLabel(null);
    label.setText(UIUtil.getHeadColumnDisplayName(model));
    String displayKey=UIUtil.getColumnHeaderDisplayNameKey(model);
    if (displayKey == null) {
      displayKey=UIUtil.getColumnDisplayNameKey(model);
    }
    if (displayKey != null) {
      label.setTextKey(displayKey);
    }
    rule.insert(label);
  }
  rule=new GroupKeySetRule(target,model);
  if (rule.canInsert()) {
    rule.insert(model);
  }
  return dataHandle;
}","/** 
 * Inserts dataset column into the target. Add label or group key if possible
 * @param model column item
 * @param target insert target like cell or ListBandProxy
 * @param targetParent target container like table or list
 * @return to be inserted data item
 * @throws SemanticException
 */
protected static DesignElementHandle performInsertDataSetColumn(ResultSetColumnHandle model,Object target,Object targetParent) throws SemanticException {
  DataItemHandle dataHandle=DesignElementFactory.getInstance().newDataItem(null);
  DataSetHandle dataSet=getDataSet(model);
  if (targetParent instanceof TableHandle) {
    TableHandle tableHandle=(TableHandle)targetParent;
    if (tableHandle.isSummaryTable()) {
      setDataSet(tableHandle,dataSet);
      setDataItemAction(model,dataHandle);
      if (DesignChoiceConstants.ANALYSIS_TYPE_DIMENSION.equals(UIUtil.getColumnAnalysis(model))) {
        ComputedColumn bindingColumn=StructureFactory.newComputedColumn(tableHandle,model.getColumnName());
        bindingColumn.setDataType(model.getDataType());
        ExpressionUtility.setBindingColumnExpression(model,bindingColumn);
        bindingColumn.setDisplayName(UIUtil.getColumnDisplayName(model));
        String displayKey=UIUtil.getColumnDisplayNameKey(model);
        if (displayKey != null)         bindingColumn.setDisplayNameID(displayKey);
        tableHandle.addColumnBinding(bindingColumn,false);
        dataHandle.setResultSetColumn(model.getColumnName());
        SlotHandle slotHandle=tableHandle.getGroups();
        for (        Object o : slotHandle.getContents()) {
          GroupHandle group=(GroupHandle)o;
          if (group.getName().equals(model.getColumnName())) {
            if (target instanceof CellHandle) {
              CellHandle cellTarget=(CellHandle)target;
              if (cellTarget.getContent().getCount() == 0) {
                return dataHandle;
              }
            }
            return null;
          }
        }
        int index=-1;
        if (target instanceof CellHandle) {
          CellHandle cellTarget=(CellHandle)target;
          CellHandleAdapter cellAdapter=HandleAdapterFactory.getInstance().getCellHandleAdapter(cellTarget);
          index=cellAdapter.getColumnNumber();
        }
        return addGroupHandle(tableHandle,model,dataHandle,index - 1);
      }
 else       if (DesignChoiceConstants.ANALYSIS_TYPE_ATTRIBUTE.equals(UIUtil.getColumnAnalysis(model))) {
        DataSetHandle dataset=getDataSet(model);
        String str=UIUtil.getAnalysisColumn(model);
        String type=""String_Node_Str"";
        ResultSetColumnHandle newResultColumn=null;
        if (str != null) {
          List<ColumnHintHandle> columnHints=DataUtil.getColumnHints(dataset);
          ColumnHintHandle temp=null;
          for (int i=0; i < columnHints.size(); i++) {
            ColumnHintHandle columnHintHandle=(ColumnHintHandle)columnHints.get(i);
            if (str.equals(columnHintHandle.getColumnName()) || str.equals(columnHintHandle.getAlias())) {
              temp=columnHintHandle;
              break;
            }
          }
          if (temp == null) {
            return dataHandle;
          }
          List columnList=DataUtil.getColumnList(dataset);
          for (int i=0; i < columnList.size(); i++) {
            ResultSetColumnHandle resultSetColumn=(ResultSetColumnHandle)columnList.get(i);
            if (temp != null && (temp.getAlias().equals(resultSetColumn.getColumnName()) || temp.getColumnName().equals((resultSetColumn.getColumnName())))) {
              newResultColumn=resultSetColumn;
              break;
            }
          }
          columnHints=DataUtil.getColumnHints(dataset);
          for (          ColumnHintHandle columnHint : columnHints) {
            if (str.equals(columnHint.getColumnName()) || str.equals(columnHint.getAlias())) {
              type=columnHint.getAnalysis();
              break;
            }
          }
          if (DesignChoiceConstants.ANALYSIS_TYPE_DIMENSION.equals(type)) {
            boolean hasGroup=false;
            SlotHandle slotHandle=tableHandle.getGroups();
            for (            Object o : slotHandle.getContents()) {
              GroupHandle group=(GroupHandle)o;
              if (group.getName().equals(temp.getColumnName()) || group.getName().equals(temp.getAlias()))               hasGroup=true;
            }
            if (!hasGroup) {
              ComputedColumn bindingColumn=StructureFactory.newComputedColumn(tableHandle,model.getColumnName());
              bindingColumn.setDataType(model.getDataType());
              ExpressionUtility.setBindingColumnExpression(model,bindingColumn);
              bindingColumn.setDisplayName(UIUtil.getColumnDisplayName(model));
              String displayKey=UIUtil.getColumnDisplayNameKey(model);
              if (displayKey != null)               bindingColumn.setDisplayNameID(displayKey);
              tableHandle.addColumnBinding(bindingColumn,false);
              dataHandle.setResultSetColumn(model.getColumnName());
              bindingColumn=StructureFactory.newComputedColumn(tableHandle,newResultColumn.getColumnName());
              bindingColumn.setDataType(newResultColumn.getDataType());
              ExpressionUtility.setBindingColumnExpression(newResultColumn,bindingColumn);
              bindingColumn.setDisplayName(UIUtil.getColumnDisplayName(newResultColumn));
              displayKey=UIUtil.getColumnDisplayNameKey(newResultColumn);
              if (displayKey != null)               bindingColumn.setDisplayNameID(displayKey);
              tableHandle.addColumnBinding(bindingColumn,false);
              int index=-1;
              if (target instanceof CellHandle) {
                CellHandle cellTarget=(CellHandle)target;
                CellHandleAdapter cellAdapter=HandleAdapterFactory.getInstance().getCellHandleAdapter(cellTarget);
                index=cellAdapter.getColumnNumber();
              }
              return addGroupHandle(tableHandle,newResultColumn,dataHandle,index - 1);
            }
          }
        }
        if (target instanceof CellHandle) {
          ComputedColumn column=StructureFactory.newComputedColumn(tableHandle,model.getColumnName());
          column.setDataType(model.getDataType());
          ExpressionUtility.setBindingColumnExpression(model,column);
          ComputedColumnHandle binding=DEUtil.addColumn(tableHandle,column,false);
          dataHandle.setResultSetColumn(binding.getName());
          InsertInLayoutRule rule=new LabelAddRule(target);
          if (rule.canInsert()) {
            LabelHandle label=DesignElementFactory.getInstance().newLabel(null);
            label.setText(UIUtil.getColumnDisplayName(model));
            rule.insert(label);
          }
          rule=new GroupKeySetRule(target,model);
          if (rule.canInsert()) {
            rule.insert(model);
          }
          return dataHandle;
        }
      }
 else       if (DesignChoiceConstants.ANALYSIS_TYPE_MEASURE.equals(UIUtil.getColumnAnalysis(model))) {
        CellHandle cellHandle=(CellHandle)target;
        ComputedColumn column=StructureFactory.newComputedColumn(tableHandle,model.getColumnName());
        ExpressionUtility.setBindingColumnExpression(model,column);
        column.setDataType(model.getDataType());
        ComputedColumnHandle binding=DEUtil.addColumn(tableHandle,column,false);
        DesignElementHandle group=cellHandle.getContainer().getContainer();
        if (group instanceof GroupHandle) {
          binding.setAggregateOn(((GroupHandle)group).getName());
        }
 else {
          binding.setAggregateOn(null);
        }
        if (DesignChoiceConstants.COLUMN_DATA_TYPE_INTEGER.equals(model.getDataType()) || DesignChoiceConstants.COLUMN_DATA_TYPE_FLOAT.equals(model.getDataType()) || DesignChoiceConstants.COLUMN_DATA_TYPE_DECIMAL.equals(model.getDataType())) {
          binding.setAggregateFunction(DesignChoiceConstants.MEASURE_FUNCTION_SUM);
        }
 else {
          binding.setAggregateFunction(DesignChoiceConstants.MEASURE_FUNCTION_MAX);
        }
        dataHandle.setResultSetColumn(binding.getName());
        InsertInLayoutRule rule=new LabelAddRule(target);
        if (rule.canInsert()) {
          LabelHandle label=DesignElementFactory.getInstance().newLabel(null);
          label.setText(UIUtil.getColumnDisplayName(model));
          rule.insert(label);
        }
        rule=new GroupKeySetRule(target,model);
        if (rule.canInsert()) {
          rule.insert(model);
        }
        return dataHandle;
      }
    }
  }
  dataHandle.setResultSetColumn(model.getColumnName());
  formatDataHandle(dataHandle,model);
  if (targetParent instanceof ReportItemHandle) {
    ReportItemHandle container=(ReportItemHandle)targetParent;
    ReportItemHandle root=DEUtil.getBindingRoot(container);
    if (root == null) {
      container=DEUtil.getListingContainer(container);
      if (container == null) {
        ComputedColumn bindingColumn=createBindingColumn(target,dataHandle,model);
        setDataSet(dataHandle,dataSet);
        dataHandle.addColumnBinding(bindingColumn,false);
      }
 else {
        ComputedColumn bindingColumn=createBindingColumn(target,container,model);
        setDataSet(container,dataSet);
        container.addColumnBinding(bindingColumn,false);
      }
    }
 else     if (root.getDataSet() == dataSet || (getAdapter() != null && root.getDataSet() != null && getAdapter().resolveExtendedData(root.getDataSet()).equals(getAdapter().resolveExtendedData(dataSet)))) {
      container=DEUtil.getBindingHolder(container);
      ComputedColumn bindingColumn=createBindingColumn(target,container,model);
      container.addColumnBinding(bindingColumn,false);
    }
 else {
      ReportItemHandle listingHandle=DEUtil.getListingContainer(container);
      if (listingHandle != null && DEUtil.getBindingRoot(listingHandle) == root && DEUtil.getBindingHolder(listingHandle) != listingHandle) {
        ComputedColumn bindingColumn=createBindingColumn(target,listingHandle,model);
        setDataSet(listingHandle,dataSet);
        listingHandle.addColumnBinding(bindingColumn,false);
      }
    }
  }
 else {
    ComputedColumn bindingColumn=StructureFactory.newComputedColumn(dataHandle,model.getColumnName());
    bindingColumn.setDataType(model.getDataType());
    ExpressionUtility.setBindingColumnExpression(model,bindingColumn);
    bindingColumn.setDisplayName(UIUtil.getColumnDisplayName(model));
    String displayKey=UIUtil.getColumnDisplayNameKey(model);
    if (displayKey != null)     bindingColumn.setDisplayNameID(displayKey);
    if (target instanceof DesignElementHandle) {
      if (ExpressionUtil.hasAggregation(bindingColumn.getExpression())) {
        String groupType=DEUtil.getGroupControlType((DesignElementHandle)target);
        if (groupType.equals(DEUtil.TYPE_GROUP_GROUP))         bindingColumn.setAggregateOn(((GroupHandle)DEUtil.getGroups((DesignElementHandle)target).get(0)).getName());
 else         if (groupType.equals(DEUtil.TYPE_GROUP_LISTING))         bindingColumn.setAggregateOn(null);
      }
    }
    dataHandle.addColumnBinding(bindingColumn,false);
    setDataSet(dataHandle,dataSet);
  }
  setDataItemAction(model,dataHandle);
  InsertInLayoutRule rule=new LabelAddRule(target);
  if (rule.canInsert()) {
    LabelHandle label=DesignElementFactory.getInstance().newLabel(null);
    label.setText(UIUtil.getHeadColumnDisplayName(model));
    String displayKey=UIUtil.getColumnHeaderDisplayNameKey(model);
    if (displayKey == null) {
      displayKey=UIUtil.getColumnDisplayNameKey(model);
    }
    if (displayKey != null) {
      label.setTextKey(displayKey);
    }
    rule.insert(label);
  }
  rule=new GroupKeySetRule(target,model);
  if (rule.canInsert()) {
    rule.insert(model);
  }
  return dataHandle;
}",0.9990317012587884
64909,"protected QueryDefinition constructQuery(DataSetHandle dataset,DataRequestSession session) throws BirtException {
  QueryDefinition query=super.constructQuery(dataset);
  PropertyHandle propertyHandle=dataset.getPropertyHandle(DataSetHandle.PARAMETERS_PROP);
  int paramsSize=propertyHandle.getListValue().size();
  Iterator paramIter=propertyHandle.iterator();
  for (int n=1; n <= paramsSize; n++) {
    DataSetParameterHandle paramDefn=(DataSetParameterHandle)paramIter.next();
    if (!paramDefn.isOutput())     continue;
    String bindingName=paramDefn.getName();
    IBinding binding=new Binding(bindingName);
    binding.setExpression(new ScriptExpression(PREFIX_OUTPUTPARAMETER + ""String_Node_Str"" + paramDefn.getName()+ ""String_Node_Str""));
    binding.setDataType(DataAdapterUtil.adaptModelDataType(paramDefn.getDataType()));
    query.addBinding(binding);
  }
  return query;
}","protected QueryDefinition constructQuery(DataSetHandle dataset,DataRequestSession session) throws BirtException {
  QueryDefinition query=super.constructQuery(dataset,session);
  query.getBindings().clear();
  PropertyHandle propertyHandle=dataset.getPropertyHandle(DataSetHandle.PARAMETERS_PROP);
  int paramsSize=propertyHandle.getListValue().size();
  Iterator paramIter=propertyHandle.iterator();
  for (int n=1; n <= paramsSize; n++) {
    DataSetParameterHandle paramDefn=(DataSetParameterHandle)paramIter.next();
    if (!paramDefn.isOutput())     continue;
    String bindingName=paramDefn.getName();
    IBinding binding=new Binding(bindingName);
    binding.setExpression(new ScriptExpression(PREFIX_OUTPUTPARAMETER + ""String_Node_Str"" + paramDefn.getName()+ ""String_Node_Str""));
    binding.setDataType(DataAdapterUtil.adaptModelDataType(paramDefn.getDataType()));
    query.addBinding(binding);
  }
  return query;
}",0.9785360484314805
64910,"protected void updateComputedColumn(Object structureOrHandle){
  if (structureOrHandle instanceof ComputedColumn) {
    try {
      computedColumns.addItem((ComputedColumn)structureOrHandle);
      viewer.getViewer().refresh();
    }
 catch (    SemanticException e) {
      ExceptionHandler.handle(e);
    }
  }
 else {
    viewer.getViewer().update(structureOrHandle,null);
  }
  if (validateAllComputedColumns())   getContainer().setMessage(Messages.getString(""String_Node_Str""),IMessageProvider.NONE);
}","protected void updateComputedColumn(Object structureOrHandle){
  if (structureOrHandle instanceof ComputedColumn) {
    try {
      computedColumns.addItem((ComputedColumn)structureOrHandle);
      viewer.getViewer().refresh();
    }
 catch (    SemanticException e) {
      ExceptionHandler.handle(e);
    }
  }
 else {
    viewer.getViewer().update(structureOrHandle,null);
  }
  if (validateAllComputedColumns())   getContainer().setMessage(Messages.getString(""String_Node_Str""),IMessageProvider.NONE);
  updateColumnCache();
}",0.9778206364513018
64911,"protected boolean isSpecifiedHeight(RowArea area){
  IContent content=(IContent)area.getContent();
  if (content != null) {
    return content.getHeight() != null;
  }
  return false;
}","protected boolean isSpecifiedHeight(RowArea area){
  IContent content=(IContent)area.getContent();
  if (content != null) {
    DimensionType cHeight=content.getHeight();
    if (cHeight != null && !cHeight.getUnits().equals(DimensionType.UNITS_PERCENTAGE)) {
      return true;
    }
  }
  return false;
}",0.6476578411405295
64912,"private void setUsesDetails(BaseQueryDefinition baseQuery){
  if (baseQuery instanceof QueryDefinition) {
    ((QueryDefinition)baseQuery).setIsSummaryQuery(true);
  }
  if (baseQuery != null && !baseQuery.cacheQueryResults()) {
    baseQuery.setUsesDetails(false);
  }
}","private void setUsesDetails(BaseQueryDefinition baseQuery){
  if (baseQuery instanceof QueryDefinition && !baseQuery.cacheQueryResults()) {
    ((QueryDefinition)baseQuery).setIsSummaryQuery(true);
  }
  if (baseQuery != null && !baseQuery.cacheQueryResults()) {
    baseQuery.setUsesDetails(false);
  }
}",0.9409722222222222
64913,"protected void updateComputedColumn(Object structureOrHandle){
  if (structureOrHandle instanceof ComputedColumn) {
    try {
      computedColumns.addItem((ComputedColumn)structureOrHandle);
      viewer.getViewer().refresh();
    }
 catch (    SemanticException e) {
      ExceptionHandler.handle(e);
    }
  }
 else {
    viewer.getViewer().update(structureOrHandle,null);
  }
  if (validateAllComputedColumns())   getContainer().setMessage(Messages.getString(""String_Node_Str""),IMessageProvider.NONE);
  updateColumnCache();
}","protected void updateComputedColumn(Object structureOrHandle){
  if (structureOrHandle instanceof ComputedColumn) {
    try {
      computedColumns.addItem((ComputedColumn)structureOrHandle);
      viewer.getViewer().refresh();
    }
 catch (    SemanticException e) {
      ExceptionHandler.handle(e);
    }
  }
 else {
    viewer.getViewer().update(structureOrHandle,null);
  }
  if (validateAllComputedColumns())   getContainer().setMessage(Messages.getString(""String_Node_Str""),IMessageProvider.NONE);
}",0.9778206364513018
64914,"public boolean hasNextChild(){
  if (currentElement < totalElements) {
    return true;
  }
  if (endOfListing) {
    return false;
  }
  try {
    while (!endOfListing) {
      int endGroup=rset.getEndingGroupLevel();
      if (endGroup <= 0) {
        ListingDesign listingDesign=(ListingDesign)getDesign();
        totalElements=0;
        currentElement=0;
        if (listingDesign.getFooter() != null) {
          executableElements[totalElements++]=listingDesign.getFooter();
        }
        endOfListing=true;
        return currentElement < totalElements;
      }
      if (rset.next()) {
        collectExecutableElements();
        if (currentElement < totalElements) {
          return true;
        }
      }
    }
  }
 catch (  BirtException ex) {
    context.addException(this.getDesign(),ex);
  }
  return false;
}","public boolean hasNextChild(){
  if (currentElement < totalElements) {
    return true;
  }
  if (endOfListing) {
    return false;
  }
  try {
    while (!endOfListing) {
      int endGroup=rset.getEndingGroupLevel();
      if (endGroup <= 0) {
        ListingDesign listingDesign=(ListingDesign)getDesign();
        totalElements=0;
        currentElement=0;
        if (listingDesign.getFooter() != null) {
          executableElements[totalElements++]=listingDesign.getFooter();
        }
        endOfListing=true;
        return currentElement < totalElements;
      }
      if (rset.next()) {
        collectExecutableElements();
        if (currentElement < totalElements) {
          return true;
        }
      }
 else {
        ListingDesign listingDesign=(ListingDesign)getDesign();
        totalElements=0;
        currentElement=0;
        if (listingDesign.getFooter() != null) {
          executableElements[totalElements++]=listingDesign.getFooter();
        }
        endOfListing=true;
        return currentElement < totalElements;
      }
    }
  }
 catch (  BirtException ex) {
    context.addException(this.getDesign(),ex);
  }
  return false;
}",0.8315842078960519
64915,"/** 
 * @param type
 * @return context
 * @throws BirtException
 */
protected DataEngineContext newContext(int type,String fileName,String fileName2) throws BirtException {
  boolean useFolder=useFolderArchive();
switch (type) {
case DataEngineContext.MODE_GENERATION:
{
      try {
        if (useFolder == true)         archiveWriter=new FolderArchiveWriter(fileName);
 else         archiveWriter=new FileArchiveWriter(fileName);
        archiveWriter.initialize();
      }
 catch (      IOException e) {
        throw new IllegalArgumentException(e.getMessage());
      }
      DataEngineContext context=DataEngineContext.newInstance(DataEngineContext.MODE_GENERATION,null,null,archiveWriter);
      context.setTmpdir(this.getTempDir());
      return context;
    }
case DataEngineContext.MODE_PRESENTATION:
{
    try {
      if (useFolder == true)       archiveReader=new FolderArchiveReader(fileName);
 else       archiveReader=new FileArchiveReader(fileName);
      archiveReader.open();
    }
 catch (    IOException e) {
      throw new IllegalArgumentException(e.getMessage());
    }
    DataEngineContext context=DataEngineContext.newInstance(DataEngineContext.MODE_PRESENTATION,null,archiveReader,null);
    context.setTmpdir(this.getTempDir());
    return context;
  }
case DataEngineContext.MODE_UPDATE:
{
  try {
    if (useFolder == true)     archiveReader=new FolderArchiveReader(fileName);
 else     archiveReader=new FileArchiveReader(fileName);
    archiveReader.open();
    if (useFolder == true)     archiveWriter=new FolderArchiveWriter(fileName2);
 else     archiveWriter=new FileArchiveWriter(fileName2);
    archiveWriter.initialize();
  }
 catch (  IOException e) {
    throw new IllegalArgumentException(e.getMessage());
  }
  DataEngineContext context=DataEngineContext.newInstance(DataEngineContext.MODE_UPDATE,null,archiveReader,archiveWriter);
  context.setTmpdir(this.getTempDir());
  return context;
}
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}","/** 
 * @param type
 * @return context
 * @throws BirtException
 */
protected DataEngineContext newContext(int type,String fileName,String fileName2) throws BirtException {
  boolean useFolder=useFolderArchive();
switch (type) {
case DataEngineContext.MODE_GENERATION:
{
      try {
        if (useFolder == true)         archiveWriter=new FolderArchiveWriter(fileName);
 else         archiveWriter=new FileArchiveWriter(fileName);
        archiveWriter.initialize();
      }
 catch (      IOException e) {
        throw new IllegalArgumentException(e.getMessage());
      }
      DataEngineContext context=DataEngineContext.newInstance(DataEngineContext.MODE_GENERATION,null,null,archiveWriter);
      context.setTmpdir(this.getTempDir());
      return context;
    }
case DataEngineContext.MODE_PRESENTATION:
{
    try {
      if (useFolder == true)       archiveReader=new FolderArchiveReader(fileName,true);
 else       archiveReader=new FileArchiveReader(fileName);
      archiveReader.open();
    }
 catch (    IOException e) {
      throw new IllegalArgumentException(e.getMessage());
    }
    DataEngineContext context=DataEngineContext.newInstance(DataEngineContext.MODE_PRESENTATION,null,archiveReader,null);
    context.setTmpdir(this.getTempDir());
    return context;
  }
case DataEngineContext.MODE_UPDATE:
{
  try {
    if (useFolder == true)     archiveReader=new FolderArchiveReader(fileName);
 else     archiveReader=new FileArchiveReader(fileName);
    archiveReader.open();
    if (useFolder == true)     archiveWriter=new FolderArchiveWriter(fileName2);
 else     archiveWriter=new FileArchiveWriter(fileName2);
    archiveWriter.initialize();
  }
 catch (  IOException e) {
    throw new IllegalArgumentException(e.getMessage());
  }
  DataEngineContext context=DataEngineContext.newInstance(DataEngineContext.MODE_UPDATE,null,archiveReader,archiveWriter);
  context.setTmpdir(this.getTempDir());
  return context;
}
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}",0.9987577639751553
64916,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(org.eclipse.birt.core.archive.ArchiveFileCacheTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.ArchiveFileSaveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.ArchiveFlushTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.ArchiveUtilTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.DocArchiveLockManagerTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.DocumentArchiveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.FileArchiveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.FolderArchiveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.InputStreamRefreshTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveEntryInputStreamTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveFileFactoryTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveFileTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchivePerformanceTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveRemoveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveViewTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.UpgradeArchiveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.BTreeCursorTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.BTreeMultipleThreadTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.BTreeTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.NodeInputStreamTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.NodeOutputStreamTest.class);
  suite.addTestSuite(org.eclipse.birt.core.config.FileConfigVarManagerTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.DataTypeUtilTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.DateUtilTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.DateUtilThreadTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.ExpressionParserUtilityTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.ExpressionUtilTest.class);
  suite.addTestSuite(org.eclipse.birt.core.exception.BirtExceptionTest.class);
  suite.addTestSuite(org.eclipse.birt.core.format.DateFormatterTest.class);
  suite.addTestSuite(org.eclipse.birt.core.format.NumberFormatterTest.class);
  suite.addTestSuite(org.eclipse.birt.core.format.StringFormatterTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtCompTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtDateTimeTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtDurationTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtMathTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtStrTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.NativeDateTimeSpanTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.NativeFinanceTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.NativeJavaMapTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.NativeNamedListTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.ScriptableParametersTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.ScriptContextTest.class);
  suite.addTestSuite(TemplateParserTest.class);
  suite.addTestSuite(org.eclipse.birt.core.util.IOUtilTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(org.eclipse.birt.core.archive.ArchiveFileCacheTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.ArchiveFileSaveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.ArchiveUtilTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.DocumentArchiveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.FileArchiveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.FolderArchiveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.InputStreamRefreshTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveEntryInputStreamTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveFileFactoryTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveFileTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveRemoveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.ArchiveViewTest.class);
  suite.addTestSuite(org.eclipse.birt.core.archive.compound.UpgradeArchiveTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.BTreeCursorTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.BTreeMultipleThreadTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.BTreeTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.NodeInputStreamTest.class);
  suite.addTestSuite(org.eclipse.birt.core.btree.NodeOutputStreamTest.class);
  suite.addTestSuite(org.eclipse.birt.core.config.FileConfigVarManagerTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.DataTypeUtilTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.DateUtilTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.DateUtilThreadTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.ExpressionParserUtilityTest.class);
  suite.addTestSuite(org.eclipse.birt.core.data.ExpressionUtilTest.class);
  suite.addTestSuite(org.eclipse.birt.core.exception.BirtExceptionTest.class);
  suite.addTestSuite(org.eclipse.birt.core.format.DateFormatterTest.class);
  suite.addTestSuite(org.eclipse.birt.core.format.NumberFormatterTest.class);
  suite.addTestSuite(org.eclipse.birt.core.format.StringFormatterTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtCompTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtDateTimeTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtDurationTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtMathTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.bre.BirtStrTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.NativeDateTimeSpanTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.NativeFinanceTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.NativeJavaMapTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.NativeNamedListTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.ScriptableParametersTest.class);
  suite.addTestSuite(org.eclipse.birt.core.script.ScriptContextTest.class);
  suite.addTestSuite(TemplateParserTest.class);
  suite.addTestSuite(org.eclipse.birt.core.util.IOUtilTest.class);
  return suite;
}",0.9630606860158312
64917,"protected ArchiveFile createArchiveFile(String name) throws IOException {
  ArchiveFile af=new ArchiveFile(name,""String_Node_Str"");
  af.setCacheSize(4096 * 10);
  for (int i=0; i < 1000; i++) {
    ArchiveEntry entry=af.createEntry(""String_Node_Str"" + i);
    long position=0;
    ByteArrayOutputStream buffer=new ByteArrayOutputStream();
    DataOutputStream output=new DataOutputStream(buffer);
    output.writeUTF(""String_Node_Str"" + i + ""String_Node_Str"");
    byte[] bytes=buffer.toByteArray();
    for (int j=0; j < 4096; j++) {
      entry.write(position,bytes,0,bytes.length);
      position+=bytes.length;
    }
    entry.close();
  }
  return af;
}","protected ArchiveFile createArchiveFile(String name) throws IOException {
  ArchiveFile af=new ArchiveFile(name,""String_Node_Str"");
  af.setCacheSize(4096 * 10);
  for (int i=0; i < 100; i++) {
    ArchiveEntry entry=af.createEntry(""String_Node_Str"" + i);
    long position=0;
    ByteArrayOutputStream buffer=new ByteArrayOutputStream();
    DataOutputStream output=new DataOutputStream(buffer);
    output.writeUTF(""String_Node_Str"" + i + ""String_Node_Str"");
    byte[] bytes=buffer.toByteArray();
    for (int j=0; j < 4096; j++) {
      entry.write(position,bytes,0,bytes.length);
      position+=bytes.length;
    }
    entry.close();
  }
  return af;
}",0.9992406985573272
64918,"/** 
 * Set the error message to the wizard dialog.
 * @param t Exception
 */
public void showErrors(String errorMessage){
  this.errorMessage=errorMessage;
  if (wizard.getDialog().getShell() == null || wizard.getDialog().getShell().isDisposed()) {
    return;
  }
  wizard.getDialog().setErrorMessage(errorMessage);
}","/** 
 * Set the error message to the wizard dialog.
 * @param t Exception
 */
public void showErrors(String errorMessage){
  this.errorMessage=errorMessage;
  if (wizard.getDialog().getShell() == null || wizard.getDialog().getShell().isDisposed()) {
    return;
  }
  wizard.getDialog().setErrorMessage(addLineSeparator(wizard.getDialog().getShell(),errorMessage));
}",0.8950437317784257
64919,"/** 
 * Read an int value from an input stream
 * @param inputStream
 * @return int value
 * @throws IOException
 */
public final static int readInt(InputStream inputStream) throws IOException {
  int ch1=inputStream.read();
  int ch2=inputStream.read();
  int ch3=inputStream.read();
  int ch4=inputStream.read();
  return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8)+ (ch4 << 0));
}","/** 
 * Read an int value from an input stream
 * @param inputStream
 * @return int value
 * @throws IOException
 */
public final static int readInt(InputStream inputStream) throws IOException {
  int ch1=inputStream.read();
  int ch2=inputStream.read();
  int ch3=inputStream.read();
  int ch4=inputStream.read();
  if (ch1 == -1 || ch2 == -1 || ch3 == -1 || ch4 == -1) {
    throw new EOFException();
  }
  return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8)+ (ch4 << 0));
}",0.8917647058823529
64920,"/** 
 * Read a bool value from an input stream
 * @param inputStream
 * @return boolean value
 * @throws IOException
 */
public final static boolean readBool(InputStream inputStream) throws IOException {
  return inputStream.read() == 0 ? false : true;
}","/** 
 * Read a bool value from an input stream
 * @param inputStream
 * @return boolean value
 * @throws IOException
 */
public final static boolean readBool(InputStream inputStream) throws IOException {
  int v=inputStream.read();
  if (v == -1) {
    throw new EOFException();
  }
  return v == 0 ? false : true;
}",0.8666666666666667
64921,"/** 
 * Read an int value from an input stream
 * @param inputStream
 * @return int value
 * @throws IOException
 */
public final static short readShort(InputStream inputStream) throws IOException {
  int ch1=inputStream.read();
  int ch2=inputStream.read();
  return (short)((ch1 << 8) + ch2);
}","/** 
 * Read an int value from an input stream
 * @param inputStream
 * @return int value
 * @throws IOException
 */
public final static short readShort(InputStream inputStream) throws IOException {
  int ch1=inputStream.read();
  int ch2=inputStream.read();
  if (ch1 == -1 || ch2 == -1) {
    throw new EOFException();
  }
  return (short)((ch1 << 8) + ch2);
}",0.8996960486322189
64922,"protected QueryDefinition constructQuery(DataSetHandle dataset,DataRequestSession session) throws BirtException {
  QueryDefinition query=super.constructQuery(dataset);
  query.getBindings().clear();
  PropertyHandle propertyHandle=dataset.getPropertyHandle(DataSetHandle.PARAMETERS_PROP);
  int paramsSize=propertyHandle.getListValue().size();
  Iterator paramIter=propertyHandle.iterator();
  for (int n=1; n <= paramsSize; n++) {
    DataSetParameterHandle paramDefn=(DataSetParameterHandle)paramIter.next();
    if (!paramDefn.isOutput())     continue;
    String bindingName=paramDefn.getName();
    IBinding binding=new Binding(bindingName);
    binding.setExpression(new ScriptExpression(PREFIX_OUTPUTPARAMETER + ""String_Node_Str"" + paramDefn.getName()+ ""String_Node_Str""));
    binding.setDataType(DataAdapterUtil.adaptModelDataType(paramDefn.getDataType()));
    query.addBinding(binding);
  }
  return query;
}","protected QueryDefinition constructQuery(DataSetHandle dataset,DataRequestSession session) throws BirtException {
  QueryDefinition query=super.constructQuery(dataset,session);
  PropertyHandle propertyHandle=dataset.getPropertyHandle(DataSetHandle.PARAMETERS_PROP);
  int paramsSize=propertyHandle.getListValue().size();
  Iterator paramIter=propertyHandle.iterator();
  for (int n=1; n <= paramsSize; n++) {
    DataSetParameterHandle paramDefn=(DataSetParameterHandle)paramIter.next();
    if (!paramDefn.isOutput())     continue;
    String bindingName=paramDefn.getName();
    IBinding binding=new Binding(bindingName);
    binding.setExpression(new ScriptExpression(PREFIX_OUTPUTPARAMETER + ""String_Node_Str"" + paramDefn.getName()+ ""String_Node_Str""));
    binding.setDataType(DataAdapterUtil.adaptModelDataType(paramDefn.getDataType()));
    query.addBinding(binding);
  }
  return query;
}",0.9785360484314805
64923,"public void onPage(long page,Object pageContext){
  if (pageContext instanceof HTMLLayoutContext) {
    context.firePageBreakEvent(((HTMLLayoutContext)pageContext).isHorizontalPageBreak());
  }
 else {
    context.firePageBreakEvent(false);
  }
}","public void onPage(long page,Object pageContext){
  if (pageContext instanceof HTMLLayoutContext) {
    context.firePageBreakEvent(((HTMLLayoutContext)pageContext).isHorizontalPageBreak(),false);
  }
 else {
    context.firePageBreakEvent(false,true);
  }
}",0.978131212723658
64924,"/** 
 * Notify page break listeners that page is broken.
 */
public void firePageBreakEvent(boolean isHorizontalPageBreak){
  if (pageBreakListeners != null) {
    for (int i=0; i < pageBreakListeners.size(); i++) {
      ((IPageBreakListener)pageBreakListeners.get(i)).onPageBreak(isHorizontalPageBreak);
    }
  }
}","/** 
 * Notify page break listeners that page is broken.
 */
public void firePageBreakEvent(boolean isHorizontalPageBreak,boolean isFixedLayoutPageBreak){
  if (pageBreakListeners != null) {
    for (int i=0; i < pageBreakListeners.size(); i++) {
      ((IPageBreakListener)pageBreakListeners.get(i)).onPageBreak(isHorizontalPageBreak,isFixedLayoutPageBreak);
    }
  }
}",0.9215116279069768
64925,"/** 
 * Handler to preocess page break before event.
 */
void onPageBreak(boolean isHorizontalPageBreak);","/** 
 * Handler to preocess page break before event.
 */
void onPageBreak(boolean isHorizontalPageBreak,boolean isFixedLayoutPageBreak);",0.8713692946058091
64926,"public void onPageBreak(boolean isHorizontalPageBreak){
  if (!isHorizontalPageBreak) {
    pageRowCount=0;
    if (addAfterBreak) {
      next();
      addAfterBreak=false;
    }
 else {
      if (softBreakBefore) {
        softBreakBefore=false;
      }
    }
  }
}","public void onPageBreak(boolean isHorizontalPageBreak,boolean isFixedlayoutPageBreak){
  if (!isHorizontalPageBreak) {
    pageRowCount=0;
    if (addAfterBreak) {
      next();
      addAfterBreak=false;
    }
 else     if (isFixedlayoutPageBreak) {
      next();
    }
 else {
      if (softBreakBefore) {
        softBreakBefore=false;
      }
    }
  }
}",0.8544
64927,"protected void okPressed(){
  try {
    ComputedColumnHandle newBindingColumn=null;
    if (bindingColumn != null) {
      if (dialogHelper.differs(bindingColumn)) {
        if (isNeedPrompt() && isBindingMultipleReferenced()) {
          MessageDialog dialog=new MessageDialog(UIUtil.getDefaultShell(),Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),MessageDialog.QUESTION,new String[]{Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str"")},0);
          int dialogClick=dialog.open();
          if (dialogClick == 0) {
            InputDialog inputDialog=new InputDialog(UIUtil.getDefaultShell(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),""String_Node_Str"",new IInputValidator(){
              public String isValid(              String newText){
                for (Iterator iterator=DEUtil.getBindingHolder(bindingObject).getColumnBindings().iterator(); iterator.hasNext(); ) {
                  ComputedColumnHandle computedColumn=(ComputedColumnHandle)iterator.next();
                  if (computedColumn.getName().equals(newText)) {
                    return Messages.getFormattedString(""String_Node_Str"",new Object[]{newText});
                  }
                }
                return null;
              }
            }
);
            if (inputDialog.open() == Window.OK) {
              bindingColumn=dialogHelper.newBinding(DEUtil.getBindingHolder(bindingObject),inputDialog.getValue());
              super.okPressed();
              return;
            }
 else {
              return;
            }
          }
 else           if (dialogClick == 2) {
            return;
          }
        }
        if (!dialogHelper.canProcessWithWarning())         return;
        bindingColumn=dialogHelper.editBinding(bindingColumn);
      }
    }
 else {
      if (!dialogHelper.canProcessWithWarning())       return;
      if (bindSelf)       bindingColumn=dialogHelper.newBinding(bindingObject,null);
 else       bindingColumn=dialogHelper.newBinding(DEUtil.getBindingHolder(bindingObject),null);
      newBindingColumn=bindingColumn;
    }
    if (ExtendedDataModelUIAdapterHelper.isBoundToExtendedData(DEUtil.getBindingHolder(bindingObject))) {
      DataModelAdapterStatus status=DataModelAdapterUtil.validateRelativeTimePeriod(DEUtil.getBindingHolder(bindingObject),bindingColumn);
      if (status.getStatus() == DataModelAdapterStatus.Status.FAIL) {
        MessageDialog.openError(UIUtil.getDefaultShell(),null,status.getMessage());
        removeColumnBinding(newBindingColumn);
        return;
      }
    }
    if (ExtendedDataModelUIAdapterHelper.isBoundToExtendedData(DEUtil.getBindingHolder(bindingObject))) {
      IStatus status=DataModelAdapterUtil.validateRelativeTimePeriod(DEUtil.getBindingHolder(bindingObject),bindingColumn);
      if (status.getSeverity() == IStatus.ERROR) {
        MessageDialog.openError(UIUtil.getDefaultShell(),null,status.getMessage());
        return;
      }
    }
    super.okPressed();
  }
 catch (  Exception e) {
    ExceptionHandler.handle(e);
  }
}","protected void okPressed(){
  try {
    ComputedColumnHandle newBindingColumn=null;
    if (bindingColumn != null) {
      if (dialogHelper.differs(bindingColumn)) {
        if (isNeedPrompt() && isBindingMultipleReferenced()) {
          MessageDialog dialog=new MessageDialog(UIUtil.getDefaultShell(),Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),MessageDialog.QUESTION,new String[]{Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str"")},0);
          int dialogClick=dialog.open();
          if (dialogClick == 0) {
            InputDialog inputDialog=new InputDialog(UIUtil.getDefaultShell(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),""String_Node_Str"",new IInputValidator(){
              public String isValid(              String newText){
                for (Iterator iterator=DEUtil.getBindingHolder(bindingObject).getColumnBindings().iterator(); iterator.hasNext(); ) {
                  ComputedColumnHandle computedColumn=(ComputedColumnHandle)iterator.next();
                  if (computedColumn.getName().equals(newText)) {
                    return Messages.getFormattedString(""String_Node_Str"",new Object[]{newText});
                  }
                }
                return null;
              }
            }
);
            if (inputDialog.open() == Window.OK) {
              bindingColumn=dialogHelper.newBinding(DEUtil.getBindingHolder(bindingObject),inputDialog.getValue());
              super.okPressed();
              return;
            }
 else {
              return;
            }
          }
 else           if (dialogClick == 2) {
            return;
          }
        }
        if (!dialogHelper.canProcessWithWarning())         return;
        bindingColumn=dialogHelper.editBinding(bindingColumn);
      }
    }
 else {
      if (!dialogHelper.canProcessWithWarning())       return;
      if (bindSelf)       bindingColumn=dialogHelper.newBinding(bindingObject,null);
 else       bindingColumn=dialogHelper.newBinding(DEUtil.getBindingHolder(bindingObject),null);
      newBindingColumn=bindingColumn;
    }
    if (ExtendedDataModelUIAdapterHelper.isBoundToExtendedData(DEUtil.getBindingHolder(bindingObject))) {
      DataModelAdapterStatus status=DataModelAdapterUtil.validateRelativeTimePeriod(DEUtil.getBindingHolder(bindingObject),bindingColumn);
      if (status.getStatus() == DataModelAdapterStatus.Status.FAIL) {
        MessageDialog.openError(UIUtil.getDefaultShell(),null,status.getMessage());
        removeColumnBinding(newBindingColumn);
        return;
      }
    }
    if (ExtendedDataModelUIAdapterHelper.isBoundToExtendedData(DEUtil.getBindingHolder(bindingObject))) {
      DataModelAdapterStatus status=DataModelAdapterUtil.validateRelativeTimePeriod(DEUtil.getBindingHolder(bindingObject),bindingColumn);
      if (status.getStatus() == DataModelAdapterStatus.Status.FAIL) {
        MessageDialog.openError(UIUtil.getDefaultShell(),null,status.getMessage());
        return;
      }
    }
    super.okPressed();
  }
 catch (  Exception e) {
    ExceptionHandler.handle(e);
  }
}",0.988276299112801
64928,"protected void okPressed(){
  if (canSelect) {
    setResult(selectedColumnName);
    if (inputElement instanceof DataItemHandle) {
      try {
        ((DataItemHandle)inputElement).setResultSetColumn(selectedColumnName);
      }
 catch (      SemanticException e) {
        ExceptionHandler.handle(e);
      }
    }
  }
  if (ExtendedDataModelUIAdapterHelper.isBoundToExtendedData(inputElement)) {
    IStatus status=DataModelAdapterUtil.validateRelativeTimePeriod(inputElement,getSelectColumnHandle());
    if (status.getSeverity() == IStatus.ERROR) {
      MessageDialog.openError(UIUtil.getDefaultShell(),null,status.getMessage());
      return;
    }
  }
  super.okPressed();
}","protected void okPressed(){
  if (canSelect) {
    setResult(selectedColumnName);
    if (inputElement instanceof DataItemHandle) {
      try {
        ((DataItemHandle)inputElement).setResultSetColumn(selectedColumnName);
      }
 catch (      SemanticException e) {
        ExceptionHandler.handle(e);
      }
    }
  }
  if (ExtendedDataModelUIAdapterHelper.isBoundToExtendedData(inputElement)) {
    DataModelAdapterStatus status=DataModelAdapterUtil.validateRelativeTimePeriod(inputElement,getSelectColumnHandle());
    if (status.getStatus() == DataModelAdapterStatus.Status.FAIL) {
      MessageDialog.openError(UIUtil.getDefaultShell(),null,status.getMessage());
      return;
    }
  }
  super.okPressed();
}",0.9471428571428572
64929,"public static List<String> getColumnNames(DataSetHandle dataset){
  CachedMetaDataHandle cachedMetaDataHandle=dataset.getCachedMetaDataHandle();
  if (cachedMetaDataHandle != null) {
    List<ResultSetColumn> resultSetColumns=(List<ResultSetColumn>)cachedMetaDataHandle.getProperty(CachedMetaData.RESULT_SET_MEMBER);
    ArrayList<String> columnNames=new ArrayList<String>();
    for (    ResultSetColumn column : resultSetColumns) {
      String columnName=column.getColumnName();
      columnNames.add(columnName);
    }
    return columnNames;
  }
  return Collections.EMPTY_LIST;
}","@SuppressWarnings(""String_Node_Str"") public static List<String> getColumnNames(DataSetHandle dataset){
  CachedMetaDataHandle cachedMetaDataHandle=dataset.getCachedMetaDataHandle();
  if (cachedMetaDataHandle != null) {
    List<ResultSetColumn> resultSetColumns=(List<ResultSetColumn>)cachedMetaDataHandle.getProperty(CachedMetaData.RESULT_SET_MEMBER);
    if (resultSetColumns == null) {
      return Collections.EMPTY_LIST;
    }
    ArrayList<String> columnNames=new ArrayList<String>();
    for (    ResultSetColumn column : resultSetColumns) {
      String columnName=column.getColumnName();
      columnNames.add(columnName);
    }
    return columnNames;
  }
  return Collections.EMPTY_LIST;
}",0.5660964230171073
64930,"/** 
 * Creates a PdfAction.
 * @param hyperlink the hyperlink.
 * @param bookmark the bookmark.
 * @param target if target equals ""_blank"", the target will be opened in a new window, else the target will be opened in the current window.
 * @return the created PdfAction.
 */
private PdfAction createPdfAction(String hyperlink,String bookmark,String target,int type){
  if (""String_Node_Str"".equalsIgnoreCase(target) || ""String_Node_Str"".equalsIgnoreCase(target) || ""String_Node_Str"".equalsIgnoreCase(target)|| ""String_Node_Str"".equalsIgnoreCase(target)) {
    boolean isUrl=hyperlink.startsWith(""String_Node_Str"");
    if (!isUrl) {
      Matcher matcher=PAGE_LINK_PATTERN.matcher(hyperlink);
      if (matcher.find()) {
        String fileName=matcher.group(1);
        String pageNumber=matcher.group(matcher.groupCount());
        return new PdfAction(fileName,Integer.valueOf(pageNumber));
      }
    }
    return new PdfAction(hyperlink);
  }
 else {
    if (type == IHyperlinkAction.ACTION_BOOKMARK) {
      return PdfAction.gotoLocalPage(bookmark,false);
    }
 else {
      return PdfAction.gotoRemotePage(hyperlink,bookmark,false,false);
    }
  }
}","/** 
 * Creates a PdfAction.
 * @param hyperlink the hyperlink.
 * @param bookmark the bookmark.
 * @param target if target equals ""_blank"", the target will be opened in a new window, else the target will be opened in the current window.
 * @return the created PdfAction.
 */
private PdfAction createPdfAction(String hyperlink,String bookmark,String target,int type){
  if (""String_Node_Str"".equalsIgnoreCase(target) || ""String_Node_Str"".equalsIgnoreCase(target) || ""String_Node_Str"".equalsIgnoreCase(target)|| ""String_Node_Str"".equalsIgnoreCase(target)) {
    if (hyperlink == null)     hyperlink=""String_Node_Str"";
    boolean isUrl=hyperlink.startsWith(""String_Node_Str"");
    if (!isUrl) {
      Matcher matcher=PAGE_LINK_PATTERN.matcher(hyperlink);
      if (matcher.find()) {
        String fileName=matcher.group(1);
        String pageNumber=matcher.group(matcher.groupCount());
        return new PdfAction(fileName,Integer.valueOf(pageNumber));
      }
    }
    return new PdfAction(hyperlink);
  }
 else {
    if (type == IHyperlinkAction.ACTION_BOOKMARK) {
      return PdfAction.gotoLocalPage(bookmark,false);
    }
 else {
      return PdfAction.gotoRemotePage(hyperlink,bookmark,false,false);
    }
  }
}",0.9747899159663864
64931,"/** 
 * Supports the obsolete setValueExpr() method.
 * @throws Exception
 */
public void testDataValueExpr() throws Exception {
  createDesign();
  DataItemHandle data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  designHandle.getBody().add(data);
  data.setValueExpr(""String_Node_Str"");
  TableHandle table=designHandle.getElementFactory().newTableItem(""String_Node_Str"",2);
  data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  data.setValueExpr(""String_Node_Str"");
  table.getCell(TableHandle.HEADER_SLOT,-1,1,1).getContent().add(data);
  designHandle.getBody().add(table);
  save();
  assertTrue(compareFile(""String_Node_Str""));
}","/** 
 * Supports the obsolete setValueExpr() method.
 * @throws IOException 
 * @throws Exception
 */
public void testDataValueExpr() throws Exception {
  createDesign();
  DataItemHandle data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  designHandle.getBody().add(data);
  data.setValueExpr(""String_Node_Str"");
  TableHandle table=designHandle.getElementFactory().newTableItem(""String_Node_Str"",2);
  data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  data.setValueExpr(""String_Node_Str"");
  table.getCell(TableHandle.HEADER_SLOT,-1,1,1).getContent().add(data);
  designHandle.getBody().add(table);
  save();
  assertTrue(compareDesignModel(""String_Node_Str"",new String[]{""String_Node_Str""}));
}",0.9441696113074204
64932,"/** 
 * Supports the misc setting expression methods.
 * @throws Exception
 */
public void testBoundColumnWriterNoExpression() throws Exception {
  createDesign();
  design.getVersionManager().setVersion(""String_Node_Str"");
  DataItemHandle data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  data.setTocExpression(""String_Node_Str"");
  data.setValueExpr(""String_Node_Str"");
  TableHandle table=designHandle.getElementFactory().newTableItem(""String_Node_Str"",2);
  table.getCell(TableHandle.HEADER_SLOT,-1,1,1).getContent().add(data);
  designHandle.getBody().add(table);
  FilterCondition filter=new FilterCondition();
  filter.setExpr(""String_Node_Str"");
  filter.setValue1(""String_Node_Str"");
  filter.setValue2(""String_Node_Str"");
  table.getPropertyHandle(ListHandle.FILTER_PROP).addItem(filter);
  save();
  assertTrue(compareFile(""String_Node_Str""));
}","/** 
 * Supports the misc setting expression methods.
 * @throws Exception
 */
public void testBoundColumnWriterNoExpression() throws Exception {
  createDesign();
  design.getVersionManager().setVersion(""String_Node_Str"");
  DataItemHandle data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  data.setTocExpression(""String_Node_Str"");
  data.setValueExpr(""String_Node_Str"");
  TableHandle table=designHandle.getElementFactory().newTableItem(""String_Node_Str"",2);
  table.getCell(TableHandle.HEADER_SLOT,-1,1,1).getContent().add(data);
  designHandle.getBody().add(table);
  FilterCondition filter=new FilterCondition();
  filter.setExpr(""String_Node_Str"");
  filter.setValue1(""String_Node_Str"");
  filter.setValue2(""String_Node_Str"");
  table.getPropertyHandle(ListHandle.FILTER_PROP).addItem(filter);
  save();
  assertTrue(compareDesignModel(""String_Node_Str"",new String[]{""String_Node_Str""}));
}",0.9493600445186422
64933,"/** 
 * Supports the misc setting expression methods.
 * @throws Exception
 */
public void testBoundColumnWriterExpression() throws Exception {
  createDesign();
  DataItemHandle data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  designHandle.getBody().add(data);
  Action action=new Action();
  data.setAction(action);
  ActionHandle actionHandle=data.getActionHandle();
  actionHandle.setLinkType(DesignChoiceConstants.ACTION_LINK_TYPE_BOOKMARK_LINK);
  actionHandle.setTargetBookmark(""String_Node_Str"");
  TableHandle table=designHandle.getElementFactory().newTableItem(""String_Node_Str"",2);
  ImageHandle image=designHandle.getElementFactory().newImage(""String_Node_Str"");
  image.setBookmark(""String_Node_Str"");
  image.setValueExpression(""String_Node_Str"");
  table.getCell(TableHandle.HEADER_SLOT,-1,1,1).getContent().add(image);
  TableHandle nestedTable=designHandle.getElementFactory().newTableItem(""String_Node_Str"",2);
  ParamBinding paramBinding=new ParamBinding();
  paramBinding.setParamName(""String_Node_Str"");
  paramBinding.setExpression(""String_Node_Str"");
  nestedTable.getPropertyHandle(TableHandle.PARAM_BINDINGS_PROP).addItem(paramBinding);
  ColumnHandle column=(ColumnHandle)nestedTable.getColumns().get(0);
  HideRule hideRule=new HideRule();
  hideRule.setExpression(""String_Node_Str"");
  hideRule.setFormat(DesignChoiceConstants.FORMAT_TYPE_REPORTLET);
  column.getPropertyHandle(ColumnHandle.VISIBILITY_PROP).addItem(hideRule);
  table.getCell(TableHandle.DETAIL_SLOT,-1,1,2).getContent().add(nestedTable);
  designHandle.getBody().add(table);
  TextDataHandle textData=designHandle.getElementFactory().newTextData(""String_Node_Str"");
  textData.setValueExpr(""String_Node_Str"");
  GridHandle grid=designHandle.getElementFactory().newGridItem(""String_Node_Str"",2,2);
  grid.getCell(2,2).getContent().add(textData);
  table.getCell(TableHandle.FOOTER_SLOT,-1,1,1).getContent().add(grid);
  table.getCell(TableHandle.FOOTER_SLOT,-1,1,1).setOnCreate(""String_Node_Str"");
  ListHandle list=designHandle.getElementFactory().newList(""String_Node_Str"");
  FilterCondition filter=new FilterCondition();
  filter.setExpr(""String_Node_Str"");
  filter.setValue1(""String_Node_Str"");
  filter.setValue2(""String_Node_Str"");
  list.getPropertyHandle(ListHandle.FILTER_PROP).addItem(filter);
  SortKey sort=new SortKey();
  sort.setKey(""String_Node_Str"");
  list.getPropertyHandle(ListHandle.SORT_PROP).addItem(sort);
  designHandle.getBody().add(list);
  ScalarParameterHandle param=designHandle.getElementFactory().newScalarParameter(""String_Node_Str"");
  param.setValueExpr(""String_Node_Str"");
  param.setLabelExpr(""String_Node_Str"");
  designHandle.getParameters().add(param);
  param=designHandle.getElementFactory().newScalarParameter(""String_Node_Str"");
  param.setValueExpr(""String_Node_Str"");
  param.setLabelExpr(""String_Node_Str"");
  designHandle.getParameters().add(param);
  textData=designHandle.getElementFactory().newTextData(""String_Node_Str"");
  designHandle.getBody().add(textData);
  ComputedColumn boundColumn=new ComputedColumn();
  boundColumn.setName(""String_Node_Str"");
  boundColumn.setExpression(""String_Node_Str"");
  textData.addColumnBinding(boundColumn,true);
  textData.setValueExpr(""String_Node_Str"");
  save();
  assertTrue(compareFile(""String_Node_Str""));
}","/** 
 * Supports the misc setting expression methods.
 * @throws Exception
 */
public void testBoundColumnWriterExpression() throws Exception {
  createDesign();
  DataItemHandle data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  designHandle.getBody().add(data);
  Action action=new Action();
  data.setAction(action);
  ActionHandle actionHandle=data.getActionHandle();
  actionHandle.setLinkType(DesignChoiceConstants.ACTION_LINK_TYPE_BOOKMARK_LINK);
  actionHandle.setTargetBookmark(""String_Node_Str"");
  TableHandle table=designHandle.getElementFactory().newTableItem(""String_Node_Str"",2);
  ImageHandle image=designHandle.getElementFactory().newImage(""String_Node_Str"");
  image.setBookmark(""String_Node_Str"");
  image.setValueExpression(""String_Node_Str"");
  table.getCell(TableHandle.HEADER_SLOT,-1,1,1).getContent().add(image);
  TableHandle nestedTable=designHandle.getElementFactory().newTableItem(""String_Node_Str"",2);
  ParamBinding paramBinding=new ParamBinding();
  paramBinding.setParamName(""String_Node_Str"");
  paramBinding.setExpression(""String_Node_Str"");
  nestedTable.getPropertyHandle(TableHandle.PARAM_BINDINGS_PROP).addItem(paramBinding);
  ColumnHandle column=(ColumnHandle)nestedTable.getColumns().get(0);
  HideRule hideRule=new HideRule();
  hideRule.setExpression(""String_Node_Str"");
  hideRule.setFormat(DesignChoiceConstants.FORMAT_TYPE_REPORTLET);
  column.getPropertyHandle(ColumnHandle.VISIBILITY_PROP).addItem(hideRule);
  table.getCell(TableHandle.DETAIL_SLOT,-1,1,2).getContent().add(nestedTable);
  designHandle.getBody().add(table);
  TextDataHandle textData=designHandle.getElementFactory().newTextData(""String_Node_Str"");
  textData.setValueExpr(""String_Node_Str"");
  GridHandle grid=designHandle.getElementFactory().newGridItem(""String_Node_Str"",2,2);
  grid.getCell(2,2).getContent().add(textData);
  table.getCell(TableHandle.FOOTER_SLOT,-1,1,1).getContent().add(grid);
  table.getCell(TableHandle.FOOTER_SLOT,-1,1,1).setOnCreate(""String_Node_Str"");
  ListHandle list=designHandle.getElementFactory().newList(""String_Node_Str"");
  FilterCondition filter=new FilterCondition();
  filter.setExpr(""String_Node_Str"");
  filter.setValue1(""String_Node_Str"");
  filter.setValue2(""String_Node_Str"");
  list.getPropertyHandle(ListHandle.FILTER_PROP).addItem(filter);
  SortKey sort=new SortKey();
  sort.setKey(""String_Node_Str"");
  list.getPropertyHandle(ListHandle.SORT_PROP).addItem(sort);
  designHandle.getBody().add(list);
  ScalarParameterHandle param=designHandle.getElementFactory().newScalarParameter(""String_Node_Str"");
  param.setValueExpr(""String_Node_Str"");
  param.setLabelExpr(""String_Node_Str"");
  designHandle.getParameters().add(param);
  param=designHandle.getElementFactory().newScalarParameter(""String_Node_Str"");
  param.setValueExpr(""String_Node_Str"");
  param.setLabelExpr(""String_Node_Str"");
  designHandle.getParameters().add(param);
  textData=designHandle.getElementFactory().newTextData(""String_Node_Str"");
  designHandle.getBody().add(textData);
  ComputedColumn boundColumn=new ComputedColumn();
  boundColumn.setName(""String_Node_Str"");
  boundColumn.setExpression(""String_Node_Str"");
  textData.addColumnBinding(boundColumn,true);
  textData.setValueExpr(""String_Node_Str"");
  save();
  assertTrue(compareDesignModel(""String_Node_Str"",new String[]{""String_Node_Str""}));
}",0.9863874345549738
64934,"/** 
 * Supports the misc setting expression methods.
 * @throws Exception
 */
public void testBoundColumnWithGroup() throws Exception {
  createDesign();
  TableHandle table=designHandle.getElementFactory().newTableItem(""String_Node_Str"",3);
  designHandle.getBody().add(table);
  TableGroupHandle group=designHandle.getElementFactory().newTableGroup();
  group.getFooter().add(designHandle.getElementFactory().newTableRow(3));
  table.getGroups().add(group);
  group=designHandle.getElementFactory().newTableGroup();
  group.getFooter().add(designHandle.getElementFactory().newTableRow(3));
  table.getGroups().add(group);
  DataItemHandle data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  data.setValueExpr(""String_Node_Str"");
  table.getCell(GroupHandle.FOOTER_SLOT,2,1,1).getContent().add(data);
  data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  data.setValueExpr(""String_Node_Str"");
  table.getCell(GroupHandle.FOOTER_SLOT,1,1,1).getContent().add(data);
  save();
  saveOutputFile(""String_Node_Str"");
  assertTrue(compareFile(""String_Node_Str""));
}","/** 
 * Supports the misc setting expression methods.
 * @throws Exception
 */
public void testBoundColumnWithGroup() throws Exception {
  createDesign();
  TableHandle table=designHandle.getElementFactory().newTableItem(""String_Node_Str"",3);
  designHandle.getBody().add(table);
  TableGroupHandle group=designHandle.getElementFactory().newTableGroup();
  group.getFooter().add(designHandle.getElementFactory().newTableRow(3));
  table.getGroups().add(group);
  group=designHandle.getElementFactory().newTableGroup();
  group.getFooter().add(designHandle.getElementFactory().newTableRow(3));
  table.getGroups().add(group);
  DataItemHandle data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  data.setValueExpr(""String_Node_Str"");
  table.getCell(GroupHandle.FOOTER_SLOT,2,1,1).getContent().add(data);
  data=designHandle.getElementFactory().newDataItem(""String_Node_Str"");
  data.setValueExpr(""String_Node_Str"");
  table.getCell(GroupHandle.FOOTER_SLOT,1,1,1).getContent().add(data);
  save();
  saveOutputFile(""String_Node_Str"");
  assertTrue(compareDesignModel(""String_Node_Str"",new String[]{""String_Node_Str""}));
}",0.9754354622599376
64935,"@Override public void drawLine(LineRenderEvent lre) throws ChartException {
  if (iv != null) {
    iv.modifyEvent(lre);
  }
  final LineAttributes lia=lre.getLineAttributes();
  if (!validateLineAttributes(lre.getSource(),lia) || lia.getColor() == null) {
    return;
  }
  if (lia.getColor().isSetTransparency() && lia.getColor().getTransparency() == 0) {
    return;
  }
  final Location loStart=lre.getStart();
  final Location loEnd=lre.getEnd();
  Stroke sPrevious=null, sCurrent=getCachedStroke(lia);
  if (sCurrent != null) {
    sPrevious=_g2d.getStroke();
    _g2d.setStroke(sCurrent);
  }
  _g2d.setColor((Color)_ids.getColor(lia.getColor()));
  _g2d.draw(new Line2D.Double(loStart.getX(),loStart.getY(),loEnd.getX(),loEnd.getY()));
  if (sPrevious != null) {
    _g2d.setStroke(sPrevious);
  }
}","@Override public void drawLine(LineRenderEvent lre) throws ChartException {
  if (iv != null) {
    iv.modifyEvent(lre);
  }
  final LineAttributes lia=lre.getLineAttributes();
  if (!validateLineAttributes(lre.getSource(),lia) || lia.getColor() == null) {
    return;
  }
  if (lia.getColor().isSetTransparency() && lia.getColor().getTransparency() == 0) {
    return;
  }
  final Location loStart=lre.getStart();
  final Location loEnd=lre.getEnd();
  if (!checkValidLocation(loStart) || !checkValidLocation(loEnd)) {
    return;
  }
  Stroke sPrevious=null, sCurrent=getCachedStroke(lia);
  if (sCurrent != null) {
    sPrevious=_g2d.getStroke();
    _g2d.setStroke(sCurrent);
  }
  _g2d.setColor((Color)_ids.getColor(lia.getColor()));
  _g2d.draw(new Line2D.Double(loStart.getX(),loStart.getY(),loEnd.getX(),loEnd.getY()));
  if (sPrevious != null) {
    _g2d.setStroke(sPrevious);
  }
}",0.950530035335689
64936,"protected QueryDefinition constructQuery(DataSetHandle dataset,DataRequestSession session) throws BirtException {
  QueryDefinition query=super.constructQuery(dataset,session);
  query.getBindings().clear();
  PropertyHandle propertyHandle=dataset.getPropertyHandle(DataSetHandle.PARAMETERS_PROP);
  int paramsSize=propertyHandle.getListValue().size();
  Iterator paramIter=propertyHandle.iterator();
  for (int n=1; n <= paramsSize; n++) {
    DataSetParameterHandle paramDefn=(DataSetParameterHandle)paramIter.next();
    if (!paramDefn.isOutput())     continue;
    String bindingName=paramDefn.getName();
    IBinding binding=new Binding(bindingName);
    binding.setExpression(new ScriptExpression(PREFIX_OUTPUTPARAMETER + ""String_Node_Str"" + paramDefn.getName()+ ""String_Node_Str""));
    binding.setDataType(DataAdapterUtil.adaptModelDataType(paramDefn.getDataType()));
    query.addBinding(binding);
  }
  return query;
}","protected QueryDefinition constructQuery(DataSetHandle dataset,DataRequestSession session) throws BirtException {
  QueryDefinition query=super.constructQuery(dataset);
  query.getBindings().clear();
  PropertyHandle propertyHandle=dataset.getPropertyHandle(DataSetHandle.PARAMETERS_PROP);
  int paramsSize=propertyHandle.getListValue().size();
  Iterator paramIter=propertyHandle.iterator();
  for (int n=1; n <= paramsSize; n++) {
    DataSetParameterHandle paramDefn=(DataSetParameterHandle)paramIter.next();
    if (!paramDefn.isOutput())     continue;
    String bindingName=paramDefn.getName();
    IBinding binding=new Binding(bindingName);
    binding.setExpression(new ScriptExpression(PREFIX_OUTPUTPARAMETER + ""String_Node_Str"" + paramDefn.getName()+ ""String_Node_Str""));
    binding.setDataType(DataAdapterUtil.adaptModelDataType(paramDefn.getDataType()));
    query.addBinding(binding);
  }
  return query;
}",0.9956709956709956
64937,"public void cancel(Object signal){
}","@Override public void cancel(String reason){
}",0.6341463414634146
64938,"public static QueryDefinition cloneQuery(QueryDefinition query){
  if (query == null) {
    return null;
  }
  IBaseQueryDefinition parent=query.getParentQuery();
  QueryDefinition newQuery=null;
  if (parent instanceof BaseQueryDefinition) {
    newQuery=new QueryDefinition((BaseQueryDefinition)parent);
  }
 else {
    newQuery=new QueryDefinition();
  }
  newQuery.getBindings().putAll(query.getBindings());
  newQuery.getFilters().addAll(query.getFilters());
  newQuery.getSorts().addAll(query.getSorts());
  newQuery.getSubqueries().addAll(query.getSubqueries());
  newQuery.getGroups().addAll(query.getGroups());
  newQuery.setUsesDetails(query.usesDetails());
  newQuery.setMaxRows(query.getMaxRows());
  newQuery.setDataSetName(query.getDataSetName());
  newQuery.setAutoBinding(query.needAutoBinding());
  newQuery.setColumnProjection(query.getColumnProjection());
  newQuery.setName(query.getName());
  newQuery.setIsSummaryQuery(query.isSummaryQuery());
  newQuery.setQueryExecutionHints(query.getQueryExecutionHints());
  return newQuery;
}","public static QueryDefinition cloneQuery(QueryDefinition query){
  if (query == null) {
    return null;
  }
  IBaseQueryDefinition parent=query.getParentQuery();
  QueryDefinition newQuery=null;
  if (parent instanceof BaseQueryDefinition) {
    newQuery=new QueryDefinition((BaseQueryDefinition)parent,query.needAutoBinding());
  }
 else {
    newQuery=new QueryDefinition(query.needAutoBinding());
  }
  newQuery.getBindings().putAll(query.getBindings());
  newQuery.getFilters().addAll(query.getFilters());
  newQuery.getSorts().addAll(query.getSorts());
  newQuery.getSubqueries().addAll(query.getSubqueries());
  newQuery.getGroups().addAll(query.getGroups());
  newQuery.setUsesDetails(query.usesDetails());
  newQuery.setMaxRows(query.getMaxRows());
  newQuery.setDataSetName(query.getDataSetName());
  newQuery.setColumnProjection(query.getColumnProjection());
  newQuery.setName(query.getName());
  newQuery.setIsSummaryQuery(query.isSummaryQuery());
  newQuery.setQueryExecutionHints(query.getQueryExecutionHints());
  return newQuery;
}",0.9528795811518324
64939,"/** 
 * Build the style of table content
 */
public void buildTableStyle(ITableContent table,StringBuffer styleBuffer){
  addDefaultTableStyles(styleBuffer);
  IStyle style=table.getStyle();
  boolean isInline=false;
  CSSValue display=style.getProperty(IStyle.STYLE_DISPLAY);
  if (IStyle.NONE_VALUE == display) {
    styleBuffer.append(""String_Node_Str"");
  }
 else   if (IStyle.INLINE_VALUE == display || IStyle.INLINE_BLOCK_VALUE == display) {
    isInline=true;
    if (!reportEmitter.browserSupportsInlineBlock) {
      styleBuffer.append(""String_Node_Str"");
    }
 else {
      styleBuffer.append(""String_Node_Str"");
    }
  }
  DimensionType height=table.getHeight();
  if (null != height) {
    buildSize(styleBuffer,HTMLTags.ATTR_HEIGHT,height);
  }
  boolean widthOutputFlag=false;
  DimensionType width=table.getWidth();
  if (null != width) {
    buildSize(styleBuffer,HTMLTags.ATTR_WIDTH,width);
    widthOutputFlag=true;
  }
 else {
    if (!""String_Node_Str"".equalsIgnoreCase(style.getCanShrink())) {
      boolean absoluteWidth=true;
      for (int i=0; i < table.getColumnCount(); i++) {
        IColumn column=table.getColumn(i);
        DimensionType columnWidth=column.getWidth();
        if (columnWidth == null) {
          absoluteWidth=false;
          break;
        }
 else {
          if (""String_Node_Str"".endsWith(columnWidth.getUnits())) {
            absoluteWidth=false;
            break;
          }
        }
      }
      if (!absoluteWidth) {
        styleBuffer.append(""String_Node_Str"");
        widthOutputFlag=true;
      }
    }
  }
  if (fixedReport) {
    if (!""String_Node_Str"".equalsIgnoreCase(style.getCanShrink())) {
      if (!widthOutputFlag) {
        if (isInline) {
          styleBuffer.append(""String_Node_Str"");
        }
 else {
          styleBuffer.append(""String_Node_Str"");
        }
      }
      CSSValue overflowValue=style.getProperty(IStyle.STYLE_OVERFLOW);
      if (overflowValue == null) {
        styleBuffer.append(""String_Node_Str"");
      }
 else {
        styleBuffer.append(""String_Node_Str"").append(overflowValue.getCssText()).append(""String_Node_Str"");
      }
      styleBuffer.append(""String_Node_Str"");
    }
  }
  String value=style.getTextAlign();
  if (null != value) {
    if (isInline) {
      styleBuffer.append(""String_Node_Str"");
      styleBuffer.append(""String_Node_Str"");
      styleBuffer.append(value);
      styleBuffer.append(""String_Node_Str"");
    }
    styleBuffer.append(""String_Node_Str"");
    styleBuffer.append(value);
    styleBuffer.append(""String_Node_Str"");
  }
  style=getElementStyle(table);
  if (style == null) {
    return;
  }
  AttributeBuilder.buildFont(styleBuffer,style);
  AttributeBuilder.buildBox(styleBuffer,style);
  AttributeBuilder.buildBackground(styleBuffer,style,reportEmitter);
  AttributeBuilder.buildText(styleBuffer,style);
  AttributeBuilder.buildVisual(styleBuffer,style);
  AttributeBuilder.buildTextDecoration(styleBuffer,style);
}","/** 
 * Build the style of table content
 */
public void buildTableStyle(ITableContent table,StringBuffer styleBuffer){
  addDefaultTableStyles(styleBuffer);
  IStyle style=table.getStyle();
  boolean isInline=false;
  CSSValue display=style.getProperty(IStyle.STYLE_DISPLAY);
  if (IStyle.NONE_VALUE == display) {
    styleBuffer.append(""String_Node_Str"");
  }
 else   if (IStyle.INLINE_VALUE == display || IStyle.INLINE_BLOCK_VALUE == display) {
    isInline=true;
    if (!reportEmitter.browserSupportsInlineBlock) {
      styleBuffer.append(""String_Node_Str"");
    }
 else {
      styleBuffer.append(""String_Node_Str"");
    }
  }
  DimensionType height=table.getHeight();
  if (null != height) {
    buildSize(styleBuffer,HTMLTags.ATTR_HEIGHT,height);
  }
  boolean widthOutputFlag=false;
  DimensionType width=table.getWidth();
  if (null != width) {
    buildSize(styleBuffer,HTMLTags.ATTR_WIDTH,width);
    widthOutputFlag=true;
  }
 else {
    if (!""String_Node_Str"".equalsIgnoreCase(style.getCanShrink())) {
      boolean absoluteWidth=true;
      for (int i=0; i < table.getColumnCount(); i++) {
        IColumn column=table.getColumn(i);
        DimensionType columnWidth=column.getWidth();
        if (columnWidth == null) {
          absoluteWidth=false;
          break;
        }
 else {
          if (""String_Node_Str"".endsWith(columnWidth.getUnits())) {
            absoluteWidth=false;
            break;
          }
        }
      }
      if (!absoluteWidth) {
        styleBuffer.append(""String_Node_Str"");
        widthOutputFlag=true;
      }
    }
  }
  if (fixedReport) {
    if (!""String_Node_Str"".equalsIgnoreCase(style.getCanShrink())) {
      if (!widthOutputFlag) {
        if (isInline) {
          styleBuffer.append(""String_Node_Str"");
        }
 else {
          styleBuffer.append(""String_Node_Str"");
        }
      }
      CSSValue overflowValue=style.getProperty(IStyle.STYLE_OVERFLOW);
      if (overflowValue == null) {
        if (isInline) {
          styleBuffer.append(""String_Node_Str"");
        }
      }
 else {
        styleBuffer.append(""String_Node_Str"").append(overflowValue.getCssText()).append(""String_Node_Str"");
      }
      styleBuffer.append(""String_Node_Str"");
    }
  }
  String value=style.getTextAlign();
  if (null != value) {
    if (isInline) {
      styleBuffer.append(""String_Node_Str"");
      styleBuffer.append(""String_Node_Str"");
      styleBuffer.append(value);
      styleBuffer.append(""String_Node_Str"");
    }
    styleBuffer.append(""String_Node_Str"");
    styleBuffer.append(value);
    styleBuffer.append(""String_Node_Str"");
  }
  style=getElementStyle(table);
  if (style == null) {
    return;
  }
  AttributeBuilder.buildFont(styleBuffer,style);
  AttributeBuilder.buildBox(styleBuffer,style);
  AttributeBuilder.buildBackground(styleBuffer,style,reportEmitter);
  AttributeBuilder.buildText(styleBuffer,style);
  AttributeBuilder.buildVisual(styleBuffer,style);
  AttributeBuilder.buildTextDecoration(styleBuffer,style);
}",0.9939678284182306
64940,"/** 
 * @param projectedColumns
 */
private void initColumnsInfo(List projectedColumns){
  m_fieldCount=projectedColumns.size();
  projectedCols=new ResultFieldMetadata[m_fieldCount];
  nameToIdMapping=new HashMap();
  this.originalAnyTypeField=new ArrayList();
  for (int i=0, n=projectedColumns.size(); i < n; i++) {
    projectedCols[i]=(ResultFieldMetadata)projectedColumns.get(i);
    ResultFieldMetadata column=projectedCols[i];
    if (isOfAnyType(column)) {
      this.hasAny=true;
      this.originalAnyTypeField.add(Integer.valueOf(i + 1));
    }
    String upperCaseName=column.getName();
    Integer index=Integer.valueOf(i + 1);
    if (!nameToIdMapping.containsKey(upperCaseName)) {
      nameToIdMapping.put(upperCaseName,index);
    }
    String upperCaseAlias=column.getAlias();
    if (upperCaseAlias != null && upperCaseAlias.length() > 0 && !nameToIdMapping.containsKey(upperCaseAlias)) {
      nameToIdMapping.put(upperCaseAlias,index);
    }
  }
}","/** 
 * @param projectedColumns
 */
private void initColumnsInfo(List projectedColumns){
  m_fieldCount=projectedColumns.size();
  projectedCols=new ResultFieldMetadata[m_fieldCount];
  nameToIdMapping=new HashMap();
  this.originalAnyTypeField=new ArrayList();
  for (int i=0, n=projectedColumns.size(); i < n; i++) {
    projectedCols[i]=(ResultFieldMetadata)projectedColumns.get(i);
    ResultFieldMetadata column=projectedCols[i];
    if (isOfAnyType(column)) {
      this.hasAny=true;
      this.originalAnyTypeField.add(Integer.valueOf(i + 1));
    }
    String upperCaseName=column.getName();
    Integer index=Integer.valueOf(i + 1);
    if (!nameToIdMapping.containsKey(upperCaseName)) {
      nameToIdMapping.put(upperCaseName,index);
    }
    String upperCaseAlias=column.getAlias();
    if (upperCaseAlias != null && upperCaseAlias.length() > 0 && !nameToIdMapping.containsKey(upperCaseAlias)) {
      nameToIdMapping.put(upperCaseAlias,index);
    }
  }
  for (int i=0; i < projectedCols.length; i++) {
    String JDBCAlias=projectedCols[i].getLabel();
    if (!nameToIdMapping.containsKey(JDBCAlias))     nameToIdMapping.put(JDBCAlias,Integer.valueOf(i + 1));
  }
}",0.90181479758027
64941,"/** 
 * Populate all valid data set column names and alias.
 * @return
 * @throws DataException
 */
private Set populateValidDataSetColumnNameSet() throws DataException {
  Set validDataSetColumnNames=new HashSet();
  for (int i=1; i <= this.odiResult.getResultClass().getFieldCount(); i++) {
    validDataSetColumnNames.add(this.odiResult.getResultClass().getFieldName(i));
    validDataSetColumnNames.add(this.odiResult.getResultClass().getFieldAlias(i));
  }
  return validDataSetColumnNames;
}","/** 
 * Populate all valid data set column names and alias.
 * @return
 * @throws DataException
 */
private Set populateValidDataSetColumnNameSet() throws DataException {
  Set validDataSetColumnNames=new HashSet();
  IResultClass rc=this.odiResult.getResultClass();
  for (int i=1; i <= rc.getFieldCount(); i++) {
    validDataSetColumnNames.add(rc.getFieldName(i));
    if (rc.getFieldAlias(i) != null)     validDataSetColumnNames.add(rc.getFieldAlias(i));
    if (rc.getFieldLabel(i) != null)     validDataSetColumnNames.add(rc.getFieldLabel(i));
  }
  return validDataSetColumnNames;
}",0.6924493554327809
64942,"void addHint(ColumnHint columnHint) throws DataException {
  final String methodName=""String_Node_Str"";
  sm_logger.entering(sm_className,methodName,columnHint);
  assert(columnHint != null);
  int columnPosition=columnHint.getPosition();
  if (columnPosition > 0 && columnPosition <= m_columns.size()) {
    int driverIndex=columnPosition - 1;
    ResultFieldMetadata fieldMD=(ResultFieldMetadata)m_columns.get(driverIndex);
    String columnHintAlias=columnHint.getAlias();
    if (columnHintAlias != null)     validateNewNameOrAlias(columnHintAlias,driverIndex);
    String newColumnName=columnHint.getName();
    if (newColumnName != null && newColumnName.length() > 0) {
      validateNewNameOrAlias(newColumnName,driverIndex);
      fieldMD.setName(newColumnName);
    }
    updateFieldDataTypeAndAlias(fieldMD,columnHint,driverIndex);
  }
 else {
    String columnHintName=columnHint.getName();
    for (int i=0, n=m_columns.size(); i < n; i++) {
      ResultFieldMetadata fieldMD=(ResultFieldMetadata)m_columns.get(i);
      if (fieldMD.getName().equals(columnHintName)) {
        updateFieldDataTypeAndAlias(fieldMD,columnHint,i);
      }
    }
  }
  doGetColumnHints().add(columnHint);
  sm_logger.exiting(sm_className,methodName);
}","void addHint(ColumnHint columnHint) throws DataException {
  final String methodName=""String_Node_Str"";
  sm_logger.entering(sm_className,methodName,columnHint);
  assert(columnHint != null);
  int columnPosition=columnHint.getPosition();
  if (columnPosition > 0 && columnPosition <= m_columns.size()) {
    int driverIndex=columnPosition - 1;
    ResultFieldMetadata fieldMD=(ResultFieldMetadata)m_columns.get(driverIndex);
    String columnHintAlias=columnHint.getAlias();
    if (columnHintAlias != null)     validateNewNameOrAlias(columnHintAlias,driverIndex);
    String newColumnName=columnHint.getName();
    if (newColumnName != null && newColumnName.length() > 0) {
      fieldMD.setName(newColumnName);
    }
    updateFieldDataTypeAndAlias(fieldMD,columnHint,driverIndex);
  }
 else {
    String columnHintName=columnHint.getName();
    for (int i=0, n=m_columns.size(); i < n; i++) {
      ResultFieldMetadata fieldMD=(ResultFieldMetadata)m_columns.get(i);
      if (fieldMD.getName().equals(columnHintName)) {
        updateFieldDataTypeAndAlias(fieldMD,columnHint,i);
      }
    }
  }
  doGetColumnHints().add(columnHint);
  sm_logger.exiting(sm_className,methodName);
}",0.9765335529024288
64943,"protected QueryDefinition constructQuery(DataSetHandle dataset) throws DataException {
  QueryDefinition query=super.constructQuery(dataset);
  PropertyHandle propertyHandle=dataset.getPropertyHandle(DataSetHandle.PARAMETERS_PROP);
  int paramsSize=propertyHandle.getListValue().size();
  Iterator paramIter=propertyHandle.iterator();
  for (int n=1; n <= paramsSize; n++) {
    DataSetParameterHandle paramDefn=(DataSetParameterHandle)paramIter.next();
    if (!paramDefn.isOutput())     continue;
    String bindingName=paramDefn.getName();
    IBinding binding=new Binding(bindingName);
    binding.setExpression(new ScriptExpression(PREFIX_OUTPUTPARAMETER + ""String_Node_Str"" + paramDefn.getName()+ ""String_Node_Str""));
    binding.setDataType(DataAdapterUtil.adaptModelDataType(paramDefn.getDataType()));
    query.addBinding(binding);
  }
  return query;
}","protected QueryDefinition constructQuery(DataSetHandle dataset,DataRequestSession session) throws BirtException {
  QueryDefinition query=super.constructQuery(dataset,session);
  PropertyHandle propertyHandle=dataset.getPropertyHandle(DataSetHandle.PARAMETERS_PROP);
  int paramsSize=propertyHandle.getListValue().size();
  Iterator paramIter=propertyHandle.iterator();
  for (int n=1; n <= paramsSize; n++) {
    DataSetParameterHandle paramDefn=(DataSetParameterHandle)paramIter.next();
    if (!paramDefn.isOutput())     continue;
    String bindingName=paramDefn.getName();
    IBinding binding=new Binding(bindingName);
    binding.setExpression(new ScriptExpression(PREFIX_OUTPUTPARAMETER + ""String_Node_Str"" + paramDefn.getName()+ ""String_Node_Str""));
    binding.setDataType(DataAdapterUtil.adaptModelDataType(paramDefn.getDataType()));
    query.addBinding(binding);
  }
  return query;
}",0.9755542922114838
64944,"public Object getSummaryValue(){
  return sum;
}","public Object getSummaryValue(){
  return Double.valueOf(sum.doubleValue());
}",0.7619047619047619
64945,"/** 
 * Zeroes out all units for this datetime instance below a specified unit.
 * @param iUnit The unit below which all values are to be zeroed out
 * @param always indicates if it's always trimmed no matter if it's full date time
 */
public final void clearBelow(int iUnit,boolean always){
  if (!always && isFullDateTime()) {
    return;
  }
  if (iUnit == YEAR) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
    set(Calendar.HOUR,0);
    set(Calendar.DATE,1);
    set(Calendar.AM_PM,AM);
    set(Calendar.MONTH,0);
  }
 else   if (iUnit == MONTH || iUnit == GroupingUnitType.QUARTERS) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
    set(Calendar.HOUR,0);
    set(Calendar.AM_PM,AM);
    set(Calendar.DATE,1);
    if (iUnit == GroupingUnitType.QUARTERS) {
      set(Calendar.MONTH,(getMonth() / 3) * 3);
    }
  }
 else   if (iUnit == WEEK_OF_YEAR) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
    set(Calendar.HOUR,0);
    set(Calendar.AM_PM,AM);
    int weekDay=get(DAY_OF_WEEK);
    add(DATE,1 - weekDay);
  }
 else   if (iUnit == DATE) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
    set(Calendar.HOUR,0);
    set(Calendar.AM_PM,AM);
  }
 else   if (iUnit == HOUR || iUnit == HOUR_OF_DAY) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
  }
 else   if (iUnit == MINUTE) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
  }
 else   if (iUnit == SECOND) {
    set(Calendar.MILLISECOND,0);
  }
}","/** 
 * Zeroes out all units for this datetime instance below a specified unit.
 * @param iUnit The unit below which all values are to be zeroed out
 * @param always indicates if it's always trimmed no matter if it's full date time
 */
public final void clearBelow(int iUnit,boolean always){
  if (!always && isFullDateTime()) {
    return;
  }
  if (iUnit == YEAR) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
    set(Calendar.HOUR,0);
    set(Calendar.DATE,1);
    set(Calendar.AM_PM,AM);
    set(Calendar.MONTH,0);
  }
 else   if (iUnit == MONTH || iUnit == QUARTER) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
    set(Calendar.HOUR,0);
    set(Calendar.AM_PM,AM);
    set(Calendar.DATE,1);
    if (iUnit == QUARTER) {
      set(Calendar.MONTH,(getMonth() / 3) * 3);
    }
  }
 else   if (iUnit == WEEK_OF_YEAR || iUnit == WEEK_OF_MONTH) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
    set(Calendar.HOUR,0);
    set(Calendar.AM_PM,AM);
    int weekDay=get(DAY_OF_WEEK);
    add(DATE,1 - weekDay);
  }
 else   if (iUnit == DATE || iUnit == DAY_OF_MONTH || iUnit == DAY_OF_WEEK || iUnit == DAY_OF_YEAR) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
    set(Calendar.HOUR,0);
    set(Calendar.AM_PM,AM);
  }
 else   if (iUnit == HOUR || iUnit == HOUR_OF_DAY) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
    set(Calendar.MINUTE,0);
  }
 else   if (iUnit == MINUTE) {
    set(Calendar.MILLISECOND,0);
    set(Calendar.SECOND,0);
  }
 else   if (iUnit == SECOND) {
    set(Calendar.MILLISECOND,0);
  }
}",0.9596412556053812
64946,"/** 
 * Reset year units for this datetime instance above a specified unit.
 * @param iUnit The unit above which year values are to be reset
 * @param always indicates if it's always trimmed no matter if it's full date time
 */
public final void clearAbove(int iUnit,boolean always){
  if (!always && isFullDateTime()) {
    return;
  }
  if (iUnit == YEAR) {
    return;
  }
 else   if (iUnit == MONTH || iUnit == GroupingUnitType.QUARTERS) {
    set(Calendar.YEAR,2000);
  }
 else   if (iUnit == DATE) {
    set(Calendar.YEAR,2000);
  }
 else   if (iUnit == WEEK_OF_YEAR) {
    set(Calendar.YEAR,2000);
  }
  return;
}","/** 
 * Reset year units for this datetime instance above a specified unit.
 * @param iUnit The unit above which year values are to be reset
 * @param always indicates if it's always trimmed no matter if it's full date time
 */
public final void clearAbove(int iUnit,boolean always){
  if (!always && isFullDateTime()) {
    return;
  }
  if (iUnit == YEAR) {
    return;
  }
 else   if (iUnit == MONTH || iUnit == QUARTER) {
    set(Calendar.YEAR,2000);
  }
 else   if (iUnit == DATE || iUnit == DAY_OF_MONTH || iUnit == DAY_OF_WEEK || iUnit == DAY_OF_YEAR) {
    set(Calendar.YEAR,2000);
  }
 else   if (iUnit == WEEK_OF_YEAR || iUnit == WEEK_OF_MONTH) {
    set(Calendar.YEAR,2000);
  }
  return;
}",0.9023467070401212
64947,"/** 
 * @param subquery Subquery definition
 * @param parentQuery Parent query (which can be a subquery itself, or a PreparedReportQuery)
 * @param groupLevel Index of group in which this subquery is defined within the parent query. If 0, subquery is defined outside of any groups.
 * @throws DataException
 */
PreparedSubquery(DataEngineSession session,DataEngineContext context,ISubqueryDefinition subquery,IPreparedQueryService queryService,int groupLevel) throws DataException {
  Object[] params={session,context,subquery,queryService,Integer.valueOf(groupLevel)};
  logger.entering(PreparedSubquery.class.getName(),""String_Node_Str"",params);
  this.groupLevel=groupLevel;
  this.queryService=queryService;
  this.subQueryOnGroup=subquery.applyOnGroup();
  logger.logp(Level.FINER,PreparedSubquery.class.getName(),""String_Node_Str"",""String_Node_Str"");
  this.session=session;
  this.preparedQuery=new PreparedQuery(session,context,subquery,this,null);
  logger.exiting(PreparedSubquery.class.getName(),""String_Node_Str"");
}","/** 
 * @param subquery Subquery definition
 * @param parentQuery Parent query (which can be a subquery itself, or a PreparedReportQuery)
 * @param groupLevel Index of group in which this subquery is defined within the parent query. If 0, subquery is defined outside of any groups.
 * @throws DataException
 */
PreparedSubquery(DataEngineSession session,DataEngineContext context,ISubqueryDefinition subquery,IPreparedQueryService queryService,int groupLevel) throws DataException {
  Object[] params={session,context,subquery,queryService,Integer.valueOf(groupLevel)};
  logger.entering(PreparedSubquery.class.getName(),""String_Node_Str"",params);
  this.groupLevel=groupLevel;
  this.queryService=queryService;
  this.subQueryOnGroup=subquery.applyOnGroup();
  logger.logp(Level.FINER,PreparedSubquery.class.getName(),""String_Node_Str"",""String_Node_Str"");
  this.session=session;
  this.preparedQuery=new PreparedQuery(session,context,subquery,this,queryService.getDataSourceQuery().appContext);
  logger.exiting(PreparedSubquery.class.getName(),""String_Node_Str"");
}",0.9770992366412212
64948,"public Object getSummaryValue(){
  return Double.valueOf(sum.doubleValue());
}","public Object getSummaryValue(){
  return sum;
}",0.7619047619047619
64949,"private double translateCoor(double d){
  return d / dpi * 72d;
}","private double translateCoor(double d){
  return d / dpi * 96d;
}",0.9692307692307692
64950,"public String getImageMap(){
  return new ImageMapEmitter(getShapeActions(),_bAltEnabled,getULocale()).getImageMap();
}","public String getImageMap(){
  return new ImageMapEmitter(getShapeActions(),_bAltEnabled,getULocale(),getDisplayServer().getDpiResolution()).getImageMap();
}",0.8623188405797102
64951,"TimeFunctionCalculator(AggregationDefinition aggr,DimColumn[] parameterColNames,IDataSet4Aggregation.MetaInfo metaInfo,ICubeDimensionReader cubeDimensionReader,long memoryCacheSize) throws DataException, IOException {
  AggregationFunctionDefinition[] timeFunction=aggr.getAggregationTimeFunctions();
  if (timeFunction == null) {
    existTimeFunction=false;
    return;
  }
  existTimeFunction=true;
  tDimName=timeFunction[0].getTimeFunction().getTimeDimension();
  timeDimension=cubeDimensionReader.getDimension(tDimName);
  periodFunction=createTimeFunction(timeFunction);
  periodFunctionResultCache=new Map[periodFunction.length];
  for (int i=0; i < periodFunctionResultCache.length; i++) {
    periodFunctionResultCache[i]=new HashMap<TimeMember,List<TimeMember>>();
  }
  timeDimensionIndex=cubeDimensionReader.getDimensionIndex(tDimName);
  lowestTimeLevel=getLowestTimeLevel(aggr);
  firstTimeLevel=getFirstTimeLevel(aggr);
  existReferenceDate=false;
  existLastDate=false;
  referenceDate=new Date[timeFunction.length];
  for (int i=0; i < timeFunction.length; i++) {
    if (timeFunction[i].getTimeFunction().getReferenceDate() != null)     referenceDate[i]=timeFunction[i].getTimeFunction().getReferenceDate().getDate();
    if (referenceDate[i] != null) {
      existReferenceDate=true;
      int levelIndex1=cubeDimensionReader.getlowestLevelIndex(tDimName) - 1;
      int levelIndex2=cubeDimensionReader.getLevelIndex(tDimName,aggr.getLevels()[lowestTimeLevel].getLevelName());
      if (levelIndex1 == levelIndex2) {
        this.avoidExtraSort=true;
      }
    }
 else {
      existLastDate=true;
    }
  }
  if (existReferenceDate) {
    endLevelIndex=cubeDimensionReader.getlowestLevelIndex(tDimName) - 1;
  }
 else {
    endLevelIndex=cubeDimensionReader.getLevelIndex(tDimName,aggr.getLevels()[lowestTimeLevel].getLevelName());
  }
  orignalLevelCount=aggr.getLevels().length;
  newMemberSize=aggr.getLevels().length - (lowestTimeLevel - firstTimeLevel + 1) + (endLevelIndex + 1);
  sortType=getSortType(aggr,cubeDimensionReader);
  Comparator comparator=new Row4AggregationComparator(sortType);
  int levelCount=0;
  if (aggr.getLevels() == null)   levelCount=0;
 else   levelCount=aggr.getLevels().length;
  int levelSize=0;
  if (levelCount != 0) {
    levelSize=getLevelSize(metaInfo,aggr.getLevels());
  }
  int measureSize=0;
  if (aggregationFunction != null && aggregationFunction.length > 0) {
    measureSize=aggregationFunction.length * 64;
  }
  int rowSize=16 + (4 + (levelSize + measureSize) - 1) / 8 * 8;
  int bufferSize=(int)(memoryCacheSize / rowSize);
  if (bufferSize < 100)   bufferSize=100;
  if (this.existReferenceDate) {
    if (!this.avoidExtraSort) {
      sortedFactRows=new DiskSortedStack(bufferSize,false,comparator,Row4Aggregation.getCreator());
      if (memoryCacheSize == 0) {
        sortedFactRows.setUseMemoryOnly(true);
      }
    }
 else {
      factRows=new BufferedStructureArray(Row4Aggregation.getCreator(),bufferSize);
      if (memoryCacheSize == 0) {
        factRows.setUseMemoryOnly(true);
      }
      factRowPostion=0;
    }
  }
  if (this.existLastDate) {
    factRows=new BufferedStructureArray(Row4Aggregation.getCreator(),bufferSize);
    if (memoryCacheSize == 0) {
      factRows.setUseMemoryOnly(true);
    }
    factRowPostion=0;
  }
  comparator=new MemberCellIndexComparator(getSortType(aggr,cubeDimensionReader));
  timeMemberFilters=new DiskSortedStack[timeFunction.length];
  for (int i=0; i < timeMemberFilters.length; i++) {
    timeMemberFilters[i]=new DiskSortedStack(bufferSize,false,comparator,MemberCellIndex.getCreator());
    if (memoryCacheSize == 0) {
      timeMemberFilters[i].setUseMemoryOnly(true);
    }
  }
  this.aggregation=aggr;
  this.measureIndexes=new int[timeFunction.length];
  this.parameterColIndex=new int[timeFunction.length];
  this.aggregationFunction=new IAggrFunction[timeFunction.length];
  for (int i=0; i < timeFunction.length; i++) {
    aggregationFunction[i]=AggregationManager.getInstance().getAggregation(timeFunction[i].getFunctionName());
    if (aggregationFunction[i] == null) {
      throw new DataException(DataResourceHandle.getInstance().getMessage(ResourceConstants.UNSUPPORTED_FUNCTION) + timeFunction[i].getFunctionName());
    }
    if (AggregationUtil.needDataField(aggregationFunction[i])) {
      this.parameterColIndex[i]=find(parameterColNames,timeFunction[i].getParaCol());
    }
 else {
      this.parameterColIndex[i]=-1;
    }
    final String measureName=timeFunction[i].getMeasureName();
    this.measureIndexes[i]=metaInfo.getMeasureIndex(measureName);
    if (this.measureIndexes[i] == -1 && measureName != null) {
      throw new DataException(ResourceConstants.MEASURE_NAME_NOT_FOUND,measureName);
    }
  }
  measureInfos=metaInfo.getMeasureInfos();
  facttableRow=new FacttableRow(measureInfos,cubeDimensionReader,metaInfo);
  this.cubeDimensionReader=cubeDimensionReader;
  getLevelType();
}","TimeFunctionCalculator(AggregationDefinition aggr,DimColumn[] parameterColNames,IDataSet4Aggregation.MetaInfo metaInfo,ICubeDimensionReader cubeDimensionReader,long memoryCacheSize) throws DataException, IOException {
  AggregationFunctionDefinition[] timeFunction=aggr.getAggregationTimeFunctions();
  if (timeFunction == null) {
    existTimeFunction=false;
    return;
  }
  existTimeFunction=true;
  tDimName=timeFunction[0].getTimeFunction().getTimeDimension();
  timeDimension=cubeDimensionReader.getDimension(tDimName);
  periodFunction=createTimeFunction(timeFunction);
  periodFunctionResultCache=new Map[periodFunction.length];
  for (int i=0; i < periodFunctionResultCache.length; i++) {
    periodFunctionResultCache[i]=new HashMap<TimeMember,List<TimeMember>>();
  }
  timeDimensionIndex=cubeDimensionReader.getDimensionIndex(tDimName);
  lowestTimeLevel=getLowestTimeLevel(aggr);
  firstTimeLevel=getFirstTimeLevel(aggr);
  existReferenceDate=false;
  existLastDate=false;
  referenceDate=new Date[timeFunction.length];
  for (int i=0; i < timeFunction.length; i++) {
    if (timeFunction[i].getTimeFunction().getReferenceDate() != null)     referenceDate[i]=timeFunction[i].getTimeFunction().getReferenceDate().getDate();
    if (referenceDate[i] != null) {
      existReferenceDate=true;
      int levelIndex1=cubeDimensionReader.getlowestLevelIndex(tDimName) - 1;
      int levelIndex2=cubeDimensionReader.getLevelIndex(tDimName,aggr.getLevels()[lowestTimeLevel].getLevelName());
      if (levelIndex1 == levelIndex2) {
        this.avoidExtraSort=true;
      }
    }
 else {
      existLastDate=true;
    }
  }
  if (existReferenceDate) {
    if (cubeDimensionReader.getlowestLevelIndex(tDimName) == 0)     endLevelIndex=0;
 else     endLevelIndex=cubeDimensionReader.getlowestLevelIndex(tDimName) - 1;
  }
 else {
    endLevelIndex=cubeDimensionReader.getLevelIndex(tDimName,aggr.getLevels()[lowestTimeLevel].getLevelName());
  }
  orignalLevelCount=aggr.getLevels().length;
  newMemberSize=aggr.getLevels().length - (lowestTimeLevel - firstTimeLevel + 1) + (endLevelIndex + 1);
  sortType=getSortType(aggr,cubeDimensionReader);
  Comparator comparator=new Row4AggregationComparator(sortType);
  int levelCount=0;
  if (aggr.getLevels() == null)   levelCount=0;
 else   levelCount=aggr.getLevels().length;
  int levelSize=0;
  if (levelCount != 0) {
    levelSize=getLevelSize(metaInfo,aggr.getLevels());
  }
  int measureSize=0;
  if (aggregationFunction != null && aggregationFunction.length > 0) {
    measureSize=aggregationFunction.length * 64;
  }
  int rowSize=16 + (4 + (levelSize + measureSize) - 1) / 8 * 8;
  int bufferSize=(int)(memoryCacheSize / rowSize);
  if (bufferSize < 100)   bufferSize=100;
  if (this.existReferenceDate) {
    if (!this.avoidExtraSort) {
      sortedFactRows=new DiskSortedStack(bufferSize,false,comparator,Row4Aggregation.getCreator());
      if (memoryCacheSize == 0) {
        sortedFactRows.setUseMemoryOnly(true);
      }
    }
 else {
      factRows=new BufferedStructureArray(Row4Aggregation.getCreator(),bufferSize);
      if (memoryCacheSize == 0) {
        factRows.setUseMemoryOnly(true);
      }
      factRowPostion=0;
    }
  }
  if (this.existLastDate) {
    factRows=new BufferedStructureArray(Row4Aggregation.getCreator(),bufferSize);
    if (memoryCacheSize == 0) {
      factRows.setUseMemoryOnly(true);
    }
    factRowPostion=0;
  }
  comparator=new MemberCellIndexComparator(getSortType(aggr,cubeDimensionReader));
  timeMemberFilters=new DiskSortedStack[timeFunction.length];
  for (int i=0; i < timeMemberFilters.length; i++) {
    timeMemberFilters[i]=new DiskSortedStack(bufferSize,false,comparator,MemberCellIndex.getCreator());
    if (memoryCacheSize == 0) {
      timeMemberFilters[i].setUseMemoryOnly(true);
    }
  }
  this.aggregation=aggr;
  this.measureIndexes=new int[timeFunction.length];
  this.parameterColIndex=new int[timeFunction.length];
  this.aggregationFunction=new IAggrFunction[timeFunction.length];
  for (int i=0; i < timeFunction.length; i++) {
    aggregationFunction[i]=AggregationManager.getInstance().getAggregation(timeFunction[i].getFunctionName());
    if (aggregationFunction[i] == null) {
      throw new DataException(DataResourceHandle.getInstance().getMessage(ResourceConstants.UNSUPPORTED_FUNCTION) + timeFunction[i].getFunctionName());
    }
    if (AggregationUtil.needDataField(aggregationFunction[i])) {
      this.parameterColIndex[i]=find(parameterColNames,timeFunction[i].getParaCol());
    }
 else {
      this.parameterColIndex[i]=-1;
    }
    final String measureName=timeFunction[i].getMeasureName();
    this.measureIndexes[i]=metaInfo.getMeasureIndex(measureName);
    if (this.measureIndexes[i] == -1 && measureName != null) {
      throw new DataException(ResourceConstants.MEASURE_NAME_NOT_FOUND,measureName);
    }
  }
  measureInfos=metaInfo.getMeasureInfos();
  facttableRow=new FacttableRow(measureInfos,cubeDimensionReader,metaInfo);
  this.cubeDimensionReader=cubeDimensionReader;
  getLevelType();
}",0.9908990899089908
64952,"/** 
 * @param value
 */
protected void doEnd(Object value){
  if (struct != null) {
    setMember(struct,propDefn.getName(),name,value);
    return;
  }
  IPropertyDefn jmpDefn=element.getPropertyDefn(name);
  if (IStyledElementModel.STYLE_PROP.equalsIgnoreCase(name)) {
    if (!element.getDefn().hasStyle()) {
      DesignParserException e=new DesignParserException(new String[]{name},DesignParserException.DESIGN_EXCEPTION_UNDEFINED_PROPERTY);
      RecoverableError.dealUndefinedProperty(handler,e);
      return;
    }
    if (handler.versionNumber < VersionUtil.VERSION_3_2_19) {
      Map<String,String> nameMap=null;
      if (handler.module instanceof ReportDesign) {
        nameMap=(Map<String,String>)handler.tempValue.get(handler.module);
      }
 else {
        Theme theme=handler.module.getTheme(handler.module);
        if (theme != null) {
          nameMap=(Map<String,String>)handler.tempValue.get(theme);
        }
      }
      if (nameMap != null && nameMap.get(value) != null) {
        ((StyledElement)element).setStyleName(nameMap.get(value));
      }
 else {
        ((StyledElement)element).setStyleName((String)value);
      }
      if (value != null) {
        if (handler.styledElements == null)         handler.styledElements=new ArrayList<DesignElement>();
        handler.styledElements.add(element);
      }
    }
 else     ((StyledElement)element).setStyleName((String)value);
  }
 else   if (element instanceof OdaDataSet && QUERY_TEXT_MEMBER == nameValue && handler.versionNumber < VersionUtil.VERSION_3_2_19) {
    value=deEscape((String)value);
    setProperty(name,value);
  }
 else   if (handler.versionNumber >= VersionUtil.VERSION_3_2_16 && isXMLorScriptType(jmpDefn) && !ModelUtil.isExtensionPropertyOwnModel(jmpDefn)) {
    value=deEscape((String)value);
    setProperty(name,value);
  }
 else {
    setProperty(name,value);
  }
}","/** 
 * @param value
 */
protected void doEnd(Object value){
  if (struct != null) {
    setMember(struct,propDefn.getName(),name,value);
    return;
  }
  IPropertyDefn jmpDefn=element.getPropertyDefn(name);
  if (IStyledElementModel.STYLE_PROP.equalsIgnoreCase(name)) {
    if (!element.getDefn().hasStyle()) {
      DesignParserException e=new DesignParserException(new String[]{name},DesignParserException.DESIGN_EXCEPTION_UNDEFINED_PROPERTY);
      RecoverableError.dealUndefinedProperty(handler,e);
      return;
    }
    if (handler.versionNumber < VersionUtil.VERSION_3_2_19) {
      Map<String,String> nameMap=null;
      if (handler.module instanceof ReportDesign) {
        nameMap=(Map<String,String>)handler.tempValue.get(handler.module);
      }
 else {
        Theme theme=handler.module.getTheme(handler.module);
        if (theme != null) {
          nameMap=(Map<String,String>)handler.tempValue.get(theme);
        }
      }
      if (nameMap != null && nameMap.get(value) != null) {
        ((StyledElement)element).setStyleName(nameMap.get(value));
      }
 else {
        ((StyledElement)element).setStyleName((String)value);
      }
      if (value != null) {
        if (handler.styledElements == null)         handler.styledElements=new ArrayList<DesignElement>();
        handler.styledElements.add(element);
      }
    }
 else     ((StyledElement)element).setStyleName((String)value);
  }
 else   if (element instanceof OdaDataSet && QUERY_TEXT_MEMBER == nameValue && handler.versionNumber < VersionUtil.VERSION_3_2_19) {
    value=deEscape((String)value);
    setProperty(name,value);
  }
 else   if (handler.versionNumber >= VersionUtil.VERSION_3_2_16 && isXMLorScriptType(jmpDefn) && !ModelUtil.isExtensionPropertyOwnModel(jmpDefn)) {
    value=deEscape((String)value);
    setProperty(name,value);
  }
 else   if (IReportItemModel.ALTTEXT_PROP.equals(name)) {
    setProperty(name,new Expression(value,ExpressionType.CONSTANT));
  }
 else {
    setProperty(name,value);
  }
}",0.9662805662805662
64953,"/** 
 * Check if the expressions of category and Y optional have same dimension.
 * @param checkType
 * @param data
 * @param queryDefinitionsMap
 * @param itemHandle
 * @param provider
 * @since 2.5.1
 */
@SuppressWarnings(""String_Node_Str"") public static boolean checkQueryExpression(String checkType,Object data,Map<String,Query[]> queryDefinitionsMap,ExtendedItemHandle itemHandle,ReportDataServiceProvider provider){
  if (data == null || ""String_Node_Str"".equals(data)) {
    return true;
  }
  ExpressionCodec exprCodec=ChartModelHelper.instance().createExpressionCodec();
  String categoryDimension=null;
  String yOptionDimension=null;
  String categoryBindName=null;
  String yOptionBindName=null;
  String expression=(String)data;
  Iterator<ComputedColumnHandle> columnBindings=null;
  if (ChartReportItemHelper.instance().getBindingCubeHandle(itemHandle) != null && provider.isInheritanceOnly() || provider.isSharedBinding()) {
    ReportItemHandle reportItemHandle=provider.getReportItemHandle();
    columnBindings=reportItemHandle.getColumnBindings().iterator();
  }
 else   if (ChartReportItemHelper.instance().getBindingCubeHandle(itemHandle) != null || (provider.isInXTabMeasureCell() && !provider.isPartChart())) {
    columnBindings=getAllColumnBindingsIterator(itemHandle);
  }
  if (ChartUIConstants.QUERY_OPTIONAL.equals(checkType)) {
    String categoryExpr=null;
    Query[] querys=queryDefinitionsMap.get(ChartUIConstants.QUERY_CATEGORY);
    if (querys != null && querys.length > 0) {
      categoryExpr=querys[0].getDefinition();
    }
    if (categoryExpr == null || ""String_Node_Str"".equals(categoryExpr)) {
      return true;
    }
    categoryBindName=exprCodec.getCubeBindingName(categoryExpr,true);
    yOptionBindName=exprCodec.getCubeBindingName(expression,true);
  }
 else   if (ChartUIConstants.QUERY_CATEGORY.equals(checkType)) {
    String yOptionExpr=null;
    Query[] querys=queryDefinitionsMap.get(ChartUIConstants.QUERY_OPTIONAL);
    if (querys != null && querys.length > 0) {
      yOptionExpr=querys[0].getDefinition();
    }
    if (yOptionExpr == null || ""String_Node_Str"".equals(yOptionExpr)) {
      return true;
    }
    categoryBindName=exprCodec.getCubeBindingName(expression,true);
    yOptionBindName=exprCodec.getCubeBindingName(yOptionExpr,true);
  }
  if (columnBindings == null) {
    return true;
  }
  while (columnBindings.hasNext()) {
    ComputedColumnHandle columnHandle=columnBindings.next();
    ChartItemUtil.loadExpression(exprCodec,columnHandle);
    String bindName=columnHandle.getName();
    if (!exprCodec.isDimensionExpresion()) {
      continue;
    }
    if (bindName.equals(categoryBindName)) {
      categoryDimension=exprCodec.getLevelNames()[0];
    }
    if (bindName.equals(yOptionBindName)) {
      yOptionDimension=exprCodec.getLevelNames()[0];
    }
  }
  if ((categoryDimension != null && yOptionDimension != null && categoryDimension.equals(yOptionDimension))) {
    return false;
  }
 else {
    return true;
  }
}","/** 
 * Check if the expressions of category and Y optional have same dimension.
 * @param checkType
 * @param data
 * @param queryDefinitionsMap
 * @param itemHandle
 * @param provider
 * @since 2.5.1
 */
@SuppressWarnings(""String_Node_Str"") public static boolean checkQueryExpression(String checkType,Object data,Map<String,Query[]> queryDefinitionsMap,ExtendedItemHandle itemHandle,ReportDataServiceProvider provider){
  if (data == null || ""String_Node_Str"".equals(data)) {
    return true;
  }
  ExpressionCodec exprCodec=ChartReportItemHelper.instance().createExpressionCodec(itemHandle);
  String categoryDimension=null;
  String yOptionDimension=null;
  String categoryBindName=null;
  String yOptionBindName=null;
  String expression=(String)data;
  Iterator<ComputedColumnHandle> columnBindings=null;
  if (ChartReportItemHelper.instance().getBindingCubeHandle(itemHandle) != null && provider.isInheritanceOnly() || provider.isSharedBinding()) {
    ReportItemHandle reportItemHandle=provider.getReportItemHandle();
    columnBindings=reportItemHandle.getColumnBindings().iterator();
  }
 else   if (ChartReportItemHelper.instance().getBindingCubeHandle(itemHandle) != null || (provider.isInXTabMeasureCell() && !provider.isPartChart())) {
    columnBindings=getAllColumnBindingsIterator(itemHandle);
  }
  if (ChartUIConstants.QUERY_OPTIONAL.equals(checkType)) {
    String categoryExpr=null;
    Query[] querys=queryDefinitionsMap.get(ChartUIConstants.QUERY_CATEGORY);
    if (querys != null && querys.length > 0) {
      categoryExpr=querys[0].getDefinition();
    }
    if (categoryExpr == null || ""String_Node_Str"".equals(categoryExpr)) {
      return true;
    }
    categoryBindName=exprCodec.getCubeBindingName(categoryExpr,true);
    yOptionBindName=exprCodec.getCubeBindingName(expression,true);
  }
 else   if (ChartUIConstants.QUERY_CATEGORY.equals(checkType)) {
    String yOptionExpr=null;
    Query[] querys=queryDefinitionsMap.get(ChartUIConstants.QUERY_OPTIONAL);
    if (querys != null && querys.length > 0) {
      yOptionExpr=querys[0].getDefinition();
    }
    if (yOptionExpr == null || ""String_Node_Str"".equals(yOptionExpr)) {
      return true;
    }
    categoryBindName=exprCodec.getCubeBindingName(expression,true);
    yOptionBindName=exprCodec.getCubeBindingName(yOptionExpr,true);
  }
  if (columnBindings == null) {
    return true;
  }
  while (columnBindings.hasNext()) {
    ComputedColumnHandle columnHandle=columnBindings.next();
    ChartReportItemHelper.instance().loadExpression(exprCodec,columnHandle);
    String bindName=columnHandle.getName();
    if (!exprCodec.isDimensionExpresion()) {
      continue;
    }
    if (bindName.equals(categoryBindName)) {
      categoryDimension=exprCodec.getLevelNames()[0];
    }
    if (bindName.equals(yOptionBindName)) {
      yOptionDimension=exprCodec.getLevelNames()[0];
    }
  }
  if ((categoryDimension != null && yOptionDimension != null && categoryDimension.equals(yOptionDimension))) {
    return false;
  }
 else {
    return true;
  }
}",0.9913992722461132
64954,"private Chart getConvertedChart(Chart currentChart,String sNewSubType,Orientation newOrientation,String sNewDimension){
  Chart helperModel=currentChart.copyInstance();
  helperModel.eAdapters().addAll(currentChart.eAdapters());
  ChartCacheManager.getInstance().cacheSeries(ChartUIUtil.getAllOrthogonalSeriesDefinitions(helperModel));
  IChartType oldType=ChartUIUtil.getChartType(currentChart.getType());
  if ((currentChart instanceof ChartWithAxes)) {
    if (currentChart.getType().equals(TYPE_LITERAL)) {
      if (!currentChart.getSubType().equals(sNewSubType)) {
        currentChart.setSubType(sNewSubType);
        EList<Axis> axes=((ChartWithAxes)currentChart).getAxes().get(0).getAssociatedAxes();
        for (int i=0; i < axes.size(); i++) {
          axes.get(i).setPercent(false);
          EList<SeriesDefinition> seriesdefinitions=axes.get(i).getSeriesDefinitions();
          for (int j=0; j < seriesdefinitions.size(); j++) {
            Series series=seriesdefinitions.get(j).getDesignTimeSeries();
            series.unsetStacked();
          }
        }
      }
      ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",newOrientation,newOrientation == null);
      try {
        ChartElementUtil.setDefaultValue(currentChart,""String_Node_Str"",Orientation.HORIZONTAL_LITERAL);
      }
 catch (      ChartException e) {
      }
      return currentChart;
    }
 else     if (currentChart.getType().equals(LineChart.TYPE_LITERAL) || currentChart.getType().equals(AreaChart.TYPE_LITERAL) || currentChart.getType().equals(BarChart.TYPE_LITERAL)|| currentChart.getType().equals(TubeChart.TYPE_LITERAL)|| currentChart.getType().equals(ConeChart.TYPE_LITERAL)|| currentChart.getType().equals(PyramidChart.TYPE_LITERAL)|| currentChart.getType().equals(ScatterChart.TYPE_LITERAL)|| currentChart.getType().equals(StockChart.TYPE_LITERAL)|| currentChart.getType().equals(BubbleChart.TYPE_LITERAL)|| currentChart.getType().equals(DifferenceChart.TYPE_LITERAL)) {
      currentChart.setType(TYPE_LITERAL);
      currentChart.setSubType(sNewSubType);
      Text title=currentChart.getTitle().getLabel().getCaption();
      if (title.getValue() != null && (title.getValue().trim().length() == 0 || title.getValue().trim().equals(oldType.getDefaultTitle().trim()))) {
        title.setValue(getDefaultTitle());
      }
      EList<Axis> axes=((ChartWithAxes)currentChart).getAxes().get(0).getAssociatedAxes();
      for (int i=0, seriesIndex=0; i < axes.size(); i++) {
        axes.get(i).setPercent(false);
        axes.get(i).setType(AxisType.DATE_TIME_LITERAL);
        EList<SeriesDefinition> seriesdefinitions=axes.get(i).getSeriesDefinitions();
        for (int j=0; j < seriesdefinitions.size(); j++) {
          Series series=seriesdefinitions.get(j).getDesignTimeSeries();
          series=getConvertedSeries(series,seriesIndex++);
          series.unsetStacked();
          seriesdefinitions.get(j).getSeries().clear();
          seriesdefinitions.get(j).getSeries().add(series);
        }
      }
      currentChart.setSampleData(getConvertedSampleData(currentChart.getSampleData(),((ChartWithAxes)currentChart).getAxes().get(0).getType(),AxisType.DATE_TIME_LITERAL));
    }
 else {
      return null;
    }
  }
 else {
    currentChart=ChartWithAxesImpl.createDefault();
    copyChartProperties(helperModel,currentChart);
    currentChart.setType(TYPE_LITERAL);
    currentChart.setSubType(sNewSubType);
    ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",newOrientation,newOrientation == null);
    ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",getDimensionFor(sNewDimension),sNewDimension == null);
    try {
      ChartElementUtil.setDefaultValue(currentChart,""String_Node_Str"",Orientation.HORIZONTAL_LITERAL);
      ChartElementUtil.setDefaultValue(((ChartWithAxes)currentChart).getAxes().get(0),""String_Node_Str"",true);
    }
 catch (    ChartException e) {
    }
    Axis xAxis=((ChartWithAxes)currentChart).getAxes().get(0);
    Axis yAxis=xAxis.getAssociatedAxes().get(0);
    currentChart.setSampleData(getConvertedSampleData(currentChart.getSampleData(),((ChartWithAxes)currentChart).getAxes().get(0).getType(),AxisType.DATE_TIME_LITERAL));
{
      xAxis.getSeriesDefinitions().clear();
      xAxis.getSeriesDefinitions().add(((ChartWithoutAxes)helperModel).getSeriesDefinitions().get(0));
      yAxis.getSeriesDefinitions().clear();
      yAxis.getSeriesDefinitions().addAll(xAxis.getSeriesDefinitions().get(0).getSeriesDefinitions());
      yAxis.setType(AxisType.DATE_TIME_LITERAL);
      Series series=xAxis.getSeriesDefinitions().get(0).getDesignTimeSeries();
      xAxis.getSeriesDefinitions().get(0).getSeries().clear();
      xAxis.getSeriesDefinitions().get(0).getSeries().add(series);
      EList<SeriesDefinition> seriesdefinitions=yAxis.getSeriesDefinitions();
      for (int j=0; j < seriesdefinitions.size(); j++) {
        series=seriesdefinitions.get(j).getDesignTimeSeries();
        series=getConvertedSeries(series,j);
        series.getLabel().unsetVisible();
        series.unsetStacked();
        seriesdefinitions.get(j).getSeries().clear();
        seriesdefinitions.get(j).getSeries().add(series);
      }
    }
    Text title=currentChart.getTitle().getLabel().getCaption();
    if (title.getValue() != null && (title.getValue().trim().length() == 0 || title.getValue().trim().equals(oldType.getDefaultTitle().trim()))) {
      title.setValue(getDefaultTitle());
    }
  }
  ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",newOrientation,newOrientation == null);
  try {
    ChartElementUtil.setDefaultValue(currentChart,""String_Node_Str"",Orientation.HORIZONTAL_LITERAL);
  }
 catch (  ChartException e) {
  }
  ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",getDimensionFor(sNewDimension),sNewDimension == null);
  ChartUIUtil.updateDefaultAggregations(currentChart);
  return currentChart;
}","private Chart getConvertedChart(Chart currentChart,String sNewSubType,Orientation newOrientation,String sNewDimension){
  Chart helperModel=currentChart.copyInstance();
  helperModel.eAdapters().addAll(currentChart.eAdapters());
  ChartCacheManager.getInstance().cacheSeries(ChartUIUtil.getAllOrthogonalSeriesDefinitions(helperModel));
  IChartType oldType=ChartUIUtil.getChartType(currentChart.getType());
  if ((currentChart instanceof ChartWithAxes)) {
    if (currentChart.getType().equals(TYPE_LITERAL)) {
      if (!currentChart.getSubType().equals(sNewSubType)) {
        currentChart.setSubType(sNewSubType);
        EList<Axis> axes=((ChartWithAxes)currentChart).getAxes().get(0).getAssociatedAxes();
        for (int i=0; i < axes.size(); i++) {
          axes.get(i).setPercent(false);
          EList<SeriesDefinition> seriesdefinitions=axes.get(i).getSeriesDefinitions();
          for (int j=0; j < seriesdefinitions.size(); j++) {
            Series series=seriesdefinitions.get(j).getDesignTimeSeries();
            series.unsetStacked();
          }
        }
      }
      ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",newOrientation,newOrientation == null);
      try {
        ChartElementUtil.setDefaultValue(currentChart,""String_Node_Str"",Orientation.HORIZONTAL_LITERAL);
      }
 catch (      ChartException e) {
      }
      ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",getDimensionFor(sNewDimension),sNewDimension == null);
      return currentChart;
    }
 else     if (currentChart.getType().equals(LineChart.TYPE_LITERAL) || currentChart.getType().equals(AreaChart.TYPE_LITERAL) || currentChart.getType().equals(BarChart.TYPE_LITERAL)|| currentChart.getType().equals(TubeChart.TYPE_LITERAL)|| currentChart.getType().equals(ConeChart.TYPE_LITERAL)|| currentChart.getType().equals(PyramidChart.TYPE_LITERAL)|| currentChart.getType().equals(ScatterChart.TYPE_LITERAL)|| currentChart.getType().equals(StockChart.TYPE_LITERAL)|| currentChart.getType().equals(BubbleChart.TYPE_LITERAL)|| currentChart.getType().equals(DifferenceChart.TYPE_LITERAL)) {
      currentChart.setType(TYPE_LITERAL);
      currentChart.setSubType(sNewSubType);
      Text title=currentChart.getTitle().getLabel().getCaption();
      if (title.getValue() != null && (title.getValue().trim().length() == 0 || title.getValue().trim().equals(oldType.getDefaultTitle().trim()))) {
        title.setValue(getDefaultTitle());
      }
      EList<Axis> axes=((ChartWithAxes)currentChart).getAxes().get(0).getAssociatedAxes();
      for (int i=0, seriesIndex=0; i < axes.size(); i++) {
        axes.get(i).setPercent(false);
        axes.get(i).setType(AxisType.DATE_TIME_LITERAL);
        EList<SeriesDefinition> seriesdefinitions=axes.get(i).getSeriesDefinitions();
        for (int j=0; j < seriesdefinitions.size(); j++) {
          Series series=seriesdefinitions.get(j).getDesignTimeSeries();
          series=getConvertedSeries(series,seriesIndex++);
          series.unsetStacked();
          seriesdefinitions.get(j).getSeries().clear();
          seriesdefinitions.get(j).getSeries().add(series);
        }
      }
      currentChart.setSampleData(getConvertedSampleData(currentChart.getSampleData(),((ChartWithAxes)currentChart).getAxes().get(0).getType(),AxisType.DATE_TIME_LITERAL));
    }
 else {
      return null;
    }
  }
 else {
    currentChart=ChartWithAxesImpl.createDefault();
    copyChartProperties(helperModel,currentChart);
    currentChart.setType(TYPE_LITERAL);
    currentChart.setSubType(sNewSubType);
    ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",newOrientation,newOrientation == null);
    ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",getDimensionFor(sNewDimension),sNewDimension == null);
    try {
      ChartElementUtil.setDefaultValue(currentChart,""String_Node_Str"",Orientation.HORIZONTAL_LITERAL);
      ChartElementUtil.setDefaultValue(((ChartWithAxes)currentChart).getAxes().get(0),""String_Node_Str"",true);
    }
 catch (    ChartException e) {
    }
    Axis xAxis=((ChartWithAxes)currentChart).getAxes().get(0);
    Axis yAxis=xAxis.getAssociatedAxes().get(0);
    currentChart.setSampleData(getConvertedSampleData(currentChart.getSampleData(),((ChartWithAxes)currentChart).getAxes().get(0).getType(),AxisType.DATE_TIME_LITERAL));
{
      xAxis.getSeriesDefinitions().clear();
      xAxis.getSeriesDefinitions().add(((ChartWithoutAxes)helperModel).getSeriesDefinitions().get(0));
      yAxis.getSeriesDefinitions().clear();
      yAxis.getSeriesDefinitions().addAll(xAxis.getSeriesDefinitions().get(0).getSeriesDefinitions());
      yAxis.setType(AxisType.DATE_TIME_LITERAL);
      Series series=xAxis.getSeriesDefinitions().get(0).getDesignTimeSeries();
      xAxis.getSeriesDefinitions().get(0).getSeries().clear();
      xAxis.getSeriesDefinitions().get(0).getSeries().add(series);
      EList<SeriesDefinition> seriesdefinitions=yAxis.getSeriesDefinitions();
      for (int j=0; j < seriesdefinitions.size(); j++) {
        series=seriesdefinitions.get(j).getDesignTimeSeries();
        series=getConvertedSeries(series,j);
        series.getLabel().unsetVisible();
        series.unsetStacked();
        seriesdefinitions.get(j).getSeries().clear();
        seriesdefinitions.get(j).getSeries().add(series);
      }
    }
    Text title=currentChart.getTitle().getLabel().getCaption();
    if (title.getValue() != null && (title.getValue().trim().length() == 0 || title.getValue().trim().equals(oldType.getDefaultTitle().trim()))) {
      title.setValue(getDefaultTitle());
    }
  }
  ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",newOrientation,newOrientation == null);
  try {
    ChartElementUtil.setDefaultValue(currentChart,""String_Node_Str"",Orientation.HORIZONTAL_LITERAL);
  }
 catch (  ChartException e) {
  }
  ChartElementUtil.setEObjectAttribute(currentChart,""String_Node_Str"",getDimensionFor(sNewDimension),sNewDimension == null);
  ChartUIUtil.updateDefaultAggregations(currentChart);
  return currentChart;
}",0.989270564750894
64955,"Composite createCustomControl(Composite parent){
  ScrolledComposite scrollContent=new ScrolledComposite(parent,SWT.H_SCROLL | SWT.V_SCROLL);
  scrollContent.setAlwaysShowScrollBars(false);
  scrollContent.setExpandHorizontal(true);
  scrollContent.setLayout(new FillLayout());
  Composite content=new Composite(scrollContent,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.numColumns=4;
  layout.marginBottom=300;
  content.setLayout(layout);
  GridData gridData;
  new Label(content,SWT.RIGHT).setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  driverChooserCombo=new ComboViewer(content,SWT.DROP_DOWN);
  gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.horizontalSpan=3;
  driverChooserCombo.getControl().setLayoutData(gridData);
  List driverListTmp1=JdbcToolKit.getJdbcDriversFromODADir(JDBC_EXTENSION_ID);
  JDBCDriverInformation[] driverListTmp2=JDBCDriverInfoManager.getDrivers();
  List driverList=new ArrayList();
  for (  Object driverInfo : driverListTmp1) {
    if (needCheckHide(driverListTmp2,(JDBCDriverInformation)driverInfo)) {
      if (!((JDBCDriverInformation)driverInfo).getHide()) {
        driverList.add(driverInfo);
      }
    }
 else {
      driverList.add(driverInfo);
    }
  }
  driverChooserCombo.setContentProvider(new IStructuredContentProvider(){
    public Object[] getElements(    Object inputElement){
      if (inputElement != null) {
        return ((ArrayList)inputElement).toArray();
      }
      return new JDBCDriverInformation[]{};
    }
    public void dispose(){
    }
    public void inputChanged(    Viewer viewer,    Object oldInput,    Object newInput){
    }
  }
);
  driverChooserCombo.setLabelProvider(new LabelProvider(){
    public String getText(    Object inputElement){
      JDBCDriverInformation info=(JDBCDriverInformation)inputElement;
      return info.getDisplayString();
    }
  }
);
  driverChooserCombo.setInput(sortDriverList(driverList));
  driverChooserCombo.addSelectionChangedListener(new ISelectionChangedListener(){
    private String driverClassName;
    public void selectionChanged(    SelectionChangedEvent event){
      StructuredSelection selection=(StructuredSelection)event.getSelection();
      final JDBCDriverInformation info=(JDBCDriverInformation)selection.getFirstElement();
      String className=(info != null) ? info.getDriverClassName() : EMPTY_STRING;
      if (className.equalsIgnoreCase(driverClassName) == true)       return;
      driverClassName=className;
      if (info != null) {
        if (info.getUrlFormat() != null) {
          jdbcUrl.setText(info.getUrlFormat());
        }
 else {
          jdbcUrl.setText(EMPTY_STRING);
        }
        ((GridData)porpertyGroupComposite.getLayoutData()).exclude=true;
        porpertyGroupComposite.setVisible(false);
        porpertyGroupComposite.getParent().layout();
        Control[] children=porpertyGroupComposite.getChildren();
        for (int i=0; i < children.length; i++) {
          children[i].dispose();
        }
        if (info.hasProperty()) {
          drawPropertyGroups(info);
        }
        porpertyGroupComposite.getParent().layout();
      }
      jndiName.setText(EMPTY_STRING);
      userName.setText(EMPTY_STRING);
      password.setText(EMPTY_STRING);
      updateTestButton();
    }
    private void drawPropertyGroups(    final JDBCDriverInformation info){
      ((GridData)porpertyGroupComposite.getLayoutData()).exclude=false;
      porpertyGroupComposite.setVisible(true);
      ((GridData)porpertyGroupComposite.getLayoutData()).heightHint=SWT.DEFAULT;
      databaseProperties.clear();
      List<PropertyGroup> propertyGroups=info.getPropertyGroup();
      for (Iterator it=propertyGroups.iterator(); it.hasNext(); ) {
        PropertyGroup group=(PropertyGroup)(it.next());
        String propertyGroupName=group.getName();
        List<PropertyElement> propertyList=group.getProperties();
        Group propertyGroup=drawPropertyGroup(propertyGroupName == null ? EMPTY_STRING : propertyGroupName);
        for (int i=0; i < propertyList.size(); i++) {
          final String propertyName=propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_NAME);
          Label propertyParam=new Label(propertyGroup,SWT.NONE);
          String propertyParamDisplayName=propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_DISPLAYNAME);
          if (propertyParamDisplayName == null) {
            propertyParamDisplayName=propertyName;
          }
          propertyParam.setText(propertyParamDisplayName);
          propertyParam.setToolTipText(propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_DEC));
          GridData gd=new GridData();
          gd.horizontalSpan=2;
          propertyParam.setLayoutData(gd);
          String propertyContent=null;
          if (profileProperties != null && !profileProperties.isEmpty()) {
            propertyContent=getProfileproperty(propertyName);
          }
          if (Constants.DRIVER_INFO_PROPERTY_TYPE_BOOLEN.equalsIgnoreCase(propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_TYPE))) {
            drawPropertyCombo(propertyGroup,propertyName,propertyContent);
          }
 else {
            if (Boolean.valueOf(propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_ENCRYPT))) {
              drawPropertyText(propertyGroup,propertyName,propertyContent,true);
            }
 else             drawPropertyText(propertyGroup,propertyName,propertyContent,false);
          }
        }
        propertyGroup.getParent().layout();
      }
    }
    private void drawPropertyText(    Group propertyGroup,    final String propertyName,    String propertyContent,    boolean encrypt){
      GridData gd;
      final Text propertyText;
      if (encrypt) {
        propertyText=new Text(propertyGroup,SWT.BORDER | SWT.PASSWORD);
      }
 else {
        propertyText=new Text(propertyGroup,SWT.BORDER);
      }
      boolean isEncryptionMethod=Constants.DRIVER_INFO_PROPERTY_ENCRYPTION_METHOD.equals(propertyName);
      if (propertyContent != null) {
        propertyText.setText(propertyContent);
        databaseProperties.put(propertyName,propertyContent);
      }
 else       if (isEncryptionMethod) {
        propertyText.setText(ENCRYTPION_METHOD_DEFAULT_VALUE);
      }
      gd=new GridData(GridData.FILL_HORIZONTAL);
      gd.horizontalSpan=3;
      propertyText.setLayoutData(gd);
      if (isEncryptionMethod) {
        Label blankLabel=new Label(propertyGroup,SWT.NONE);
        GridData blankLabelGd=new GridData();
        blankLabelGd.horizontalSpan=2;
        blankLabel.setLayoutData(blankLabelGd);
        Label prompLabel=new Label(propertyGroup,SWT.NONE);
        prompLabel.setText(JdbcPlugin.getResourceString(""String_Node_Str""));
        GridData labelGd=new GridData(GridData.FILL_HORIZONTAL);
        labelGd.horizontalSpan=3;
        prompLabel.setLayoutData(labelGd);
      }
      propertyText.addModifyListener(new ModifyListener(){
        public void modifyText(        ModifyEvent e){
          databaseProperties.put(propertyName,propertyText.getText());
        }
      }
);
      propertyText.getParent().layout();
    }
    private void drawPropertyCombo(    Group propertyGroup,    final String propertyName,    String propertyContent){
      GridData gd;
      final Combo propertyField=new Combo(propertyGroup,SWT.BORDER | SWT.READ_ONLY);
      propertyField.setItems(new String[]{EMPTY_STRING,""String_Node_Str"",""String_Node_Str""});
      if (propertyContent != null) {
        propertyField.setText(propertyContent);
        databaseProperties.put(propertyName,propertyContent);
      }
 else       propertyField.setText(EMPTY_STRING);
      propertyField.addSelectionListener(new SelectionListener(){
        public void widgetSelected(        SelectionEvent arg0){
          if (propertyField.getSelectionIndex() == 1) {
            databaseProperties.put(propertyName,""String_Node_Str"");
          }
 else           if (propertyField.getSelectionIndex() == 2) {
            databaseProperties.put(propertyName,""String_Node_Str"");
          }
 else {
            databaseProperties.put(propertyName,EMPTY_STRING);
          }
        }
        public void widgetDefaultSelected(        SelectionEvent arg0){
          databaseProperties.put(propertyName,EMPTY_STRING);
        }
      }
);
      gd=new GridData(GridData.FILL_HORIZONTAL);
      gd.horizontalSpan=3;
      gd.horizontalAlignment=SWT.FILL;
      propertyField.setLayoutData(gd);
      propertyField.getParent().layout();
    }
    private Group drawPropertyGroup(    String propertyGroupName){
      GridData gridData;
      Group propertyGroup=new Group(porpertyGroupComposite,SWT.NONE);
      gridData=new GridData(GridData.FILL_HORIZONTAL | GridData.GRAB_HORIZONTAL);
      gridData.horizontalSpan=4;
      gridData.horizontalAlignment=SWT.FILL;
      propertyGroup.setText(propertyGroupName);
      propertyGroup.setLayoutData(gridData);
      GridLayout layout=new GridLayout();
      layout.marginWidth=layout.marginHeight=0;
      layout.numColumns=5;
      Layout parentLayout=porpertyGroupComposite.getParent().getLayout();
      if (parentLayout instanceof GridLayout)       layout.horizontalSpacing=((GridLayout)parentLayout).horizontalSpacing;
      propertyGroup.setLayout(layout);
      return propertyGroup;
    }
    private String getProfileproperty(    String propertyName){
      return profileProperties.getProperty(propertyName);
    }
  }
);
  new Label(content,SWT.RIGHT).setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  jdbcUrl=new Text(content,SWT.BORDER);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  jdbcUrl.setLayoutData(gridData);
  new Label(content,SWT.RIGHT).setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  userName=new Text(content,SWT.BORDER);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.FILL;
  userName.setLayoutData(gridData);
  new Label(content,SWT.RIGHT).setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  password=new Text(content,SWT.BORDER | SWT.PASSWORD);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.FILL;
  password.setLayoutData(gridData);
  String jndiLabel=JdbcPlugin.getResourceString(""String_Node_Str"");
  new Label(content,SWT.RIGHT).setText(jndiLabel);
  jndiName=new Text(content,SWT.BORDER);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.FILL;
  jndiName.setLayoutData(gridData);
  createPropertiesComposite(content);
  manageButton=new Button(content,SWT.PUSH);
  manageButton.setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  testButton=new Button(content,SWT.PUSH);
  testButton.setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  testButton.setLayoutData(new GridData(GridData.CENTER));
  Point size=content.computeSize(SWT.DEFAULT,SWT.DEFAULT);
  content.setSize(size.x,size.y);
  scrollContent.setMinWidth(size.x + 10);
  scrollContent.setContent(content);
  addControlListeners();
  updateTestButton();
  verifyJDBCProperties();
  Utility.setSystemHelp(getControl(),IHelpConstants.CONEXT_ID_DATASOURCE_JDBC);
  return content;
}","Composite createCustomControl(Composite parent){
  ScrolledComposite scrollContent=new ScrolledComposite(parent,SWT.H_SCROLL | SWT.V_SCROLL);
  scrollContent.setAlwaysShowScrollBars(false);
  scrollContent.setExpandHorizontal(true);
  scrollContent.setLayout(new FillLayout());
  Composite content=new Composite(scrollContent,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.numColumns=4;
  layout.marginBottom=300;
  content.setLayout(layout);
  GridData gridData;
  new Label(content,SWT.RIGHT).setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  driverChooserCombo=new ComboViewer(content,SWT.DROP_DOWN);
  gridData=new GridData(GridData.FILL_HORIZONTAL);
  gridData.horizontalSpan=3;
  driverChooserCombo.getControl().setLayoutData(gridData);
  List driverListTmp1=JdbcToolKit.getJdbcDriversFromODADir(JDBC_EXTENSION_ID);
  JDBCDriverInformation[] driverListTmp2=JDBCDriverInfoManager.getDrivers();
  List driverList=new ArrayList();
  for (  Object driverInfo : driverListTmp1) {
    if (needCheckHide(driverListTmp2,(JDBCDriverInformation)driverInfo)) {
      if (!((JDBCDriverInformation)driverInfo).getHide()) {
        driverList.add(driverInfo);
      }
    }
 else {
      driverList.add(driverInfo);
    }
  }
  driverChooserCombo.setContentProvider(new IStructuredContentProvider(){
    public Object[] getElements(    Object inputElement){
      if (inputElement != null) {
        return ((ArrayList)inputElement).toArray();
      }
      return new JDBCDriverInformation[]{};
    }
    public void dispose(){
    }
    public void inputChanged(    Viewer viewer,    Object oldInput,    Object newInput){
    }
  }
);
  driverChooserCombo.setLabelProvider(new LabelProvider(){
    public String getText(    Object inputElement){
      JDBCDriverInformation info=(JDBCDriverInformation)inputElement;
      return info.getDisplayString();
    }
  }
);
  driverChooserCombo.setInput(sortDriverList(driverList));
  driverChooserCombo.addSelectionChangedListener(new ISelectionChangedListener(){
    private String driverClassName;
    public void selectionChanged(    SelectionChangedEvent event){
      StructuredSelection selection=(StructuredSelection)event.getSelection();
      final JDBCDriverInformation info=(JDBCDriverInformation)selection.getFirstElement();
      String className=(info != null) ? info.getDriverClassName() : EMPTY_STRING;
      if (className.equalsIgnoreCase(driverClassName) == true)       return;
      driverClassName=className;
      if (info != null) {
        if (info.getUrlFormat() != null) {
          jdbcUrl.setText(info.getUrlFormat());
        }
 else {
          jdbcUrl.setText(EMPTY_STRING);
        }
        ((GridData)porpertyGroupComposite.getLayoutData()).exclude=true;
        porpertyGroupComposite.setVisible(false);
        porpertyGroupComposite.getParent().layout();
        Control[] children=porpertyGroupComposite.getChildren();
        for (int i=0; i < children.length; i++) {
          children[i].dispose();
        }
        if (info.hasProperty()) {
          drawPropertyGroups(info);
        }
        porpertyGroupComposite.getParent().layout();
      }
      jndiName.setText(EMPTY_STRING);
      userName.setText(EMPTY_STRING);
      password.setText(EMPTY_STRING);
      updateTestButton();
    }
    private void drawPropertyGroups(    final JDBCDriverInformation info){
      ((GridData)porpertyGroupComposite.getLayoutData()).exclude=false;
      porpertyGroupComposite.setVisible(true);
      ((GridData)porpertyGroupComposite.getLayoutData()).heightHint=SWT.DEFAULT;
      databaseProperties.clear();
      List<PropertyGroup> propertyGroups=info.getPropertyGroup();
      for (Iterator it=propertyGroups.iterator(); it.hasNext(); ) {
        PropertyGroup group=(PropertyGroup)(it.next());
        String propertyGroupName=group.getName();
        List<PropertyElement> propertyList=group.getProperties();
        Group propertyGroup=drawPropertyGroup(propertyGroupName == null ? EMPTY_STRING : propertyGroupName);
        for (int i=0; i < propertyList.size(); i++) {
          final String propertyName=propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_NAME);
          Label propertyParam=new Label(propertyGroup,SWT.NONE);
          String propertyParamDisplayName=propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_DISPLAYNAME);
          if (propertyParamDisplayName == null) {
            propertyParamDisplayName=propertyName;
          }
          propertyParam.setText(propertyParamDisplayName);
          propertyParam.setToolTipText(propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_DEC));
          GridData gd=new GridData();
          gd.horizontalSpan=2;
          propertyParam.setLayoutData(gd);
          String propertyContent=null;
          if (profileProperties != null && !profileProperties.isEmpty()) {
            propertyContent=getProfileproperty(propertyName);
          }
          if (Constants.DRIVER_INFO_PROPERTY_TYPE_BOOLEN.equalsIgnoreCase(propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_TYPE))) {
            drawPropertyCombo(propertyGroup,propertyName,propertyContent);
          }
 else {
            if (Boolean.valueOf(propertyList.get(i).getAttribute(Constants.DRIVER_INFO_PROPERTY_ENCRYPT))) {
              drawPropertyText(propertyGroup,propertyName,propertyContent,true);
            }
 else             drawPropertyText(propertyGroup,propertyName,propertyContent,false);
          }
        }
        propertyGroup.getParent().layout();
      }
    }
    private void drawPropertyText(    Group propertyGroup,    final String propertyName,    String propertyContent,    boolean encrypt){
      GridData gd;
      final Text propertyText;
      if (encrypt) {
        propertyText=new Text(propertyGroup,SWT.BORDER | SWT.PASSWORD);
      }
 else {
        propertyText=new Text(propertyGroup,SWT.BORDER);
      }
      boolean isEncryptionMethod=Constants.DRIVER_INFO_PROPERTY_ENCRYPTION_METHOD.equals(propertyName);
      if (propertyContent != null) {
        propertyText.setText(propertyContent);
        databaseProperties.put(propertyName,propertyContent);
      }
 else       if (isEncryptionMethod) {
        propertyText.setText(ENCRYTPION_METHOD_DEFAULT_VALUE);
      }
      gd=new GridData(GridData.FILL_HORIZONTAL);
      gd.horizontalSpan=3;
      propertyText.setLayoutData(gd);
      if (isEncryptionMethod) {
        Label blankLabel=new Label(propertyGroup,SWT.NONE);
        GridData blankLabelGd=new GridData();
        blankLabelGd.horizontalSpan=2;
        blankLabel.setLayoutData(blankLabelGd);
        Label prompLabel=new Label(propertyGroup,SWT.NONE);
        prompLabel.setText(JdbcPlugin.getResourceString(""String_Node_Str""));
        GridData labelGd=new GridData(GridData.FILL_HORIZONTAL);
        labelGd.horizontalSpan=3;
        prompLabel.setLayoutData(labelGd);
      }
      propertyText.addModifyListener(new ModifyListener(){
        public void modifyText(        ModifyEvent e){
          databaseProperties.put(propertyName,propertyText.getText());
        }
      }
);
      propertyText.getParent().layout();
    }
    private void drawPropertyCombo(    Group propertyGroup,    final String propertyName,    String propertyContent){
      GridData gd;
      final Combo propertyField=new Combo(propertyGroup,SWT.BORDER | SWT.READ_ONLY);
      propertyField.setItems(new String[]{EMPTY_STRING,""String_Node_Str"",""String_Node_Str""});
      if (propertyContent != null) {
        propertyField.setText(propertyContent);
        databaseProperties.put(propertyName,propertyContent);
      }
 else       propertyField.setText(EMPTY_STRING);
      propertyField.addSelectionListener(new SelectionListener(){
        public void widgetSelected(        SelectionEvent arg0){
          if (propertyField.getSelectionIndex() == 1) {
            databaseProperties.put(propertyName,""String_Node_Str"");
          }
 else           if (propertyField.getSelectionIndex() == 2) {
            databaseProperties.put(propertyName,""String_Node_Str"");
          }
 else {
            databaseProperties.put(propertyName,EMPTY_STRING);
          }
        }
        public void widgetDefaultSelected(        SelectionEvent arg0){
          databaseProperties.put(propertyName,EMPTY_STRING);
        }
      }
);
      gd=new GridData(GridData.FILL_HORIZONTAL);
      gd.horizontalSpan=3;
      gd.horizontalAlignment=SWT.FILL;
      propertyField.setLayoutData(gd);
      propertyField.getParent().layout();
    }
    private Group drawPropertyGroup(    String propertyGroupName){
      GridData gridData;
      Group propertyGroup=new Group(porpertyGroupComposite,SWT.NONE);
      gridData=new GridData(GridData.FILL_HORIZONTAL | GridData.GRAB_HORIZONTAL);
      gridData.horizontalSpan=4;
      gridData.horizontalAlignment=SWT.FILL;
      propertyGroup.setText(propertyGroupName);
      propertyGroup.setLayoutData(gridData);
      GridLayout layout=new GridLayout();
      layout.marginWidth=layout.marginHeight=0;
      layout.numColumns=5;
      Layout parentLayout=porpertyGroupComposite.getParent().getLayout();
      if (parentLayout instanceof GridLayout)       layout.horizontalSpacing=((GridLayout)parentLayout).horizontalSpacing;
      propertyGroup.setLayout(layout);
      return propertyGroup;
    }
    private String getProfileproperty(    String propertyName){
      return profileProperties.getProperty(propertyName);
    }
  }
);
  new Label(content,SWT.RIGHT).setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  jdbcUrl=new Text(content,SWT.BORDER);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  jdbcUrl.setLayoutData(gridData);
  new Label(content,SWT.RIGHT).setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  userName=new Text(content,SWT.BORDER);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.FILL;
  userName.setLayoutData(gridData);
  new Label(content,SWT.RIGHT).setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  password=new Text(content,SWT.BORDER | SWT.PASSWORD);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.FILL;
  password.setLayoutData(gridData);
  String jndiLabel=JdbcPlugin.getResourceString(""String_Node_Str"");
  new Label(content,SWT.RIGHT).setText(jndiLabel);
  jndiName=new Text(content,SWT.BORDER);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.FILL;
  jndiName.setLayoutData(gridData);
  createPropertiesComposite(content);
  manageButton=new Button(content,SWT.PUSH);
  manageButton.setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  testButton=new Button(content,SWT.PUSH);
  testButton.setText(JdbcPlugin.getResourceString(""String_Node_Str""));
  testButton.setLayoutData(new GridData(GridData.CENTER));
  Point size=content.computeSize(SWT.DEFAULT,SWT.DEFAULT);
  content.setSize(size.x,size.y);
  scrollContent.setExpandHorizontal(true);
  scrollContent.setMinWidth(size.x + 20);
  scrollContent.setExpandVertical(true);
  scrollContent.setMinHeight(size.y + 20);
  scrollContent.setContent(content);
  addControlListeners();
  updateTestButton();
  verifyJDBCProperties();
  Utility.setSystemHelp(getControl(),IHelpConstants.CONEXT_ID_DATASOURCE_JDBC);
  return content;
}",0.9943204332320698
64956,"/** 
 * @throws IOException
 */
abstract protected void saveToDisk(int fromIndex,int toIndex) throws IOException ;","/** 
 * @throws IOException
 */
protected void saveToDisk(int fromIndex,int toIndex) throws IOException {
  throw new UnsupportedOperationException();
}",0.7894736842105263
64957,"/** 
 * @param o
 * @return
 * @throws IOException
 */
public void push(Object o) throws IOException {
  if (bufferPos < buffer.length) {
    buffer[bufferPos]=o;
    bufferPos++;
  }
 else   if (useMemoryOnly) {
    Object tempBuffer[]=new Object[buffer.length * 2];
    System.arraycopy(buffer,0,tempBuffer,0,buffer.length);
    buffer=tempBuffer;
    buffer[bufferPos]=o;
    bufferPos++;
  }
 else {
    sort(buffer);
    if (forceDistinct) {
      int endIndex=removeDuplicated(buffer);
      saveToDisk(0,endIndex);
    }
 else {
      saveToDisk(0,buffer.length - 1);
    }
    buffer[0]=o;
    bufferPos=1;
  }
  size++;
}","/** 
 * @param o
 * @return
 * @throws IOException
 */
public void push(Object o) throws IOException {
  if (bufferPos < buffer.length) {
    buffer[bufferPos]=o;
    bufferPos++;
  }
 else   if (useMemoryOnly) {
    Object tempBuffer[]=new Object[buffer.length * 2];
    System.arraycopy(buffer,0,tempBuffer,0,buffer.length);
    buffer=tempBuffer;
    buffer[bufferPos]=o;
    bufferPos++;
  }
 else {
    sort(buffer);
    if (this.segments.size() < MAX_NUMBER_OF_SEGMENT) {
      int endIndex=buffer.length - 1;
      if (forceDistinct) {
        endIndex=removeDuplicated(buffer);
      }
      saveToDisk(0,endIndex);
    }
 else {
      BaseDiskSortedStack temp=new BaseDiskSortedStack(this.forceDistinct,segments,this.comparator,this.buffer,this.bufferPos);
      BaseDiskArray diskArray=this.creator == null ? new PrimitiveDiskArray() : new StructureDiskArray(this.creator);
      Object next=null;
      while ((next=temp.pop()) != null) {
        diskArray.add(next);
      }
      temp.close();
      this.segments.clear();
      this.segments.add(diskArray);
    }
    buffer[0]=o;
    bufferPos=1;
  }
  size++;
}",0.6875355719977234
64958,"/** 
 * @param bufferSize
 * @param forceDistinct
 * @param comparator
 */
public BaseDiskSortedStack(int bufferSize,boolean forceDistinct,Comparator comparator){
  if (bufferSize <= 0) {
    buffer=new Object[DEFAULT_BUFFER_SIZE];
  }
 else {
    buffer=new Object[bufferSize];
  }
  segments=new ArrayList();
  this.comparator=comparator;
  this.forceDistinct=forceDistinct;
  mValueIndex=new ValueIndex(null,0,comparator);
  this.size=0;
}","private BaseDiskSortedStack(boolean forceDistinct,List segments,Comparator comparator,Object[] buffer,int bufferPos){
  this.forceDistinct=forceDistinct;
  this.segments=segments;
  this.comparator=comparator;
  this.buffer=buffer;
  this.bufferPos=bufferPos;
  this.mValueIndex=new ValueIndex(null,0,comparator);
}",0.3355350066050198
64959,"public DiskSortedStack(int bufferSize,boolean forceDistinct,Comparator comparator,IStructureCreator creator){
  super(bufferSize,forceDistinct,comparator);
  this.creator=creator;
}","public DiskSortedStack(int bufferSize,boolean forceDistinct,Comparator comparator,IStructureCreator creator){
  super(bufferSize,forceDistinct,comparator,creator);
  this.creator=creator;
}",0.9783783783783784
64960,"public PrimitiveDiskSortedStack(int bufferSize,boolean forceDistinct,Comparator comparator){
  super(bufferSize,forceDistinct,comparator);
}","public PrimitiveDiskSortedStack(int bufferSize,boolean forceDistinct,Comparator comparator){
  super(bufferSize,forceDistinct,comparator,null);
}",0.9824561403508772
64961,"private static Date getDate(int year,int month,int day,int hours,int minutes,int seconds){
  Date newDate=new Date();
  Calendar calendar=getCalendar(newDate);
  calendar.set(year,month,day,hours,minutes,seconds);
  return calendar.getTime();
}","private static Date getDate(int year,int month,int day,int hours,int minutes,int seconds){
  Date newDate=new Date();
  Calendar calendar=getCalendar(newDate);
  calendar.set(year,month,day,hours,minutes,seconds);
  calendar.set(Calendar.MILLISECOND,0);
  return calendar.getTime();
}",0.9242424242424242
64962,"/** 
 * Find a connection available for new statements in the pool, or create a new one if none available 
 */
private CacheConnection getAvailableConnection() throws DataException {
  Iterator it=this.getOdaConnections(true).iterator();
  while (it.hasNext()) {
    CacheConnection c=(CacheConnection)(it.next());
    if (c.odaConn.isOpen() && c.currentStatements < c.maxStatements)     return c;
  }
  return newConnection();
}","/** 
 * Find a connection available for new statements in the pool, or create a new one if none available 
 */
public CacheConnection getAvailableConnection() throws DataException {
  Iterator it=this.getOdaConnections(true).iterator();
  while (it.hasNext()) {
    CacheConnection c=(CacheConnection)(it.next());
    if (c.odaConn.isOpen() && c.currentStatements < c.maxStatements)     return c;
  }
  return newConnection();
}",0.9871645274212368
64963,"public void close(){
  releaseDataSource();
}","public void close() throws DataException {
  if (odaConn != null) {
    odaConn.close();
    odaConn=null;
  }
}",0.4076433121019108
64964,"public void doCancel(){
synchronized (cancellableList) {
    for (    ICancellable cancellable : cancellableList) {
      if (cancellable.doCancel())       cancellable.cancel();
    }
  }
}","public void doCancel(){
synchronized (cancellableList) {
    List<ICancellable> cancellableLists=new ArrayList<ICancellable>(cancellableList);
    for (    ICancellable cancellable : cancellableLists) {
      if (cancellable.doCancel())       cancellable.cancel();
    }
  }
}",0.8129032258064516
64965,"public void cancel() throws OdaException, UnsupportedOperationException {
  throw new UnsupportedOperationException();
}","public void cancel() throws OdaException, UnsupportedOperationException {
  try {
    if (this.callStat != null)     this.callStat.cancel();
  }
 catch (  Exception e) {
  }
  try {
    if (this.conn != null) {
      this.conn.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    IConnectionPoolManager manager=ConnectionPoolFactory.getInstance();
    if (manager != null)     manager.closeConnection(this.conn);
  }
 catch (  Exception e) {
  }
}",0.3170731707317073
64966,"public void cancel() throws OdaException {
  try {
    if (this.preStat != null) {
      System.out.println(""String_Node_Str"");
      this.preStat.cancel();
    }
  }
 catch (  SQLException e) {
    throw new OdaException(e);
  }
}","public void cancel() throws OdaException {
  try {
    if (this.preStat != null) {
      this.preStat.cancel();
    }
  }
 catch (  Exception e) {
  }
  try {
    if (this.conn != null) {
      this.conn.close();
    }
  }
 catch (  Exception e) {
  }
  try {
    IConnectionPoolManager manager=ConnectionPoolFactory.getInstance();
    if (manager != null)     manager.closeConnection(this.conn);
  }
 catch (  Exception e) {
  }
}",0.3867069486404834
64967,"public void stop(BundleContext context) throws Exception {
  plugin=null;
  super.stop(context);
}","public void stop(BundleContext context) throws Exception {
  plugin=null;
  ClassLoaderProvider.releaseInstance();
  super.stop(context);
}",0.8270042194092827
64968,"private URLClassLoader getPojoDataSetClassLoader() throws OdaException {
  URLParser up=new URLParser(appContext);
  URL[] urls=up.parse(pojoDataSetClassPath);
  logger.log(Level.INFO,""String_Node_Str"" + Arrays.toString(urls) + ""String_Node_Str"");
  return new URLClassLoader(urls,Activator.class.getClassLoader());
}","private URLClassLoader getPojoDataSetClassLoader() throws OdaException {
  URLParser up=new URLParser(appContext);
  URL[] urls=up.parse(pojoDataSetClassPath);
  logger.log(Level.INFO,""String_Node_Str"" + Arrays.toString(urls) + ""String_Node_Str"");
  URLClassLoader loader=ClassLoaderProvider.getInstance().getClassLoader(urls);
  return loader;
}",0.7662141779788839
64969,"public void close() throws OdaException {
  currentRowId=0;
  if (pojoDataSet != null) {
    pojoDataSet.close();
  }
  if (pojoClassLoader != null) {
    pojoClassLoader.close();
  }
}","public void close() throws OdaException {
  currentRowId=0;
  if (pojoDataSet != null) {
    pojoDataSet.close();
  }
}",0.7828947368421053
64970,"private String enableURI(String location){
  String result=location.replace(""String_Node_Str"",""String_Node_Str"");
  if (File.separatorChar != '/') {
    result=result.replace(File.separatorChar,'/');
  }
  if (!result.endsWith(""String_Node_Str"") && !result.endsWith(""String_Node_Str"")) {
    if (result.charAt(result.length() - 1) != '/') {
      result+=""String_Node_Str"";
    }
  }
  return result;
}","/** 
 * @param location
 * @return
 */
private String enableURI(String location){
  String result=location;
  try {
    if (File.separatorChar != '/')     location=location.replace(File.separatorChar,'/');
    if (location.startsWith(""String_Node_Str"")) {
      result=new File(location).toURI().toASCIIString().replace(new File(""String_Node_Str"").toURI().toASCIIString(),""String_Node_Str"");
    }
 else     result=new File(location).toURI().toASCIIString().replace(new File(""String_Node_Str"").toURI().toASCIIString(),""String_Node_Str"");
  }
 catch (  Exception e) {
    return location;
  }
  return result;
}",0.3181818181818182
64971,"/** 
 * parse <code>classPath</code> into an array containing <code>java.net.URL<code>
 * @param classPath : each path is separated with <code>Constants.CLASS_PATH_SEPERATOR</code>
 * @return
 * @throws OdaException if error/exception occur during parsing
 */
public URL[] parse(String classPath) throws OdaException {
  if (classPath == null) {
    return new URL[0];
  }
  String[] paths=classPath.split(String.valueOf(Constants.CLASS_PATH_SEPERATOR));
  List<URL> urls=new ArrayList<URL>();
  for (  String path : paths) {
    path=path.trim();
    if (path.equals(""String_Node_Str"")) {
      continue;
    }
    URI uri=null;
    if ((new File(path)).isAbsolute()) {
      uri=new File(path).toURI();
      try {
        urls.add(uri.toURL());
      }
 catch (      MalformedURLException e) {
        throw new OdaException(e);
      }
    }
 else {
      try {
        uri=new URI(enableURI(path));
      }
 catch (      URISyntaxException e) {
        throw new OdaException(e);
      }
      URI resovledUri=null;
      if (resourceIdentifiers != null) {
        resovledUri=ResourceIdentifiers.resolveApplResource(resourceIdentifiers,uri);
        if (resovledUri == null) {
          logger.log(Level.WARNING,""String_Node_Str"" + uri + ""String_Node_Str""+ ResourceIdentifiers.getApplResourceBaseURI(resourceIdentifiers)+ ')');
          resovledUri=ResourceIdentifiers.resolveDesignResource(resourceIdentifiers,uri);
        }
      }
      if (resovledUri == null) {
        logger.log(Level.WARNING,""String_Node_Str"" + uri);
      }
 else {
        try {
          urls.add(resovledUri.toURL());
        }
 catch (        MalformedURLException e) {
          throw new OdaException(e);
        }
      }
    }
  }
  return urls.toArray(new URL[0]);
}","/** 
 * parse <code>classPath</code> into an array containing <code>java.net.URL<code>
 * @param classPath : each path is separated with <code>Constants.CLASS_PATH_SEPERATOR</code>
 * @return
 * @throws OdaException if error/exception occur during parsing
 */
public URL[] parse(String classPath) throws OdaException {
  if (classPath == null) {
    return new URL[0];
  }
  String[] paths=classPath.split(String.valueOf(Constants.CLASS_PATH_SEPERATOR));
  List<URL> urls=new ArrayList<URL>();
  for (  String path : paths) {
    path=path.trim();
    if (path.equals(""String_Node_Str"")) {
      continue;
    }
    URI uri=null;
    if ((new File(path)).isAbsolute()) {
      uri=new File(path).toURI();
      try {
        urls.add(uri.toURL());
      }
 catch (      MalformedURLException e) {
        throw new OdaException(e);
      }
    }
 else {
      try {
        uri=new URI(resolveURI(path));
      }
 catch (      URISyntaxException e) {
        throw new OdaException(e);
      }
      if (resourceIdentifiers != null) {
        URI resovledUri=ResourceIdentifiers.resolveApplResource(resourceIdentifiers,uri);
        if (resovledUri == null) {
          logger.log(Level.WARNING,""String_Node_Str"" + uri + ""String_Node_Str""+ ResourceIdentifiers.getApplResourceBaseURI(resourceIdentifiers)+ ')');
          resovledUri=ResourceIdentifiers.resolveDesignResource(resourceIdentifiers,uri);
        }
        if (resovledUri == null) {
          logger.log(Level.WARNING,""String_Node_Str"" + uri);
        }
 else {
          try {
            try {
              String urlpath=enableURI(URLDecoder.decode(resovledUri.toString(),""String_Node_Str""));
              urls.add(new URL(urlpath));
            }
 catch (            UnsupportedEncodingException e) {
              urls.add(resovledUri.toURL());
            }
          }
 catch (          MalformedURLException e) {
            throw new OdaException(e);
          }
        }
      }
 else {
        try {
          urls.add(uri.toURL());
        }
 catch (        MalformedURLException e) {
          throw new OdaException(e);
        }
      }
    }
  }
  return urls.toArray(new URL[0]);
}",0.8728014274789702
64972,"public static IQueryDefinition getOptimizedIVQuery(IBaseQueryDefinition oldq,IQueryDefinition newq,String queryResultID) throws DataException {
  if (oldq == null || newq == null)   return null;
  if (!QueryCompUtil.isEqualBindings(oldq.getBindings(),newq.getBindings()))   return null;
  if (!QueryCompUtil.isEqualGroups(oldq.getGroups(),newq.getGroups(),true))   return null;
  if (!QueryCompUtil.isEqualSorts(oldq.getSorts(),newq.getSorts()))   return null;
  List<IFilterDefinition> filters=getEffectiveFilters(oldq.getFilters(),newq.getFilters());
  if (filters == null)   return null;
  NoRecalculateIVQuery query=new NoRecalculateIVQuery(newq,oldq,new LinkedList<ISortDefinition>(),filters,new LinkedList(),queryResultID);
  return query;
}","public static IQueryDefinition getOptimizedIVQuery(IBaseQueryDefinition oldq,IQueryDefinition newq,String queryResultID) throws DataException {
  if (oldq == null || newq == null)   return null;
  if (!QueryCompUtil.isEqualBindings(oldq.getBindings(),newq.getBindings()))   return null;
  if (!QueryCompUtil.isEqualGroups(oldq.getGroups(),newq.getGroups(),true))   return null;
  if (!QueryCompUtil.isEqualSorts(oldq.getSorts(),newq.getSorts()))   return null;
  List<IFilterDefinition> filters=getEffectiveFilters(oldq.getFilters(),newq.getFilters());
  if (filters == null)   return null;
  NoRecalculateIVQuery query=new NoRecalculateIVQuery(newq,oldq,new LinkedList<ISortDefinition>(),filters,newq.getGroups(),queryResultID);
  return query;
}",0.9852744310575636
64973,"@SuppressWarnings(""String_Node_Str"") public IPreparedDSQuery prepare() throws DataException {
  if (odaStatement != null)   throw new DataException(ResourceConstants.QUERY_HAS_PREPARED);
  populateQuerySpecification();
  if (this.querySpecificaton != null && this.querySpecificaton.getBaseQuery() instanceof CombinedQuery) {
    odaStatement=dataSource.prepareStatement(null,queryType,this.querySpecificaton);
  }
 else {
    odaStatement=dataSource.prepareStatement(queryText,queryType,this.querySpecificaton);
  }
  addPropertiesToPreparedStatement();
  addParameterDefns();
  odaStatement.setMaxRows(this.getRowFetchLimit());
  IOdaDataSetDesign design=null;
  if (session.getDataSetCacheManager().getCurrentDataSetDesign() instanceof IOdaDataSetDesign)   design=(IOdaDataSetDesign)session.getDataSetCacheManager().getCurrentDataSetDesign();
  ICancellable queryCanceller=new OdaQueryCanceller(odaStatement,session.getStopSign());
  if (design != null) {
    if (canAccessResultSetByName(design)) {
      addCustomFields(design.getPrimaryResultSetName(),odaStatement);
      addColumnHints(design.getPrimaryResultSetName(),odaStatement);
      if (this.projectedFields != null)       odaStatement.setColumnsProjection(design.getPrimaryResultSetName(),this.projectedFields);
    }
 else     if (canAccessResultSetByNumber(design)) {
      addCustomFields(design.getPrimaryResultSetNumber(),odaStatement);
      addColumnHints(design.getPrimaryResultSetNumber(),odaStatement);
      if (this.projectedFields != null)       odaStatement.setColumnsProjection(design.getPrimaryResultSetNumber(),this.projectedFields);
    }
 else {
      this.session.getCancelManager().register(queryCanceller);
      if (!session.getStopSign().isStopped()) {
        prepareColumns();
      }
      this.session.getCancelManager().deregister(queryCanceller);
    }
  }
 else {
    this.session.getCancelManager().register(queryCanceller);
    if (!session.getStopSign().isStopped()) {
      prepareColumns();
    }
    this.session.getCancelManager().deregister(queryCanceller);
  }
  try {
    this.session.getCancelManager().register(queryCanceller);
    if (!session.getStopSign().isStopped())     resultMetadata=getMetaData((IOdaDataSetDesign)session.getDataSetCacheManager().getCurrentDataSetDesign(),odaStatement);
    if (design != null) {
      List modelResultHints=design.getResultSetHints();
      resultMetadata=mergeResultHint(modelResultHints,resultMetadata);
    }
    if (queryCanceller.collectException() != null) {
      if (!(queryCanceller.collectException().getCause() instanceof UnsupportedOperationException))       throw queryCanceller.collectException();
    }
    this.session.getCancelManager().deregister(queryCanceller);
  }
 catch (  DataException e) {
    resultMetadata=null;
  }
  return this;
}","@SuppressWarnings(""String_Node_Str"") public IPreparedDSQuery prepare() throws DataException {
  long start=System.currentTimeMillis();
  if (odaStatement != null)   throw new DataException(ResourceConstants.QUERY_HAS_PREPARED);
  populateQuerySpecification();
  if (this.querySpecificaton != null && this.querySpecificaton.getBaseQuery() instanceof CombinedQuery) {
    odaStatement=dataSource.prepareStatement(null,queryType,this.querySpecificaton);
  }
 else {
    odaStatement=dataSource.prepareStatement(queryText,queryType,this.querySpecificaton);
  }
  addPropertiesToPreparedStatement();
  addParameterDefns();
  odaStatement.setMaxRows(this.getRowFetchLimit());
  IOdaDataSetDesign design=null;
  if (session.getDataSetCacheManager().getCurrentDataSetDesign() instanceof IOdaDataSetDesign)   design=(IOdaDataSetDesign)session.getDataSetCacheManager().getCurrentDataSetDesign();
  ICancellable queryCanceller=new OdaQueryCanceller(odaStatement,session.getStopSign());
  if (design != null) {
    if (canAccessResultSetByName(design)) {
      addCustomFields(design.getPrimaryResultSetName(),odaStatement);
      addColumnHints(design.getPrimaryResultSetName(),odaStatement);
      if (this.projectedFields != null)       odaStatement.setColumnsProjection(design.getPrimaryResultSetName(),this.projectedFields);
    }
 else     if (canAccessResultSetByNumber(design)) {
      addCustomFields(design.getPrimaryResultSetNumber(),odaStatement);
      addColumnHints(design.getPrimaryResultSetNumber(),odaStatement);
      if (this.projectedFields != null)       odaStatement.setColumnsProjection(design.getPrimaryResultSetNumber(),this.projectedFields);
    }
 else {
      this.session.getCancelManager().register(queryCanceller);
      if (!session.getStopSign().isStopped()) {
        prepareColumns();
      }
      this.session.getCancelManager().deregister(queryCanceller);
    }
  }
 else {
    this.session.getCancelManager().register(queryCanceller);
    if (!session.getStopSign().isStopped()) {
      prepareColumns();
    }
    this.session.getCancelManager().deregister(queryCanceller);
  }
  try {
    this.session.getCancelManager().register(queryCanceller);
    if (!session.getStopSign().isStopped())     resultMetadata=getMetaData((IOdaDataSetDesign)session.getDataSetCacheManager().getCurrentDataSetDesign(),odaStatement);
    if (design != null) {
      List modelResultHints=design.getResultSetHints();
      resultMetadata=mergeResultHint(modelResultHints,resultMetadata);
    }
    if (queryCanceller.collectException() != null) {
      if (!(queryCanceller.collectException().getCause() instanceof UnsupportedOperationException))       throw queryCanceller.collectException();
    }
    this.session.getCancelManager().deregister(queryCanceller);
  }
 catch (  DataException e) {
    resultMetadata=null;
  }
  logger.fine(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
  return this;
}",0.9767199444058374
64974,"/** 
 * @return
 * @throws IOException
 */
private long getOffset() throws IOException {
  return randomAccessFile.getFilePointer();
}","/** 
 * @return
 * @throws IOException
 */
private long getOffset() throws IOException {
  return getRandomAccessFile().getFilePointer();
}",0.9743589743589745
64975,"/** 
 * @throws IOException
 */
public BaseDiskArray() throws IOException {
  this.currentCacheStartIndex=0;
  this.size=0;
  this.buffer=new Object[bufferSize];
  this.segmentOffsets=new ArrayList<Long>();
  this.segmentOffsets.add(Long.valueOf(0L));
  createRandomAccessFile();
  DataEngineThreadLocal.getInstance().getCloseListener().add(this);
}","/** 
 * @throws IOException
 */
public BaseDiskArray() throws IOException {
  this.currentCacheStartIndex=0;
  this.size=0;
  this.buffer=new Object[bufferSize];
  this.segmentOffsets=new ArrayList<Long>();
  this.segmentOffsets.add(Long.valueOf(0L));
  DataEngineThreadLocal.getInstance().getCloseListener().add(this);
}",0.9582089552238806
64976,"/** 
 * Reads up to <code>readSize</code> objects from disk.
 * @param dis
 * @param list
 * @return
 * @throws IOException
 */
private void readObjects(long offset,int readSize) throws IOException {
  this.randomAccessFile.seek(offset);
  for (int i=0; i < readSize; i++) {
    this.buffer[i]=readObject();
  }
}","/** 
 * Reads up to <code>readSize</code> objects from disk.
 * @param dis
 * @param list
 * @return
 * @throws IOException
 */
private void readObjects(long offset,int readSize) throws IOException {
  getRandomAccessFile().seek(offset);
  for (int i=0; i < readSize; i++) {
    this.buffer[i]=readObject();
  }
}",0.9808306709265175
64977,"protected void writeObject(Object object) throws IOException {
  if (object == null) {
    randomAccessFile.writeShort(NULL_VALUE);
    return;
  }
  randomAccessFile.writeShort(NORMAL_VALUE);
  if (fieldWriter == null) {
    fieldWriter=IOUtil.getRandomWriter(DataType.getDataType(object.getClass()));
    fieldReader=IOUtil.getRandomReader(DataType.getDataType(object.getClass()));
  }
  fieldWriter.write(randomAccessFile,object);
}","protected void writeObject(Object object) throws IOException {
  if (object == null) {
    getRandomAccessFile().writeShort(NULL_VALUE);
    return;
  }
  getRandomAccessFile().writeShort(NORMAL_VALUE);
  if (fieldWriter == null) {
    fieldWriter=IOUtil.getRandomWriter(DataType.getDataType(object.getClass()));
    fieldReader=IOUtil.getRandomReader(DataType.getDataType(object.getClass()));
  }
  fieldWriter.write(getRandomAccessFile(),object);
}",0.976271186440678
64978,"protected Object readObject() throws IOException {
  short fieldCount=randomAccessFile.readShort();
  if (fieldCount == NULL_VALUE) {
    return null;
  }
  return fieldReader.read(randomAccessFile);
}","protected Object readObject() throws IOException {
  short fieldCount=getRandomAccessFile().readShort();
  if (fieldCount == NULL_VALUE) {
    return null;
  }
  return fieldReader.read(getRandomAccessFile());
}",0.9660194174757282
64979,"protected void writeObject(Object object) throws IOException {
  if (object == null) {
    randomAccessFile.writeShort(NULL_VALUE);
    return;
  }
  IStructure cachedObject=(IStructure)object;
  Object[] objects=cachedObject.getFieldValues();
  randomAccessFile.writeShort((short)objects.length);
  if (fieldWriters == null || fieldWriters.length < objects.length) {
    createReadersAndWriters(objects.length);
  }
  for (int i=0; i < objects.length; i++) {
    if (i >= fieldWriters.length) {
      fieldWriters[fieldWriters.length - 1].write(randomAccessFile,objects[i]);
    }
 else {
      fieldWriters[i].write(randomAccessFile,objects[i]);
    }
  }
}","protected void writeObject(Object object) throws IOException {
  if (object == null) {
    getRandomAccessFile().writeShort(NULL_VALUE);
    return;
  }
  IStructure cachedObject=(IStructure)object;
  Object[] objects=cachedObject.getFieldValues();
  getRandomAccessFile().writeShort((short)objects.length);
  if (fieldWriters == null || fieldWriters.length < objects.length) {
    createReadersAndWriters(objects.length);
  }
  for (int i=0; i < objects.length; i++) {
    if (i >= fieldWriters.length) {
      fieldWriters[fieldWriters.length - 1].write(getRandomAccessFile(),objects[i]);
    }
 else {
      fieldWriters[i].write(getRandomAccessFile(),objects[i]);
    }
  }
}",0.9790732436472348
64980,"protected Object readObject() throws IOException {
  short fieldCount=randomAccessFile.readShort();
  if (fieldCount == NULL_VALUE) {
    return null;
  }
  Object[] objects=new Object[fieldCount];
  for (int i=0; i < objects.length; i++) {
    if (i < fieldReaders.length && fieldReaders[i].getDataType() != fieldWriters[i].getDataType())     fieldReaders[i].setDataType(fieldWriters[i].getDataType());
    if (i >= fieldReaders.length) {
      objects[i]=fieldReaders[fieldReaders.length - 1].read(randomAccessFile);
    }
 else {
      objects[i]=fieldReaders[i].read(randomAccessFile);
    }
  }
  return creator.createInstance(objects);
}","protected Object readObject() throws IOException {
  short fieldCount=getRandomAccessFile().readShort();
  if (fieldCount == NULL_VALUE) {
    return null;
  }
  Object[] objects=new Object[fieldCount];
  for (int i=0; i < objects.length; i++) {
    if (i < fieldReaders.length && fieldReaders[i].getDataType() != fieldWriters[i].getDataType())     fieldReaders[i].setDataType(fieldWriters[i].getDataType());
    if (i >= fieldReaders.length) {
      objects[i]=fieldReaders[fieldReaders.length - 1].read(getRandomAccessFile());
    }
 else {
      objects[i]=fieldReaders[i].read(getRandomAccessFile());
    }
  }
  return creator.createInstance(objects);
}",0.9838585703305148
64981,"public IParameterDefn[] getParameterDefn(){
  IParameterDefn paramDefn[]=new IParameterDefn[]{new ParameterDefn(Constants.EXPRESSION_NAME,Constants.EXPRESSION_DISPLAY_NAME,false,true,SupportedDataTypes.ANY,Messages.getString(""String_Node_Str"")),new ParameterDefn(Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),true,false,SupportedDataTypes.CALCULATABLE,Messages.getString(""String_Node_Str"")),new ParameterDefn(Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),true,false,SupportedDataTypes.CALCULATABLE,Messages.getString(""String_Node_Str"")),new ParameterDefn(Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),true,false,SupportedDataTypes.CALCULATABLE,Messages.getString(""String_Node_Str""))};
  return paramDefn;
}","public IParameterDefn[] getParameterDefn(){
  IParameterDefn paramDefn[]=new IParameterDefn[]{new ParameterDefn(Constants.EXPRESSION_NAME,Constants.EXPRESSION_DISPLAY_NAME,false,true,SupportedDataTypes.ANY,Messages.getString(""String_Node_Str"")),new ParameterDefn(Constants.SEPARATOR_NAME,Constants.SEPARATOR_DISPLAY_NAME,true,false,SupportedDataTypes.CALCULATABLE,Messages.getString(""String_Node_Str"")),new ParameterDefn(Constants.MAXLENGTH_NAME,Constants.MAXLENGTH__DISPLAY_NAME,true,false,SupportedDataTypes.CALCULATABLE,Messages.getString(""String_Node_Str"")),new ParameterDefn(Constants.SHOWALLVALUES_NAME,Constants.SHOWALLVALUES_DISPLAY_NAME,true,false,SupportedDataTypes.CALCULATABLE,Messages.getString(""String_Node_Str""))};
  return paramDefn;
}",0.5765998707175177
64982,"/** 
 */
public void cancel(){
  try {
    this.statement.cancel();
  }
 catch (  DataException e) {
    this.exception=e;
  }
}","/** 
 */
public void cancel(){
  try {
    this.statement.cancel();
  }
 catch (  Exception e) {
    try {
      this.statement.close();
    }
 catch (    Exception e1) {
      this.exception=new DataException(e.getLocalizedMessage(),e);
    }
  }
}",0.5251989389920424
64983,"public IBinding adaptBinding(ComputedColumnHandle handle,ExpressionLocation el) throws AdapterException {
  if (el.equals(ExpressionLocation.TABLE)) {
    return this.adaptBinding(handle);
  }
 else {
    Binding binding=null;
    try {
      binding=new Binding(handle.getName());
      binding.setAggrFunction(handle.getAggregateFunction() == null ? null : DataAdapterUtil.adaptModelAggregationType(handle.getAggregateFunction()));
      binding.setDisplayName(handle.getExternalizedValue(org.eclipse.birt.report.model.api.elements.structures.ComputedColumn.DISPLAY_NAME_ID_MEMBER,org.eclipse.birt.report.model.api.elements.structures.ComputedColumn.DISPLAY_NAME_MEMBER,this.context.getDataEngineContext().getLocale()));
      binding.setExportable(handle.allowExport());
      if (handle.getElementHandle() instanceof ReportItemHandle && LinkedDataSetUtil.bindToLinkedDataSet(((ReportItemHandle)handle.getElementHandle()))) {
        binding.setExpression(adaptExpression((Expression)handle.getExpressionProperty(org.eclipse.birt.report.model.api.elements.structures.ComputedColumn.EXPRESSION_MEMBER).getValue(),ExpressionLocation.TABLE));
      }
 else {
        binding.setExpression(adaptExpression((Expression)handle.getExpressionProperty(org.eclipse.birt.report.model.api.elements.structures.ComputedColumn.EXPRESSION_MEMBER).getValue(),ExpressionLocation.CUBE));
      }
      binding.setDataType(DataAdapterUtil.adaptModelDataType(handle.getDataType()));
      if (handle.getFilterExpression() != null) {
        binding.setFilter(adaptExpression((Expression)handle.getExpressionProperty(org.eclipse.birt.report.model.api.elements.structures.ComputedColumn.FILTER_MEMBER).getValue(),ExpressionLocation.CUBE));
      }
      for (Iterator argItr=handle.argumentsIterator(); argItr.hasNext(); ) {
        AggregationArgumentHandle aah=(AggregationArgumentHandle)argItr.next();
        binding.addArgument(aah.getName(),adaptExpression((Expression)aah.getExpressionProperty(AggregationArgument.VALUE_MEMBER).getValue(),ExpressionLocation.CUBE));
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage(),e);
      return null;
    }
    try {
      binding.setTimeFunction(adaptTimeFunction(handle));
    }
 catch (    BirtException ex) {
      throw new AdapterException(ex.getLocalizedMessage());
    }
    return binding;
  }
}","public IBinding adaptBinding(ComputedColumnHandle handle,ExpressionLocation el) throws AdapterException {
  if (el.equals(ExpressionLocation.TABLE)) {
    return this.adaptBinding(handle);
  }
 else {
    Binding binding=null;
    try {
      binding=new Binding(handle.getName());
      binding.setAggrFunction(handle.getAggregateFunction() == null ? null : DataAdapterUtil.adaptModelAggregationType(handle.getAggregateFunction()));
      binding.setDisplayName(handle.getExternalizedValue(org.eclipse.birt.report.model.api.elements.structures.ComputedColumn.DISPLAY_NAME_ID_MEMBER,org.eclipse.birt.report.model.api.elements.structures.ComputedColumn.DISPLAY_NAME_MEMBER,this.context.getDataEngineContext().getLocale()));
      binding.setExportable(handle.allowExport());
      ExpressionLocation location=el;
      if (handle.getElementHandle() instanceof ReportItemHandle && LinkedDataSetUtil.bindToLinkedDataSet(((ReportItemHandle)handle.getElementHandle()))) {
        location=ExpressionLocation.TABLE;
      }
      binding.setExpression(adaptExpression((Expression)handle.getExpressionProperty(org.eclipse.birt.report.model.api.elements.structures.ComputedColumn.EXPRESSION_MEMBER).getValue(),location));
      if (handle.getFilterExpression() != null) {
        binding.setFilter(adaptExpression((Expression)handle.getExpressionProperty(org.eclipse.birt.report.model.api.elements.structures.ComputedColumn.FILTER_MEMBER).getValue(),location));
      }
      binding.setDataType(DataAdapterUtil.adaptModelDataType(handle.getDataType()));
      for (Iterator argItr=handle.argumentsIterator(); argItr.hasNext(); ) {
        AggregationArgumentHandle aah=(AggregationArgumentHandle)argItr.next();
        binding.addArgument(aah.getName(),adaptExpression((Expression)aah.getExpressionProperty(AggregationArgument.VALUE_MEMBER).getValue(),location));
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage(),e);
      return null;
    }
    try {
      binding.setTimeFunction(adaptTimeFunction(handle));
    }
 catch (    BirtException ex) {
      throw new AdapterException(ex.getLocalizedMessage());
    }
    return binding;
  }
}",0.8672839506172839
64984,"public int getSubQueryStartingIndex() throws DataException {
  if (!subQueryOnGroup)   return this.parentIterator.getCurrentResultIndex();
  int groupIndex=this.parentIterator.getCurrentGroupIndex(groupLevel);
  int[] groupStartingEndingIndex=this.parentIterator.getGroupStartAndEndIndex(groupLevel);
  return (this.parentExecutor instanceof ISubQueryExecutor) ? ((ISubQueryExecutor)this.parentExecutor).getSubQueryStartingIndex() + groupStartingEndingIndex[groupIndex * 2] : groupStartingEndingIndex[groupIndex * 2];
}","public int getSubQueryStartingIndex() throws DataException {
  if (!subQueryOnGroup)   return this.parentIterator.getCurrentResultIndex();
  if (parentIterator instanceof EmptyResultIterator)   return 0;
  int groupIndex=this.parentIterator.getCurrentGroupIndex(groupLevel);
  int[] groupStartingEndingIndex=this.parentIterator.getGroupStartAndEndIndex(groupLevel);
  return (this.parentExecutor instanceof ISubQueryExecutor) ? ((ISubQueryExecutor)this.parentExecutor).getSubQueryStartingIndex() + groupStartingEndingIndex[groupIndex * 2] : groupStartingEndingIndex[groupIndex * 2];
}",0.941069809610154
64985,"/** 
 * Splits text for fixed layout reports.
 */
private void splitText(){
  Integer taskType=(Integer)engine.getOption(EngineTask.TASK_TYPE);
  if (taskType.intValue() == IEngineTask.TASK_RENDER && context.isFixedLayout()) {
    SizeBasedContent sizeBasedContent=context.getPageHintManager().getSizeBasedContentMapping().get(content.getInstanceID().toUniqueString());
    if (sizeBasedContent == null || sizeBasedContent.dimension == -1) {
      return;
    }
    HtmlRegionArea container=new HtmlRegionArea();
    container.setWidth(sizeBasedContent.width);
    IReportContent report=content.getReportContent();
    IContainerContent containerContent=report.createContainerContent();
    containerContent.getChildren().add(content);
    LayoutContext pdfLayoutContext=new LayoutContext();
    pdfLayoutContext.setFormat(""String_Node_Str"");
    pdfLayoutContext.setFixedLayout(true);
    pdfLayoutContext.setInHtmlRender(true);
    pdfLayoutContext.setLocale(engine.locale);
    pdfLayoutContext.setHtmlLayoutContext(context);
    pdfLayoutContext.setMaxBP(Integer.MAX_VALUE);
    pdfLayoutContext.setReport(report);
    RegionLayoutEngine rle=new RegionLayoutEngine(container,pdfLayoutContext);
    try {
      rle.layout(containerContent);
    }
 catch (    BirtException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
}","/** 
 * Splits text for fixed layout reports.
 */
private void splitText(){
  Integer taskType=(Integer)engine.getOption(EngineTask.TASK_TYPE);
  if (taskType.intValue() == IEngineTask.TASK_RENDER && context.isFixedLayout()) {
    SizeBasedContent sizeBasedContent=context.getPageHintManager().getSizeBasedContentMapping().get(content.getInstanceID().toUniqueString());
    if (sizeBasedContent == null || sizeBasedContent.dimension == -1) {
      return;
    }
    HtmlRegionArea container=new HtmlRegionArea();
    container.setWidth(sizeBasedContent.width);
    IReportContent report=content.getReportContent();
    IContainerContent containerContent=report.createContainerContent();
    containerContent.getChildren().add(content);
    LayoutContext pdfLayoutContext=new LayoutContext();
    pdfLayoutContext.setFormat(""String_Node_Str"");
    pdfLayoutContext.setFixedLayout(true);
    pdfLayoutContext.setInHtmlRender(true);
    pdfLayoutContext.setLocale(engine.locale);
    pdfLayoutContext.setHtmlLayoutContext(context);
    pdfLayoutContext.setMaxBP(Integer.MAX_VALUE);
    pdfLayoutContext.setMaxHeight(Integer.MAX_VALUE);
    pdfLayoutContext.setReport(report);
    RegionLayoutEngine rle=new RegionLayoutEngine(container,pdfLayoutContext);
    try {
      rle.layout(containerContent);
    }
 catch (    BirtException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
}",0.9802775748721696
64986,"/** 
 * Tested cases: <ul> <li>The getProperty() algorithm. If the structure member has no local value, uses values of the referred style. <li>The back reference must be right for undo/redo. <li>The back reference must be right if the style member is set to a new value. <li>Circular references must throw exceptions. </ul>
 * @throws Exception
 */
public void testStyle() throws Exception {
  openDesign(inputFile);
  StyleHandle style2=designHandle.findStyle(""String_Node_Str"");
  StyleHandle style3=designHandle.findStyle(""String_Node_Str"");
  Iterator highlightRules=style2.highlightRulesIterator();
  assert(highlightRules.hasNext());
  HighlightRuleHandle style2Highlight=(HighlightRuleHandle)highlightRules.next();
  assertEquals(DesignChoiceConstants.TEXT_ALIGN_RIGHT,style2Highlight.getTextAlign());
  assertEquals(ColorPropertyType.RED,style2Highlight.getColor().getStringValue());
  assertNull(style2Highlight.getProperty(IStyleModel.HIGHLIGHT_RULES_PROP));
  assertNull(style2Highlight.getProperty(HighlightRule.VALUE2_MEMBER));
  StyleHandle style1=designHandle.findStyle(""String_Node_Str"");
  List refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(1,refs.size());
  BackRef ref1=(BackRef)refs.get(0);
  assertEquals(""String_Node_Str"",ref1.getElement().getName());
  assertEquals(HighlightRule.STYLE_MEMBER,ref1.getPropertyName());
  style2Highlight.drop();
  refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(0,refs.size());
  designHandle.getCommandStack().undo();
  refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(1,refs.size());
  designHandle.getCommandStack().redo();
  refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(0,refs.size());
  designHandle.getCommandStack().undo();
  style2Highlight.setStyle(style3);
  assertEquals(style3,style2Highlight.getStyle());
  refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(0,refs.size());
  refs=((ReferenceableElement)style3.getElement()).getClientList();
  assertEquals(1,refs.size());
  assertEquals(""String_Node_Str"",ref1.getElement().getName());
  assertEquals(HighlightRule.STYLE_MEMBER,ref1.getPropertyName());
  style2Highlight.setStyle(null);
  assertNull(style2Highlight.getStyle());
  assertNull(style2Highlight.getProperty(HighlightRule.STYLE_MEMBER));
  try {
    style2Highlight.setStyle(style2);
    fail();
  }
 catch (  SemanticException e) {
    assertEquals(SemanticError.DESIGN_EXCEPTION_CIRCULAR_ELEMENT_REFERNECE,e.getErrorCode());
  }
  style2Highlight.setStyle(style3);
  Iterator style3HighlightRules=style3.highlightRulesIterator();
  assertTrue(style3HighlightRules.hasNext());
  HighlightRuleHandle style3Highlight=(HighlightRuleHandle)style3HighlightRules.next();
  try {
    style3Highlight.setStyleName(""String_Node_Str"");
    fail();
  }
 catch (  SemanticException e) {
    assertEquals(SemanticError.DESIGN_EXCEPTION_CIRCULAR_ELEMENT_REFERNECE,e.getErrorCode());
  }
  HighlightRule newRule1=StructureFactory.createHighlightRule();
  newRule1.setProperty(HighlightRule.STYLE_MEMBER,""String_Node_Str"");
  try {
    style3.getPropertyHandle(StyleHandle.HIGHLIGHT_RULES_PROP).addItem(newRule1);
    fail();
  }
 catch (  SemanticException e) {
    assertEquals(SemanticError.DESIGN_EXCEPTION_CIRCULAR_ELEMENT_REFERNECE,e.getErrorCode());
  }
}","/** 
 * Tested cases: <ul> <li>The getProperty() algorithm. If the structure member has no local value, uses values of the referred style. <li>The back reference must be right for undo/redo. <li>The back reference must be right if the style member is set to a new value. <li>Circular references must throw exceptions. </ul>
 * @throws Exception
 */
public void testStyle() throws Exception {
  openDesign(inputFile);
  StyleHandle style2=designHandle.findStyle(""String_Node_Str"");
  StyleHandle style3=designHandle.findStyle(""String_Node_Str"");
  StyleHandle style4=designHandle.findStyle(""String_Node_Str"");
  Iterator highlightRules=style2.highlightRulesIterator();
  assert(highlightRules.hasNext());
  HighlightRuleHandle style2Highlight=(HighlightRuleHandle)highlightRules.next();
  assertEquals(DesignChoiceConstants.TEXT_ALIGN_RIGHT,style2Highlight.getTextAlign());
  assertEquals(ColorPropertyType.RED,style2Highlight.getColor().getStringValue());
  assertNull(style2Highlight.getProperty(IStyleModel.HIGHLIGHT_RULES_PROP));
  assertNull(style2Highlight.getProperty(HighlightRule.VALUE2_MEMBER));
  StyleHandle style1=designHandle.findStyle(""String_Node_Str"");
  List refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(1,refs.size());
  BackRef ref1=(BackRef)refs.get(0);
  assertEquals(""String_Node_Str"",ref1.getElement().getName());
  assertEquals(HighlightRule.STYLE_MEMBER,ref1.getPropertyName());
  style2Highlight.drop();
  refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(0,refs.size());
  designHandle.getCommandStack().undo();
  refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(1,refs.size());
  designHandle.getCommandStack().redo();
  refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(0,refs.size());
  designHandle.getCommandStack().undo();
  style2Highlight.setStyle(style3);
  assertEquals(style3,style2Highlight.getStyle());
  refs=((ReferenceableElement)style1.getElement()).getClientList();
  assertEquals(0,refs.size());
  refs=((ReferenceableElement)style3.getElement()).getClientList();
  assertEquals(1,refs.size());
  assertEquals(""String_Node_Str"",ref1.getElement().getName());
  assertEquals(HighlightRule.STYLE_MEMBER,ref1.getPropertyName());
  style2Highlight.setStyle(null);
  assertNull(style2Highlight.getStyle());
  assertNull(style2Highlight.getProperty(HighlightRule.STYLE_MEMBER));
  try {
    style2Highlight.setStyle(style2);
    fail();
  }
 catch (  SemanticException e) {
    assertEquals(SemanticError.DESIGN_EXCEPTION_CIRCULAR_ELEMENT_REFERNECE,e.getErrorCode());
  }
  style2Highlight.setStyle(style3);
  Iterator style3HighlightRules=style3.highlightRulesIterator();
  assertTrue(style3HighlightRules.hasNext());
  HighlightRuleHandle style3Highlight=(HighlightRuleHandle)style3HighlightRules.next();
  Iterator style4HighlightRules=style4.highlightRulesIterator();
  assertTrue(style4HighlightRules.hasNext());
  HighlightRuleHandle style4Highlight=(HighlightRuleHandle)style4HighlightRules.next();
  DimensionValue dv=(DimensionValue)style4Highlight.getLineHeight().getValue();
  assertEquals(10.0,dv.getMeasure());
  assertEquals(""String_Node_Str"",dv.getUnits());
  try {
    style3Highlight.setStyleName(""String_Node_Str"");
    fail();
  }
 catch (  SemanticException e) {
    assertEquals(SemanticError.DESIGN_EXCEPTION_CIRCULAR_ELEMENT_REFERNECE,e.getErrorCode());
  }
  HighlightRule newRule1=StructureFactory.createHighlightRule();
  newRule1.setProperty(HighlightRule.STYLE_MEMBER,""String_Node_Str"");
  try {
    style3.getPropertyHandle(StyleHandle.HIGHLIGHT_RULES_PROP).addItem(newRule1);
    fail();
  }
 catch (  SemanticException e) {
    assertEquals(SemanticError.DESIGN_EXCEPTION_CIRCULAR_ELEMENT_REFERNECE,e.getErrorCode());
  }
}",0.940410199556541
64987,"/** 
 * Convert an object to an locale neutral String value. For Date values we will convert to ISO8601 format.
 * @param source
 * @return
 * @throws BirtException
 */
public static String toLocaleNeutralString(Object source) throws BirtException {
  if (source == null)   return null;
  if (source instanceof Time) {
    return ((Time)source).toString();
  }
 else   if (source instanceof java.sql.Date) {
    return ((java.sql.Date)source).toString();
  }
 else   if (source instanceof Timestamp) {
    return ((java.sql.Timestamp)source).toString();
  }
 else   if (source instanceof Date) {
    return DateFormatISO8601.format((Date)source);
  }
 else   if (source instanceof Number) {
    return ((Number)source).toString();
  }
 else {
    return toLimitedSizeString(source);
  }
}","/** 
 * Convert an object to an locale neutral String value. For Date values we will convert to ISO8601 format. This will always output default(current) time zone.
 * @param source
 * @return
 * @throws BirtException
 */
public static String toLocaleNeutralString(Object source) throws BirtException {
  if (source == null)   return null;
  if (source instanceof Time) {
    return ((Time)source).toString();
  }
 else   if (source instanceof java.sql.Date) {
    return ((java.sql.Date)source).toString();
  }
 else   if (source instanceof Timestamp) {
    return ((java.sql.Timestamp)source).toString();
  }
 else   if (source instanceof Date) {
    return DateFormatISO8601.format((Date)source);
  }
 else   if (source instanceof Number) {
    return ((Number)source).toString();
  }
 else {
    return toLimitedSizeString(source);
  }
}",0.968058968058968
64988,"/** 
 * Parse a date/time string.
 * @param source
 * @return
 * @throws ParseException
 */
public static String format(Date date) throws BirtException {
  String result=null;
  if (date == null) {
    return null;
  }
  Object simpleDateFormatter=DateFormatFactory.getPatternInstance(PatternKey.getPatterKey(""String_Node_Str""));
  if (simpleDateFormatter != null) {
    try {
      result=((SimpleDateFormat)simpleDateFormatter).format(date);
      return result;
    }
 catch (    Exception e1) {
    }
  }
  throw new CoreException(ResourceConstants.CONVERT_FAILS,new Object[]{date.toString(),""String_Node_Str""});
}","/** 
 * Parse a date/time string.
 * @param source
 * @return
 * @throws ParseException
 */
public static String format(Date date) throws BirtException {
  return format(date,TimeZone.getDefault());
}",0.4205378973105134
64989,"/** 
 * Output metadata properties.
 * @param map
 * @param element
 * @param tagName
 * @return boolean: has the bookmark been output?
 */
public boolean outputMetadataProperty(HashMap propertyMap,Object element,String tagName){
  if (propertyMap == null) {
    return false;
  }
  boolean iidOutput=false;
  boolean bookmarkOutput=false;
  boolean elementTypeOutput=false;
  boolean addToIIDList=false;
  InstanceID iid=null;
  String bookmark=null;
  String elementType=null;
  Iterator ite=propertyMap.entrySet().iterator();
  while (ite.hasNext()) {
    Map.Entry entry=(Map.Entry)ite.next();
    Object keyObj=entry.getKey();
    Object valueObj=entry.getValue();
    if (keyObj instanceof String) {
      String keyStr=(String)keyObj;
      if (keyStr == IMetadataFilter.KEY_OUTPUT_IID) {
        Object genBy=null;
        if (element instanceof IContent) {
          iid=((IContent)element).getInstanceID();
          genBy=((IContent)element).getGenerateBy();
        }
 else         if (element instanceof IColumn) {
          iid=((IColumn)element).getInstanceID();
          genBy=((IColumn)element).getGenerateBy();
        }
        if (iid != null) {
          if ((genBy instanceof TableItemDesign) || (genBy instanceof ListItemDesign) || (genBy instanceof ExtendedItemDesign)) {
            writer.attribute(attrIID,iid.toUniqueString());
          }
 else {
            writer.attribute(attrIID,iid.toString());
          }
          iidOutput=true;
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_OUTPUT_BOOKMARK) {
        if (element instanceof IContent) {
          IContent content=(IContent)element;
          bookmark=content.getBookmark();
          if (bookmark == null) {
            bookmark=idGenerator.generateUniqueID();
            content.setBookmark(bookmark);
          }
          htmlReportEmitter.outputBookmark(writer,tagName,htmlIDNamespace,bookmark);
          bookmarkOutput=true;
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_ATTR_ELEMENT_TYPE) {
        if (valueObj == null) {
          continue;
        }
        elementType=(String)valueObj;
        writer.attribute(attrElementType,elementType);
        elementTypeOutput=true;
      }
 else       if (keyStr == IMetadataFilter.KEY_ADD_INTO_IID_LIST) {
        addToIIDList=true;
      }
 else       if (keyStr.equalsIgnoreCase(IMetadataFilter.KEY_ATTR_TYPE)) {
        if (valueObj != null) {
          writer.attribute(attrType,(String)valueObj);
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_ATTR_ROW_TYPE) {
        if (valueObj != null) {
          writer.attribute(attrRowType,(String)valueObj);
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_OUTPUT_GOURP_ID) {
        if (element instanceof IRowContent) {
          String groupId=((IRowContent)element).getGroupId();
          if (groupId != null) {
            writer.attribute(HTMLTags.ATTR_GOURP_ID,groupId);
          }
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_OUTPUT_RAW_DATA) {
        if (element instanceof IDataContent) {
          Object value=((IDataContent)element).getValue();
          if (value != null) {
            String rawData=null;
            try {
              rawData=DataTypeUtil.toLocaleNeutralString(value);
            }
 catch (            BirtException e) {
            }
            if (rawData == null) {
              rawData=value.toString();
            }
            writer.attributeAllowEmpty(HTMLTags.ATTR_RAW_DATA,rawData);
          }
        }
      }
 else {
        if (valueObj != null) {
          if (keyStr.length() > 0) {
            if (attrNamePrefix != null) {
              writer.attribute(attrNamePrefix + keyStr,valueObj.toString());
            }
 else {
              writer.attribute(keyStr,valueObj.toString());
            }
          }
        }
      }
    }
  }
  if (addToIIDList && iidOutput && bookmarkOutput&& elementTypeOutput) {
    exportElementID(bookmark,elementType,iid.getComponentID());
  }
  return bookmarkOutput;
}","/** 
 * Output metadata properties.
 * @param map
 * @param element
 * @param tagName
 * @return boolean: has the bookmark been output?
 */
public boolean outputMetadataProperty(HashMap propertyMap,Object element,String tagName){
  if (propertyMap == null) {
    return false;
  }
  boolean iidOutput=false;
  boolean bookmarkOutput=false;
  boolean elementTypeOutput=false;
  boolean addToIIDList=false;
  InstanceID iid=null;
  String bookmark=null;
  String elementType=null;
  Iterator ite=propertyMap.entrySet().iterator();
  while (ite.hasNext()) {
    Map.Entry entry=(Map.Entry)ite.next();
    Object keyObj=entry.getKey();
    Object valueObj=entry.getValue();
    if (keyObj instanceof String) {
      String keyStr=(String)keyObj;
      if (keyStr == IMetadataFilter.KEY_OUTPUT_IID) {
        Object genBy=null;
        if (element instanceof IContent) {
          iid=((IContent)element).getInstanceID();
          genBy=((IContent)element).getGenerateBy();
        }
 else         if (element instanceof IColumn) {
          iid=((IColumn)element).getInstanceID();
          genBy=((IColumn)element).getGenerateBy();
        }
        if (iid != null) {
          if ((genBy instanceof TableItemDesign) || (genBy instanceof ListItemDesign) || (genBy instanceof ExtendedItemDesign)) {
            writer.attribute(attrIID,iid.toUniqueString());
          }
 else {
            writer.attribute(attrIID,iid.toString());
          }
          iidOutput=true;
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_OUTPUT_BOOKMARK) {
        if (element instanceof IContent) {
          IContent content=(IContent)element;
          bookmark=content.getBookmark();
          if (bookmark == null) {
            bookmark=idGenerator.generateUniqueID();
            content.setBookmark(bookmark);
          }
          htmlReportEmitter.outputBookmark(writer,tagName,htmlIDNamespace,bookmark);
          bookmarkOutput=true;
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_ATTR_ELEMENT_TYPE) {
        if (valueObj == null) {
          continue;
        }
        elementType=(String)valueObj;
        writer.attribute(attrElementType,elementType);
        elementTypeOutput=true;
      }
 else       if (keyStr == IMetadataFilter.KEY_ADD_INTO_IID_LIST) {
        addToIIDList=true;
      }
 else       if (keyStr.equalsIgnoreCase(IMetadataFilter.KEY_ATTR_TYPE)) {
        if (valueObj != null) {
          writer.attribute(attrType,(String)valueObj);
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_ATTR_ROW_TYPE) {
        if (valueObj != null) {
          writer.attribute(attrRowType,(String)valueObj);
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_OUTPUT_GOURP_ID) {
        if (element instanceof IRowContent) {
          String groupId=((IRowContent)element).getGroupId();
          if (groupId != null) {
            writer.attribute(HTMLTags.ATTR_GOURP_ID,groupId);
          }
        }
      }
 else       if (keyStr == IMetadataFilter.KEY_OUTPUT_RAW_DATA) {
        if (element instanceof IDataContent) {
          Object value=((IDataContent)element).getValue();
          if (value != null) {
            String rawData=null;
            try {
              rawData=DataTypeUtil.toLocaleNeutralString(value,TimeZone.getTimeZone(""String_Node_Str""));
            }
 catch (            BirtException e) {
            }
            if (rawData == null) {
              rawData=value.toString();
            }
            writer.attributeAllowEmpty(HTMLTags.ATTR_RAW_DATA,rawData);
          }
        }
      }
 else {
        if (valueObj != null) {
          if (keyStr.length() > 0) {
            if (attrNamePrefix != null) {
              writer.attribute(attrNamePrefix + keyStr,valueObj.toString());
            }
 else {
              writer.attribute(keyStr,valueObj.toString());
            }
          }
        }
      }
    }
  }
  if (addToIIDList && iidOutput && bookmarkOutput&& elementTypeOutput) {
    exportElementID(bookmark,elementType,iid.getComponentID());
  }
  return bookmarkOutput;
}",0.9950811608460404
64990,"/** 
 * Test all properties.
 * @throws Exception if opening design file failed.
 */
public void testParser() throws Exception {
  openDesign(fileName);
  DataItem data=(DataItem)design.findElement(""String_Node_Str"");
  DataItemHandle dataHandle=(DataItemHandle)data.getHandle(design);
  assertTrue(dataHandle.allowExport());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetColumn());
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  assertEquals(""String_Node_Str"",dataHandle.getHelpText());
  assertEquals(""String_Node_Str"",dataHandle.getHelpTextKey());
  ActionHandle actionHandle=dataHandle.getActionHandle();
  assertNotNull(actionHandle);
  assertEquals(DesignChoiceConstants.ACTION_LINK_TYPE_HYPERLINK,actionHandle.getLinkType());
  assertEquals(""String_Node_Str"",actionHandle.getURI());
  assertEquals(""String_Node_Str"",dataHandle.getRole());
  assertEquals(""String_Node_Str"",dataHandle.getLanguage());
  assertEquals(""String_Node_Str"",dataHandle.getAltText());
  assertEquals(1,dataHandle.getOrder());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",dataHandle.getRole());
  assertEquals(ReportDesign.BODY_SLOT,dataHandle.getContainer().findContentSlot(dataHandle));
  assertEquals(""String_Node_Str"",dataHandle.getResultSetColumn());
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  assertEquals(""String_Node_Str"",dataHandle.getHelpText());
  assertEquals(""String_Node_Str"",dataHandle.getHelpTextKey());
  actionHandle=dataHandle.getActionHandle();
  assertNotNull(actionHandle);
  assertEquals(DesignChoiceConstants.ACTION_LINK_TYPE_HYPERLINK,actionHandle.getLinkType());
  assertEquals(""String_Node_Str"",actionHandle.getURI());
  Iterator columnBindings=dataHandle.columnBindingsIterator();
  ComputedColumnHandle column=(ComputedColumnHandle)columnBindings.next();
  assertEquals(""String_Node_Str"",column.getName());
  assertEquals(""String_Node_Str"",column.getExpression());
  assertEquals(""String_Node_Str"",column.getDisplayName());
  assertEquals(""String_Node_Str"",column.getDisplayNameID());
  assertEquals(""String_Node_Str"",column.getDisplayText());
  assertEquals(DesignChoiceConstants.COLUMN_DATA_TYPE_INTEGER,column.getDataType());
  assertEquals(""String_Node_Str"",column.getAggregateOn());
  assertEquals(""String_Node_Str"",serializeStringList(column.getAggregateOnList()));
  Iterator iter=column.argumentsIterator();
  AggregationArgumentHandle argument=(AggregationArgumentHandle)iter.next();
  assertEquals(""String_Node_Str"",argument.getName());
  assertEquals(""String_Node_Str"",argument.getValue());
  argument=(AggregationArgumentHandle)iter.next();
  assertEquals(""String_Node_Str"",argument.getName());
  assertEquals(""String_Node_Str"",argument.getValue());
  assertEquals(DesignChoiceConstants.MEASURE_FUNCTION_SUM,column.getAggregateFunction());
  assertEquals(""String_Node_Str"",column.getFilterExpression());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  columnBindings=dataHandle.columnBindingsIterator();
  column=(ComputedColumnHandle)columnBindings.next();
  assertEquals(""String_Node_Str"",column.getName());
  assertEquals(""String_Node_Str"",column.getExpression());
  assertEquals(""String_Node_Str"",column.getDisplayName());
  assertEquals(DesignChoiceConstants.COLUMN_DATA_TYPE_INTEGER,column.getDataType());
  assertEquals(""String_Node_Str"",column.getAggregateOn());
  assertEquals(""String_Node_Str"",serializeStringList(column.getAggregateOnList()));
  assertFalse(dataHandle.allowExport());
}","/** 
 * Test all properties.
 * @throws Exception if opening design file failed.
 */
public void testParser() throws Exception {
  openDesign(fileName);
  DataItem data=(DataItem)design.findElement(""String_Node_Str"");
  DataItemHandle dataHandle=(DataItemHandle)data.getHandle(design);
  assertTrue(dataHandle.allowExport());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetColumn());
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  assertEquals(""String_Node_Str"",dataHandle.getHelpText());
  assertEquals(""String_Node_Str"",dataHandle.getHelpTextKey());
  ActionHandle actionHandle=dataHandle.getActionHandle();
  assertNotNull(actionHandle);
  assertEquals(DesignChoiceConstants.ACTION_LINK_TYPE_HYPERLINK,actionHandle.getLinkType());
  assertEquals(""String_Node_Str"",actionHandle.getURI());
  assertEquals(""String_Node_Str"",dataHandle.getTagType());
  assertEquals(""String_Node_Str"",dataHandle.getLanguage());
  assertEquals(""String_Node_Str"",dataHandle.getAltText());
  assertEquals(1,dataHandle.getOrder());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",dataHandle.getTagType());
  assertEquals(ReportDesign.BODY_SLOT,dataHandle.getContainer().findContentSlot(dataHandle));
  assertEquals(""String_Node_Str"",dataHandle.getResultSetColumn());
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  assertEquals(""String_Node_Str"",dataHandle.getHelpText());
  assertEquals(""String_Node_Str"",dataHandle.getHelpTextKey());
  actionHandle=dataHandle.getActionHandle();
  assertNotNull(actionHandle);
  assertEquals(DesignChoiceConstants.ACTION_LINK_TYPE_HYPERLINK,actionHandle.getLinkType());
  assertEquals(""String_Node_Str"",actionHandle.getURI());
  Iterator columnBindings=dataHandle.columnBindingsIterator();
  ComputedColumnHandle column=(ComputedColumnHandle)columnBindings.next();
  assertEquals(""String_Node_Str"",column.getName());
  assertEquals(""String_Node_Str"",column.getExpression());
  assertEquals(""String_Node_Str"",column.getDisplayName());
  assertEquals(""String_Node_Str"",column.getDisplayNameID());
  assertEquals(""String_Node_Str"",column.getDisplayText());
  assertEquals(DesignChoiceConstants.COLUMN_DATA_TYPE_INTEGER,column.getDataType());
  assertEquals(""String_Node_Str"",column.getAggregateOn());
  assertEquals(""String_Node_Str"",serializeStringList(column.getAggregateOnList()));
  Iterator iter=column.argumentsIterator();
  AggregationArgumentHandle argument=(AggregationArgumentHandle)iter.next();
  assertEquals(""String_Node_Str"",argument.getName());
  assertEquals(""String_Node_Str"",argument.getValue());
  argument=(AggregationArgumentHandle)iter.next();
  assertEquals(""String_Node_Str"",argument.getName());
  assertEquals(""String_Node_Str"",argument.getValue());
  assertEquals(DesignChoiceConstants.MEASURE_FUNCTION_SUM,column.getAggregateFunction());
  assertEquals(""String_Node_Str"",column.getFilterExpression());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  assertNull(dataHandle.getValueExpr());
  assertEquals(""String_Node_Str"",dataHandle.getResultSetExpression());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  columnBindings=dataHandle.columnBindingsIterator();
  column=(ComputedColumnHandle)columnBindings.next();
  assertEquals(""String_Node_Str"",column.getName());
  assertEquals(""String_Node_Str"",column.getExpression());
  assertEquals(""String_Node_Str"",column.getDisplayName());
  assertEquals(DesignChoiceConstants.COLUMN_DATA_TYPE_INTEGER,column.getDataType());
  assertEquals(""String_Node_Str"",column.getAggregateOn());
  assertEquals(""String_Node_Str"",serializeStringList(column.getAggregateOnList()));
  assertFalse(dataHandle.allowExport());
}",0.997865275142315
64991,"/** 
 * This test sets properties, writes the design file and compares it with golden file.
 * @throws Exception if opening or saving design file failed.
 */
public void testWriter() throws Exception {
  openDesign(fileName);
  DataItem data=(DataItem)design.findElement(""String_Node_Str"");
  DataItemHandle dataHandle=(DataItemHandle)data.getHandle(design);
  dataHandle.setHelpTextKey(""String_Node_Str"");
  dataHandle.setHelpText(""String_Node_Str"");
  ActionHandle action=dataHandle.getActionHandle();
  assertNotNull(action);
  dataHandle.setRole(""String_Node_Str"");
  dataHandle.setLanguage(""String_Node_Str"");
  dataHandle.setAltText(""String_Node_Str"");
  dataHandle.setOrder(2);
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  dataHandle.setHelpTextKey(""String_Node_Str"");
  dataHandle.setHelpText(""String_Node_Str"");
  action=dataHandle.getActionHandle();
  assertNotNull(action);
  Iterator columnBindings=dataHandle.columnBindingsIterator();
  ComputedColumnHandle column=(ComputedColumnHandle)columnBindings.next();
  column.setDisplayName(""String_Node_Str"");
  column.setDisplayNameID(""String_Node_Str"");
  column.setAggregateFunction(DesignChoiceConstants.MEASURE_FUNCTION_COUNT);
  data=(DataItem)design.findElement(""String_Node_Str"");
  columnBindings=dataHandle.columnBindingsIterator();
  column=(ComputedColumnHandle)columnBindings.next();
  AggregationArgumentHandle argumentHandle=(AggregationArgumentHandle)column.argumentsIterator().next();
  argumentHandle.setName(""String_Node_Str"" + argumentHandle.getName());
  argumentHandle.setValue(""String_Node_Str"" + argumentHandle.getValue());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  dataHandle.setAllowExport(true);
  save();
  assertTrue(compareFile(goldenFileName));
}","/** 
 * This test sets properties, writes the design file and compares it with golden file.
 * @throws Exception if opening or saving design file failed.
 */
public void testWriter() throws Exception {
  openDesign(fileName);
  DataItem data=(DataItem)design.findElement(""String_Node_Str"");
  DataItemHandle dataHandle=(DataItemHandle)data.getHandle(design);
  dataHandle.setHelpTextKey(""String_Node_Str"");
  dataHandle.setHelpText(""String_Node_Str"");
  ActionHandle action=dataHandle.getActionHandle();
  assertNotNull(action);
  dataHandle.setTagType(""String_Node_Str"");
  dataHandle.setLanguage(""String_Node_Str"");
  dataHandle.setAltText(""String_Node_Str"");
  dataHandle.setOrder(2);
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  dataHandle.setHelpTextKey(""String_Node_Str"");
  dataHandle.setHelpText(""String_Node_Str"");
  action=dataHandle.getActionHandle();
  assertNotNull(action);
  Iterator columnBindings=dataHandle.columnBindingsIterator();
  ComputedColumnHandle column=(ComputedColumnHandle)columnBindings.next();
  column.setDisplayName(""String_Node_Str"");
  column.setDisplayNameID(""String_Node_Str"");
  column.setAggregateFunction(DesignChoiceConstants.MEASURE_FUNCTION_COUNT);
  data=(DataItem)design.findElement(""String_Node_Str"");
  columnBindings=dataHandle.columnBindingsIterator();
  column=(ComputedColumnHandle)columnBindings.next();
  AggregationArgumentHandle argumentHandle=(AggregationArgumentHandle)column.argumentsIterator().next();
  argumentHandle.setName(""String_Node_Str"" + argumentHandle.getName());
  argumentHandle.setValue(""String_Node_Str"" + argumentHandle.getValue());
  dataHandle=(DataItemHandle)designHandle.findElement(""String_Node_Str"");
  dataHandle.setAllowExport(true);
  save();
  assertTrue(compareFile(goldenFileName));
}",0.9975006942515968
64992,"/** 
 * Test parser and its properties.
 * @throws Exception
 */
public void testParser() throws Exception {
  openDesign(fileName);
  SlotHandle body=designHandle.getBody();
  GridHandle grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  assertEquals(0,body.findPosn(grid));
  assertEquals(""String_Node_Str"",grid.getSummary());
  assertEquals(""String_Node_Str"",grid.getCaption());
  assertEquals(""String_Node_Str"",grid.getCaptionKey());
  assertEquals(""String_Node_Str"",grid.getRole());
  assertEquals(""String_Node_Str"",grid.getLanguage());
  assertEquals(1,grid.getOrder());
  SlotHandle columns=grid.getColumns();
  assertEquals(2,columns.getCount());
  ColumnHandle column=(ColumnHandle)columns.get(0);
  assertEquals(2.5,column.getWidth().getMeasure(),0.1);
  assertEquals(3,column.getRepeatCount());
  assertEquals(""String_Node_Str"",column.getStyle().getName());
  assertNull(column.getPropertyDefn(Style.PAGE_BREAK_INSIDE_PROP));
  SlotHandle rows=grid.getRows();
  assertEquals(2,rows.getCount());
  RowHandle row=(RowHandle)rows.get(0);
  assertEquals(5,row.getHeight().getMeasure(),1);
  assertEquals(""String_Node_Str"",row.getBookmark());
  assertEquals(""String_Node_Str"",row.getStyle().getName());
  SlotHandle cells=row.getCells();
  assertEquals(2,cells.getCount());
  CellHandle cell=(CellHandle)cells.get(0);
  assertEquals(DesignChoiceConstants.LINE_STYLE_NONE,cell.getDiagonalStyle());
  assertEquals(DesignChoiceConstants.LINE_STYLE_NONE,cell.getAntidiagonalStyle());
  assertEquals(0,cell.getDiagonalNumber());
  assertEquals(0,cell.getAntidiagonalNumber());
  assertEquals(ColorPropertyType.BLACK,cell.getDiagonalColor().getStringValue());
  assertEquals(ColorPropertyType.BLACK,cell.getAntidiagonalColor().getStringValue());
  DimensionHandle dimensionHandle=cell.getDiagonalThickness();
  assertEquals(DesignChoiceConstants.LINE_WIDTH_MEDIUM,dimensionHandle.getStringValue());
  dimensionHandle=cell.getAntidiagonalThickness();
  assertEquals(DesignChoiceConstants.LINE_WIDTH_MEDIUM,dimensionHandle.getStringValue());
  assertEquals(""String_Node_Str"",cell.getRole());
  cell=(CellHandle)cells.get(1);
  assertEquals(2,cell.getColumn());
  assertEquals(3,cell.getColumnSpan());
  assertEquals(1,cell.getRowSpan());
  assertEquals(""String_Node_Str"",cell.getDrop());
  assertEquals(""String_Node_Str"",cell.getHeight().getStringValue());
  assertEquals(""String_Node_Str"",cell.getWidth().getStringValue());
  assertEquals(""String_Node_Str"",cell.getPrivateStyle().getBackgroundColor().getStringValue());
  assertEquals(""String_Node_Str"",cell.getRole());
  assertEquals(""String_Node_Str"",cell.getLanguage());
  assertEquals(""String_Node_Str"",cell.getAltText());
  SlotHandle content=cell.getContent();
  LabelHandle label=(LabelHandle)content.get(0);
  assertEquals(""String_Node_Str"",label.getName());
  assertEquals(DesignChoiceConstants.LINE_STYLE_SOLID,cell.getDiagonalStyle());
  assertEquals(DesignChoiceConstants.LINE_STYLE_DASHED,cell.getAntidiagonalStyle());
  assertEquals(10,cell.getDiagonalNumber());
  assertEquals(20,cell.getAntidiagonalNumber());
  assertEquals(ColorPropertyType.RED,cell.getDiagonalColor().getStringValue());
  assertEquals(ColorPropertyType.BLUE,cell.getAntidiagonalColor().getStringValue());
  dimensionHandle=cell.getDiagonalThickness();
  assertEquals(""String_Node_Str"",dimensionHandle.getStringValue());
  dimensionHandle=cell.getAntidiagonalThickness();
  assertEquals(""String_Node_Str"",dimensionHandle.getStringValue());
  assertEquals(DesignChoiceConstants.SCOPE_TYPE_ROWGROUP,cell.getScope());
  assertEquals(""String_Node_Str"",cell.getBookmark());
  assertEquals(""String_Node_Str"",cell.getHeaders());
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",grid.getRole());
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
}","/** 
 * Test parser and its properties.
 * @throws Exception
 */
public void testParser() throws Exception {
  openDesign(fileName);
  SlotHandle body=designHandle.getBody();
  GridHandle grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  assertEquals(0,body.findPosn(grid));
  assertEquals(""String_Node_Str"",grid.getSummary());
  assertEquals(""String_Node_Str"",grid.getCaption());
  assertEquals(""String_Node_Str"",grid.getCaptionKey());
  assertEquals(""String_Node_Str"",grid.getTagType());
  assertEquals(""String_Node_Str"",grid.getLanguage());
  assertEquals(1,grid.getOrder());
  SlotHandle columns=grid.getColumns();
  assertEquals(2,columns.getCount());
  ColumnHandle column=(ColumnHandle)columns.get(0);
  assertEquals(2.5,column.getWidth().getMeasure(),0.1);
  assertEquals(3,column.getRepeatCount());
  assertEquals(""String_Node_Str"",column.getStyle().getName());
  assertNull(column.getPropertyDefn(Style.PAGE_BREAK_INSIDE_PROP));
  SlotHandle rows=grid.getRows();
  assertEquals(2,rows.getCount());
  RowHandle row=(RowHandle)rows.get(0);
  assertEquals(5,row.getHeight().getMeasure(),1);
  assertEquals(""String_Node_Str"",row.getBookmark());
  assertEquals(""String_Node_Str"",row.getStyle().getName());
  SlotHandle cells=row.getCells();
  assertEquals(2,cells.getCount());
  CellHandle cell=(CellHandle)cells.get(0);
  assertEquals(DesignChoiceConstants.LINE_STYLE_NONE,cell.getDiagonalStyle());
  assertEquals(DesignChoiceConstants.LINE_STYLE_NONE,cell.getAntidiagonalStyle());
  assertEquals(0,cell.getDiagonalNumber());
  assertEquals(0,cell.getAntidiagonalNumber());
  assertEquals(ColorPropertyType.BLACK,cell.getDiagonalColor().getStringValue());
  assertEquals(ColorPropertyType.BLACK,cell.getAntidiagonalColor().getStringValue());
  DimensionHandle dimensionHandle=cell.getDiagonalThickness();
  assertEquals(DesignChoiceConstants.LINE_WIDTH_MEDIUM,dimensionHandle.getStringValue());
  dimensionHandle=cell.getAntidiagonalThickness();
  assertEquals(DesignChoiceConstants.LINE_WIDTH_MEDIUM,dimensionHandle.getStringValue());
  assertEquals(""String_Node_Str"",cell.getTagType());
  cell=(CellHandle)cells.get(1);
  assertEquals(2,cell.getColumn());
  assertEquals(3,cell.getColumnSpan());
  assertEquals(1,cell.getRowSpan());
  assertEquals(""String_Node_Str"",cell.getDrop());
  assertEquals(""String_Node_Str"",cell.getHeight().getStringValue());
  assertEquals(""String_Node_Str"",cell.getWidth().getStringValue());
  assertEquals(""String_Node_Str"",cell.getPrivateStyle().getBackgroundColor().getStringValue());
  assertEquals(""String_Node_Str"",cell.getTagType());
  assertEquals(""String_Node_Str"",cell.getLanguage());
  assertEquals(""String_Node_Str"",cell.getAltText());
  SlotHandle content=cell.getContent();
  LabelHandle label=(LabelHandle)content.get(0);
  assertEquals(""String_Node_Str"",label.getName());
  assertEquals(DesignChoiceConstants.LINE_STYLE_SOLID,cell.getDiagonalStyle());
  assertEquals(DesignChoiceConstants.LINE_STYLE_DASHED,cell.getAntidiagonalStyle());
  assertEquals(10,cell.getDiagonalNumber());
  assertEquals(20,cell.getAntidiagonalNumber());
  assertEquals(ColorPropertyType.RED,cell.getDiagonalColor().getStringValue());
  assertEquals(ColorPropertyType.BLUE,cell.getAntidiagonalColor().getStringValue());
  dimensionHandle=cell.getDiagonalThickness();
  assertEquals(""String_Node_Str"",dimensionHandle.getStringValue());
  dimensionHandle=cell.getAntidiagonalThickness();
  assertEquals(""String_Node_Str"",dimensionHandle.getStringValue());
  assertEquals(DesignChoiceConstants.SCOPE_TYPE_ROWGROUP,cell.getScope());
  assertEquals(""String_Node_Str"",cell.getBookmark());
  assertEquals(""String_Node_Str"",cell.getHeaders());
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",grid.getTagType());
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
  grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(grid);
}",0.8939164321281663
64993,"/** 
 * This test writes the design file and compare it with golden file.
 * @throws Exception
 */
public void testWriter() throws Exception {
  openDesign(fileName);
  GridHandle grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  grid.setCaption(""String_Node_Str"");
  grid.setCaptionKey(""String_Node_Str"");
  grid.setSummary(""String_Node_Str"");
  grid.setRole(""String_Node_Str"");
  grid.setLanguage(""String_Node_Str"");
  grid.setOrder(1);
  SlotHandle rows=grid.getRows();
  RowHandle row=(RowHandle)rows.get(0);
  SlotHandle cells=row.getCells();
  CellHandle cell=(CellHandle)cells.get(1);
  cell.setDiagonalStyle(DesignChoiceConstants.LINE_STYLE_INSET);
  cell.setAntidiagonalStyle(DesignChoiceConstants.LINE_STYLE_OUTSET);
  cell.setDiagonalNumber(20);
  cell.setAntidiagonalNumber(30);
  cell.setProperty(ICellModel.DIAGONAL_THICKNESS_PROP,""String_Node_Str"");
  cell.setProperty(ICellModel.ANTIDIAGONAL_THICKNESS_PROP,""String_Node_Str"");
  cell.setRole(""String_Node_Str"");
  cell.setLanguage(""String_Node_Str"");
  cell.setAltText(""String_Node_Str"");
  ColorHandle colorHandle=cell.getDiagonalColor();
  colorHandle.setStringValue(ColorPropertyType.YELLOW);
  colorHandle=cell.getAntidiagonalColor();
  colorHandle.setStringValue(ColorPropertyType.OLIVE);
  cell.setScope(DesignChoiceConstants.SCOPE_TYPE_COL);
  cell.setBookmark(""String_Node_Str"");
  cell.setHeaders(""String_Node_Str"");
  save();
  assertTrue(compareFile(goldenFileName));
}","/** 
 * This test writes the design file and compare it with golden file.
 * @throws Exception
 */
public void testWriter() throws Exception {
  openDesign(fileName);
  GridHandle grid=(GridHandle)designHandle.findElement(""String_Node_Str"");
  grid.setCaption(""String_Node_Str"");
  grid.setCaptionKey(""String_Node_Str"");
  grid.setSummary(""String_Node_Str"");
  grid.setTagType(""String_Node_Str"");
  grid.setLanguage(""String_Node_Str"");
  grid.setOrder(1);
  SlotHandle rows=grid.getRows();
  RowHandle row=(RowHandle)rows.get(0);
  SlotHandle cells=row.getCells();
  CellHandle cell=(CellHandle)cells.get(1);
  cell.setDiagonalStyle(DesignChoiceConstants.LINE_STYLE_INSET);
  cell.setAntidiagonalStyle(DesignChoiceConstants.LINE_STYLE_OUTSET);
  cell.setDiagonalNumber(20);
  cell.setAntidiagonalNumber(30);
  cell.setProperty(ICellModel.DIAGONAL_THICKNESS_PROP,""String_Node_Str"");
  cell.setProperty(ICellModel.ANTIDIAGONAL_THICKNESS_PROP,""String_Node_Str"");
  cell.setTagType(""String_Node_Str"");
  cell.setLanguage(""String_Node_Str"");
  cell.setAltText(""String_Node_Str"");
  ColorHandle colorHandle=cell.getDiagonalColor();
  colorHandle.setStringValue(ColorPropertyType.YELLOW);
  colorHandle=cell.getAntidiagonalColor();
  colorHandle.setStringValue(ColorPropertyType.OLIVE);
  cell.setScope(DesignChoiceConstants.SCOPE_TYPE_COL);
  cell.setBookmark(""String_Node_Str"");
  cell.setHeaders(""String_Node_Str"");
  save();
  assertTrue(compareFile(goldenFileName));
}",0.9938482570061518
64994,"/** 
 * After getting the image item instance from the design file, set properties on this image to see the property can be correctly set on the image and also can be written into the design file.
 * @throws Exception if errors occur when reads or writes the design file
 */
public void testWriteProperties() throws Exception {
  openDesign(""String_Node_Str"");
  image=findImageItemByName(""String_Node_Str"");
  handle=image.handle(design);
  handle.setProportionalScale(false);
  image=findImageItemByName(""String_Node_Str"");
  handle=image.handle(design);
  handle.setName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",handle.getName());
  handle.setSize(DesignChoiceConstants.IMAGE_SIZE_SIZE_TO_IMAGE);
  assertTrue(handle.getSize().compareToIgnoreCase(DesignChoiceConstants.IMAGE_SIZE_SIZE_TO_IMAGE) == 0);
  handle.setScale(4.0f);
  assertTrue(4.0 == handle.getScale());
  handle.setImageName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",handle.getImageName());
  image=findImageItemByName(""String_Node_Str"");
  handle.setTypeExpression(""String_Node_Str"");
  assertEquals(""String_Node_Str"",handle.getTypeExpression());
  handle.setValueExpression(""String_Node_Str"");
  assertEquals(""String_Node_Str"",handle.getValueExpression());
  image=findImageItemByName(""String_Node_Str"");
  handle=image.handle(design);
  handle.setImageName(""String_Node_Str"");
  handle.setBookmark(""String_Node_Str"");
  ActionHandle actionHandle=handle.getActionHandle();
  actionHandle.setURI(""String_Node_Str"");
  handle.setHelpText(""String_Node_Str"");
  handle.setHelpTextKey(""String_Node_Str"");
  handle.setFitToContainer(false);
  handle.setRole(""String_Node_Str"");
  handle.setLanguage(""String_Node_Str"");
  handle.setOrder(1);
  save();
  assertTrue(compareFile(""String_Node_Str""));
}","/** 
 * After getting the image item instance from the design file, set properties on this image to see the property can be correctly set on the image and also can be written into the design file.
 * @throws Exception if errors occur when reads or writes the design file
 */
public void testWriteProperties() throws Exception {
  openDesign(""String_Node_Str"");
  image=findImageItemByName(""String_Node_Str"");
  handle=image.handle(design);
  handle.setProportionalScale(false);
  image=findImageItemByName(""String_Node_Str"");
  handle=image.handle(design);
  handle.setName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",handle.getName());
  handle.setSize(DesignChoiceConstants.IMAGE_SIZE_SIZE_TO_IMAGE);
  assertTrue(handle.getSize().compareToIgnoreCase(DesignChoiceConstants.IMAGE_SIZE_SIZE_TO_IMAGE) == 0);
  handle.setScale(4.0f);
  assertTrue(4.0 == handle.getScale());
  handle.setImageName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",handle.getImageName());
  image=findImageItemByName(""String_Node_Str"");
  handle.setTypeExpression(""String_Node_Str"");
  assertEquals(""String_Node_Str"",handle.getTypeExpression());
  handle.setValueExpression(""String_Node_Str"");
  assertEquals(""String_Node_Str"",handle.getValueExpression());
  image=findImageItemByName(""String_Node_Str"");
  handle=image.handle(design);
  handle.setImageName(""String_Node_Str"");
  handle.setBookmark(""String_Node_Str"");
  ActionHandle actionHandle=handle.getActionHandle();
  actionHandle.setURI(""String_Node_Str"");
  handle.setHelpText(""String_Node_Str"");
  handle.setHelpTextKey(""String_Node_Str"");
  handle.setFitToContainer(false);
  handle.setTagType(""String_Node_Str"");
  handle.setLanguage(""String_Node_Str"");
  handle.setOrder(1);
  save();
  assertTrue(compareFile(""String_Node_Str""));
}",0.9974796975637076
64995,"/** 
 * Test the properties of the image. These properties are well defined in the design file.
 * @throws Exception if errors occur when reads the design file
 */
public void testReadProperties() throws Exception {
  openDesign(""String_Node_Str"");
  image=findImageItemByName(""String_Node_Str"");
  double scale=handle.getScale();
  assertTrue(scale == 0.8);
  assertEquals(""String_Node_Str"",handle.getRole());
  String size=handle.getSize();
  assertEquals(DesignChoiceConstants.IMAGE_SIZE_SCALE_TO_ITEM,size);
  String helpText=handle.getAltText();
  assertEquals(""String_Node_Str"",helpText);
  String refType=handle.getSource();
  assertEquals(DesignChoiceConstants.IMAGE_REF_TYPE_URL,refType);
  String url=handle.getURI();
  assertEquals(""String_Node_Str"",url);
  assertEquals(DesignChoiceConstants.ACTION_LINK_TYPE_HYPERLINK,handle.getActionHandle().getLinkType());
  assertFalse(handle.fitToContainer());
  assertTrue(handle.isProportionalScale());
  image=findImageItemByName(""String_Node_Str"");
  refType=handle.getSource();
  assertEquals(DesignChoiceConstants.IMAGE_REF_TYPE_EMBED,refType);
  String imageName=handle.getImageName();
  assertEquals(""String_Node_Str"",imageName);
  helpText=handle.getHelpText();
  assertEquals(""String_Node_Str"",helpText);
  image=findImageItemByName(""String_Node_Str"");
  refType=handle.getSource();
  assertEquals(DesignChoiceConstants.IMAGE_REF_TYPE_EXPR,refType);
  String typeExpression=handle.getTypeExpression();
  assertEquals(""String_Node_Str"",typeExpression);
  String valueExpression=handle.getValueExpression();
  assertEquals(""String_Node_Str"",valueExpression);
  helpText=handle.getHelpText();
  assertEquals(""String_Node_Str"",helpText);
  image=findImageItemByName(""String_Node_Str"");
  ActionHandle actionHandle=image.handle(design).getActionHandle();
  assertNull(actionHandle);
  image=findImageItemByName(""String_Node_Str"");
  handle=image.handle(design);
  assertEquals(ReportDesign.BODY_SLOT,handle.getContainer().findContentSlot(handle));
  assertEquals(""String_Node_Str"",handle.getImageName());
  assertEquals(""String_Node_Str"",handle.getHelpText());
  assertEquals(""String_Node_Str"",handle.getHelpTextKey());
  actionHandle=handle.getActionHandle();
  assertNotNull(actionHandle);
  assertEquals(""String_Node_Str"",actionHandle.getURI());
  assertTrue(handle.fitToContainer());
  assertEquals(""String_Node_Str"",handle.getRole());
  assertEquals(""String_Node_Str"",handle.getLanguage());
  assertEquals(1,handle.getOrder());
}","/** 
 * Test the properties of the image. These properties are well defined in the design file.
 * @throws Exception if errors occur when reads the design file
 */
public void testReadProperties() throws Exception {
  openDesign(""String_Node_Str"");
  image=findImageItemByName(""String_Node_Str"");
  double scale=handle.getScale();
  assertTrue(scale == 0.8);
  assertEquals(""String_Node_Str"",handle.getTagType());
  String size=handle.getSize();
  assertEquals(DesignChoiceConstants.IMAGE_SIZE_SCALE_TO_ITEM,size);
  String helpText=handle.getAltText();
  assertEquals(""String_Node_Str"",helpText);
  String refType=handle.getSource();
  assertEquals(DesignChoiceConstants.IMAGE_REF_TYPE_URL,refType);
  String url=handle.getURI();
  assertEquals(""String_Node_Str"",url);
  assertEquals(DesignChoiceConstants.ACTION_LINK_TYPE_HYPERLINK,handle.getActionHandle().getLinkType());
  assertFalse(handle.fitToContainer());
  assertTrue(handle.isProportionalScale());
  image=findImageItemByName(""String_Node_Str"");
  refType=handle.getSource();
  assertEquals(DesignChoiceConstants.IMAGE_REF_TYPE_EMBED,refType);
  String imageName=handle.getImageName();
  assertEquals(""String_Node_Str"",imageName);
  helpText=handle.getHelpText();
  assertEquals(""String_Node_Str"",helpText);
  image=findImageItemByName(""String_Node_Str"");
  refType=handle.getSource();
  assertEquals(DesignChoiceConstants.IMAGE_REF_TYPE_EXPR,refType);
  String typeExpression=handle.getTypeExpression();
  assertEquals(""String_Node_Str"",typeExpression);
  String valueExpression=handle.getValueExpression();
  assertEquals(""String_Node_Str"",valueExpression);
  helpText=handle.getHelpText();
  assertEquals(""String_Node_Str"",helpText);
  image=findImageItemByName(""String_Node_Str"");
  ActionHandle actionHandle=image.handle(design).getActionHandle();
  assertNull(actionHandle);
  image=findImageItemByName(""String_Node_Str"");
  handle=image.handle(design);
  assertEquals(ReportDesign.BODY_SLOT,handle.getContainer().findContentSlot(handle));
  assertEquals(""String_Node_Str"",handle.getImageName());
  assertEquals(""String_Node_Str"",handle.getHelpText());
  assertEquals(""String_Node_Str"",handle.getHelpTextKey());
  actionHandle=handle.getActionHandle();
  assertNotNull(actionHandle);
  assertEquals(""String_Node_Str"",actionHandle.getURI());
  assertTrue(handle.fitToContainer());
  assertEquals(""String_Node_Str"",handle.getTagType());
  assertEquals(""String_Node_Str"",handle.getLanguage());
  assertEquals(1,handle.getOrder());
}",0.9963898916967509
64996,"/** 
 * Tests Label element in the PageSetup and Body slots.
 * @throws Exception if opening design file failed.
 */
public void testParser() throws Exception {
  LabelHandle labelHandle=getLabel();
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.X_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.Y_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.HEIGHT_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.WIDTH_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.TEXT_PROP));
  OdaDataSet dataSet=(OdaDataSet)design.findDataSet(""String_Node_Str"");
  assertNotNull(dataSet);
  assertEquals(dataSet.getName(),labelHandle.getProperty(Label.DATA_SET_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.COLOR_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.FONT_FAMILY_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.FONT_SIZE_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.FONT_WEIGHT_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.TEXT_UNDERLINE_PROP));
  assertEquals(null,labelHandle.getStringProperty(Style.HIGHLIGHT_RULES_PROP));
  ActionHandle action=labelHandle.getActionHandle();
  assertNotNull(action);
  assertEquals(DesignChoiceConstants.ACTION_LINK_TYPE_HYPERLINK,action.getLinkType());
  assertEquals(""String_Node_Str"",action.getURI());
  assertEquals(""String_Node_Str"",labelHandle.getRole());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getCustomXml());
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.COLOR_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getText());
  assertEquals(""String_Node_Str"",labelHandle.getHelpText());
  assertEquals(""String_Node_Str"",labelHandle.getHelpTextKey());
  assertEquals(""String_Node_Str"",labelHandle.getTextKey());
  assertEquals(""String_Node_Str"",labelHandle.getRole());
  assertEquals(""String_Node_Str"",labelHandle.getLanguage());
  assertEquals(""String_Node_Str"",labelHandle.getAltText());
  assertEquals(1,labelHandle.getOrder());
  assertEquals(ReportDesign.BODY_SLOT,labelHandle.getContainer().findContentSlot(labelHandle));
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  assertEquals(""String_Node_Str"",labelHandle.getHelpText());
  assertEquals(""String_Node_Str"",labelHandle.getHelpTextKey());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  assertTrue(labelHandle.pushDown());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  assertTrue(labelHandle.pushDown());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
}","/** 
 * Tests Label element in the PageSetup and Body slots.
 * @throws Exception if opening design file failed.
 */
public void testParser() throws Exception {
  LabelHandle labelHandle=getLabel();
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.X_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.Y_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.HEIGHT_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.WIDTH_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Label.TEXT_PROP));
  OdaDataSet dataSet=(OdaDataSet)design.findDataSet(""String_Node_Str"");
  assertNotNull(dataSet);
  assertEquals(dataSet.getName(),labelHandle.getProperty(Label.DATA_SET_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.COLOR_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.FONT_FAMILY_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.FONT_SIZE_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.FONT_WEIGHT_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.TEXT_UNDERLINE_PROP));
  assertEquals(null,labelHandle.getStringProperty(Style.HIGHLIGHT_RULES_PROP));
  ActionHandle action=labelHandle.getActionHandle();
  assertNotNull(action);
  assertEquals(DesignChoiceConstants.ACTION_LINK_TYPE_HYPERLINK,action.getLinkType());
  assertEquals(""String_Node_Str"",action.getURI());
  assertEquals(""String_Node_Str"",labelHandle.getTagType());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getCustomXml());
  assertEquals(""String_Node_Str"",labelHandle.getStringProperty(Style.COLOR_PROP));
  assertEquals(""String_Node_Str"",labelHandle.getText());
  assertEquals(""String_Node_Str"",labelHandle.getHelpText());
  assertEquals(""String_Node_Str"",labelHandle.getHelpTextKey());
  assertEquals(""String_Node_Str"",labelHandle.getTextKey());
  assertEquals(""String_Node_Str"",labelHandle.getTagType());
  assertEquals(""String_Node_Str"",labelHandle.getLanguage());
  assertEquals(""String_Node_Str"",labelHandle.getAltText());
  assertEquals(1,labelHandle.getOrder());
  assertEquals(ReportDesign.BODY_SLOT,labelHandle.getContainer().findContentSlot(labelHandle));
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  assertEquals(""String_Node_Str"",labelHandle.getHelpText());
  assertEquals(""String_Node_Str"",labelHandle.getHelpTextKey());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  assertTrue(labelHandle.pushDown());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  assertTrue(labelHandle.pushDown());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(""String_Node_Str"",labelHandle.getText());
}",0.99757934373319
64997,"/** 
 * This test sets properties, writes the design file and compares it with golden file.
 * @throws Exception if opening or saving design file failed.
 */
public void testWriter() throws Exception {
  LabelHandle labelHandle=getLabel();
  labelHandle.setProperty(Label.X_PROP,""String_Node_Str"");
  labelHandle.setProperty(Label.HEIGHT_PROP,""String_Node_Str"");
  labelHandle.setProperty(Label.STYLE_PROP,null);
  OdaDataSet dataSet=(OdaDataSet)design.findDataSet(""String_Node_Str"");
  assertNotNull(dataSet);
  labelHandle.setProperty(Label.DATA_SET_PROP,null);
  labelHandle.setProperty(Label.NAME_PROP,""String_Node_Str"");
  ActionHandle action=labelHandle.getActionHandle();
  assertNotNull(action);
  action.setURI(""String_Node_Str"");
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(ReportDesign.BODY_SLOT,labelHandle.getContainer().findContentSlot(labelHandle));
  labelHandle.setProperty(Style.COLOR_PROP,""String_Node_Str"");
  assertEquals(ReportDesign.BODY_SLOT,labelHandle.getContainer().findContentSlot(labelHandle));
  labelHandle.setText(""String_Node_Str"");
  labelHandle.setWidth(""String_Node_Str"");
  labelHandle.setTextKey(""String_Node_Str"");
  labelHandle.setHelpText(""String_Node_Str"");
  labelHandle.setHelpTextKey(""String_Node_Str"");
  labelHandle.setRole(""String_Node_Str"");
  labelHandle.setLanguage(""String_Node_Str"");
  labelHandle.setAltText(""String_Node_Str"");
  labelHandle.setOrder(1);
  labelHandle.setCustomXml(""String_Node_Str"");
  labelHandle.setProperty(IStyleModel.WIDOWS_PROP,""String_Node_Str"");
  labelHandle.setProperty(IStyleModel.ORPHANS_PROP,""String_Node_Str"");
  assertEquals(ReportDesign.BODY_SLOT,labelHandle.getContainer().findContentSlot(labelHandle));
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  labelHandle.setPushDown(true);
  save();
  assertTrue(compareFile(goldenFileName));
}","/** 
 * This test sets properties, writes the design file and compares it with golden file.
 * @throws Exception if opening or saving design file failed.
 */
public void testWriter() throws Exception {
  LabelHandle labelHandle=getLabel();
  labelHandle.setProperty(Label.X_PROP,""String_Node_Str"");
  labelHandle.setProperty(Label.HEIGHT_PROP,""String_Node_Str"");
  labelHandle.setProperty(Label.STYLE_PROP,null);
  OdaDataSet dataSet=(OdaDataSet)design.findDataSet(""String_Node_Str"");
  assertNotNull(dataSet);
  labelHandle.setProperty(Label.DATA_SET_PROP,null);
  labelHandle.setProperty(Label.NAME_PROP,""String_Node_Str"");
  ActionHandle action=labelHandle.getActionHandle();
  assertNotNull(action);
  action.setURI(""String_Node_Str"");
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  assertEquals(ReportDesign.BODY_SLOT,labelHandle.getContainer().findContentSlot(labelHandle));
  labelHandle.setProperty(Style.COLOR_PROP,""String_Node_Str"");
  assertEquals(ReportDesign.BODY_SLOT,labelHandle.getContainer().findContentSlot(labelHandle));
  labelHandle.setText(""String_Node_Str"");
  labelHandle.setWidth(""String_Node_Str"");
  labelHandle.setTextKey(""String_Node_Str"");
  labelHandle.setHelpText(""String_Node_Str"");
  labelHandle.setHelpTextKey(""String_Node_Str"");
  labelHandle.setTagType(""String_Node_Str"");
  labelHandle.setLanguage(""String_Node_Str"");
  labelHandle.setAltText(""String_Node_Str"");
  labelHandle.setOrder(1);
  labelHandle.setCustomXml(""String_Node_Str"");
  labelHandle.setProperty(IStyleModel.WIDOWS_PROP,""String_Node_Str"");
  labelHandle.setProperty(IStyleModel.ORPHANS_PROP,""String_Node_Str"");
  assertEquals(ReportDesign.BODY_SLOT,labelHandle.getContainer().findContentSlot(labelHandle));
  labelHandle=(LabelHandle)designHandle.findElement(""String_Node_Str"");
  labelHandle.setPushDown(true);
  save();
  assertTrue(compareFile(goldenFileName));
}",0.997627208014764
64998,"/** 
 * Test the slots of List item.
 * @throws Exception if any exception
 */
public void testParser() throws Exception {
  ListItem list=(ListItem)design.findElement(""String_Node_Str"");
  assertNotNull(list);
  ListHandle listHandle=list.handle(design);
  assertEquals(""String_Node_Str"",listHandle.getOnCreate());
  assertEquals(""String_Node_Str"",listHandle.getOnPrepare());
  assertEquals(""String_Node_Str"",listHandle.getOnRender());
  assertEquals(""String_Node_Str"",listHandle.getOnPageBreak());
  assertEquals(""String_Node_Str"",listHandle.getRole());
  assertEquals(""String_Node_Str"",listHandle.getLanguage());
  assertEquals(""String_Node_Str"",listHandle.getAltText());
  assertEquals(120,listHandle.getPageBreakInterval());
  Iterator sortKeys=listHandle.sortsIterator();
  SortKeyHandle sortKeyHandle=(SortKeyHandle)sortKeys.next();
  assertEquals(""String_Node_Str"",sortKeyHandle.getKey());
  assertEquals(""String_Node_Str"",sortKeyHandle.getDirection());
  sortKeyHandle=(SortKeyHandle)sortKeys.next();
  assertEquals(""String_Node_Str"",sortKeyHandle.getKey());
  assertEquals(""String_Node_Str"",sortKeyHandle.getDirection());
  assertNull(sortKeys.next());
  Iterator filters=listHandle.filtersIterator();
  FilterConditionHandle filterHandle=(FilterConditionHandle)filters.next();
  assertEquals(""String_Node_Str"",filterHandle.getOperator());
  assertEquals(""String_Node_Str"",filterHandle.getExpr());
  assertEquals(""String_Node_Str"",filterHandle.getValue1());
  assertEquals(""String_Node_Str"",filterHandle.getValue2());
  MultiElementSlot header=(MultiElementSlot)list.getSlot(ListItem.HEADER_SLOT);
  FreeForm form=(FreeForm)header.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  MultiElementSlot detail=(MultiElementSlot)list.getSlot(ListItem.DETAIL_SLOT);
  form=(FreeForm)detail.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  MultiElementSlot footer=(MultiElementSlot)list.getSlot(ListItem.FOOTER_SLOT);
  form=(FreeForm)footer.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  MultiElementSlot groupSlot=(MultiElementSlot)list.getSlot(ListItem.GROUP_SLOT);
  ListGroup group=(ListGroup)groupSlot.getContent(0);
  ListGroupHandle groupHandle=(ListGroupHandle)group.getHandle(design);
  assertEquals(""String_Node_Str"",groupHandle.getGroupStart());
  assertEquals(""String_Node_Str"",groupHandle.getTocExpression());
  assertTrue(groupHandle.hideDetail());
  assertFalse(groupHandle.showDetailFilter());
  filters=groupHandle.filtersIterator();
  filterHandle=(FilterConditionHandle)filters.next();
  assertEquals(""String_Node_Str"",filterHandle.getOperator());
  assertEquals(""String_Node_Str"",filterHandle.getExpr());
  assertEquals(""String_Node_Str"",filterHandle.getValue1());
  assertEquals(""String_Node_Str"",filterHandle.getValue2());
  header=(MultiElementSlot)group.getSlot(ListGroup.HEADER_SLOT);
  form=(FreeForm)header.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  footer=(MultiElementSlot)group.getSlot(ListGroup.FOOTER_SLOT);
  form=(FreeForm)footer.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  assertEquals(""String_Node_Str"",groupHandle.getInterval());
  assertTrue(3.0 == groupHandle.getIntervalRange());
  assertEquals(""String_Node_Str"",groupHandle.getSortDirection());
  assertEquals(""String_Node_Str"",groupHandle.getSortType());
  assertEquals(""String_Node_Str"",groupHandle.getKeyExpr());
  assertEquals(""String_Node_Str"",groupHandle.getName());
  assertEquals(""String_Node_Str"",groupHandle.getOnCreate());
  assertEquals(""String_Node_Str"",groupHandle.getOnPrepare());
  assertEquals(""String_Node_Str"",groupHandle.getOnRender());
  assertEquals(""String_Node_Str"",groupHandle.getOnPageBreak());
  sortKeys=groupHandle.sortsIterator();
  sortKeyHandle=(SortKeyHandle)sortKeys.next();
  assertEquals(""String_Node_Str"",sortKeyHandle.getKey());
  assertEquals(""String_Node_Str"",sortKeyHandle.getDirection());
  sortKeyHandle=(SortKeyHandle)sortKeys.next();
  assertEquals(""String_Node_Str"",sortKeyHandle.getKey());
  assertEquals(""String_Node_Str"",sortKeyHandle.getDirection());
  assertEquals(""String_Node_Str"",groupHandle.getBookmark());
  ListItem list2=(ListItem)design.findElement(""String_Node_Str"");
  ListHandle list2Handle=list2.handle(design);
  assertEquals(""String_Node_Str"",list2Handle.getRole());
}","/** 
 * Test the slots of List item.
 * @throws Exception if any exception
 */
public void testParser() throws Exception {
  ListItem list=(ListItem)design.findElement(""String_Node_Str"");
  assertNotNull(list);
  ListHandle listHandle=list.handle(design);
  assertEquals(""String_Node_Str"",listHandle.getOnCreate());
  assertEquals(""String_Node_Str"",listHandle.getOnPrepare());
  assertEquals(""String_Node_Str"",listHandle.getOnRender());
  assertEquals(""String_Node_Str"",listHandle.getOnPageBreak());
  assertEquals(""String_Node_Str"",listHandle.getTagType());
  assertEquals(""String_Node_Str"",listHandle.getLanguage());
  assertEquals(""String_Node_Str"",listHandle.getAltText());
  assertEquals(120,listHandle.getPageBreakInterval());
  Iterator sortKeys=listHandle.sortsIterator();
  SortKeyHandle sortKeyHandle=(SortKeyHandle)sortKeys.next();
  assertEquals(""String_Node_Str"",sortKeyHandle.getKey());
  assertEquals(""String_Node_Str"",sortKeyHandle.getDirection());
  sortKeyHandle=(SortKeyHandle)sortKeys.next();
  assertEquals(""String_Node_Str"",sortKeyHandle.getKey());
  assertEquals(""String_Node_Str"",sortKeyHandle.getDirection());
  assertNull(sortKeys.next());
  Iterator filters=listHandle.filtersIterator();
  FilterConditionHandle filterHandle=(FilterConditionHandle)filters.next();
  assertEquals(""String_Node_Str"",filterHandle.getOperator());
  assertEquals(""String_Node_Str"",filterHandle.getExpr());
  assertEquals(""String_Node_Str"",filterHandle.getValue1());
  assertEquals(""String_Node_Str"",filterHandle.getValue2());
  MultiElementSlot header=(MultiElementSlot)list.getSlot(ListItem.HEADER_SLOT);
  FreeForm form=(FreeForm)header.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  MultiElementSlot detail=(MultiElementSlot)list.getSlot(ListItem.DETAIL_SLOT);
  form=(FreeForm)detail.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  MultiElementSlot footer=(MultiElementSlot)list.getSlot(ListItem.FOOTER_SLOT);
  form=(FreeForm)footer.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  MultiElementSlot groupSlot=(MultiElementSlot)list.getSlot(ListItem.GROUP_SLOT);
  ListGroup group=(ListGroup)groupSlot.getContent(0);
  ListGroupHandle groupHandle=(ListGroupHandle)group.getHandle(design);
  assertEquals(""String_Node_Str"",groupHandle.getGroupStart());
  assertEquals(""String_Node_Str"",groupHandle.getTocExpression());
  assertTrue(groupHandle.hideDetail());
  assertFalse(groupHandle.showDetailFilter());
  filters=groupHandle.filtersIterator();
  filterHandle=(FilterConditionHandle)filters.next();
  assertEquals(""String_Node_Str"",filterHandle.getOperator());
  assertEquals(""String_Node_Str"",filterHandle.getExpr());
  assertEquals(""String_Node_Str"",filterHandle.getValue1());
  assertEquals(""String_Node_Str"",filterHandle.getValue2());
  header=(MultiElementSlot)group.getSlot(ListGroup.HEADER_SLOT);
  form=(FreeForm)header.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  footer=(MultiElementSlot)group.getSlot(ListGroup.FOOTER_SLOT);
  form=(FreeForm)footer.getContent(0);
  assertEquals(""String_Node_Str"",form.getStringProperty(design,FreeForm.COMMENTS_PROP));
  assertEquals(""String_Node_Str"",groupHandle.getInterval());
  assertTrue(3.0 == groupHandle.getIntervalRange());
  assertEquals(""String_Node_Str"",groupHandle.getSortDirection());
  assertEquals(""String_Node_Str"",groupHandle.getSortType());
  assertEquals(""String_Node_Str"",groupHandle.getKeyExpr());
  assertEquals(""String_Node_Str"",groupHandle.getName());
  assertEquals(""String_Node_Str"",groupHandle.getOnCreate());
  assertEquals(""String_Node_Str"",groupHandle.getOnPrepare());
  assertEquals(""String_Node_Str"",groupHandle.getOnRender());
  assertEquals(""String_Node_Str"",groupHandle.getOnPageBreak());
  sortKeys=groupHandle.sortsIterator();
  sortKeyHandle=(SortKeyHandle)sortKeys.next();
  assertEquals(""String_Node_Str"",sortKeyHandle.getKey());
  assertEquals(""String_Node_Str"",sortKeyHandle.getDirection());
  sortKeyHandle=(SortKeyHandle)sortKeys.next();
  assertEquals(""String_Node_Str"",sortKeyHandle.getKey());
  assertEquals(""String_Node_Str"",sortKeyHandle.getDirection());
  assertEquals(""String_Node_Str"",groupHandle.getBookmark());
  ListItem list2=(ListItem)design.findElement(""String_Node_Str"");
  ListHandle list2Handle=list2.handle(design);
  assertEquals(""String_Node_Str"",list2Handle.getTagType());
}",0.9980119284294234
64999,"/** 
 * Test writer.
 * @throws Exception if any exception
 */
public void testWriter() throws Exception {
  ListHandle listHandle=(ListHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(listHandle);
  listHandle.setOnPrepare(""String_Node_Str"");
  listHandle.setOnCreate(""String_Node_Str"");
  listHandle.setOnRender(null);
  listHandle.setPageBreakInterval(100);
  listHandle.setOnPageBreak(""String_Node_Str"");
  listHandle.setRole(""String_Node_Str"");
  listHandle.setLanguage(""String_Node_Str"");
  listHandle.setAltText(""String_Node_Str"");
  GroupHandle groupHandle=(GroupHandle)listHandle.getGroups().get(0);
  groupHandle.setGroupStart(""String_Node_Str"");
  groupHandle.setTocExpression(""String_Node_Str"");
  groupHandle.setSortType(""String_Node_Str"");
  groupHandle.setOnPageBreak(""String_Node_Str"");
  groupHandle.setOnCreate(""String_Node_Str"");
  groupHandle.setOnRender(""String_Node_Str"");
  groupHandle.setShowDetailFilter(true);
  assertEquals(""String_Node_Str"",groupHandle.getBookmark());
  groupHandle.setBookmark(""String_Node_Str"");
  save();
  assertTrue(compareFile(goldenFileName));
}","/** 
 * Test writer.
 * @throws Exception if any exception
 */
public void testWriter() throws Exception {
  ListHandle listHandle=(ListHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(listHandle);
  listHandle.setOnPrepare(""String_Node_Str"");
  listHandle.setOnCreate(""String_Node_Str"");
  listHandle.setOnRender(null);
  listHandle.setPageBreakInterval(100);
  listHandle.setOnPageBreak(""String_Node_Str"");
  listHandle.setTagType(""String_Node_Str"");
  listHandle.setLanguage(""String_Node_Str"");
  listHandle.setAltText(""String_Node_Str"");
  GroupHandle groupHandle=(GroupHandle)listHandle.getGroups().get(0);
  groupHandle.setGroupStart(""String_Node_Str"");
  groupHandle.setTocExpression(""String_Node_Str"");
  groupHandle.setSortType(""String_Node_Str"");
  groupHandle.setOnPageBreak(""String_Node_Str"");
  groupHandle.setOnCreate(""String_Node_Str"");
  groupHandle.setOnRender(""String_Node_Str"");
  groupHandle.setShowDetailFilter(true);
  assertEquals(""String_Node_Str"",groupHandle.getBookmark());
  groupHandle.setBookmark(""String_Node_Str"");
  save();
  assertTrue(compareFile(goldenFileName));
}",0.995973154362416
65000,"/** 
 * Test parser and properties of table element.
 * @throws Exception
 */
public void testParser() throws Exception {
  openDesign(fileName);
  save();
  TableHandle table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  assertEquals(""String_Node_Str"",table.getEventHandlerClass());
  assertTrue(table.newHandlerOnEachEvent());
  assertEquals(""String_Node_Str"",table.getOnCreate());
  assertEquals(""String_Node_Str"",table.getOnRender());
  assertEquals(""String_Node_Str"",table.getOnPrepare());
  assertFalse(table.repeatHeader());
  assertEquals(""String_Node_Str"",table.getCaption());
  assertEquals(""String_Node_Str"",table.getCaptionKey());
  assertEquals(""String_Node_Str"",table.getSummary());
  assertEquals(3,table.getColumnCount());
  assertEquals(""String_Node_Str"",table.getRole());
  assertEquals(""String_Node_Str"",table.getLanguage());
  assertEquals(1,table.getOrder());
  Iterator sorts=table.sortsIterator();
  SortKeyHandle sortHandle=(SortKeyHandle)sorts.next();
  assertEquals(""String_Node_Str"",sortHandle.getKey());
  assertEquals(""String_Node_Str"",sortHandle.getDirection());
  sortHandle=(SortKeyHandle)sorts.next();
  assertEquals(""String_Node_Str"",sortHandle.getKey());
  assertEquals(""String_Node_Str"",sortHandle.getDirection());
  assertNull(sorts.next());
  Iterator filters=table.filtersIterator();
  FilterConditionHandle filterHandle=(FilterConditionHandle)filters.next();
  assertEquals(""String_Node_Str"",filterHandle.getOperator());
  assertEquals(""String_Node_Str"",filterHandle.getExpr());
  assertEquals(""String_Node_Str"",filterHandle.getValue1());
  assertEquals(""String_Node_Str"",filterHandle.getValue2());
  assertFalse(table.isSortByGroups());
  SlotHandle headerSlot=table.getHeader();
  assertNotNull(headerSlot);
  RowHandle rowHandle=(RowHandle)headerSlot.get(0);
  assertFalse(rowHandle.repeatable());
  testReadVisibilityRules(rowHandle);
  assertEquals(1,headerSlot.getCount());
  SlotHandle detailSlot=table.getDetail();
  assertNotNull(detailSlot);
  assertEquals(1,detailSlot.getCount());
  RowHandle row=(RowHandle)detailSlot.get(0);
  assertTrue(row.suppressDuplicates());
  assertEquals(""String_Node_Str"",row.getBookmark());
  assertEquals(""String_Node_Str"",row.getBookmarkDisplayName());
  assertEquals(""String_Node_Str"",row.getEventHandlerClass());
  assertTrue(row.newHandlerOnEachEvent());
  assertEquals(""String_Node_Str"",row.getOnCreate());
  assertEquals(""String_Node_Str"",row.getOnRender());
  assertEquals(""String_Node_Str"",row.getOnPrepare());
  assertEquals(""String_Node_Str"",row.getRole());
  assertEquals(""String_Node_Str"",row.getLanguage());
  SlotHandle headSlot=table.getHeader();
  RowHandle headRow=(RowHandle)headSlot.get(0);
  assertEquals(""String_Node_Str"",headRow.getRole());
  ColumnHandle column=(ColumnHandle)table.getColumns().get(2);
  assertTrue(column.getBooleanProperty(TableColumn.SUPPRESS_DUPLICATES_PROP));
  Iterator hideRules=column.visibilityRulesIterator();
  assertTrue(hideRules.hasNext());
  HideRuleHandle hideRule=(HideRuleHandle)hideRules.next();
  assertEquals(DesignChoiceConstants.FORMAT_TYPE_VIEWER,hideRule.getFormat());
  assertEquals(""String_Node_Str"",hideRule.getExpression());
  SlotHandle cells=row.getCells();
  assertNotNull(cells);
  assertEquals(1,cells.getCount());
  CellHandle cell=(CellHandle)cells.get(0);
  assertEquals(""String_Node_Str"",cell.getBookmark());
  assertEquals(""String_Node_Str"",cell.getBookmarkDisplayName());
  assertEquals(""String_Node_Str"",cell.getEventHandlerClass());
  assertTrue(cell.newHandlerOnEachEvent());
  assertEquals(""String_Node_Str"",cell.getOnCreate());
  assertEquals(""String_Node_Str"",cell.getOnRender());
  assertEquals(""String_Node_Str"",cell.getOnPrepare());
  SlotHandle groupSlot=table.getGroups();
  assertNotNull(groupSlot);
  assertEquals(1,groupSlot.getCount());
  TableGroupHandle group=(TableGroupHandle)groupSlot.get(0);
  assertEquals(DesignChoiceConstants.INTERVAL_WEEK,group.getInterval());
  assertTrue(3.0 == group.getIntervalRange());
  assertEquals(""String_Node_Str"",group.getSortDirection());
  assertEquals(""String_Node_Str"",group.getKeyExpr());
  assertEquals(""String_Node_Str"",group.getTOC().getExpression());
  assertEquals(""String_Node_Str"",group.getACLExpression());
  assertFalse(group.cascadeACL());
  assertEquals(""String_Node_Str"",group.getBookmark());
  assertEquals(""String_Node_Str"",group.getBookmarkDisplayName());
  assertEquals(""String_Node_Str"",group.getEventHandlerClass());
  assertTrue(group.newHandlerOnEachEvent());
  assertEquals(""String_Node_Str"",group.getOnCreate());
  assertEquals(""String_Node_Str"",group.getOnRender());
  assertEquals(""String_Node_Str"",group.getOnPrepare());
  sorts=group.sortsIterator();
  sortHandle=(SortKeyHandle)sorts.next();
  assertEquals(""String_Node_Str"",sortHandle.getKey());
  assertEquals(""String_Node_Str"",sortHandle.getDirection());
  sortHandle=(SortKeyHandle)sorts.next();
  assertEquals(""String_Node_Str"",sortHandle.getKey());
  assertEquals(""String_Node_Str"",sortHandle.getDirection());
  filters=group.filtersIterator();
  filterHandle=(FilterConditionHandle)filters.next();
  assertEquals(""String_Node_Str"",filterHandle.getOperator());
  assertEquals(""String_Node_Str"",filterHandle.getExpr());
  assertEquals(""String_Node_Str"",filterHandle.getValue1());
  assertEquals(""String_Node_Str"",filterHandle.getValue2());
  SlotHandle groupHeaderSlot=group.getHeader();
  assertEquals(2,groupHeaderSlot.getCount());
  SlotHandle groupFooterSlot=group.getFooter();
  assertEquals(1,groupFooterSlot.getCount());
  SlotHandle footerSlot=table.getFooter();
  assertNotNull(footerSlot);
  assertEquals(1,footerSlot.getCount());
  rowHandle=(RowHandle)footerSlot.get(0);
  assertTrue(rowHandle.repeatable());
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  assertEquals(""String_Node_Str"",table.getRole());
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
}","/** 
 * Test parser and properties of table element.
 * @throws Exception
 */
public void testParser() throws Exception {
  openDesign(fileName);
  save();
  TableHandle table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  assertEquals(""String_Node_Str"",table.getEventHandlerClass());
  assertTrue(table.newHandlerOnEachEvent());
  assertEquals(""String_Node_Str"",table.getOnCreate());
  assertEquals(""String_Node_Str"",table.getOnRender());
  assertEquals(""String_Node_Str"",table.getOnPrepare());
  assertFalse(table.repeatHeader());
  assertEquals(""String_Node_Str"",table.getCaption());
  assertEquals(""String_Node_Str"",table.getCaptionKey());
  assertEquals(""String_Node_Str"",table.getSummary());
  assertEquals(3,table.getColumnCount());
  assertEquals(""String_Node_Str"",table.getTagType());
  assertEquals(""String_Node_Str"",table.getLanguage());
  assertEquals(1,table.getOrder());
  Iterator sorts=table.sortsIterator();
  SortKeyHandle sortHandle=(SortKeyHandle)sorts.next();
  assertEquals(""String_Node_Str"",sortHandle.getKey());
  assertEquals(""String_Node_Str"",sortHandle.getDirection());
  sortHandle=(SortKeyHandle)sorts.next();
  assertEquals(""String_Node_Str"",sortHandle.getKey());
  assertEquals(""String_Node_Str"",sortHandle.getDirection());
  assertNull(sorts.next());
  Iterator filters=table.filtersIterator();
  FilterConditionHandle filterHandle=(FilterConditionHandle)filters.next();
  assertEquals(""String_Node_Str"",filterHandle.getOperator());
  assertEquals(""String_Node_Str"",filterHandle.getExpr());
  assertEquals(""String_Node_Str"",filterHandle.getValue1());
  assertEquals(""String_Node_Str"",filterHandle.getValue2());
  assertFalse(table.isSortByGroups());
  SlotHandle headerSlot=table.getHeader();
  assertNotNull(headerSlot);
  RowHandle rowHandle=(RowHandle)headerSlot.get(0);
  assertFalse(rowHandle.repeatable());
  testReadVisibilityRules(rowHandle);
  assertEquals(1,headerSlot.getCount());
  SlotHandle detailSlot=table.getDetail();
  assertNotNull(detailSlot);
  assertEquals(1,detailSlot.getCount());
  RowHandle row=(RowHandle)detailSlot.get(0);
  assertTrue(row.suppressDuplicates());
  assertEquals(""String_Node_Str"",row.getBookmark());
  assertEquals(""String_Node_Str"",row.getBookmarkDisplayName());
  assertEquals(""String_Node_Str"",row.getEventHandlerClass());
  assertTrue(row.newHandlerOnEachEvent());
  assertEquals(""String_Node_Str"",row.getOnCreate());
  assertEquals(""String_Node_Str"",row.getOnRender());
  assertEquals(""String_Node_Str"",row.getOnPrepare());
  assertEquals(""String_Node_Str"",row.getTagType());
  assertEquals(""String_Node_Str"",row.getLanguage());
  SlotHandle headSlot=table.getHeader();
  RowHandle headRow=(RowHandle)headSlot.get(0);
  assertEquals(""String_Node_Str"",headRow.getTagType());
  ColumnHandle column=(ColumnHandle)table.getColumns().get(2);
  assertTrue(column.getBooleanProperty(TableColumn.SUPPRESS_DUPLICATES_PROP));
  Iterator hideRules=column.visibilityRulesIterator();
  assertTrue(hideRules.hasNext());
  HideRuleHandle hideRule=(HideRuleHandle)hideRules.next();
  assertEquals(DesignChoiceConstants.FORMAT_TYPE_VIEWER,hideRule.getFormat());
  assertEquals(""String_Node_Str"",hideRule.getExpression());
  SlotHandle cells=row.getCells();
  assertNotNull(cells);
  assertEquals(1,cells.getCount());
  CellHandle cell=(CellHandle)cells.get(0);
  assertEquals(""String_Node_Str"",cell.getBookmark());
  assertEquals(""String_Node_Str"",cell.getBookmarkDisplayName());
  assertEquals(""String_Node_Str"",cell.getEventHandlerClass());
  assertTrue(cell.newHandlerOnEachEvent());
  assertEquals(""String_Node_Str"",cell.getOnCreate());
  assertEquals(""String_Node_Str"",cell.getOnRender());
  assertEquals(""String_Node_Str"",cell.getOnPrepare());
  SlotHandle groupSlot=table.getGroups();
  assertNotNull(groupSlot);
  assertEquals(1,groupSlot.getCount());
  TableGroupHandle group=(TableGroupHandle)groupSlot.get(0);
  assertEquals(DesignChoiceConstants.INTERVAL_WEEK,group.getInterval());
  assertTrue(3.0 == group.getIntervalRange());
  assertEquals(""String_Node_Str"",group.getSortDirection());
  assertEquals(""String_Node_Str"",group.getKeyExpr());
  assertEquals(""String_Node_Str"",group.getTOC().getExpression());
  assertEquals(""String_Node_Str"",group.getACLExpression());
  assertFalse(group.cascadeACL());
  assertEquals(""String_Node_Str"",group.getBookmark());
  assertEquals(""String_Node_Str"",group.getBookmarkDisplayName());
  assertEquals(""String_Node_Str"",group.getEventHandlerClass());
  assertTrue(group.newHandlerOnEachEvent());
  assertEquals(""String_Node_Str"",group.getOnCreate());
  assertEquals(""String_Node_Str"",group.getOnRender());
  assertEquals(""String_Node_Str"",group.getOnPrepare());
  sorts=group.sortsIterator();
  sortHandle=(SortKeyHandle)sorts.next();
  assertEquals(""String_Node_Str"",sortHandle.getKey());
  assertEquals(""String_Node_Str"",sortHandle.getDirection());
  sortHandle=(SortKeyHandle)sorts.next();
  assertEquals(""String_Node_Str"",sortHandle.getKey());
  assertEquals(""String_Node_Str"",sortHandle.getDirection());
  filters=group.filtersIterator();
  filterHandle=(FilterConditionHandle)filters.next();
  assertEquals(""String_Node_Str"",filterHandle.getOperator());
  assertEquals(""String_Node_Str"",filterHandle.getExpr());
  assertEquals(""String_Node_Str"",filterHandle.getValue1());
  assertEquals(""String_Node_Str"",filterHandle.getValue2());
  SlotHandle groupHeaderSlot=group.getHeader();
  assertEquals(2,groupHeaderSlot.getCount());
  SlotHandle groupFooterSlot=group.getFooter();
  assertEquals(1,groupFooterSlot.getCount());
  SlotHandle footerSlot=table.getFooter();
  assertNotNull(footerSlot);
  assertEquals(1,footerSlot.getCount());
  rowHandle=(RowHandle)footerSlot.get(0);
  assertTrue(rowHandle.repeatable());
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  assertEquals(""String_Node_Str"",table.getTagType());
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
  table=(TableHandle)designHandle.findElement(""String_Node_Str"");
  assertNotNull(table);
}",0.9972472855176632
