record_number,buggy_code,fixed_code,code_similarity
3001,"@BeforeClass public void startServer() throws Exception {
  tempDir=DeploymentUtils.createTempDir(""String_Node_Str"");
  Map<String,String> properties=ImmutableMap.<String,String>builder().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",tempDir.getAbsolutePath()).build();
  Injector injector=Guice.createInjector(new TestingHttpServerModule(),new JaxrsModule(),new AgentMainModule(),new ConfigurationModule(new ConfigurationFactory(properties)));
  server=injector.getInstance(TestingHttpServer.class);
  agent=injector.getInstance(Agent.class);
  server.start();
  client=new AsyncHttpClient();
  testRepository=RepositoryTestHelper.createTestRepository();
  appleAssignment=newAssignment(""String_Node_Str"",""String_Node_Str"");
  bananaAssignment=newAssignment(""String_Node_Str"",""String_Node_Str"");
}","@BeforeClass public void startServer() throws Exception {
  tempDir=DeploymentUtils.createTempDir(""String_Node_Str"");
  Map<String,String> properties=ImmutableMap.<String,String>builder().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",tempDir.getAbsolutePath()).build();
  Injector injector=Guice.createInjector(new TestingHttpServerModule(),new JaxrsModule(),new AgentMainModule(),new ConfigurationModule(new ConfigurationFactory(properties)));
  server=injector.getInstance(TestingHttpServer.class);
  agent=injector.getInstance(Agent.class);
  server.start();
  client=new AsyncHttpClient();
  testRepository=RepositoryTestHelper.createTestRepository();
  appleAssignment=newAssignment(""String_Node_Str"",""String_Node_Str"");
  bananaAssignment=newAssignment(""String_Node_Str"",""String_Node_Str"");
}",0.9754637941352484
3002,"/** 
 * Causes all old versions older than the specified parameter to be discarded.
 * @param preserveVersion The version to be preserved.
 */
public void flushOldVersions(long preserveVersion){
  VersionedObject<T> vo=currentVersion;
  for (; ; ) {
    if (vo == null)     return;
    if (vo.getVersion() <= preserveVersion) {
      vo.clearOldVersions();
      return;
    }
    vo=vo.getOlderVersion();
  }
}","/** 
 * Causes all old versions older than the specified parameter to be discarded.
 * @param preserveVersion The version to be preserved.
 */
public void flushOldVersions(long preserveVersion){
  VersionedObject<T> vo=currentVersion;
  for (; ; ) {
    if (vo == null)     return;
    if (vo.getVersion() < preserveVersion) {
      vo.clearOldVersions();
      return;
    }
    vo=vo.getOlderVersion();
  }
}",0.9987819732034104
3003,"public byte[] getPrefixData(){
  StringBuffer sb=new StringBuffer();
  Set<String> set=jibbleMap.keySet();
  for (  String s : set) {
    sb.append(s);
    int l=s.length();
    while (l < 4) {
      l++;
      sb.append(' ');
    }
  }
  String data=sb.toString();
  try {
    return data.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new Error(""String_Node_Str"",e);
  }
}","public byte[] getPrefixData(){
  if (prefixData != null) {
    return prefixData;
  }
  StringBuffer sb=new StringBuffer();
  Set<String> set=jibbleMap.keySet();
  for (  String s : set) {
    sb.append(s);
    int l=s.length();
    while (l < 4) {
      l++;
      sb.append(' ');
    }
  }
  String data=sb.toString();
  try {
    prefixData=data.getBytes(""String_Node_Str"");
    return prefixData;
  }
 catch (  UnsupportedEncodingException e) {
    throw new Error(""String_Node_Str"",e);
  }
}",0.8945054945054945
3004,"@Override public Iterable<T> doInTransaction(TransactionStatus status){
  return repo.save(objects);
}","public Iterable<T> doInTransaction(TransactionStatus status){
  return repo.save(objects);
}",0.9484536082474226
3005,"private void save(final ArrayList<T> objects){
  new TransactionTemplate(transactionManager).execute(new TransactionCallback<Iterable<T>>(){
    @Override public Iterable<T> doInTransaction(    TransactionStatus status){
      return repo.save(objects);
    }
  }
);
}","private void save(final ArrayList<T> objects){
  new TransactionTemplate(transactionManager).execute(new TransactionCallback<Iterable<T>>(){
    public Iterable<T> doInTransaction(    TransactionStatus status){
      return repo.save(objects);
    }
  }
);
}",0.9049429657794676
3006,"private Object wrapValue(String key,Object value,Class<? extends IAttribute> dbClass){
  if (dbClass.equals(EnumExclusiveValue.class)) {
    return new EnumAttribute(key,null,(String)value);
  }
  if (dbClass.equals(EnumMultipleValue.class)) {
    return new MultiEnumAttribute(key,null,(String[])value);
  }
  return value;
}","private Object wrapValue(String key,Object value,Class<? extends IAttribute> dbClass){
  if (dbClass.equals(EnumExclusiveValue.class)) {
    return new EnumAttribute(key,""String_Node_Str"",(String)value);
  }
  if (dbClass.equals(EnumMultipleValue.class)) {
    return new MultiEnumAttribute(key,""String_Node_Str"",(String[])value);
  }
  return value;
}",0.9380530973451328
3007,"private static void addScorerMappings(){
  Map<String,Class<?>> currentAttrNameMap;
  currentAttrNameMap=new HashMap<String,Class<?>>(1);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",BooleanValue.class);
  currentAttrNameMap.put(""String_Node_Str"",BooleanValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",EnumMultipleValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumMultipleValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(3);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(4);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(4);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(3);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
}","private static void addScorerMappings(){
  Map<String,Class<?>> currentAttrNameMap;
  currentAttrNameMap=new HashMap<String,Class<?>>(1);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",BooleanValue.class);
  currentAttrNameMap.put(""String_Node_Str"",BooleanValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",EnumMultipleValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumMultipleValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",FloatRangePreference.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(3);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(2);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(4);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  currentAttrNameMap.put(""String_Node_Str"",EcefVector.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(4);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  currentAttrNameMap.put(""String_Node_Str"",EnumExclusiveValue.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
  currentAttrNameMap=new HashMap<String,Class<?>>(3);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  currentAttrNameMap.put(""String_Node_Str"",FloatHave.class);
  scorerNameMap.put(""String_Node_Str"",currentAttrNameMap);
}",0.9974892925712596
3008,"@SuppressWarnings(""String_Node_Str"") public JibbleConvertor(Logger log){
  log.info(""String_Node_Str"" + jibbleFile);
  try {
    jibbleMap=(TreeMap<String,PostcodeResult>)FileUtils.readObjectFromGZip(jibbleFile);
  }
 catch (  Error e) {
    log.error(""String_Node_Str"" + e.getCause().getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") public JibbleConvertor(Logger removeThis){
  log.info(""String_Node_Str"" + jibbleFile);
  try {
    jibbleMap=(TreeMap<String,PostcodeResult>)FileUtils.readObjectFromGZip(jibbleFile);
  }
 catch (  Error e) {
    log.error(""String_Node_Str"" + e.getCause().getMessage());
  }
}",0.9789303079416533
3009,"public PostcodeResult lookupShort(String prefix){
  if (prefix == null || jibbleMap == null)   return null;
  prefix=StringUtils.stripSpaces(prefix.toUpperCase());
  return jibbleMap.get(prefix);
}","public PostcodeResult lookupShort(String prefix){
  if (prefix == null || jibbleMap == null)   return null;
  prefix=StringUtils.stripSpaces(prefix.toUpperCase());
  log.debug(""String_Node_Str"",prefix);
  return jibbleMap.get(prefix);
}",0.9099307159353348
3010,"/** 
 * Look up a full postcode.<br><br>WARNING - EXECUTING THIS FUNCTION COSTS 1p!!<br><br>
 * @param postcode A full postcode to lookup, any caps, any spaces
 * @return A PostcodeResult if the postcode is valid, otherwise null
 * @throws LostDbConnection
 */
public synchronized PostcodeResult lookupFull(String postcode){
  if (service != null) {
    return service.lookupFull(postcode);
  }
  log.debug(""String_Node_Str"",postcode);
  postcode=StringUtils.stripSpaces(postcode);
  int trimmedLength=postcode.length() - 3;
  if (trimmedLength != 3 && trimmedLength != 4)   return null;
  postcode=postcode.substring(0,trimmedLength);
  return jibble.lookupShort(postcode);
}","/** 
 * Look up a full postcode.<br><br>WARNING - EXECUTING THIS FUNCTION COSTS 1p!!<br><br>
 * @param postcode A full postcode to lookup, any caps, any spaces
 * @return A PostcodeResult if the postcode is valid, otherwise null
 * @throws LostDbConnection
 */
public synchronized PostcodeResult lookupFull(String postcode){
  if (service != null) {
    return service.lookupFull(postcode);
  }
  log.debug(""String_Node_Str"",postcode);
  postcode=StringUtils.stripSpaces(postcode);
  int trimmedLength=postcode.length() - 3;
  if (trimmedLength < 2 || trimmedLength > 4)   return null;
  postcode=postcode.substring(0,trimmedLength);
  return jibble.lookupShort(postcode);
}",0.988148148148148
3011,"/** 
 * On txLog playback, we want to apply transaction logs that include the transactions from the version of the currently loaded repository, forwards. Algo:  - keep track of highest version that is lower than current db version (as that might be the one) - if version == dbversion, return it, it's exact match (what we normally expect) - if version < dbversion but not greater than highestDbVer,  then remove it (as all it's transactions are in repos or have been applied) - if version < dbversion and > highestDbVer, update highestDbVer, and remember what file it is After have been through all, return the best found
 */
private File removeBestCandidate(ArrayList<File> candidates){
  File best=null;
  Iterator<File> i=candidates.iterator();
  while (i.hasNext()) {
    File file=i.next();
    long version=getDbVerFromFilename(file);
    if (version == -1) {
      continue;
    }
    if (version == startVersion) {
      i.remove();
      highestDbVer=version;
      return file;
    }
 else     if (version < startVersion) {
      if (version > highestDbVer && allowNonExact) {
        highestDbVer=version;
        best=file;
      }
 else {
        i.remove();
      }
    }
  }
  return best;
}","/** 
 * On txLog playback, we want to apply transaction logs that include the transactions from the version of the currently loaded repository, forwards. Algo:  - keep track of highest version that is lower than current db version (as that might be the one) - if version == dbversion, return it, it's exact match (what we normally expect) - if version < dbversion but not greater than highestDbVer,  then remove it (as all it's transactions are in repos or have been applied) - if version < dbversion and > highestDbVer, update highestDbVer, and remember what file it is After have been through all, return the best found
 */
private File removeBestCandidate(ArrayList<File> candidates){
  File best=null;
  Iterator<File> i=candidates.iterator();
  while (i.hasNext()) {
    File file=i.next();
    long version=getDbVerFromFilename(file);
    if (version == -1) {
      continue;
    }
    if (version == startVersion) {
      i.remove();
      highestDbVer=version;
      return file;
    }
 else     if (version < startVersion) {
      if (version > highestDbVer && allowNonExact) {
        highestDbVer=version;
        best=file;
      }
    }
 else {
      i.remove();
    }
  }
  return best;
}",0.9825581395348836
3012,public IDimensions clone() throws CloneNotSupportedException ;,public Object clone() throws CloneNotSupportedException ;,0.8739495798319328
3013,"protected static void performDrop(Location target,OtherBlocksContainer dropData){
  if (!isCreature(dropData.dropped)) {
    if (dropData.dropped.equalsIgnoreCase(""String_Node_Str"")) {
      Inventory inven=null;
switch (Material.valueOf(dropData.original)) {
case FURNACE:
case BURNING_FURNACE:
        Furnace oven=(Furnace)target.getBlock().getState();
      inven=oven.getInventory();
    ItemStack cooking=inven.getItem(0);
  if (oven.getCookTime() > 0)   cooking.setAmount(cooking.getAmount() - 1);
if (cooking.getAmount() <= 0) inven.setItem(0,null);
break;
case DISPENSER:
Dispenser trap=(Dispenser)target.getBlock().getState();
inven=trap.getInventory();
break;
case CHEST:
Chest box=(Chest)target.getBlock().getState();
inven=box.getInventory();
break;
}
if (inven != null) {
for (ItemStack item : inven.getContents()) {
if (item.getType() != Material.AIR) {
target.getWorld().dropItemNaturally(target,item);
}
}
}
}
 else if (Material.valueOf(dropData.dropped) != Material.AIR) {
target.getWorld().dropItemNaturally(target,new ItemStack(Material.valueOf(dropData.dropped),dropData.quantity,dropData.color));
}
}
 else {
target.getWorld().spawnCreature(new Location(target.getWorld(),target.getX() + 0.5,target.getY() + 1,target.getZ() + 0.5),CreatureType.valueOf(OtherBlocks.creatureName(dropData.dropped)));
}
}","protected static void performDrop(Location target,OtherBlocksContainer dropData){
  if (!isCreature(dropData.dropped)) {
    if (dropData.dropped.equalsIgnoreCase(""String_Node_Str"")) {
      Inventory inven=null;
switch (Material.valueOf(dropData.original)) {
case FURNACE:
case BURNING_FURNACE:
        Furnace oven=(Furnace)target.getBlock().getState();
      inven=oven.getInventory();
    ItemStack cooking=inven.getItem(0);
  if (oven.getCookTime() > 0)   cooking.setAmount(cooking.getAmount() - 1);
if (cooking.getAmount() <= 0) inven.setItem(0,null);
break;
case DISPENSER:
Dispenser trap=(Dispenser)target.getBlock().getState();
inven=trap.getInventory();
break;
case CHEST:
Chest box=(Chest)target.getBlock().getState();
inven=box.getInventory();
break;
}
if (inven != null) {
for (ItemStack item : inven.getContents()) {
if (item.getType() != Material.AIR) {
target.getWorld().dropItemNaturally(target,item);
}
}
}
}
 else if (Material.valueOf(dropData.dropped) != Material.AIR) {
target.getWorld().dropItemNaturally(target,new ItemStack(Material.valueOf(dropData.dropped),dropData.quantity,dropData.color));
}
}
 else {
for (Integer i=0; i < dropData.quantity; i++) {
target.getWorld().spawnCreature(new Location(target.getWorld(),target.getX() + 0.5,target.getY() + 1,target.getZ() + 0.5),CreatureType.valueOf(OtherBlocks.creatureName(dropData.dropped)));
}
}
}",0.981454005934718
3014,"@Override public void onEntityDeath(EntityDeathEvent event){
  if (!parent.damagerList.containsKey(event.getEntity())) {
    return;
  }
  Material weapon=parent.damagerList.get(event.getEntity()).tool;
  Entity victim=event.getEntity();
  CreatureType victimType=CommonEntity.getCreatureType(victim);
  parent.damagerList.remove(event.getEntity());
  for (  OtherBlocksContainer obc : parent.transformList) {
    if (!obc.worlds.contains(null) && !obc.worlds.contains(event.getEntity().getWorld().getName()))     continue;
    if (!OtherBlocks.containsValidToolString(weapon.toString(),obc.tool))     continue;
    if (!OtherBlocks.isCreature(obc.original) || CreatureType.valueOf(OtherBlocks.creatureName(obc.original)) != victimType) {
      continue;
    }
    if (parent.rng.nextDouble() > (obc.chance.doubleValue() / 100))     continue;
    event.getDrops().clear();
    Location location=victim.getLocation();
    OtherBlocks.performDrop(location,obc);
  }
}","@Override public void onEntityDeath(EntityDeathEvent event){
  if (!parent.damagerList.containsKey(event.getEntity())) {
    return;
  }
  Material weapon=parent.damagerList.get(event.getEntity()).tool;
  Entity victim=event.getEntity();
  CreatureType victimType=CommonEntity.getCreatureType(victim);
  parent.damagerList.remove(event.getEntity());
  for (  OtherBlocksContainer obc : parent.transformList) {
    if (!obc.worlds.contains(null) && !obc.worlds.contains(event.getEntity().getWorld().getName()))     continue;
    if (!OtherBlocks.containsValidToolString(weapon.toString(),obc.tool))     continue;
    if (!OtherBlocks.isCreature(obc.original) || CreatureType.valueOf(OtherBlocks.creatureName(obc.original)) != victimType) {
      continue;
    }
    if (parent.rng.nextDouble() > (obc.chance.doubleValue() / 100))     continue;
    setQuantity(obc);
    event.getDrops().clear();
    Location location=victim.getLocation();
    OtherBlocks.performDrop(location,obc);
  }
}",0.9887295081967212
3015,"public void onEnable(){
  getDataFolder().mkdirs();
  File yml=new File(getDataFolder(),""String_Node_Str"");
  if (!yml.exists()) {
    try {
      yml.createNewFile();
      log.info(""String_Node_Str"" + getDataFolder() + ""String_Node_Str"");
      getConfiguration().setProperty(""String_Node_Str"",null);
      getConfiguration().save();
    }
 catch (    IOException ex) {
      log.warning(getDescription().getName() + ""String_Node_Str"");
    }
  }
  verbosity=CommonPlugin.getVerbosity(this);
  pri=CommonPlugin.getPriority(this);
  List<String> keys=CommonPlugin.getRootKeys(this);
  if (keys == null) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  if (!keys.contains(""String_Node_Str"")) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  keys.clear();
  keys=getConfiguration().getKeys(""String_Node_Str"");
  if (null == keys) {
    log.info(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  for (  String s : keys) {
    List<Object> original_children=getConfiguration().getList(""String_Node_Str"" + s);
    if (original_children == null) {
      log.warning(""String_Node_Str"" + s + ""String_Node_Str"");
      continue;
    }
    for (    Object o : original_children) {
      if (o instanceof HashMap<?,?>) {
        OtherBlocksContainer bt=new OtherBlocksContainer();
        try {
          HashMap<?,?> m=(HashMap<?,?>)o;
          String originalString=s;
          if (isCreature(originalString)) {
            bt.original=""String_Node_Str"" + CreatureType.valueOf(creatureName(originalString)).toString();
          }
 else           if (isLeafDecay(originalString)) {
            bt.original=originalString;
          }
 else {
            bt.original=Material.valueOf(originalString).toString();
          }
          bt.tool=new ArrayList<Material>();
          if (isLeafDecay(bt.original)) {
            bt.tool.add((Material)null);
          }
 else           if (m.get(""String_Node_Str"") instanceof String) {
            String toolString=(String)m.get(""String_Node_Str"");
            if (toolString.equalsIgnoreCase(""String_Node_Str"")) {
              toolString=""String_Node_Str"";
            }
            if (toolString.equalsIgnoreCase(""String_Node_Str"") || toolString.equalsIgnoreCase(""String_Node_Str"")) {
              bt.tool.add((Material)null);
            }
 else {
              bt.tool.add(Material.valueOf(toolString));
            }
          }
 else           if (m.get(""String_Node_Str"") instanceof List<?>) {
            for (            Object listTool : (List<?>)m.get(""String_Node_Str"")) {
              bt.tool.add(Material.valueOf((String)listTool));
            }
          }
 else {
            throw new Exception(""String_Node_Str"");
          }
          String dropString=String.valueOf(m.get(""String_Node_Str""));
          if (dropString.equalsIgnoreCase(""String_Node_Str"")) {
            dropString=""String_Node_Str"";
          }
          if (isCreature(dropString)) {
            bt.dropped=""String_Node_Str"" + CreatureType.valueOf(creatureName(dropString)).toString();
          }
 else           if (dropString.equalsIgnoreCase(""String_Node_Str"")) {
            bt.dropped=""String_Node_Str"";
          }
 else {
            bt.dropped=Material.valueOf(dropString).toString();
          }
          String dropColor=String.valueOf(m.get(""String_Node_Str""));
          if (dropColor == ""String_Node_Str"") {
            bt.color=0;
          }
 else           if (dropString.equalsIgnoreCase(""String_Node_Str"")) {
            bt.color=CommonMaterial.getWoolColor(DyeColor.valueOf(dropColor));
          }
 else           if (dropString.equalsIgnoreCase(""String_Node_Str"")) {
            bt.color=CommonMaterial.getDyeColor(DyeColor.valueOf(dropColor));
          }
 else {
            bt.color=Short.valueOf(dropColor);
          }
          Integer dropQuantity=Integer.class.cast(m.get(""String_Node_Str""));
          bt.quantity=(dropQuantity == null || dropQuantity <= 0) ? 1 : dropQuantity;
          Integer toolDamage=Integer.class.cast(m.get(""String_Node_Str""));
          bt.damage=(toolDamage == null || toolDamage < 0) ? 1 : toolDamage;
          Double dropChance;
          try {
            dropChance=Double.valueOf(String.valueOf(m.get(""String_Node_Str"")));
            bt.chance=(dropChance < 0 || dropChance > 100) ? 100 : dropChance;
          }
 catch (          NumberFormatException ex) {
            bt.chance=100.0;
          }
          bt.worlds=new ArrayList<String>();
          if (m.get(""String_Node_Str"") == null) {
            bt.worlds.add((String)null);
          }
 else           if (m.get(""String_Node_Str"") instanceof String) {
            String worldString=(String)m.get(""String_Node_Str"");
            if (worldString.equalsIgnoreCase(""String_Node_Str"") || worldString.equalsIgnoreCase(""String_Node_Str"")) {
              bt.worlds.add((String)null);
            }
 else {
              bt.worlds.add(worldString);
            }
          }
 else           if (m.get(""String_Node_Str"") instanceof List<?>) {
            for (            Object listWorld : (List<?>)m.get(""String_Node_Str"")) {
              bt.worlds.add((String)listWorld);
            }
          }
 else {
            throw new Exception(""String_Node_Str"");
          }
        }
 catch (        Throwable ex) {
          if (verbosity > 1) {
            log.warning(""String_Node_Str"" + s + ""String_Node_Str""+ ex.getMessage());
          }
          ex.printStackTrace();
          continue;
        }
        transformList.add(bt);
        if (verbosity > 1) {
          log.info(getDescription().getName() + ""String_Node_Str"" + (bt.tool.contains(null) ? ""String_Node_Str"" : (bt.tool.size() == 1 ? bt.tool.get(0).toString() : bt.tool.toString()))+ ""String_Node_Str""+ creatureName(bt.original)+ ""String_Node_Str""+ (bt.quantity != 1 ? bt.quantity.toString() + ""String_Node_Str"" : ""String_Node_Str"")+ creatureName(bt.dropped)+ (bt.chance < 100 ? ""String_Node_Str"" + bt.chance.toString() + ""String_Node_Str"" : ""String_Node_Str""));
        }
      }
    }
  }
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,pri,this);
  pm.registerEvent(Event.Type.LEAVES_DECAY,blockListener,pri,this);
  pm.registerEvent(Event.Type.ENTITY_DEATH,entityListener,pri,this);
  pm.registerEvent(Event.Type.ENTITY_DAMAGED,entityListener,pri,this);
  log.info(getDescription().getName() + ""String_Node_Str"" + getDescription().getVersion()+ ""String_Node_Str"");
}","public void onEnable(){
  getDataFolder().mkdirs();
  File yml=new File(getDataFolder(),""String_Node_Str"");
  if (!yml.exists()) {
    try {
      yml.createNewFile();
      log.info(""String_Node_Str"" + getDataFolder() + ""String_Node_Str"");
      getConfiguration().setProperty(""String_Node_Str"",null);
      getConfiguration().save();
    }
 catch (    IOException ex) {
      log.warning(getDescription().getName() + ""String_Node_Str"");
    }
  }
  verbosity=CommonPlugin.getVerbosity(this);
  pri=CommonPlugin.getPriority(this);
  List<String> keys=CommonPlugin.getRootKeys(this);
  if (keys == null) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  if (!keys.contains(""String_Node_Str"")) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  keys.clear();
  keys=getConfiguration().getKeys(""String_Node_Str"");
  if (null == keys) {
    log.info(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  for (  String s : keys) {
    List<Object> original_children=getConfiguration().getList(""String_Node_Str"" + s);
    if (original_children == null) {
      log.warning(""String_Node_Str"" + s + ""String_Node_Str"");
      continue;
    }
    for (    Object o : original_children) {
      if (o instanceof HashMap<?,?>) {
        OtherBlocksContainer bt=new OtherBlocksContainer();
        try {
          HashMap<?,?> m=(HashMap<?,?>)o;
          String originalString=s;
          if (isCreature(originalString)) {
            bt.original=""String_Node_Str"" + CreatureType.valueOf(creatureName(originalString)).toString();
          }
 else           if (isLeafDecay(originalString)) {
            bt.original=originalString;
          }
 else {
            bt.original=Material.valueOf(originalString).toString();
          }
          bt.tool=new ArrayList<Material>();
          if (isLeafDecay(bt.original)) {
            bt.tool.add((Material)null);
          }
 else           if (m.get(""String_Node_Str"") instanceof String) {
            String toolString=(String)m.get(""String_Node_Str"");
            if (toolString.equalsIgnoreCase(""String_Node_Str"")) {
              toolString=""String_Node_Str"";
            }
            if (toolString.equalsIgnoreCase(""String_Node_Str"") || toolString.equalsIgnoreCase(""String_Node_Str"")) {
              bt.tool.add((Material)null);
            }
 else {
              bt.tool.add(Material.valueOf(toolString));
            }
          }
 else           if (m.get(""String_Node_Str"") instanceof List<?>) {
            for (            Object listTool : (List<?>)m.get(""String_Node_Str"")) {
              bt.tool.add(Material.valueOf((String)listTool));
            }
          }
 else {
            throw new Exception(""String_Node_Str"");
          }
          String dropString=String.valueOf(m.get(""String_Node_Str""));
          if (dropString.equalsIgnoreCase(""String_Node_Str"")) {
            dropString=""String_Node_Str"";
          }
          if (isCreature(dropString)) {
            bt.dropped=""String_Node_Str"" + CreatureType.valueOf(creatureName(dropString)).toString();
          }
 else           if (dropString.equalsIgnoreCase(""String_Node_Str"")) {
            bt.dropped=""String_Node_Str"";
          }
 else {
            bt.dropped=Material.valueOf(dropString).toString();
          }
          String dropColor=String.valueOf(m.get(""String_Node_Str""));
          if (dropColor == ""String_Node_Str"") {
            bt.color=0;
          }
 else           if (dropString.equalsIgnoreCase(""String_Node_Str"")) {
            bt.color=CommonMaterial.getWoolColor(DyeColor.valueOf(dropColor));
          }
 else           if (dropString.equalsIgnoreCase(""String_Node_Str"")) {
            bt.color=CommonMaterial.getDyeColor(DyeColor.valueOf(dropColor));
          }
 else {
            bt.color=Short.valueOf(dropColor);
          }
          try {
            Integer dropQuantity=Integer.class.cast(m.get(""String_Node_Str""));
            bt.min_quantity=(dropQuantity == null || dropQuantity <= 0) ? 1 : dropQuantity;
            bt.max_quantity=null;
          }
 catch (          ClassCastException x) {
            String dropQuantity=String.class.cast(m.get(""String_Node_Str""));
            String[] split=dropQuantity.split(""String_Node_Str"");
            bt.min_quantity=Integer.valueOf(split[0]);
            bt.max_quantity=Integer.valueOf(split[1]);
          }
          Integer toolDamage=Integer.class.cast(m.get(""String_Node_Str""));
          bt.damage=(toolDamage == null || toolDamage < 0) ? 1 : toolDamage;
          Double dropChance;
          try {
            dropChance=Double.valueOf(String.valueOf(m.get(""String_Node_Str"")));
            bt.chance=(dropChance < 0 || dropChance > 100) ? 100 : dropChance;
          }
 catch (          NumberFormatException ex) {
            bt.chance=100.0;
          }
          bt.worlds=new ArrayList<String>();
          if (m.get(""String_Node_Str"") == null) {
            bt.worlds.add((String)null);
          }
 else           if (m.get(""String_Node_Str"") instanceof String) {
            String worldString=(String)m.get(""String_Node_Str"");
            if (worldString.equalsIgnoreCase(""String_Node_Str"") || worldString.equalsIgnoreCase(""String_Node_Str"")) {
              bt.worlds.add((String)null);
            }
 else {
              bt.worlds.add(worldString);
            }
          }
 else           if (m.get(""String_Node_Str"") instanceof List<?>) {
            for (            Object listWorld : (List<?>)m.get(""String_Node_Str"")) {
              bt.worlds.add((String)listWorld);
            }
          }
 else {
            throw new Exception(""String_Node_Str"");
          }
        }
 catch (        Throwable ex) {
          if (verbosity > 1) {
            log.warning(""String_Node_Str"" + s + ""String_Node_Str""+ ex.getMessage());
          }
          ex.printStackTrace();
          continue;
        }
        transformList.add(bt);
        if (verbosity > 1) {
          log.info(getDescription().getName() + ""String_Node_Str"" + (bt.tool.contains(null) ? ""String_Node_Str"" : (bt.tool.size() == 1 ? bt.tool.get(0).toString() : bt.tool.toString()))+ ""String_Node_Str""+ creatureName(bt.original)+ ""String_Node_Str""+ (bt.min_quantity != 1 ? bt.min_quantity.toString() + (bt.max_quantity == null ? ""String_Node_Str"" : ""String_Node_Str"" + bt.max_quantity.toString()) + ""String_Node_Str"" : ""String_Node_Str"")+ creatureName(bt.dropped)+ (bt.chance < 100 ? ""String_Node_Str"" + bt.chance.toString() + ""String_Node_Str"" : ""String_Node_Str""));
        }
      }
    }
  }
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,pri,this);
  pm.registerEvent(Event.Type.LEAVES_DECAY,blockListener,pri,this);
  pm.registerEvent(Event.Type.ENTITY_DEATH,entityListener,pri,this);
  pm.registerEvent(Event.Type.ENTITY_DAMAGED,entityListener,pri,this);
  log.info(getDescription().getName() + ""String_Node_Str"" + getDescription().getVersion()+ ""String_Node_Str"");
}",0.9644490337807936
3016,"@Override public void onLeavesDecay(LeavesDecayEvent event){
  boolean successfulConversion=false;
  Block target=event.getBlock();
  if (event.isCancelled())   return;
  for (  OtherBlocksContainer obc : parent.transformList) {
    if (!OtherBlocks.isLeafDecay(obc.original))     continue;
    if (!containsValidString(target.getWorld().getName(),obc.worlds))     continue;
    if (parent.rng.nextDouble() > (obc.chance.doubleValue() / 100))     continue;
    successfulConversion=true;
    OtherBlocks.performDrop(target.getLocation(),obc);
  }
  if (successfulConversion) {
    event.setCancelled(true);
    target.setType(Material.AIR);
  }
}","@Override public void onLeavesDecay(LeavesDecayEvent event){
  boolean successfulConversion=false;
  Block target=event.getBlock();
  if (event.isCancelled())   return;
  for (  OtherBlocksContainer obc : parent.transformList) {
    if (!OtherBlocks.isLeafDecay(obc.original))     continue;
    if (!containsValidString(target.getWorld().getName(),obc.worlds))     continue;
    if (parent.rng.nextDouble() > (obc.chance.doubleValue() / 100))     continue;
    setQuantity(obc);
    successfulConversion=true;
    OtherBlocks.performDrop(target.getLocation(),obc);
  }
  if (successfulConversion) {
    event.setCancelled(true);
    target.setType(Material.AIR);
  }
}",0.9832572298325722
3017,"@Override public void onBlockBreak(BlockBreakEvent event){
  if (event.isCancelled())   return;
  Block target=event.getBlock();
  ItemStack tool=event.getPlayer().getItemInHand();
  Integer maxDamage=0;
  boolean successfulConversion=false;
  for (  OtherBlocksContainer obc : parent.transformList) {
    if (!containsValidString(target.getWorld().getName(),obc.worlds))     continue;
    if (!containsValidMaterial(tool.getType(),obc.tool))     continue;
    if (OtherBlocks.isCreature(obc.original))     continue;
    if (OtherBlocks.isLeafDecay(obc.original))     continue;
    if (Material.valueOf(obc.original) != event.getBlock().getType())     continue;
    if (parent.rng.nextDouble() > (obc.chance.doubleValue() / 100))     continue;
    successfulConversion=true;
    OtherBlocks.performDrop(target.getLocation(),obc);
    maxDamage=(maxDamage < obc.damage) ? obc.damage : maxDamage;
  }
  if (successfulConversion) {
    event.setCancelled(true);
    target.setType(Material.AIR);
    if (tool.getType().getMaxDurability() < 0 || tool.getType().isBlock())     return;
    tool.setDurability((short)(tool.getDurability() + maxDamage));
    if (tool.getDurability() >= tool.getType().getMaxDurability()) {
      event.getPlayer().setItemInHand(null);
    }
  }
}","@Override public void onBlockBreak(BlockBreakEvent event){
  if (event.isCancelled())   return;
  Block target=event.getBlock();
  ItemStack tool=event.getPlayer().getItemInHand();
  Integer maxDamage=0;
  boolean successfulConversion=false;
  for (  OtherBlocksContainer obc : parent.transformList) {
    if (!containsValidString(target.getWorld().getName(),obc.worlds))     continue;
    if (!containsValidMaterial(tool.getType(),obc.tool))     continue;
    if (OtherBlocks.isCreature(obc.original))     continue;
    if (OtherBlocks.isLeafDecay(obc.original))     continue;
    if (Material.valueOf(obc.original) != event.getBlock().getType())     continue;
    if (parent.rng.nextDouble() > (obc.chance.doubleValue() / 100))     continue;
    setQuantity(obc);
    successfulConversion=true;
    OtherBlocks.performDrop(target.getLocation(),obc);
    maxDamage=(maxDamage < obc.damage) ? obc.damage : maxDamage;
  }
  if (successfulConversion) {
    event.setCancelled(true);
    target.setType(Material.AIR);
    if (tool.getType().getMaxDurability() < 0 || tool.getType().isBlock())     return;
    tool.setDurability((short)(tool.getDurability() + maxDamage));
    if (tool.getDurability() >= tool.getType().getMaxDurability()) {
      event.getPlayer().setItemInHand(null);
    }
  }
}",0.9914263445050664
3018,"public OtherBlocks(PluginLoader pluginLoader,Server instance,PluginDescriptionFile desc,File folder,File plugin,ClassLoader cLoader){
  super(pluginLoader,instance,desc,folder,plugin,cLoader);
  folder.mkdirs();
  File yml=new File(getDataFolder(),""String_Node_Str"");
  if (!yml.exists()) {
    try {
      yml.createNewFile();
      log.info(""String_Node_Str"" + getDataFolder() + ""String_Node_Str"");
      getConfiguration().setProperty(""String_Node_Str"",null);
      getConfiguration().save();
    }
 catch (    IOException ex) {
      log.warning(getDescription().getName() + ""String_Node_Str"");
    }
  }
  List<String> keys;
  try {
    keys=getConfiguration().getKeys(null);
  }
 catch (  NullPointerException ex) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  if (!keys.contains(""String_Node_Str"")) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  keys.clear();
  keys=getConfiguration().getKeys(""String_Node_Str"");
  if (null == keys) {
    log.info(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  for (  String s : keys) {
    List<Object> original_children=getConfiguration().getList(""String_Node_Str"" + s);
    if (original_children == null) {
      log.warning(""String_Node_Str"" + s + ""String_Node_Str"");
      continue;
    }
    for (    Object o : original_children) {
      if (o instanceof HashMap<?,?>) {
        OtherBlocksContainer bt=new OtherBlocksContainer();
        try {
          @SuppressWarnings(""String_Node_Str"") HashMap<String,Object> m=(HashMap<String,Object>)o;
          bt.original=Material.valueOf(s);
          String toolString=String.class.cast(m.get(""String_Node_Str""));
          if (toolString.equalsIgnoreCase(""String_Node_Str"")) {
            toolString=""String_Node_Str"";
          }
          bt.tool=(toolString.equalsIgnoreCase(""String_Node_Str"") ? null : Material.valueOf(toolString));
          bt.dropped=Material.valueOf(String.class.cast(m.get(""String_Node_Str"")));
          Integer dropQuantity=Integer.class.cast(m.get(""String_Node_Str""));
          bt.quantity=(dropQuantity == null || dropQuantity <= 0) ? 1 : dropQuantity;
          Integer toolDamage=Integer.class.cast(m.get(""String_Node_Str""));
          bt.damage=(toolDamage == null || toolDamage < 0) ? 1 : toolDamage;
          Integer dropChance=Integer.class.cast(m.get(""String_Node_Str""));
          bt.chance=(dropChance == null || dropChance < 0 || dropChance > 100) ? 100 : dropChance;
          DyeColor dropColor=DyeColor.valueOf(String.class.cast(m.get(""String_Node_Str"")));
          bt.color=((dropColor == null) ? null : dropColor.getData());
        }
 catch (        IllegalArgumentException ex) {
          log.warning(""String_Node_Str"" + s);
          continue;
        }
        transformList.add(bt);
        log.info(getDescription().getName() + ""String_Node_Str"" + (bt.tool == null ? ""String_Node_Str"" : bt.tool.toString())+ ""String_Node_Str""+ bt.original.toString()+ ""String_Node_Str""+ bt.quantity.toString()+ ""String_Node_Str""+ bt.dropped.toString()+ ""String_Node_Str""+ bt.chance.toString()+ ""String_Node_Str"");
      }
    }
  }
}","public OtherBlocks(PluginLoader pluginLoader,Server instance,PluginDescriptionFile desc,File folder,File plugin,ClassLoader cLoader){
  super(pluginLoader,instance,desc,folder,plugin,cLoader);
  folder.mkdirs();
  File yml=new File(getDataFolder(),""String_Node_Str"");
  if (!yml.exists()) {
    try {
      yml.createNewFile();
      log.info(""String_Node_Str"" + getDataFolder() + ""String_Node_Str"");
      getConfiguration().setProperty(""String_Node_Str"",null);
      getConfiguration().save();
    }
 catch (    IOException ex) {
      log.warning(getDescription().getName() + ""String_Node_Str"");
    }
  }
  List<String> keys;
  try {
    keys=getConfiguration().getKeys(null);
  }
 catch (  NullPointerException ex) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  if (!keys.contains(""String_Node_Str"")) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  keys.clear();
  keys=getConfiguration().getKeys(""String_Node_Str"");
  if (null == keys) {
    log.info(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  for (  String s : keys) {
    List<Object> original_children=getConfiguration().getList(""String_Node_Str"" + s);
    if (original_children == null) {
      log.warning(""String_Node_Str"" + s + ""String_Node_Str"");
      continue;
    }
    for (    Object o : original_children) {
      if (o instanceof HashMap<?,?>) {
        OtherBlocksContainer bt=new OtherBlocksContainer();
        try {
          @SuppressWarnings(""String_Node_Str"") HashMap<String,Object> m=(HashMap<String,Object>)o;
          bt.original=Material.valueOf(s);
          String toolString=String.class.cast(m.get(""String_Node_Str""));
          if (toolString.equalsIgnoreCase(""String_Node_Str"")) {
            toolString=""String_Node_Str"";
          }
          bt.tool=(toolString.equalsIgnoreCase(""String_Node_Str"") ? null : Material.valueOf(toolString));
          bt.dropped=Material.valueOf(String.class.cast(m.get(""String_Node_Str"")));
          Integer dropQuantity=Integer.class.cast(m.get(""String_Node_Str""));
          bt.quantity=(dropQuantity == null || dropQuantity <= 0) ? 1 : dropQuantity;
          Integer toolDamage=Integer.class.cast(m.get(""String_Node_Str""));
          bt.damage=(toolDamage == null || toolDamage < 0) ? 1 : toolDamage;
          Integer dropChance=Integer.class.cast(m.get(""String_Node_Str""));
          bt.chance=(dropChance == null || dropChance < 0 || dropChance > 100) ? 100 : dropChance;
          String dropColor=String.class.cast(m.get(""String_Node_Str""));
          bt.color=((dropColor == null) ? 0 : DyeColor.valueOf(dropColor).getData());
        }
 catch (        IllegalArgumentException ex) {
          log.warning(""String_Node_Str"" + s);
          continue;
        }
catch (        NullPointerException ex) {
          log.warning(""String_Node_Str"" + s);
          continue;
        }
        transformList.add(bt);
        log.info(getDescription().getName() + ""String_Node_Str"" + (bt.tool == null ? ""String_Node_Str"" : bt.tool.toString())+ ""String_Node_Str""+ bt.original.toString()+ ""String_Node_Str""+ bt.quantity.toString()+ ""String_Node_Str""+ bt.dropped.toString()+ ""String_Node_Str""+ bt.chance.toString()+ ""String_Node_Str"");
      }
    }
  }
}",0.9470414660661594
3019,"@Override public void onBlockBreak(BlockBreakEvent event){
  if (event.isCancelled()) {
    return;
  }
  Block target=event.getBlock();
  ItemStack tool=event.getPlayer().getItemInHand();
  Integer maxDamage=0;
  boolean successfulConversion=false;
  for (  OtherBlocksContainer obc : parent.transformList) {
    if (!obc.tool.contains(null) && !obc.tool.contains(tool.getType())) {
      continue;
    }
    if (obc.original != event.getBlock().getType()) {
      continue;
    }
    if (parent.rng.nextDouble() > (obc.chance.doubleValue() / 100)) {
      continue;
    }
    Location location=new Location(target.getWorld(),target.getX(),target.getY(),target.getZ());
    successfulConversion=true;
    try {
      if (obc.droptype.equalsIgnoreCase(""String_Node_Str"")) {
        target.getWorld().dropItemNaturally(location,new ItemStack(Material.valueOf(obc.dropped),obc.quantity,obc.color));
      }
 else       if (obc.droptype.equalsIgnoreCase(""String_Node_Str"")) {
        target.getWorld().spawnCreature(new Location(target.getWorld(),location.getX() + 0.5,location.getY() + 1,location.getZ() + 0.5),CreatureType.valueOf(obc.dropped));
      }
 else {
        throw new Exception(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    maxDamage=(maxDamage < obc.damage) ? obc.damage : maxDamage;
  }
  if (successfulConversion) {
    event.setCancelled(true);
    target.setType(Material.AIR);
    if (parent.getFixedMaxDurability(tool.getType()) < 0 || tool.getType().isBlock()) {
      return;
    }
    tool.setDurability((short)(tool.getDurability() + maxDamage));
    if (tool.getDurability() >= parent.getFixedMaxDurability(tool.getType())) {
      event.getPlayer().setItemInHand(null);
    }
  }
}","@Override public void onBlockBreak(BlockBreakEvent event){
  if (event.isCancelled()) {
    return;
  }
  Block target=event.getBlock();
  ItemStack tool=event.getPlayer().getItemInHand();
  Integer maxDamage=0;
  boolean successfulConversion=false;
  for (  OtherBlocksContainer obc : parent.transformList) {
    if (!obc.tool.contains(null) && !obc.tool.contains(tool.getType())) {
      continue;
    }
    if (obc.original != event.getBlock().getType()) {
      continue;
    }
    if (parent.rng.nextDouble() > (obc.chance.doubleValue() / 100)) {
      continue;
    }
    Location location=new Location(target.getWorld(),target.getX(),target.getY(),target.getZ());
    successfulConversion=true;
    try {
      if (obc.droptype.equalsIgnoreCase(""String_Node_Str"")) {
        if (Material.valueOf(obc.dropped) != Material.AIR) {
          target.getWorld().dropItemNaturally(location,new ItemStack(Material.valueOf(obc.dropped),obc.quantity,obc.color));
        }
      }
 else       if (obc.droptype.equalsIgnoreCase(""String_Node_Str"")) {
        target.getWorld().spawnCreature(new Location(target.getWorld(),location.getX() + 0.5,location.getY() + 1,location.getZ() + 0.5),CreatureType.valueOf(obc.dropped));
      }
 else {
        throw new Exception(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    maxDamage=(maxDamage < obc.damage) ? obc.damage : maxDamage;
  }
  if (successfulConversion) {
    event.setCancelled(true);
    target.setType(Material.AIR);
    if (parent.getFixedMaxDurability(tool.getType()) < 0 || tool.getType().isBlock()) {
      return;
    }
    tool.setDurability((short)(tool.getDurability() + maxDamage));
    if (tool.getDurability() >= parent.getFixedMaxDurability(tool.getType())) {
      event.getPlayer().setItemInHand(null);
    }
  }
}",0.6127683300808475
3020,"public void onEnable(){
  getDataFolder().mkdirs();
  File yml=new File(getDataFolder(),""String_Node_Str"");
  if (!yml.exists()) {
    try {
      yml.createNewFile();
      log.info(""String_Node_Str"" + getDataFolder() + ""String_Node_Str"");
      getConfiguration().setProperty(""String_Node_Str"",null);
      getConfiguration().save();
    }
 catch (    IOException ex) {
      log.warning(getDescription().getName() + ""String_Node_Str"");
    }
  }
  List<String> keys;
  try {
    keys=getConfiguration().getKeys(null);
  }
 catch (  NullPointerException ex) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  if (!keys.contains(""String_Node_Str"")) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  keys.clear();
  keys=getConfiguration().getKeys(""String_Node_Str"");
  if (null == keys) {
    log.info(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  for (  String s : keys) {
    List<Object> original_children=getConfiguration().getList(""String_Node_Str"" + s);
    if (original_children == null) {
      log.warning(""String_Node_Str"" + s + ""String_Node_Str"");
      continue;
    }
    for (    Object o : original_children) {
      if (o instanceof HashMap<?,?>) {
        OtherBlocksContainer bt=new OtherBlocksContainer();
        try {
          HashMap<?,?> m=(HashMap<?,?>)o;
          bt.original=Material.valueOf(s);
          String toolString=String.valueOf(m.get(""String_Node_Str""));
          if (toolString.equalsIgnoreCase(""String_Node_Str"")) {
            toolString=""String_Node_Str"";
          }
          bt.tool=(toolString.equalsIgnoreCase(""String_Node_Str"") ? null : Material.valueOf(toolString));
          String dropString=String.valueOf(m.get(""String_Node_Str""));
          if (dropString.length() > 9 && dropString.substring(0,9).equalsIgnoreCase(""String_Node_Str"")) {
            bt.dropped=CreatureType.valueOf(dropString.substring(9)).toString();
            bt.droptype=""String_Node_Str"";
          }
 else {
            bt.dropped=Material.valueOf(dropString).toString();
            bt.droptype=""String_Node_Str"";
          }
          Integer dropQuantity=Integer.getInteger(String.valueOf(m.get(""String_Node_Str"")),1);
          bt.quantity=(dropQuantity <= 0) ? 1 : dropQuantity;
          Integer toolDamage=Integer.getInteger(String.valueOf(m.get(""String_Node_Str"")),1);
          bt.damage=(toolDamage < 0) ? 1 : toolDamage;
          Double dropChance;
          try {
            dropChance=Double.valueOf(String.valueOf(m.get(""String_Node_Str"")));
            bt.chance=(dropChance < 0 || dropChance > 100) ? 100 : dropChance;
          }
 catch (          NumberFormatException ex) {
            bt.chance=100.0;
          }
          String dropColor=String.valueOf(m.get(""String_Node_Str""));
          bt.color=((dropColor == ""String_Node_Str"") ? 0 : DyeColor.valueOf(dropColor).getData());
        }
 catch (        Throwable ex) {
          log.warning(""String_Node_Str"" + s + ""String_Node_Str""+ ex.getMessage());
          continue;
        }
        transformList.add(bt);
        log.info(getDescription().getName() + ""String_Node_Str"" + (bt.tool == null ? ""String_Node_Str"" : bt.tool.toString())+ ""String_Node_Str""+ bt.original.toString()+ ""String_Node_Str""+ bt.quantity.toString()+ ""String_Node_Str""+ bt.dropped.toString()+ ""String_Node_Str""+ bt.chance.toString()+ ""String_Node_Str"");
      }
    }
  }
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,Priority.Lowest,this);
  log.info(getDescription().getName() + ""String_Node_Str"" + getDescription().getVersion()+ ""String_Node_Str"");
}","public void onEnable(){
  getDataFolder().mkdirs();
  File yml=new File(getDataFolder(),""String_Node_Str"");
  if (!yml.exists()) {
    try {
      yml.createNewFile();
      log.info(""String_Node_Str"" + getDataFolder() + ""String_Node_Str"");
      getConfiguration().setProperty(""String_Node_Str"",null);
      getConfiguration().save();
    }
 catch (    IOException ex) {
      log.warning(getDescription().getName() + ""String_Node_Str"");
    }
  }
  List<String> keys;
  try {
    keys=getConfiguration().getKeys(null);
  }
 catch (  NullPointerException ex) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  if (!keys.contains(""String_Node_Str"")) {
    log.warning(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  keys.clear();
  keys=getConfiguration().getKeys(""String_Node_Str"");
  if (null == keys) {
    log.info(getDescription().getName() + ""String_Node_Str"");
    return;
  }
  for (  String s : keys) {
    List<Object> original_children=getConfiguration().getList(""String_Node_Str"" + s);
    if (original_children == null) {
      log.warning(""String_Node_Str"" + s + ""String_Node_Str"");
      continue;
    }
    for (    Object o : original_children) {
      if (o instanceof HashMap<?,?>) {
        OtherBlocksContainer bt=new OtherBlocksContainer();
        try {
          HashMap<?,?> m=(HashMap<?,?>)o;
          bt.original=Material.valueOf(s);
          String toolString=String.valueOf(m.get(""String_Node_Str""));
          if (toolString.equalsIgnoreCase(""String_Node_Str"")) {
            toolString=""String_Node_Str"";
          }
          bt.tool=(toolString.equalsIgnoreCase(""String_Node_Str"") ? null : Material.valueOf(toolString));
          String dropString=String.valueOf(m.get(""String_Node_Str""));
          if (dropString.length() > 9 && dropString.substring(0,9).equalsIgnoreCase(""String_Node_Str"")) {
            bt.dropped=CreatureType.valueOf(dropString.substring(9)).toString();
            bt.droptype=""String_Node_Str"";
          }
 else {
            bt.dropped=Material.valueOf(dropString).toString();
            bt.droptype=""String_Node_Str"";
          }
          Integer dropQuantity=Integer.class.cast(m.get(""String_Node_Str""));
          bt.quantity=(dropQuantity == null || dropQuantity <= 0) ? 1 : dropQuantity;
          Integer toolDamage=Integer.class.cast(m.get(""String_Node_Str""));
          bt.damage=(toolDamage == null || toolDamage < 0) ? 1 : toolDamage;
          Double dropChance;
          try {
            dropChance=Double.valueOf(String.valueOf(m.get(""String_Node_Str"")));
            bt.chance=(dropChance < 0 || dropChance > 100) ? 100 : dropChance;
          }
 catch (          NumberFormatException ex) {
            bt.chance=100.0;
          }
          String dropColor=String.valueOf(m.get(""String_Node_Str""));
          bt.color=((dropColor == ""String_Node_Str"") ? 0 : DyeColor.valueOf(dropColor).getData());
        }
 catch (        Throwable ex) {
          log.warning(""String_Node_Str"" + s + ""String_Node_Str""+ ex.getMessage());
          continue;
        }
        transformList.add(bt);
        log.info(getDescription().getName() + ""String_Node_Str"" + (bt.tool == null ? ""String_Node_Str"" : bt.tool.toString())+ ""String_Node_Str""+ bt.original.toString()+ ""String_Node_Str""+ bt.quantity.toString()+ ""String_Node_Str""+ bt.dropped.toString()+ ""String_Node_Str""+ bt.chance.toString()+ ""String_Node_Str"");
      }
    }
  }
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,Priority.Lowest,this);
  log.info(getDescription().getName() + ""String_Node_Str"" + getDescription().getVersion()+ ""String_Node_Str"");
}",0.9450013546464372
3021,"public int getFixedMaxStackSize(Material m){
  return (int)((Material.DIAMOND_PICKAXE.getMaxStackSize() > 1) ? m.getMaxDurability() : m.getMaxStackSize());
}","public int getFixedMaxStackSize(Material m){
  return (int)((m.getMaxStackSize() < 1) ? m.getMaxDurability() : m.getMaxStackSize());
}",0.9072164948453608
3022,"public short getFixedMaxDurability(Material m){
  return (short)((Material.DIAMOND_PICKAXE.getMaxStackSize() > 1) ? m.getMaxStackSize() : m.getMaxDurability());
}","public short getFixedMaxDurability(Material m){
  return (short)((m.getMaxStackSize() < 1) ? m.getMaxStackSize() : m.getMaxDurability());
}",0.9102990033222592
3023,"public void onEnable(){
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_DAMAGED,blockListener,Priority.Monitor,this);
  log.info(getDescription().getName() + ""String_Node_Str"" + getDescription().getVersion()+ ""String_Node_Str"");
}","public void onEnable(){
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_DAMAGED,blockListener,Priority.Lowest,this);
  log.info(getDescription().getName() + ""String_Node_Str"" + getDescription().getVersion()+ ""String_Node_Str"");
}",0.9757914338919924
3024,"public int getFixedMaxStackSize(Material m){
  return (int)(Material.AIR.getMaxStackSize() == -1 ? m.getMaxDurability() : m.getMaxStackSize());
}","public int getFixedMaxStackSize(Material m){
  return (int)((Material.DIAMOND_PICKAXE.getMaxStackSize() > 1) ? m.getMaxDurability() : m.getMaxStackSize());
}",0.933774834437086
3025,"public short getFixedMaxDurability(Material m){
  return (short)(Material.AIR.getMaxStackSize() == -1 ? m.getMaxStackSize() : m.getMaxDurability());
}","public short getFixedMaxDurability(Material m){
  return (short)((Material.DIAMOND_PICKAXE.getMaxStackSize() > 1) ? m.getMaxStackSize() : m.getMaxDurability());
}",0.935897435897436
3026,"public List<EventItem> getEventItems(){
  return eventItems;
}","public List<EventItem> getEventItems(){
  if (eventItems == null)   eventItems=new ArrayList<EventItem>();
  return eventItems;
}",0.6492146596858639
3027,"public List<Emotion> getEmotionList(){
  return emotionList;
}","public List<Emotion> getEmotionList(){
  if (emotionList == null)   emotionList=new ArrayList<Emotion>();
  return emotionList;
}",0.6492146596858639
3028,"public static MoodEnum getType(double x,double y){
  if (x >= 0.5 && y >= 0.5) {
    MoodEnum m=MoodEnum.NERVOUS;
    m.x=x;
    m.y=y;
    return m;
  }
 else   if (x >= 0.5 && y <= 0.5) {
    MoodEnum m=MoodEnum.CALM;
    m.x=x;
    m.y=y;
    return m;
  }
 else   if (x <= 0.5 && y <= 0.5) {
    MoodEnum m=MoodEnum.SAD;
    m.x=x;
    m.y=y;
    return m;
  }
 else   if (x <= 0.5 && y >= 0.5) {
    MoodEnum m=MoodEnum.NERVOUS;
    m.x=x;
    m.y=y;
    return m;
  }
 else {
    MoodEnum m=MoodEnum.NERVOUS;
    m.x=x;
    m.y=y;
    return m;
  }
}","public static MoodEnum getType(double x,double y){
  if (x >= 0.5 && y >= 0.5) {
    MoodEnum m=MoodEnum.HAPPY;
    m.x=x;
    m.y=y;
    return m;
  }
 else   if (x >= 0.5 && y <= 0.5) {
    MoodEnum m=MoodEnum.CALM;
    m.x=x;
    m.y=y;
    return m;
  }
 else   if (x <= 0.5 && y <= 0.5) {
    MoodEnum m=MoodEnum.SAD;
    m.x=x;
    m.y=y;
    return m;
  }
 else   if (x <= 0.5 && y >= 0.5) {
    MoodEnum m=MoodEnum.NERVOUS;
    m.x=x;
    m.y=y;
    return m;
  }
 else {
    MoodEnum m=MoodEnum.CALM;
    m.x=x;
    m.y=y;
    return m;
  }
}",0.4209575429087624
3029,"@Override public int delete(Uri uri,String userName,String[] whereArgs){
  int count=0;
  String where=userName + ""String_Node_Str"" + UserColumns.USER_NAME;
  count=super.getUserDatabase().delete(SQLStatements.USER_DATABASE_TABLE_NAME,where,whereArgs);
  return count;
}","@Override public int delete(Uri uri,String where,String[] whereArgs){
  int count=0;
  count=super.getUserDatabase().delete(SQLStatements.USER_DATABASE_TABLE_NAME,where,whereArgs);
  return count;
}",0.8376068376068376
3030,"private void createAndOpenNewExperienceBasedOnSelectedTags(){
  List<String> selectedTagsName=tagListAdapter.getCheckedTags();
  List<BaseEvent> eventsTaggedWithSelectedTags=tagManager.getAllEventsConnectedToTag(selectedTagsName);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + eventsTaggedWithSelectedTags.size() + ""String_Node_Str"");
  String experienceTitle=""String_Node_Str"";
  for (int i=0; i < Math.min(3,selectedTagsName.size()); i++) {
    experienceTitle+=selectedTagsName.get(i) + ""String_Node_Str"";
  }
  Experience tagExperience=new Experience(experienceTitle.trim(),false,Utilities.getUserAccount(this));
  for (  BaseEvent baseEvent : eventsTaggedWithSelectedTags) {
    baseEvent.setExperienceid(tagExperience.getId());
    baseEvent.generateNewId();
    tagExperience.addEvent(baseEvent);
  }
  String databaseName=tagExperience.getTitle() + ""String_Node_Str"";
  Intent timelineIntent=new Intent(this,TimelineActivity.class);
  timelineIntent.setAction(Utilities.INTENT_ACTION_NEW_TIMELINE);
  timelineIntent.putExtra(Utilities.DATABASENAME_REQUEST,databaseName);
  timelineIntent.putExtra(Utilities.SHARED_REQUEST,tagExperience.isShared());
  timelineIntent.putExtra(Utilities.EXPERIENCEID_REQUEST,tagExperience.getId());
  timelineIntent.putExtra(Utilities.EXPERIENCECREATOR_REQUEST,tagExperience.getUser().name);
  new TimelineDatabaseHelper(this,Utilities.ALL_TIMELINES_DATABASE_NAME);
  new DatabaseHelper(this,databaseName);
  ContentAdder adder=new ContentAdder(this);
  adder.addExperienceToTimelineContentProvider(tagExperience);
  DatabaseHelper.getCurrentTimelineDatabase().close();
  TimelineDatabaseHelper.getCurrentTimeLineDatabase().close();
  startActivity(timelineIntent);
  finish();
}","private void createAndOpenNewExperienceBasedOnSelectedTags(){
  List<String> selectedTagsName=tagListAdapter.getCheckedTags();
  List<BaseEvent> eventsTaggedWithSelectedTags=tagManager.getAllEventsConnectedToTag(selectedTagsName);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + eventsTaggedWithSelectedTags.size() + ""String_Node_Str"");
  if (!tagListAdapter.getCheckedTags().isEmpty() && !eventsTaggedWithSelectedTags.isEmpty()) {
    String experienceTitle=""String_Node_Str"";
    for (int i=0; i < Math.min(3,selectedTagsName.size()); i++) {
      experienceTitle+=selectedTagsName.get(i) + ""String_Node_Str"";
    }
    Experience tagExperience=new Experience(experienceTitle.trim(),false,Utilities.getUserAccount(this));
    for (    BaseEvent baseEvent : eventsTaggedWithSelectedTags) {
      baseEvent.setExperienceid(tagExperience.getId());
      baseEvent.generateNewId();
      tagExperience.addEvent(baseEvent);
    }
    String databaseName=tagExperience.getTitle() + ""String_Node_Str"";
    Intent timelineIntent=new Intent(this,TimelineActivity.class);
    timelineIntent.setAction(Utilities.INTENT_ACTION_NEW_TIMELINE);
    timelineIntent.putExtra(Utilities.DATABASENAME_REQUEST,databaseName);
    timelineIntent.putExtra(Utilities.SHARED_REQUEST,tagExperience.isShared());
    timelineIntent.putExtra(Utilities.EXPERIENCEID_REQUEST,tagExperience.getId());
    timelineIntent.putExtra(Utilities.EXPERIENCECREATOR_REQUEST,tagExperience.getUser().name);
    new TimelineDatabaseHelper(this,Utilities.ALL_TIMELINES_DATABASE_NAME);
    new DatabaseHelper(this,databaseName);
    ContentAdder adder=new ContentAdder(this);
    adder.addExperienceToTimelineContentProvider(tagExperience);
    DatabaseHelper.getCurrentTimelineDatabase().close();
    TimelineDatabaseHelper.getCurrentTimeLineDatabase().close();
    startActivity(timelineIntent);
    finish();
  }
 else   if (tagListAdapter.getCheckedTags().isEmpty()) {
    Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
 else   if (eventsTaggedWithSelectedTags.isEmpty()) {
    Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
}",0.885480572597137
3031,"/** 
 * Renders the Views(the squares in the Grid). A bit ""hackish"" in the sense that we put in time as textview for the first slots to represent the time.
 */
public View getView(int position,View convertView,ViewGroup parent){
  if (position < ZOOMTYPE.getColumns()) {
    Log.i(this.getClass().getSimpleName() + ""String_Node_Str"",""String_Node_Str"" + ZOOMTYPE.toString());
    TextView textView=new TextView(mContext);
switch (ZOOMTYPE.getType()) {
case Utilities.DAY_MODE:
      textView.setText(""String_Node_Str"" + String.valueOf(position) + ""String_Node_Str"");
    textView.setTag(position);
  break;
case Utilities.HOUR_MODE:
textView.setText(""String_Node_Str"" + getZoomDate().getHours() + ""String_Node_Str""+ getMinuteOnPosition(position));
break;
case Utilities.WEEK_MODE:
Calendar cal2=Calendar.getInstance();
cal2.setTime(Utilities.getFirstDayOfWeek(getZoomDate()));
cal2.add(Calendar.DATE,(position));
int displayDate=cal2.get(Calendar.DAY_OF_MONTH);
int displaymonth=cal2.get(Calendar.MONTH);
textView.setText(""String_Node_Str"" + displayDate + ""String_Node_Str""+ (displaymonth + 1));
textView.setTag(cal2.getTime());
break;
case Utilities.MONTH_MODE:
textView.setText(""String_Node_Str"" + Utilities.getDayName(position));
Calendar monthCal=Calendar.getInstance();
monthCal.setTime(Utilities.getFirstDayOfWeek(getZoomDate()));
monthCal.set(Calendar.DAY_OF_MONTH,1);
textView.setTag(-1);
break;
default :
break;
}
textView.setGravity(Gravity.CENTER_HORIZONTAL);
textView.setTextSize(12);
textView.setTextColor(mContext.getResources().getColor(android.R.color.black));
textView.setPadding(0,0,0,10);
((AdapterView<?>)parent).setOnItemClickListener(new OnItemClickListener(){
public void onItemClick(AdapterView<?> arg0,View v,int arg2,long arg3){
handleClick(v);
}
}
);
return textView;
}
 else {
if (ZOOMTYPE == Zoom.MONTH) {
((AdapterView<?>)parent).setOnLongClickListener(null);
((AdapterView<?>)parent).setOnCreateContextMenuListener(null);
TextView textView=new TextView(mContext);
try {
textView.setText(String.valueOf(Utilities.convertGridPositionToDate(position,getZoomDate()).getDate()));
}
 catch (NullPointerException e) {
textView.setText(""String_Node_Str"");
}
textView.setGravity(Gravity.CENTER);
textView.setTextSize(18);
textView.setPadding(10,6,10,6);
if (displayedEvents.containsKey(position)) {
textView.setTextColor(mContext.getResources().getColor(R.color.Green));
textView.setTag(Utilities.convertGridPositionToDate(position,getZoomDate()));
}
 else {
textView.setTextColor(mContext.getResources().getColor(android.R.color.black));
textView.setTag(null);
}
((AdapterView<?>)parent).setOnItemClickListener(new OnItemClickListener(){
public void onItemClick(AdapterView<?> arg0,View v,int arg2,long arg3){
handleClick(v);
}
}
);
return textView;
}
{
ImageView imageView;
imageView=new ImageView(mContext);
imageView.setLayoutParams(new GridView.LayoutParams(40,40));
imageView.setScaleType(ImageView.ScaleType.FIT_XY);
imageView.setPadding(0,0,0,0);
if (displayedEvents.containsKey(Integer.valueOf(position))) {
BaseEvent ex=displayedEvents.get(position);
imageView.setTag(ex);
if (ex instanceof Event) {
imageView.setImageResource(Utilities.getImageIcon((Event)ex));
}
 else if (ex instanceof MoodEvent) {
imageView.setImageResource(((MoodEvent)ex).getMood().getIcon());
}
imageView.setOnClickListener(new View.OnClickListener(){
public void onClick(View v){
handleClick(v);
}
}
);
imageView.setOnCreateContextMenuListener(new OnCreateContextMenuListener(){
public void onCreateContextMenu(ContextMenu menu,View v,ContextMenuInfo menuInfo){
menu.add(R.id.MENU_DELETE_EVENT,0,0,R.string.Delete_event_label);
}
}
);
imageView.setOnLongClickListener(new View.OnLongClickListener(){
public boolean onLongClick(View v){
((TimelineActivity)mActivity).setSelectedEvent((Event)v.getTag());
Log.i(TimelineGridAdapter.class.toString(),""String_Node_Str"" + ((Event)v.getTag()).getId());
return false;
}
}
);
}
return imageView;
}
}
}","/** 
 * Renders the Views(the squares in the Grid). A bit ""hackish"" in the sense that we put in time as textview for the first slots to represent the time.
 */
public View getView(int position,View convertView,ViewGroup parent){
  if (position < ZOOMTYPE.getColumns()) {
    Log.i(this.getClass().getSimpleName() + ""String_Node_Str"",""String_Node_Str"" + ZOOMTYPE.toString());
    TextView textView=new TextView(mContext);
switch (ZOOMTYPE.getType()) {
case Utilities.DAY_MODE:
      textView.setText(""String_Node_Str"" + String.valueOf(position) + ""String_Node_Str"");
    textView.setTag(position);
  break;
case Utilities.HOUR_MODE:
textView.setText(""String_Node_Str"" + getZoomDate().getHours() + ""String_Node_Str""+ getMinuteOnPosition(position));
break;
case Utilities.WEEK_MODE:
Calendar cal2=Calendar.getInstance();
cal2.setTime(Utilities.getFirstDayOfWeek(getZoomDate()));
cal2.add(Calendar.DATE,(position));
int displayDate=cal2.get(Calendar.DAY_OF_MONTH);
int displaymonth=cal2.get(Calendar.MONTH);
textView.setText(""String_Node_Str"" + displayDate + ""String_Node_Str""+ (displaymonth + 1));
textView.setTag(cal2.getTime());
break;
case Utilities.MONTH_MODE:
textView.setText(""String_Node_Str"" + Utilities.getDayName(position));
Calendar monthCal=Calendar.getInstance();
monthCal.setTime(Utilities.getFirstDayOfWeek(getZoomDate()));
monthCal.set(Calendar.DAY_OF_MONTH,1);
textView.setTag(-1);
break;
default :
break;
}
textView.setGravity(Gravity.CENTER_HORIZONTAL);
textView.setTextSize(12);
textView.setTextColor(mContext.getResources().getColor(android.R.color.black));
textView.setPadding(0,0,0,10);
((AdapterView<?>)parent).setOnItemClickListener(new OnItemClickListener(){
public void onItemClick(AdapterView<?> arg0,View v,int arg2,long arg3){
handleClick(v);
}
}
);
return textView;
}
 else {
if (ZOOMTYPE == Zoom.MONTH) {
((AdapterView<?>)parent).setOnLongClickListener(null);
((AdapterView<?>)parent).setOnCreateContextMenuListener(null);
TextView textView=new TextView(mContext);
try {
textView.setText(String.valueOf(Utilities.convertGridPositionToDate(position,getZoomDate()).getDate()));
}
 catch (NullPointerException e) {
textView.setText(""String_Node_Str"");
}
textView.setGravity(Gravity.CENTER);
textView.setTextSize(18);
textView.setPadding(10,6,10,6);
if (displayedEvents.containsKey(position)) {
textView.setTextColor(mContext.getResources().getColor(R.color.Green));
textView.setTag(Utilities.convertGridPositionToDate(position,getZoomDate()));
}
 else {
textView.setTextColor(mContext.getResources().getColor(android.R.color.black));
textView.setTag(null);
}
((AdapterView<?>)parent).setOnItemClickListener(new OnItemClickListener(){
public void onItemClick(AdapterView<?> arg0,View v,int arg2,long arg3){
handleClick(v);
}
}
);
return textView;
}
{
ImageView imageView;
imageView=new ImageView(mContext);
imageView.setLayoutParams(new GridView.LayoutParams(40,40));
imageView.setScaleType(ImageView.ScaleType.FIT_XY);
imageView.setPadding(0,0,0,0);
if (displayedEvents.containsKey(Integer.valueOf(position))) {
BaseEvent ex=displayedEvents.get(position);
imageView.setTag(ex);
if (ex instanceof Event) {
imageView.setImageResource(Utilities.getImageIcon((Event)ex));
}
 else if (ex instanceof MoodEvent) {
imageView.setImageResource(((MoodEvent)ex).getMood().getIcon());
}
imageView.setOnClickListener(new View.OnClickListener(){
public void onClick(View v){
handleClick(v);
}
}
);
if (imageView.getTag() instanceof Event) {
imageView.setOnCreateContextMenuListener(new OnCreateContextMenuListener(){
public void onCreateContextMenu(ContextMenu menu,View v,ContextMenuInfo menuInfo){
menu.add(R.id.MENU_DELETE_EVENT,0,0,R.string.Delete_event_label);
}
}
);
imageView.setOnLongClickListener(new View.OnLongClickListener(){
public boolean onLongClick(View v){
((TimelineActivity)mActivity).setSelectedEvent((Event)v.getTag());
Log.i(TimelineGridAdapter.class.toString(),""String_Node_Str"" + ((Event)v.getTag()).getId());
return false;
}
}
);
}
}
return imageView;
}
}
}",0.994333207404609
3032,"@SuppressWarnings(""String_Node_Str"") public void removeEvent(Event event){
  super.remove(event);
  Set<?> s=displayedEvents.entrySet();
  Iterator<?> it=s.iterator();
  int key=-1;
  while (it.hasNext()) {
    Map.Entry m=(Map.Entry)it.next();
    key=(Integer)m.getKey();
    System.out.println(event.getId());
    System.out.println(((Event)m.getValue()).getId());
    if (event.getId().equals(((Event)m.getValue()).getId())) {
      break;
    }
  }
  try {
    displayedEvents.remove(key);
  }
 catch (  Exception e) {
  }
  notifyDataSetChanged();
}","@SuppressWarnings(""String_Node_Str"") public void removeEvent(Event event){
  super.remove(event);
  Set<?> s=displayedEvents.entrySet();
  Iterator<?> it=s.iterator();
  int key=-1;
  while (it.hasNext()) {
    Map.Entry m=(Map.Entry)it.next();
    key=(Integer)m.getKey();
    System.out.println(event.getId());
    System.out.println(((BaseEvent)m.getValue()).getId());
    if (event.getId().equals(((BaseEvent)m.getValue()).getId())) {
      break;
    }
  }
  try {
    displayedEvents.remove(key);
  }
 catch (  Exception e) {
  }
  notifyDataSetChanged();
}",0.992844364937388
3033,"protected void openExperience(Experience experience){
  String databaseName=experience.getTitle();
  boolean shared=experience.isShared();
  String id=experience.getId();
  receivedIntent.putExtra(Utilities.DATABASENAME_REQUEST,databaseName);
  receivedIntent.putExtra(Utilities.SHARED_REQUEST,shared);
  receivedIntent.putExtra(Utilities.EXPERIENCEID_REQUEST,id);
  receivedIntent.putExtra(Utilities.EXPERIENCECREATOR_REQUEST,experience.getUser().name);
  context.startActivity(receivedIntent);
  this.dismiss();
}","protected void openExperience(Experience experience){
  String databaseName=experience.getTitle() + ""String_Node_Str"";
  boolean shared=experience.isShared();
  String id=experience.getId();
  receivedIntent.putExtra(Utilities.DATABASENAME_REQUEST,databaseName);
  receivedIntent.putExtra(Utilities.SHARED_REQUEST,shared);
  receivedIntent.putExtra(Utilities.EXPERIENCEID_REQUEST,id);
  receivedIntent.putExtra(Utilities.EXPERIENCECREATOR_REQUEST,experience.getUser().name);
  context.startActivity(receivedIntent);
  this.dismiss();
}",0.9809523809523808
3034,"public Event(String id,String exID,Date dateTime,Location location,Account user){
  super(id,exID,dateTime,location,user);
  eventItems=new ArrayList<EventItem>();
  emotionList=new ArrayList<Emotion>();
}","public Event(String id,String exID,Date dateTime,Location location,Account user){
  super(id,exID,dateTime,location,user);
  eventItems=new ArrayList<EventItem>();
  emotionList=new ArrayList<Emotion>();
  className=this.getClass().getSimpleName();
}",0.9010989010989012
3035,"public MoodEvent(String id,String experienceID,Date dateTime,Location location,MoodEnum mood,Account user){
  super(id,experienceID,dateTime,location,user);
  this.mood=mood;
}","public MoodEvent(String id,String experienceID,Date dateTime,Location location,MoodEnum mood,Account user){
  super(id,experienceID,dateTime,location,user);
  this.mood=mood;
  className=this.getClass().getSimpleName();
}",0.8866498740554156
3036,"public JsonElement serialize(Event src,Type typeOfSrc,JsonSerializationContext context){
  if (src.getEmotionList().size() == 0)   src.setEmotionList(null);
  Gson gson=new Gson();
  return new JsonParser().parse(gson.toJson(src));
}","public JsonElement serialize(Experiences src,Type typeOfSrc,JsonSerializationContext context){
  if (src.getExperiences().size() == 0)   src.setExperiences(null);
 else {
    for (    Experience ex : src.getExperiences()) {
      if (ex.getEvents().size() == 0)       ex.setEvents(null);
 else {
        for (        BaseEvent baseEvent : ex.getEvents()) {
          if (baseEvent instanceof Event) {
            BaseEvent bEvent=new BaseEvent(baseEvent.getId(),baseEvent.getExperienceid(),baseEvent.getDatetime(),baseEvent.getLocation(),baseEvent.getUser());
            bEvent.setClassName(baseEvent.getClassName());
            if (((Event)baseEvent).getEmotionList().size() == 0)             bEvent.setEmotionList(null);
 else             bEvent.setEmotionList(baseEvent.getEmotionList());
            if (((Event)baseEvent).getEventItems().size() == 0)             bEvent.setEventItems(null);
 else             bEvent.setEventItems(((Event)baseEvent).getEventItems());
            ex.getEvents().add(bEvent);
            ex.getEvents().remove(baseEvent);
          }
 else           if (baseEvent instanceof MoodEvent) {
            baseEvent=(BaseEvent)baseEvent;
            baseEvent.setClassName(((MoodEvent)baseEvent).getClassName());
            baseEvent.setMood(((MoodEvent)baseEvent).getMood());
          }
        }
      }
    }
  }
  Gson gson=new Gson();
  return new JsonParser().parse(gson.toJson(src));
}",0.2579867389993972
3037,"/** 
 * @param object The object to send
 * @param a Needs {@link Activity} to get the path of the content?
 */
public static void send(Object object,Activity a){
  GsonBuilder gsonB=new GsonBuilder();
  gsonB.registerTypeAdapter(Experiences.class,new ExperiencesSerializer());
  gsonB.registerTypeAdapter(Event.class,new EventSerializer());
  Gson gson=gsonB.create();
  String jsonString=""String_Node_Str"";
  try {
    jsonString=gson.toJson(object,object.getClass());
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",e.getMessage());
  }
  System.out.println(""String_Node_Str"" + jsonString);
  Uploader.putToGAE(object,jsonString);
  System.out.println(""String_Node_Str"");
  if (object instanceof Experiences) {
    if (((Experiences)object).getExperiences() != null) {
      for (      Experience ex : ((Experiences)object).getExperiences()) {
        if (((Experience)ex).getEvents() != null) {
          for (          BaseEvent baseEvent : ex.getEvents()) {
            Event event=(Event)baseEvent;
            for (            EventItem eventI : event.getEventItems()) {
              if (eventI instanceof SimplePicture) {
                Uploader.uploadFile(Utilities.IMAGE_STORAGE_FILEPATH + ((SimplePicture)eventI).getPictureFilename(),((SimplePicture)eventI).getPictureFilename());
              }
            }
          }
        }
      }
    }
  }
 else   if (object instanceof Event) {
    for (    EventItem eventI : ((Event)object).getEventItems()) {
      if (eventI instanceof SimplePicture) {
        Uploader.uploadFile(Utilities.IMAGE_STORAGE_FILEPATH + ((SimplePicture)eventI).getPictureFilename(),((SimplePicture)eventI).getPictureFilename());
      }
    }
  }
}","/** 
 * @param object The object to send
 * @param a Needs {@link Activity} to get the path of the content?
 */
public static void send(Object object,Activity a){
  GsonBuilder gsonB=new GsonBuilder();
  gsonB.registerTypeAdapter(Experiences.class,new ExperiencesSerializer());
  Gson gson=gsonB.create();
  String jsonString=""String_Node_Str"";
  try {
    jsonString=gson.toJson(object,object.getClass());
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",e.getMessage());
  }
  System.out.println(""String_Node_Str"" + jsonString);
  Uploader.putToGAE(object,jsonString);
  System.out.println(""String_Node_Str"");
  if (object instanceof Experiences) {
    if (((Experiences)object).getExperiences() != null) {
      for (      Experience ex : ((Experiences)object).getExperiences()) {
        if (((Experience)ex).getEvents() != null) {
          for (          BaseEvent baseEvent : ex.getEvents()) {
            if (baseEvent.getEventItems() != null) {
              for (              EventItem eventI : baseEvent.getEventItems()) {
                if (eventI instanceof SimplePicture) {
                  Uploader.uploadFile(Utilities.IMAGE_STORAGE_FILEPATH + ((SimplePicture)eventI).getPictureFilename(),((SimplePicture)eventI).getPictureFilename());
                }
              }
            }
          }
        }
      }
    }
  }
 else   if (object instanceof Event) {
    for (    EventItem eventI : ((Event)object).getEventItems()) {
      if (eventI instanceof SimplePicture) {
        Uploader.uploadFile(Utilities.IMAGE_STORAGE_FILEPATH + ((SimplePicture)eventI).getPictureFilename(),((SimplePicture)eventI).getPictureFilename());
      }
    }
  }
}",0.8894814814814814
3038,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.timelinescreen);
  selectedEvent=null;
  detector=new SimpleGestureFilter(this,this);
  setupZoom();
  myLocation=MyLocation.getInstance(this);
  createNewDatabaseIfTimeLineIsNew();
  contentAdder=new ContentAdder(getApplicationContext());
  contentUpdater=new ContentUpdater(getApplicationContext());
  contentDeleter=new ContentDeleter(getApplicationContext());
  databaseName=getIntent().getExtras().getString(Utilities.DATABASENAME_REQUEST);
  experienceID=getIntent().getExtras().getString(Utilities.EXPERIENCEID_REQUEST);
  experienceCreator=getIntent().getExtras().getString(Utilities.EXPERIENCECREATOR_REQUEST);
  sharedExperience=getIntent().getExtras().getBoolean(Utilities.SHARED_REQUEST);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + databaseName + ""String_Node_Str"");
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + experienceID);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + experienceCreator);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + sharedExperience);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"");
  new DatabaseHelper(this,databaseName);
  loadedEvents=loadEventItemsFromDatabase();
  timeline=new Experience(experienceID,databaseName,sharedExperience,new Account(experienceCreator,""String_Node_Str""));
  timeline.setEvents(loadedEvents);
  setupViews();
  setupMoodButtonQuickAction();
  if (getIntent().getAction().equals(Utilities.INTENT_ACTION_ADD_TO_TIMELINE)) {
    if (getIntent().getType().contains(""String_Node_Str"")) {
      imageUri=(Uri)getIntent().getExtras().get(Intent.EXTRA_STREAM);
      String filename=(Utilities.getUserAccount(this).name + new Date().getTime()).hashCode() + ""String_Node_Str"";
      Utilities.copyFile(Utilities.getRealPathFromURI(imageUri,this),Utilities.IMAGE_STORAGE_FILEPATH,filename);
      addPictureToTimeline(filename);
    }
 else     if (getIntent().getType().contains(""String_Node_Str"")) {
      videoUri=(Uri)getIntent().getExtras().get(Intent.EXTRA_STREAM);
      addVideoToTimeline();
    }
 else     if (getIntent().getType().contains(""String_Node_Str"")) {
      audioUri=(Uri)getIntent().getExtras().get(Intent.EXTRA_STREAM);
      addAudioToTimeline();
    }
 else     if (getIntent().getType().contains(""String_Node_Str"")) {
      addNoteToTimeline(getIntent());
    }
  }
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.timelinescreen);
  selectedEvent=null;
  detector=new SimpleGestureFilter(this,this);
  setupZoom();
  myLocation=MyLocation.getInstance(this);
  createNewDatabaseIfTimeLineIsNew();
  contentAdder=new ContentAdder(getApplicationContext());
  contentUpdater=new ContentUpdater(getApplicationContext());
  contentDeleter=new ContentDeleter(getApplicationContext());
  databaseName=getIntent().getExtras().getString(Utilities.DATABASENAME_REQUEST);
  experienceID=getIntent().getExtras().getString(Utilities.EXPERIENCEID_REQUEST);
  experienceCreator=getIntent().getExtras().getString(Utilities.EXPERIENCECREATOR_REQUEST);
  sharedExperience=getIntent().getExtras().getBoolean(Utilities.SHARED_REQUEST);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + databaseName + ""String_Node_Str"");
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + experienceID);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + experienceCreator);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"" + sharedExperience);
  Log.i(this.getClass().getSimpleName(),""String_Node_Str"");
  new DatabaseHelper(this,databaseName);
  loadedEvents=loadEventItemsFromDatabase();
  timeline=new Experience(experienceID,databaseName,sharedExperience,new Account(experienceCreator,""String_Node_Str""));
  timeline.setEvents(loadedEvents);
  System.out.println(""String_Node_Str"" + timeline.getEvents().size());
  setupViews();
  setupMoodButtonQuickAction();
  if (getIntent().getAction().equals(Utilities.INTENT_ACTION_ADD_TO_TIMELINE)) {
    if (getIntent().getType().contains(""String_Node_Str"")) {
      imageUri=(Uri)getIntent().getExtras().get(Intent.EXTRA_STREAM);
      String filename=(Utilities.getUserAccount(this).name + new Date().getTime()).hashCode() + ""String_Node_Str"";
      Utilities.copyFile(Utilities.getRealPathFromURI(imageUri,this),Utilities.IMAGE_STORAGE_FILEPATH,filename);
      addPictureToTimeline(filename);
    }
 else     if (getIntent().getType().contains(""String_Node_Str"")) {
      videoUri=(Uri)getIntent().getExtras().get(Intent.EXTRA_STREAM);
      addVideoToTimeline();
    }
 else     if (getIntent().getType().contains(""String_Node_Str"")) {
      audioUri=(Uri)getIntent().getExtras().get(Intent.EXTRA_STREAM);
      addAudioToTimeline();
    }
 else     if (getIntent().getType().contains(""String_Node_Str"")) {
      addNoteToTimeline(getIntent());
    }
  }
}",0.9860043366844076
3039,"public ArrayList<BaseEvent> LoadAllEventsFromDatabase(){
  ArrayList<BaseEvent> allEvents=new ArrayList<BaseEvent>();
  String[] eventTableColumns=new String[]{EventColumns._ID,EventColumns.EVENT_EXPERIENCEID,EventColumns.EVENT_TITLE,EventColumns.EVENT_LOCATION_LAT,EventColumns.EVENT_LOCATION_LNG,EventColumns.IS_SHARED};
  Cursor c=context.getContentResolver().query(EventColumns.CONTENT_URI,eventTableColumns,null,null,null);
  if (c.moveToFirst()) {
    do {
      Date createdDate=new Date(c.getLong(c.getColumnIndex(EventColumns.EVENT_TITLE)));
      Location location=new Location(""String_Node_Str"");
      location.setLatitude(Double.parseDouble(c.getString(c.getColumnIndex(EventColumns.EVENT_LOCATION_LAT))));
      location.setLongitude(Double.parseDouble(c.getString(c.getColumnIndex(EventColumns.EVENT_LOCATION_LNG))));
      System.out.println(""String_Node_Str"" + c.getString(c.getColumnIndex(EventColumns.CREATOR)));
      Event event=new Event(c.getString(c.getColumnIndex(EventColumns._ID)),c.getString(c.getColumnIndex(EventColumns.EVENT_EXPERIENCEID)),createdDate,location,new Account(c.getString(c.getColumnIndex(EventColumns.CREATOR)),""String_Node_Str""));
      event.setShared((c.getInt((c.getColumnIndex(EventColumns.IS_SHARED))) == 1) ? true : false);
      loadAllEmotions(event);
      loadAllConnectedEventItems(event);
      allEvents.add(event);
    }
 while (c.moveToNext());
  }
  c.close();
  Log.i(""String_Node_Str"",allEvents.size() + ""String_Node_Str"");
  return allEvents;
}","public ArrayList<BaseEvent> LoadAllEventsFromDatabase(){
  ArrayList<BaseEvent> allEvents=new ArrayList<BaseEvent>();
  String[] eventTableColumns=new String[]{EventColumns._ID,EventColumns.EVENT_EXPERIENCEID,EventColumns.EVENT_TITLE,EventColumns.EVENT_LOCATION_LAT,EventColumns.EVENT_LOCATION_LNG,EventColumns.IS_SHARED,EventColumns.CREATOR};
  Cursor c=context.getContentResolver().query(EventColumns.CONTENT_URI,eventTableColumns,null,null,null);
  if (c.moveToFirst()) {
    do {
      Date createdDate=new Date(c.getLong(c.getColumnIndex(EventColumns.EVENT_TITLE)));
      Location location=new Location(""String_Node_Str"");
      location.setLatitude(Double.parseDouble(c.getString(c.getColumnIndex(EventColumns.EVENT_LOCATION_LAT))));
      location.setLongitude(Double.parseDouble(c.getString(c.getColumnIndex(EventColumns.EVENT_LOCATION_LNG))));
      Event event=new Event(c.getString(c.getColumnIndex(EventColumns._ID)),c.getString(c.getColumnIndex(EventColumns.EVENT_EXPERIENCEID)),createdDate,location,new Account(c.getString(c.getColumnIndex(EventColumns.CREATOR)),""String_Node_Str""));
      event.setShared((c.getInt((c.getColumnIndex(EventColumns.IS_SHARED))) == 1) ? true : false);
      loadAllEmotions(event);
      loadAllConnectedEventItems(event);
      allEvents.add(event);
    }
 while (c.moveToNext());
  }
  c.close();
  Log.i(""String_Node_Str"",allEvents.size() + ""String_Node_Str"");
  return allEvents;
}",0.8462585034013606
3040,"/** 
 * Synchronize shared timelines with database.
 */
private void syncTimelines(){
  UserAndGroupServiceHandler ugHandler=new UserAndGroupServiceHandler(this,this);
  ugHandler.downloadUsersAndGroups();
  ArrayList<Experience> sharedExperiences=contentLoader.LoadAllSharedExperiencesFromDatabase();
  for (  Experience experience : sharedExperiences) {
    new DatabaseHelper(this,experience.getTitle() + ""String_Node_Str"");
    experience.setEvents(contentLoader.LoadAllEventsFromDatabase());
    DatabaseHelper.getCurrentTimelineDatabase().close();
  }
  Experiences experiences=new Experiences(sharedExperiences);
  GAEHandler.send(experiences,this);
  Experiences exps=Downloader.getAllSharedExperiencesFromServer(user);
  if (exps != null) {
    for (    Experience e : exps.getExperiences()) {
      e.setSharingGroupObject(uGManager.getGroupFromDatabase(e.getSharingGroup()));
      contentAdder.addExperienceToTimelineContentProvider(e);
      addNewTimelineToTimelineDatabase(e);
    }
  }
  runOnUiThread(confirmSync);
}","/** 
 * Synchronize shared timelines with database.
 */
private void syncTimelines(){
  UserAndGroupServiceHandler ugHandler=new UserAndGroupServiceHandler(this,this);
  ugHandler.downloadUsersAndGroups();
  ArrayList<Experience> sharedExperiences=contentLoader.LoadAllSharedExperiencesFromDatabase();
  for (  Experience experience : sharedExperiences) {
    new DatabaseHelper(this,experience.getTitle() + ""String_Node_Str"");
    experience.setEvents(contentLoader.LoadAllEventsFromDatabase());
    DatabaseHelper.getCurrentTimelineDatabase().close();
  }
  Experiences experiences=new Experiences(sharedExperiences);
  GAEHandler.persistTimelineObject(experiences);
  Experiences exps=Downloader.getAllSharedExperiencesFromServer(user);
  if (exps != null) {
    for (    Experience e : exps.getExperiences()) {
      e.setSharingGroupObject(uGManager.getGroupFromDatabase(e.getSharingGroup()));
      contentAdder.addExperienceToTimelineContentProvider(e);
      addNewTimelineToTimelineDatabase(e);
    }
  }
  runOnUiThread(confirmSync);
}",0.8084696823869105
3041,"public void run(){
  GAEHandler.send(moodEvent,TimelineActivity.this);
}","public void run(){
  GAEHandler.persistTimelineObject(moodEvent);
}",0.7050359712230215
3042,"private void addMoodEventToTimeline(final MoodEvent moodEvent){
  Runnable SendMoodEventRunnable=new Runnable(){
    public void run(){
      GAEHandler.send(moodEvent,TimelineActivity.this);
    }
  }
;
  timeline.addEvent(moodEvent);
  EventAdapter.updateAdapter();
  contentAdder.addEventToEventContentProvider(moodEvent);
  Thread sendMoodThread=new Thread(SendMoodEventRunnable,""String_Node_Str"");
  sendMoodThread.start();
}","private void addMoodEventToTimeline(final MoodEvent moodEvent){
  Runnable SendMoodEventRunnable=new Runnable(){
    public void run(){
      GAEHandler.persistTimelineObject(moodEvent);
    }
  }
;
  timeline.addEvent(moodEvent);
  EventAdapter.updateAdapter();
  contentAdder.addEventToEventContentProvider(moodEvent);
  Thread sendMoodThread=new Thread(SendMoodEventRunnable,""String_Node_Str"");
  sendMoodThread.start();
}",0.928654970760234
3043,"public void run(){
  GAEHandler.send(mEvent,mActivity);
  ContentUpdater updater=new ContentUpdater(mContext);
  updater.setEventShared(mEvent);
}","public void run(){
  GAEHandler.persistTimelineObject(mEvent);
  ContentUpdater updater=new ContentUpdater(mContext);
  updater.setEventShared(mEvent);
}",0.903010033444816
3044,"public EventDialog(Context context,Event event,Activity activity,boolean fromMap){
  super(context);
  this.mContext=context;
  this.mEvent=event;
  this.mActivity=activity;
  this.requestWindowFeature(Window.FEATURE_NO_TITLE);
  this.setContentView(R.layout.popupcontentdialog);
  this.setCancelable(true);
  this.fromMap=fromMap;
  dialogIcon=(ImageView)findViewById(R.id.PopupDialogTypeIconImageView);
  dialogIcon.setImageResource(Utilities.getImageIcon(this.mEvent));
  TextView dialogDateTime=(TextView)findViewById(R.id.PopupDialogDateAndTimeTextView);
  TextView dialogLocation=(TextView)findViewById(R.id.PopupDialogLocationTextView);
  dialogDateTime.setText(DateFormat.format(""String_Node_Str"" + DateFormat.HOUR_OF_DAY + ""String_Node_Str"",this.mEvent.getDatetime()));
  if (this.mEvent.getLocation() != null) {
    try {
      address=MyLocation.getAddressForLocation(mContext,this.mEvent.getLocation());
      addressString+=address.getAddressLine(0) + ""String_Node_Str"";
      addressString+=address.getAddressLine(1) + ""String_Node_Str"";
    }
 catch (    Exception e) {
      addressString=""String_Node_Str"";
    }
  }
  dialogLocation.setText(addressString);
  mainLayout=(LinearLayout)findViewById(R.id.PopupContentLinearLayout);
  emotionLayout=(LinearLayout)findViewById(R.id.PopupMenuDockLinearLayout);
  updateMainview();
  ((TimelineActivity)mActivity).setSelectedEvent(this.mEvent);
  setupAddButtonQuickAction();
  setupEmotionButtonQuickAction();
  final ToggleButton shareButton=(ToggleButton)findViewById(R.id.PopupShareButton);
  shareButton.setTag(this.mEvent);
  shareButton.setChecked(mEvent.isShared());
  if (((TimelineActivity)activity).getTimeline().isShared() && Utilities.isConnectedToInternet(mContext)) {
    shareButton.setEnabled(!mEvent.isShared());
  }
 else {
    shareButton.setEnabled(false);
  }
  shareButton.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      mEvent.setShared(isChecked);
      shareButton.setEnabled(!mEvent.isShared());
      Thread shareThread=new Thread(shareEventThread,""String_Node_Str"");
      shareThread.start();
    }
  }
);
  ImageButton deleteButton=(ImageButton)findViewById(R.id.popupDeleteButton);
  deleteButton.setTag(event);
  deleteButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      AlertDialog.Builder builder=new AlertDialog.Builder(mActivity);
      builder.setMessage(R.string.Delete_event_confirmation).setPositiveButton(R.string.yes_label,deleteEventListener).setNegativeButton(R.string.no_label,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          try {
            dialog.cancel();
          }
 catch (          Exception e) {
          }
        }
      }
).setOnCancelListener(new OnCancelListener(){
        public void onCancel(        DialogInterface dialog){
          try {
            dialog.cancel();
          }
 catch (          Exception e) {
          }
        }
      }
);
      AlertDialog confirmation=builder.create();
      confirmation.show();
    }
  }
);
  shareEventThread=new Runnable(){
    public void run(){
      GAEHandler.send(mEvent,mActivity);
      ContentUpdater updater=new ContentUpdater(mContext);
      updater.setEventShared(mEvent);
    }
  }
;
}","public EventDialog(Context context,Event event,Activity activity,boolean fromMap){
  super(context);
  this.mContext=context;
  this.mEvent=event;
  this.mActivity=activity;
  this.requestWindowFeature(Window.FEATURE_NO_TITLE);
  this.setContentView(R.layout.popupcontentdialog);
  this.setCancelable(true);
  this.fromMap=fromMap;
  dialogIcon=(ImageView)findViewById(R.id.PopupDialogTypeIconImageView);
  dialogIcon.setImageResource(Utilities.getImageIcon(this.mEvent));
  TextView dialogDateTime=(TextView)findViewById(R.id.PopupDialogDateAndTimeTextView);
  TextView dialogLocation=(TextView)findViewById(R.id.PopupDialogLocationTextView);
  dialogDateTime.setText(DateFormat.format(""String_Node_Str"" + DateFormat.HOUR_OF_DAY + ""String_Node_Str"",this.mEvent.getDatetime()));
  if (this.mEvent.getLocation() != null) {
    try {
      address=MyLocation.getAddressForLocation(mContext,this.mEvent.getLocation());
      addressString+=address.getAddressLine(0) + ""String_Node_Str"";
      addressString+=address.getAddressLine(1) + ""String_Node_Str"";
    }
 catch (    Exception e) {
      addressString=""String_Node_Str"";
    }
  }
  dialogLocation.setText(addressString);
  mainLayout=(LinearLayout)findViewById(R.id.PopupContentLinearLayout);
  emotionLayout=(LinearLayout)findViewById(R.id.PopupMenuDockLinearLayout);
  updateMainview();
  ((TimelineActivity)mActivity).setSelectedEvent(this.mEvent);
  setupAddButtonQuickAction();
  setupEmotionButtonQuickAction();
  final ToggleButton shareButton=(ToggleButton)findViewById(R.id.PopupShareButton);
  shareButton.setTag(this.mEvent);
  shareButton.setChecked(mEvent.isShared());
  if (((TimelineActivity)activity).getTimeline().isShared() && Utilities.isConnectedToInternet(mContext)) {
    shareButton.setEnabled(!mEvent.isShared());
  }
 else {
    shareButton.setEnabled(false);
  }
  shareButton.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      mEvent.setShared(isChecked);
      shareButton.setEnabled(!mEvent.isShared());
      Thread shareThread=new Thread(shareEventThread,""String_Node_Str"");
      shareThread.start();
    }
  }
);
  ImageButton deleteButton=(ImageButton)findViewById(R.id.popupDeleteButton);
  deleteButton.setTag(event);
  deleteButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      AlertDialog.Builder builder=new AlertDialog.Builder(mActivity);
      builder.setMessage(R.string.Delete_event_confirmation).setPositiveButton(R.string.yes_label,deleteEventListener).setNegativeButton(R.string.no_label,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          try {
            dialog.cancel();
          }
 catch (          Exception e) {
          }
        }
      }
).setOnCancelListener(new OnCancelListener(){
        public void onCancel(        DialogInterface dialog){
          try {
            dialog.cancel();
          }
 catch (          Exception e) {
          }
        }
      }
);
      AlertDialog confirmation=builder.create();
      confirmation.show();
    }
  }
);
  shareEventThread=new Runnable(){
    public void run(){
      GAEHandler.persistTimelineObject(mEvent);
      ContentUpdater updater=new ContentUpdater(mContext);
      updater.setEventShared(mEvent);
    }
  }
;
}",0.9948567229977956
3045,"public static Experiences getAllSharedExperiencesFromServer(User user){
  try {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    GsonBuilder gsonB=new GsonBuilder();
    gsonB.registerTypeAdapter(EventItem.class,new EventItemDeserializer());
    gsonB.serializeNulls();
    Gson gson=gsonB.create();
    Reader r=new InputStreamReader(getJSONData(""String_Node_Str"" + user.getUserName() + ""String_Node_Str""));
    Experiences experiences=gson.fromJson(r,Experiences.class);
    List<BaseEvent> baseEvents=new ArrayList<BaseEvent>();
    for (    Experience experience : experiences.getExperiences()) {
      for (      BaseEvent be : experience.getEvents()) {
        Location location=new Location(""String_Node_Str"");
        location.setLatitude(be.getLatitude());
        location.setLongitude(be.getLongitude());
        if (be.getClassName().equals(Event.class.getSimpleName())) {
          BaseEvent bEvent=new BaseEvent(be.getId(),be.getExperienceid(),new Date(be.getDatetimemillis()),location,be.getUser());
          bEvent.setEmotionList(be.getEmotionList());
          bEvent.setEventItems(be.getEventItems());
          bEvent.setShared(be.isShared());
          baseEvents.add(bEvent);
        }
 else         if (be.getClassName().equals(MoodEvent.class.getSimpleName())) {
          MoodEvent me=new MoodEvent(be.getId(),be.getExperienceid(),new Date(be.getDatetimemillis()),location,MoodEnum.getType(be.getMoodInt()),be.getUser());
          me.setShared(true);
          me.setAverage(be.isAverage());
          baseEvents.add(me);
        }
      }
      experience.setEvents(baseEvents);
    }
    Log.i(""String_Node_Str"",""String_Node_Str"" + experiences.getExperiences().size() + ""String_Node_Str"");
    return experiences;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","public static Experiences getAllSharedExperiencesFromServer(User user){
  try {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    GsonBuilder gsonB=new GsonBuilder();
    gsonB.registerTypeAdapter(EventItem.class,new EventItemDeserializer());
    gsonB.serializeNulls();
    Gson gson=gsonB.create();
    Reader r=new InputStreamReader(getJSONData(""String_Node_Str"" + user.getUserName() + ""String_Node_Str""));
    Experiences experiences=gson.fromJson(r,Experiences.class);
    for (    Experience experience : experiences.getExperiences()) {
      List<BaseEvent> baseEvents=new ArrayList<BaseEvent>();
      if (experience.getEvents() != null) {
        for (        BaseEvent be : experience.getEvents()) {
          Location location=new Location(""String_Node_Str"");
          location.setLatitude(be.getLatitude());
          location.setLongitude(be.getLongitude());
          if (be.getClassName().equals(Event.class.getSimpleName())) {
            Event event=new Event(be.getId(),be.getExperienceid(),new Date(be.getDatetimemillis()),location,be.getUser());
            event.setEmotionList(be.getEmotionList());
            event.setEventItems(be.getEventItems());
            event.setShared(be.isShared());
            baseEvents.add(event);
          }
 else           if (be.getClassName().equals(MoodEvent.class.getSimpleName())) {
            MoodEvent me=new MoodEvent(be.getId(),be.getExperienceid(),new Date(be.getDatetimemillis()),location,MoodEnum.getType(be.getMoodInt()),be.getUser());
            me.setShared(true);
            me.setAverage(be.isAverage());
            baseEvents.add(me);
          }
        }
      }
      experience.setEvents(baseEvents);
    }
    Log.i(""String_Node_Str"",""String_Node_Str"" + experiences.getExperiences().size() + ""String_Node_Str"");
    return experiences;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}",0.8938457403923676
3046,"public JsonElement serialize(BaseEvent baseEvent,Type typeOfSrc,JsonSerializationContext context){
  BaseEvent bEvent=new BaseEvent(baseEvent.getId(),baseEvent.getExperienceid(),baseEvent.getDatetime(),baseEvent.getLocation(),baseEvent.getUser());
  if (baseEvent instanceof Event) {
    bEvent.setClassName(baseEvent.getClassName());
    if (((Event)baseEvent).getEmotionList().size() == 0)     bEvent.setEmotionList(null);
 else     bEvent.setEmotionList(baseEvent.getEmotionList());
    if (((Event)baseEvent).getEventItems().size() == 0)     bEvent.setEventItems(null);
 else     bEvent.setEventItems(((Event)baseEvent).getEventItems());
    bEvent.setShared(((Event)baseEvent).isShared());
  }
 else   if (baseEvent instanceof MoodEvent) {
    bEvent.setClassName(((MoodEvent)baseEvent).getClassName());
    bEvent.setMoodInt(((MoodEvent)baseEvent).getMood().getMoodInt());
    bEvent.setShared(((MoodEvent)baseEvent).isShared());
  }
  Gson gson=new Gson();
  return new JsonParser().parse(gson.toJson(bEvent));
}","public JsonElement serialize(BaseEvent baseEvent,Type typeOfSrc,JsonSerializationContext context){
  BaseEvent bEvent=null;
  if (baseEvent instanceof Event) {
    bEvent=convertEventToBaseEvent(baseEvent);
  }
 else   if (baseEvent instanceof MoodEvent) {
    bEvent=convertMoodEventToBaseEvent(baseEvent);
  }
  Gson gson=new Gson();
  return new JsonParser().parse(gson.toJson(bEvent));
}",0.3205673758865248
3047,"private void loadAllEmotions(Event event){
  String[] columns=new String[]{EmotionColumns._ID,EmotionColumns.EVENT_ID,EmotionColumns.EMOTION_TYPE};
  String where=EmotionColumns.EVENT_ID + ""String_Node_Str"" + event.getId()+ ""String_Node_Str"";
  Cursor listOfEmotions=context.getContentResolver().query(EmotionColumns.CONTENT_URI,columns,where,null,null);
  if (listOfEmotions.moveToFirst()) {
    String id=listOfEmotions.getString(listOfEmotions.getColumnIndex(NoteColumns._ID));
    do {
switch (listOfEmotions.getInt(listOfEmotions.getColumnIndex(EmotionColumns.EMOTION_TYPE))) {
case 1:
        event.addEmotion(new Emotion(id,EmotionEnum.LIKE));
      break;
case 2:
    event.addEmotion(new Emotion(id,EmotionEnum.COOL));
  break;
case 3:
event.addEmotion(new Emotion(id,EmotionEnum.DISLIKE));
break;
case 4:
event.addEmotion(new Emotion(id,EmotionEnum.SAD));
break;
}
}
 while (listOfEmotions.moveToNext());
}
listOfEmotions.close();
}","private void loadAllEmotions(Event event){
  String[] columns=new String[]{EmotionColumns._ID,EmotionColumns.EVENT_ID,EmotionColumns.EMOTION_TYPE};
  String where=EmotionColumns.EVENT_ID + ""String_Node_Str"" + event.getId()+ ""String_Node_Str"";
  Cursor listOfEmotions=context.getContentResolver().query(EmotionColumns.CONTENT_URI,columns,where,null,null);
  if (listOfEmotions.moveToFirst()) {
    do {
      String id=listOfEmotions.getString(listOfEmotions.getColumnIndex(EmotionColumns._ID));
switch (listOfEmotions.getInt(listOfEmotions.getColumnIndex(EmotionColumns.EMOTION_TYPE))) {
case 1:
        event.addEmotion(new Emotion(id,EmotionEnum.LIKE));
      break;
case 2:
    event.addEmotion(new Emotion(id,EmotionEnum.COOL));
  break;
case 3:
event.addEmotion(new Emotion(id,EmotionEnum.DISLIKE));
break;
case 4:
event.addEmotion(new Emotion(id,EmotionEnum.SAD));
break;
}
}
 while (listOfEmotions.moveToNext());
}
listOfEmotions.close();
}",0.9835892006352568
3048,"/** 
 * @param object The object to send
 * @param a Needs {@link Activity} to get the path of the content?
 */
public static void send(Object object,Activity a){
  Gson gson=new Gson();
  String jsonString=""String_Node_Str"";
  try {
    jsonString=gson.toJson(object,object.getClass());
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",e.getMessage());
  }
  System.out.println(""String_Node_Str"" + jsonString);
  Uploader.putToGAE(object,jsonString);
  System.out.println(""String_Node_Str"");
  if (object instanceof Experiences) {
    for (    Experience ex : ((Experiences)object).getExperiences()) {
      for (      Event event : ex.getEvents()) {
        for (        EventItem eventI : event.getEventItems()) {
          if (eventI instanceof SimplePicture) {
            Uploader.uploadFile(Utilities.IMAGE_STORAGE_FILEPATH + ((SimplePicture)eventI).getPictureFilename(),((SimplePicture)eventI).getPictureFilename());
          }
        }
      }
    }
  }
 else   if (object instanceof Event) {
    for (    EventItem eventI : ((Event)object).getEventItems()) {
      if (eventI instanceof SimplePicture) {
        Uploader.uploadFile(Utilities.getRealPathFromURI(((SimplePicture)eventI).getPictureUri(),a),((SimplePicture)eventI).getPictureFilename());
      }
    }
  }
}","/** 
 * @param object The object to send
 * @param a Needs {@link Activity} to get the path of the content?
 */
public static void send(Object object,Activity a){
  GsonBuilder gsonB=new GsonBuilder();
  gsonB.registerTypeAdapter(Experience.class,new ExperienceSerializer());
  Gson gson=gsonB.create();
  String jsonString=""String_Node_Str"";
  try {
    jsonString=gson.toJson(object,object.getClass());
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",e.getMessage());
  }
  System.out.println(""String_Node_Str"" + jsonString);
  Uploader.putToGAE(object,jsonString);
  System.out.println(""String_Node_Str"");
  if (object instanceof Experiences) {
    for (    Experience ex : ((Experiences)object).getExperiences()) {
      for (      Event event : ex.getEvents()) {
        for (        EventItem eventI : event.getEventItems()) {
          if (eventI instanceof SimplePicture) {
            Uploader.uploadFile(Utilities.IMAGE_STORAGE_FILEPATH + ((SimplePicture)eventI).getPictureFilename(),((SimplePicture)eventI).getPictureFilename());
          }
        }
      }
    }
  }
 else   if (object instanceof Event) {
    for (    EventItem eventI : ((Event)object).getEventItems()) {
      if (eventI instanceof SimplePicture) {
        Uploader.uploadFile(Utilities.getRealPathFromURI(((SimplePicture)eventI).getPictureUri(),a),((SimplePicture)eventI).getPictureFilename());
      }
    }
  }
}",0.9529106414534668
3049,"public boolean run(CommandLine cline){
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  String netfile=cline.getOptionValue(""String_Node_Str"");
  Net net=Net.load(netfile);
  String progFile=cline.getOptionValue(""String_Node_Str"");
  String outDir=cline.getOptionValue(""String_Node_Str"");
  int bins=100;
  if (cline.hasOption(""String_Node_Str"")) {
    bins=new Integer(cline.getOptionValue(""String_Node_Str""));
  }
  int trials=50;
  if (cline.hasOption(""String_Node_Str"")) {
    trials=new Integer(cline.getOptionValue(""String_Node_Str""));
  }
  int runs=1;
  if (cline.hasOption(""String_Node_Str"")) {
    runs=new Integer(cline.getOptionValue(""String_Node_Str""));
  }
  boolean directed=true;
  System.out.println(net);
  boolean append=false;
  for (int i=0; i < runs; i++) {
    System.out.println(""String_Node_Str"" + i);
    Generator gen=new Generator(net.getNodeCount(),net.getEdgeCount(),directed,trials);
    gen.load(progFile);
    gen.run();
    Net syntNet=gen.getNet();
    syntNet.save(outDir + ""String_Node_Str"" + i+ ""String_Node_Str"",NetFileType.SNAP);
    DiscreteDistrib inDegrees=new DiscreteDistrib(syntNet.inDegSeq());
    DiscreteDistrib outDegrees=new DiscreteDistrib(syntNet.outDegSeq());
    Distrib dPageRank=new Distrib(syntNet.prDSeq(),bins);
    Distrib uPageRank=new Distrib(syntNet.prUSeq(),bins);
    DiscreteDistrib dDistsDist=gen.getDistMatrixD().getDistrib();
    DiscreteDistrib uDistsDist=gen.getDistMatrixU().getDistrib();
    inDegrees.write(outDir + ""String_Node_Str"",append);
    outDegrees.write(outDir + ""String_Node_Str"",append);
    dPageRank.write(outDir + ""String_Node_Str"",append);
    uPageRank.write(outDir + ""String_Node_Str"",append);
    (new TriadicProfile(syntNet)).write(outDir + ""String_Node_Str"",append);
    dDistsDist.write(outDir + ""String_Node_Str"",append);
    uDistsDist.write(outDir + ""String_Node_Str"",append);
    append=true;
  }
  System.out.println(""String_Node_Str"");
  return true;
}","public boolean run(CommandLine cline){
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  String netfile=cline.getOptionValue(""String_Node_Str"");
  Net net=Net.load(netfile);
  String progFile=cline.getOptionValue(""String_Node_Str"");
  String outDir=cline.getOptionValue(""String_Node_Str"");
  int bins=100;
  if (cline.hasOption(""String_Node_Str"")) {
    bins=new Integer(cline.getOptionValue(""String_Node_Str""));
  }
  int trials=50;
  if (cline.hasOption(""String_Node_Str"")) {
    trials=new Integer(cline.getOptionValue(""String_Node_Str""));
  }
  int runs=1;
  if (cline.hasOption(""String_Node_Str"")) {
    runs=new Integer(cline.getOptionValue(""String_Node_Str""));
  }
  boolean directed=true;
  Distrib dPageRankReal=new Distrib(net.prDSeq(),bins);
  Distrib uPageRankReal=new Distrib(net.prUSeq(),bins);
  System.out.println(net);
  boolean append=false;
  for (int i=0; i < runs; i++) {
    System.out.println(""String_Node_Str"" + i);
    Generator gen=new Generator(net.getNodeCount(),net.getEdgeCount(),directed,trials);
    gen.load(progFile);
    gen.run();
    Net syntNet=gen.getNet();
    syntNet.save(outDir + ""String_Node_Str"" + i+ ""String_Node_Str"",NetFileType.SNAP);
    DiscreteDistrib inDegrees=new DiscreteDistrib(syntNet.inDegSeq());
    DiscreteDistrib outDegrees=new DiscreteDistrib(syntNet.outDegSeq());
    Distrib dPageRank=new Distrib(syntNet.prDSeq(),bins,dPageRankReal);
    Distrib uPageRank=new Distrib(syntNet.prUSeq(),bins,uPageRankReal);
    DiscreteDistrib dDistsDist=gen.getDistMatrixD().getDistrib();
    DiscreteDistrib uDistsDist=gen.getDistMatrixU().getDistrib();
    inDegrees.write(outDir + ""String_Node_Str"",append);
    outDegrees.write(outDir + ""String_Node_Str"",append);
    dPageRank.write(outDir + ""String_Node_Str"",append);
    uPageRank.write(outDir + ""String_Node_Str"",append);
    (new TriadicProfile(syntNet)).write(outDir + ""String_Node_Str"",append);
    dDistsDist.write(outDir + ""String_Node_Str"",append);
    uDistsDist.write(outDir + ""String_Node_Str"",append);
    append=true;
  }
  System.out.println(""String_Node_Str"");
  return true;
}",0.9695519791213572
3050,"private void calcDistances(MetricsBag bag){
  inDegreesDist=inDegrees.emdDistance(bag.inDegrees);
  outDegreesDist=outDegrees.emdDistance(bag.outDegrees);
  inPageRanksDist=inPageRanks.emdDistance(bag.inPageRanks);
  outPageRanksDist=outPageRanks.emdDistance(bag.outPageRanks);
  triadicProfileDist=triadicProfile.emdDistance(bag.triadicProfile);
  double verySmall=0.999;
  if (inDegreesDist == 0)   inDegreesDist=verySmall;
  if (outDegreesDist == 0)   outDegreesDist=verySmall;
  if (inPageRanksDist == 0)   inPageRanksDist=verySmall;
  if (outPageRanksDist == 0)   outPageRanksDist=verySmall;
  if (triadicProfileDist == 0)   triadicProfileDist=verySmall;
  distance=inDegreesDist * outDegreesDist * inPageRanksDist* outPageRanksDist* triadicProfileDist;
  distance=Math.pow(distance,1.0 / 4.0);
}","private void calcDistances(MetricsBag bag){
  inDegreesDist=inDegrees.emdDistance(bag.inDegrees);
  outDegreesDist=outDegrees.emdDistance(bag.outDegrees);
  inPageRanksDist=inPageRanks.emdDistance(bag.inPageRanks);
  outPageRanksDist=outPageRanks.emdDistance(bag.outPageRanks);
  triadicProfileDist=triadicProfile.emdDistance(bag.triadicProfile);
  double verySmall=0.999;
  if (inDegreesDist == 0)   inDegreesDist=verySmall;
  if (outDegreesDist == 0)   outDegreesDist=verySmall;
  if (inPageRanksDist == 0)   inPageRanksDist=verySmall;
  if (outPageRanksDist == 0)   outPageRanksDist=verySmall;
  if (triadicProfileDist == 0)   triadicProfileDist=verySmall;
  distance=inDegreesDist * outDegreesDist * inPageRanksDist* outPageRanksDist* triadicProfileDist;
  distance=Math.pow(distance,1.0 / 5.0);
}",0.9987515605493134
3051,"public void run(String[] args){
  CommandLineParser parser=new GnuParser();
  options=new Options();
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  try {
    cline=parser.parse(options,args);
    String cmd=args[0];
    Command cmdObj=null;
    if (cmd.equals(""String_Node_Str"")) {
      printHelpMessage();
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      cmdObj=new NetStats();
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      cmdObj=new Evolve();
    }
 else {
      printErrorMessage(""String_Node_Str"" + cmd + ""String_Node_Str"");
    }
    if (cmdObj != null) {
      if (!cmdObj.run(cline)) {
        printErrorMessage(cmdObj.getErrorMessage());
      }
    }
  }
 catch (  ParseException e) {
    String msg=e.getMessage();
    if (msg == null) {
      msg=""String_Node_Str"";
    }
    printErrorMessage(msg);
  }
  System.exit(0);
}","public void run(String[] args){
  args=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  CommandLineParser parser=new GnuParser();
  options=new Options();
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",true,""String_Node_Str"");
  try {
    cline=parser.parse(options,args);
    String cmd=args[0];
    Command cmdObj=null;
    if (cmd.equals(""String_Node_Str"")) {
      printHelpMessage();
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      cmdObj=new NetStats();
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      cmdObj=new Evolve();
    }
 else {
      printErrorMessage(""String_Node_Str"" + cmd + ""String_Node_Str"");
    }
    if (cmdObj != null) {
      if (!cmdObj.run(cline)) {
        printErrorMessage(cmdObj.getErrorMessage());
      }
    }
  }
 catch (  ParseException e) {
    String msg=e.getMessage();
    if (msg == null) {
      msg=""String_Node_Str"";
    }
    printErrorMessage(msg);
  }
  System.exit(0);
}",0.9626666666666668
3052,"public FastGenerator(int nodeCount,int edgeCount){
  super(nodeCount,edgeCount);
  trialRatio=0.01;
  trials=(int)((nodeCount * nodeCount) * trialRatio * trialRatio);
}","public FastGenerator(int nodeCount,int edgeCount){
  super(nodeCount,edgeCount);
  trialRatio=0.1;
  trials=(int)((nodeCount * nodeCount) * trialRatio * trialRatio);
}",0.9970149253731344
3053,"@Override public void run(){
  prog.clearEvalStats();
  DistMatrix distMatrix=new DistMatrix(nodeCount);
  net=new Net();
  Node[] nodeArray=new Node[nodeCount];
  for (int i=0; i < nodeCount; i++) {
    nodeArray[i]=net.addNode();
  }
  for (int i=0; i < edgeCount; i++) {
    double bestWeight=-1;
    int bestOrigIndex=-1;
    int bestTargIndex=-1;
    for (int j=0; j < trials; j++) {
      int origIndex=-1;
      int targIndex=-1;
      while ((origIndex == targIndex) || (distMatrix.getDist(origIndex,targIndex) < 2)) {
        origIndex=RandomGenerator.instance().random.nextInt(nodeCount);
        targIndex=RandomGenerator.instance().random.nextInt(nodeCount);
      }
      Node origNode=nodeArray[origIndex];
      Node targNode=nodeArray[targIndex];
      double directDistance=distMatrix.getDist(origNode.getId(),targNode.getId());
      double reverseDistance=distMatrix.getDist(targNode.getId(),origNode.getId());
      prog.vars[0]=(double)origIndex;
      prog.vars[1]=(double)targIndex;
      prog.vars[2]=(double)origNode.getInDegree();
      prog.vars[3]=(double)origNode.getOutDegree();
      prog.vars[4]=(double)targNode.getInDegree();
      prog.vars[5]=(double)targNode.getOutDegree();
      prog.vars[6]=directDistance;
      prog.vars[7]=reverseDistance;
      double weight=prog.eval(i);
      if (weight < 0) {
        weight=0;
      }
      if (weight > bestWeight) {
        bestWeight=weight;
        bestOrigIndex=origIndex;
        bestTargIndex=targIndex;
      }
    }
    Node origNode=nodeArray[bestOrigIndex];
    Node targNode=nodeArray[bestTargIndex];
    net.addEdge(origNode,targNode,i);
    distMatrix.updateDistances(net,bestOrigIndex,bestTargIndex);
    simulated=true;
  }
}","@Override public void run(){
  prog.clearEvalStats();
  DistMatrix distMatrix=new DistMatrix(nodeCount);
  net=new Net();
  Node[] nodeArray=new Node[nodeCount];
  for (int i=0; i < nodeCount; i++) {
    nodeArray[i]=net.addNode();
  }
  for (int i=0; i < edgeCount; i++) {
    double bestWeight=-1;
    int bestOrigIndex=-1;
    int bestTargIndex=-1;
    for (int j=0; j < trials; j++) {
      int origIndex=-1;
      int targIndex=-1;
      while ((origIndex == targIndex) || (distMatrix.getDist(origIndex,targIndex) < 2)) {
        origIndex=RandomGenerator.instance().random.nextInt(nodeCount);
        targIndex=RandomGenerator.instance().random.nextInt(nodeCount);
      }
      Node origNode=nodeArray[origIndex];
      Node targNode=nodeArray[targIndex];
      double directDistance=distMatrix.getDist(origNode.getId(),targNode.getId());
      double reverseDistance=distMatrix.getDist(targNode.getId(),origNode.getId());
      prog.vars[0]=(double)origIndex;
      prog.vars[1]=(double)targIndex;
      prog.vars[2]=(double)origNode.getInDegree();
      prog.vars[3]=(double)origNode.getOutDegree();
      prog.vars[4]=(double)targNode.getInDegree();
      prog.vars[5]=(double)targNode.getOutDegree();
      prog.vars[6]=directDistance;
      prog.vars[7]=reverseDistance;
      double weight=prog.eval(i);
      if (weight < 0) {
        weight=0;
      }
      if (Double.isNaN(weight)) {
        weight=0;
      }
      if (weight > bestWeight) {
        bestWeight=weight;
        bestOrigIndex=origIndex;
        bestTargIndex=targIndex;
      }
    }
    Node origNode=nodeArray[bestOrigIndex];
    Node targNode=nodeArray[bestTargIndex];
    net.addEdge(origNode,targNode,i);
    distMatrix.updateDistances(net,bestOrigIndex,bestTargIndex);
    simulated=true;
  }
}",0.9828864803194524
3054,"@Override public void run(){
  prog.clearEvalStats();
  DistMatrix distMatrix=new DistMatrix(nodeCount);
  net=new Net();
  Node[] nodeArray=new Node[nodeCount];
  for (int i=0; i < nodeCount; i++) {
    nodeArray[i]=net.addNode();
  }
  double weights[][]=new double[nodeCount][nodeCount];
  for (int i=0; i < edgeCount; i++) {
    double totalWeight=0;
    for (int origIndex=0; origIndex < nodeCount; origIndex++) {
      for (int targIndex=0; targIndex < nodeCount; targIndex++) {
        double weight=0;
        if (distMatrix.getDist(origIndex,targIndex) < 2) {
          Node origNode=nodeArray[origIndex];
          Node targNode=nodeArray[targIndex];
          double directDistance=distMatrix.getDist(origNode.getId(),targNode.getId());
          double reverseDistance=distMatrix.getDist(targNode.getId(),origNode.getId());
          prog.vars[0]=(double)origIndex;
          prog.vars[1]=(double)targIndex;
          prog.vars[2]=(double)origNode.getInDegree();
          prog.vars[3]=(double)origNode.getOutDegree();
          prog.vars[4]=(double)targNode.getInDegree();
          prog.vars[5]=(double)targNode.getOutDegree();
          prog.vars[6]=directDistance;
          prog.vars[7]=reverseDistance;
          weight=prog.eval(i);
          if (weight < 0) {
            weight=0;
          }
        }
        weights[origIndex][targIndex]=weight;
        totalWeight+=weight;
      }
    }
    double targWeight=RandomGenerator.instance().random.nextDouble() * totalWeight;
    int selectedOrigIndex=-1;
    int selectedTargIndex=-1;
    if (totalWeight > 0) {
      totalWeight=0;
      boolean selected=false;
      for (int origIndex=0; (origIndex < nodeCount) && (!selected); origIndex++) {
        for (int targIndex=0; (targIndex < nodeCount) && (!selected); targIndex++) {
          totalWeight+=weights[origIndex][targIndex];
          if (totalWeight >= targWeight) {
            selectedOrigIndex=origIndex;
            selectedTargIndex=targIndex;
            selected=true;
          }
        }
      }
    }
 else {
      while (selectedOrigIndex == selectedTargIndex) {
        selectedOrigIndex=RandomGenerator.instance().random.nextInt(nodeCount);
        selectedTargIndex=RandomGenerator.instance().random.nextInt(nodeCount);
      }
    }
    Node origNode=nodeArray[selectedOrigIndex];
    Node targNode=nodeArray[selectedTargIndex];
    net.addEdge(origNode,targNode,i);
    distMatrix.updateDistances(net,selectedOrigIndex,selectedTargIndex);
    simulated=true;
  }
}","@Override public void run(){
  prog.clearEvalStats();
  DistMatrix distMatrix=new DistMatrix(nodeCount);
  net=new Net();
  Node[] nodeArray=new Node[nodeCount];
  for (int i=0; i < nodeCount; i++) {
    nodeArray[i]=net.addNode();
  }
  double weights[][]=new double[nodeCount][nodeCount];
  for (int i=0; i < edgeCount; i++) {
    double totalWeight=0;
    for (int origIndex=0; origIndex < nodeCount; origIndex++) {
      for (int targIndex=0; targIndex < nodeCount; targIndex++) {
        double weight=0;
        if (distMatrix.getDist(origIndex,targIndex) < 2) {
          Node origNode=nodeArray[origIndex];
          Node targNode=nodeArray[targIndex];
          double directDistance=distMatrix.getDist(origNode.getId(),targNode.getId());
          double reverseDistance=distMatrix.getDist(targNode.getId(),origNode.getId());
          prog.vars[0]=(double)origIndex;
          prog.vars[1]=(double)targIndex;
          prog.vars[2]=(double)origNode.getInDegree();
          prog.vars[3]=(double)origNode.getOutDegree();
          prog.vars[4]=(double)targNode.getInDegree();
          prog.vars[5]=(double)targNode.getOutDegree();
          prog.vars[6]=directDistance;
          prog.vars[7]=reverseDistance;
          weight=prog.eval(i);
          if (weight < 0) {
            weight=0;
          }
          if (Double.isNaN(weight)) {
            weight=0;
          }
        }
        weights[origIndex][targIndex]=weight;
        totalWeight+=weight;
      }
    }
    double targWeight=RandomGenerator.instance().random.nextDouble() * totalWeight;
    int selectedOrigIndex=-1;
    int selectedTargIndex=-1;
    if (totalWeight > 0) {
      totalWeight=0;
      boolean selected=false;
      for (int origIndex=0; (origIndex < nodeCount) && (!selected); origIndex++) {
        for (int targIndex=0; (targIndex < nodeCount) && (!selected); targIndex++) {
          totalWeight+=weights[origIndex][targIndex];
          if (totalWeight >= targWeight) {
            selectedOrigIndex=origIndex;
            selectedTargIndex=targIndex;
            selected=true;
          }
        }
      }
    }
 else {
      while (selectedOrigIndex == selectedTargIndex) {
        selectedOrigIndex=RandomGenerator.instance().random.nextInt(nodeCount);
        selectedTargIndex=RandomGenerator.instance().random.nextInt(nodeCount);
      }
    }
    Node origNode=nodeArray[selectedOrigIndex];
    Node targNode=nodeArray[selectedTargIndex];
    net.addEdge(origNode,targNode,i);
    distMatrix.updateDistances(net,selectedOrigIndex,selectedTargIndex);
    simulated=true;
  }
}",0.9858823529411764
3055,"public boolean run(CommandLine cline){
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  String netfile=cline.getOptionValue(""String_Node_Str"");
  Net net=Net.load(netfile);
  String outDir=cline.getOptionValue(""String_Node_Str"");
  int bins=100;
  if (cline.hasOption(""String_Node_Str"")) {
    bins=new Integer(cline.getOptionValue(""String_Node_Str""));
  }
  int nodeCount=net.getNodeCount();
  int edgeCount=net.getEdgeCount();
  Net randomNet=RandomNet.generate(nodeCount,edgeCount);
  randomNet.save(outDir + ""String_Node_Str"",NetFileType.SNAP);
  DiscreteDistrib inDegrees=new DiscreteDistrib(net.inDegSeq());
  DiscreteDistrib outDegrees=new DiscreteDistrib(net.outDegSeq());
  Distrib dPageRank=new Distrib(net.prDSeq(),bins);
  Distrib uPageRank=new Distrib(net.prUSeq(),bins);
  inDegrees.write(outDir + ""String_Node_Str"");
  outDegrees.write(outDir + ""String_Node_Str"");
  dPageRank.write(outDir + ""String_Node_Str"");
  uPageRank.write(outDir + ""String_Node_Str"");
  (new TriadicProfile(randomNet)).write(outDir + ""String_Node_Str"");
  return true;
}","public boolean run(CommandLine cline){
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  String netfile=cline.getOptionValue(""String_Node_Str"");
  Net net=Net.load(netfile);
  String outDir=cline.getOptionValue(""String_Node_Str"");
  int bins=100;
  if (cline.hasOption(""String_Node_Str"")) {
    bins=new Integer(cline.getOptionValue(""String_Node_Str""));
  }
  int nodeCount=net.getNodeCount();
  int edgeCount=net.getEdgeCount();
  Net randomNet=RandomNet.generate(nodeCount,edgeCount);
  randomNet.save(outDir + ""String_Node_Str"",NetFileType.SNAP);
  DiscreteDistrib inDegrees=new DiscreteDistrib(randomNet.inDegSeq());
  DiscreteDistrib outDegrees=new DiscreteDistrib(randomNet.outDegSeq());
  Distrib dPageRank=new Distrib(randomNet.prDSeq(),bins);
  Distrib uPageRank=new Distrib(randomNet.prUSeq(),bins);
  inDegrees.write(outDir + ""String_Node_Str"");
  outDegrees.write(outDir + ""String_Node_Str"");
  dPageRank.write(outDir + ""String_Node_Str"");
  uPageRank.write(outDir + ""String_Node_Str"");
  (new TriadicProfile(randomNet)).write(outDir + ""String_Node_Str"");
  return true;
}",0.9870759289176092
3056,"private void calcDistances(MetricsBag bag){
  inDegreesDist=inDegrees.emdDistance(bag.inDegrees);
  outDegreesDist=outDegrees.emdDistance(outDegrees);
  pageRanksDist=pageRanks.emdDistance(bag.pageRanks);
  triadicProfileDist=triadicProfile.emdDistance(bag.triadicProfile);
  double verySmall=0.999;
  if (inDegreesDist == 0)   inDegreesDist=verySmall;
  if (outDegreesDist == 0)   outDegreesDist=verySmall;
  if (pageRanksDist == 0)   pageRanksDist=verySmall;
  if (triadicProfileDist == 0)   triadicProfileDist=verySmall;
  distance=inDegreesDist * outDegreesDist * pageRanksDist* triadicProfileDist;
  distance=Math.pow(distance,1.0 / 4.0);
}","private void calcDistances(MetricsBag bag){
  inDegreesDist=inDegrees.emdDistance(bag.inDegrees);
  outDegreesDist=outDegrees.emdDistance(bag.outDegrees);
  pageRanksDist=pageRanks.emdDistance(bag.pageRanks);
  triadicProfileDist=triadicProfile.emdDistance(bag.triadicProfile);
  double verySmall=0.999;
  if (inDegreesDist == 0)   inDegreesDist=verySmall;
  if (outDegreesDist == 0)   outDegreesDist=verySmall;
  if (pageRanksDist == 0)   pageRanksDist=verySmall;
  if (triadicProfileDist == 0)   triadicProfileDist=verySmall;
  distance=inDegreesDist * outDegreesDist * pageRanksDist* triadicProfileDist;
  distance=Math.pow(distance,1.0 / 4.0);
}",0.9969088098918084
3057,"public Net cloneFlagged(){
  Net clonedNet=new Net();
  for (  Node node : nodes) {
    if (node.isFlag()) {
      clonedNet.addNode(node.clone());
    }
  }
  for (  Edge edge : edges) {
    Node orig=edge.getOrigin();
    Node targ=edge.getTarget();
    if (orig.isFlag() && targ.isFlag()) {
      long timestamp=edge.getTimestamp();
      Node corig=clonedNet.getNodeById(orig.getId());
      Node ctarg=clonedNet.getNodeById(targ.getId());
      clonedNet.addEdge(corig,ctarg,timestamp);
    }
  }
  return clonedNet;
}","public Net cloneFlagged(){
  Net clonedNet=new Net();
  for (  Node node : nodes) {
    if (node.getFlag()) {
      clonedNet.addNode(node.clone());
    }
  }
  for (  Edge edge : edges) {
    Node orig=edge.getOrigin();
    Node targ=edge.getTarget();
    if (orig.getFlag() && targ.getFlag()) {
      long timestamp=edge.getTimestamp();
      Node corig=clonedNet.getNodeById(orig.getId());
      Node ctarg=clonedNet.getNodeById(targ.getId());
      clonedNet.addEdge(corig,ctarg,timestamp);
    }
  }
  return clonedNet;
}",0.6882745471877979
3058,"public Node(int id){
  this.id=id;
  inDegree=0;
  outDegree=0;
  birth=-1;
  inEdges=new HashSet<Edge>();
  outEdges=new HashSet<Edge>();
}","public Node(int id){
  this.id=id;
  inDegree=0;
  outDegree=0;
  inEdges=new HashSet<Edge>();
  outEdges=new HashSet<Edge>();
}",0.9552238805970148
3059,"public static Net loadNet(String filePath){
  int dotpos=filePath.lastIndexOf(""String_Node_Str"");
  String ext=""String_Node_Str"";
  if (dotpos > 0) {
    ext=filePath.substring(dotpos + 1,filePath.length());
  }
  ext=ext.toLowerCase();
  Net net=null;
  if (ext.equals(""String_Node_Str"")) {
    net=(new SNAPNetFile()).load(filePath);
    return net;
  }
 else   if (ext.equals(""String_Node_Str"")) {
    net=(new MatrixFile()).load(filePath);
    return net;
  }
 else   if (ext.equals(""String_Node_Str"")) {
    net=(new GMLNetFile()).load(filePath);
    return net;
  }
 else {
    return null;
  }
}","public static Net loadNet(String filePath){
  int dotpos=filePath.lastIndexOf(""String_Node_Str"");
  String ext=""String_Node_Str"";
  if (dotpos > 0) {
    ext=filePath.substring(dotpos + 1,filePath.length());
  }
  ext=ext.toLowerCase();
  Net net=null;
  if (ext.equals(""String_Node_Str"")) {
    net=(new SNAPNetFile()).load(filePath);
    return net;
  }
 else   if (ext.equals(""String_Node_Str"")) {
    net=(new SNAPNetFile()).load(filePath);
    return net;
  }
 else   if (ext.equals(""String_Node_Str"")) {
    net=(new MatrixFile()).load(filePath);
    return net;
  }
 else   if (ext.equals(""String_Node_Str"")) {
    net=(new GMLNetFile()).load(filePath);
    return net;
  }
 else {
    return null;
  }
}",0.916984006092917
3060,"static public void main(String[] args){
  Net net=Net.load(""String_Node_Str"");
  TriadicProfile tp=new TriadicProfile(net);
  System.out.println(net);
  long[] profile=tp.getProfile();
  for (  long p : profile)   System.out.print(""String_Node_Str"" + p);
  System.out.println();
}","static public void main(String[] args){
  Generator gen=new Generator(7115,103689);
  gen.initRandom();
  gen.run();
  Net net=gen.getNet();
  System.out.println(""String_Node_Str"");
  TriadicProfile tp=new TriadicProfile(net);
  System.out.println(net);
  long[] profile=tp.getProfile();
  for (  long p : profile)   System.out.print(""String_Node_Str"" + p);
  System.out.println();
}",0.8295625942684767
3061,"private void triadProfile(){
  Node[] triad=new Node[3];
  profile=new long[13];
  for (int i=0; i < 13; i++)   profile[i]=0;
  for (  Node node : net.getNodes()) {
    triad[0]=node;
    triadProfileRec(triad,0,profile);
    node.setFlag(false);
  }
}","private void triadProfile(){
  Node[] triad=new Node[3];
  profile=new long[13];
  for (int i=0; i < 13; i++) {
    profile[i]=0;
  }
  int nodeCount=0;
  for (  Node node : net.getNodes()) {
    triad[0]=node;
    triadProfileRec(triad,0,profile);
    nodeCount++;
  }
}",0.8604206500956023
3062,"private void sampleRec(Node node){
  if (sampleNodeCount >= targNodeCount) {
    return;
  }
  List<Node> candidates=new LinkedList<Node>();
  for (  Edge edge : node.getOutEdges()) {
    Node outNode=edge.getTarget();
    if (!outNode.isFlag()) {
      candidates.add(outNode);
    }
  }
  Collections.shuffle(candidates);
  int count=RandomGenerator.instance().nextGeometric(0.2);
  for (  Node c : candidates) {
    if (count <= 0) {
      break;
    }
    count--;
    c.setFlag(true);
    sampleNodeCount++;
    if (sampleNodeCount >= targNodeCount) {
      return;
    }
  }
  for (  Node c : candidates) {
    if (count <= 0) {
      break;
    }
    sampleRec(c);
  }
}","private void sampleRec(Node node){
  if (sampleNodeCount >= targNodeCount) {
    return;
  }
  List<Node> candidates=new LinkedList<Node>();
  for (  Edge edge : node.getOutEdges()) {
    Node outNode=edge.getTarget();
    if (!outNode.getFlag()) {
      candidates.add(outNode);
    }
  }
  Collections.shuffle(candidates);
  int count=RandomGenerator.instance().nextGeometric(0.2);
  for (  Node c : candidates) {
    if (count <= 0) {
      break;
    }
    count--;
    c.setFlag(true);
    sampleNodeCount++;
    if (sampleNodeCount >= targNodeCount) {
      return;
    }
  }
  for (  Node c : candidates) {
    if (count <= 0) {
      break;
    }
    sampleRec(c);
  }
}",0.996309963099631
3063,"public Net sample(double samplePercentage){
  targNodeCount=(int)((double)origNet.getNodeCount() * samplePercentage);
  sampleNodeCount=0;
  origNet.clearFlags();
  while (sampleNodeCount < targNodeCount) {
    Node node=origNet.getRandomNode();
    if (!node.isFlag()) {
      node.setFlag(true);
      sampleNodeCount++;
      sampleRec(node);
    }
  }
  return origNet.cloneFlagged();
}","public Net sample(double samplePercentage){
  targNodeCount=(int)((double)origNet.getNodeCount() * samplePercentage);
  sampleNodeCount=0;
  origNet.clearFlags();
  while (sampleNodeCount < targNodeCount) {
    Node node=origNet.getRandomNode();
    if (!node.getFlag()) {
      node.setFlag(true);
      sampleNodeCount++;
      sampleRec(node);
    }
  }
  return origNet.cloneFlagged();
}",0.9935979513444302
3064,"@Override public boolean run(CommandLine cline){
  long maxEffort=1000 * 1000 * 50;
  int generations=999999999;
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  String netfile=cline.getOptionValue(""String_Node_Str"");
  String outdir=cline.getOptionValue(""String_Node_Str"");
  EvoDRMap2P callbacks=new EvoDRMap2P(Net.load(netfile,NetFileType.SNAP),outdir,maxEffort);
  EvoStrategy popGen=new EvoStrategy(1,1,1);
  EvoGen evo=new EvoGen(popGen,callbacks,generations);
  System.out.println(""String_Node_Str"" + netfile);
  System.out.println(evo.infoString());
  try {
    FileWriter fstream=new FileWriter(outdir + ""String_Node_Str"");
    BufferedWriter out=new BufferedWriter(fstream);
    out.write(evo.infoString());
    out.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  evo.run();
  return true;
}","@Override public boolean run(CommandLine cline){
  double maxEffort=5.00;
  int generations=999999999;
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  if (!cline.hasOption(""String_Node_Str"")) {
    setErrorMessage(""String_Node_Str"");
    return false;
  }
  String netfile=cline.getOptionValue(""String_Node_Str"");
  String outdir=cline.getOptionValue(""String_Node_Str"");
  EvoDRMap2P callbacks=new EvoDRMap2P(Net.load(netfile,NetFileType.SNAP),outdir,maxEffort);
  EvoStrategy popGen=new EvoStrategy(1,1,1);
  EvoGen evo=new EvoGen(popGen,callbacks,generations);
  System.out.println(""String_Node_Str"" + netfile);
  System.out.println(evo.infoString());
  try {
    FileWriter fstream=new FileWriter(outdir + ""String_Node_Str"");
    BufferedWriter out=new BufferedWriter(fstream);
    out.write(evo.infoString());
    out.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  evo.run();
  return true;
}",0.9867886178861788
3065,"public EvoDRMap2P(Net targNet,String outDir,long maxEffort){
  this.outDir=outDir;
  this.maxEffort=maxEffort;
  targNodeCount=targNet.getNodeCount();
  targEdgeCount=targNet.getEdgeCount();
  Net sampleNet=targNet;
  samplingRatio=1;
  DownSampler sampler=new DownSampler(targNet,5);
  while (computeEffort(sampleNet) > maxEffort) {
    sampleNet=sampler.sampleDown();
    samplingRatio=sampler.getRatio();
    System.out.println(""String_Node_Str"" + samplingRatio + ""String_Node_Str""+ maxEffort+ ""String_Node_Str""+ computeEffort(sampleNet));
  }
  effort=computeEffort(sampleNet);
  sampleNodeCount=sampleNet.getNodeCount();
  sampleEdgeCount=sampleNet.getEdgeCount();
  targDRMap=genDRMap(sampleNet);
  gen=new GPGen2P(sampleNodeCount,sampleEdgeCount);
  bestCount=0;
  genDRMap(targNet).draw(outDir + ""String_Node_Str"");
  genDRMap(sampleNet).draw(outDir + ""String_Node_Str"");
  try {
    FileWriter fwriter=new FileWriter(outDir + ""String_Node_Str"");
    BufferedWriter writer=new BufferedWriter(fwriter);
    writer.write(""String_Node_Str"");
    writer.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public EvoDRMap2P(Net targNet,String outDir,double maxEffort){
  this.outDir=outDir;
  this.maxEffort=maxEffort;
  targNodeCount=targNet.getNodeCount();
  targEdgeCount=targNet.getEdgeCount();
  Net sampleNet=targNet;
  samplingRatio=1;
  DownSampler sampler=new DownSampler(targNet,5);
  while (computeEffort(sampleNet) > maxEffort) {
    sampleNet=sampler.sampleDown();
    samplingRatio=sampler.getRatio();
    System.out.println(""String_Node_Str"" + samplingRatio + ""String_Node_Str""+ maxEffort+ ""String_Node_Str""+ computeEffort(sampleNet));
  }
  effort=computeEffort(sampleNet);
  sampleNodeCount=sampleNet.getNodeCount();
  sampleEdgeCount=sampleNet.getEdgeCount();
  targDRMap=genDRMap(sampleNet);
  gen=new GPGen2P(sampleNodeCount,sampleEdgeCount);
  bestCount=0;
  genDRMap(targNet).draw(outDir + ""String_Node_Str"");
  genDRMap(sampleNet).draw(outDir + ""String_Node_Str"");
  try {
    FileWriter fwriter=new FileWriter(outDir + ""String_Node_Str"");
    BufferedWriter writer=new BufferedWriter(fwriter);
    writer.write(""String_Node_Str"");
    writer.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9955634427684116
3066,"private static long computeEffort(Net net){
  return 2 * net.getNodeCount() * net.getEdgeCount();
}","private static double computeEffort(Net net){
  return 2.0 * (((double)net.getNodeCount()) / 1000.0) * (((double)net.getEdgeCount()) / 1000.0);
}",0.7868852459016393
3067,"private void calcEndogamicNetworkConcentration(){
  endogamicNetworkConcentration=0;
  double endogamicN=endogamousPercentage;
  for (int i=0; i < m; i++) {
    double x=matrix[i][i] / endogamicN;
    endogamicNetworkConcentration+=x * x;
  }
}","private void calcEndogamicNetworkConcentration(){
  endogamicNetworkConcentration=0;
  if (endogamousPercentage == 0.0)   return;
  double endogamicN=endogamousPercentage;
  for (int i=0; i < m; i++) {
    double x=matrix[i][i] / endogamicN;
    endogamicNetworkConcentration+=x * x;
  }
}",0.9155722326454032
3068,"/** 
 * Constructor
 * @param is
 * @throws IOException
 * @throws UnsupportedAudioFileException 
 */
public Sample(InputStream is) throws IOException, UnsupportedAudioFileException {
  AudioInputStream ais=AudioSystem.getAudioInputStream(is);
  _format=ais.getFormat();
  this.nChannel=_format.getChannels();
  this.nSamplesPerSec=_format.getSampleRate();
  this.nBitsPerSample=_format.getSampleSizeInBits();
  byte[] d=new byte[(int)(ais.getFrameLength() * _format.getFrameSize())];
  ais.read(d);
  data=new SampleData(d);
  points=new ArrayList<SamplePoint>();
  int count=0;
  for (int i=0; i < d.length; i++) {
    try {
      SamplePoint point=new SamplePoint(this,i);
      points.add(point);
      count++;
    }
 catch (    ArrayIndexOutOfBoundsException e) {
      break;
    }
  }
}","/** 
 * Constructor
 * @param is
 * @throws IOException
 * @throws UnsupportedAudioFileException 
 */
public Sample(InputStream is) throws IOException, UnsupportedAudioFileException {
  AudioInputStream ais=AudioSystem.getAudioInputStream(new BufferedInputStream(is));
  _format=ais.getFormat();
  this.nChannel=_format.getChannels();
  this.nSamplesPerSec=_format.getSampleRate();
  this.nBitsPerSample=_format.getSampleSizeInBits();
  byte[] d=new byte[(int)(ais.getFrameLength() * _format.getFrameSize())];
  ais.read(d);
  data=new SampleData(d);
  points=new ArrayList<SamplePoint>();
  int count=0;
  for (int i=0; i < d.length; i++) {
    try {
      SamplePoint point=new SamplePoint(this,i);
      points.add(point);
      count++;
    }
 catch (    ArrayIndexOutOfBoundsException e) {
      break;
    }
  }
}",0.982021078735276
3069,"public void uploadPhoto(HttpRequest request) throws HttpException, IOException {
  Log.d(TAG,myId + ""String_Node_Str"" + request.toString());
  HttpEntityEnclosingRequest eyefiRequest=(HttpEntityEnclosingRequest)request;
  Header contentTypes[]=eyefiRequest.getHeaders(""String_Node_Str"");
  if ((contentTypes == null) || contentTypes.length < 1) {
    Log.e(TAG,myId + ""String_Node_Str"");
    close();
  }
  HeaderElement elements[]=contentTypes[0].getElements();
  if ((elements == null) || elements.length < 1) {
    Log.e(TAG,myId + ""String_Node_Str"");
    close();
  }
  if (!elements[0].getName().equals(""String_Node_Str"")) {
    Log.e(TAG,myId + ""String_Node_Str"");
    close();
  }
  String b=""String_Node_Str"";
  String value=contentTypes[0].getValue();
  int pos=value.indexOf(b);
  if (pos < 0) {
    Log.e(TAG,myId + ""String_Node_Str"");
    close();
  }
  String boundary=""String_Node_Str"" + value.substring(pos + b.length()) + ""String_Node_Str"";
  Log.d(TAG,myId + ""String_Node_Str"" + boundary);
  receiveRequestEntity(eyefiRequest);
  HttpEntity entity=eyefiRequest.getEntity();
  MultipartInputStream in=new MultipartInputStream(new BufferedInputStream(entity.getContent(),400000),boundary);
  in.close();
  Map<String,String> headers=in.getHeaders();
  UploadPhoto uploadPhoto=null;
  String fileSignature=null;
  String imageName=null;
  File destinationPath=null;
  long id=-1;
  boolean success=false;
  String readDigest=null, calculatedDigest=null;
  Vector<File> written=new Vector<File>();
  String fileName=null;
  while (!headers.isEmpty()) {
    String contentDisposition=headers.get(""String_Node_Str"");
    if (contentDisposition == null)     break;
    if (!contentDisposition.startsWith(CONTENT_DISPOSITION_PREAMBLE))     break;
    int endPos=contentDisposition.indexOf('""',CONTENT_DISPOSITION_PREAMBLE.length());
    if (endPos < 0)     break;
    String partName=contentDisposition.substring(CONTENT_DISPOSITION_PREAMBLE.length(),endPos);
    Log.d(TAG,myId + ""String_Node_Str"" + partName);
    if (partName.equals(""String_Node_Str"")) {
      UploadPhoto u=new UploadPhoto();
      u.parse(in);
      uploadPhoto=u;
      Log.d(TAG,myId + ""String_Node_Str"");
    }
 else     if (partName.equals(""String_Node_Str"")) {
      EyefiIntegrityDigest checksum=new EyefiIntegrityDigest();
      TarInputStream tarball=new TarInputStream(new CheckedInputStream(in,checksum));
      TarEntry file=tarball.getNextEntry();
      while (file != null) {
        fileName=file.getName();
        Log.d(TAG,myId + ""String_Node_Str"" + fileName+ ""String_Node_Str""+ file.getSize()+ ""String_Node_Str"");
        if (fileName.endsWith(""String_Node_Str"")) {
          File destination=openWritableFile(id,""String_Node_Str"");
          copyToLocalFile(tarball,destination);
          written.add(destination);
        }
 else {
          if (uploadPhoto == null) {
            Log.d(TAG,myId + ""String_Node_Str"");
            break;
          }
          fileSignature=uploadPhoto.getParameter(EyefiMessage.FILESIGNATURE);
          imageName=fileName;
          try {
            try {
              id=db.imageUploadable(fileSignature);
            }
 catch (            DBAdapter.UnknownUpload e) {
              fileSignature=fileSignature + ""String_Node_Str"" + fileName;
              Log.d(TAG,myId + ""String_Node_Str"" + fileSignature);
              db.registerNewImage(fileSignature);
              id=db.imageUploadable(fileSignature);
            }
            Log.d(TAG,myId + ""String_Node_Str"" + fileName+ ""String_Node_Str""+ fileSignature+ ""String_Node_Str""+ id);
            destinationPath=openWritableFile(id,""String_Node_Str"");
            Log.d(TAG,myId + ""String_Node_Str"" + imageName+ ""String_Node_Str""+ destinationPath);
            copyToLocalFile(tarball,destinationPath);
            written.add(destinationPath);
            success=true;
          }
 catch (          IOException e) {
            Log.e(TAG,myId + ""String_Node_Str"" + e);
          }
catch (          DBAdapter.DuplicateUpload e) {
            Log.e(TAG,myId + ""String_Node_Str"");
            success=true;
          }
catch (          DBAdapter.UnknownUpload e) {
            Log.e(TAG,myId + ""String_Node_Str"" + uploadPhoto);
          }
        }
        Log.d(TAG,myId + ""String_Node_Str"");
        file=tarball.getNextEntry();
      }
      UploadKey uploadKey=getKeyForMac(uploadPhoto.getMacAddress());
      calculatedDigest=checksum.getValue(uploadKey).toString();
      Log.d(TAG,myId + ""String_Node_Str"" + calculatedDigest);
    }
 else     if (partName.equals(""String_Node_Str"")) {
      BufferedReader r=new BufferedReader(new InputStreamReader(in));
      readDigest=r.readLine();
      Log.d(TAG,myId + ""String_Node_Str"" + readDigest);
    }
    in.close();
    headers=in.getHeaders();
  }
  if (calculatedDigest == null) {
    Log.d(TAG,myId + ""String_Node_Str"");
    success=false;
  }
  if (readDigest == null) {
    Log.d(TAG,myId + ""String_Node_Str"");
    success=false;
  }
  if (success && !readDigest.equals(calculatedDigest)) {
    Log.d(TAG,myId + ""String_Node_Str"");
    success=false;
  }
  if (success && destinationPath != null) {
    Uri uri=importPhoto(destinationPath,fileName,id);
    db.receiveImage(id,imageName,destinationPath.toString());
    db.finishImage(id,uri);
  }
  if (!success)   for (  File f : written)   f.delete();
  UploadPhotoResponse response=new UploadPhotoResponse(success);
  sendResponseHeader(response);
  sendResponseEntity(response);
}","public void uploadPhoto(HttpRequest request) throws HttpException, IOException {
  Log.d(TAG,myId + ""String_Node_Str"" + request.toString());
  HttpEntityEnclosingRequest eyefiRequest=(HttpEntityEnclosingRequest)request;
  Header contentTypes[]=eyefiRequest.getHeaders(""String_Node_Str"");
  if ((contentTypes == null) || contentTypes.length < 1) {
    Log.e(TAG,myId + ""String_Node_Str"");
    close();
  }
  HeaderElement elements[]=contentTypes[0].getElements();
  if ((elements == null) || elements.length < 1) {
    Log.e(TAG,myId + ""String_Node_Str"");
    close();
  }
  if (!elements[0].getName().equals(""String_Node_Str"")) {
    Log.e(TAG,myId + ""String_Node_Str"");
    close();
  }
  String b=""String_Node_Str"";
  String value=contentTypes[0].getValue();
  int pos=value.indexOf(b);
  if (pos < 0) {
    Log.e(TAG,myId + ""String_Node_Str"");
    close();
  }
  String boundary=""String_Node_Str"" + value.substring(pos + b.length());
  Log.d(TAG,myId + ""String_Node_Str"" + boundary);
  receiveRequestEntity(eyefiRequest);
  HttpEntity entity=eyefiRequest.getEntity();
  MultipartInputStream in=new MultipartInputStream(new BufferedInputStream(entity.getContent(),400000),boundary);
  in.close();
  Map<String,String> headers=in.getHeaders();
  UploadPhoto uploadPhoto=null;
  String fileSignature=null;
  String imageName=null;
  File destinationPath=null;
  long id=-1;
  boolean success=false;
  String readDigest=null, calculatedDigest=null;
  Vector<File> written=new Vector<File>();
  String fileName=null;
  while (!headers.isEmpty()) {
    String contentDisposition=headers.get(""String_Node_Str"");
    if (contentDisposition == null)     break;
    if (!contentDisposition.startsWith(CONTENT_DISPOSITION_PREAMBLE))     break;
    int endPos=contentDisposition.indexOf('""',CONTENT_DISPOSITION_PREAMBLE.length());
    if (endPos < 0)     break;
    String partName=contentDisposition.substring(CONTENT_DISPOSITION_PREAMBLE.length(),endPos);
    Log.d(TAG,myId + ""String_Node_Str"" + partName);
    if (partName.equals(""String_Node_Str"")) {
      UploadPhoto u=new UploadPhoto();
      u.parse(in);
      uploadPhoto=u;
      Log.d(TAG,myId + ""String_Node_Str"");
    }
 else     if (partName.equals(""String_Node_Str"")) {
      EyefiIntegrityDigest checksum=new EyefiIntegrityDigest();
      CheckedInputStream c=new CheckedInputStream(in,checksum);
      TarInputStream tarball=new TarInputStream(c);
      TarEntry file=tarball.getNextEntry();
      while (file != null) {
        fileName=file.getName();
        Log.d(TAG,myId + ""String_Node_Str"" + fileName+ ""String_Node_Str""+ file.getSize()+ ""String_Node_Str"");
        if (fileName.endsWith(""String_Node_Str"")) {
          File destination=openWritableFile(id,""String_Node_Str"");
          copyToLocalFile(tarball,destination);
          written.add(destination);
        }
 else {
          if (uploadPhoto == null) {
            Log.d(TAG,myId + ""String_Node_Str"");
            break;
          }
          fileSignature=uploadPhoto.getParameter(EyefiMessage.FILESIGNATURE);
          imageName=fileName;
          try {
            try {
              id=db.imageUploadable(fileSignature);
            }
 catch (            DBAdapter.UnknownUpload e) {
              fileSignature=fileSignature + ""String_Node_Str"" + fileName;
              Log.d(TAG,myId + ""String_Node_Str"" + fileSignature);
              db.registerNewImage(fileSignature);
              id=db.imageUploadable(fileSignature);
            }
            Log.d(TAG,myId + ""String_Node_Str"" + fileName+ ""String_Node_Str""+ fileSignature+ ""String_Node_Str""+ id);
            destinationPath=openWritableFile(id,""String_Node_Str"");
            Log.d(TAG,myId + ""String_Node_Str"" + imageName+ ""String_Node_Str""+ destinationPath);
            copyToLocalFile(tarball,destinationPath);
            written.add(destinationPath);
            success=true;
          }
 catch (          IOException e) {
            Log.e(TAG,myId + ""String_Node_Str"" + e);
          }
catch (          DBAdapter.DuplicateUpload e) {
            Log.e(TAG,myId + ""String_Node_Str"");
            success=true;
          }
catch (          DBAdapter.UnknownUpload e) {
            Log.e(TAG,myId + ""String_Node_Str"" + uploadPhoto);
          }
        }
        Log.d(TAG,myId + ""String_Node_Str"");
        file=tarball.getNextEntry();
      }
      c.skip(4096);
      UploadKey uploadKey=getKeyForMac(uploadPhoto.getMacAddress());
      calculatedDigest=checksum.getValue(uploadKey).toString();
      Log.d(TAG,myId + ""String_Node_Str"" + calculatedDigest);
    }
 else     if (partName.equals(""String_Node_Str"")) {
      BufferedReader r=new BufferedReader(new InputStreamReader(in));
      readDigest=r.readLine();
      Log.d(TAG,myId + ""String_Node_Str"" + readDigest);
    }
    in.close();
    headers=in.getHeaders();
  }
  if (calculatedDigest == null) {
    Log.d(TAG,myId + ""String_Node_Str"");
    success=false;
  }
  if (readDigest == null) {
    Log.d(TAG,myId + ""String_Node_Str"");
    success=false;
  }
  if (success && !readDigest.equals(calculatedDigest)) {
    Log.d(TAG,myId + ""String_Node_Str"");
    success=false;
  }
  if (success && destinationPath != null) {
    Uri uri=importPhoto(destinationPath,fileName,id);
    db.receiveImage(id,imageName,destinationPath.toString());
    db.finishImage(id,uri);
  }
  if (!success)   for (  File f : written)   f.delete();
  UploadPhotoResponse response=new UploadPhotoResponse(success);
  sendResponseHeader(response);
  sendResponseEntity(response);
}",0.985291447248956
3070,"public void getPhotoStatus(HttpRequest request) throws HttpException, IOException {
  Log.d(TAG,myId + ""String_Node_Str"");
  if (!(request instanceof HttpEntityEnclosingRequest))   throw new RuntimeException();
  HttpEntityEnclosingRequest eyefiRequest=(HttpEntityEnclosingRequest)request;
  receiveRequestEntity(eyefiRequest);
  GetPhotoStatus photoStatus=new GetPhotoStatus();
  photoStatus.parse(eyefiRequest.getEntity().getContent());
  MacAddress mac=photoStatus.getMacAddress();
  UploadKey uploadKey=getKeyForMac(mac);
  if (uploadKey != null)   photoStatus.authenticate(uploadKey,serverNonce);
 else {
    uploadKey=context.registerUnknownMac(mac);
    if (uploadKey != null) {
      photoStatus.authenticate(uploadKey,serverNonce);
      long id=db.addNewKeyWithMac(mac,uploadKey);
      Log.d(TAG,myId + ""String_Node_Str"" + mac+ ""String_Node_Str""+ id);
      context.registerNewCard(mac,uploadKey,id);
    }
 else {
      close();
      return;
    }
  }
  int offset=0;
  String filesignature=photoStatus.getParameter(""String_Node_Str"");
  long id=db.imageExists(filesignature);
  if (id != -1) {
    Log.i(TAG,myId + ""String_Node_Str"" + filesignature+ ""String_Node_Str"");
    offset=0;
  }
 else {
    Log.i(TAG,myId + ""String_Node_Str"" + filesignature);
    db.registerNewImage(filesignature);
  }
  GetPhotoStatusResponse gpsr=new GetPhotoStatusResponse(photoStatus,1,offset);
  sendResponseHeader(gpsr);
  sendResponseEntity(gpsr);
}","public void getPhotoStatus(HttpRequest request) throws HttpException, IOException {
  Log.d(TAG,myId + ""String_Node_Str"");
  if (!(request instanceof HttpEntityEnclosingRequest))   throw new RuntimeException();
  HttpEntityEnclosingRequest eyefiRequest=(HttpEntityEnclosingRequest)request;
  receiveRequestEntity(eyefiRequest);
  GetPhotoStatus photoStatus=new GetPhotoStatus();
  photoStatus.parse(eyefiRequest.getEntity().getContent());
  MacAddress mac=photoStatus.getMacAddress();
  UploadKey uploadKey=getKeyForMac(mac);
  if (uploadKey != null)   photoStatus.authenticate(uploadKey,serverNonce);
 else {
    uploadKey=context.registerUnknownMac(mac);
    if (uploadKey != null) {
      photoStatus.authenticate(uploadKey,serverNonce);
      long id=db.addNewKeyWithMac(mac,uploadKey);
      Log.d(TAG,myId + ""String_Node_Str"" + mac+ ""String_Node_Str""+ id);
      context.registerNewCard(mac,uploadKey,id);
    }
 else {
      close();
      return;
    }
  }
  int offset=0;
  String filesignature=photoStatus.getParameter(""String_Node_Str"");
  long id=db.imageExists(filesignature);
  if (id != -1) {
    Log.i(TAG,myId + ""String_Node_Str"" + filesignature+ ""String_Node_Str"");
  }
 else {
    Log.i(TAG,myId + ""String_Node_Str"" + filesignature);
    db.registerNewImage(filesignature);
  }
  GetPhotoStatusResponse gpsr=new GetPhotoStatusResponse(photoStatus,1,offset);
  sendResponseHeader(gpsr);
  sendResponseEntity(gpsr);
}",0.9951422623178348
3071,"protected int readChunk(int requested) throws IOException {
  if (isEof)   return -1;
  if (requested > maxRead)   requested=maxRead;
  in.mark(requested);
  int read=in.read(buf,0,requested);
  if (read == -1) {
    isEof=true;
    return -1;
  }
  if (read >= boundaryLength) {
    int boundaryPosition=match.indexOf(buf,0,read);
    if (boundaryPosition >= 0) {
      in.reset();
      read=in.read(buf,0,boundaryPosition + boundaryLength);
      isEof=true;
      return boundaryPosition > 0 ? boundaryPosition : -1;
    }
  }
  in.mark(boundaryLength);
  int additionalRead=in.read(buf,read,boundaryLength - 1);
  if (additionalRead == -1) {
    isEof=true;
    return read;
  }
  if ((read + additionalRead) < boundaryLength) {
    in.reset();
    return read;
  }
  int additionalStart=read - boundaryLength + 1;
  if (additionalStart < 0)   additionalStart=0;
  int boundaryPosition=match.indexOf(buf,additionalStart,read + additionalRead - additionalStart);
  if (boundaryPosition >= 0) {
    in.reset();
    read=in.read(buf,read,boundaryPosition + boundaryLength - read);
    isEof=true;
    return boundaryPosition > 0 ? boundaryPosition : -1;
  }
  in.reset();
  return read;
}","protected int readChunk(int requested) throws IOException {
  if (isEof)   return -1;
  if (requested > maxRead)   requested=maxRead;
  in.mark(requested);
  int read=in.read(buf,0,requested);
  if (read == -1) {
    isEof=true;
    return -1;
  }
  if (read >= boundaryLength) {
    int boundaryPosition=match.indexOf(buf,0,read);
    if (boundaryPosition >= 0) {
      in.reset();
      read=in.read(buf,0,boundaryPosition + boundaryLength);
      isEof=true;
      return boundaryPosition > 0 ? boundaryPosition : -1;
    }
  }
  in.mark(boundaryLength);
  int additionalRead=in.read(buf,read,boundaryLength - 1);
  if (additionalRead == -1) {
    isEof=true;
    return read;
  }
  if ((read + additionalRead) < boundaryLength) {
    in.reset();
    return read;
  }
  int additionalStart=read - boundaryLength + 1;
  if (additionalStart < 0)   additionalStart=0;
  int boundaryPosition=match.indexOf(buf,additionalStart,read + additionalRead);
  if (boundaryPosition >= 0) {
    in.reset();
    read=in.read(buf,read,boundaryPosition + boundaryLength - read);
    isEof=true;
    return boundaryPosition > 0 ? boundaryPosition : -1;
  }
  in.reset();
  return read;
}",0.9923793395427604
3072,"@Override public void onUpgrade(SQLiteDatabase db,int arg1,int arg2){
  Log.e(TAG,""String_Node_Str"" + arg1 + ""String_Node_Str""+ arg2);
  if ((arg1 <= 1) && (arg2 >= 2)) {
    Log.d(TAG,""String_Node_Str"");
    db.beginTransaction();
    Cursor c=db.query(UPLOADS,new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",null,null,null,null);
    int pathindex=c.getColumnIndex(""String_Node_Str"");
    int logindex=c.getColumnIndex(""String_Node_Str"");
    try {
      if (!c.moveToFirst())       return;
      do {
        String path=c.getString(pathindex);
        String log=c.getString(logindex);
        Log.d(TAG,""String_Node_Str"" + path + ""String_Node_Str""+ log.length()+ ""String_Node_Str"");
        if (!path.endsWith(""String_Node_Str""))         throw new RuntimeException(""String_Node_Str"" + path);
        String logpath=path.replace(""String_Node_Str"",""String_Node_Str"");
        File f=new File(logpath);
        if (f.exists()) {
          if (f.length() > log.length())           throw new RuntimeException(""String_Node_Str"" + path + ""String_Node_Str""+ f.length()+ ""String_Node_Str""+ log.length());
          if (f.length() == log.length()) {
            Log.d(TAG,""String_Node_Str"");
            continue;
          }
        }
        Log.d(TAG,""String_Node_Str"" + logpath);
        FileWriter out=new FileWriter(logpath,false);
        out.write(log);
        out.close();
      }
 while (c.moveToNext());
      c.close();
      Log.d(TAG,""String_Node_Str"");
      ContentValues cv=new ContentValues();
      cv.putNull(""String_Node_Str"");
      int updated=db.update(UPLOADS,cv,""String_Node_Str"",null);
      Log.d(TAG,""String_Node_Str"" + updated + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
 finally {
      if (!c.isClosed())       c.close();
      db.endTransaction();
      Log.d(TAG,""String_Node_Str"");
    }
  }
  if ((arg1 <= 2) && (arg2 >= 3)) {
    Log.d(TAG,""String_Node_Str"");
    scheduleBackup();
  }
  Log.d(TAG,""String_Node_Str"");
}","@Override public void onUpgrade(SQLiteDatabase db,int currentVersion,int requestedVersion){
  Log.e(TAG,""String_Node_Str"" + currentVersion + ""String_Node_Str""+ requestedVersion);
  if ((currentVersion <= 1) && (requestedVersion >= 2)) {
    Log.d(TAG,""String_Node_Str"");
    db.beginTransaction();
    Cursor c=db.query(UPLOADS,new String[]{""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",null,null,null,null);
    int pathindex=c.getColumnIndex(""String_Node_Str"");
    int logindex=c.getColumnIndex(""String_Node_Str"");
    try {
      if (c.moveToFirst())       do {
        String path=c.getString(pathindex);
        String log=c.getString(logindex);
        Log.d(TAG,""String_Node_Str"" + path + ""String_Node_Str""+ log.length()+ ""String_Node_Str"");
        if (!path.endsWith(""String_Node_Str""))         throw new RuntimeException(""String_Node_Str"" + path);
        String logpath=path.replace(""String_Node_Str"",""String_Node_Str"");
        File f=new File(logpath);
        if (f.exists()) {
          if (f.length() > log.length())           throw new RuntimeException(""String_Node_Str"" + path + ""String_Node_Str""+ f.length()+ ""String_Node_Str""+ log.length());
          if (f.length() == log.length()) {
            Log.d(TAG,""String_Node_Str"");
            continue;
          }
        }
        Log.d(TAG,""String_Node_Str"" + logpath);
        FileWriter out=new FileWriter(logpath,false);
        out.write(log);
        out.close();
      }
 while (c.moveToNext());
      c.close();
      Log.d(TAG,""String_Node_Str"");
      ContentValues cv=new ContentValues();
      cv.putNull(""String_Node_Str"");
      int updated=db.update(UPLOADS,cv,""String_Node_Str"",null);
      Log.d(TAG,""String_Node_Str"" + updated + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
 catch (    IOException e) {
      Log.d(TAG,""String_Node_Str"" + e);
      throw new RuntimeException(e);
    }
 finally {
      if (!c.isClosed())       c.close();
      db.endTransaction();
      Log.d(TAG,""String_Node_Str"");
    }
  }
  if ((currentVersion <= 2) && (requestedVersion >= 3)) {
    Log.d(TAG,""String_Node_Str"");
    scheduleBackup();
  }
  for (int i=currentVersion; i < requestedVersion; i++) {
    if (sqlSetup[i] == null)     continue;
    Log.d(TAG,""String_Node_Str"" + sqlSetup[i]);
    db.execSQL(sqlSetup[i]);
  }
  Log.d(TAG,""String_Node_Str"");
}",0.8329943502824859
3073,"protected DBAdapter(Context c){
  super(c,""String_Node_Str"",null,3);
  context=c;
}","protected DBAdapter(Context c){
  super(c,""String_Node_Str"",null,sqlSetup.length);
  context=c;
}",0.9111111111111112
3074,"/** 
 * A contact has accepted our subscription request
 */
@Override public void contactAcceptedReceived(SessionFriendAcceptedEvent event){
  final Set<String> groups=new HashSet<String>();
  groups.add(event.getGroupName());
  final YahooUser user=new YahooUser(event.getFrom(),YahooSession.DEFAULT_GROUPNAME);
  final YahooBuddy buddy=new YahooBuddy(getSession().getBuddyManager(),user,null,groups,null);
  getSession().getBuddyManager().storeBuddy(buddy);
  final Presence p=new Presence(Presence.Type.subscribed);
  p.setTo(getSession().getJID());
  p.setFrom(getSession().getTransport().convertIDToJID(event.getFrom()));
  getSession().getTransport().sendPacket(p);
}","/** 
 * A contact has accepted our subscription request
 */
@Override public void contactAcceptedReceived(SessionFriendAcceptedEvent event){
  final Set<String> groups=new HashSet<String>();
  groups.add(event.getGroupName());
  final YahooUser user=new YahooUser(event.getFrom());
  final YahooBuddy buddy=new YahooBuddy(getSession().getBuddyManager(),user,null,groups,null);
  getSession().getBuddyManager().storeBuddy(buddy);
  final Presence p=new Presence(Presence.Type.subscribed);
  p.setTo(getSession().getJID());
  p.setFrom(getSession().getTransport().convertIDToJID(event.getFrom()));
  getSession().getTransport().sendPacket(p);
}",0.976425855513308
3075,"/** 
 * @see net.sf.kraken.session.TransportSession#acceptAddContact(JID)
 */
@Override public void acceptAddContact(JID jid){
  final String userID=getTransport().convertJIDToID(jid);
  Log.debug(""String_Node_Str"" + userID);
  try {
    yahooSession.acceptFriendAuthorization(userID);
  }
 catch (  IOException e) {
    Log.debug(""String_Node_Str"");
  }
}","/** 
 * @see net.sf.kraken.session.TransportSession#acceptAddContact(JID)
 */
@Override public void acceptAddContact(JID jid){
  final String userID=getTransport().convertJIDToID(jid);
  Log.debug(""String_Node_Str"" + userID);
  try {
    yahooSession.acceptFriendAuthorization(userID,YahooProtocol.YAHOO);
  }
 catch (  IOException e) {
    Log.debug(""String_Node_Str"");
  }
}",0.9726775956284152
3076,"/** 
 * Sets up a presence packet according to a presenceType setting.
 * @param packet packet to set up.
 * @param presenceType presence type to set up.
 */
public void setUpPresencePacket(Presence packet,PresenceType presenceType){
  if (presenceType.equals(PresenceType.away)) {
    packet.setShow(Presence.Show.away);
  }
 else   if (presenceType.equals(PresenceType.xa)) {
    packet.setShow(Presence.Show.xa);
  }
 else   if (presenceType.equals(PresenceType.dnd)) {
    packet.setShow(Presence.Show.dnd);
  }
 else   if (presenceType.equals(PresenceType.chat)) {
    packet.setShow(Presence.Show.chat);
  }
 else   if (presenceType.equals(PresenceType.unavailable)) {
    packet.setType(Presence.Type.unavailable);
  }
}","/** 
 * Sets up a presence packet according to a presenceType setting.
 * @param packet packet to set up.
 * @param presenceType presence type to set up.
 */
public void setUpPresencePacket(Presence packet,PresenceType presenceType){
  if (presenceType.equals(PresenceType.away)) {
    packet.setShow(Presence.Show.away);
  }
 else   if (presenceType.equals(PresenceType.xa)) {
    packet.setShow(Presence.Show.xa);
  }
 else   if (presenceType.equals(PresenceType.dnd)) {
    packet.setShow(Presence.Show.dnd);
  }
 else   if (presenceType.equals(PresenceType.chat)) {
    packet.setShow(Presence.Show.chat);
  }
 else   if (presenceType.equals(PresenceType.unavailable)) {
    packet.setType(Presence.Type.unavailable);
  }
 else   if (presenceType.equals(PresenceType.unknown)) {
    packet.setType(Presence.Type.unavailable);
  }
}",0.9308578745198464
3077,"public void presenceChanged(org.jivesoftware.smack.packet.Presence presence){
  if (getSession().getBuddyManager().isActivated()) {
    try {
      final XMPPBuddy xmppBuddy=(XMPPBuddy)getSession().getBuddyManager().getBuddy(getSession().getTransport().convertIDToJID(presence.getFrom()));
      xmppBuddy.setPresenceAndStatus(((XMPPTransport)getSession().getTransport()).convertXMPPStatusToGateway(presence.getType(),presence.getMode()),presence.getStatus());
      if (JiveGlobals.getBooleanProperty(""String_Node_Str"" + getSession().getTransport().getType() + ""String_Node_Str"",true)) {
        PacketExtension pe=presence.getExtension(""String_Node_Str"",NameSpace.VCARD_TEMP_X_UPDATE);
        if (pe != null) {
          DefaultPacketExtension dpe=(DefaultPacketExtension)pe;
          String hash=dpe.getValue(""String_Node_Str"");
          final String from=presence.getFrom();
          if (hash != null) {
            Avatar curAvatar=xmppBuddy.getAvatar();
            if (curAvatar == null || !curAvatar.getLegacyIdentifier().equals(hash)) {
              new Thread(){
                public void run(){
                  VCard vcard=new VCard();
                  try {
                    vcard.load(getSession().conn,from);
                    xmppBuddy.setAvatar(new Avatar(xmppBuddy.getJID(),from,vcard.getAvatar()));
                  }
 catch (                  XMPPException e) {
                    Log.debug(""String_Node_Str"",e);
                  }
catch (                  IllegalArgumentException e) {
                    Log.debug(""String_Node_Str"");
                  }
                }
              }
.start();
            }
          }
        }
      }
    }
 catch (    NotFoundException e) {
      Log.debug(""String_Node_Str"" + presence.getFrom());
    }
  }
 else {
    getSession().getBuddyManager().storePendingStatus(getSession().getTransport().convertIDToJID(presence.getFrom()),((XMPPTransport)getSession().getTransport()).convertXMPPStatusToGateway(presence.getType(),presence.getMode()),presence.getStatus());
  }
}","public void presenceChanged(org.jivesoftware.smack.packet.Presence presence){
  if (getSession().getBuddyManager().isActivated()) {
    try {
      final XMPPBuddy xmppBuddy=(XMPPBuddy)getSession().getBuddyManager().getBuddy(getSession().getTransport().convertIDToJID(presence.getFrom()));
      Log.debug(""String_Node_Str"" + presence.getType() + ""String_Node_Str""+ presence.getMode()+ ""String_Node_Str""+ presence.getFrom());
      xmppBuddy.setPresenceAndStatus(((XMPPTransport)getSession().getTransport()).convertXMPPStatusToGateway(presence.getType(),presence.getMode()),presence.getStatus());
      if (JiveGlobals.getBooleanProperty(""String_Node_Str"" + getSession().getTransport().getType() + ""String_Node_Str"",true)) {
        PacketExtension pe=presence.getExtension(""String_Node_Str"",NameSpace.VCARD_TEMP_X_UPDATE);
        if (pe != null) {
          DefaultPacketExtension dpe=(DefaultPacketExtension)pe;
          String hash=dpe.getValue(""String_Node_Str"");
          final String from=presence.getFrom();
          if (hash != null) {
            Avatar curAvatar=xmppBuddy.getAvatar();
            if (curAvatar == null || !curAvatar.getLegacyIdentifier().equals(hash)) {
              new Thread(){
                public void run(){
                  VCard vcard=new VCard();
                  try {
                    vcard.load(getSession().conn,from);
                    xmppBuddy.setAvatar(new Avatar(xmppBuddy.getJID(),from,vcard.getAvatar()));
                  }
 catch (                  XMPPException e) {
                    Log.debug(""String_Node_Str"",e);
                  }
catch (                  IllegalArgumentException e) {
                    Log.debug(""String_Node_Str"");
                  }
                }
              }
.start();
            }
          }
        }
      }
    }
 catch (    NotFoundException e) {
      Log.debug(""String_Node_Str"" + presence.getFrom());
    }
  }
 else {
    getSession().getBuddyManager().storePendingStatus(getSession().getTransport().convertIDToJID(presence.getFrom()),((XMPPTransport)getSession().getTransport()).convertXMPPStatusToGateway(presence.getType(),presence.getMode()),presence.getStatus());
  }
}",0.9679547596606974
3078,"/** 
 * Converts an XMPP/Smack status to a Gateway status.
 * @param type Smack presence type.
 * @param mode Smack presence mode (show).
 * @return Gateway status.
 */
public PresenceType convertXMPPStatusToGateway(org.jivesoftware.smack.packet.Presence.Type type,org.jivesoftware.smack.packet.Presence.Mode mode){
  if (mode == Presence.Mode.away) {
    return PresenceType.away;
  }
 else   if (mode == Presence.Mode.dnd) {
    return PresenceType.dnd;
  }
 else   if (mode == Presence.Mode.xa) {
    return PresenceType.xa;
  }
 else   if (mode == Presence.Mode.chat) {
    return PresenceType.chat;
  }
 else   if (type == Presence.Type.unavailable) {
    return PresenceType.unavailable;
  }
 else {
    return PresenceType.available;
  }
}","/** 
 * Converts an XMPP/Smack status to a Gateway status.
 * @param type Smack presence type.
 * @param mode Smack presence mode (show).
 * @return Gateway status.
 */
public PresenceType convertXMPPStatusToGateway(org.jivesoftware.smack.packet.Presence.Type type,org.jivesoftware.smack.packet.Presence.Mode mode){
  if (mode == Presence.Mode.away) {
    return PresenceType.away;
  }
 else   if (mode == Presence.Mode.dnd) {
    return PresenceType.dnd;
  }
 else   if (mode == Presence.Mode.xa) {
    return PresenceType.xa;
  }
 else   if (mode == Presence.Mode.chat) {
    return PresenceType.chat;
  }
 else   if (type == Presence.Type.unavailable) {
    return PresenceType.unavailable;
  }
 else   if (type == Presence.Type.error) {
    return PresenceType.unavailable;
  }
 else {
    return PresenceType.available;
  }
}",0.9467005076142132
3079,"public void start(){
  super.start();
  mucTransport=new IRCMUCTransport(this);
  try {
    componentManager.addComponent(""String_Node_Str"",mucTransport);
  }
 catch (  Exception e) {
    componentManager.getLog().error(e);
  }
}","public void start(){
  super.start();
  mucTransport=new IRCMUCTransport(this);
  try {
    componentManager.addComponent(""String_Node_Str"",mucTransport);
  }
 catch (  Exception e) {
    Log.error(""String_Node_Str"",e);
  }
}",0.8722466960352423
3080,"public void shutdown(){
  mucTransport.shutdown();
  try {
    componentManager.removeComponent(""String_Node_Str"");
  }
 catch (  Exception e) {
    componentManager.getLog().error(e);
  }
  super.shutdown();
}","public void shutdown(){
  mucTransport.shutdown();
  try {
    componentManager.removeComponent(""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.error(""String_Node_Str"",e);
  }
  super.shutdown();
}",0.8701923076923077
3081,"/** 
 * Stops the transport instance if it's running.
 */
public void stopInstance(){
  if (!running) {
    return;
  }
  Log.info(""String_Node_Str"" + type.toString());
  transport.shutdown();
  PropertyEventDispatcher.removeListener(this);
  try {
    componentManager.removeComponent(this.subDomain);
  }
 catch (  Exception e) {
    componentManager.getLog().error(e);
  }
  transport=null;
  running=false;
}","/** 
 * Stops the transport instance if it's running.
 */
public void stopInstance(){
  if (!running) {
    return;
  }
  Log.info(""String_Node_Str"" + type.toString());
  transport.shutdown();
  PropertyEventDispatcher.removeListener(this);
  try {
    componentManager.removeComponent(this.subDomain);
  }
 catch (  Exception e) {
    Log.error(""String_Node_Str"" + this.subDomain + ""String_Node_Str"",e);
  }
  transport=null;
  running=false;
}",0.8938156359393232
3082,"/** 
 * Starts the transport instance if it's enabled and not already running.
 */
public void startInstance(){
  if (!enabled || running) {
    return;
  }
  Log.info(""String_Node_Str"" + type.toString());
  transport=null;
  try {
    transport=(BaseTransport)Class.forName(nameOfClass).newInstance();
    transport.setup(this.type,this.description,sessionRouter);
  }
 catch (  ClassNotFoundException e) {
    Log.error(""String_Node_Str"" + nameOfClass);
    return;
  }
catch (  InstantiationException e) {
    Log.error(""String_Node_Str"" + nameOfClass);
    return;
  }
catch (  IllegalAccessException e) {
    Log.error(""String_Node_Str"" + nameOfClass);
    return;
  }
  SessionManager sessionManager=SessionManager.getInstance();
  String fullJID=this.subDomain + ""String_Node_Str"" + XMPPServer.getInstance().getServerInfo().getXMPPDomain();
  Boolean pause=false;
  try {
    for (    Session sess : sessionManager.getIncomingServerSessions(fullJID)) {
      sess.close();
      pause=true;
    }
  }
 catch (  Exception ignored) {
  }
  try {
    Session sess=sessionManager.getOutgoingServerSession(fullJID);
    if (sess != null) {
      sess.close();
      pause=true;
    }
  }
 catch (  Exception ignored) {
  }
  try {
    if (pause) {
      Thread.sleep(1000L);
    }
  }
 catch (  Exception ignored) {
  }
  try {
    componentManager.addComponent(this.subDomain,transport);
    PropertyEventDispatcher.addListener(this);
    running=true;
  }
 catch (  Exception e) {
    componentManager.getLog().error(e);
  }
}","/** 
 * Starts the transport instance if it's enabled and not already running.
 */
public void startInstance(){
  if (!enabled || running) {
    return;
  }
  Log.info(""String_Node_Str"" + type.toString());
  transport=null;
  try {
    transport=(BaseTransport)Class.forName(nameOfClass).newInstance();
    transport.setup(this.type,this.description,sessionRouter);
  }
 catch (  ClassNotFoundException e) {
    Log.error(""String_Node_Str"" + nameOfClass);
    return;
  }
catch (  InstantiationException e) {
    Log.error(""String_Node_Str"" + nameOfClass);
    return;
  }
catch (  IllegalAccessException e) {
    Log.error(""String_Node_Str"" + nameOfClass);
    return;
  }
  SessionManager sessionManager=SessionManager.getInstance();
  String fullJID=this.subDomain + ""String_Node_Str"" + XMPPServer.getInstance().getServerInfo().getXMPPDomain();
  Boolean pause=false;
  try {
    for (    Session sess : sessionManager.getIncomingServerSessions(fullJID)) {
      sess.close();
      pause=true;
    }
  }
 catch (  Exception ignored) {
  }
  try {
    Session sess=sessionManager.getOutgoingServerSession(fullJID);
    if (sess != null) {
      sess.close();
      pause=true;
    }
  }
 catch (  Exception ignored) {
  }
  try {
    if (pause) {
      Thread.sleep(1000L);
    }
  }
 catch (  Exception ignored) {
  }
  try {
    componentManager.addComponent(this.subDomain,transport);
    PropertyEventDispatcher.addListener(this);
    running=true;
  }
 catch (  Exception e) {
    Log.error(""String_Node_Str"" + this.subDomain + ""String_Node_Str"",e);
  }
}",0.9641125121241512
3083,"private void init(){
  setLayout(new BorderLayout(0,5));
  setBorder(makeBorder());
  add(makeTitlePanel(),BorderLayout.NORTH);
  VerticalPanel mainPanel=new VerticalPanel();
  mainPanel.add(createJPOSPanel());
  tcpDefaultPanel=new TCPConfigGui(false);
  JPanel mainpanel2=(JPanel)tcpDefaultPanel.getComponent(tcpDefaultPanel.getComponentCount() - 1);
  Box box=(Box)mainpanel2.getComponent(mainpanel2.getComponentCount() - 1);
  JPanel reqDataPanel=(JPanel)box.getComponent(10);
  reqDataPanel.setVisible(false);
  mainPanel.add(tcpDefaultPanel);
  add(mainPanel,BorderLayout.CENTER);
}","private void init(){
  setLayout(new BorderLayout(0,5));
  setBorder(makeBorder());
  add(makeTitlePanel(),BorderLayout.NORTH);
  VerticalPanel mainPanel=new VerticalPanel();
  mainPanel.add(createJPOSPanel());
  tcpDefaultPanel=new TCPConfigGui(false);
  add(mainPanel,BorderLayout.CENTER);
}",0.6651532349602725
3084,"/** 
 * Respond to ""Start"" button by requesting activity recognition updates.
 * @param view The view that triggered this method.
 */
public void onStartUpdates(View view){
  if (!servicesConnected()) {
    return;
  }
  mRunning=false;
  mRequestType=ActivityUtils.REQUEST_TYPE.ADD;
  mActivityDetectionRequester.requestUpdates(getIntervalMillis());
  ((TextView)view).setText(R.string.stop_updates);
}","/** 
 * Respond to ""Start"" button by requesting activity recognition updates.
 * @param view The view that triggered this method.
 */
public void onStartUpdates(View view){
  if (!servicesConnected()) {
    return;
  }
  mRunning=true;
  mRequestType=ActivityUtils.REQUEST_TYPE.ADD;
  mActivityDetectionRequester.requestUpdates(getIntervalMillis());
  ((TextView)view).setText(R.string.stop_updates);
}",0.991304347826087
3085,"/** 
 * Respond to ""Stop"" button by canceling updates.
 * @param view The view that triggered this method.
 */
public void onStopUpdates(View view){
  if (!servicesConnected()) {
    return;
  }
  mRunning=true;
  mRequestType=ActivityUtils.REQUEST_TYPE.REMOVE;
  mActivityDetectionRemover.removeUpdates(mActivityDetectionRequester.getRequestPendingIntent());
  mActivityDetectionRequester.getRequestPendingIntent().cancel();
  ((TextView)view).setText(R.string.start_updates);
}","/** 
 * Respond to ""Stop"" button by canceling updates.
 * @param view The view that triggered this method.
 */
public void onStopUpdates(View view){
  if (!servicesConnected()) {
    return;
  }
  mRunning=false;
  mRequestType=ActivityUtils.REQUEST_TYPE.REMOVE;
  mActivityDetectionRemover.removeUpdates(mActivityDetectionRequester.getRequestPendingIntent());
  mActivityDetectionRequester.getRequestPendingIntent().cancel();
  ((TextView)view).setText(R.string.start_updates);
}",0.9927007299270072
3086,"@Override public void onCreate(){
  super.onCreate();
  self=this;
  LogProbe.setLevel(true,Loglevel.VERBOSE);
  LogProbe.get(this);
  probeWriter=new MobilityProbeWriter(this);
  probeWriter.connect();
  SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
  if (settings.getBoolean(MobilityControl.MOBILITY_ON,false)) {
    Mobility.start(this);
  }
  if (settings.getBoolean(""String_Node_Str"",true)) {
    settings.edit().putBoolean(""String_Node_Str"",true).commit();
    aggregateRead();
  }
}","@Override public void onCreate(){
  super.onCreate();
  self=this;
  ensureLogProbe(this);
  probeWriter=new MobilityProbeWriter(this);
  probeWriter.connect();
  SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
  if (settings.getBoolean(MobilityControl.MOBILITY_ON,false)) {
    Mobility.start(this);
  }
  if (settings.getBoolean(""String_Node_Str"",true)) {
    settings.edit().putBoolean(""String_Node_Str"",true).commit();
    aggregateRead();
  }
}",0.9471624266144814
3087,"@Override public boolean onCreate(){
  dbHelper=new DatabaseHelper(getContext());
  return true;
}","@Override public boolean onCreate(){
  dbHelper=new DatabaseHelper(getContext());
  MobilityApplication.ensureLogProbe(getContext());
  return true;
}",0.7903225806451613
3088,"/** 
 * Connects to the database, gets the information requested based on the parameters, closes the connection to the database, and returns the Cursor object that the query generated.
 * @param columns A String array representing the columns that are being requested.
 * @param selection A SQLite WHERE clause without the ""WHERE"" keyword.
 * @param selectionArgs A String array used for replacing ""?""s in the 'selection' String with values. The number of items in the array should be equal to the number of ""?""s in the 'selection' String. 'null' is an acceptable value if there are no ""?""s in the 'selection' String.
 * @param orderBy A SQLite ""ORDER BY"" clause without the ""ORDER BY"" keyword.
 * @return A Cursor object pointing to all the elements that satisfy the theparameters. If a SQLite exception occurs, null is returned.
 */
public synchronized Cursor getMobilityCursor(String[] columns,String selection,String[] selectionArgs,String orderBy){
  Cursor c;
  try {
    c=getReadableDatabase().query(""String_Node_Str"",columns,selection,selectionArgs,null,null,orderBy);
    c.setNotificationUri(mContext.getContentResolver(),MobilityInterface.CONTENT_URI);
  }
 catch (  SQLiteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    c=null;
  }
  return c;
}","/** 
 * Connects to the database, gets the information requested based on the parameters, closes the connection to the database, and returns the Cursor object that the query generated.
 * @param columns A String array representing the columns that are being requested.
 * @param selection A SQLite WHERE clause without the ""WHERE"" keyword.
 * @param selectionArgs A String array used for replacing ""?""s in the 'selection' String with values. The number of items in the array should be equal to the number of ""?""s in the 'selection' String. 'null' is an acceptable value if there are no ""?""s in the 'selection' String.
 * @param orderBy A SQLite ""ORDER BY"" clause without the ""ORDER BY"" keyword.
 * @return A Cursor object pointing to all the elements that satisfy the theparameters. If a SQLite exception occurs, null is returned.
 */
public Cursor getMobilityCursor(String[] columns,String selection,String[] selectionArgs,String orderBy){
  Cursor c;
  try {
    c=getReadableDatabase().query(""String_Node_Str"",columns,selection,selectionArgs,null,null,orderBy);
    c.setNotificationUri(mContext.getContentResolver(),MobilityInterface.CONTENT_URI);
  }
 catch (  SQLiteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    c=null;
  }
  return c;
}",0.9948351211760031
3089,"private void writeWifi(SharedPreferences settings,long time,String mode,Vector<String> APs,HashMap<Long,Vector<String>> lastAPs){
  String store=time + ""String_Node_Str"" + mode+ ""String_Node_Str""+ time+ ""String_Node_Str"";
  for (  String s : APs)   store+=s + ""String_Node_Str"";
  if (APs.size() > 0) {
    if (!store.endsWith(""String_Node_Str""))     Log.e(TAG,""String_Node_Str"" + store + ""String_Node_Str""+ APs.size());
 else     store=store.substring(0,store.length() - 1);
  }
  long now=System.currentTimeMillis();
  if (lastAPs != null) {
    for (    Long ts : lastAPs.keySet()) {
      if (ts > now - checkLength) {
        store+=""String_Node_Str"" + ts + ""String_Node_Str"";
        for (        String ap : lastAPs.get(ts))         store+=ap + ""String_Node_Str"";
      }
      if (!store.endsWith(""String_Node_Str""))       Log.e(TAG,""String_Node_Str"" + store + ""String_Node_Str""+ APs.size());
 else       store=store.substring(0,store.length() - 1);
    }
  }
  Editor editor=settings.edit();
  editor.putString(WIFI_HISTORY,store);
  editor.commit();
}","private void writeWifi(SharedPreferences settings,long time,String mode,Vector<String> APs,HashMap<Long,Vector<String>> lastAPs){
  StringBuilder store=new StringBuilder(time + ""String_Node_Str"" + mode+ ""String_Node_Str""+ time);
  for (  String s : APs)   store.append(""String_Node_Str"").append(s);
  long now=System.currentTimeMillis();
  if (lastAPs != null) {
    for (    Long ts : lastAPs.keySet()) {
      if (ts > now - checkLength) {
        store.append(""String_Node_Str"").append(ts);
        for (        String ap : lastAPs.get(ts))         store.append(""String_Node_Str"").append(ap);
      }
    }
  }
  Editor editor=settings.edit();
  editor.putString(WIFI_HISTORY,store.toString());
  editor.commit();
}",0.6992692523889825
3090,"@SuppressWarnings(""String_Node_Str"") private Vector<ArrayList<Double>> getAccSamples(){
  try {
    if (Mobility.getmAccel() == null || System.currentTimeMillis() - Mobility.getmAccel().getLastTimeStamp() > 10000 + Mobility.sampleRate) {
      Log.v(TAG,""String_Node_Str"");
      if (Mobility.failCount++ > 2) {
        if (Mobility.getmAccel() == null)         Mobility.setNotification(this,Mobility.STATUS_ERROR,""String_Node_Str"");
 else {
          Log.w(TAG,""String_Node_Str"" + (System.currentTimeMillis() - Mobility.getmAccel().getLastTimeStamp()) / 1000 + ""String_Node_Str"");
          Mobility.setNotification(this,Mobility.STATUS_ERROR,""String_Node_Str"");
        }
      }
 else       Mobility.setNotification(this,Mobility.STATUS_PENDING,""String_Node_Str"");
      return null;
    }
    Mobility.failCount=0;
    ArrayList<Double> force=new ArrayList<Double>();
    Log.i(TAG,(System.currentTimeMillis() - Mobility.getmAccel().getLastTimeStamp()) / 1000 + ""String_Node_Str"");
    Vector<ArrayList<Double>> curList=new Vector<ArrayList<Double>>();
    curList.add((ArrayList<Double>)Mobility.getmAccel().getLastXValues());
    curList.add((ArrayList<Double>)Mobility.getmAccel().getLastYValues());
    curList.add((ArrayList<Double>)Mobility.getmAccel().getLastZValues());
    curList.add((ArrayList<Double>)Mobility.getmAccel().getLastForce());
    if (curList.get(0) != null) {
      return curList;
    }
 else     Log.w(TAG,""String_Node_Str"");
  }
 catch (  RemoteException re) {
    Log.e(TAG,""String_Node_Str"",re);
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") private Vector<ArrayList<Double>> getAccSamples(){
  try {
    if (Mobility.getmAccel() == null || System.currentTimeMillis() - Mobility.getmAccel().getLastTimeStamp() > 10000 + Mobility.sampleRate) {
      Log.v(TAG,""String_Node_Str"");
      if (Mobility.failCount++ > 2) {
        if (Mobility.getmAccel() == null)         Mobility.setNotification(this,Mobility.STATUS_ERROR,""String_Node_Str"");
 else {
          Log.w(TAG,""String_Node_Str"" + (System.currentTimeMillis() - Mobility.getmAccel().getLastTimeStamp()) / 1000 + ""String_Node_Str"");
          Mobility.setNotification(this,Mobility.STATUS_ERROR,""String_Node_Str"");
        }
      }
 else       Mobility.setNotification(this,Mobility.STATUS_PENDING,""String_Node_Str"");
      return null;
    }
    Mobility.failCount=0;
    NotificationManager nm=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
    nm.cancel(Mobility.NOTIF_ERROR_ID);
    ArrayList<Double> force=new ArrayList<Double>();
    Log.i(TAG,(System.currentTimeMillis() - Mobility.getmAccel().getLastTimeStamp()) / 1000 + ""String_Node_Str"");
    Vector<ArrayList<Double>> curList=new Vector<ArrayList<Double>>();
    curList.add((ArrayList<Double>)Mobility.getmAccel().getLastXValues());
    curList.add((ArrayList<Double>)Mobility.getmAccel().getLastYValues());
    curList.add((ArrayList<Double>)Mobility.getmAccel().getLastZValues());
    curList.add((ArrayList<Double>)Mobility.getmAccel().getLastForce());
    if (curList.get(0) != null) {
      return curList;
    }
 else     Log.w(TAG,""String_Node_Str"");
  }
 catch (  RemoteException re) {
    Log.e(TAG,""String_Node_Str"",re);
  }
  return null;
}",0.957972805933251
3091,"public static void setDebugNotification(Context context,String message){
  NotificationManager nm=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  int icon=android.R.drawable.stat_notify_error;
  Notification notification=new Notification(icon,null,System.currentTimeMillis());
  PendingIntent pi=PendingIntent.getActivity(context.getApplicationContext(),1,new Intent(""String_Node_Str""),1);
  notification.setLatestEventInfo(context.getApplicationContext(),""String_Node_Str"",message,pi);
  nm.notify(124,notification);
}","public static void setDebugNotification(Context context,String message){
  NotificationManager nm=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  int icon=android.R.drawable.stat_notify_error;
  Notification notification=new Notification(icon,null,System.currentTimeMillis());
  PendingIntent pi=PendingIntent.getActivity(context.getApplicationContext(),1,new Intent(""String_Node_Str""),1);
  notification.setLatestEventInfo(context.getApplicationContext(),""String_Node_Str"",message,pi);
  nm.notify(NOTIF_ERROR_ID,notification);
}",0.9846984698469848
3092,"public long createRow(String mode,long time,String status,Float speed,long timestamp,Float accuracy,String provider,String wifiData,Vector<ArrayList<Double>> samples,Double latitude,Double longitude){
  ContentValues vals=new ContentValues();
  SharedPreferences settings=mCtx.getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
  String username=settings.getString(Mobility.KEY_USERNAME,DEFAULT_USERNAME);
  if (wifiData.equals(""String_Node_Str""))   wifiData=""String_Node_Str"";
  UUID id=UUID.randomUUID();
  String timezone=DateTimeZone.getDefault().getID();
  vals.put(KEY_ID,id.toString());
  Log.d(TAG,id.toString());
  vals.put(KEY_MODE,mode);
  vals.put(KEY_SPEED,speed);
  vals.put(KEY_STATUS,status);
  vals.put(KEY_LOC_TIMESTAMP,timestamp);
  vals.put(KEY_ACCURACY,accuracy);
  vals.put(KEY_PROVIDER,provider);
  vals.put(KEY_WIFIDATA,wifiData);
  vals.put(KEY_ACCELDATA,formatAccelData(samples));
  vals.put(KEY_TIME,time + ""String_Node_Str"");
  vals.put(KEY_TIMEZONE,timezone);
  vals.put(KEY_LATITUDE,latitude);
  vals.put(KEY_LONGITUDE,longitude);
  vals.put(KEY_USERNAME,username);
  Log.d(TAG,""String_Node_Str"" + MOBILITY_TABLE + ""String_Node_Str""+ mode);
  long rowid=-1;
  Uri row=mCtx.getContentResolver().insert(MobilityInterface.CONTENT_URI,vals);
  ProbeBuilder probe=new ProbeBuilder();
  probe.withId(id.toString()).withTime(time,timezone).withLocation(time,timezone,latitude,longitude,accuracy,provider);
  Mobility.probeWriter.write(probe,mode,speed,formatAccelData(samples),wifiData);
  if (row != null) {
    rowid=ContentUris.parseId(row);
    ContentResolver r=mCtx.getContentResolver();
    r.notifyChange(MobilityInterface.CONTENT_URI,null);
  }
  return rowid;
}","public long createRow(String mode,long time,String status,Float speed,long timestamp,Float accuracy,String provider,String wifiData,Vector<ArrayList<Double>> samples,Double latitude,Double longitude){
  ContentValues vals=new ContentValues();
  SharedPreferences settings=mCtx.getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
  String username=settings.getString(Mobility.KEY_USERNAME,DEFAULT_USERNAME);
  if (wifiData.equals(""String_Node_Str""))   wifiData=""String_Node_Str"";
  UUID id=UUID.randomUUID();
  String timezone=DateTimeZone.getDefault().getID();
  vals.put(KEY_ID,id.toString());
  Log.d(TAG,id.toString());
  vals.put(KEY_MODE,mode);
  vals.put(KEY_SPEED,speed);
  vals.put(KEY_STATUS,status);
  vals.put(KEY_LOC_TIMESTAMP,timestamp);
  vals.put(KEY_ACCURACY,accuracy);
  vals.put(KEY_PROVIDER,provider);
  vals.put(KEY_WIFIDATA,wifiData);
  vals.put(KEY_ACCELDATA,formatAccelData(samples));
  vals.put(KEY_TIME,time + ""String_Node_Str"");
  vals.put(KEY_TIMEZONE,timezone);
  vals.put(KEY_LATITUDE,latitude);
  vals.put(KEY_LONGITUDE,longitude);
  vals.put(KEY_USERNAME,username);
  Log.d(TAG,""String_Node_Str"" + MOBILITY_TABLE + ""String_Node_Str""+ mode);
  long rowid=-1;
  Uri row=mCtx.getContentResolver().insert(MobilityInterface.CONTENT_URI,vals);
  ProbeBuilder probe=new ProbeBuilder();
  probe.withId(id.toString()).withTime(time,timezone).withLocation(time,timezone,latitude,longitude,accuracy,provider);
  Mobility.writeProbe(mCtx,probe,mode,speed,formatAccelData(samples),wifiData);
  if (row != null) {
    rowid=ContentUris.parseId(row);
    ContentResolver r=mCtx.getContentResolver();
    r.notifyChange(MobilityInterface.CONTENT_URI,null);
  }
  return rowid;
}",0.9923708920187794
3093,"public static void start(Context context){
  Log.setAppName(""String_Node_Str"");
  context.bindService(new Intent(ISystemLog.class.getName()),Log.SystemLogConnection,Context.BIND_AUTO_CREATE);
  Log.register(TAG);
  TriggerDB db=new TriggerDB(context);
  db.open();
  boolean canRunNow=true;
  Cursor c=db.getAllTriggers();
  if (c.moveToFirst()) {
    do {
      int trigId=c.getInt(c.getColumnIndexOrThrow(TriggerDB.KEY_ID));
      String trigDesc=db.getTriggerDescription(trigId);
      BlackoutDesc conf=new BlackoutDesc();
      if (!conf.loadString(trigDesc)) {
        continue;
      }
      SimpleTime start=conf.getRangeStart();
      SimpleTime end=conf.getRangeEnd();
      SimpleTime now=new SimpleTime();
      Log.d(TAG,start.getHour() + ""String_Node_Str"" + start.getMinute()+ ""String_Node_Str""+ end.getHour()+ ""String_Node_Str""+ end.getMinute()+ ""String_Node_Str""+ now.getHour()+ now.getMinute());
      if (!start.isAfter(now) && end.isAfter(now)) {
        canRunNow=false;
      }
    }
 while (c.moveToNext());
  }
  c.close();
  db.close();
  TriggerInit.initTriggers(context);
  initialize(context);
  if (canRunNow) {
    Log.d(TAG,""String_Node_Str"");
    startMobility(context);
  }
  GarbageCollectReceiver.scheduleGC(context,mgr);
}","public static void start(Context context){
  initSystemLog(context);
  TriggerDB db=new TriggerDB(context);
  db.open();
  boolean canRunNow=true;
  Cursor c=db.getAllTriggers();
  if (c.moveToFirst()) {
    do {
      int trigId=c.getInt(c.getColumnIndexOrThrow(TriggerDB.KEY_ID));
      String trigDesc=db.getTriggerDescription(trigId);
      BlackoutDesc conf=new BlackoutDesc();
      if (!conf.loadString(trigDesc)) {
        continue;
      }
      SimpleTime start=conf.getRangeStart();
      SimpleTime end=conf.getRangeEnd();
      SimpleTime now=new SimpleTime();
      Log.d(TAG,start.getHour() + ""String_Node_Str"" + start.getMinute()+ ""String_Node_Str""+ end.getHour()+ ""String_Node_Str""+ end.getMinute()+ ""String_Node_Str""+ now.getHour()+ now.getMinute());
      if (!start.isAfter(now) && end.isAfter(now)) {
        canRunNow=false;
      }
    }
 while (c.moveToNext());
  }
  c.close();
  db.close();
  TriggerInit.initTriggers(context);
  initialize(context);
  if (canRunNow) {
    Log.d(TAG,""String_Node_Str"");
    startMobility(context);
  }
  GarbageCollectReceiver.scheduleGC(context,mgr);
}",0.929957805907173
3094,"@Override public IBinder onBind(Intent intent){
  return new IMobility.Stub(){
    public void stopMobility(){
      SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
      if (settings.getBoolean(MobilityControl.MOBILITY_ON,false)) {
        Editor editor=settings.edit();
        editor.putBoolean(MobilityControl.MOBILITY_ON,false);
        editor.commit();
        Log.e(TAG,""String_Node_Str"");
        Mobility.stop(getApplicationContext());
      }
 else {
        Log.e(TAG,""String_Node_Str"");
      }
    }
    public void startMobility(){
      Log.e(TAG,""String_Node_Str"");
      SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
      if (!settings.getBoolean(MobilityControl.MOBILITY_ON,false)) {
        Editor editor=settings.edit();
        editor.putBoolean(MobilityControl.MOBILITY_ON,true);
        editor.commit();
        Log.e(TAG,""String_Node_Str"");
        Mobility.start(getApplicationContext());
      }
 else {
        Log.e(TAG,""String_Node_Str"");
      }
      Log.e(TAG,""String_Node_Str"");
    }
    /** 
 * Set the rate in seconds to 300, 60, 30, or 15.
 * @param context
 * @param intervalInSeconds This must be 300, 60, 30, or 15.
 * @return true if successful, false otherwise
 */
    public boolean changeMobilityRate(    int intervalInSeconds){
      for (      int rate : new int[]{300,60,30,15})       if (intervalInSeconds == rate) {
        SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
        Editor editor=settings.edit();
        editor.putInt(Mobility.SAMPLE_RATE,intervalInSeconds);
        editor.commit();
        if (settings.getBoolean(MobilityControl.MOBILITY_ON,false)) {
          stopMobility();
          startMobility();
        }
        return true;
      }
      return false;
    }
    public boolean isMobilityOn(){
      SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
      return settings.getBoolean(MobilityControl.MOBILITY_ON,false);
    }
    public int getMobilityInterval(){
      SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
      return settings.getInt(Mobility.SAMPLE_RATE,60);
    }
  }
;
}","@Override public IBinder onBind(Intent intent){
  Mobility.initSystemLog(getApplicationContext());
  return new IMobility.Stub(){
    public void stopMobility(){
      SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
      if (settings.getBoolean(MobilityControl.MOBILITY_ON,false)) {
        Editor editor=settings.edit();
        editor.putBoolean(MobilityControl.MOBILITY_ON,false);
        editor.commit();
        Log.e(TAG,""String_Node_Str"");
        Mobility.stop(getApplicationContext());
      }
 else {
        Log.e(TAG,""String_Node_Str"");
      }
    }
    public void startMobility(){
      Log.e(TAG,""String_Node_Str"");
      SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
      if (!settings.getBoolean(MobilityControl.MOBILITY_ON,false)) {
        Editor editor=settings.edit();
        editor.putBoolean(MobilityControl.MOBILITY_ON,true);
        editor.commit();
        Log.e(TAG,""String_Node_Str"");
        Mobility.start(getApplicationContext());
      }
 else {
        Log.e(TAG,""String_Node_Str"");
      }
      Log.e(TAG,""String_Node_Str"");
    }
    /** 
 * Set the rate in seconds to 300, 60, 30, or 15.
 * @param context
 * @param intervalInSeconds This must be 300, 60, 30, or 15.
 * @return true if successful, false otherwise
 */
    public boolean changeMobilityRate(    int intervalInSeconds){
      for (      int rate : new int[]{300,60,30,15})       if (intervalInSeconds == rate) {
        SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
        Editor editor=settings.edit();
        editor.putInt(Mobility.SAMPLE_RATE,intervalInSeconds);
        editor.commit();
        if (settings.getBoolean(MobilityControl.MOBILITY_ON,false)) {
          stopMobility();
          startMobility();
        }
        return true;
      }
      return false;
    }
    public boolean isMobilityOn(){
      SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
      return settings.getBoolean(MobilityControl.MOBILITY_ON,false);
    }
    public int getMobilityInterval(){
      SharedPreferences settings=getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
      return settings.getInt(Mobility.SAMPLE_RATE,60);
    }
  }
;
}",0.9888816219751472
3095,"public long createRow(String mode,long time,String status,Float speed,long timestamp,Float accuracy,String provider,String wifiData,Vector<ArrayList<Double>> samples,Double latitude,Double longitude){
  ContentValues vals=new ContentValues();
  SharedPreferences settings=mCtx.getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
  String username=settings.getString(Mobility.KEY_USERNAME,DEFAULT_USERNAME);
  if (wifiData.equals(""String_Node_Str""))   wifiData=""String_Node_Str"";
  UUID id=UUID.randomUUID();
  String timezone=DateTimeZone.getDefault().getID();
  vals.put(KEY_ID,id.toString());
  Log.d(TAG,id.toString());
  vals.put(KEY_MODE,mode);
  vals.put(KEY_SPEED,speed);
  vals.put(KEY_STATUS,status);
  vals.put(KEY_LOC_TIMESTAMP,timestamp);
  vals.put(KEY_ACCURACY,accuracy);
  vals.put(KEY_PROVIDER,provider);
  vals.put(KEY_WIFIDATA,wifiData);
  vals.put(KEY_ACCELDATA,formatAccelData(samples));
  vals.put(KEY_TIME,time + ""String_Node_Str"");
  vals.put(KEY_TIMEZONE,timezone);
  vals.put(KEY_LATITUDE,latitude);
  vals.put(KEY_LONGITUDE,longitude);
  vals.put(KEY_USERNAME,username);
  Log.d(TAG,""String_Node_Str"" + MOBILITY_TABLE + ""String_Node_Str""+ mode);
  long rowid=-1;
  Uri row=mCtx.getContentResolver().insert(MobilityInterface.CONTENT_URI,vals);
  ProbeBuilder probe=new ProbeBuilder();
  probe.withId(id.toString()).withTime(time,timezone).withLocation(time,timezone,latitude,longitude,accuracy,provider);
  Mobility.writeProbe(mCtx,probe,mode,speed,formatAccelData(samples),wifiData);
  if (row != null) {
    rowid=ContentUris.parseId(row);
    ContentResolver r=mCtx.getContentResolver();
    r.notifyChange(MobilityInterface.CONTENT_URI,null);
  }
  return rowid;
}","public long createRow(String mode,long time,String status,Float speed,long timestamp,Float accuracy,String provider,String wifiData,Vector<ArrayList<Double>> samples,Double latitude,Double longitude){
  ContentValues vals=new ContentValues();
  SharedPreferences settings=mCtx.getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
  String username=settings.getString(Mobility.KEY_USERNAME,DEFAULT_USERNAME);
  if (wifiData.equals(""String_Node_Str""))   wifiData=""String_Node_Str"";
  UUID id=UUID.randomUUID();
  String timezone=DateTimeZone.getDefault().getID();
  vals.put(KEY_ID,id.toString());
  Log.d(TAG,id.toString());
  vals.put(KEY_MODE,mode);
  vals.put(KEY_SPEED,speed.toString());
  vals.put(KEY_STATUS,status);
  vals.put(KEY_LOC_TIMESTAMP,timestamp);
  vals.put(KEY_ACCURACY,accuracy.toString());
  vals.put(KEY_PROVIDER,provider);
  vals.put(KEY_WIFIDATA,wifiData);
  vals.put(KEY_ACCELDATA,formatAccelData(samples));
  vals.put(KEY_TIME,time + ""String_Node_Str"");
  vals.put(KEY_TIMEZONE,timezone);
  vals.put(KEY_LATITUDE,latitude.toString());
  vals.put(KEY_LONGITUDE,longitude.toString());
  vals.put(KEY_USERNAME,username);
  Log.d(TAG,""String_Node_Str"" + MOBILITY_TABLE + ""String_Node_Str""+ mode);
  long rowid=-1;
  Uri row=mCtx.getContentResolver().insert(MobilityInterface.CONTENT_URI,vals);
  ProbeBuilder probe=new ProbeBuilder();
  probe.withId(id.toString()).withTime(time,timezone).withLocation(time,timezone,latitude,longitude,accuracy,provider);
  Mobility.writeProbe(mCtx,probe,mode,speed,formatAccelData(samples),wifiData);
  if (row != null) {
    rowid=ContentUris.parseId(row);
    ContentResolver r=mCtx.getContentResolver();
    r.notifyChange(MobilityInterface.CONTENT_URI,null);
  }
  return rowid;
}",0.9872463768115942
3096,"public long createRow(String mode,long time,String status,Float speed,long timestamp,Float accuracy,String provider,String wifiData,Vector<ArrayList<Double>> samples,Double latitude,Double longitude){
  ContentValues vals=new ContentValues();
  SharedPreferences settings=mCtx.getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
  String username=settings.getString(Mobility.KEY_USERNAME,DEFAULT_USERNAME);
  if (wifiData.equals(""String_Node_Str""))   wifiData=""String_Node_Str"";
  UUID id=UUID.randomUUID();
  String timezone=DateTimeZone.getDefault().getID();
  vals.put(KEY_ID,id.toString());
  Log.d(TAG,id.toString());
  vals.put(KEY_MODE,mode);
  vals.put(KEY_SPEED,speed.toString());
  vals.put(KEY_STATUS,status);
  vals.put(KEY_LOC_TIMESTAMP,timestamp);
  vals.put(KEY_ACCURACY,accuracy.toString());
  vals.put(KEY_PROVIDER,provider);
  vals.put(KEY_WIFIDATA,wifiData);
  vals.put(KEY_ACCELDATA,formatAccelData(samples));
  vals.put(KEY_TIME,time + ""String_Node_Str"");
  vals.put(KEY_TIMEZONE,timezone);
  vals.put(KEY_LATITUDE,latitude.toString());
  vals.put(KEY_LONGITUDE,longitude.toString());
  vals.put(KEY_USERNAME,username);
  Log.d(TAG,""String_Node_Str"" + MOBILITY_TABLE + ""String_Node_Str""+ mode);
  long rowid=-1;
  Uri row=mCtx.getContentResolver().insert(MobilityInterface.CONTENT_URI,vals);
  ProbeBuilder probe=new ProbeBuilder();
  probe.withId(id.toString()).withTime(time,timezone).withLocation(time,timezone,latitude,longitude,accuracy,provider);
  Mobility.writeProbe(mCtx,probe,mode,speed,formatAccelData(samples),wifiData);
  if (row != null) {
    rowid=ContentUris.parseId(row);
    ContentResolver r=mCtx.getContentResolver();
    r.notifyChange(MobilityInterface.CONTENT_URI,null);
  }
  return rowid;
}","public long createRow(String mode,long time,String status,Float speed,long timestamp,Float accuracy,String provider,String wifiData,Vector<ArrayList<Double>> samples,Double latitude,Double longitude){
  ContentValues vals=new ContentValues();
  SharedPreferences settings=mCtx.getSharedPreferences(Mobility.MOBILITY,Context.MODE_PRIVATE);
  String username=settings.getString(Mobility.KEY_USERNAME,DEFAULT_USERNAME);
  if (wifiData.equals(""String_Node_Str""))   wifiData=""String_Node_Str"";
  UUID id=UUID.randomUUID();
  String timezone=DateTimeZone.getDefault().getID();
  vals.put(KEY_ID,id.toString());
  Log.d(TAG,id.toString());
  vals.put(KEY_MODE,mode);
  vals.put(KEY_SPEED,speed.toString());
  vals.put(KEY_STATUS,status);
  vals.put(KEY_LOC_TIMESTAMP,timestamp);
  vals.put(KEY_ACCURACY,accuracy.toString());
  vals.put(KEY_PROVIDER,provider);
  vals.put(KEY_WIFIDATA,wifiData);
  vals.put(KEY_ACCELDATA,formatAccelData(samples));
  vals.put(KEY_TIME,time + ""String_Node_Str"");
  vals.put(KEY_TIMEZONE,timezone);
  vals.put(KEY_LATITUDE,latitude.toString());
  vals.put(KEY_LONGITUDE,longitude.toString());
  vals.put(KEY_USERNAME,username);
  Log.d(TAG,""String_Node_Str"" + MOBILITY_TABLE + ""String_Node_Str""+ mode);
  long rowid=-1;
  Uri row=mCtx.getContentResolver().insert(MobilityInterface.CONTENT_URI,vals);
  ProbeBuilder probe=new ProbeBuilder();
  probe.withId(id.toString()).withTime(time,timezone);
  if (!""String_Node_Str"".equals(status))   probe.withLocation(time,timezone,latitude,longitude,accuracy,provider);
  if (Float.isInfinite(speed) || Float.isNaN(speed))   speed=null;
  Mobility.writeProbe(mCtx,probe,mode,speed,formatAccelData(samples),wifiData);
  if (row != null) {
    rowid=ContentUris.parseId(row);
    ContentResolver r=mCtx.getContentResolver();
    r.notifyChange(MobilityInterface.CONTENT_URI,null);
  }
  return rowid;
}",0.9675990030462476
3097,"@Override public final String render(StackTrace stackTrace){
  StringBuilder builder=new StringBuilder();
  renderPreTrace(builder,stackTrace);
  List<Entry> ignoredEntries=new ArrayList<Entry>();
  for (int segmentIndex=0; segmentIndex < stackTrace.getSegments().size(); segmentIndex++) {
    Segment segment=stackTrace.getSegments().get(segmentIndex);
    renderPreSegment(builder,stackTrace.getSegments(),segmentIndex);
    for (int entryIndex=0; entryIndex < segment.numberOfEntries(); entryIndex++) {
      Entry entry=segment.getEntries().get(entryIndex);
      if (filter == null) {
        renderEntry(builder,segment.getEntries(),entryIndex);
      }
 else       if (filter.include(entry,entryIndex)) {
        if (!ignoredEntries.isEmpty()) {
          renderIgnoredEntries(builder,ignoredEntries,entryIndex - ignoredEntries.size());
          ignoredEntries.clear();
        }
        renderEntry(builder,segment.getEntries(),entryIndex);
      }
 else {
        ignoredEntries.add(entry);
      }
    }
    if (!ignoredEntries.isEmpty()) {
      renderIgnoredEntries(builder,ignoredEntries,segment.numberOfEntries() - ignoredEntries.size());
      ignoredEntries.clear();
    }
    renderPostSegment(builder,stackTrace.getSegments(),segmentIndex);
    segmentIndex++;
  }
  renderPostTrace(builder,stackTrace);
  return builder.toString();
}","@Override public final String render(StackTrace stackTrace){
  final StringBuilder builder=new StringBuilder();
  renderPreTrace(builder,stackTrace);
  final List<Entry> ignoredEntries=new ArrayList<Entry>();
  for (int segmentIndex=0; segmentIndex < stackTrace.getSegments().size(); segmentIndex++) {
    renderSegment(stackTrace,segmentIndex,builder,ignoredEntries);
    segmentIndex++;
  }
  renderPostTrace(builder,stackTrace);
  return builder.toString();
}",0.3977961432506887
3098,"public void setFilter(EntryFilter filter){
  this.filter=filter;
}","public final void setFilter(EntryFilter filter){
  this.filter=filter;
}",0.9565217391304348
3099,"private void renderSegmentAsText(StringBuilder builder,Entry segmentEntry){
  builder.append(LINE_PAD);
  builder.append(segmentEntry.getFqClassName());
  builder.append(segmentEntry.getMethodName());
  builder.append(""String_Node_Str"");
  builder.append(segmentEntry.getFileName());
  builder.append(""String_Node_Str"");
  builder.append(segmentEntry.getLineNumber());
  builder.append(""String_Node_Str"");
}","private void renderSegmentAsText(StringBuilder builder,Entry segmentEntry){
  builder.append(LINE_PAD);
  builder.append(segmentEntry.getFqClassName());
  builder.append(""String_Node_Str"");
  builder.append(segmentEntry.getMethodName());
  builder.append(""String_Node_Str"");
  builder.append(segmentEntry.getFileName());
  builder.append(""String_Node_Str"");
  builder.append(segmentEntry.getLineNumber());
  builder.append(""String_Node_Str"");
}",0.9565217391304348
3100,"public String getURLFor(Entry entry){
  boolean matchesPackages=false;
  for (int i=0; i < forPackagesStartingWith.length; i++) {
    String prefix=forPackagesStartingWith[i];
    if (entry.getPackageName().startsWith(prefix)) {
      matchesPackages=true;
      break;
    }
  }
  if (matchesPackages) {
    StringBuilder builder=new StringBuilder();
    builder.append(javadocUrl);
    builder.append(entry.getPackageName().replace('.','/'));
    builder.append('/');
    builder.append(entry.getClassName());
    builder.append(""String_Node_Str"");
    return builder.toString();
  }
 else {
    return null;
  }
}","@Override public String getURLFor(Entry entry){
  boolean matchesPackages=false;
  for (int i=0; i < forPackagesStartingWith.length; i++) {
    final String prefix=forPackagesStartingWith[i];
    if (entry.getPackageName().startsWith(prefix)) {
      matchesPackages=true;
      break;
    }
  }
  final String url;
  if (matchesPackages) {
    StringBuilder builder=new StringBuilder();
    builder.append(javadocUrl);
    builder.append(entry.getPackageName().replace('.','/'));
    builder.append('/');
    builder.append(entry.getClassName());
    builder.append(""String_Node_Str"");
    url=builder.toString();
  }
 else {
    url=null;
  }
  return url;
}",0.9435736677115988
3101,"public String getURLFor(Entry entry){
  for (int i=0; i < resolvers.length; i++) {
    ClassLinkResolver classLinkResolver=resolvers[i];
    String url=classLinkResolver.getURLFor(entry);
    if (url != null) {
      return url;
    }
  }
  return null;
}","@Override public String getURLFor(Entry entry){
  for (int i=0; i < resolvers.length; i++) {
    ClassLinkResolver classLinkResolver=resolvers[i];
    String url=classLinkResolver.getURLFor(entry);
    if (url != null) {
      return url;
    }
  }
  return null;
}",0.9807692307692308
3102,"static void sendMessage(CommandSender player,String s,boolean isPublic){
  if (player != null) {
    player.sendMessage(BetterShop.config.getString(""String_Node_Str"") + s);
    if (isPublic) {
      broadcastMessage(player,s,false);
    }
  }
}","static void sendMessage(CommandSender player,String s,boolean isPublic){
  if (player != null) {
    if (isPublic) {
      broadcastMessage(player,s);
    }
 else {
      player.sendMessage(BetterShop.config.getString(""String_Node_Str"") + s);
    }
  }
}",0.7108433734939759
3103,"public boolean sell(CommandSender player,String[] s){
  String currency=iConomy.getBank().getCurrency();
  int amtSold=1;
  double price=0;
  MaterialData item=new MaterialData(0);
  if (!BSutils.hasPermission(player,""String_Node_Str"",true)) {
    return true;
  }
  if ((s.length > 2) || (s.length == 0)) {
    return false;
  }
 else   if (BSutils.anonymousCheck(player)) {
    return true;
  }
 else {
    try {
      item=itemDb.get(s[0]);
    }
 catch (    Exception e1) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),s[0]));
      return false;
    }
    String itemname=null;
    try {
      itemname=itemDb.getName(item.getItemTypeId(),item.getData());
    }
 catch (    Exception e2) {
      e2.printStackTrace();
    }
    try {
      price=PriceList.getSellPrice(itemname);
      if (price < 1)       throw new Exception();
    }
 catch (    Exception e1) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemname));
      return true;
    }
    ItemStack itemsToSell=item.toItemStack();
    if (s.length == 2)     try {
      amtSold=Integer.parseInt(s[1]);
    }
 catch (    Exception e) {
      BSutils.sendMessage(player,s[1] + ""String_Node_Str"");
    }
    if (amtSold < 0) {
      BSutils.sendMessage(player,BetterShop.configfile.getString(""String_Node_Str""));
      return true;
    }
    itemsToSell.setAmount(amtSold);
    PlayerInventory inv=((Player)player).getInventory();
    int amtHas=amtSold;
    leftover.clear();
    leftover.putAll(inv.removeItem(itemsToSell));
    if (leftover.size() > 0) {
      amtHas=amtSold - leftover.get(0).getAmount();
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),amtHas,amtSold));
    }
    double total=amtHas * price;
    try {
      BSutils.credit(player,total);
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemDb.getName(item.getItemTypeId(),item.getData()),amtHas,price,total,currency));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return true;
  }
}","public boolean sell(CommandSender player,String[] s){
  String currency=iConomy.getBank().getCurrency();
  int amtSold=1;
  double price=0;
  MaterialData item=new MaterialData(0);
  if (!BSutils.hasPermission(player,""String_Node_Str"",true)) {
    return true;
  }
  if ((s.length > 2) || (s.length == 0)) {
    return false;
  }
 else   if (BSutils.anonymousCheck(player)) {
    return true;
  }
 else {
    try {
      item=itemDb.get(s[0]);
    }
 catch (    Exception e1) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),s[0]));
      return false;
    }
    String itemname=null;
    try {
      itemname=itemDb.getName(item.getItemTypeId(),item.getData());
    }
 catch (    Exception e2) {
      e2.printStackTrace();
    }
    try {
      price=PriceList.getSellPrice(itemname);
      if (price <= 0)       throw new Exception();
    }
 catch (    Exception e1) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemname));
      return true;
    }
    ItemStack itemsToSell=item.toItemStack();
    if (s.length == 2)     try {
      amtSold=Integer.parseInt(s[1]);
    }
 catch (    Exception e) {
      BSutils.sendMessage(player,s[1] + ""String_Node_Str"");
    }
    if (amtSold < 0) {
      BSutils.sendMessage(player,BetterShop.configfile.getString(""String_Node_Str""));
      return true;
    }
    itemsToSell.setAmount(amtSold);
    PlayerInventory inv=((Player)player).getInventory();
    int amtHas=amtSold;
    leftover.clear();
    leftover.putAll(inv.removeItem(itemsToSell));
    if (leftover.size() > 0) {
      amtHas=amtSold - leftover.get(0).getAmount();
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),amtHas,amtSold));
    }
    double total=amtHas * price;
    try {
      BSutils.credit(player,total);
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemDb.getName(item.getItemTypeId(),item.getData()),amtHas,price,total,currency));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return true;
  }
}",0.9990213348991976
3104,"public boolean sell(CommandSender player,String[] s){
  int amtSold=1;
  int price=0;
  MaterialData item=new MaterialData(0);
  if (!BSutils.hasPermission(player,""String_Node_Str"",true)) {
    return true;
  }
  if ((s.length > 2) || (s.length == 0)) {
    return false;
  }
 else   if (BSutils.anonymousCheck(player)) {
    return true;
  }
 else {
    try {
      item=itemDb.get(s[0]);
    }
 catch (    Exception e1) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),s[0]));
      return false;
    }
    String itemname=null;
    try {
      itemname=itemDb.getName(item.getItemTypeId(),item.getData());
    }
 catch (    Exception e2) {
      e2.printStackTrace();
    }
    try {
      price=PriceList.getSellPrice(item.getItemTypeId());
      if (price < 1)       throw new Exception();
    }
 catch (    Exception e1) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemname));
      return true;
    }
    ItemStack itemsToSell=item.toItemStack();
    if (s.length == 2)     try {
      amtSold=Integer.parseInt(s[1]);
    }
 catch (    Exception e) {
      BSutils.sendMessage(player,s[1] + ""String_Node_Str"");
    }
    if (amtSold < 0) {
      BSutils.sendMessage(player,BetterShop.configfile.getString(""String_Node_Str""));
      return true;
    }
    itemsToSell.setAmount(amtSold);
    PlayerInventory inv=((Player)player).getInventory();
    leftover.clear();
    leftover.putAll(inv.removeItem(itemsToSell));
    if (leftover.size() > 0) {
      int amtHas=amtSold - leftover.get(0).getAmount();
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),amtHas,amtSold));
    }
    int total=amtSold * price;
    try {
      BSutils.credit(player,total);
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemDb.getName(item.getItemTypeId(),item.getData()),amtSold,price,total,iConomy.currency));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return true;
  }
}","public boolean sell(CommandSender player,String[] s){
  int amtSold=1;
  int price=0;
  MaterialData item=new MaterialData(0);
  if (!BSutils.hasPermission(player,""String_Node_Str"",true)) {
    return true;
  }
  if ((s.length > 2) || (s.length == 0)) {
    return false;
  }
 else   if (BSutils.anonymousCheck(player)) {
    return true;
  }
 else {
    try {
      item=itemDb.get(s[0]);
    }
 catch (    Exception e1) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),s[0]));
      return false;
    }
    String itemname=null;
    try {
      itemname=itemDb.getName(item.getItemTypeId(),item.getData());
    }
 catch (    Exception e2) {
      e2.printStackTrace();
    }
    try {
      price=PriceList.getSellPrice(item.getItemTypeId());
      if (price < 1)       throw new Exception();
    }
 catch (    Exception e1) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemname));
      return true;
    }
    ItemStack itemsToSell=item.toItemStack();
    if (s.length == 2)     try {
      amtSold=Integer.parseInt(s[1]);
    }
 catch (    Exception e) {
      BSutils.sendMessage(player,s[1] + ""String_Node_Str"");
    }
    if (amtSold < 0) {
      BSutils.sendMessage(player,BetterShop.configfile.getString(""String_Node_Str""));
      return true;
    }
    itemsToSell.setAmount(amtSold);
    PlayerInventory inv=((Player)player).getInventory();
    int amtHas=amtSold;
    leftover.clear();
    leftover.putAll(inv.removeItem(itemsToSell));
    if (leftover.size() > 0) {
      amtHas=amtSold - leftover.get(0).getAmount();
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),amtHas,amtSold));
    }
    int total=amtHas * price;
    try {
      BSutils.credit(player,total);
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemDb.getName(item.getItemTypeId(),item.getData()),amtHas,price,total,iConomy.currency));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    return true;
  }
}",0.9916267942583732
3105,"public boolean load(CommandSender player){
  if (!BSutils.hasPermission(player,""String_Node_Str"",true)) {
    return true;
  }
  PriceList.reload();
  BSutils.sendMessage(player,pricefilename + ""String_Node_Str"");
  BetterShop.configfile.load();
  BSutils.sendMessage(player,""String_Node_Str"");
  return true;
}","public boolean load(CommandSender player){
  if (!BSutils.hasPermission(player,""String_Node_Str"",true)) {
    return true;
  }
  BetterShop.configfile.load();
  BSutils.sendMessage(player,""String_Node_Str"");
  if (PriceList.reload())   BSutils.sendMessage(player,""String_Node_Str"");
 else   BSutils.sendMessage(player,""String_Node_Str"");
  return true;
}",0.7879699248120301
3106,"public BSCommand(BSConfig config){
  if (config.useMySQL()) {
    PriceList=new BSPriceList(config.sql_database,config.sql_tableName,config.sql_username,config.sql_password,config.sql_hostName,config.sql_portNum);
    PriceList.pagesize=config.pagesize;
  }
 else {
    PriceList=new BSPriceList(pluginFolder,pricefilename);
  }
}","public BSCommand(BSConfig config){
  if (config.useMySQL()) {
    PriceList=new BSPriceList(config.sql_database,config.sql_tableName,config.sql_username,config.sql_password,config.sql_hostName,config.sql_portNum);
  }
 else {
    PriceList=new BSPriceList(pluginFolder,pricefilename);
  }
  PriceList.pagesize=config.pagesize;
}",0.7750759878419453
3107,"public boolean remove(CommandSender player,String[] s){
  if ((!BSutils.hasPermission(player,""String_Node_Str"",true))) {
    return true;
  }
  if (s.length != 1) {
    return false;
  }
 else {
    try {
      PriceList.remove(s[0]);
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),s[0]));
    }
 catch (    Exception e) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),s[0]));
    }
    return true;
  }
}","public boolean remove(CommandSender player,String[] s){
  if ((!BSutils.hasPermission(player,""String_Node_Str"",true))) {
    return true;
  }
  if (s.length != 1) {
    return false;
  }
 else {
    try {
      String itemName=itemDb.getName(itemDb.get(s[0]));
      PriceList.remove(itemName);
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemName));
    }
 catch (    Exception e) {
      BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),s[0]));
    }
    return true;
  }
}",0.6095238095238096
3108,"public void remove(String s) throws Exception {
  MaterialData matdat=itemDb.get(s);
  if (isMySQL) {
    MySQLPriceList.RemoveItem(s);
  }
 else {
    if (NameMap.containsKey(matdat.getItemTypeId() + (double)matdat.getData() / 100)) {
      BuyMap.remove(matdat.getItemTypeId() + (double)matdat.getData() / 100);
      SellMap.remove(matdat.getItemTypeId() + (double)matdat.getData() / 100);
      NameMap.remove(matdat.getItemTypeId() + (double)matdat.getData() / 100);
    }
    save();
  }
}","public boolean remove(double i){
  try {
    MaterialData matdat=itemDb.get(i);
    if (isMySQL) {
      MySQLPriceList.RemoveItem(itemDb.getName(matdat));
    }
 else {
      if (NameMap.containsKey(matdat.getItemTypeId() + (double)matdat.getData() / 100)) {
        BuyMap.remove(matdat.getItemTypeId() + (double)matdat.getData() / 100);
        SellMap.remove(matdat.getItemTypeId() + (double)matdat.getData() / 100);
        NameMap.remove(matdat.getItemTypeId() + (double)matdat.getData() / 100);
      }
      save();
    }
  }
 catch (  Exception ex) {
    return false;
  }
  return true;
}",0.8087831655992681
3109,"public void reload(){
  if (isMySQL) {
    load(PLfolder,fileName);
  }
 else {
    load(sql_database,sql_tableName,sql_username,sql_password,sql_hostName,sql_portNum);
  }
}","public boolean reload(){
  if (isMySQL) {
    return load(sql_database,sql_tableName,sql_username,sql_password,sql_hostName,sql_portNum);
  }
 else {
    return load(PLfolder,fileName);
  }
}",0.7287671232876712
3110,"public boolean list(CommandSender player,String[] s){
  int pagesize=9;
  int page=0;
  if (!BSutils.hasPermission(player,""String_Node_Str"",true)) {
    return true;
  }
  try {
    page=(s.length == 0) ? 1 : Integer.parseInt(s[0]);
  }
 catch (  Exception e) {
    BSutils.sendMessage(player,""String_Node_Str"");
    return false;
  }
  int pages=(int)Math.ceil((double)PriceList.NameMap.size() / pagesize);
  String listhead=BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",String.valueOf(page)).replace(""String_Node_Str"",String.valueOf(pages));
  if ((s.length != 0) && (s.length != 1)) {
    return false;
  }
 else   if (page > pages) {
    BSutils.sendMessage(player,""String_Node_Str"" + page + ""String_Node_Str"");
    return true;
  }
 else {
    int linenum=1;
    Iterator<Double> iter=PriceList.ItemMap.iterator();
    BSutils.sendMessage(player,String.format(listhead,page,pages));
    while ((linenum < (page - 1) * pagesize) && iter.hasNext()) {
      iter.next();
      linenum++;
    }
    while ((linenum < page * pagesize) && (iter.hasNext())) {
      Double i=iter.next();
      try {
        String sellStr=(PriceList.getSellPrice(i) <= 0) ? ""String_Node_Str"" : String.format(""String_Node_Str"",PriceList.getSellPrice(i));
        String buyStr=(PriceList.getBuyPrice(i) < 0) ? ""String_Node_Str"" : String.format(""String_Node_Str"",PriceList.getBuyPrice(i));
        BSutils.sendMessage(player,String.format(""String_Node_Str"",itemDb.getName(i),PriceList.getBuyPrice(i),buyStr,sellStr));
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      linenum++;
    }
    BSutils.sendMessage(player,BetterShop.configfile.getString(""String_Node_Str""));
    return true;
  }
}","public boolean list(CommandSender player,String[] s){
  int pagesize=9;
  int page=0;
  if (!BSutils.hasPermission(player,""String_Node_Str"",true)) {
    return true;
  }
  try {
    page=(s.length == 0) ? 1 : Integer.parseInt(s[0]);
  }
 catch (  Exception e) {
    BSutils.sendMessage(player,""String_Node_Str"");
    return false;
  }
  int pages=(int)Math.ceil((double)PriceList.NameMap.size() / pagesize);
  String listhead=BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",String.valueOf(page)).replace(""String_Node_Str"",String.valueOf(pages));
  if ((s.length != 0) && (s.length != 1)) {
    return false;
  }
 else   if (page > pages) {
    BSutils.sendMessage(player,""String_Node_Str"" + page + ""String_Node_Str"");
    return true;
  }
 else {
    int linenum=1;
    Iterator<Double> iter=PriceList.ItemMap.iterator();
    BSutils.sendMessage(player,String.format(listhead,page,pages));
    while ((linenum < (page - 1) * pagesize) && iter.hasNext()) {
      iter.next();
      linenum++;
    }
    while ((linenum < page * pagesize) && (iter.hasNext())) {
      Double i=iter.next();
      try {
        String sellStr=(PriceList.getSellPrice(i) <= 0) ? ""String_Node_Str"" : String.format(""String_Node_Str"",PriceList.getSellPrice(i));
        String buyStr=(PriceList.getBuyPrice(i) < 0) ? ""String_Node_Str"" : String.format(""String_Node_Str"",PriceList.getBuyPrice(i));
        BSutils.sendMessage(player,String.format(BetterShop.configfile.getString(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),itemDb.getName(i),buyStr,sellStr));
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      linenum++;
    }
    BSutils.sendMessage(player,BetterShop.configfile.getString(""String_Node_Str""));
    return true;
  }
}",0.937066814527308
3111,"public void load(File PLpath,String fileName) throws IOException {
  int i=0;
  PLfile=new File(PLpath,fileName);
  if (!PLfile.getParentFile().exists()) {
    logger.info(""String_Node_Str"" + PLpath.getAbsolutePath());
    PLpath.mkdirs();
  }
  if (!PLfile.exists()) {
    logger.info(""String_Node_Str"" + PLfile.getAbsolutePath());
    PLfile.createNewFile();
  }
  logger.info(""String_Node_Str"");
  PriceList=new Configuration(PLfile);
  PriceList.load();
  BuyMap.clear();
  SellMap.clear();
  NameMap.clear();
  try {
    keys.addAll(PriceList.getKeys(""String_Node_Str""));
  }
 catch (  Exception e0) {
    logger.info(""String_Node_Str"");
    return;
  }
  while (i < keys.size()) {
    double buy=-1;
    double sell=-1;
    String name=""String_Node_Str"";
    String[] split=keys.get(i).split(""String_Node_Str"");
    if (split.length != 0) {
      int id=0;
      int sub=0;
      try {
        id=Integer.parseInt(split[split.length - 4]);
      }
 catch (      Exception e1) {
        id=0;
      }
      try {
        sub=Integer.parseInt(split[split.length - 1]);
      }
 catch (      Exception e1) {
        sub=0;
      }
      if (keys.contains(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str""+ String.valueOf(sub))) {
        buy=PriceList.getDouble(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str""+ String.valueOf(sub)+ ""String_Node_Str"",-1);
        sell=PriceList.getInt(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str""+ String.valueOf(sub)+ ""String_Node_Str"",-1);
        name=PriceList.getString(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str""+ String.valueOf(sub)+ ""String_Node_Str"",""String_Node_Str"");
      }
 else       if (keys.contains(""String_Node_Str"" + String.valueOf(id))) {
        buy=PriceList.getDouble(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str"",-1);
        sell=PriceList.getInt(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str"",-1);
        name=PriceList.getString(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str"",""String_Node_Str"");
      }
      if ((buy != -1) && (sell != -1)) {
        double d=id + (sub * .01);
        BuyMap.put(d,buy);
        SellMap.put(d,sell);
        NameMap.put(d,name);
      }
    }
    i++;
  }
  ItemMap.clear();
  ItemMap.addAll(NameMap.keySet());
  logger.info(""String_Node_Str"");
}","public void load(File PLpath,String fileName) throws IOException {
  int i=0;
  PLfile=new File(PLpath,fileName);
  if (!PLfile.getParentFile().exists()) {
    logger.info(""String_Node_Str"" + PLpath.getAbsolutePath());
    PLpath.mkdirs();
  }
  if (!PLfile.exists()) {
    logger.info(""String_Node_Str"" + PLfile.getAbsolutePath());
    PLfile.createNewFile();
  }
  logger.info(""String_Node_Str"");
  PriceList=new Configuration(PLfile);
  PriceList.load();
  BuyMap.clear();
  SellMap.clear();
  NameMap.clear();
  keys.clear();
  try {
    keys.addAll(PriceList.getKeys(""String_Node_Str""));
  }
 catch (  Exception e0) {
    logger.info(""String_Node_Str"");
    return;
  }
  while (i < keys.size()) {
    double buy=-1.003;
    double sell=-1.003;
    String name=""String_Node_Str"";
    String[] split=keys.get(i).split(""String_Node_Str"");
    if (split.length != 0) {
      int id=0;
      int sub=0;
      if (split.length == 8) {
        try {
          id=Integer.parseInt(split[split.length - 4]);
        }
 catch (        Exception e1) {
          id=0;
        }
        try {
          sub=Integer.parseInt(split[split.length - 1]);
        }
 catch (        Exception e1) {
          sub=0;
        }
      }
 else {
        try {
          id=Integer.parseInt(split[split.length - 1]);
        }
 catch (        Exception e1) {
          id=0;
        }
      }
      if (keys.contains(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str""+ String.valueOf(sub))) {
        buy=PriceList.getDouble(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str""+ String.valueOf(sub)+ ""String_Node_Str"",-1);
        sell=PriceList.getDouble(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str""+ String.valueOf(sub)+ ""String_Node_Str"",-1);
        name=PriceList.getString(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str""+ String.valueOf(sub)+ ""String_Node_Str"",""String_Node_Str"");
      }
 else       if (keys.contains(""String_Node_Str"" + String.valueOf(id))) {
        buy=PriceList.getDouble(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str"",-1);
        sell=PriceList.getDouble(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str"",-1);
        name=PriceList.getString(""String_Node_Str"" + String.valueOf(id) + ""String_Node_Str"",""String_Node_Str"");
      }
      if ((buy != -1.003) && (sell != -1.003)) {
        double d=id + (sub * .01);
        BuyMap.put(d,buy);
        SellMap.put(d,sell);
        NameMap.put(d,name);
      }
    }
    i++;
  }
  ItemMap.clear();
  ItemMap.addAll(NameMap.keySet());
  logger.info(""String_Node_Str"");
}",0.9457427352164194
3112,"public Action nextAction(Percept percept){
  makePerceptSentences(percept);
  Action action=makeActionQuery();
  System.out.println(""String_Node_Str"" + action);
  return action;
}","public Action nextAction(Percept percept){
  makePerceptSentences(percept);
  Action action=makeActionQuery();
  System.out.println(""String_Node_Str"" + action + ""String_Node_Str""+ pos);
  return action;
}",0.9347258485639688
3113,"private boolean ttCheckAll(Sentence alpha,List<Symbol> symbols,Model model){
  if (symbols.isEmpty()) {
    if (isTrue(model))     return alpha.isTrue(model);
 else     return true;
  }
 else {
    Symbol P=symbols.get(0);
    List<Symbol> rest=symbols.subList(1,symbols.size());
    boolean result=false;
    model.set(P,true);
    if (ttCheckAll(alpha,rest,model)) {
      model.set(P,false);
      if (ttCheckAll(alpha,rest,model)) {
        result=true;
      }
    }
    model.unset(P);
    return result;
  }
}","private boolean ttCheckAll(Sentence alpha,List<Symbol> symbols,Model model){
  if (symbols.isEmpty()) {
    if (isTrue(model)) {
      return alpha.isTrue(model);
    }
 else     return true;
  }
 else {
    Symbol P=symbols.get(0);
    List<Symbol> rest=symbols.subList(1,symbols.size());
    boolean result=false;
    model.set(P,true);
    if (ttCheckAll(alpha,rest,model)) {
      model.set(P,false);
      if (ttCheckAll(alpha,rest,model)) {
        result=true;
      }
    }
    model.unset(P);
    return result;
  }
}",0.9904030710172744
3114,"WumpusWorld(){
  map=new WumpusSquare[SIZE][SIZE];
  int wumpusPos=rand.nextInt(SIZE * SIZE - 1);
  int goldPos=rand.nextInt(SIZE * SIZE);
  for (int i=0; i < SIZE; i++) {
    for (int j=0; j < SIZE; j++) {
      map[i][j]=new WumpusSquare();
      WumpusSquare current=map[i][j];
      if (i > 0 && j > 0) {
        if (wumpusPos == 0) {
          current.hasWumpus=true;
        }
        wumpusPos--;
      }
      if (goldPos == 0) {
        current.hasGold=true;
      }
      goldPos--;
      if (rand.nextInt(5) == 0) {
        current.hasPit=true;
      }
    }
  }
}","WumpusWorld(){
  map=new WumpusSquare[SIZE][SIZE];
  int wumpusPos=rand.nextInt(SIZE * SIZE - 1);
  int goldPos=rand.nextInt(SIZE * SIZE);
  for (int i=0; i < SIZE - 1; i++) {
    for (int j=0; j < SIZE - 1; j++) {
      map[i][j]=new WumpusSquare();
      WumpusSquare current=map[i][j];
      if (i > 0 && j > 0) {
        if (wumpusPos == 0) {
          current.hasWumpus=true;
        }
        wumpusPos--;
      }
      if (goldPos == 0) {
        current.hasGold=true;
      }
      goldPos--;
      if (rand.nextInt(5) == 0) {
        current.hasPit=true;
      }
    }
  }
}",0.993091537132988
3115,"private Action makeActionQuery(){
  List<GridPos> neighbors=WumpusWorld.neighbors(pos);
  for (  GridPos npos : neighbors) {
    if (kb.query(new Not(""String_Node_Str"" + npos))) {
      return move(npos);
    }
  }
  return Action.Up;
}","private Action makeActionQuery(){
  List<GridPos> neighbors=WumpusWorld.neighbors(pos);
  Collections.shuffle(neighbors);
  for (  GridPos npos : neighbors) {
    if (kb.query(new Not(""String_Node_Str"" + npos))) {
      return move(npos);
    }
  }
  return Action.Up;
}",0.932806324110672
3116,"/** 
 * @param m2Home Maven2 installation. This is where we find Maven jars that we'll run.
 * @param remotingJar Hudson's remoting.jar that we'll load.
 * @param interceptorJar maven-interceptor.jar that we'll load.
 * @param tcpPort TCP socket that the launching Hudson will be listening to. This is used for the remoting communication.
 * @param interceptorOverrideJar Possibly null override jar to be placed in front of maven-interceptor.jar
 */
public static void main(File m2Home,File remotingJar,File interceptorJar,int tcpPort,File interceptorOverrideJar) throws Exception {
  try {
    m2Home=m2Home.getCanonicalFile();
  }
 catch (  IOException e) {
  }
  if (!m2Home.exists()) {
    System.err.println(""String_Node_Str"" + m2Home);
    System.exit(1);
  }
  versionCheck();
  System.setProperty(""String_Node_Str"",m2Home.getPath());
  System.setProperty(""String_Node_Str"",interceptorJar.getPath());
  System.setProperty(""String_Node_Str"",(interceptorOverrideJar != null ? interceptorOverrideJar : interceptorJar).getPath());
  boolean is206OrLater=!new File(m2Home,""String_Node_Str"").exists();
  launcher=new Launcher();
  launcher.setSystemClassLoader(Main.class.getClassLoader());
  launcher.configure(Main.class.getResourceAsStream(is206OrLater ? ""String_Node_Str"" : ""String_Node_Str""));
  ClassRealm remoting=new DefaultClassRealm(launcher.getWorld(),""String_Node_Str"",launcher.getSystemClassLoader());
  remoting.setParent(launcher.getWorld().getRealm(""String_Node_Str""));
  remoting.addConstituent(remotingJar.toURI().toURL());
  final Socket s;
  String mavenRemoteUseInetEnvVar=System.getenv(""String_Node_Str"");
  boolean mavenRemoteUseInet=Boolean.parseBoolean(mavenRemoteUseInetEnvVar);
  if (mavenRemoteUseInet) {
    InetAddress host=InetAddress.getLocalHost();
    String hostname=host.getHostName();
    System.out.println(""String_Node_Str"" + hostname);
    s=new Socket(hostname,tcpPort);
  }
 else   s=new Socket((String)null,tcpPort);
  Class remotingLauncher=remoting.loadClass(""String_Node_Str"");
  remotingLauncher.getMethod(""String_Node_Str"",new Class[]{InputStream.class,OutputStream.class}).invoke(null,new Object[]{new BufferedInputStream(new FilterInputStream(s.getInputStream()){
    public void close() throws IOException {
      s.shutdownInput();
    }
  }
),new BufferedOutputStream(new RealFilterOutputStream(s.getOutputStream()){
    public void close() throws IOException {
      s.shutdownOutput();
    }
  }
)});
  System.exit(0);
}","/** 
 * @param m2Home Maven2 installation. This is where we find Maven jars that we'll run.
 * @param remotingJar Hudson's remoting.jar that we'll load.
 * @param interceptorJar maven-interceptor.jar that we'll load.
 * @param tcpPort TCP socket that the launching Hudson will be listening to. This is used for the remoting communication.
 * @param interceptorOverrideJar Possibly null override jar to be placed in front of maven-interceptor.jar
 */
public static void main(File m2Home,File remotingJar,File interceptorJar,int tcpPort,File interceptorOverrideJar) throws Exception {
  try {
    m2Home=m2Home.getCanonicalFile();
  }
 catch (  IOException e) {
  }
  if (!m2Home.exists()) {
    System.err.println(""String_Node_Str"" + m2Home);
    System.exit(1);
  }
  versionCheck();
  System.setProperty(""String_Node_Str"",m2Home.getPath());
  System.setProperty(""String_Node_Str"",interceptorJar.getPath());
  System.setProperty(""String_Node_Str"",(interceptorOverrideJar != null ? interceptorOverrideJar : interceptorJar).getPath());
  is206OrLater=!new File(m2Home,""String_Node_Str"").exists();
  launcher=new Launcher();
  launcher.setSystemClassLoader(Main.class.getClassLoader());
  launcher.configure(Main.class.getResourceAsStream(is206OrLater ? ""String_Node_Str"" : ""String_Node_Str""));
  ClassRealm remoting=new DefaultClassRealm(launcher.getWorld(),""String_Node_Str"",launcher.getSystemClassLoader());
  remoting.setParent(launcher.getWorld().getRealm(""String_Node_Str""));
  remoting.addConstituent(remotingJar.toURI().toURL());
  final Socket s;
  String mavenRemoteUseInetEnvVar=System.getenv(""String_Node_Str"");
  boolean mavenRemoteUseInet=Boolean.parseBoolean(mavenRemoteUseInetEnvVar);
  if (mavenRemoteUseInet) {
    InetAddress host=InetAddress.getLocalHost();
    String hostname=host.getHostName();
    System.out.println(""String_Node_Str"" + hostname);
    s=new Socket(hostname,tcpPort);
  }
 else   s=new Socket((String)null,tcpPort);
  Class remotingLauncher=remoting.loadClass(""String_Node_Str"");
  remotingLauncher.getMethod(""String_Node_Str"",new Class[]{InputStream.class,OutputStream.class}).invoke(null,new Object[]{new BufferedInputStream(new FilterInputStream(s.getInputStream()){
    public void close() throws IOException {
      s.shutdownInput();
    }
  }
),new BufferedOutputStream(new RealFilterOutputStream(s.getOutputStream()){
    public void close() throws IOException {
      s.shutdownOutput();
    }
  }
)});
  System.exit(0);
}",0.9983818770226536
3117,"/** 
 * @throws MavenExecutionRequestPopulationException 
 * @see org.jvnet.hudson.maven3.MavenExecutionRequestBuilder.MavenExecutionRequestsBuilder#getMavenExecutionRequest(java.lang.String[])
 */
public MavenExecutionRequest getMavenExecutionRequest(String[] args,PrintStream printStream) throws MavenExecutionRequestPopulationException, SettingsBuildingException, MavenExecutionRequestsBuilderException {
  try {
    CliRequest cliRequest=new CliRequest(args,null);
    initialize(cliRequest,printStream);
    cli(cliRequest);
    logging(cliRequest);
    commands(cliRequest);
    properties(cliRequest);
    settings(cliRequest);
    populateRequest(cliRequest);
    encryption(cliRequest);
    MavenExecutionRequest request=executionRequestPopulator.populateDefaults(cliRequest.request);
    if (request.getProjectBuildingRequest().getRepositorySession() == null) {
      MavenRepositorySystemSession session=new MavenRepositorySystemSession();
      if (session.getLocalRepositoryManager() == null) {
        session.setLocalRepositoryManager(new EnhancedLocalRepositoryManager(request.getLocalRepositoryPath()));
      }
      request.getProjectBuildingRequest().setRepositorySession(session);
    }
    return request;
  }
 catch (  Exception e) {
    throw new MavenExecutionRequestsBuilderException(e.getMessage(),e);
  }
}","/** 
 * @throws MavenExecutionRequestPopulationException 
 * @see org.jvnet.hudson.maven3.MavenExecutionRequestBuilder.MavenExecutionRequestsBuilder#getMavenExecutionRequest(java.lang.String[])
 */
public MavenExecutionRequest getMavenExecutionRequest(String[] args,PrintStream printStream) throws MavenExecutionRequestPopulationException, SettingsBuildingException, MavenExecutionRequestsBuilderException {
  try {
    CliRequest cliRequest=new CliRequest(args,null);
    initialize(cliRequest,printStream);
    cli(cliRequest);
    logging(cliRequest);
    commands(cliRequest);
    properties(cliRequest);
    settings(cliRequest);
    populateRequest(cliRequest);
    encryption(cliRequest);
    MavenExecutionRequest request=executionRequestPopulator.populateDefaults(cliRequest.request);
    return request;
  }
 catch (  Exception e) {
    throw new MavenExecutionRequestsBuilderException(e.getMessage(),e);
  }
}",0.7160603371783496
3118,"static void populateProperties(CommandLine commandLine,Properties systemProperties,Properties userProperties){
  EnvironmentUtils.addEnvVars(systemProperties);
  if (commandLine.hasOption(CLIManager.SET_SYSTEM_PROPERTY)) {
    String[] defStrs=commandLine.getOptionValues(CLIManager.SET_SYSTEM_PROPERTY);
    if (defStrs != null) {
      for (int i=0; i < defStrs.length; ++i) {
        setCliProperty(defStrs[i],userProperties);
      }
    }
  }
  systemProperties.putAll(System.getProperties());
  systemProperties.put(""String_Node_Str"",new SimpleDateFormat(DEFAULT_BUILD_TIMESTAMP_FORMAT).format(new Date()));
}","static void populateProperties(CommandLine commandLine,Properties systemProperties,Properties userProperties){
  EnvironmentUtils.addEnvVars(systemProperties);
  if (commandLine.hasOption(CLIManager.SET_SYSTEM_PROPERTY)) {
    String[] defStrs=commandLine.getOptionValues(CLIManager.SET_SYSTEM_PROPERTY);
    if (defStrs != null) {
      for (int i=0; i < defStrs.length; ++i) {
        setCliProperty(defStrs[i],userProperties);
      }
    }
  }
  systemProperties.putAll(System.getProperties());
}",0.8968609865470852
3119,"@Override public void disconnected(Stream stream) throws SkypeException {
  if (stream == Stream.this) {
synchronized (wait) {
      wait.notify();
    }
  }
}","@Override public void disconnected(Stream stream) throws SkypeException {
  if (stream == Stream.this) {
    future.cancel(true);
  }
}",0.8095238095238095
3120,"/** 
 * Send a message through this Stream.
 * @param text The message to send.
 * @throws SkypeException when the connection to the Skype client has gone bad or AP2AP connection is not ok.
 */
public void write(String text) throws SkypeException {
  Utils.checkNotNull(text,""String_Node_Str"");
  try {
    final Object wait=new Object();
    AbstractConnectorListener connectorListener=new AbstractConnectorListener(){
      @Override public void messageReceived(      ConnectorMessageEvent event){
        String message=event.getMessage();
        if (message.startsWith(""String_Node_Str"" + getApplication().getName() + ""String_Node_Str"")) {
          String data=message.substring((""String_Node_Str"" + getApplication().getName() + ""String_Node_Str"").length());
          if (""String_Node_Str"".equals(data)) {
synchronized (wait) {
              wait.notify();
            }
            return;
          }
          String[] streams=data.split(""String_Node_Str"");
          for (          String stream : streams) {
            stream=stream.substring(0,stream.indexOf('='));
            if (stream.equals(getId())) {
              return;
            }
          }
synchronized (wait) {
            wait.notify();
          }
        }
      }
    }
;
    ApplicationListener applicationListener=new ApplicationAdapter(){
      @Override public void disconnected(      Stream stream) throws SkypeException {
        if (stream == Stream.this) {
synchronized (wait) {
            wait.notify();
          }
        }
      }
    }
;
    Connector.getInstance().addConnectorListener(connectorListener);
    application.addApplicationListener(applicationListener);
    String header=""String_Node_Str"" + getApplication().getName() + ""String_Node_Str""+ getId();
synchronized (wait) {
      try {
        String result=Connector.getInstance().executeWithId(header + ""String_Node_Str"" + text,header);
        Utils.checkError(result);
        wait.wait();
      }
 catch (      InterruptedException e) {
        throw new SkypeException(""String_Node_Str"",e);
      }
 finally {
        Connector.getInstance().removeConnectorListener(connectorListener);
        application.removeApplicationListener(applicationListener);
      }
    }
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
  }
}","/** 
 * Send a message through this Stream.
 * @param text The message to send.
 * @throws SkypeException when the connection to the Skype client has gone bad or AP2AP connection is not ok.
 */
public void write(String text) throws SkypeException {
  Utils.checkNotNull(text,""String_Node_Str"");
  try {
    NotificationChecker checker=new NotificationChecker(){
      public boolean isTarget(      String message){
        if (message.startsWith(""String_Node_Str"" + getApplication().getName() + ""String_Node_Str"")) {
          String data=message.substring((""String_Node_Str"" + getApplication().getName() + ""String_Node_Str"").length());
          if (""String_Node_Str"".equals(data)) {
            return true;
          }
          String[] streams=data.split(""String_Node_Str"");
          for (          String stream : streams) {
            stream=stream.substring(0,stream.indexOf('='));
            if (stream.equals(getId())) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
    }
;
    String header=""String_Node_Str"" + getApplication().getName() + ""String_Node_Str""+ getId();
    ApplicationListener applicationListener=null;
    try {
      final Future<String> future=Connector.getInstance().waitForEndWithId(header + ""String_Node_Str"" + text,header,checker);
      applicationListener=new ApplicationAdapter(){
        @Override public void disconnected(        Stream stream) throws SkypeException {
          if (stream == Stream.this) {
            future.cancel(true);
          }
        }
      }
;
      application.addApplicationListener(applicationListener);
      try {
        Utils.checkError(future.get());
      }
 catch (      CancellationException e) {
        throw new SkypeException(""String_Node_Str"" + getId() + ""String_Node_Str"",e);
      }
catch (      ExecutionException e) {
        if (e.getCause() instanceof ConnectorException) {
          throw (ConnectorException)e.getCause();
        }
        throw new SkypeException(""String_Node_Str"" + header + ""String_Node_Str""+ text+ ""String_Node_Str"",e);
      }
catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new SkypeException(""String_Node_Str"",e);
      }
    }
  finally {
      application.removeApplicationListener(applicationListener);
    }
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
  }
}",0.2578470613018748
3121,"/** 
 * Send a Skype command to the Skype client and wait for the reply, using an ID.
 * @param command The command to send.
 * @param responseHeader The expected reply header.
 * @return The reply.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
public final String executeWithId(final String command,final String responseHeader) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",command);
  ConnectorUtils.checkNotNull(""String_Node_Str"",responseHeader);
  String header=""String_Node_Str"" + (_commandCount++) + ""String_Node_Str"";
  String response=execute(header + command,new String[]{header + responseHeader,header + ""String_Node_Str""},true);
  return response.substring(header.length());
}","/** 
 * Send a Skype command to the Skype client and wait for the reply, using an ID.
 * @param command The command to send.
 * @param responseHeader The expected reply header.
 * @return The reply.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
public final String executeWithId(final String command,final String responseHeader) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",command);
  ConnectorUtils.checkNotNull(""String_Node_Str"",responseHeader);
  String header=""String_Node_Str"" + _commandCount.getAndIncrement() + ""String_Node_Str"";
  String response=execute(header + command,new String[]{header + responseHeader,header + ""String_Node_Str""},true);
  return response.substring(header.length());
}",0.9715394566623544
3122,"/** 
 * Send a Skype command to Skype (actual implementation method) and wait for response.
 * @param command the command to send.
 * @param responseHeaders The expected response headers.
 * @param checkAttached if true the connector will first check if it is connected.
 * @return the response.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
private String execute(final String command,final String[] responseHeaders,final boolean checkAttached,boolean withoutTimeout) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",command);
  ConnectorUtils.checkNotNull(""String_Node_Str"",responseHeaders);
  if (checkAttached) {
    assureAttached();
  }
  final BlockingQueue<String> responses=new LinkedBlockingQueue<String>();
  ConnectorListener listener=new AbstractConnectorListener(){
    public void messageReceived(    ConnectorMessageEvent event){
      String message=event.getMessage();
      for (      String responseHeader : responseHeaders) {
        if (message.startsWith(responseHeader) || message.startsWith(""String_Node_Str"")) {
          responses.add(message);
          return;
        }
      }
    }
  }
;
  addConnectorListener(listener,false);
  fireMessageSent(command);
  sendCommand(command);
  try {
    boolean pinged=false;
    while (true) {
      String response;
      try {
        response=responses.poll(getCommandTimeout(),TimeUnit.MILLISECONDS);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new ConnectorException(""String_Node_Str"" + command + ""String_Node_Str"");
      }
      if (response == null) {
        if (pinged) {
          setStatus(Status.NOT_RUNNING);
          throw new NotAttachedException(Status.NOT_RUNNING);
        }
 else {
          fireMessageSent(""String_Node_Str"");
          sendCommand(""String_Node_Str"");
          pinged=true;
          continue;
        }
      }
      if (response.startsWith(""String_Node_Str"")) {
        pinged=false;
        continue;
      }
 else {
        return response;
      }
    }
  }
  finally {
    removeConnectorListener(listener);
  }
}","/** 
 * Send a Skype command to Skype (actual implementation method) and wait for response.
 * @param command the command to send.
 * @param responseChecker the response checker.
 * @param checkAttached if true the connector will first check if it is connected.
 * @return the response future.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
private Future<String> execute(final String command,final NotificationChecker responseChecker,final boolean checkAttached,boolean withoutTimeout) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",command);
  ConnectorUtils.checkNotNull(""String_Node_Str"",responseChecker);
  if (checkAttached) {
    assureAttached();
  }
  return _commandExecutor.submit(new Callable<String>(){
    public String call() throws Exception {
      final BlockingQueue<String> responses=new LinkedBlockingQueue<String>();
      ConnectorListener listener=new AbstractConnectorListener(){
        public void messageReceived(        ConnectorMessageEvent event){
          String message=event.getMessage();
          if (responseChecker.isTarget(message) || message.startsWith(""String_Node_Str"")) {
            responses.add(message);
          }
        }
      }
;
      addConnectorListener(listener,false);
      fireMessageSent(command);
      sendCommand(command);
      try {
        boolean pinged=false;
        while (true) {
          String response=responses.poll(getCommandTimeout(),TimeUnit.MILLISECONDS);
          if (response == null) {
            if (pinged) {
              setStatus(Status.NOT_RUNNING);
              throw new NotAttachedException(Status.NOT_RUNNING);
            }
 else {
              fireMessageSent(""String_Node_Str"");
              sendCommand(""String_Node_Str"");
              pinged=true;
              continue;
            }
          }
          if (response.startsWith(""String_Node_Str"")) {
            pinged=false;
            continue;
          }
 else {
            return response;
          }
        }
      }
  finally {
        removeConnectorListener(listener);
      }
    }
  }
);
}",0.7978649338593641
3123,"public void messageReceived(ConnectorMessageEvent event){
  String message=event.getMessage();
  for (  String responseHeader : responseHeaders) {
    if (message.startsWith(responseHeader) || message.startsWith(""String_Node_Str"")) {
      responses.add(message);
      return;
    }
  }
}","public void messageReceived(ConnectorMessageEvent event){
  String message=event.getMessage();
  if (responseChecker.isTarget(message) || message.startsWith(""String_Node_Str"")) {
    responses.add(message);
  }
}",0.7425149700598802
3124,"/** 
 * Return the status of this connector instance.
 * @return status.
 */
public final Status getStatus(){
  return _status;
}","/** 
 * Gets the status of this connector.
 * @return status the status of this connector
 * @see #setStatus(com.skype.connector.Connector.Status)
 */
public final synchronized Status getStatus(){
  return _status;
}",0.6550724637681159
3125,"/** 
 * Fire a status changed event.
 * @param listenerList the event listener list
 * @param status the new status.
 */
private void fireStatusChanged(final ConnectorListener[] listeners,final Status status){
  ConnectorStatusEvent event=new ConnectorStatusEvent(this,status);
  for (int i=listeners.length - 1; 0 <= i; i--) {
    listeners[i].statusChanged(event);
  }
}","/** 
 * Sends a status change event to the specified listeners.
 * @param listeners the event listeners
 * @param newStatus the new status
 */
private void fireStatusChanged(final ConnectorListener[] listeners,final Status newStatus){
  ConnectorStatusEvent event=new ConnectorStatusEvent(this,newStatus);
  for (int i=listeners.length - 1; 0 <= i; i--) {
    listeners[i].statusChanged(event);
  }
}",0.8134715025906736
3126,"private ConnectorListener[] toConnectorListenerArray(List<ConnectorListener> listeners){
  return listeners.toArray(new ConnectorListener[0]);
}","/** 
 * Converts the specified listener list to an listener array.
 * @param listeners the listener list
 * @return an listener array
 */
private ConnectorListener[] toConnectorListenerArray(List<ConnectorListener> listeners){
  return listeners.toArray(new ConnectorListener[0]);
}",0.676056338028169
3127,"/** 
 * Sets the application name used to get the access grant of Skype API. <p> The specified name is what the User will see in the Skype API Allow/Deny dialog. </p>
 * @param newApplicationName the application name
 * @throws NullPointerException if the specified new debug out is null
 * @see #getApplicationName()
 */
public final synchronized void setApplicationName(final String newApplicationName){
  ConnectorUtils.checkNotNull(""String_Node_Str"",newApplicationName);
  _applicationName=newApplicationName;
}","/** 
 * Sets the application name used to get the access grant of Skype API. The specified name is what the User will see in the Skype API Allow/Deny dialog.
 * @param newApplicationName the application name
 * @throws NullPointerException if the specified application name is null
 * @see #getApplicationName()
 */
public final synchronized void setApplicationName(final String newApplicationName){
  ConnectorUtils.checkNotNull(""String_Node_Str"",newApplicationName);
  _applicationName=newApplicationName;
}",0.962890625
3128,"/** 
 * Set the status of this connector instance.
 * @param newValue The new status.
 */
protected final void setStatus(final Status newValue){
  ConnectorUtils.checkNotNull(""String_Node_Str"",newValue);
  _status=newValue;
  fireStatusChanged(newValue);
}","/** 
 * Sets the status of this connector. After setting, an status changed event will be sent to the all listeners.
 * @param newValue the new status
 * @throws NullPointerException if the specified status is null
 * @see #getStatus()
 */
protected final synchronized void setStatus(final Status newStatus){
  ConnectorUtils.checkNotNull(""String_Node_Str"",newStatus);
  _status=newStatus;
  fireStatusChanged(newStatus);
}",0.5390279823269514
3129,"public void run(){
  fireMessageEvent(_asyncListeners,message,isReceived);
}","public void run(){
  fireMessageEvent(toConnectorListenerArray(_asyncListeners),message,isReceived);
}",0.8539325842696629
3130,"/** 
 * Remove a listener from the collection of listeners. The listener will no longer be triggered when a event happens.
 * @param listener The listener to remove.
 */
public final void removeConnectorListener(final ConnectorListener listener){
  ConnectorUtils.checkNotNull(""String_Node_Str"",listener);
{
    List<ConnectorListener> listeners=new ArrayList(Arrays.asList(_syncListeners));
    if (listeners.remove(listener)) {
      _syncListeners=listeners.toArray(new ConnectorListener[0]);
    }
  }
{
    List<ConnectorListener> listeners=new ArrayList(Arrays.asList(_asyncListeners));
    if (listeners.remove(listener)) {
      _asyncListeners=listeners.toArray(new ConnectorListener[0]);
    }
  }
}","/** 
 * Remove a listener from the collection of listeners. The listener will no longer be triggered when a event happens.
 * @param listener The listener to remove.
 */
public final void removeConnectorListener(final ConnectorListener listener){
  ConnectorUtils.checkNotNull(""String_Node_Str"",listener);
  _syncListeners.remove(listener);
  _asyncListeners.remove(listener);
}",0.6053357865685373
3131,"/** 
 * Add a listener to this connector if the connector is attached.
 * @param listener The listener to add.
 * @param checkAttached if true check if connector is attached.
 * @param isSynchronous if true the listener is handled synchronously.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
public final void addConnectorListener(final ConnectorListener listener,final boolean checkAttached,final boolean isSynchronous) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",listener);
  if (isSynchronous) {
    List<ConnectorListener> listeners=new ArrayList(Arrays.asList(_syncListeners));
    if (listeners.add(listener)) {
      _syncListeners=listeners.toArray(new ConnectorListener[0]);
    }
  }
 else {
    List<ConnectorListener> listeners=new ArrayList(Arrays.asList(_asyncListeners));
    if (listeners.add(listener)) {
      _asyncListeners=listeners.toArray(new ConnectorListener[0]);
    }
  }
  if (checkAttached) {
    assureAttached();
  }
}","/** 
 * Add a listener to this connector if the connector is attached.
 * @param listener The listener to add.
 * @param checkAttached if true check if connector is attached.
 * @param isSynchronous if true the listener is handled synchronously.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
public final void addConnectorListener(final ConnectorListener listener,final boolean checkAttached,final boolean isSynchronous) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",listener);
  if (isSynchronous) {
    _syncListeners.add(listener);
  }
 else {
    _asyncListeners.add(listener);
  }
  if (checkAttached) {
    assureAttached();
  }
}",0.7564469914040115
3132,"/** 
 * Fire a message event.
 * @param listenerList the event listener list
 * @param message the message that triggered the event.
 * @param isReceived the message is a received type or not.
 */
private void fireMessageEvent(final ConnectorListener[] listeners,final String message,final boolean isReceived){
  ConnectorMessageEvent event=new ConnectorMessageEvent(this,message);
  boolean fireMessageReceived=isReceived;
  for (int i=listeners.length - 1; 0 <= i; i--) {
    if (fireMessageReceived) {
      listeners[i].messageReceived(event);
    }
 else {
      listeners[i].messageSent(event);
    }
  }
}","/** 
 * Fire a message event.
 * @param listenerList the event listener list
 * @param message the message that triggered the event.
 * @param isReceived the message is a received type or not.
 */
private void fireMessageEvent(final ConnectorListener[] listeners,final String message,final boolean isReceived){
  ConnectorMessageEvent event=new ConnectorMessageEvent(this,message);
  for (int i=listeners.length - 1; 0 <= i; i--) {
    if (isReceived) {
      listeners[i].messageReceived(event);
    }
 else {
      listeners[i].messageSent(event);
    }
  }
}",0.9531116794543903
3133,"/** 
 * Constructor with the current status.
 * @param newStatus Current status.
 */
NotAttachedException(Status newStatus){
  this.status=newStatus;
}","NotAttachedException(Status newStatus,Throwable cause){
  this(newStatus);
  initCause(cause);
}",0.4696356275303643
3134,"private ConnectorListener[] toConnectorListenerArray(List<ConnectorListener> listeners){
  return listeners.toArray(new ConnectorListener[listeners.size()]);
}","private ConnectorListener[] toConnectorListenerArray(List<ConnectorListener> listeners){
  return listeners.toArray(new ConnectorListener[0]);
}",0.943894389438944
3135,"/** 
 * Sets the debug output stream.
 * @param newDebugOut the new debug output streamthrows NullPointerException if <code>debugOut</code> is null.
 * @see #setDebugOut(PrintWriter)
 * @see #getDebugOut()
 */
public final void setDebugOut(final PrintStream newDebugOut){
  ConnectorUtils.checkNotNull(""String_Node_Str"",newDebugOut);
  setDebugOut(new PrintWriter(newDebugOut,true));
}","/** 
 * Sets the debug output stream.
 * @param newDebugOut the new debug output stream
 * @throws NullPointerException if the specified new debug out is null
 * @see #setDebugOut(PrintWriter)
 * @see #getDebugOut()
 */
public final synchronized void setDebugOut(final PrintStream newDebugOut){
  ConnectorUtils.checkNotNull(""String_Node_Str"",newDebugOut);
  setDebugOut(new PrintWriter(newDebugOut,true));
}",0.7440100882723834
3136,"/** 
 * Enable or disable debug printing for more information.
 * @param on if true debug output will be written to System.out
 * @throws ConnectorException thrown when connection to Skype Client has gone bad.
 */
public final void setDebug(final boolean on) throws ConnectorException {
synchronized (_debugFieldMutex) {
    if (on) {
      if (_debugListener == null) {
        _debugListener=new AbstractConnectorListener(){
          @Override public void messageReceived(          final ConnectorMessageEvent event){
            getDebugOut().println(""String_Node_Str"" + event.getMessage());
          }
          @Override public void messageSent(          final ConnectorMessageEvent event){
            getDebugOut().println(""String_Node_Str"" + event.getMessage());
          }
        }
;
        addConnectorListener(_debugListener,true,true);
      }
    }
 else {
      if (_debugListener != null) {
        removeConnectorListener(_debugListener);
      }
    }
  }
}","/** 
 * Enable or disable debug printing for more information.
 * @param on if true debug output will be written to System.out
 * @throws ConnectorException thrown when connection to Skype Client has gone bad.
 */
public final synchronized void setDebug(final boolean on) throws ConnectorException {
  if (on) {
    if (_debugListener == null) {
      _debugListener=new AbstractConnectorListener(){
        @Override public void messageReceived(        final ConnectorMessageEvent event){
          getDebugOut().println(""String_Node_Str"" + event.getMessage());
        }
        @Override public void messageSent(        final ConnectorMessageEvent event){
          getDebugOut().println(""String_Node_Str"" + event.getMessage());
        }
      }
;
      addConnectorListener(_debugListener,true,true);
    }
  }
 else {
    if (_debugListener != null) {
      removeConnectorListener(_debugListener);
      _debugListener=null;
    }
  }
}",0.9334027055150884
3137,"/** 
 * Gets the debug output stream.
 * @return the current debug output stream
 * @see #setDebugOut(PrintWriter)
 * @see #setDebugOut(PrintStream)
 */
public final PrintWriter getDebugOut(){
  return _debugOut;
}","/** 
 * Gets the debug output stream.
 * @return the current debug output stream
 * @see #setDebugOut(PrintWriter)
 * @see #setDebugOut(PrintStream)
 */
public final synchronized PrintWriter getDebugOut(){
  return _debugOut;
}",0.9705215419501134
3138,"/** 
 * Return the current application name.
 * @return applicationName.
 */
public final String getApplicationName(){
  return _applicationName;
}","/** 
 * Gets the application name used to get the access grant of Skype API.
 * @return the application name
 * @see #setApplicationName(String)
 */
public final synchronized String getApplicationName(){
  return _applicationName;
}",0.5804749340369393
3139,"/** 
 * Set the application name for this application. This is what the User will see in the Allow/Deny dialog.
 * @param newApplicationName Name of this application.
 */
public final void setApplicationName(final String newApplicationName){
  ConnectorUtils.checkNotNull(""String_Node_Str"",newApplicationName);
  _applicationName=newApplicationName;
}","/** 
 * Sets the application name used to get the access grant of Skype API. <p> The specified name is what the User will see in the Skype API Allow/Deny dialog. </p>
 * @param newApplicationName the application name
 * @throws NullPointerException if the specified new debug out is null
 * @see #getApplicationName()
 */
public final synchronized void setApplicationName(final String newApplicationName){
  ConnectorUtils.checkNotNull(""String_Node_Str"",newApplicationName);
  _applicationName=newApplicationName;
}",0.6628175519630485
3140,"public void attachResponse(int attachResponseCode){
  SkypeFramework.removeSkypeFrameworkListener(this);
switch (attachResponseCode) {
case 0:
    setStatus(Status.REFUSED);
  latch.countDown();
break;
case 1:
setStatus(Status.ATTACHED);
latch.countDown();
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","@Override public void attachResponse(int attachResponseCode){
  SkypeFramework.removeSkypeFrameworkListener(this);
switch (attachResponseCode) {
case 0:
    setStatus(Status.REFUSED);
  latch.countDown();
break;
case 1:
setStatus(Status.ATTACHED);
latch.countDown();
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}",0.9850299401197604
3141,"@Override public void becameAvailable(){
  setStatus(Status.API_AVAILABLE);
}","@Override public void becameAvailable(){
}",0.7058823529411765
3142,"/** 
 * Connects to Skype client.
 * @param timeout the maximum time in milliseconds to connect.
 * @return Status the status after connecting.
 * @throws ConnectorException when connection can not be established.
 */
protected Status connect(int timeout) throws ConnectorException {
  if (!SkypeFramework.isRunning()) {
    setStatus(Status.NOT_RUNNING);
    return getStatus();
  }
  if (!SkypeFramework.isAvailable()) {
    setStatus(Status.NOT_AVAILABLE);
    return getStatus();
  }
  try {
    final CountDownLatch latch=new CountDownLatch(1);
    SkypeFrameworkListener listener=new AbstractSkypeFrameworkListener(){
      public void attachResponse(      int attachResponseCode){
        SkypeFramework.removeSkypeFrameworkListener(this);
switch (attachResponseCode) {
case 0:
          setStatus(Status.REFUSED);
        latch.countDown();
      break;
case 1:
    setStatus(Status.ATTACHED);
  latch.countDown();
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}
}
;
setStatus(Status.PENDING_AUTHORIZATION);
SkypeFramework.addSkypeFrameworkListener(listener);
SkypeFramework.connect();
latch.await(timeout,TimeUnit.MILLISECONDS);
return getStatus();
}
 catch (InterruptedException e) {
throw new ConnectorException(""String_Node_Str"",e);
}
}","/** 
 * Connects to Skype client.
 * @param timeout the maximum time in milliseconds to connect.
 * @return Status the status after connecting.
 * @throws ConnectorException when connection can not be established.
 */
protected Status connect(int timeout) throws ConnectorException {
  if (!SkypeFramework.isRunning()) {
    setStatus(Status.NOT_RUNNING);
    return getStatus();
  }
  try {
    final CountDownLatch latch=new CountDownLatch(1);
    SkypeFrameworkListener listener=new AbstractSkypeFrameworkListener(){
      @Override public void attachResponse(      int attachResponseCode){
        SkypeFramework.removeSkypeFrameworkListener(this);
switch (attachResponseCode) {
case 0:
          setStatus(Status.REFUSED);
        latch.countDown();
      break;
case 1:
    setStatus(Status.ATTACHED);
  latch.countDown();
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}
}
;
setStatus(Status.PENDING_AUTHORIZATION);
SkypeFramework.addSkypeFrameworkListener(listener);
SkypeFramework.connect();
latch.await();
return getStatus();
}
 catch (InterruptedException e) {
throw new ConnectorException(""String_Node_Str"",e);
}
}",0.94098225340487
3143,"/** 
 * Search users by a part of id or e-mail.
 * @param keword a part of id or e-mail
 * @return users
 * @throws SkypeException when connection has gone bad or ERROR reply.
 */
public static User[] searchUsers(String keyword) throws SkypeException {
  int oldTimeout=Connector.getInstance().getCommandTimeout();
  try {
    Connector.getInstance().setCommandTimeout(0);
    String command=""String_Node_Str"" + keyword;
    String responseHeader=""String_Node_Str"";
    String response=Connector.getInstance().executeWithId(command,responseHeader);
    String data=response.substring(responseHeader.length());
    String[] ids=Utils.convertToArray(data);
    User[] users=new User[ids.length];
    for (int i=0; i < ids.length; ++i) {
      users[i]=User.getInstance(ids[i]);
    }
    return users;
  }
 catch (  ConnectorException ex) {
    Utils.convertToSkypeException(ex);
    return null;
  }
 finally {
    Connector.getInstance().setCommandTimeout(oldTimeout);
  }
}","/** 
 * Search users by a part of id or e-mail.
 * @param keword a part of id or e-mail
 * @return users
 * @throws SkypeException when connection has gone bad or ERROR reply.
 */
public static User[] searchUsers(String keyword) throws SkypeException {
  String command=""String_Node_Str"" + keyword;
  String responseHeader=""String_Node_Str"";
  String response;
  try {
    response=Connector.getInstance().executeWithId(command,responseHeader);
  }
 catch (  ConnectorException ex) {
    Utils.convertToSkypeException(ex);
    return null;
  }
  Utils.checkError(response);
  String data=response.substring(responseHeader.length());
  String[] ids=Utils.convertToArray(data);
  User[] users=new User[ids.length];
  for (int i=0; i < ids.length; ++i) {
    users[i]=User.getInstance(ids[i]);
  }
  return users;
}",0.5251959686450168
3144,"/** 
 * Sets the Skype silent mode.
 * @param on if true turn on the silent mode.
 * @return true if the user responds ok.
 * @throws SkypeException when connection has gone bad or ERROR reply.
 * @since 2.6.0.84
 */
public static boolean setSilentMode(boolean on) throws SkypeException {
  try {
    String command=""String_Node_Str"" + (on ? ""String_Node_Str"" : ""String_Node_Str"");
    String responseHeader=""String_Node_Str"";
    String response=Connector.getInstance().executeWithoutTimeout(command,responseHeader);
    Utils.checkError(response);
    String responseValue=response.substring(responseHeader.length());
    return ""String_Node_Str"".equals(responseValue);
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
    return false;
  }
}","/** 
 * Sets the Skype silent mode.
 * @param on if true turn on the silent mode.
 * @return true if the user responds ok.
 * @throws SkypeException when connection has gone bad or ERROR reply.
 * @since 2.6.0.84
 */
public static boolean setSilentMode(boolean on) throws SkypeException {
  try {
    String command=""String_Node_Str"" + (on ? ""String_Node_Str"" : ""String_Node_Str"");
    String responseHeader=""String_Node_Str"";
    String response=Connector.getInstance().execute(command,responseHeader);
    Utils.checkError(response);
    String responseValue=response.substring(responseHeader.length());
    return ""String_Node_Str"".equals(responseValue);
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
    return false;
  }
}",0.9908376963350786
3145,"/** 
 * Send a Skype command to Skype (actual implementation method) and wait for response.
 * @param command the command to send.
 * @param responseHeaders The expected response headers.
 * @param checkAttached if true the connector will first check if it is connected.
 * @param withoutTimeout if true the command has no timeout
 * @return the response.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
private String execute(final String command,final String[] responseHeaders,final boolean checkAttached,boolean withoutTimeout) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",command);
  ConnectorUtils.checkNotNull(""String_Node_Str"",responseHeaders);
  if (checkAttached) {
    assureAttached();
  }
  final Object wait=new Object();
  final String[] response=new String[1];
  ConnectorListener listener=new AbstractConnectorListener(){
    public void messageReceived(    ConnectorMessageEvent event){
      String message=event.getMessage();
      for (      String responseHeader : responseHeaders) {
        if (message.startsWith(responseHeader)) {
          response[0]=message;
synchronized (wait) {
            wait.notify();
          }
          return;
        }
      }
    }
  }
;
  addConnectorListener(listener,false);
synchronized (wait) {
    try {
      fireMessageSent(command);
      sendCommand(command);
      if (withoutTimeout) {
        wait.wait();
      }
 else {
        long start=System.currentTimeMillis();
        long commandResponseTime=getCommandTimeout();
        wait.wait(commandResponseTime);
        if (commandResponseTime != 0 && commandResponseTime <= System.currentTimeMillis() - start) {
          setStatus(Status.NOT_RUNNING);
          throw new NotAttachedException(Status.NOT_RUNNING);
        }
      }
    }
 catch (    InterruptedException e) {
      throw new ConnectorException(""String_Node_Str"" + command + ""String_Node_Str"");
    }
 finally {
      removeConnectorListener(listener);
    }
  }
  return response[0];
}","/** 
 * Send a Skype command to Skype (actual implementation method) and wait for response.
 * @param command the command to send.
 * @param responseHeaders The expected response headers.
 * @param checkAttached if true the connector will first check if it is connected.
 * @return the response.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
public String execute(final String command,final String[] responseHeaders,final boolean checkAttached) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",command);
  ConnectorUtils.checkNotNull(""String_Node_Str"",responseHeaders);
  if (checkAttached) {
    assureAttached();
  }
  final BlockingQueue<String> responses=new LinkedBlockingQueue<String>();
  ConnectorListener listener=new AbstractConnectorListener(){
    public void messageReceived(    ConnectorMessageEvent event){
      String message=event.getMessage();
      for (      String responseHeader : responseHeaders) {
        if (message.startsWith(responseHeader) || message.startsWith(""String_Node_Str"")) {
          responses.add(message);
          return;
        }
      }
    }
  }
;
  addConnectorListener(listener,false);
  fireMessageSent(command);
  sendCommand(command);
  try {
    boolean pinged=false;
    while (true) {
      String response;
      try {
        response=responses.poll(getCommandTimeout(),TimeUnit.MILLISECONDS);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new ConnectorException(""String_Node_Str"" + command + ""String_Node_Str"");
      }
      if (response == null) {
        if (pinged) {
          setStatus(Status.NOT_RUNNING);
          throw new NotAttachedException(Status.NOT_RUNNING);
        }
 else {
          fireMessageSent(""String_Node_Str"");
          sendCommand(""String_Node_Str"");
          pinged=true;
          continue;
        }
      }
      if (response.startsWith(""String_Node_Str"")) {
        pinged=false;
        continue;
      }
 else {
        return response;
      }
    }
  }
  finally {
    removeConnectorListener(listener);
  }
}",0.6418870621872766
3146,"public void messageReceived(ConnectorMessageEvent event){
  String message=event.getMessage();
  for (  String responseHeader : responseHeaders) {
    if (message.startsWith(responseHeader)) {
      response[0]=message;
synchronized (wait) {
        wait.notify();
      }
      return;
    }
  }
}","public void messageReceived(ConnectorMessageEvent event){
  String message=event.getMessage();
  for (  String responseHeader : responseHeaders) {
    if (message.startsWith(responseHeader) || message.startsWith(""String_Node_Str"")) {
      responses.add(message);
      return;
    }
  }
}",0.7563884156729132
3147,"/** 
 * Initializes the AP2AP.
 * @throws SkypeException when connection is gone bad. if connection could not be established.
 */
void initialize() throws SkypeException {
  try {
    String response=Connector.getInstance().execute(""String_Node_Str"" + name);
    Utils.checkError(response);
    Connector.getInstance().addConnectorListener(dataListener);
    shutdownHookForFinish=new Thread(){
      @Override public void run(){
        try {
          Connector.getInstance().execute(""String_Node_Str"" + Application.this.getName());
        }
 catch (        ConnectorException e) {
        }
      }
    }
;
    Runtime.getRuntime().addShutdownHook(shutdownHookForFinish);
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
  }
}","/** 
 * Initializes the AP2AP.
 * @throws SkypeException when connection is gone bad. if connection could not be established.
 */
void initialize() throws SkypeException {
  try {
    String response=Connector.getInstance().execute(""String_Node_Str"" + name);
    Utils.checkError(response);
    Connector.getInstance().addConnectorListener(dataListener,true,true);
    shutdownHookForFinish=new Thread(){
      @Override public void run(){
        try {
          Connector.getInstance().execute(""String_Node_Str"" + Application.this.getName());
        }
 catch (        ConnectorException e) {
        }
      }
    }
;
    Runtime.getRuntime().addShutdownHook(shutdownHookForFinish);
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
  }
}",0.9934383202099738
3148,"public static void main(String[] args) throws Exception {
  Skype.setDebug(true);
  Skype.setDeamon(false);
  String name=A2AClient.class.getName();
  Stream[] streams=connectToServer(name);
  for (int i=0; i < 25; i++) {
    for (    Stream stream : streams) {
      stream.write(createData(i,(char)('a' + i)));
    }
  }
  for (  Stream stream : streams) {
    stream.disconnect();
  }
}","public static void main(String[] args) throws Exception {
  Skype.setDebug(true);
  Skype.setDeamon(false);
  String name=A2AClient.class.getName();
  Stream[] streams=connectToServer(name);
  for (int i=0; i < 26; i++) {
    for (    Stream stream : streams) {
      stream.write(createData(i + 1,(char)('a' + i)));
    }
  }
  Thread.sleep(5000);
  for (  Stream stream : streams) {
    stream.disconnect();
  }
}",0.965174129353234
3149,"@Override public void connected(Stream stream) throws SkypeException {
  System.out.println(""String_Node_Str"" + stream.getId());
  stream.addStreamListener(new StreamAdapter(){
    @Override public void textReceived(    String receivedText) throws SkypeException {
      System.out.println(""String_Node_Str"" + Integer.toHexString(receivedText.length()));
    }
  }
);
}","@Override public void connected(Stream stream) throws SkypeException {
  System.out.println(""String_Node_Str"" + stream.getId());
  stream.addStreamListener(new StreamAdapter(){
    @Override public void textReceived(    String receivedText) throws SkypeException {
      System.out.println(""String_Node_Str"" + receivedText);
    }
  }
);
}",0.9576271186440678
3150,"@Override public void textReceived(String receivedText) throws SkypeException {
  System.out.println(""String_Node_Str"" + Integer.toHexString(receivedText.length()));
}","@Override public void textReceived(String receivedText) throws SkypeException {
  System.out.println(""String_Node_Str"" + receivedText);
}",0.9013157894736842
3151,"public static void main(String[] args) throws Exception {
  Skype.setDebug(true);
  Skype.setDeamon(false);
  Application application=Skype.addApplication(A2AClient.class.getName());
  application.addApplicationListener(new ApplicationAdapter(){
    @Override public void connected(    Stream stream) throws SkypeException {
      System.out.println(""String_Node_Str"" + stream.getId());
      stream.addStreamListener(new StreamAdapter(){
        @Override public void textReceived(        String receivedText) throws SkypeException {
          System.out.println(""String_Node_Str"" + Integer.toHexString(receivedText.length()));
        }
      }
);
    }
  }
);
}","public static void main(String[] args) throws Exception {
  Skype.setDebug(true);
  Skype.setDeamon(false);
  Application application=Skype.addApplication(A2AClient.class.getName());
  application.addApplicationListener(new ApplicationAdapter(){
    @Override public void connected(    Stream stream) throws SkypeException {
      System.out.println(""String_Node_Str"" + stream.getId());
      stream.addStreamListener(new StreamAdapter(){
        @Override public void textReceived(        String receivedText) throws SkypeException {
          System.out.println(""String_Node_Str"" + receivedText);
        }
      }
);
    }
  }
);
}",0.9614791987673345
3152,"/** 
 * Setup an AP2AP connection with members.
 * @param ids The member IDs to start a AP2AP with.
 * @return The connected streams.
 * @throws SkypeException when connection is gone bad.
 */
public Stream[] connect(final String... ids) throws SkypeException {
  Utils.checkNotNull(""String_Node_Str"",ids);
synchronized (connectMutex) {
    try {
      final Object wait=new Object();
      ConnectorListener connectorListener=new AbstractConnectorListener(){
        public void messageReceived(        ConnectorMessageEvent event){
          String message=event.getMessage();
          if (message.equals(""String_Node_Str"" + getName() + ""String_Node_Str"")) {
synchronized (wait) {
              wait.notify();
            }
          }
        }
      }
;
      try {
        Connector.getInstance().addConnectorListener(connectorListener);
synchronized (wait) {
          for (          String skypeId : ids) {
            if (skypeId != null) {
              String result=Connector.getInstance().execute(""String_Node_Str"" + getName() + ""String_Node_Str""+ skypeId);
              Utils.checkError(result);
            }
          }
          try {
            wait.wait();
          }
 catch (          InterruptedException e) {
            throw new SkypeException(""String_Node_Str"",e);
          }
        }
        return getAllStreams(ids);
      }
 catch (      ConnectorException e) {
        Utils.convertToSkypeException(e);
        return null;
      }
 finally {
        Connector.getInstance().removeConnectorListener(connectorListener);
      }
    }
 catch (    SkypeException e) {
      for (      Stream stream : getAllStreams(ids)) {
        try {
          stream.disconnect();
        }
 catch (        SkypeException e2) {
        }
      }
      throw e;
    }
  }
}","/** 
 * Setup an AP2AP connection with members.
 * @param ids The member IDs to start a AP2AP with.
 * @return The connected streams.
 * @throws SkypeException when connection is gone bad.
 */
public Stream[] connect(final String... ids) throws SkypeException {
  Utils.checkNotNull(""String_Node_Str"",ids);
synchronized (connectMutex) {
    try {
      final Object wait=new Object();
      ConnectorListener connectorListener=new AbstractConnectorListener(){
        public void messageReceived(        ConnectorMessageEvent event){
          String message=event.getMessage();
          if (message.equals(""String_Node_Str"" + getName() + ""String_Node_Str"")) {
synchronized (wait) {
              wait.notify();
            }
          }
 else           if (message.startsWith(""String_Node_Str"" + getName() + ""String_Node_Str"")) {
            String streamIds=message.substring((""String_Node_Str"" + getName() + ""String_Node_Str"").length());
            if (""String_Node_Str"".equals(streamIds)) {
              return;
            }
            for (            String streamId : streamIds.split(""String_Node_Str"")) {
              for (              String id : ids) {
                if (streamId.startsWith(id + ""String_Node_Str"")) {
synchronized (wait) {
                    wait.notify();
                    return;
                  }
                }
              }
            }
          }
        }
      }
;
      try {
        Connector.getInstance().addConnectorListener(connectorListener);
synchronized (wait) {
          for (          String skypeId : ids) {
            if (skypeId != null) {
              String result=Connector.getInstance().execute(""String_Node_Str"" + getName() + ""String_Node_Str""+ skypeId);
              Utils.checkError(result);
            }
          }
          try {
            wait.wait();
          }
 catch (          InterruptedException e) {
            throw new SkypeException(""String_Node_Str"",e);
          }
        }
        return getAllStreams(ids);
      }
 catch (      ConnectorException e) {
        Utils.convertToSkypeException(e);
        return null;
      }
 finally {
        Connector.getInstance().removeConnectorListener(connectorListener);
      }
    }
 catch (    SkypeException e) {
      for (      Stream stream : getAllStreams(ids)) {
        try {
          stream.disconnect();
        }
 catch (        SkypeException e2) {
        }
      }
      throw e;
    }
  }
}",0.8438162544169612
3153,"/** 
 * Add an AP2AP capable application.
 * @param name The name of the AP2AP application.
 * @return Application object reference.
 * @throws SkypeException when connection has gone bad or ERROR reply.
 */
public static Application addApplication(String name) throws SkypeException {
  return Application.getInstance(name);
}","/** 
 * Add an AP2AP capable application.
 * @param name The name of the AP2AP application.
 * @return Application object reference.
 * @throws SkypeException when connection has gone bad or ERROR reply.
 */
public static Application addApplication(String name) throws SkypeException {
  Utils.checkNotNull(""String_Node_Str"",name);
  return Application.getInstance(name);
}",0.8514285714285714
3154,"public void clearPlayer() throws ConnectorException {
synchronized (playingFieldsMutex) {
    playerCleared=true;
    playerThread.interrupt();
    playerThread=null;
    Connector.getInstance().removeConnectorListener(playingLister);
    playingLister=null;
    player=null;
    Connector.setInstance(null);
  }
}","public void clearPlayer() throws ConnectorException {
synchronized (playingFieldsMutex) {
    playerThread.interrupt();
    playerThread=null;
    Connector.getInstance().removeConnectorListener(playingLister);
    playingLister=null;
    player=null;
    Connector.setInstance(null);
  }
}",0.4503311258278146
3155,"public void setPlayer(final Player player) throws ConnectorException {
synchronized (playingFieldsMutex) {
    Connector.setInstance(this);
    Connector.getInstance().connect();
    if (this.player != null) {
      clearPlayer();
    }
    this.player=player;
    playingLister=new AbstractConnectorListener(){
      @Override public void messageSent(      ConnectorMessageEvent event){
synchronized (sentMessageFieldsMutex) {
          while (sentMessage != null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              return;
            }
          }
          sentMessage=event.getMessage();
          sentMessageFieldsMutex.notify();
        }
      }
    }
;
    Connector.getInstance().addConnectorListener(playingLister,false,true);
    playerCleared=false;
    playerThread=new Thread(""String_Node_Str""){
      @Override public void run(){
        try {
          player.init();
          long startTime=System.currentTimeMillis();
          while (player.hasNextMessage()) {
            PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
                while (sentMessage == null) {
                  try {
                    sentMessageFieldsMutex.wait();
                  }
 catch (                  InterruptedException e) {
                    if (playerCleared) {
                      return;
                    }
                  }
                }
                String sentMessage=TestConnector.this.sentMessage;
                TestConnector.this.sentMessage=null;
                sentMessageFieldsMutex.notify();
                if (!message.getMessage().equals(sentMessage)) {
                  throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
                }
              }
            break;
case RECEIVED:
          long period=System.currentTimeMillis() - startTime - message.getTime();
        if (period < 0) {
          try {
            Thread.sleep(-period);
          }
 catch (          InterruptedException e) {
            if (playerCleared) {
              return;
            }
          }
        }
      fireMessageReceived(message.getMessage());
    break;
}
if (playerCleared) {
  return;
}
}
}
  finally {
player.destory();
}
}
}
;
playerThread.setDaemon(true);
playerThread.start();
}
}","public void setPlayer(final Player player) throws ConnectorException {
synchronized (playingFieldsMutex) {
    Connector.setInstance(this);
    Connector.getInstance().connect();
    if (this.player != null) {
      clearPlayer();
    }
    this.player=player;
    playingLister=new AbstractConnectorListener(){
      @Override public void messageSent(      ConnectorMessageEvent event){
        if (event.getMessage().startsWith(""String_Node_Str"")) {
          return;
        }
synchronized (sentMessageFieldsMutex) {
          while (sentMessage != null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
              return;
            }
          }
          sentMessage=event.getMessage();
          sentMessageFieldsMutex.notify();
        }
      }
    }
;
    Connector.getInstance().addConnectorListener(playingLister,false,true);
    playerThread=new Thread(""String_Node_Str""){
      @Override public void run(){
        try {
          player.init();
          long startTime=System.currentTimeMillis();
          while (player.hasNextMessage()) {
            PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
                while (sentMessage == null) {
                  try {
                    sentMessageFieldsMutex.wait();
                  }
 catch (                  InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                  }
                }
                String sentMessage=TestConnector.this.sentMessage;
                TestConnector.this.sentMessage=null;
                sentMessageFieldsMutex.notify();
                if (!message.getMessage().equals(sentMessage)) {
                  throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
                }
              }
            break;
case RECEIVED:
          long period=System.currentTimeMillis() - startTime - message.getTime();
        if (period < 0) {
          try {
            Thread.sleep(-period);
          }
 catch (          InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
          }
        }
      fireMessageReceived(message.getMessage());
    break;
}
if (Thread.currentThread().isInterrupted()) {
  return;
}
}
}
  finally {
player.destory();
}
}
}
;
playerThread.setDaemon(true);
playerThread.start();
}
}",0.8384433962264151
3156,"@Override public void run(){
  try {
    player.init();
    long startTime=System.currentTimeMillis();
    while (player.hasNextMessage()) {
      PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
          while (sentMessage == null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              if (playerCleared) {
                return;
              }
            }
          }
          String sentMessage=TestConnector.this.sentMessage;
          TestConnector.this.sentMessage=null;
          sentMessageFieldsMutex.notify();
          if (!message.getMessage().equals(sentMessage)) {
            throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
          }
        }
      break;
case RECEIVED:
    long period=System.currentTimeMillis() - startTime - message.getTime();
  if (period < 0) {
    try {
      Thread.sleep(-period);
    }
 catch (    InterruptedException e) {
      if (playerCleared) {
        return;
      }
    }
  }
fireMessageReceived(message.getMessage());
break;
}
if (playerCleared) {
return;
}
}
}
  finally {
player.destory();
}
}","@Override public void run(){
  try {
    player.init();
    long startTime=System.currentTimeMillis();
    while (player.hasNextMessage()) {
      PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
          while (sentMessage == null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
              return;
            }
          }
          String sentMessage=TestConnector.this.sentMessage;
          TestConnector.this.sentMessage=null;
          sentMessageFieldsMutex.notify();
          if (!message.getMessage().equals(sentMessage)) {
            throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
          }
        }
      break;
case RECEIVED:
    long period=System.currentTimeMillis() - startTime - message.getTime();
  if (period < 0) {
    try {
      Thread.sleep(-period);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      return;
    }
  }
fireMessageReceived(message.getMessage());
break;
}
if (Thread.currentThread().isInterrupted()) {
return;
}
}
}
  finally {
player.destory();
}
}",0.8241129339946586
3157,"@Override public void messageSent(ConnectorMessageEvent event){
synchronized (sentMessageFieldsMutex) {
    while (sentMessage != null) {
      try {
        sentMessageFieldsMutex.wait();
      }
 catch (      InterruptedException e) {
        return;
      }
    }
    sentMessage=event.getMessage();
    sentMessageFieldsMutex.notify();
  }
}","@Override public void messageSent(ConnectorMessageEvent event){
  if (event.getMessage().startsWith(""String_Node_Str"")) {
    return;
  }
synchronized (sentMessageFieldsMutex) {
    while (sentMessage != null) {
      try {
        sentMessageFieldsMutex.wait();
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        return;
      }
    }
    sentMessage=event.getMessage();
    sentMessageFieldsMutex.notify();
  }
}",0.8539603960396039
3158,"/** 
 * Send a Skype command to Skype (actual implementation method) and wait for response.
 * @param command the command to send.
 * @param responseHeaders The expected response headers.
 * @param checkAttached if true the connector will first check if it is connected.
 * @param withoutTimeout if true the command has no timeout
 * @return the response.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
private String execute(final String command,final String[] responseHeaders,final boolean checkAttached,boolean withoutTimeout) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",command);
  ConnectorUtils.checkNotNull(""String_Node_Str"",responseHeaders);
  if (checkAttached) {
    assureAttached();
  }
  final Object wait=new Object();
  final String[] response=new String[1];
  ConnectorListener listener=new AbstractConnectorListener(){
    public void messageReceived(    ConnectorMessageEvent event){
      String message=event.getMessage();
      for (      String responseHeader : responseHeaders) {
        if (message.startsWith(responseHeader)) {
          response[0]=message;
synchronized (wait) {
            wait.notify();
          }
          return;
        }
      }
    }
  }
;
  addConnectorListener(listener,false);
  fireMessageSent(command);
synchronized (wait) {
    try {
      sendCommand(command);
      if (withoutTimeout) {
        wait.wait();
      }
 else {
        long start=System.currentTimeMillis();
        long commandResponseTime=getCommandTimeout();
        wait.wait(commandResponseTime);
        if (commandResponseTime <= System.currentTimeMillis() - start) {
          setStatus(Status.NOT_RUNNING);
          throw new NotAttachedException(Status.NOT_RUNNING);
        }
      }
    }
 catch (    InterruptedException e) {
      throw new ConnectorException(""String_Node_Str"" + command + ""String_Node_Str"");
    }
 finally {
      removeConnectorListener(listener);
    }
  }
  return response[0];
}","/** 
 * Send a Skype command to Skype (actual implementation method) and wait for response.
 * @param command the command to send.
 * @param responseHeaders The expected response headers.
 * @param checkAttached if true the connector will first check if it is connected.
 * @param withoutTimeout if true the command has no timeout
 * @return the response.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
private String execute(final String command,final String[] responseHeaders,final boolean checkAttached,boolean withoutTimeout) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",command);
  ConnectorUtils.checkNotNull(""String_Node_Str"",responseHeaders);
  if (checkAttached) {
    assureAttached();
  }
  final Object wait=new Object();
  final String[] response=new String[1];
  ConnectorListener listener=new AbstractConnectorListener(){
    public void messageReceived(    ConnectorMessageEvent event){
      String message=event.getMessage();
      for (      String responseHeader : responseHeaders) {
        if (message.startsWith(responseHeader)) {
          response[0]=message;
synchronized (wait) {
            wait.notify();
          }
          return;
        }
      }
    }
  }
;
  addConnectorListener(listener,false);
synchronized (wait) {
    try {
      fireMessageSent(command);
      sendCommand(command);
      if (withoutTimeout) {
        wait.wait();
      }
 else {
        long start=System.currentTimeMillis();
        long commandResponseTime=getCommandTimeout();
        wait.wait(commandResponseTime);
        if (commandResponseTime <= System.currentTimeMillis() - start) {
          setStatus(Status.NOT_RUNNING);
          throw new NotAttachedException(Status.NOT_RUNNING);
        }
      }
    }
 catch (    InterruptedException e) {
      throw new ConnectorException(""String_Node_Str"" + command + ""String_Node_Str"");
    }
 finally {
      removeConnectorListener(listener);
    }
  }
  return response[0];
}",0.9831932773109244
3159,"public void setPlayer(final Player player) throws ConnectorException {
synchronized (playingFieldsMutex) {
    Connector.setInstance(this);
    Connector.getInstance().connect();
    if (this.player != null) {
      clearPlayer();
    }
    this.player=player;
    playingLister=new AbstractConnectorListener(){
      @Override public void messageSent(      ConnectorMessageEvent event){
synchronized (sentMessageFieldsMutex) {
          while (sentMessage != null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              return;
            }
          }
          sentMessage=event.getMessage();
          sentMessageFieldsMutex.notify();
        }
      }
    }
;
    Connector.getInstance().addConnectorListener(playingLister);
    playerCleared=false;
    playerThread=new Thread(""String_Node_Str""){
      @Override public void run(){
        try {
          player.init();
          long startTime=System.currentTimeMillis();
          while (player.hasNextMessage()) {
            PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
                while (sentMessage == null) {
                  try {
                    sentMessageFieldsMutex.wait();
                  }
 catch (                  InterruptedException e) {
                    if (playerCleared) {
                      return;
                    }
                  }
                }
                String sentMessage=TestConnector.this.sentMessage;
                TestConnector.this.sentMessage=null;
                sentMessageFieldsMutex.notify();
                if (!message.getMessage().equals(sentMessage)) {
                  throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
                }
              }
            break;
case RECEIVED:
          long period=System.currentTimeMillis() - startTime - message.getTime();
        if (period < 0) {
          try {
            Thread.sleep(-period);
          }
 catch (          InterruptedException e) {
            if (playerCleared) {
              return;
            }
          }
        }
      fireMessageReceived(message.getMessage());
    break;
}
if (playerCleared) {
  return;
}
}
}
  finally {
player.destory();
}
}
}
;
playerThread.setDaemon(true);
playerThread.start();
}
}","public void setPlayer(final Player player) throws ConnectorException {
synchronized (playingFieldsMutex) {
    Connector.setInstance(this);
    Connector.getInstance().connect();
    if (this.player != null) {
      clearPlayer();
    }
    this.player=player;
    playingLister=new AbstractConnectorListener(){
      @Override public void messageSent(      ConnectorMessageEvent event){
synchronized (sentMessageFieldsMutex) {
          while (sentMessage != null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              return;
            }
          }
          sentMessage=event.getMessage();
          sentMessageFieldsMutex.notify();
        }
      }
    }
;
    Connector.getInstance().addConnectorListener(playingLister,false,true);
    playerCleared=false;
    playerThread=new Thread(""String_Node_Str""){
      @Override public void run(){
        try {
          player.init();
          long startTime=System.currentTimeMillis();
          while (player.hasNextMessage()) {
            PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
                while (sentMessage == null) {
                  try {
                    sentMessageFieldsMutex.wait();
                  }
 catch (                  InterruptedException e) {
                    if (playerCleared) {
                      return;
                    }
                  }
                }
                String sentMessage=TestConnector.this.sentMessage;
                TestConnector.this.sentMessage=null;
                sentMessageFieldsMutex.notify();
                if (!message.getMessage().equals(sentMessage)) {
                  throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
                }
              }
            break;
case RECEIVED:
          long period=System.currentTimeMillis() - startTime - message.getTime();
        if (period < 0) {
          try {
            Thread.sleep(-period);
          }
 catch (          InterruptedException e) {
            if (playerCleared) {
              return;
            }
          }
        }
      fireMessageReceived(message.getMessage());
    break;
}
if (playerCleared) {
  return;
}
}
}
  finally {
player.destory();
}
}
}
;
playerThread.setDaemon(true);
playerThread.start();
}
}",0.9977755308392317
3160,"public void addRecorder(final Recorder recorder) throws ConnectorException {
synchronized (recordingFieldsMutex) {
    Connector.getInstance().connect();
    if (recordListener == null) {
      recordListener=new AbstractConnectorListener(){
        @Override public void messageSent(        ConnectorMessageEvent event){
          long time=System.currentTimeMillis();
          Recorder[] recorders=TestConnector.this.recorders;
          for (          Recorder recorder : recorders) {
            recorder.recordSentMessage(time - recorder.getStartTime(),event.getMessage());
          }
        }
        @Override public void messageReceived(        ConnectorMessageEvent event){
          long time=System.currentTimeMillis();
          Recorder[] recorders=TestConnector.this.recorders;
          for (          Recorder recorder : recorders) {
            recorder.recordReceivedMessage(time - recorder.getStartTime(),event.getMessage());
          }
        }
      }
;
      Connector.getInstance().addConnectorListener(recordListener);
    }
    if (recorderList == null) {
      recorderList=new ArrayList<Recorder>();
    }
    if (!recorderList.contains(recorder)) {
      recorderList.add(recorder);
      recorders=recorderList.toArray(new Recorder[0]);
      if (!recorder.isStarted()) {
        recorder.setStartTime(System.currentTimeMillis());
      }
    }
  }
}","public void addRecorder(final Recorder recorder) throws ConnectorException {
synchronized (recordingFieldsMutex) {
    Connector.getInstance().connect();
    if (recordListener == null) {
      recordListener=new AbstractConnectorListener(){
        @Override public void messageSent(        ConnectorMessageEvent event){
          long time=System.currentTimeMillis();
          Recorder[] recorders=TestConnector.this.recorders;
          for (          Recorder recorder : recorders) {
            recorder.recordSentMessage(time - recorder.getStartTime(),event.getMessage());
          }
        }
        @Override public void messageReceived(        ConnectorMessageEvent event){
          long time=System.currentTimeMillis();
          Recorder[] recorders=TestConnector.this.recorders;
          for (          Recorder recorder : recorders) {
            recorder.recordReceivedMessage(time - recorder.getStartTime(),event.getMessage());
          }
        }
      }
;
      Connector.getInstance().addConnectorListener(recordListener,false,true);
    }
    if (recorderList == null) {
      recorderList=new ArrayList<Recorder>();
    }
    if (!recorderList.contains(recorder)) {
      recorderList.add(recorder);
      recorders=recorderList.toArray(new Recorder[0]);
      if (!recorder.isStarted()) {
        recorder.setStartTime(System.currentTimeMillis());
      }
    }
  }
}",0.9960417416336812
3161,"/** 
 * Check if this User has a Skype client that can do video chats.
 * @return true if User can do videochats.
 */
public final boolean isVideoCapable(){
  return Boolean.parseBoolean(""String_Node_Str"");
}","/** 
 * Check if this User has a Skype client that can do video chats.
 * @return true if User can do videochats.
 * @throws SkypeException when connection to Skype client has gone bad. 
 */
public final boolean isVideoCapable() throws SkypeException {
  return Boolean.parseBoolean(getProperty(""String_Node_Str""));
}",0.7923809523809524
3162,"/** 
 * Initialize the connection to Skype API.
 * @param timeout Wait for this amout of millisecs to initialize.
 */
protected void initialize(int timeout){
  if (!inited) {
    inited=true;
    (new Thread(this)).start();
    setStatus(com.skype.connector.Connector.Status.PENDING_AUTHORIZATION);
    fireMessageReceived(""String_Node_Str"");
    setDebugPrinting(false);
    init(getApplicationName());
  }
}","/** 
 * Initialize the connection to Skype API.
 * @param timeout Wait for this amout of millisecs to initialize.
 */
protected void initialize(int timeout){
  if (!inited) {
    inited=true;
    if (isSWTAvailable()) {
      try {
        Class displayClass=Class.forName(""String_Node_Str"");
        Method getCurrentMethod=displayClass.getMethod(""String_Node_Str"",null);
        Class[] params=new Class[1];
        params[0]=Class.forName(""String_Node_Str"");
        Method asyncExecMethod=displayClass.getMethod(""String_Node_Str"",params);
        Object display=getCurrentMethod.invoke(null,null);
        Object[] args=new Object[1];
        args[0]=this;
        asyncExecMethod.invoke(display,args);
      }
 catch (      Throwable e) {
        (new Thread(this)).start();
      }
    }
 else {
      (new Thread(this)).start();
    }
    setStatus(com.skype.connector.Connector.Status.PENDING_AUTHORIZATION);
    fireMessageReceived(""String_Node_Str"");
    setDebugPrinting(false);
    init(getApplicationName());
  }
}",0.541782729805014
3163,"/** 
 * Add a listener to this connector if the connector is attached.
 * @param listener The listener to add.
 * @param checkAttached if true check if connector is attached.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
protected final void addConnectorListener(final ConnectorListener listener,boolean checkAttached) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",listener);
  listeners.add(ConnectorListener.class,listener);
  if (checkAttached) {
    assureAttached();
  }
}","/** 
 * Add a listener to this connector if the connector is attached.
 * @param listener The listener to add.
 * @param checkAttached if true check if connector is attached.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
public final void addConnectorListener(final ConnectorListener listener,boolean checkAttached) throws ConnectorException {
  ConnectorUtils.checkNotNull(""String_Node_Str"",listener);
  listeners.add(ConnectorListener.class,listener);
  if (checkAttached) {
    assureAttached();
  }
}",0.9882777276825968
3164,"/** 
 * Method to check the attached status of the connector to the Skype Client. If it isn't connected it will connect.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
private void assureAttached() throws ConnectorException {
  Status attachedStatus=getStatus();
  if (attachedStatus != Status.ATTACHED) {
    attachedStatus=connect();
    attachedStatus=getStatus();
    if (attachedStatus != Status.ATTACHED) {
      System.err.println(""String_Node_Str"" + attachedStatus);
      throw new NotAttachedException(attachedStatus);
    }
  }
}","/** 
 * Method to check the attached status of the connector to the Skype Client. If it isn't connected it will connect.
 * @throws ConnectorException thrown when the connection to the Skype client has gone bad.
 */
private void assureAttached() throws ConnectorException {
  Status attachedStatus=getStatus();
  if (attachedStatus != Status.ATTACHED) {
    attachedStatus=connect();
    if (attachedStatus != Status.ATTACHED) {
      throw new NotAttachedException(attachedStatus);
    }
  }
}",0.9131238447319778
3165,"/** 
 * Set the status of this connector instance.
 * @param newValue The new status.
 */
protected final void setStatus(final Status newValue){
  if (status != newValue) {
    status=newValue;
    fireStatusChanged(newValue);
  }
}","/** 
 * Set the status of this connector instance.
 * @param newValue The new status.
 */
protected final void setStatus(final Status newValue){
  status=newValue;
  fireStatusChanged(newValue);
}",0.9158878504672896
3166,"public void testNotAvailableAfterTryingToConnect() throws Exception {
  TestUtils.showMessageDialog(""String_Node_Str"");
  assertEquals(Connector.Status.NOT_AVAILABLE,WindowsConnector.getInstance().connect());
  final boolean[] available=new boolean[1];
  ConnectorListener listener=new AbstractConnectorListener(){
    public void statusChanged(    ConnectorStatusEvent event){
      Connector.Status status=event.getStatus();
      if (status == Connector.Status.API_AVAILABLE) {
        available[0]=true;
      }
    }
  }
;
  WindowsConnector.getInstance().addConnectorListener(listener);
  TestUtils.showMessageDialog(""String_Node_Str"");
  assertTrue(available[0]);
}","public void testNotAvailableAfterTryingToConnect() throws Exception {
  TestUtils.showMessageDialog(""String_Node_Str"");
  assertEquals(Connector.Status.NOT_AVAILABLE,WindowsConnector.getInstance().connect());
  final boolean[] available=new boolean[1];
  ConnectorListener listener=new AbstractConnectorListener(){
    public void statusChanged(    ConnectorStatusEvent event){
      Connector.Status status=event.getStatus();
      if (status == Connector.Status.API_AVAILABLE) {
        available[0]=true;
      }
    }
  }
;
  WindowsConnector.getInstance().addConnectorListener(listener,false);
  TestUtils.showMessageDialog(""String_Node_Str"");
  assertTrue(available[0]);
}",0.9955555555555556
3167,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object compared){
  if (compared instanceof CallForwardingRule) {
    return toString().equals(((Profile)compared).toString());
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object compared){
  if (compared instanceof CallForwardingRule) {
    return toString().equals(((CallForwardingRule)compared).toString());
  }
  return false;
}",0.7482352941176471
3168,"public void setPlayer(final Player player) throws ConnectorException {
synchronized (playingFieldsMutex) {
    Connector.setInstance(this);
    Connector.getInstance().connect();
    if (this.player != null) {
      clearPlayer();
    }
    this.player=player;
    playingLister=new AbstractConnectorListener(){
      @Override public void messageSent(      ConnectorMessageEvent event){
synchronized (sentMessageFieldsMutex) {
          while (sentMessage != null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              return;
            }
          }
          sentMessage=event.getMessage();
          sentMessageFieldsMutex.notify();
        }
      }
    }
;
    Connector.getInstance().addConnectorListener(playingLister);
    playerCleared=false;
    playerThread=new Thread(""String_Node_Str""){
      @Override public void run(){
        try {
          player.init();
          long startTime=System.currentTimeMillis();
          while (player.hasNextMessage()) {
            PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
                while (sentMessage == null) {
                  try {
                    sentMessageFieldsMutex.wait();
                  }
 catch (                  InterruptedException e) {
                    if (playerCleared) {
                      return;
                    }
                  }
                }
                String sentMessage=TestConnector.this.sentMessage;
                TestConnector.this.sentMessage=null;
                sentMessageFieldsMutex.notify();
                if (!message.getMessage().equals(sentMessage)) {
                  throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
                }
              }
            break;
case RECEIVED:
          long period=System.currentTimeMillis() - startTime - message.getTime();
        if (0 < period) {
          try {
            Thread.sleep(period);
          }
 catch (          InterruptedException e) {
            if (playerCleared) {
              return;
            }
          }
        }
      fireMessageReceived(message.getMessage());
    break;
}
if (playerCleared) {
  return;
}
}
}
  finally {
player.destory();
}
}
}
;
playerThread.setDaemon(true);
playerThread.start();
}
}","public void setPlayer(final Player player) throws ConnectorException {
synchronized (playingFieldsMutex) {
    Connector.setInstance(this);
    Connector.getInstance().connect();
    if (this.player != null) {
      clearPlayer();
    }
    this.player=player;
    playingLister=new AbstractConnectorListener(){
      @Override public void messageSent(      ConnectorMessageEvent event){
synchronized (sentMessageFieldsMutex) {
          while (sentMessage != null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              return;
            }
          }
          sentMessage=event.getMessage();
          sentMessageFieldsMutex.notify();
        }
      }
    }
;
    Connector.getInstance().addConnectorListener(playingLister);
    playerCleared=false;
    playerThread=new Thread(""String_Node_Str""){
      @Override public void run(){
        try {
          player.init();
          long startTime=System.currentTimeMillis();
          while (player.hasNextMessage()) {
            PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
                while (sentMessage == null) {
                  try {
                    sentMessageFieldsMutex.wait();
                  }
 catch (                  InterruptedException e) {
                    if (playerCleared) {
                      return;
                    }
                  }
                }
                String sentMessage=TestConnector.this.sentMessage;
                TestConnector.this.sentMessage=null;
                sentMessageFieldsMutex.notify();
                if (!message.getMessage().equals(sentMessage)) {
                  throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
                }
              }
            break;
case RECEIVED:
          long period=System.currentTimeMillis() - startTime - message.getTime();
        if (period < 0) {
          try {
            Thread.sleep(-period);
          }
 catch (          InterruptedException e) {
            if (playerCleared) {
              return;
            }
          }
        }
      fireMessageReceived(message.getMessage());
    break;
}
if (playerCleared) {
  return;
}
}
}
  finally {
player.destory();
}
}
}
;
playerThread.setDaemon(true);
playerThread.start();
}
}",0.996148388404622
3169,"@Override public void run(){
  try {
    player.init();
    long startTime=System.currentTimeMillis();
    while (player.hasNextMessage()) {
      PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
          while (sentMessage == null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              if (playerCleared) {
                return;
              }
            }
          }
          String sentMessage=TestConnector.this.sentMessage;
          TestConnector.this.sentMessage=null;
          sentMessageFieldsMutex.notify();
          if (!message.getMessage().equals(sentMessage)) {
            throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
          }
        }
      break;
case RECEIVED:
    long period=System.currentTimeMillis() - startTime - message.getTime();
  if (0 < period) {
    try {
      Thread.sleep(period);
    }
 catch (    InterruptedException e) {
      if (playerCleared) {
        return;
      }
    }
  }
fireMessageReceived(message.getMessage());
break;
}
if (playerCleared) {
return;
}
}
}
  finally {
player.destory();
}
}","@Override public void run(){
  try {
    player.init();
    long startTime=System.currentTimeMillis();
    while (player.hasNextMessage()) {
      PlayerMessage message=player.getNextMessage();
switch (message.getType()) {
case SENT:
synchronized (sentMessageFieldsMutex) {
          while (sentMessage == null) {
            try {
              sentMessageFieldsMutex.wait();
            }
 catch (            InterruptedException e) {
              if (playerCleared) {
                return;
              }
            }
          }
          String sentMessage=TestConnector.this.sentMessage;
          TestConnector.this.sentMessage=null;
          sentMessageFieldsMutex.notify();
          if (!message.getMessage().equals(sentMessage)) {
            throw new IllegalStateException(""String_Node_Str"" + sentMessage + ""String_Node_Str""+ message.getMessage()+ ""String_Node_Str"");
          }
        }
      break;
case RECEIVED:
    long period=System.currentTimeMillis() - startTime - message.getTime();
  if (period < 0) {
    try {
      Thread.sleep(-period);
    }
 catch (    InterruptedException e) {
      if (playerCleared) {
        return;
      }
    }
  }
fireMessageReceived(message.getMessage());
break;
}
if (playerCleared) {
return;
}
}
}
  finally {
player.destory();
}
}",0.9926725800231392
3170,"/** 
 * Extract a file for a jarfile on the classpath. Used to extract library files.
 * @param searchString The path+filename to search for.
 * @param filename The file to search and extract.
 * @param destinationDirectory The directory to place it in.
 * @return true if file could be found and extracted.
 */
public static boolean extractFromJar(String searchString,String filename,String destinationDirectory){
  boolean extracted=false;
  String classpath=System.getProperty(""String_Node_Str"");
  File jarfile=null;
  byte[] buf=new byte[1024];
  String jarFileName;
  StringTokenizer st=new StringTokenizer(classpath,File.pathSeparator);
  while (st.hasMoreTokens() && !extracted) {
    jarFileName=st.nextToken();
    jarfile=new File(jarFileName);
    if (jarfile.exists() && jarfile.isFile()) {
      FileInputStream fis=null;
      try {
        fis=new FileInputStream(jarFileName);
        BufferedInputStream bis=new BufferedInputStream(fis);
        ZipInputStream zis=new ZipInputStream(bis);
        ZipEntry ze=null;
        while ((ze=zis.getNextEntry()) != null) {
          if (ze.getName().endsWith(searchString)) {
            if (!destinationDirectory.endsWith(File.separator)) {
              destinationDirectory=destinationDirectory + File.separator;
            }
            File destFile=new File(destinationDirectory + filename);
            if (destFile.exists()) {
              destFile.delete();
            }
            int n;
            FileOutputStream fileoutputstream;
            fileoutputstream=new FileOutputStream(destinationDirectory + filename);
            while ((n=zis.read(buf,0,1024)) > -1) {
              fileoutputstream.write(buf,0,n);
            }
            fileoutputstream.close();
            extracted=true;
            destFile.deleteOnExit();
          }
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        extracted=false;
      }
    }
  }
  return extracted;
}","/** 
 * Extract a file from a jarfile on the classpath. Used to extract library files.
 * @param searchString The path+filename to search for.
 * @param filename The file to search and extract.
 * @param destinationDirectory The directory to place it in.
 * @return true if file could be found and extracted.
 */
public static boolean extractFromJar(String searchString,String filename,String destinationDirectory){
  boolean extracted=extractFromJarZipMethod(filename,filename,destinationDirectory);
  if (!extracted) {
    extractFromJarUsingClassLoader(filename,filename,destinationDirectory);
  }
  return extracted;
}",0.3475232198142415
3171,"/** 
 * Search for a file in the jars of the classpath, return true if found.
 * @param searchString The path+filename to search for.
 * @return true if file could be found.
 */
public static boolean isInJar(String searchString){
  boolean found=false;
  String classpath=System.getProperty(""String_Node_Str"");
  File jarfile=null;
  String jarFileName;
  StringTokenizer st=new StringTokenizer(classpath,File.pathSeparator);
  while (st.hasMoreTokens() && !found) {
    jarFileName=st.nextToken();
    jarfile=new File(jarFileName);
    if (jarfile.exists() && jarfile.isFile()) {
      FileInputStream fis=null;
      try {
        fis=new FileInputStream(jarFileName);
        BufferedInputStream bis=new BufferedInputStream(fis);
        ZipInputStream zis=new ZipInputStream(bis);
        ZipEntry ze=null;
        while ((ze=zis.getNextEntry()) != null) {
          if (ze.getName().endsWith(searchString)) {
            found=true;
          }
        }
      }
 catch (      Exception e) {
        found=false;
      }
    }
  }
  return found;
}","/** 
 * Search for a file in the jars of the classpath, return true if found.
 * @param searchString The path+filename to search for.
 * @return true if file could be found.
 */
public static boolean isInJar(String searchString){
  boolean found=false;
  String classpath=getExtendedClasspath();
  File jarfile=null;
  String jarFileName;
  StringTokenizer st=new StringTokenizer(classpath,File.pathSeparator);
  while (st.hasMoreTokens() && !found) {
    jarFileName=st.nextToken();
    jarfile=new File(jarFileName);
    if (jarfile.exists() && jarfile.isFile()) {
      FileInputStream fis=null;
      try {
        fis=new FileInputStream(jarFileName);
        BufferedInputStream bis=new BufferedInputStream(fis);
        ZipInputStream zis=new ZipInputStream(bis);
        ZipEntry ze=null;
        while ((ze=zis.getNextEntry()) != null) {
          if (ze.getName().endsWith(searchString)) {
            found=true;
          }
        }
      }
 catch (      Exception e) {
        found=false;
      }
    }
  }
  return found;
}",0.4366937410415671
3172,"/** 
 * Private constructor to keep this a singleton. Use getInstance to get an instance.
 */
private LinuxConnector(){
  try {
    System.loadLibrary(""String_Node_Str"");
  }
 catch (  Exception e) {
    try {
      if (!Utils.checkLibraryInPath(LIBFILENAME)) {
        Utils.extractFromJarToTemp(LIBFILENAME);
        System.load(System.getProperty(""String_Node_Str"") + File.separatorChar + LIBFILENAME);
      }
    }
 catch (    Exception e2) {
      setStatus(Status.NOT_AVAILABLE);
      fireMessageReceived(CONNECTOR_STATUS_CHANGED);
    }
  }
  setStatus(Status.PENDING_AUTHORIZATION);
  fireMessageReceived(CONNECTOR_STATUS_CHANGED);
}","/** 
 * Private constructor to keep this a singleton. Use getInstance to get an instance.
 */
private LinuxConnector(){
  try {
    System.loadLibrary(""String_Node_Str"");
  }
 catch (  Throwable e) {
    try {
      if (!Utils.checkLibraryInPath(LIBFILENAME)) {
        Utils.extractFromJarToTemp(LIBFILENAME);
        System.load(System.getProperty(""String_Node_Str"") + File.separatorChar + LIBFILENAME);
      }
    }
 catch (    Exception e2) {
      setStatus(Status.NOT_AVAILABLE);
      fireMessageReceived(CONNECTOR_STATUS_CHANGED);
    }
  }
  setStatus(Status.PENDING_AUTHORIZATION);
  fireMessageReceived(CONNECTOR_STATUS_CHANGED);
}",0.9860031104199068
3173,"@Override protected void initialize(int timeout){
  try {
    System.loadLibrary(""String_Node_Str"");
  }
 catch (  Exception e) {
    if (!Utils.checkLibraryInPath(LIBFILENAME)) {
      Utils.extractFromJarToTemp(LIBFILENAME);
      System.load(System.getProperty(""String_Node_Str"") + File.separatorChar + LIBFILENAME);
    }
  }
  jni_init();
  thread_=new Thread(new Runnable(){
    public void run(){
      jni_windowProc();
    }
  }
,""String_Node_Str"");
  thread_.setDaemon(true);
  thread_.start();
}","@Override protected void initialize(int timeout){
  try {
    System.loadLibrary(""String_Node_Str"");
  }
 catch (  Throwable e) {
    if (!Utils.checkLibraryInPath(LIBFILENAME)) {
      Utils.extractFromJarToTemp(LIBFILENAME);
      System.load(System.getProperty(""String_Node_Str"") + File.separatorChar + LIBFILENAME);
    }
  }
  jni_init();
  thread_=new Thread(new Runnable(){
    public void run(){
      jni_windowProc();
    }
  }
,""String_Node_Str"");
  thread_.setDaemon(true);
  thread_.start();
}",0.982213438735178
3174,"public void messageReceived(final String message){
  final String dataHeader=""String_Node_Str"" + getName() + ""String_Node_Str"";
  if (isStreamMessage(message)) {
    String streamIds=message.substring((""String_Node_Str"" + getName() + ""String_Node_Str"").length());
    if (!""String_Node_Str"".equals(streamIds)) {
      for (      String streamId : streamIds.split(""String_Node_Str"")) {
        if (streams.containsKey(streamId)) {
          continue;
        }
        int delimiterIndex=streamId.indexOf(':');
        String friendId=streamId.substring(0,delimiterIndex);
        Friend friend;
        try {
          friend=Skype.getContactList().getFriend(friendId);
        }
 catch (        SkypeException e) {
          throw new IllegalStateException(""String_Node_Str"" + friendId);
        }
        int number=Integer.parseInt(streamId.substring(delimiterIndex + 1));
        Stream stream=new Stream(Application.this,friend,number);
        streams.put(streamId,stream);
        fireConnected(stream);
      }
    }
    NEXT:     for (    String existedStreamId : streams.keySet()) {
      if (!""String_Node_Str"".equals(streamIds)) {
        for (        String streamId : streamIds.split(""String_Node_Str"")) {
          if (existedStreamId.equals(streamId)) {
            continue NEXT;
          }
        }
      }
      fireDisconnected(streams.get(existedStreamId));
    }
  }
  if (message.startsWith(dataHeader)) {
    handleData(message.substring(dataHeader.length()));
  }
}","public void messageReceived(final String message){
  String streamsHeader=""String_Node_Str"" + getName() + ""String_Node_Str"";
  if (message.startsWith(streamsHeader)) {
    String streamIds=message.substring(streamsHeader.length());
    fireStreamEvents(streamIds);
  }
  final String dataHeader=""String_Node_Str"" + getName() + ""String_Node_Str"";
  if (message.startsWith(dataHeader)) {
    handleData(message.substring(dataHeader.length()));
  }
}",0.1835997937080969
3175,"public void finish() throws SkypeException {
synchronized (isFinishedFieldMutex) {
    if (!isFinished) {
      try {
        String response=Connector.getInstance().execute(""String_Node_Str"" + getName());
        Utils.checkError(response);
      }
 catch (      ConnectorException e) {
        Utils.convertToSkypeException(e);
      }
      Connector.getInstance().removeConnectorMessageReceivedListener(dataListener);
      Runtime.getRuntime().removeShutdownHook(shutdownHookForFinish);
      isFinished=true;
    }
  }
}","public void finish() throws SkypeException {
synchronized (isFinishedFieldMutex) {
    if (!isFinished) {
      Connector.getInstance().removeConnectorMessageReceivedListener(dataListener);
      Runtime.getRuntime().removeShutdownHook(shutdownHookForFinish);
      isFinished=true;
      try {
        String response=Connector.getInstance().execute(""String_Node_Str"" + getName());
        Utils.checkError(response);
      }
 catch (      ConnectorException e) {
        Utils.convertToSkypeException(e);
      }
    }
  }
}",0.6634980988593155
3176,"void initialize() throws SkypeException {
  try {
    String createResponse=Connector.getInstance().execute(""String_Node_Str"" + name);
    try {
      Utils.checkError(createResponse);
    }
 catch (    SkypeException e) {
      String deleteResponse=Connector.getInstance().execute(""String_Node_Str"" + getName());
      Utils.checkError(deleteResponse);
      String retryResponse=Connector.getInstance().execute(""String_Node_Str"" + name);
      Utils.checkError(retryResponse);
    }
    Connector.getInstance().addConnectorMessageReceivedListener(dataListener);
    shutdownHookForFinish=new Thread(){
      @Override public void run(){
        try {
          Connector.getInstance().execute(""String_Node_Str"" + Application.this.getName());
        }
 catch (        ConnectorException e) {
        }
      }
    }
;
    Runtime.getRuntime().addShutdownHook(shutdownHookForFinish);
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
  }
}","void initialize() throws SkypeException {
  try {
    String response=Connector.getInstance().execute(""String_Node_Str"" + name);
    Utils.checkError(response);
    Connector.getInstance().addConnectorMessageReceivedListener(dataListener);
    shutdownHookForFinish=new Thread(){
      @Override public void run(){
        try {
          Connector.getInstance().execute(""String_Node_Str"" + Application.this.getName());
        }
 catch (        ConnectorException e) {
        }
      }
    }
;
    Runtime.getRuntime().addShutdownHook(shutdownHookForFinish);
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
  }
}",0.795525170913611
3177,"private void handleData(String dataResponse){
  try {
    if (isReceivedText(dataResponse)) {
      String data=dataResponse.substring(""String_Node_Str"".length());
      String streamId=data.substring(0,data.indexOf('='));
      String dataHeader=""String_Node_Str"" + getName() + ""String_Node_Str""+ streamId;
      String response=Connector.getInstance().executeWithId(dataHeader,dataHeader);
      Utils.checkError(response);
      String text=response.substring(dataHeader.length() + 1);
      streams.get(streamId).fireTextReceived(text);
    }
 else     if (isReceivedDatagram(dataResponse)) {
      String data=dataResponse.substring(""String_Node_Str"".length());
      String streamId=data.substring(0,data.indexOf(' '));
      String datagram=data.substring(data.indexOf(' ') + 1);
      streams.get(streamId).fireDatagramReceived(datagram);
    }
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}","private void handleData(String dataResponse){
  try {
    if (isReceivedText(dataResponse)) {
      String data=dataResponse.substring(""String_Node_Str"".length());
      String streamId=data.substring(0,data.indexOf('='));
      String dataHeader=""String_Node_Str"" + getName() + ""String_Node_Str""+ streamId;
      String response=Connector.getInstance().executeWithId(dataHeader,dataHeader);
      Utils.checkError(response);
      String text=response.substring(dataHeader.length() + 1);
synchronized (streams) {
        if (streams.containsKey(streamId)) {
          streams.get(streamId).fireTextReceived(text);
        }
      }
    }
 else     if (isReceivedDatagram(dataResponse)) {
      String data=dataResponse.substring(""String_Node_Str"".length());
      String streamId=data.substring(0,data.indexOf(' '));
      String datagram=data.substring(data.indexOf(' ') + 1);
synchronized (streams) {
        if (streams.containsKey(streamId)) {
          streams.get(streamId).fireDatagramReceived(datagram);
        }
      }
    }
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}",0.8784956605593057
3178,"public Stream connect(final Friend friend) throws SkypeException {
  Utils.checkNotNull(""String_Node_Str"",friend);
  try {
    final String[] id=new String[1];
    final String[] error=new String[1];
    MessageProcessor processor=new MessageProcessor(){
      public void messageReceived(      String message){
        if (message.equals(""String_Node_Str"" + getName() + ""String_Node_Str""+ friend.getId())) {
        }
 else         if (message.equals(""String_Node_Str"" + getName() + ""String_Node_Str"")) {
        }
 else         if (message.startsWith(""String_Node_Str"" + getName() + ""String_Node_Str"")) {
          id[0]=message.substring((""String_Node_Str"" + getName() + ""String_Node_Str"").length());
          releaseLock();
        }
 else         if (message.startsWith(""String_Node_Str"")) {
          error[0]=message.substring(""String_Node_Str"".length());
          releaseLock();
        }
      }
    }
;
    Connector.getInstance().execute(""String_Node_Str"" + getName() + ""String_Node_Str""+ friend.getId(),processor);
    Utils.checkError(error[0]);
    return streams.get(id[0]);
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
    return null;
  }
}","public Stream[] connect(Friend... friends) throws SkypeException {
  Utils.checkNotNull(""String_Node_Str"",friends);
synchronized (connectMutex) {
    try {
      final Object wait=new Object();
      ConnectorMessageReceivedListener connectorListener=new ConnectorMessageReceivedListener(){
        public void messageReceived(        String receivedMessage){
          if (receivedMessage.equals(""String_Node_Str"" + getName() + ""String_Node_Str"")) {
synchronized (wait) {
              wait.notify();
            }
          }
        }
      }
;
      try {
        Connector.getInstance().addConnectorMessageReceivedListener(connectorListener);
synchronized (wait) {
          for (          Friend friend : friends) {
            String result=Connector.getInstance().execute(""String_Node_Str"" + getName() + ""String_Node_Str""+ friend.getId());
            Utils.checkError(result);
          }
          try {
            wait.wait();
          }
 catch (          InterruptedException e) {
            throw new SkypeException(""String_Node_Str"",e);
          }
        }
        return getAllStreams(friends);
      }
 catch (      ConnectorException e) {
        Utils.convertToSkypeException(e);
        return null;
      }
 finally {
        Connector.getInstance().removeConnectorMessageReceivedListener(connectorListener);
      }
    }
 catch (    SkypeException e) {
      for (      Stream stream : getAllStreams(friends)) {
        try {
          stream.disconnect();
        }
 catch (        SkypeException e2) {
        }
      }
      throw e;
    }
  }
}",0.2857142857142857
3179,"SkypeException(String message){
  super(message);
}","SkypeException(String message,Throwable cause){
  super(message,cause);
}",0.8225806451612904
3180,"public void disconnect() throws SkypeException {
  try {
    String response=Connector.getInstance().execute(""String_Node_Str"" + application.getName() + ""String_Node_Str""+ friend.getId()+ ""String_Node_Str"");
    Utils.checkError(response);
    application.fireDisconnected(this);
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
  }
}","public void disconnect() throws SkypeException {
  try {
    String response=Connector.getInstance().execute(""String_Node_Str"" + application.getName() + ""String_Node_Str""+ getId());
    Utils.checkError(response);
    application.fireDisconnected(this);
  }
 catch (  ConnectorException e) {
    Utils.convertToSkypeException(e);
  }
}",0.9626436781609196
3181,"public Friend getFriend(){
  return friend;
}","public Friend getFriend(){
  return new Friend(getId().substring(0,getId().indexOf(':')));
}",0.6423357664233577
3182,"public String getId(){
  return getFriend().getId() + ""String_Node_Str"" + getNumber();
}","public String getId(){
  return id;
}",0.592
3183,"Stream(Application application,Friend friend,int number){
}","Stream(Application application,String id){
}",0.7572815533980582
3184,"public void testWriteOnMultiThread() throws Exception {
  Skype.setDebug(true);
  Application application=Skype.addApplication(APPLICATION_NAME);
  Friend friend=TestData.getFriend();
  try {
    Stream stream=application.connect(friend);
    checkConnectedFriends(application,friend);
    checkWriteOnMultiThread(stream);
    checkDisconnect(application,stream);
  }
  finally {
    application.finish();
  }
}","public void testWriteOnMultiThread() throws Exception {
  Skype.setDebug(true);
  Application application=Skype.addApplication(APPLICATION_NAME);
  Friend friend=TestData.getFriend();
  try {
    Stream[] streams=application.connect(friend);
    assertEquals(1,streams.length);
    Stream stream=streams[0];
    checkConnectedFriends(application,friend);
    checkWriteOnMultiThread(stream);
    checkDisconnect(application,stream);
  }
  finally {
    application.finish();
  }
}",0.9068462401795736
3185,"public void testApplication() throws Exception {
  Skype.setDebug(true);
  Application application=Skype.addApplication(APPLICATION_NAME);
  Friend friend=TestData.getFriend();
  checkConnectableFriendsBeforeConnecting(application);
  try {
    Stream stream=application.connect(friend);
    checkConnectableFriendsAfterConnecting(application);
    checkConnectedFriends(application,friend);
    checkWrite(stream);
    checkSend(stream);
    checkDisconnect(application,stream);
  }
  finally {
    application.finish();
  }
}","public void testApplication() throws Exception {
  Skype.setDebug(true);
  Application application=Skype.addApplication(APPLICATION_NAME);
  Friend friend=TestData.getFriend();
  checkConnectableFriendsBeforeConnecting(application);
  try {
    Stream[] streams=application.connect(friend);
    assertEquals(1,streams.length);
    Stream stream=streams[0];
    checkConnectableFriendsAfterConnecting(application);
    checkConnectedFriends(application,friend);
    checkWrite(stream);
    checkSend(stream);
    checkDisconnect(application,stream);
  }
  finally {
    application.finish();
  }
}",0.9260908281389136
3186,"public static Application addApplication(String name) throws SkypeException {
  Application application=new Application(name);
  application.initialize();
  return application;
}","public static Application addApplication(String name) throws SkypeException {
  Application application=new Application(name);
  application.initalize();
  return application;
}",0.9971830985915492
3187,"public FetchResult updateData(Context context,boolean force){
  DBOpenHelper dbhelper=new DBOpenHelper(context);
  SQLiteDatabase db=dbhelper.getWritableDatabase();
  try {
    if (!isOnline(context)) {
      Log.d(TAG,""String_Node_Str"");
      return FetchResult.NOTONLINE;
    }
  }
 catch (  Exception e) {
    exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
  }
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  if (!force) {
    try {
      if (sp.getBoolean(""String_Node_Str"",false) == true) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      if (sp.getBoolean(""String_Node_Str"",true) == false) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isBackgroundDataEnabled(context) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isAutoSyncEnabled() && sp.getBoolean(""String_Node_Str"",true) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (isWifi(context) && !sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
 else       if (!isWifi(context)) {
        Log.d(TAG,""String_Node_Str"");
        if (!isRoaming(context) && !sp.getBoolean(""String_Node_Str"",true)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
 else         if (isRoaming(context) && !sp.getBoolean(""String_Node_Str"",false)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
      }
    }
 catch (    Exception e) {
      exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  try {
    String username=sp.getString(""String_Node_Str"",null);
    String password=sp.getString(""String_Node_Str"",null);
    if (username == null || password == null) {
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.USERNAMEPASSWORDNOTSET;
    }
    Log.d(TAG,""String_Node_Str"");
    HttpGetter loginPageGet=new HttpGetter(""String_Node_Str"");
    String loginPageString=loginPageGet.execute();
    if (loginPageString != null) {
      Document loginPage=Jsoup.parse(loginPageString,""String_Node_Str"");
      Element loginForm=loginPage.getElementsByAttributeValue(""String_Node_Str"",""String_Node_Str"").first();
      String loginAction=loginForm.attr(""String_Node_Str"");
      List<NameValuePair> loginValues=new ArrayList<NameValuePair>();
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",username));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",password));
      Log.d(TAG,""String_Node_Str"");
      HttpPoster sendLoginPoster=new HttpPoster(loginAction,loginValues);
      Document homePage=Jsoup.parse(sendLoginPoster.execute());
      boolean postPaid;
      if (homePage.getElementById(""String_Node_Str"") == null) {
        Log.d(TAG,""String_Node_Str"");
        postPaid=false;
      }
 else {
        Log.d(TAG,""String_Node_Str"");
        postPaid=true;
      }
      Element accountSummary=homePage.getElementById(""String_Node_Str"");
      if (accountSummary == null) {
        Log.d(TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      db.delete(""String_Node_Str"",""String_Node_Str"",null);
      Element accountSummaryTable=accountSummary.getElementsByClass(""String_Node_Str"").first();
      Elements rows=accountSummaryTable.getElementsByTag(""String_Node_Str"");
      for (      Element row : rows) {
        Double value;
        String units;
        try {
          Element amount=row.getElementsByClass(""String_Node_Str"").first();
          String amountHTML=amount.html();
          String[] amountParts=amountHTML.split(""String_Node_Str"",2);
          if (amountParts[0].contains(""String_Node_Str"") || amountParts[0].equals(""String_Node_Str"")) {
            value=Values.INCLUDED;
          }
 else {
            try {
              value=Double.parseDouble(amountParts[0]);
            }
 catch (            NumberFormatException e) {
              exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
              value=0.0;
            }
          }
          units=amountParts[1];
        }
 catch (        NullPointerException e) {
          value=null;
          units=null;
        }
        Element details=row.getElementsByClass(""String_Node_Str"").first();
        String name=details.getElementsByTag(""String_Node_Str"").first().text();
        Element expires=details.getElementsByTag(""String_Node_Str"").first();
        String expiresDetails=""String_Node_Str"";
        if (expires != null) {
          expiresDetails=expires.text();
        }
        Log.d(TAG,expiresDetails);
        Pattern pattern;
        if (postPaid == false) {
          pattern=Pattern.compile(""String_Node_Str"");
        }
 else {
          pattern=Pattern.compile(""String_Node_Str"");
        }
        Matcher matcher=pattern.matcher(expiresDetails);
        Double expiresValue=null;
        String expiresDate=null;
        if (matcher.find()) {
          try {
            expiresValue=Double.parseDouble(matcher.group(1));
          }
 catch (          NumberFormatException e) {
            expiresValue=null;
          }
          String expiresDateString=matcher.group(2);
          Date expiresDateObj;
          if (expiresDateString != null) {
            if (expiresDateString.length() > 0) {
              try {
                expiresDateObj=DateFormatters.EXPIRESDATE.parse(expiresDateString);
                expiresDate=DateFormatters.ISO8601DATEONLYFORMAT.format(expiresDateObj);
              }
 catch (              java.text.ParseException e) {
                Log.d(TAG,""String_Node_Str"" + expiresDateString);
              }
            }
          }
        }
        ContentValues values=new ContentValues();
        values.put(""String_Node_Str"",name);
        values.put(""String_Node_Str"",value);
        values.put(""String_Node_Str"",units);
        values.put(""String_Node_Str"",expiresValue);
        values.put(""String_Node_Str"",expiresDate);
        db.insert(""String_Node_Str"",""String_Node_Str"",values);
      }
      if (postPaid == false) {
        Log.d(TAG,""String_Node_Str"");
        HttpGetter valuePacksPageGet=new HttpGetter(""String_Node_Str"");
        String valuePacksPageString=valuePacksPageGet.execute();
        if (valuePacksPageString != null) {
          Document valuePacksPage=Jsoup.parse(valuePacksPageString);
          Elements enabledPacks=valuePacksPage.getElementsByClass(""String_Node_Str"");
          for (          Element enabledPack : enabledPacks) {
            Element offerNameElemt=enabledPack.getElementsByAttributeValueStarting(""String_Node_Str"",""String_Node_Str"").first();
            if (offerNameElemt != null) {
              String offerName=offerNameElemt.val();
              DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName);
              ValuePack[] packs=Values.valuePacks.get(offerName);
              if (packs == null) {
                DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName + ""String_Node_Str"");
              }
 else {
                for (                ValuePack pack : packs) {
                  ContentValues values=new ContentValues();
                  values.put(""String_Node_Str"",pack.value);
                  values.put(""String_Node_Str"",offerName);
                  DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + pack.type.id + ""String_Node_Str""+ pack.value);
                  db.update(""String_Node_Str"",values,""String_Node_Str"" + pack.type.id + ""String_Node_Str"",null);
                }
              }
            }
          }
        }
      }
      SharedPreferences.Editor prefedit=sp.edit();
      Date now=new Date();
      prefedit.putString(""String_Node_Str"",DateFormatters.ISO8601FORMAT.format(now));
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.commit();
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.SUCCESS;
    }
  }
 catch (  ClientProtocolException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
catch (  IOException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
 finally {
    db.close();
  }
  return null;
}","public FetchResult updateData(Context context,boolean force){
  DBOpenHelper dbhelper=new DBOpenHelper(context);
  SQLiteDatabase db=dbhelper.getWritableDatabase();
  try {
    if (!isOnline(context)) {
      Log.d(TAG,""String_Node_Str"");
      return FetchResult.NOTONLINE;
    }
  }
 catch (  Exception e) {
    exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
  }
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  if (!force) {
    try {
      if (sp.getBoolean(""String_Node_Str"",false) == true) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      if (sp.getBoolean(""String_Node_Str"",true) == false) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isBackgroundDataEnabled(context) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isAutoSyncEnabled() && sp.getBoolean(""String_Node_Str"",true) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (isWifi(context) && !sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
 else       if (!isWifi(context)) {
        Log.d(TAG,""String_Node_Str"");
        if (!isRoaming(context) && !sp.getBoolean(""String_Node_Str"",true)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
 else         if (isRoaming(context) && !sp.getBoolean(""String_Node_Str"",false)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
      }
    }
 catch (    Exception e) {
      exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  try {
    String username=sp.getString(""String_Node_Str"",null);
    String password=sp.getString(""String_Node_Str"",null);
    if (username == null || password == null) {
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.USERNAMEPASSWORDNOTSET;
    }
    Log.d(TAG,""String_Node_Str"");
    HttpGetter loginPageGet=new HttpGetter(""String_Node_Str"");
    String loginPageString=loginPageGet.execute();
    if (loginPageString != null) {
      Document loginPage=Jsoup.parse(loginPageString,""String_Node_Str"");
      Element loginForm=loginPage.getElementsByAttributeValue(""String_Node_Str"",""String_Node_Str"").first();
      String loginAction=loginForm.attr(""String_Node_Str"");
      List<NameValuePair> loginValues=new ArrayList<NameValuePair>();
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",username));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",password));
      Log.d(TAG,""String_Node_Str"");
      HttpPoster sendLoginPoster=new HttpPoster(loginAction,loginValues);
      Document homePage=Jsoup.parse(sendLoginPoster.execute());
      boolean postPaid;
      if (homePage.getElementById(""String_Node_Str"") == null) {
        Log.d(TAG,""String_Node_Str"");
        postPaid=false;
      }
 else {
        Log.d(TAG,""String_Node_Str"");
        postPaid=true;
      }
      Element accountSummary=homePage.getElementById(""String_Node_Str"");
      if (accountSummary == null) {
        Log.d(TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      db.delete(""String_Node_Str"",""String_Node_Str"",null);
      Element accountSummaryTable=accountSummary.getElementsByClass(""String_Node_Str"").first();
      Elements rows=accountSummaryTable.getElementsByTag(""String_Node_Str"");
      for (      Element row : rows) {
        Double value;
        String units;
        try {
          Element amount=row.getElementsByClass(""String_Node_Str"").first();
          String amountHTML=amount.html();
          String[] amountParts=amountHTML.split(""String_Node_Str"",2);
          if (amountParts[0].contains(""String_Node_Str"") || amountParts[0].equals(""String_Node_Str"") || amountParts[0].equals(""String_Node_Str"")) {
            value=Values.INCLUDED;
          }
 else {
            try {
              value=Double.parseDouble(amountParts[0]);
            }
 catch (            NumberFormatException e) {
              exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
              value=0.0;
            }
          }
          units=amountParts[1];
        }
 catch (        NullPointerException e) {
          value=null;
          units=null;
        }
        Element details=row.getElementsByClass(""String_Node_Str"").first();
        String name=details.getElementsByTag(""String_Node_Str"").first().text();
        Element expires=details.getElementsByTag(""String_Node_Str"").first();
        String expiresDetails=""String_Node_Str"";
        if (expires != null) {
          expiresDetails=expires.text();
        }
        Log.d(TAG,expiresDetails);
        Pattern pattern;
        if (postPaid == false) {
          pattern=Pattern.compile(""String_Node_Str"");
        }
 else {
          pattern=Pattern.compile(""String_Node_Str"");
        }
        Matcher matcher=pattern.matcher(expiresDetails);
        Double expiresValue=null;
        String expiresDate=null;
        if (matcher.find()) {
          try {
            expiresValue=Double.parseDouble(matcher.group(1));
          }
 catch (          NumberFormatException e) {
            expiresValue=null;
          }
          String expiresDateString=matcher.group(2);
          Date expiresDateObj;
          if (expiresDateString != null) {
            if (expiresDateString.length() > 0) {
              try {
                expiresDateObj=DateFormatters.EXPIRESDATE.parse(expiresDateString);
                expiresDate=DateFormatters.ISO8601DATEONLYFORMAT.format(expiresDateObj);
              }
 catch (              java.text.ParseException e) {
                Log.d(TAG,""String_Node_Str"" + expiresDateString);
              }
            }
          }
        }
        ContentValues values=new ContentValues();
        values.put(""String_Node_Str"",name);
        values.put(""String_Node_Str"",value);
        values.put(""String_Node_Str"",units);
        values.put(""String_Node_Str"",expiresValue);
        values.put(""String_Node_Str"",expiresDate);
        db.insert(""String_Node_Str"",""String_Node_Str"",values);
      }
      if (postPaid == false) {
        Log.d(TAG,""String_Node_Str"");
        HttpGetter valuePacksPageGet=new HttpGetter(""String_Node_Str"");
        String valuePacksPageString=valuePacksPageGet.execute();
        if (valuePacksPageString != null) {
          Document valuePacksPage=Jsoup.parse(valuePacksPageString);
          Elements enabledPacks=valuePacksPage.getElementsByClass(""String_Node_Str"");
          for (          Element enabledPack : enabledPacks) {
            Element offerNameElemt=enabledPack.getElementsByAttributeValueStarting(""String_Node_Str"",""String_Node_Str"").first();
            if (offerNameElemt != null) {
              String offerName=offerNameElemt.val();
              DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName);
              ValuePack[] packs=Values.valuePacks.get(offerName);
              if (packs == null) {
                DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName + ""String_Node_Str"");
              }
 else {
                for (                ValuePack pack : packs) {
                  ContentValues values=new ContentValues();
                  values.put(""String_Node_Str"",pack.value);
                  values.put(""String_Node_Str"",offerName);
                  DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + pack.type.id + ""String_Node_Str""+ pack.value);
                  db.update(""String_Node_Str"",values,""String_Node_Str"" + pack.type.id + ""String_Node_Str"",null);
                }
              }
            }
          }
        }
      }
      SharedPreferences.Editor prefedit=sp.edit();
      Date now=new Date();
      prefedit.putString(""String_Node_Str"",DateFormatters.ISO8601FORMAT.format(now));
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.commit();
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.SUCCESS;
    }
  }
 catch (  ClientProtocolException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
catch (  IOException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
 finally {
    db.close();
  }
  return null;
}",0.997741968592836
3188,"public boolean isWifi(Context context){
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  NetworkInfo info=cm.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  if (info == null) {
    return false;
  }
 else {
    return info.isConnectedOrConnecting();
  }
}","public boolean isWifi(Context context){
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  NetworkInfo info=cm.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
  if (info == null) {
    return false;
  }
 else {
    return info.isConnected();
  }
}",0.980327868852459
3189,"public FetchResult updateData(Context context,boolean force){
  DBOpenHelper dbhelper=new DBOpenHelper(context);
  SQLiteDatabase db=dbhelper.getWritableDatabase();
  try {
    if (!isOnline(context)) {
      Log.d(TAG,""String_Node_Str"");
      return FetchResult.NOTONLINE;
    }
  }
 catch (  Exception e) {
    exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
  }
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  if (!force) {
    try {
      if (sp.getBoolean(""String_Node_Str"",false) == true) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      if (sp.getBoolean(""String_Node_Str"",true) == false) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isBackgroundDataEnabled(context) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isAutoSyncEnabled() && sp.getBoolean(""String_Node_Str"",true) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (isWifi(context) && !sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
 else       if (!isWifi(context)) {
        Log.d(TAG,""String_Node_Str"");
        if (!isRoaming(context) && !sp.getBoolean(""String_Node_Str"",true)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
 else         if (isRoaming(context) && !sp.getBoolean(""String_Node_Str"",false)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
      }
    }
 catch (    Exception e) {
      exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  try {
    String username=sp.getString(""String_Node_Str"",null);
    String password=sp.getString(""String_Node_Str"",null);
    if (username == null || password == null) {
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.USERNAMEPASSWORDNOTSET;
    }
    Log.d(TAG,""String_Node_Str"");
    HttpGetter loginPageGet=new HttpGetter(""String_Node_Str"");
    String loginPageString=loginPageGet.execute();
    if (loginPageString != null) {
      Document loginPage=Jsoup.parse(loginPageString,""String_Node_Str"");
      Element loginForm=loginPage.getElementsByAttributeValue(""String_Node_Str"",""String_Node_Str"").first();
      String loginAction=loginForm.attr(""String_Node_Str"");
      List<NameValuePair> loginValues=new ArrayList<NameValuePair>();
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",username));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",password));
      Log.d(TAG,""String_Node_Str"");
      HttpPoster sendLoginPoster=new HttpPoster(loginAction,loginValues);
      Document homePage=Jsoup.parse(sendLoginPoster.execute());
      boolean postPaid;
      if (homePage.getElementById(""String_Node_Str"") == null) {
        Log.d(TAG,""String_Node_Str"");
        postPaid=false;
      }
 else {
        Log.d(TAG,""String_Node_Str"");
        postPaid=true;
      }
      Element accountSummary=homePage.getElementById(""String_Node_Str"");
      if (accountSummary == null) {
        Log.d(TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      db.delete(""String_Node_Str"",""String_Node_Str"",null);
      Element accountSummaryTable=accountSummary.getElementsByClass(""String_Node_Str"").first();
      Elements rows=accountSummaryTable.getElementsByTag(""String_Node_Str"");
      for (      Element row : rows) {
        Double value;
        String units;
        try {
          Element amount=row.getElementsByClass(""String_Node_Str"").first();
          String amountHTML=amount.html();
          String[] amountParts=amountHTML.split(""String_Node_Str"",2);
          if (amountParts[0].equals(""String_Node_Str"")) {
            value=Values.INCLUDED;
          }
 else {
            try {
              value=Double.parseDouble(amountParts[0]);
            }
 catch (            NumberFormatException e) {
              exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
              value=0.0;
            }
          }
          units=amountParts[1];
        }
 catch (        NullPointerException e) {
          value=null;
          units=null;
        }
        Element details=row.getElementsByClass(""String_Node_Str"").first();
        String name=details.getElementsByTag(""String_Node_Str"").first().text();
        Element expires=details.getElementsByTag(""String_Node_Str"").first();
        String expiresDetails=""String_Node_Str"";
        if (expires != null) {
          expiresDetails=expires.text();
        }
        Log.d(TAG,expiresDetails);
        Pattern pattern;
        if (postPaid == false) {
          pattern=Pattern.compile(""String_Node_Str"");
        }
 else {
          pattern=Pattern.compile(""String_Node_Str"");
        }
        Matcher matcher=pattern.matcher(expiresDetails);
        Double expiresValue=null;
        String expiresDate=null;
        if (matcher.find()) {
          try {
            expiresValue=Double.parseDouble(matcher.group(1));
          }
 catch (          NumberFormatException e) {
            expiresValue=null;
          }
          String expiresDateString=matcher.group(2);
          Date expiresDateObj;
          if (expiresDateString != null) {
            if (expiresDateString.length() > 0) {
              try {
                expiresDateObj=DateFormatters.EXPIRESDATE.parse(expiresDateString);
                expiresDate=DateFormatters.ISO8601DATEONLYFORMAT.format(expiresDateObj);
              }
 catch (              java.text.ParseException e) {
                Log.d(TAG,""String_Node_Str"" + expiresDateString);
              }
            }
          }
        }
        ContentValues values=new ContentValues();
        values.put(""String_Node_Str"",name);
        values.put(""String_Node_Str"",value);
        values.put(""String_Node_Str"",units);
        values.put(""String_Node_Str"",expiresValue);
        values.put(""String_Node_Str"",expiresDate);
        db.insert(""String_Node_Str"",""String_Node_Str"",values);
      }
      if (postPaid == false) {
        Log.d(TAG,""String_Node_Str"");
        HttpGetter valuePacksPageGet=new HttpGetter(""String_Node_Str"");
        String valuePacksPageString=valuePacksPageGet.execute();
        if (valuePacksPageString != null) {
          Document valuePacksPage=Jsoup.parse(valuePacksPageString);
          Elements enabledPacks=valuePacksPage.getElementsByClass(""String_Node_Str"");
          for (          Element enabledPack : enabledPacks) {
            Element offerNameElemt=enabledPack.getElementsByAttributeValueStarting(""String_Node_Str"",""String_Node_Str"").first();
            String offerName=offerNameElemt.val();
            DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName);
            ValuePack[] packs=Values.valuePacks.get(offerName);
            if (packs == null) {
              DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName + ""String_Node_Str"");
            }
 else {
              for (              ValuePack pack : packs) {
                ContentValues values=new ContentValues();
                values.put(""String_Node_Str"",pack.value);
                values.put(""String_Node_Str"",offerName);
                DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + pack.type.id + ""String_Node_Str""+ pack.value);
                db.update(""String_Node_Str"",values,""String_Node_Str"" + pack.type.id + ""String_Node_Str"",null);
              }
            }
          }
        }
      }
      SharedPreferences.Editor prefedit=sp.edit();
      Date now=new Date();
      prefedit.putString(""String_Node_Str"",DateFormatters.ISO8601FORMAT.format(now));
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.commit();
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.SUCCESS;
    }
  }
 catch (  ClientProtocolException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
catch (  IOException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
 finally {
    db.close();
  }
  return null;
}","public FetchResult updateData(Context context,boolean force){
  DBOpenHelper dbhelper=new DBOpenHelper(context);
  SQLiteDatabase db=dbhelper.getWritableDatabase();
  try {
    if (!isOnline(context)) {
      Log.d(TAG,""String_Node_Str"");
      return FetchResult.NOTONLINE;
    }
  }
 catch (  Exception e) {
    exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
  }
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  if (!force) {
    try {
      if (sp.getBoolean(""String_Node_Str"",false) == true) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      if (sp.getBoolean(""String_Node_Str"",true) == false) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isBackgroundDataEnabled(context) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isAutoSyncEnabled() && sp.getBoolean(""String_Node_Str"",true) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (isWifi(context) && !sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
 else       if (!isWifi(context)) {
        Log.d(TAG,""String_Node_Str"");
        if (!isRoaming(context) && !sp.getBoolean(""String_Node_Str"",true)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
 else         if (isRoaming(context) && !sp.getBoolean(""String_Node_Str"",false)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
      }
    }
 catch (    Exception e) {
      exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  try {
    String username=sp.getString(""String_Node_Str"",null);
    String password=sp.getString(""String_Node_Str"",null);
    if (username == null || password == null) {
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.USERNAMEPASSWORDNOTSET;
    }
    Log.d(TAG,""String_Node_Str"");
    HttpGetter loginPageGet=new HttpGetter(""String_Node_Str"");
    String loginPageString=loginPageGet.execute();
    if (loginPageString != null) {
      Document loginPage=Jsoup.parse(loginPageString,""String_Node_Str"");
      Element loginForm=loginPage.getElementsByAttributeValue(""String_Node_Str"",""String_Node_Str"").first();
      String loginAction=loginForm.attr(""String_Node_Str"");
      List<NameValuePair> loginValues=new ArrayList<NameValuePair>();
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",username));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",password));
      Log.d(TAG,""String_Node_Str"");
      HttpPoster sendLoginPoster=new HttpPoster(loginAction,loginValues);
      Document homePage=Jsoup.parse(sendLoginPoster.execute());
      boolean postPaid;
      if (homePage.getElementById(""String_Node_Str"") == null) {
        Log.d(TAG,""String_Node_Str"");
        postPaid=false;
      }
 else {
        Log.d(TAG,""String_Node_Str"");
        postPaid=true;
      }
      Element accountSummary=homePage.getElementById(""String_Node_Str"");
      if (accountSummary == null) {
        Log.d(TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      db.delete(""String_Node_Str"",""String_Node_Str"",null);
      Element accountSummaryTable=accountSummary.getElementsByClass(""String_Node_Str"").first();
      Elements rows=accountSummaryTable.getElementsByTag(""String_Node_Str"");
      for (      Element row : rows) {
        Double value;
        String units;
        try {
          Element amount=row.getElementsByClass(""String_Node_Str"").first();
          String amountHTML=amount.html();
          String[] amountParts=amountHTML.split(""String_Node_Str"",2);
          if (amountParts[0].equals(""String_Node_Str"") || amountParts[0].equals(""String_Node_Str"")) {
            value=Values.INCLUDED;
          }
 else {
            try {
              value=Double.parseDouble(amountParts[0]);
            }
 catch (            NumberFormatException e) {
              exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
              value=0.0;
            }
          }
          units=amountParts[1];
        }
 catch (        NullPointerException e) {
          value=null;
          units=null;
        }
        Element details=row.getElementsByClass(""String_Node_Str"").first();
        String name=details.getElementsByTag(""String_Node_Str"").first().text();
        Element expires=details.getElementsByTag(""String_Node_Str"").first();
        String expiresDetails=""String_Node_Str"";
        if (expires != null) {
          expiresDetails=expires.text();
        }
        Log.d(TAG,expiresDetails);
        Pattern pattern;
        if (postPaid == false) {
          pattern=Pattern.compile(""String_Node_Str"");
        }
 else {
          pattern=Pattern.compile(""String_Node_Str"");
        }
        Matcher matcher=pattern.matcher(expiresDetails);
        Double expiresValue=null;
        String expiresDate=null;
        if (matcher.find()) {
          try {
            expiresValue=Double.parseDouble(matcher.group(1));
          }
 catch (          NumberFormatException e) {
            expiresValue=null;
          }
          String expiresDateString=matcher.group(2);
          Date expiresDateObj;
          if (expiresDateString != null) {
            if (expiresDateString.length() > 0) {
              try {
                expiresDateObj=DateFormatters.EXPIRESDATE.parse(expiresDateString);
                expiresDate=DateFormatters.ISO8601DATEONLYFORMAT.format(expiresDateObj);
              }
 catch (              java.text.ParseException e) {
                Log.d(TAG,""String_Node_Str"" + expiresDateString);
              }
            }
          }
        }
        ContentValues values=new ContentValues();
        values.put(""String_Node_Str"",name);
        values.put(""String_Node_Str"",value);
        values.put(""String_Node_Str"",units);
        values.put(""String_Node_Str"",expiresValue);
        values.put(""String_Node_Str"",expiresDate);
        db.insert(""String_Node_Str"",""String_Node_Str"",values);
      }
      if (postPaid == false) {
        Log.d(TAG,""String_Node_Str"");
        HttpGetter valuePacksPageGet=new HttpGetter(""String_Node_Str"");
        String valuePacksPageString=valuePacksPageGet.execute();
        if (valuePacksPageString != null) {
          Document valuePacksPage=Jsoup.parse(valuePacksPageString);
          Elements enabledPacks=valuePacksPage.getElementsByClass(""String_Node_Str"");
          for (          Element enabledPack : enabledPacks) {
            Element offerNameElemt=enabledPack.getElementsByAttributeValueStarting(""String_Node_Str"",""String_Node_Str"").first();
            String offerName=offerNameElemt.val();
            DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName);
            ValuePack[] packs=Values.valuePacks.get(offerName);
            if (packs == null) {
              DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName + ""String_Node_Str"");
            }
 else {
              for (              ValuePack pack : packs) {
                ContentValues values=new ContentValues();
                values.put(""String_Node_Str"",pack.value);
                values.put(""String_Node_Str"",offerName);
                DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + pack.type.id + ""String_Node_Str""+ pack.value);
                db.update(""String_Node_Str"",values,""String_Node_Str"" + pack.type.id + ""String_Node_Str"",null);
              }
            }
          }
        }
      }
      SharedPreferences.Editor prefedit=sp.edit();
      Date now=new Date();
      prefedit.putString(""String_Node_Str"",DateFormatters.ISO8601FORMAT.format(now));
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.commit();
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.SUCCESS;
    }
  }
 catch (  ClientProtocolException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
catch (  IOException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
 finally {
    db.close();
  }
  return null;
}",0.9977109561960252
3190,"public boolean isOnline(Context context){
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  NetworkInfo info=cm.getActiveNetworkInfo();
  if (info == null) {
    return false;
  }
 else {
    return info.isConnectedOrConnecting();
  }
}","public boolean isOnline(Context context){
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  NetworkInfo info=cm.getActiveNetworkInfo();
  if (info == null) {
    return false;
  }
 else {
    return info.isConnected();
  }
}",0.9788732394366196
3191,"public FetchResult updateData(Context context,boolean force){
  DBOpenHelper dbhelper=new DBOpenHelper(context);
  SQLiteDatabase db=dbhelper.getWritableDatabase();
  try {
    if (!isOnline(context)) {
      Log.d(TAG,""String_Node_Str"");
      return FetchResult.NOTONLINE;
    }
  }
 catch (  Exception e) {
    exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
  }
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  if (!force) {
    try {
      if (sp.getBoolean(""String_Node_Str"",false) == true) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      if (sp.getBoolean(""String_Node_Str"",true) == false) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isBackgroundDataEnabled(context) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isAutoSyncEnabled() && sp.getBoolean(""String_Node_Str"",true) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (isWifi(context) && !sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
 else       if (!isWifi(context)) {
        Log.d(TAG,""String_Node_Str"");
        if (!isRoaming(context) && !sp.getBoolean(""String_Node_Str"",true)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
 else         if (isRoaming(context) && !sp.getBoolean(""String_Node_Str"",false)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
      }
    }
 catch (    Exception e) {
      exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  try {
    String username=sp.getString(""String_Node_Str"",null);
    String password=sp.getString(""String_Node_Str"",null);
    if (username == null || password == null) {
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.USERNAMEPASSWORDNOTSET;
    }
    Log.d(TAG,""String_Node_Str"");
    HttpGetter loginPageGet=new HttpGetter(""String_Node_Str"");
    String loginPageString=loginPageGet.execute();
    if (loginPageString != null) {
      Document loginPage=Jsoup.parse(loginPageString,""String_Node_Str"");
      Element loginForm=loginPage.getElementsByAttributeValue(""String_Node_Str"",""String_Node_Str"").first();
      String loginAction=loginForm.attr(""String_Node_Str"");
      List<NameValuePair> loginValues=new ArrayList<NameValuePair>();
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",username));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",password));
      Log.d(TAG,""String_Node_Str"");
      HttpPoster sendLoginPoster=new HttpPoster(loginAction,loginValues);
      Document homePage=Jsoup.parse(sendLoginPoster.execute());
      boolean postPaid;
      if (homePage.getElementById(""String_Node_Str"") == null) {
        Log.d(TAG,""String_Node_Str"");
        postPaid=false;
      }
 else {
        Log.d(TAG,""String_Node_Str"");
        postPaid=true;
      }
      Element accountSummary=homePage.getElementById(""String_Node_Str"");
      if (accountSummary == null) {
        Log.d(TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      db.delete(""String_Node_Str"",""String_Node_Str"",null);
      Element accountSummaryTable=accountSummary.getElementsByClass(""String_Node_Str"").first();
      Elements rows=accountSummaryTable.getElementsByTag(""String_Node_Str"");
      for (      Element row : rows) {
        Double value;
        String units;
        try {
          Element amount=row.getElementsByClass(""String_Node_Str"").first();
          String amountHTML=amount.html();
          String[] amountParts=amountHTML.split(""String_Node_Str"",2);
          if (amountParts[0].contains(""String_Node_Str"") || amountParts[0].equals(""String_Node_Str"")) {
            value=Values.INCLUDED;
          }
 else {
            try {
              value=Double.parseDouble(amountParts[0]);
            }
 catch (            NumberFormatException e) {
              exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
              value=0.0;
            }
          }
          units=amountParts[1];
        }
 catch (        NullPointerException e) {
          value=null;
          units=null;
        }
        Element details=row.getElementsByClass(""String_Node_Str"").first();
        String name=details.getElementsByTag(""String_Node_Str"").first().text();
        Element expires=details.getElementsByTag(""String_Node_Str"").first();
        String expiresDetails=""String_Node_Str"";
        if (expires != null) {
          expiresDetails=expires.text();
        }
        Log.d(TAG,expiresDetails);
        Pattern pattern;
        if (postPaid == false) {
          pattern=Pattern.compile(""String_Node_Str"");
        }
 else {
          pattern=Pattern.compile(""String_Node_Str"");
        }
        Matcher matcher=pattern.matcher(expiresDetails);
        Double expiresValue=null;
        String expiresDate=null;
        if (matcher.find()) {
          try {
            expiresValue=Double.parseDouble(matcher.group(1));
          }
 catch (          NumberFormatException e) {
            expiresValue=null;
          }
          String expiresDateString=matcher.group(2);
          Date expiresDateObj;
          if (expiresDateString != null) {
            if (expiresDateString.length() > 0) {
              try {
                expiresDateObj=DateFormatters.EXPIRESDATE.parse(expiresDateString);
                expiresDate=DateFormatters.ISO8601DATEONLYFORMAT.format(expiresDateObj);
              }
 catch (              java.text.ParseException e) {
                Log.d(TAG,""String_Node_Str"" + expiresDateString);
              }
            }
          }
        }
        ContentValues values=new ContentValues();
        values.put(""String_Node_Str"",name);
        values.put(""String_Node_Str"",value);
        values.put(""String_Node_Str"",units);
        values.put(""String_Node_Str"",expiresValue);
        values.put(""String_Node_Str"",expiresDate);
        db.insert(""String_Node_Str"",""String_Node_Str"",values);
      }
      if (postPaid == false) {
        Log.d(TAG,""String_Node_Str"");
        HttpGetter valuePacksPageGet=new HttpGetter(""String_Node_Str"");
        String valuePacksPageString=valuePacksPageGet.execute();
        if (valuePacksPageString != null) {
          Document valuePacksPage=Jsoup.parse(valuePacksPageString);
          Elements enabledPacks=valuePacksPage.getElementsByClass(""String_Node_Str"");
          for (          Element enabledPack : enabledPacks) {
            Element offerNameElemt=enabledPack.getElementsByAttributeValueStarting(""String_Node_Str"",""String_Node_Str"").first();
            String offerName=offerNameElemt.val();
            DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName);
            ValuePack[] packs=Values.valuePacks.get(offerName);
            if (packs == null) {
              DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName + ""String_Node_Str"");
            }
 else {
              for (              ValuePack pack : packs) {
                ContentValues values=new ContentValues();
                values.put(""String_Node_Str"",pack.value);
                values.put(""String_Node_Str"",offerName);
                DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + pack.type.id + ""String_Node_Str""+ pack.value);
                db.update(""String_Node_Str"",values,""String_Node_Str"" + pack.type.id + ""String_Node_Str"",null);
              }
            }
          }
        }
      }
      SharedPreferences.Editor prefedit=sp.edit();
      Date now=new Date();
      prefedit.putString(""String_Node_Str"",DateFormatters.ISO8601FORMAT.format(now));
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.commit();
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.SUCCESS;
    }
  }
 catch (  ClientProtocolException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
catch (  IOException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
 finally {
    db.close();
  }
  return null;
}","public FetchResult updateData(Context context,boolean force){
  DBOpenHelper dbhelper=new DBOpenHelper(context);
  SQLiteDatabase db=dbhelper.getWritableDatabase();
  try {
    if (!isOnline(context)) {
      Log.d(TAG,""String_Node_Str"");
      return FetchResult.NOTONLINE;
    }
  }
 catch (  Exception e) {
    exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
  }
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  if (!force) {
    try {
      if (sp.getBoolean(""String_Node_Str"",false) == true) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      if (sp.getBoolean(""String_Node_Str"",true) == false) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isBackgroundDataEnabled(context) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (!isAutoSyncEnabled() && sp.getBoolean(""String_Node_Str"",true) && sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
      if (isWifi(context) && !sp.getBoolean(""String_Node_Str"",true)) {
        Log.d(TAG,""String_Node_Str"");
        DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
        return FetchResult.NOTALLOWED;
      }
 else       if (!isWifi(context)) {
        Log.d(TAG,""String_Node_Str"");
        if (!isRoaming(context) && !sp.getBoolean(""String_Node_Str"",true)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
 else         if (isRoaming(context) && !sp.getBoolean(""String_Node_Str"",false)) {
          Log.d(TAG,""String_Node_Str"");
          DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
          return FetchResult.NOTALLOWED;
        }
      }
    }
 catch (    Exception e) {
      exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
    }
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  try {
    String username=sp.getString(""String_Node_Str"",null);
    String password=sp.getString(""String_Node_Str"",null);
    if (username == null || password == null) {
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.USERNAMEPASSWORDNOTSET;
    }
    Log.d(TAG,""String_Node_Str"");
    HttpGetter loginPageGet=new HttpGetter(""String_Node_Str"");
    String loginPageString=loginPageGet.execute();
    if (loginPageString != null) {
      Document loginPage=Jsoup.parse(loginPageString,""String_Node_Str"");
      Element loginForm=loginPage.getElementsByAttributeValue(""String_Node_Str"",""String_Node_Str"").first();
      String loginAction=loginForm.attr(""String_Node_Str"");
      List<NameValuePair> loginValues=new ArrayList<NameValuePair>();
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",username));
      loginValues.add(new BasicNameValuePair(""String_Node_Str"",password));
      Log.d(TAG,""String_Node_Str"");
      HttpPoster sendLoginPoster=new HttpPoster(loginAction,loginValues);
      Document homePage=Jsoup.parse(sendLoginPoster.execute());
      boolean postPaid;
      if (homePage.getElementById(""String_Node_Str"") == null) {
        Log.d(TAG,""String_Node_Str"");
        postPaid=false;
      }
 else {
        Log.d(TAG,""String_Node_Str"");
        postPaid=true;
      }
      Element accountSummary=homePage.getElementById(""String_Node_Str"");
      if (accountSummary == null) {
        Log.d(TAG,""String_Node_Str"");
        return FetchResult.LOGINFAILED;
      }
      db.delete(""String_Node_Str"",""String_Node_Str"",null);
      Element accountSummaryTable=accountSummary.getElementsByClass(""String_Node_Str"").first();
      Elements rows=accountSummaryTable.getElementsByTag(""String_Node_Str"");
      for (      Element row : rows) {
        Double value;
        String units;
        try {
          Element amount=row.getElementsByClass(""String_Node_Str"").first();
          String amountHTML=amount.html();
          String[] amountParts=amountHTML.split(""String_Node_Str"",2);
          if (amountParts[0].contains(""String_Node_Str"") || amountParts[0].equals(""String_Node_Str"")) {
            value=Values.INCLUDED;
          }
 else {
            try {
              value=Double.parseDouble(amountParts[0]);
            }
 catch (            NumberFormatException e) {
              exceptionReporter.reportException(Thread.currentThread(),e,""String_Node_Str"");
              value=0.0;
            }
          }
          units=amountParts[1];
        }
 catch (        NullPointerException e) {
          value=null;
          units=null;
        }
        Element details=row.getElementsByClass(""String_Node_Str"").first();
        String name=details.getElementsByTag(""String_Node_Str"").first().text();
        Element expires=details.getElementsByTag(""String_Node_Str"").first();
        String expiresDetails=""String_Node_Str"";
        if (expires != null) {
          expiresDetails=expires.text();
        }
        Log.d(TAG,expiresDetails);
        Pattern pattern;
        if (postPaid == false) {
          pattern=Pattern.compile(""String_Node_Str"");
        }
 else {
          pattern=Pattern.compile(""String_Node_Str"");
        }
        Matcher matcher=pattern.matcher(expiresDetails);
        Double expiresValue=null;
        String expiresDate=null;
        if (matcher.find()) {
          try {
            expiresValue=Double.parseDouble(matcher.group(1));
          }
 catch (          NumberFormatException e) {
            expiresValue=null;
          }
          String expiresDateString=matcher.group(2);
          Date expiresDateObj;
          if (expiresDateString != null) {
            if (expiresDateString.length() > 0) {
              try {
                expiresDateObj=DateFormatters.EXPIRESDATE.parse(expiresDateString);
                expiresDate=DateFormatters.ISO8601DATEONLYFORMAT.format(expiresDateObj);
              }
 catch (              java.text.ParseException e) {
                Log.d(TAG,""String_Node_Str"" + expiresDateString);
              }
            }
          }
        }
        ContentValues values=new ContentValues();
        values.put(""String_Node_Str"",name);
        values.put(""String_Node_Str"",value);
        values.put(""String_Node_Str"",units);
        values.put(""String_Node_Str"",expiresValue);
        values.put(""String_Node_Str"",expiresDate);
        db.insert(""String_Node_Str"",""String_Node_Str"",values);
      }
      if (postPaid == false) {
        Log.d(TAG,""String_Node_Str"");
        HttpGetter valuePacksPageGet=new HttpGetter(""String_Node_Str"");
        String valuePacksPageString=valuePacksPageGet.execute();
        if (valuePacksPageString != null) {
          Document valuePacksPage=Jsoup.parse(valuePacksPageString);
          Elements enabledPacks=valuePacksPage.getElementsByClass(""String_Node_Str"");
          for (          Element enabledPack : enabledPacks) {
            Element offerNameElemt=enabledPack.getElementsByAttributeValueStarting(""String_Node_Str"",""String_Node_Str"").first();
            if (offerNameElemt != null) {
              String offerName=offerNameElemt.val();
              DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName);
              ValuePack[] packs=Values.valuePacks.get(offerName);
              if (packs == null) {
                DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + offerName + ""String_Node_Str"");
              }
 else {
                for (                ValuePack pack : packs) {
                  ContentValues values=new ContentValues();
                  values.put(""String_Node_Str"",pack.value);
                  values.put(""String_Node_Str"",offerName);
                  DBLog.insertMessage(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + pack.type.id + ""String_Node_Str""+ pack.value);
                  db.update(""String_Node_Str"",values,""String_Node_Str"" + pack.type.id + ""String_Node_Str"",null);
                }
              }
            }
          }
        }
      }
      SharedPreferences.Editor prefedit=sp.edit();
      Date now=new Date();
      prefedit.putString(""String_Node_Str"",DateFormatters.ISO8601FORMAT.format(now));
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.putBoolean(""String_Node_Str"",false);
      prefedit.commit();
      DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"");
      return FetchResult.SUCCESS;
    }
  }
 catch (  ClientProtocolException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
catch (  IOException e) {
    DBLog.insertMessage(context,""String_Node_Str"",TAG,""String_Node_Str"" + e.getMessage());
    return FetchResult.NETWORKERROR;
  }
 finally {
    db.close();
  }
  return null;
}",0.9948336433147345
3192,"@Override public void run(){
  Log.d(TAG,""String_Node_Str"");
  for (  AbstractWidgetUpdater updater : Values.widgetUpdaters) {
    updater.widgetLoading(this);
  }
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(this);
  String updateDateString=sp.getString(""String_Node_Str"",""String_Node_Str"");
  boolean update=true;
  if (!force) {
    try {
      Date now=new Date();
      Date lastUpdate=DateFormatters.ISO8601FORMAT.parse(updateDateString);
      long diff=now.getTime() - lastUpdate.getTime();
      long mins=diff / (1000 * 60);
      if (mins < Integer.parseInt(sp.getString(""String_Node_Str"",""String_Node_Str""))) {
        update=false;
      }
    }
 catch (    Exception e) {
      Log.d(TAG,""String_Node_Str"");
    }
  }
  int error=NONE;
  DataFetcher dataFetcher=new DataFetcher(getExceptionReporter());
  if (update) {
    try {
      dataFetcher.updateData(this,force);
    }
 catch (    DataFetcherLoginDetailsException e) {
      Log.d(TAG,e.getMessage());
switch (e.getErrorType()) {
case DataFetcherLoginDetailsException.LOGINFAILED:
        error=LOGINFAILED;
      break;
case DataFetcherLoginDetailsException.USERNAMEPASSWORDNOTSET:
    error=USERNAMEPASSWORD;
  break;
}
Editor edit=sp.edit();
edit.putBoolean(""String_Node_Str"",true);
edit.commit();
}
catch (ClientProtocolException e) {
Log.d(TAG,e.getMessage());
error=NETWORK;
Editor edit=sp.edit();
edit.putBoolean(""String_Node_Str"",true);
edit.commit();
}
catch (IOException e) {
Log.d(TAG,e.getMessage());
error=NETWORK;
Editor edit=sp.edit();
edit.putBoolean(""String_Node_Str"",true);
edit.commit();
}
Log.d(TAG,""String_Node_Str"");
}
 else {
Log.d(TAG,""String_Node_Str"");
}
Log.d(TAG,Integer.toString(error));
for (AbstractWidgetUpdater updater : Values.widgetUpdaters) {
updater.updateWidgets(this,force,error);
}
Log.d(TAG,""String_Node_Str"");
Intent myIntent=new Intent(NEWDATA);
sendBroadcast(myIntent);
if (Values.tracker == null) {
Values.tracker=GoogleAnalyticsTracker.getInstance();
}
Values.tracker.dispatch();
isThreadRunning=false;
stopSelf();
}","@Override public void run(){
  Log.d(TAG,""String_Node_Str"");
  for (  AbstractWidgetUpdater updater : Values.widgetUpdaters) {
    updater.widgetLoading(this);
  }
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(this);
  String updateDateString=sp.getString(""String_Node_Str"",""String_Node_Str"");
  boolean update=true;
  if (!force) {
    try {
      Date now=new Date();
      Date lastUpdate=DateFormatters.ISO8601FORMAT.parse(updateDateString);
      long diff=now.getTime() - lastUpdate.getTime();
      long mins=diff / (1000 * 60);
      if (mins < Integer.parseInt(sp.getString(""String_Node_Str"",""String_Node_Str""))) {
        update=false;
      }
    }
 catch (    Exception e) {
      Log.d(TAG,""String_Node_Str"");
    }
  }
  int error=NONE;
  DataFetcher dataFetcher=new DataFetcher(getExceptionReporter());
  if (update) {
    try {
      dataFetcher.updateData(this,force);
    }
 catch (    DataFetcherLoginDetailsException e) {
      Log.d(TAG,e.getMessage());
switch (e.getErrorType()) {
case DataFetcherLoginDetailsException.LOGINFAILED:
        error=LOGINFAILED;
      break;
case DataFetcherLoginDetailsException.USERNAMEPASSWORDNOTSET:
    error=USERNAMEPASSWORD;
  break;
}
Editor edit=sp.edit();
edit.putBoolean(""String_Node_Str"",true);
edit.commit();
}
catch (ClientProtocolException e) {
Log.d(TAG,e.getMessage());
error=NETWORK;
Editor edit=sp.edit();
edit.putBoolean(""String_Node_Str"",true);
edit.commit();
}
catch (IOException e) {
Log.d(TAG,e.getMessage());
error=NETWORK;
Editor edit=sp.edit();
edit.putBoolean(""String_Node_Str"",true);
edit.commit();
}
Log.d(TAG,""String_Node_Str"");
}
 else {
Log.d(TAG,""String_Node_Str"");
}
Log.d(TAG,Integer.toString(error));
for (AbstractWidgetUpdater updater : Values.widgetUpdaters) {
updater.updateWidgets(this,force,error);
}
Log.d(TAG,""String_Node_Str"");
Intent myIntent=new Intent(NEWDATA);
sendBroadcast(myIntent);
GoogleAnalyticsTracker tracker=GoogleAnalyticsTracker.getInstance();
tracker.dispatch();
isThreadRunning=false;
stopSelf();
}",0.9865624236501344
3193,"@Override protected void fillRemoteViews(RemoteViews updateViews,Context context,int widgetId,int error){
  Log.d(TAG,""String_Node_Str"" + error);
switch (error) {
case UpdateWidgetService.NONE:
case UpdateWidgetService.NETWORK:
    List<Line> lines=buildLines(context);
  if (lines.size() > 0) {
    updateViews.setTextViewText(R.id.widget1x2_line1,lines.get(0).getLineContent());
    if (lines.size() > 1) {
      updateViews.setTextViewText(R.id.widget1x2_line2,lines.get(1).getLineContent());
      if (lines.size() > 2) {
        updateViews.setTextViewText(R.id.widget1x2_line3,lines.get(2).getLineContent());
        for (int i=3; i < lines.size(); i++) {
          if ((lines.get(1).getLineContent() + lines.get(3).getLineContent()).length() < LINELIMIT) {
            updateViews.setTextViewText(R.id.widget1x2_right1,lines.get(i).getLineContent());
            lines.remove(i);
          }
        }
        for (int i=3; i < lines.size(); i++) {
          if ((lines.get(2).getLineContent() + lines.get(3).getLineContent()).length() < LINELIMIT) {
            updateViews.setTextViewText(R.id.widget1x2_right2,lines.get(i).getLineContent());
          }
        }
      }
    }
  }
break;
case UpdateWidgetService.LOGINFAILED:
updateViews.setTextViewText(R.id.widget1x2_line1,""String_Node_Str"");
break;
case UpdateWidgetService.USERNAMEPASSWORD:
updateViews.setTextViewText(R.id.widget1x2_line1,""String_Node_Str"");
break;
}
updateViews.setTextViewText(R.id.widget1x2_lastupdate,getUpdateDateString(context));
Intent viewIntent=new Intent(context,MainActivity.class);
PendingIntent pending=PendingIntent.getActivity(context,0,viewIntent,0);
updateViews.setOnClickPendingIntent(R.id.widget1x2_widget,pending);
Intent updateIntent=new Intent(context,UpdateWidgetService.class);
updateIntent.putExtra(""String_Node_Str"",true);
updateViews.setOnClickPendingIntent(R.id.widget1x2_refreshButton,PendingIntent.getService(context,0,updateIntent,0));
}","@Override protected void fillRemoteViews(RemoteViews updateViews,Context context,int widgetId,int error){
  Log.d(TAG,""String_Node_Str"" + error);
switch (error) {
case UpdateWidgetService.NONE:
case UpdateWidgetService.NETWORK:
    int[] lineIds={R.id.widget1x2_line1,R.id.widget1x2_line2,R.id.widget1x2_line3,R.id.widget1x2_right1,R.id.widget1x2_right2};
  for (  int line : lineIds) {
    updateViews.setTextViewText(line,""String_Node_Str"");
  }
List<Line> lines=buildLines(context);
if (lines.size() > 0) {
updateViews.setTextViewText(R.id.widget1x2_line1,lines.get(0).getLineContent());
if (lines.size() > 1) {
  updateViews.setTextViewText(R.id.widget1x2_line2,lines.get(1).getLineContent());
  if (lines.size() > 2) {
    updateViews.setTextViewText(R.id.widget1x2_line3,lines.get(2).getLineContent());
    for (int i=3; i < lines.size(); i++) {
      if ((lines.get(1).getLineContent() + lines.get(3).getLineContent()).length() < LINELIMIT) {
        updateViews.setTextViewText(R.id.widget1x2_right1,lines.get(i).getLineContent());
        lines.remove(i);
      }
    }
    for (int i=3; i < lines.size(); i++) {
      if ((lines.get(2).getLineContent() + lines.get(3).getLineContent()).length() < LINELIMIT) {
        updateViews.setTextViewText(R.id.widget1x2_right2,lines.get(i).getLineContent());
      }
    }
  }
}
}
break;
case UpdateWidgetService.LOGINFAILED:
updateViews.setTextViewText(R.id.widget1x2_line1,""String_Node_Str"");
break;
case UpdateWidgetService.USERNAMEPASSWORD:
updateViews.setTextViewText(R.id.widget1x2_line1,""String_Node_Str"");
break;
}
updateViews.setTextViewText(R.id.widget1x2_lastupdate,getUpdateDateString(context));
Intent viewIntent=new Intent(context,MainActivity.class);
PendingIntent pending=PendingIntent.getActivity(context,0,viewIntent,0);
updateViews.setOnClickPendingIntent(R.id.widget1x2_widget,pending);
Intent updateIntent=new Intent(context,UpdateWidgetService.class);
updateIntent.putExtra(""String_Node_Str"",true);
updateViews.setOnClickPendingIntent(R.id.widget1x2_refreshButton,PendingIntent.getService(context,0,updateIntent,0));
}",0.9277585353785256
3194,"@Override protected void fillRemoteViews(RemoteViews updateViews,Context context,int widgetId,int error){
switch (error) {
case UpdateWidgetService.NONE:
case UpdateWidgetService.NETWORK:
    List<Line> lines=buildLines(context);
  int[] lineViews={R.id.widget2x2_line2,R.id.widget2x2_line3,R.id.widget2x2_line4,R.id.widget2x2_line5,R.id.widget2x2_line6,R.id.widget2x2_line7,R.id.widget2x2_line8,R.id.widget2x2_line9};
Log.d(TAG,Integer.toString(lines.size()));
for (int n=0; n < lineViews.length; n++) {
if (n >= lines.size()) {
  break;
}
SpannableString formattedLine=new SpannableString(lines.get(n).getLineContent());
if (lines.get(n).getSize() != -1) {
  formattedLine.setSpan(new AbsoluteSizeSpan(Util.dpToPx(context,lines.get(n).getSize())),0,formattedLine.length(),0);
}
 else {
  formattedLine.setSpan(new AbsoluteSizeSpan(Util.dpToPx(context,NORMALSIZE)),0,formattedLine.length(),0);
}
updateViews.setTextViewText(lineViews[n],formattedLine);
}
updateViews.setTextViewText(R.id.widget2x2_line1,getUpdateDateString(context));
break;
case UpdateWidgetService.LOGINFAILED:
updateViews.setTextViewText(R.id.widget2x2_line1,""String_Node_Str"");
break;
case UpdateWidgetService.USERNAMEPASSWORD:
updateViews.setTextViewText(R.id.widget2x2_line1,""String_Node_Str"");
break;
}
Intent viewIntent=new Intent(context,MainActivity.class);
PendingIntent pending=PendingIntent.getActivity(context,0,viewIntent,0);
updateViews.setOnClickPendingIntent(R.id.widget2x2_widget,pending);
}","@Override protected void fillRemoteViews(RemoteViews updateViews,Context context,int widgetId,int error){
switch (error) {
case UpdateWidgetService.NONE:
case UpdateWidgetService.NETWORK:
    List<Line> lines=buildLines(context);
  int[] lineViews={R.id.widget2x2_line2,R.id.widget2x2_line3,R.id.widget2x2_line4,R.id.widget2x2_line5,R.id.widget2x2_line6,R.id.widget2x2_line7,R.id.widget2x2_line8,R.id.widget2x2_line9};
for (int line : lineViews) {
  updateViews.setTextViewText(line,""String_Node_Str"");
}
Log.d(TAG,Integer.toString(lines.size()));
for (int n=0; n < lineViews.length; n++) {
if (n >= lines.size()) {
break;
}
SpannableString formattedLine=new SpannableString(lines.get(n).getLineContent());
if (lines.get(n).getSize() != -1) {
formattedLine.setSpan(new AbsoluteSizeSpan(Util.dpToPx(context,lines.get(n).getSize())),0,formattedLine.length(),0);
}
 else {
formattedLine.setSpan(new AbsoluteSizeSpan(Util.dpToPx(context,NORMALSIZE)),0,formattedLine.length(),0);
}
updateViews.setTextViewText(lineViews[n],formattedLine);
}
updateViews.setTextViewText(R.id.widget2x2_line1,getUpdateDateString(context));
break;
case UpdateWidgetService.LOGINFAILED:
updateViews.setTextViewText(R.id.widget2x2_line1,""String_Node_Str"");
break;
case UpdateWidgetService.USERNAMEPASSWORD:
updateViews.setTextViewText(R.id.widget2x2_line1,""String_Node_Str"");
break;
}
Intent viewIntent=new Intent(context,MainActivity.class);
PendingIntent pending=PendingIntent.getActivity(context,0,viewIntent,0);
updateViews.setOnClickPendingIntent(R.id.widget2x2_widget,pending);
}",0.9696969696969696
3195,"public QuickFindBox() throws Exception {
  super();
  searchEntryField=new TextField(INPUT_QUERY_CSS);
  accounts=new ClickableElement(""String_Node_Str"");
}","public QuickFindBox() throws Exception {
  super();
  searchEntryField=new TextField(INPUT_QUERY_CSS);
  accountsMenuItem=new ClickableElement(""String_Node_Str"");
}",0.975
3196,"private static DefaultSelenium launchStaticSeleniumBrowser(){
  try {
    SeleniumProxySingleton.makeSureWeHaveAJettyProxyRunning();
    seleniumSingleton=new DefaultSelenium(SeleniumProxySingleton.SELENIUM_SERVER_HOST,SeleniumProxySingleton.SELENIUM_SERVER_PORT,getBrowserForTesting(),DashBoard.FFCRM_DOMAIN);
    seleniumSingleton.start();
    seleniumSingleton.setSpeed(""String_Node_Str"");
    seleniumSingleton.setTimeout(STANDARD_PAGE_LOAD_WAIT_TIME);
    seleniumSingleton.windowMaximize();
    return seleniumSingleton;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","private static DefaultSelenium launchStaticSeleniumBrowser(){
  try {
    SeleniumProxySingleton.makeSureWeHaveAJettyProxyRunning();
    seleniumSingleton=new DefaultSelenium(SeleniumProxySingleton.SELENIUM_SERVER_HOST,SeleniumProxySingleton.SELENIUM_SERVER_PORT,getBrowserForTesting(),DashBoard.FFCRM_DOMAIN){
      @Override public void open(      final String url){
        commandProcessor.doCommand(""String_Node_Str"",new String[]{url,""String_Node_Str""});
      }
    }
;
    seleniumSingleton.start();
    seleniumSingleton.setSpeed(""String_Node_Str"");
    seleniumSingleton.setTimeout(STANDARD_PAGE_LOAD_WAIT_TIME);
    seleniumSingleton.windowMaximize();
    return seleniumSingleton;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.8784082535003684
3197,"private static SeleniumServer getInstance() throws Exception, IOException {
  Socket socket=null;
  try {
    socket=new Socket(SELENIUM_SERVER_HOST,SELENIUM_SERVER_PORT);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + SELENIUM_SERVER_PORT);
    System.out.println(""String_Node_Str"" + SELENIUM_SERVER_PORT);
    jettyProxyInstance=startJettyProxy();
    jettyProxyWasStartedByATest=true;
  }
 finally {
    if (socket != null)     socket.close();
  }
  return jettyProxyInstance;
}","private static SeleniumServer getInstance() throws Exception, IOException {
  Socket socket=null;
  try {
    socket=checkWhetherPortIsInUse();
  }
 catch (  Exception e) {
    launchJettyProxy();
  }
 finally {
    if (socket != null)     socket.close();
  }
  return jettyProxyInstance;
}",0.5376884422110553
3198,"@Test public void canFindExistingAccount() throws Exception {
  QuickFindBox quickFind=(QuickFindBox)CommonComponents.topRightLinks.quickFind.clickToNewContainer();
  quickFind.accounts.click();
  AccountPage huckabiesPage=(AccountPage)quickFind.searchForAccount(""String_Node_Str"",AccountPage.class);
  assertTrue(huckabiesPage.title.reads(""String_Node_Str""));
}","@Test public void canFindExistingAccount() throws Exception {
  QuickFindBox quickFind=(QuickFindBox)CommonComponents.topRightLinks.quickFind.clickToNewContainer();
  quickFind.accountsMenuItem.click();
  AccountPage huckabiesPage=(AccountPage)quickFind.searchForAccount(""String_Node_Str"",AccountPage.class);
  assertTrue(huckabiesPage.title.reads(""String_Node_Str""));
}",0.989071038251366
3199,"@AroundInvoke public Object handle(InvocationContext ctx){
  Session session=null;
  try {
    Class<?> declaringClass=ctx.getMethod().getDeclaringClass();
    Method method=ctx.getMethod();
    Object[] params=ctx.getParameters();
    JcrConfiguration sessionConfig=declaringClass.getAnnotation(JcrDao.class).value();
    session=resolver.createSessionFromParameters(sessionConfig,null);
    Class<?> returnType=method.getReturnType();
    if (method.isAnnotationPresent(JcrFind.class)) {
      String uuid=params[0].toString();
      Node foundNode=session.getNodeByIdentifier(uuid);
      Object result=returnType.newInstance();
      ConvertToObject event=new ConvertToObject(foundNode,result);
      ctoEvent.fire(event);
      System.out.println(""String_Node_Str"" + event);
      return result;
    }
 else     if (method.isAnnotationPresent(JcrQuery.class)) {
      JcrQuery jcrQuery=method.getAnnotation(JcrQuery.class);
      String query=jcrQuery.query();
      String language=jcrQuery.language();
      Class<?> target=jcrQuery.resultClass();
      List results=new ArrayList();
      QueryManager queryManager=session.getWorkspace().getQueryManager();
      Query resultQuery=queryManager.createQuery(query,language);
      Annotation[][] annotations=method.getParameterAnnotations();
      for (int i=0; i < params.length; i++) {
        Value value=(Value)params[i];
        JcrParam param=(JcrParam)annotations[i][0];
        resultQuery.bindValue(param.value(),value);
      }
      QueryResult result=resultQuery.execute();
      javax.jcr.NodeIterator nodeIter=result.getNodes();
      while (nodeIter.hasNext()) {
        Node node=nodeIter.nextNode();
        Object nodeobj=target.newInstance();
        ConvertToObject event=new ConvertToObject(node,nodeobj);
        ctoEvent.fire(event);
        results.add(nodeobj);
      }
      return results;
    }
 else     if (method.isAnnotationPresent(JcrSave.class)) {
      String path=params[0].toString();
      Object entityToSave=params[1];
      if (session.nodeExists(path)) {
        Node targetNode=session.getNode(path);
        ConvertToNode ctn=new ConvertToNode(entityToSave,targetNode);
        ctnEvent.fire(ctn);
        return targetNode.getIdentifier();
      }
 else {
        Node parent=session.getRootNode();
        String[] pathLocation=path.replaceFirst(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"");
        for (int i=0; i < pathLocation.length; i++) {
          if (parent.hasNode(pathLocation[i])) {
            parent=parent.getNode(pathLocation[i]);
          }
 else {
            if (i == pathLocation.length) {
            }
 else {
              parent=parent.addNode(pathLocation[i]);
            }
          }
        }
        ConvertToNode ctn=new ConvertToNode(entityToSave,parent);
        ctnEvent.fire(ctn);
        return parent.getIdentifier();
      }
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (session != null) {
      try {
        session.save();
      }
 catch (      RepositoryException e) {
        e.printStackTrace();
      }
      session.logout();
    }
  }
  System.out.println(""String_Node_Str"");
  return null;
}","@AroundInvoke public Object handle(InvocationContext ctx){
  Session session=null;
  try {
    Class<?> declaringClass=ctx.getMethod().getDeclaringClass();
    Method method=ctx.getMethod();
    Object[] params=ctx.getParameters();
    JcrConfiguration sessionConfig=declaringClass.getAnnotation(JcrDao.class).value();
    session=resolver.createSessionFromParameters(sessionConfig,null);
    Class<?> returnType=method.getReturnType();
    if (method.isAnnotationPresent(JcrFind.class)) {
      String uuid=params[0].toString();
      Node foundNode=session.getNodeByIdentifier(uuid);
      Object result=returnType.newInstance();
      ConvertToObject event=new ConvertToObject(foundNode,result);
      ctoEvent.fire(event);
      logger.debug(""String_Node_Str"" + event);
      return result;
    }
 else     if (method.isAnnotationPresent(JcrQuery.class)) {
      JcrQuery jcrQuery=method.getAnnotation(JcrQuery.class);
      String query=jcrQuery.query();
      String language=jcrQuery.language();
      Class<?> target=jcrQuery.resultClass();
      List results=new ArrayList();
      QueryManager queryManager=session.getWorkspace().getQueryManager();
      Query resultQuery=queryManager.createQuery(query,language);
      Annotation[][] annotations=method.getParameterAnnotations();
      for (int i=0; i < params.length; i++) {
        Value value=(Value)params[i];
        JcrParam param=(JcrParam)annotations[i][0];
        resultQuery.bindValue(param.value(),value);
      }
      QueryResult result=resultQuery.execute();
      javax.jcr.NodeIterator nodeIter=result.getNodes();
      while (nodeIter.hasNext()) {
        Node node=nodeIter.nextNode();
        Object nodeobj=target.newInstance();
        ConvertToObject event=new ConvertToObject(node,nodeobj);
        ctoEvent.fire(event);
        results.add(nodeobj);
      }
      return results;
    }
 else     if (method.isAnnotationPresent(JcrSave.class)) {
      String path=params[0].toString();
      Object entityToSave=params[1];
      if (session.nodeExists(path)) {
        Node targetNode=session.getNode(path);
        ConvertToNode ctn=new ConvertToNode(entityToSave,targetNode);
        ctnEvent.fire(ctn);
        return targetNode.getIdentifier();
      }
 else {
        Node parent=session.getRootNode();
        String[] pathLocation=path.replaceFirst(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"");
        for (int i=0; i < pathLocation.length; i++) {
          if (parent.hasNode(pathLocation[i])) {
            parent=parent.getNode(pathLocation[i]);
          }
 else {
            if (i == pathLocation.length) {
            }
 else {
              parent=parent.addNode(pathLocation[i]);
            }
          }
        }
        ConvertToNode ctn=new ConvertToNode(entityToSave,parent);
        ctnEvent.fire(ctn);
        return parent.getIdentifier();
      }
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
 finally {
    if (session != null) {
      try {
        session.save();
      }
 catch (      RepositoryException e) {
        e.printStackTrace();
      }
      session.logout();
    }
  }
  logger.debug(""String_Node_Str"");
  return null;
}",0.9818238309771632
3200,"public <T>void convertNodeToObject(javax.jcr.Node node,Class<?> nodeType,Object returnValue) throws RepositoryException {
  OCMMapping mapping=ocmExtension.getOCMMappingStore().findMapping(nodeType);
  if (mapping == null) {
    throw new RuntimeException(""String_Node_Str"" + nodeType);
  }
  Set<String> jcrProperties=mapping.getPropertiesToFields().keySet();
  for (  String jcrProperty : jcrProperties) {
    Field field=mapping.getPropertiesToFields().get(jcrProperty);
    Object value=null;
    if (field != null && jcrProperty.equalsIgnoreCase(""String_Node_Str"")) {
      value=node.getIdentifier();
    }
 else {
      Property property=node.getProperty(jcrProperty);
      if (field != null && property != null) {
        Class<?> fieldType=field.getType();
        if (fieldType.equals(java.util.Calendar.class)) {
          value=property.getDate();
        }
 else         if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
          value=property.getBoolean();
        }
 else         if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
          value=property.getDouble();
        }
 else         if (fieldType.equals(BigDecimal.class)) {
          value=property.getDecimal();
        }
 else         if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
          value=property.getLong();
        }
 else         if (fieldType.equals(String.class)) {
          value=property.getString();
        }
 else {
          logger.warnf(""String_Node_Str"",field);
        }
      }
    }
    if (value != null) {
      String setterMethodName=""String_Node_Str"" + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1);
      Method method=Reflections.findDeclaredMethod(nodeType,setterMethodName,field.getType());
      Reflections.invokeMethod(method,returnValue,value);
    }
  }
}","public <T>void convertNodeToObject(javax.jcr.Node node,Class<?> nodeType,Object returnValue) throws RepositoryException {
  OCMMapping mapping=ocmExtension.getOCMMappingStore().findMapping(nodeType);
  if (mapping == null) {
    throw new RuntimeException(""String_Node_Str"" + nodeType);
  }
  Set<String> jcrProperties=mapping.getPropertiesToFields().keySet();
  for (  String jcrProperty : jcrProperties) {
    Field field=mapping.getPropertiesToFields().get(jcrProperty);
    Object value=null;
    if (field != null && jcrProperty.equalsIgnoreCase(""String_Node_Str"")) {
      value=node.getIdentifier();
    }
 else {
      try {
        Property property=node.getProperty(jcrProperty);
        if (field != null && property != null) {
          Class<?> fieldType=field.getType();
          if (fieldType.equals(java.util.Calendar.class)) {
            value=property.getDate();
          }
 else           if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
            value=property.getBoolean();
          }
 else           if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
            value=property.getDouble();
          }
 else           if (fieldType.equals(BigDecimal.class)) {
            value=property.getDecimal();
          }
 else           if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
            value=property.getLong();
          }
 else           if (fieldType.equals(String.class)) {
            value=property.getString();
          }
 else {
            logger.warnf(""String_Node_Str"",field);
          }
        }
      }
 catch (      RepositoryException e) {
        logger.debug(""String_Node_Str"" + jcrProperty,e);
      }
    }
    if (value != null) {
      String setterMethodName=""String_Node_Str"" + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1);
      Method method=Reflections.findDeclaredMethod(nodeType,setterMethodName,field.getType());
      Reflections.invokeMethod(method,returnValue,value);
    }
  }
}",0.9560776302349336
3201,"public <T>void objectToNode(T object,javax.jcr.Node node) throws RepositoryException {
  Class<?> nodeType=object.getClass();
  OCMMapping mapping=ocmExtension.getOCMMappingStore().findMapping(nodeType);
  Set<String> jcrProperties=mapping.getPropertiesToFields().keySet();
  for (  String jcrProperty : jcrProperties) {
    Field field=mapping.getPropertiesToFields().get(jcrProperty);
    String getterMethodName=""String_Node_Str"" + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1);
    Method method=Reflections.findDeclaredMethod(nodeType,getterMethodName);
    Object value=Reflections.invokeMethod(method,object);
    if (field != null && jcrProperty.equalsIgnoreCase(""String_Node_Str"")) {
    }
 else {
      if (field != null) {
        Class<?> fieldType=field.getType();
        if (fieldType.equals(java.util.Calendar.class)) {
          node.setProperty(jcrProperty,(Calendar)value);
        }
 else         if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
          node.setProperty(jcrProperty,(Boolean)value);
        }
 else         if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
          node.setProperty(jcrProperty,(Double)value);
        }
 else         if (fieldType.equals(BigDecimal.class)) {
          node.setProperty(jcrProperty,(BigDecimal)value);
        }
 else         if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
          node.setProperty(jcrProperty,(Long)value);
        }
 else         if (fieldType.equals(String.class)) {
          node.setProperty(jcrProperty,value.toString());
        }
 else {
          logger.warnf(""String_Node_Str"",field);
        }
      }
    }
  }
}","public <T>void objectToNode(T object,javax.jcr.Node node) throws RepositoryException {
  Class<?> nodeType=object.getClass();
  OCMMapping mapping=ocmExtension.getOCMMappingStore().findMapping(nodeType);
  Set<String> jcrProperties=mapping.getPropertiesToFields().keySet();
  logger.debug(""String_Node_Str"" + jcrProperties);
  for (  String jcrProperty : jcrProperties) {
    Field field=mapping.getPropertiesToFields().get(jcrProperty);
    logger.debugf(""String_Node_Str"",jcrProperty,field);
    String getterMethodName=""String_Node_Str"" + field.getName().substring(0,1).toUpperCase() + field.getName().substring(1);
    Method method=Reflections.findDeclaredMethod(nodeType,getterMethodName);
    logger.debug(""String_Node_Str"" + method);
    Object value=Reflections.invokeMethod(method,object);
    if (field != null && jcrProperty.equalsIgnoreCase(""String_Node_Str"")) {
    }
 else {
      if (field != null) {
        Class<?> fieldType=field.getType();
        if (fieldType.equals(java.util.Calendar.class)) {
          node.setProperty(jcrProperty,(Calendar)value);
        }
 else         if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
          node.setProperty(jcrProperty,(Boolean)value);
        }
 else         if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
          node.setProperty(jcrProperty,(Double)value);
        }
 else         if (fieldType.equals(BigDecimal.class)) {
          node.setProperty(jcrProperty,(BigDecimal)value);
        }
 else         if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
          node.setProperty(jcrProperty,(Long)value);
        }
 else         if (fieldType.equals(String.class)) {
          node.setProperty(jcrProperty,(String)value);
        }
 else {
          logger.warnf(""String_Node_Str"",field);
        }
      }
    }
  }
}",0.951928451648966
3202,"void map(AnnotatedType<?> annotatedType,JcrNode jcrNode){
  OCMMapping mapping=new OCMMapping();
  mapping.setNodeType(jcrNode.value());
  Class<?> clazz=(Class<?>)annotatedType.getBaseType();
  Field[] fields=clazz.getDeclaredFields();
  mapping.setNodeClass(clazz);
  for (  Field field : fields) {
    logger.debugf(""String_Node_Str"",field.getName());
    String fieldName=field.getName();
    String prop=field.getName();
    JcrProperty property=field.getAnnotation(JcrProperty.class);
    if (property != null) {
      prop=property.value();
    }
    logger.debugf(""String_Node_Str"",fieldName,prop);
    mapping.getPropertiesToFields().put(prop,field);
    mapping.getFieldsToProperties().put(fieldName,prop);
  }
  addMapping(mapping);
}","void map(AnnotatedType<?> annotatedType,JcrNode jcrNode){
  OCMMapping mapping=new OCMMapping();
  mapping.setNodeType(jcrNode.value());
  Class<?> clazz=(Class<?>)annotatedType.getBaseType();
  Field[] fields=clazz.getDeclaredFields();
  Method[] methods=clazz.getMethods();
  mapping.setNodeClass(clazz);
  Map<String,JcrProperty> properties=new HashMap<String,JcrProperty>();
  for (  Method method : methods) {
    if (method.isAnnotationPresent(JcrProperty.class)) {
      String fieldName=getterToFieldName(method.getName());
      properties.put(fieldName,method.getAnnotation(JcrProperty.class));
    }
  }
  for (  Field field : fields) {
    logger.debugf(""String_Node_Str"",field.getName());
    String fieldName=field.getName();
    String prop=field.getName();
    JcrProperty property=field.getAnnotation(JcrProperty.class);
    if (property != null) {
      prop=property.value();
    }
 else     if (properties.containsKey(prop)) {
      prop=properties.get(prop).value();
    }
    logger.debugf(""String_Node_Str"",fieldName,prop);
    mapping.getPropertiesToFields().put(prop,field);
    mapping.getFieldsToProperties().put(fieldName,prop);
  }
  addMapping(mapping);
}",0.7481865284974093
3203,"@Test public void testCreateNodeAndOCM() throws Exception {
  try {
    Node root=session.getRootNode();
    Node hello=root.addNode(""String_Node_Str"",""String_Node_Str"");
    hello.setProperty(""String_Node_Str"",""String_Node_Str"");
    Node hello2=root.getNode(""String_Node_Str"");
    BasicNode bn=nodeConverter.nodeToObject(hello2,BasicNode.class);
    Assert.assertEquals(""String_Node_Str"",bn.getValue());
    Node hello3=root.addNode(""String_Node_Str"",""String_Node_Str"");
    session.save();
    BasicNode bn3=new BasicNode();
    bn3.setValue(""String_Node_Str"");
    Node hello3b=root.getNode(""String_Node_Str"");
    nodeConverter.objectToNode(bn3,hello3b);
    Assert.assertEquals(hello3b.getProperty(""String_Node_Str"").getString(),bn3.getValue());
  }
  finally {
    session.logout();
  }
}","@Test public void testCreateNodeAndOCM() throws Exception {
  try {
    Node root=session.getRootNode();
    Node hello=root.addNode(""String_Node_Str"",""String_Node_Str"");
    hello.setProperty(""String_Node_Str"",""String_Node_Str"");
    hello.setProperty(""String_Node_Str"",""String_Node_Str"");
    Node hello2=root.getNode(""String_Node_Str"");
    BasicNode bn=nodeConverter.nodeToObject(hello2,BasicNode.class);
    Assert.assertEquals(""String_Node_Str"",bn.getValue());
    Assert.assertEquals(""String_Node_Str"",bn.getLordy());
    Node hello3=root.addNode(""String_Node_Str"",""String_Node_Str"");
    session.save();
    BasicNode bn3=new BasicNode();
    bn3.setValue(""String_Node_Str"");
    Node hello3b=root.getNode(""String_Node_Str"");
    nodeConverter.objectToNode(bn3,hello3b);
    Assert.assertEquals(hello3b.getProperty(""String_Node_Str"").getString(),bn3.getValue());
  }
  finally {
    session.logout();
  }
}",0.9309941520467836
3204,"@Test public void testRun(){
  OCMMappingStore ocmMappingStore=extension.getOCMMappingStore();
  OCMMapping mapping=ocmMappingStore.findMapping(BasicNode.class);
  Assert.assertNotNull(mapping);
  Assert.assertEquals(2,mapping.getFieldsToProperties().size());
  String result=mapping.getFieldsToProperties().get(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",result);
  String uuid=mapping.getFieldsToProperties().get(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",uuid);
}","@Test public void testRun(){
  OCMMappingStore ocmMappingStore=extension.getOCMMappingStore();
  OCMMapping mapping=ocmMappingStore.findMapping(BasicNode.class);
  Assert.assertNotNull(mapping);
  Assert.assertEquals(3,mapping.getFieldsToProperties().size());
  String result=mapping.getFieldsToProperties().get(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",result);
  String uuid=mapping.getFieldsToProperties().get(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",uuid);
  String notaproperty=mapping.getFieldsToProperties().get(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",notaproperty);
}",0.8806366047745358
3205,"public static void run(InputStream is,boolean isZip) throws Exception {
  init(is,isZip);
  instCount=0;
  maxInstructions=Long.parseLong(Settings.get(Settings.CORE_MAX_INSTRUCTIONS));
  if (Settings.isSet(Settings.SAVE_PATH)) {
    InputStream saveStream=Util.getStreamFromUrl(Settings.get(Settings.SAVE_PATH));
    if (saveStream != null) {
      mem.loadSram(saveStream);
    }
  }
  if (Settings.get(Settings.SAVE_PATH) != null) {
    File save=new File(Settings.get(Settings.SAVE_PATH));
    if (save != null) {
      mem.loadSram(new FileInputStream(save));
    }
  }
  if (Log.instruction.enabled() && Settings.get(Settings.CPU_ALT_DEBUG) == ""String_Node_Str"") {
    Log.instruction(""String_Node_Str"");
    Log.instruction(""String_Node_Str"");
    Log.instruction(""String_Node_Str"");
  }
  timeBegin=new Date().getTime();
  cycle(maxInstructions);
  timeEnd=new Date().getTime();
  running=false;
  System.out.println(""String_Node_Str"" + ((timeEnd - timeBegin) / 1000) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + instCount);
  System.out.println(""String_Node_Str"" + Timing.getCycles());
  System.out.println(""String_Node_Str"" + (((Timing.getCycles() + 0f) / ((timeEnd - timeBegin + 0f) / 1000f)) / (1024f * 1024f)) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (((Timing.getCycles() + 0f) / ((timeEnd - timeBegin + 0f) / 1000f))) + ""String_Node_Str"");
  printMMaps();
  PPU.dumpVRAM();
  mem.dumpWRAM();
  APUMemory.dump();
  renderScreen();
}","public static void run(InputStream is,boolean isZip) throws Exception {
  init(is,isZip);
  instCount=0;
  maxInstructions=Long.parseLong(Settings.get(Settings.CORE_MAX_INSTRUCTIONS));
  if (Settings.isSet(Settings.SAVE_PATH)) {
    InputStream saveStream=Util.getStreamFromUrl(Settings.get(Settings.SAVE_PATH));
    if (saveStream != null) {
      mem.loadSram(saveStream);
    }
  }
  if (Log.instruction.enabled() && Settings.get(Settings.CPU_ALT_DEBUG) == ""String_Node_Str"") {
    Log.instruction(""String_Node_Str"");
    Log.instruction(""String_Node_Str"");
    Log.instruction(""String_Node_Str"");
  }
  timeBegin=new Date().getTime();
  cycle(maxInstructions);
  timeEnd=new Date().getTime();
  running=false;
  System.out.println(""String_Node_Str"" + ((timeEnd - timeBegin) / 1000) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + instCount);
  System.out.println(""String_Node_Str"" + Timing.getCycles());
  System.out.println(""String_Node_Str"" + (((Timing.getCycles() + 0f) / ((timeEnd - timeBegin + 0f) / 1000f)) / (1024f * 1024f)) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (((Timing.getCycles() + 0f) / ((timeEnd - timeBegin + 0f) / 1000f))) + ""String_Node_Str"");
  printMMaps();
  PPU.dumpVRAM();
  mem.dumpWRAM();
  APUMemory.dump();
  renderScreen();
}",0.9320388349514565
3206,"/** 
 * Ported from bsnes
 */
public int mode7Run(){
  int a=Util.sclip(16,BGRegisters.m7a.val);
  int b=Util.sclip(16,BGRegisters.m7b.val);
  int c=Util.sclip(16,BGRegisters.m7c.val);
  int d=Util.sclip(16,BGRegisters.m7d.val);
  int cx=Util.sclip(13,BGRegisters.m7x.val);
  int cy=Util.sclip(13,BGRegisters.m7y.val);
  int hoffset=Util.sclip(13,PPU.m7HOffset);
  int voffset=Util.sclip(13,PPU.m7VOffset);
  int tempX=PPU.x - 22;
  int tempY=PPU.y;
  if (PPU.m7XFlip)   tempX=255 - tempX;
  if (PPU.m7YFlip)   tempY=255 - tempY;
  int psx=((a * m7Clip(hoffset - cx)) & ~63) + ((b * m7Clip(voffset - cy)) & ~63) + ((b * tempY) & ~63)+ (cx << 8);
  int psy=((c * m7Clip(hoffset - cx)) & ~63) + ((d * m7Clip(voffset - cy)) & ~63) + ((d * tempY) & ~63)+ (cy << 8);
  int px=(psx + (a * tempX)) >> 8;
  int py=(psy + (x * tempX)) >> 8;
  int tile=0, palette=0, priority=0;
switch (PPU.m7Repeat) {
case 0:
case 1:
    px&=1023;
  py&=1023;
tile=PPU.vram[((py >> 3) * 128 + (px >> 3)) << 1];
palette=PPU.vram[(((tile << 6) + ((py & 7) << 3) + (px & 7)) << 1) + 1];
break;
case 2:
if (((px | py) & (~1023)) != 0) {
palette=0;
}
 else {
px&=1023;
py&=1023;
tile=PPU.vram[((py >> 3) * 128 + (px >> 3)) << 1];
palette=PPU.vram[(((tile << 6) + ((py & 7) << 3) + (px & 7)) << 1) + 1];
}
break;
case 3:
if (((px | py) & (~1023)) != 0) {
tile=0;
}
 else {
px&=1023;
py&=1023;
tile=PPU.vram[((py >> 3) * 128 + (px >> 3)) << 1];
}
palette=PPU.vram[(((tile << 6) + ((py & 7) << 3) + (px & 7)) << 1) + 1];
break;
}
if (num == 1) {
priority=priority0;
}
 else if (num == 2) {
priority=((palette & 0x80) != 0 ? priority1 : priority0);
palette&=0x7f;
}
if (palette != 0 && enabled()) {
boolean masked=Window.checkBackgroundMask(this);
boolean mainMask=windowMaskMain && masked;
boolean subMask=windowMaskSub && masked;
if (mainScreen && !mainMask && priority > PPU.priorityMain) {
PPU.priorityMain=priority;
PPU.colorMain=palette;
PPU.sourceMain=num - 1;
}
if (subScreen && !subMask && priority > PPU.prioritySub) {
PPU.prioritySub=priority;
PPU.colorSub=palette;
PPU.sourceSub=num - 1;
}
}
x++;
return palette;
}","/** 
 * Ported from bsnes
 */
public int mode7Run(){
  int a=Util.sclip(16,BGRegisters.m7a.val);
  int b=Util.sclip(16,BGRegisters.m7b.val);
  int c=Util.sclip(16,BGRegisters.m7c.val);
  int d=Util.sclip(16,BGRegisters.m7d.val);
  int cx=Util.sclip(13,BGRegisters.m7x.val);
  int cy=Util.sclip(13,BGRegisters.m7y.val);
  int hoffset=Util.sclip(13,PPU.m7HOffset);
  int voffset=Util.sclip(13,PPU.m7VOffset);
  int tempX=PPU.x - 22;
  int tempY=PPU.y;
  if (PPU.m7XFlip)   tempX=255 - tempX;
  if (PPU.m7YFlip)   tempY=255 - tempY;
  int psx=((a * m7Clip(hoffset - cx)) & (~63)) + ((b * m7Clip(voffset - cy)) & (~63)) + ((b * tempY) & (~63))+ (cx << 8);
  int psy=((c * m7Clip(hoffset - cx)) & (~63)) + ((d * m7Clip(voffset - cy)) & (~63)) + ((d * tempY) & (~63))+ (cy << 8);
  int px=(psx + (a * tempX)) >> 8;
  int py=(psy + (c * tempX)) >> 8;
  int tile=0, palette=0, priority=0;
switch (PPU.m7Repeat) {
case 0:
case 1:
    px&=1023;
  py&=1023;
tile=PPU.vram[((py >> 3) * 128 + (px >> 3)) << 1];
palette=PPU.vram[(((tile << 6) + ((py & 7) << 3) + (px & 7)) << 1) + 1];
break;
case 2:
if (((px | py) & (~1023)) != 0) {
palette=0;
}
 else {
px&=1023;
py&=1023;
tile=PPU.vram[((py >> 3) * 128 + (px >> 3)) << 1];
palette=PPU.vram[(((tile << 6) + ((py & 7) << 3) + (px & 7)) << 1) + 1];
}
break;
case 3:
if (((px | py) & (~1023)) != 0) {
tile=0;
}
 else {
px&=1023;
py&=1023;
tile=PPU.vram[((py >> 3) * 128 + (px >> 3)) << 1];
}
palette=PPU.vram[(((tile << 6) + ((py & 7) << 3) + (px & 7)) << 1) + 1];
break;
}
if (num == 1) {
priority=priority0;
}
 else if (num == 2) {
priority=((palette & 0x80) != 0 ? priority1 : priority0);
palette&=0x7f;
}
if (palette != 0 && enabled()) {
boolean masked=Window.checkBackgroundMask(this);
boolean mainMask=windowMaskMain && masked;
boolean subMask=windowMaskSub && masked;
if (mainScreen && !mainMask && priority > PPU.priorityMain) {
PPU.priorityMain=priority;
PPU.colorMain=palette;
PPU.sourceMain=num - 1;
}
if (subScreen && !subMask && priority > PPU.prioritySub) {
PPU.prioritySub=priority;
PPU.colorSub=palette;
PPU.sourceSub=num - 1;
}
}
x++;
return palette;
}",0.9966634890371784
3207,"/** 
 * From anomie's doc
 * @param a
 * @return
 */
private int m7Clip(int a){
  if ((a & 0x2000) != 0) {
    return a | (~0x3ff);
  }
 else {
    return a & 0x3ff;
  }
}","/** 
 * 13 bit sign extend; ported from bsnes
 */
private int m7Clip(int a){
  if ((a & 0x2000) != 0) {
    return a | (~0x3ff);
  }
 else {
    return a & 0x3ff;
  }
}",0.8141592920353983
3208,"/** 
 * Calculates the address of the current tile using x and y and loads it into tile. Also processes some attributes of the current tile.
 */
public void loadTile(){
  xTilePos=x / tileWidth;
  yTilePos=y / tileHeight;
  tile=cacheTilemap[xTilePos][yTilePos];
  if (tile == 0)   tile=cacheTilemap[xTilePos][yTilePos]=PPU.vram[tileMapAddress] | (PPU.vram[tileMapAddress + 1] << 8);
  pixelY=y % tileHeight;
  if ((tile & 0x8000) != 0) {
    pixelY=tileHeight - pixelY - 1;
  }
  tilePaletteOffset=getPaletteOffset();
  curPriority=(((tile >> 13) & 1) != 0 ? priority1 : priority0);
}","/** 
 * Calculates the address of the current tile using x and y and loads it into tile. Also processes some attributes of the current tile.
 */
public void loadTile(){
  xTilePos=x / tileWidth;
  yTilePos=y / tileHeight;
  tile=cacheTilemap[xTilePos][yTilePos];
  pixelY=y % tileHeight;
  if ((tile & 0x8000) != 0) {
    pixelY=tileHeight - pixelY - 1;
  }
  tilePaletteOffset=getPaletteOffset();
  curPriority=(((tile >> 13) & 1) != 0 ? priority1 : priority0);
}",0.8846520495710201
3209,"void rebuildTilemap(int addr){
  if (addr >= tileMapAddress + 0x2000) {
    return;
  }
  int origAddr=addr;
  addr-=(addr % 2);
  int taddr=addr;
  int tileX=0;
  int tileY=0;
  addr-=tileMapAddress;
switch (size) {
case bg32x32:
    break;
case bg32x64:
  if (addr >= 0x800) {
    tileY+=32;
    addr-=0x0800;
  }
break;
case bg64x32:
if (addr >= 0x800) {
tileX+=32;
addr-=0x0800;
}
break;
case bg64x64:
if (addr >= 0x1800) {
tileX+=32;
tileY+=32;
addr-=0x1800;
}
 else if (addr >= 0x1000) {
tileY+=32;
addr-=0x1000;
}
 else if (addr >= 0x0800) {
tileX+=32;
addr-=0x0800;
}
break;
}
tileY+=addr / 64;
addr%=64;
tileX+=addr / 2;
cacheTilemap[tileX][tileY]=PPU.vram[taddr] | (PPU.vram[taddr + 1] << 8);
}","void rebuildTilemap(int addr){
  addr-=(addr % 2);
  int taddr=addr;
  int tileX=0;
  int tileY=0;
  addr-=tileMapAddress;
switch (size) {
case bg32x64:
case bg64x32:
    if (addr >= 0x800) {
      tileX+=32;
      addr-=0x0800;
    }
  break;
case bg64x64:
if (addr >= 0x1800) {
  tileX+=32;
  tileY+=32;
  addr-=0x1800;
}
 else if (addr >= 0x1000) {
  tileY+=32;
  addr-=0x1000;
}
 else if (addr >= 0x0800) {
  tileX+=32;
  addr-=0x0800;
}
break;
}
tileY+=addr / 64;
addr%=64;
tileX+=addr / 2;
cacheTilemap[tileX][tileY]=PPU.vram[taddr] | (PPU.vram[taddr + 1] << 8);
}",0.7221350078492935
3210,"public static void cycle(long numCycles){
  totalCycles+=numCycles;
  sinceLastScanline+=numCycles;
  if (sinceLastScanline >= 536 && !wramRefreshed) {
    numCycles+=40;
    totalCycles+=40;
    wramRefreshed=true;
  }
  if (currentScanline == 0 && !hdmaStarted) {
    DMA.HDMAInit();
    hdmaStarted=true;
  }
  PPU.renderCycles(numCycles);
  checkIRQ();
  while (sinceLastScanline > cyclesPerScanLine) {
    sinceLastScanline-=cyclesPerScanLine;
    currentScanline++;
    irqOnCurrentLine=false;
    PPU.scanline();
    DMA.HDMARun();
    if (currentScanline == 0xE1) {
      CPU.triggerVBlank();
      PPU.vBlank();
      Core.advanceFrameOnce=false;
      break;
    }
  }
  if (currentScanline == 0xE3 && CPU.standardControllerRead) {
    Input.autoRead();
  }
  if (currentScanline >= scanlines) {
    currentScanline=0;
    wramRefreshed=false;
    PPU.vBlanking=false;
    hdmaStarted=false;
  }
  if (currentScanline >= 0xE1) {
    CPURegisters.rdnmi.val|=0x80;
  }
 else {
    CPURegisters.rdnmi.val&=0x7F;
  }
  toremove.clear();
  for (  TimerCallback t : callbacks) {
    if (t.callbackTime <= totalCycles) {
      System.out.println(""String_Node_Str"" + t);
      t.callback();
      toremove.add(t);
    }
  }
  for (  TimerCallback t : toremove)   callbacks.remove(t);
  cyclesToCatchup+=numCycles;
  if (limitSpeed && currentScanline == 1) {
    long sleep, elapsed;
    do {
      elapsed=System.nanoTime() - lastTime;
      sleep=cyclesToCatchup * cycleTimeNS - elapsed;
    }
 while (sleep > cycleTimeNS);
    lastTime=System.nanoTime();
    cyclesToCatchup=0;
  }
  if (autoFrameSkip) {
    long duration=numCycles * cycleTimeNS;
    long actualDuration=System.nanoTime() - lastTime;
    if (actualDuration > duration) {
      PPU.renderFrames=false;
    }
 else {
      PPU.renderFrames=true;
    }
  }
}","public static void cycle(long numCycles){
  totalCycles+=numCycles;
  sinceLastScanline+=numCycles;
  if (sinceLastScanline >= 536 && !wramRefreshed) {
    numCycles+=40;
    totalCycles+=40;
    wramRefreshed=true;
  }
  if (currentScanline == 0 && !hdmaStarted) {
    DMA.HDMAInit();
    hdmaStarted=true;
  }
  PPU.renderCycles(numCycles);
  checkIRQ();
  while (sinceLastScanline > cyclesPerScanLine) {
    sinceLastScanline-=cyclesPerScanLine;
    currentScanline++;
    irqOnCurrentLine=false;
    PPU.scanline();
    DMA.HDMARun();
    if (currentScanline == 0xE1) {
      CPU.triggerVBlank();
      PPU.vBlank();
      Core.advanceFrameOnce=false;
      break;
    }
    if (currentScanline == 0xE3 && CPU.standardControllerRead) {
      Input.autoRead();
    }
  }
  if (currentScanline >= scanlines) {
    currentScanline=0;
    wramRefreshed=false;
    PPU.vBlanking=false;
    hdmaStarted=false;
  }
  if (currentScanline >= 0xE1) {
    CPURegisters.rdnmi.val|=0x80;
  }
 else {
    CPURegisters.rdnmi.val&=0x7F;
  }
  toremove.clear();
  for (  TimerCallback t : callbacks) {
    if (t.callbackTime <= totalCycles) {
      System.out.println(""String_Node_Str"" + t);
      t.callback();
      toremove.add(t);
    }
  }
  for (  TimerCallback t : toremove)   callbacks.remove(t);
  cyclesToCatchup+=numCycles;
  if (limitSpeed && currentScanline == 1) {
    long sleep, elapsed;
    do {
      elapsed=System.nanoTime() - lastTime;
      sleep=cyclesToCatchup * cycleTimeNS - elapsed;
    }
 while (sleep > cycleTimeNS);
    lastTime=System.nanoTime();
    cyclesToCatchup=0;
  }
  if (autoFrameSkip) {
    long duration=numCycles * cycleTimeNS;
    long actualDuration=System.nanoTime() - lastTime;
    if (actualDuration > duration) {
      PPU.renderFrames=false;
    }
 else {
      PPU.renderFrames=true;
    }
  }
}",0.9972677595628416
3211,"/** 
 * Cycles through each active tile and checks if it has a pixel at the  current x/y position on the screen, and outputs if one is found. Called once per on-screen pixel by PPU
 */
public static void loadPixel(){
  SpriteTile curTile;
  for (int k=0; k < numTiles; k++) {
    curTile=curTiles[k];
    if (Util.inRange(PPU.x - 22,curTile.x,curTile.x + 7)) {
      int color=curTile.getPixel((PPU.x - 22) - curTile.x,PPU.y - 1 - curTile.y);
      if (color == 0 || !userEnabled)       continue;
      if (mainScreen && curTile.priority > PPU.priorityMain) {
        PPU.colorMain=color + curTile.paletteOffset;
        PPU.priorityMain=curTile.priority;
        PPU.sourceMain=PPU.SRC_OAM;
      }
      if (subScreen && curTile.priority > PPU.prioritySub) {
        PPU.colorSub=color + curTile.paletteOffset;
        PPU.prioritySub=curTile.priority;
        PPU.sourceSub=PPU.SRC_OAM;
      }
    }
  }
}","/** 
 * Cycles through each active tile and checks if it has a pixel at the  current x/y position on the screen, and outputs if one is found. Called once per on-screen pixel by PPU
 */
public static void loadPixel(){
  SpriteTile curTile;
  for (int k=0; k < numTiles; k++) {
    curTile=curTiles[k];
    if (Util.inRange(PPU.x - 22,curTile.x,curTile.x + 7)) {
      int color=curTile.getPixel((PPU.x - 22) - curTile.x,PPU.y - 1 - curTile.y);
      if (color == 0 || !userEnabled)       continue;
      if (mainScreen && curTile.priority >= PPU.priorityMain) {
        PPU.colorMain=color + curTile.paletteOffset;
        PPU.priorityMain=curTile.priority;
        PPU.sourceMain=PPU.SRC_OAM;
      }
      if (subScreen && curTile.priority >= PPU.prioritySub) {
        PPU.colorSub=color + curTile.paletteOffset;
        PPU.prioritySub=curTile.priority;
        PPU.sourceSub=PPU.SRC_OAM;
      }
    }
  }
}",0.9989010989010988
3212,"private int dmaTransferPPUOnce(int fromBank,int fromAddress,int toBank,int toAddress){
  int size=0;
  int tmp=0;
  if (transferMode == 0x0) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    size=1;
  }
 else   if (transferMode == 0x01) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 0);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 1);
    Core.mem.set(Size.BYTE,toBank,toAddress + 1,tmp);
    size=2;
  }
 else   if (transferMode == 0x02 || transferMode == 0x06) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 0);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 1);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    size=2;
  }
 else   if (transferMode == 0x03 || transferMode == 0x07) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 0);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 1);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 2);
    Core.mem.set(Size.BYTE,toBank,toAddress + 1,tmp);
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 3);
    Core.mem.set(Size.BYTE,toBank,toAddress + 1,tmp);
    size=4;
  }
 else   if (transferMode == 0x04) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 0);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 1);
    Core.mem.set(Size.BYTE,toBank,toAddress + 1,tmp);
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 2);
    Core.mem.set(Size.BYTE,toBank,toAddress + 2,tmp);
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 3);
    Core.mem.set(Size.BYTE,toBank,toAddress + 3,tmp);
    size=4;
  }
 else {
    System.out.println(""String_Node_Str"");
    return 0;
  }
  return size;
}","private int dmaTransferPPUOnce(int fromBank,int fromAddress,int toBank,int toAddress){
  int size=0;
  int tmp=0;
  if (transferMode == 0x0) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    size=1;
  }
 else   if (transferMode == 0x01) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 0);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    if (!fixedTransfer)     tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 1);
    Core.mem.set(Size.BYTE,toBank,toAddress + 1,tmp);
    size=2;
  }
 else   if (transferMode == 0x02 || transferMode == 0x06) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 0);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    if (!fixedTransfer)     tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 1);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    size=2;
  }
 else   if (transferMode == 0x03 || transferMode == 0x07) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 0);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    if (!fixedTransfer)     tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 1);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    if (!fixedTransfer)     tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 2);
    Core.mem.set(Size.BYTE,toBank,toAddress + 1,tmp);
    if (!fixedTransfer)     tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 3);
    Core.mem.set(Size.BYTE,toBank,toAddress + 1,tmp);
    size=4;
  }
 else   if (transferMode == 0x04) {
    tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 0);
    Core.mem.set(Size.BYTE,toBank,toAddress,tmp);
    if (!fixedTransfer)     tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 1);
    Core.mem.set(Size.BYTE,toBank,toAddress + 1,tmp);
    if (!fixedTransfer)     tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 2);
    Core.mem.set(Size.BYTE,toBank,toAddress + 2,tmp);
    if (!fixedTransfer)     tmp=Core.mem.get(Size.BYTE,fromBank,fromAddress + 3);
    Core.mem.set(Size.BYTE,toBank,toAddress + 3,tmp);
    size=4;
  }
 else {
    System.out.println(""String_Node_Str"");
    return 0;
  }
  return size;
}",0.9524752475247524
3213,"/** 
 * Resets the x and y values to 0 (handling scrolling) and load the first tile of scanline 0
 */
public void vBlank(){
  x=getHScroll();
  y=getVScroll();
  loadTile();
}","/** 
 * Resets the x and y values to 0 (handling scrolling) and load the first tile of scanline 0
 */
public void vBlank(){
  x=getHScroll();
  baseY=0;
  y=baseY + getVScroll() % (size.height * tileHeight);
  loadTile();
}",0.8793969849246231
3214,"/** 
 * Resets x and y to the beginning of the next scanline and loads the first tile in the scanline
 */
public void nextScanline(){
  y=(y + 1) % (size.height * tileHeight);
  x=getHScroll();
  loadTile();
}","/** 
 * Resets x and y to the beginning of the next scanline and loads the first tile in the scanline
 */
public void nextScanline(){
  baseY=(baseY + 1);
  y=(baseY + getVScroll()) % (size.height * tileHeight);
  x=getHScroll();
  loadTile();
}",0.9118942731277532
3215,"/** 
 * Loads and outputs the current pixel and increments x to move to the next pixel in the scanline.
 */
public void loadPixel(){
  int index=0;
  int pixelX=x % tileWidth;
  if ((tile & 0x4000) != 0) {
    pixelX=tileWidth - pixelX - 1;
  }
  int xMask=0x80 >> (pixelX % 8);
switch (colorMode) {
case Color4:
    index|=((PPU.vram[characterAddr] & xMask) != 0) ? 0x1 : 0;
  index|=((PPU.vram[characterAddr + 1] & xMask) != 0) ? 0x2 : 0;
break;
case Color16:
index|=((PPU.vram[characterAddr] & xMask) != 0) ? 0x1 : 0;
index|=((PPU.vram[characterAddr + 1] & xMask) != 0) ? 0x2 : 0;
index|=((PPU.vram[characterAddr + 16] & xMask) != 0) ? 0x4 : 0;
index|=((PPU.vram[characterAddr + 17] & xMask) != 0) ? 0x8 : 0;
break;
case Color256:
index|=((PPU.vram[characterAddr] & xMask) != 0) ? 0x1 : 0;
index|=((PPU.vram[characterAddr + 1] & xMask) != 0) ? 0x2 : 0;
index|=((PPU.vram[characterAddr + 16] & xMask) != 0) ? 0x4 : 0;
index|=((PPU.vram[characterAddr + 17] & xMask) != 0) ? 0x8 : 0;
index|=((PPU.vram[characterAddr + 32] & xMask) != 0) ? 0x10 : 0;
index|=((PPU.vram[characterAddr + 33] & xMask) != 0) ? 0x20 : 0;
index|=((PPU.vram[characterAddr + 48] & xMask) != 0) ? 0x40 : 0;
index|=((PPU.vram[characterAddr + 49] & xMask) != 0) ? 0x80 : 0;
break;
}
if (mainScreen) {
if (index == 0) {
outMainPriority=0;
}
 else {
outMainPriority=curPriority;
outMainPixel=index + tilePaletteOffset;
}
}
if (subScreen) {
if (index == 0) {
outSubPriority=0;
}
 else {
outSubPriority=curPriority;
outSubPixel=index + tilePaletteOffset;
}
}
x=(x + 1) % (size.width * tileWidth);
if (((x % 8) == 0 && !tile16px) || (x % 16) == 0) {
loadTile();
}
 else if ((x % 16) == 8 && tile16px) {
characterAddr+=8 * colorMode.bitDepth;
}
}","/** 
 * Loads and outputs the current pixel and increments x to move to the next pixel in the scanline.
 */
public int loadPixel(){
  int index=0;
  int pixelX=x % tileWidth;
  if ((tile & 0x4000) != 0) {
    pixelX=tileWidth - pixelX - 1;
  }
  int xMask=0x80 >> (pixelX % 8);
switch (colorMode) {
case Color4:
    index|=((PPU.vram[characterAddr] & xMask) != 0) ? 0x1 : 0;
  index|=((PPU.vram[characterAddr + 1] & xMask) != 0) ? 0x2 : 0;
break;
case Color16:
index|=((PPU.vram[characterAddr] & xMask) != 0) ? 0x1 : 0;
index|=((PPU.vram[characterAddr + 1] & xMask) != 0) ? 0x2 : 0;
index|=((PPU.vram[characterAddr + 16] & xMask) != 0) ? 0x4 : 0;
index|=((PPU.vram[characterAddr + 17] & xMask) != 0) ? 0x8 : 0;
break;
case Color256:
index|=((PPU.vram[characterAddr] & xMask) != 0) ? 0x1 : 0;
index|=((PPU.vram[characterAddr + 1] & xMask) != 0) ? 0x2 : 0;
index|=((PPU.vram[characterAddr + 16] & xMask) != 0) ? 0x4 : 0;
index|=((PPU.vram[characterAddr + 17] & xMask) != 0) ? 0x8 : 0;
index|=((PPU.vram[characterAddr + 32] & xMask) != 0) ? 0x10 : 0;
index|=((PPU.vram[characterAddr + 33] & xMask) != 0) ? 0x20 : 0;
index|=((PPU.vram[characterAddr + 48] & xMask) != 0) ? 0x40 : 0;
index|=((PPU.vram[characterAddr + 49] & xMask) != 0) ? 0x80 : 0;
break;
}
if (mainScreen) {
if (index == 0) {
outMainPriority=0;
}
 else {
outMainPriority=curPriority;
outMainPixel=index + tilePaletteOffset;
}
}
if (subScreen) {
if (index == 0) {
outSubPriority=0;
}
 else {
outSubPriority=curPriority;
outSubPixel=index + tilePaletteOffset;
}
}
x=(x + 1) % (size.width * tileWidth);
if (((x % 8) == 0 && !tile16px) || (x % 16) == 0) {
loadTile();
}
 else if ((x % 16) == 8 && tile16px) {
characterAddr+=8 * colorMode.bitDepth;
}
return (index == 0 ? 0 : index + tilePaletteOffset);
}",0.9827188940092166
3216,"public static void run(InputStream is,boolean isZip) throws Exception {
  init(is,isZip);
  instCount=0;
  maxInstructions=Long.parseLong(Settings.get(Settings.CORE_MAX_INSTRUCTIONS));
  if (Settings.isSet(Settings.SAVE_PATH)) {
    InputStream saveStream=Util.getStreamFromUrl(Settings.get(Settings.SAVE_PATH));
    if (saveStream != null) {
      mem.loadSram(saveStream);
    }
  }
  File save=new File(Settings.get(Settings.SAVE_PATH));
  if (save != null) {
    mem.loadSram(new FileInputStream(save));
  }
  if (Log.instruction.enabled() && Settings.get(Settings.CPU_ALT_DEBUG) == ""String_Node_Str"") {
    Log.instruction(""String_Node_Str"");
    Log.instruction(""String_Node_Str"");
    Log.instruction(""String_Node_Str"");
  }
  timeBegin=new Date().getTime();
  cycle(maxInstructions);
  timeEnd=new Date().getTime();
  running=false;
  System.out.println(""String_Node_Str"" + ((timeEnd - timeBegin) / 1000) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + instCount);
  System.out.println(""String_Node_Str"" + Timing.getCycles());
  System.out.println(""String_Node_Str"" + (((Timing.getCycles() + 0f) / ((timeEnd - timeBegin + 0f) / 1000f)) / (1024f * 1024f)) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (((Timing.getCycles() + 0f) / ((timeEnd - timeBegin + 0f) / 1000f))) + ""String_Node_Str"");
  printMMaps();
  PPU.dumpVRAM();
  mem.dumpWRAM();
  APUMemory.dump();
  renderScreen();
}","public static void run(InputStream is,boolean isZip) throws Exception {
  init(is,isZip);
  instCount=0;
  maxInstructions=Long.parseLong(Settings.get(Settings.CORE_MAX_INSTRUCTIONS));
  if (Settings.isSet(Settings.SAVE_PATH)) {
    InputStream saveStream=Util.getStreamFromUrl(Settings.get(Settings.SAVE_PATH));
    if (saveStream != null) {
      mem.loadSram(saveStream);
    }
  }
  if (Settings.get(Settings.SAVE_PATH) != null) {
    File save=new File(Settings.get(Settings.SAVE_PATH));
    if (save != null) {
      mem.loadSram(new FileInputStream(save));
    }
  }
  if (Log.instruction.enabled() && Settings.get(Settings.CPU_ALT_DEBUG) == ""String_Node_Str"") {
    Log.instruction(""String_Node_Str"");
    Log.instruction(""String_Node_Str"");
    Log.instruction(""String_Node_Str"");
  }
  timeBegin=new Date().getTime();
  cycle(maxInstructions);
  timeEnd=new Date().getTime();
  running=false;
  System.out.println(""String_Node_Str"" + ((timeEnd - timeBegin) / 1000) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + instCount);
  System.out.println(""String_Node_Str"" + Timing.getCycles());
  System.out.println(""String_Node_Str"" + (((Timing.getCycles() + 0f) / ((timeEnd - timeBegin + 0f) / 1000f)) / (1024f * 1024f)) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (((Timing.getCycles() + 0f) / ((timeEnd - timeBegin + 0f) / 1000f))) + ""String_Node_Str"");
  printMMaps();
  PPU.dumpVRAM();
  mem.dumpWRAM();
  APUMemory.dump();
  renderScreen();
}",0.9484181568088031
3217,"public void set(Size size,int bank,int addr,int val){
  if (Util.inRange(bank,0x0,0x3F)) {
    if (addr < 0x2000) {
      setInArray(size,wram,addr,val);
      return;
    }
 else     if (addr >= 0x2000 && addr < 0x6000) {
      writeHWReg(size,addr,val);
      return;
    }
 else     if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
 else   if (Util.inRange(bank,0x40,0x7C)) {
    if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
 else   if (bank == 0x7D) {
    if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
 else   if (bank == 0x7E) {
    setInArray(size,wram,addr,val);
    return;
  }
 else   if (bank == 0x7F) {
    setInArray(size,wram,(addr + 0x8000),val);
    return;
  }
 else   if (Util.inRange(bank,0x80,0xBF)) {
    if (addr < 0x2000) {
      setInArray(size,wram,addr,val);
      return;
    }
 else     if (addr >= 0x2000 && addr < 0x6000) {
      writeHWReg(size,addr,val);
      return;
    }
 else     if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
 else   if (Util.inRange(bank,0xC0,0xFF)) {
    if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
  if (Settings.get(Settings.MEM_THROW_INVALID_ADDR).equals(""String_Node_Str""))   throw new RuntimeException(String.format(""String_Node_Str"",bank,addr));
}","public void set(Size size,int bank,int addr,int val){
  if (Util.inRange(bank,0x0,0x3F)) {
    if (addr < 0x2000) {
      setInArray(size,wram,addr,val);
      return;
    }
 else     if (addr >= 0x2000 && addr < 0x6000) {
      writeHWReg(size,addr,val);
      return;
    }
 else     if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
 else   if (Util.inRange(bank,0x40,0x7C)) {
    if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
 else   if (bank == 0x7D) {
    if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
 else   if (bank == 0x7E) {
    setInArray(size,wram,addr,val);
    return;
  }
 else   if (bank == 0x7F) {
    setInArray(size,wram,(addr + 0x10000),val);
    return;
  }
 else   if (Util.inRange(bank,0x80,0xBF)) {
    if (addr < 0x2000) {
      setInArray(size,wram,addr,val);
      return;
    }
 else     if (addr >= 0x2000 && addr < 0x6000) {
      writeHWReg(size,addr,val);
      return;
    }
 else     if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
 else   if (Util.inRange(bank,0xC0,0xFF)) {
    if (addr >= 0x8000) {
      invalidMemoryWrite(""String_Node_Str"",bank,addr);
    }
  }
  if (Settings.get(Settings.MEM_THROW_INVALID_ADDR).equals(""String_Node_Str""))   throw new RuntimeException(String.format(""String_Node_Str"",bank,addr));
}",0.9989388043862752
3218,"public int get(Size size,int bank,int addr){
  if (Util.inRange(bank,0x0,0x3F)) {
    if (addr < 0x2000) {
      return getFromArray(size,wram,addr);
    }
 else     if (addr >= 0x2000 && addr < 0x6000) {
      return readHWReg(size,addr);
    }
 else     if (addr >= 0x8000) {
      return getFromArray(size,rom,(bank * 0x8000) + (addr - 0x8000));
    }
  }
 else   if (Util.inRange(bank,0x40,0x7C)) {
    if (addr >= 0x8000) {
      return getFromArray(size,rom,(bank * 0x8000) + (addr - 0x8000));
    }
  }
 else   if (bank == 0x7D) {
    if (addr < 0x8000) {
      return 0;
    }
 else {
      return getFromArray(size,rom,(bank * 0x8000) + (addr - 0x8000));
    }
  }
 else   if (bank == 0x7E) {
    return getFromArray(size,wram,addr);
  }
 else   if (bank == 0x7F) {
    return getFromArray(size,wram,(addr + 0x8000));
  }
 else   if (Util.inRange(bank,0x80,0xBF)) {
    if (addr < 0x2000) {
      return getFromArray(size,wram,addr);
    }
 else     if (addr >= 0x2000 && addr < 0x6000) {
      return readHWReg(size,addr);
    }
 else     if (addr >= 0x8000) {
      return getFromArray(size,rom,((bank - 0x80) * 0x8000) + (addr - 0x8000));
    }
  }
 else   if (Util.inRange(bank,0xC0,0xFF)) {
    if (addr >= 0x8000) {
      return getFromArray(size,rom,((bank - 0x80) * 0x8000) + (addr - 0x8000));
    }
  }
  if (Settings.get(Settings.MEM_THROW_INVALID_ADDR).equals(""String_Node_Str""))   throw new RuntimeException(String.format(""String_Node_Str"",bank,addr));
  return 0;
}","public int get(Size size,int bank,int addr){
  if (Util.inRange(bank,0x0,0x3F)) {
    if (addr < 0x2000) {
      return getFromArray(size,wram,addr);
    }
 else     if (addr >= 0x2000 && addr < 0x6000) {
      return readHWReg(size,addr);
    }
 else     if (addr >= 0x8000) {
      return getFromArray(size,rom,(bank * 0x8000) + (addr - 0x8000));
    }
  }
 else   if (Util.inRange(bank,0x40,0x7C)) {
    if (addr >= 0x8000) {
      return getFromArray(size,rom,(bank * 0x8000) + (addr - 0x8000));
    }
  }
 else   if (bank == 0x7D) {
    if (addr < 0x8000) {
      return 0;
    }
 else {
      return getFromArray(size,rom,(bank * 0x8000) + (addr - 0x8000));
    }
  }
 else   if (bank == 0x7E) {
    return getFromArray(size,wram,addr);
  }
 else   if (bank == 0x7F) {
    return getFromArray(size,wram,(addr + 0x10000));
  }
 else   if (Util.inRange(bank,0x80,0xBF)) {
    if (addr < 0x2000) {
      return getFromArray(size,wram,addr);
    }
 else     if (addr >= 0x2000 && addr < 0x6000) {
      return readHWReg(size,addr);
    }
 else     if (addr >= 0x8000) {
      return getFromArray(size,rom,((bank - 0x80) * 0x8000) + (addr - 0x8000));
    }
  }
 else   if (Util.inRange(bank,0xC0,0xFF)) {
    if (addr >= 0x8000) {
      return getFromArray(size,rom,((bank - 0x80) * 0x8000) + (addr - 0x8000));
    }
  }
  if (Settings.get(Settings.MEM_THROW_INVALID_ADDR).equals(""String_Node_Str""))   throw new RuntimeException(String.format(""String_Node_Str"",bank,addr));
  return 0;
}",0.9989915966386554
3219,"public void addBody(Body body) throws SAXException, WingException, SQLException, IOException {
  int collectionID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  Collection collection=Collection.find(context,collectionID);
  String query=decodeFromURL(parameters.getParameter(""String_Node_Str"",null));
  java.util.List<Item> items=preformSearch(collection,query);
  Division div=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_GET,""String_Node_Str"");
  div.setHead(T_head1.parameterize(query));
  Para actions=div.addPara();
  actions.addButton(""String_Node_Str"").setValue(T_submit_map);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  Table table=div.addTable(""String_Node_Str"",1,1);
  Row header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_column1);
  header.addCellContent(T_column2);
  header.addCellContent(T_column3);
  header.addCellContent(T_column4);
  for (  Item item : items) {
    String itemID=String.valueOf(item.getID());
    Collection owningCollection=item.getOwningCollection();
    String owning=owningCollection.getMetadata(""String_Node_Str"");
    String author=""String_Node_Str"";
    DCValue[] dcAuthors=item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    if (dcAuthors != null && dcAuthors.length >= 1) {
      author=dcAuthors[0].value;
    }
    String title=""String_Node_Str"";
    DCValue[] dcTitles=item.getDC(""String_Node_Str"",null,Item.ANY);
    if (dcTitles != null && dcTitles.length >= 1) {
      title=dcTitles[0].value;
    }
    String url=contextPath + ""String_Node_Str"" + item.getHandle();
    Row row=table.addRow();
    boolean canBeMapped=true;
    Collection[] collections=item.getCollections();
    for (    Collection c : collections) {
      if (c.getID() == collectionID) {
        canBeMapped=false;
      }
    }
    if (canBeMapped) {
      CheckBox select=row.addCell().addCheckBox(""String_Node_Str"");
      select.setLabel(""String_Node_Str"");
      select.addOption(itemID);
    }
 else {
      row.addCell().addContent(""String_Node_Str"");
    }
    row.addCellContent(owning);
    row.addCell().addXref(url,author);
    row.addCell().addXref(url,title);
  }
  actions=div.addPara();
  actions.addButton(""String_Node_Str"").setValue(T_submit_map);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, SQLException, IOException {
  int collectionID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  Collection collection=Collection.find(context,collectionID);
  String query=decodeFromURL(parameters.getParameter(""String_Node_Str"",null));
  java.util.List<Item> items=preformSearch(collection,query);
  Division div=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_GET,""String_Node_Str"");
  div.setHead(T_head1.parameterize(query));
  Para actions=div.addPara();
  actions.addButton(""String_Node_Str"").setValue(T_submit_map);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  Table table=div.addTable(""String_Node_Str"",1,1);
  Row header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_column1);
  header.addCellContent(T_column2);
  header.addCellContent(T_column3);
  header.addCellContent(T_column4);
  for (  Item item : items) {
    String itemID=String.valueOf(item.getID());
    Collection owningCollection=item.getOwningCollection();
    String owning=""String_Node_Str"";
    if (owningCollection != null)     owning=owningCollection.getMetadata(""String_Node_Str"");
    String author=""String_Node_Str"";
    DCValue[] dcCreators=item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    if (dcCreators != null && dcCreators.length >= 1) {
      author=dcCreators[0].value;
    }
 else {
      DCValue[] dcContributors=item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
      if (dcContributors != null && dcContributors.length >= 1) {
        author=dcContributors[0].value;
      }
    }
    String title=""String_Node_Str"";
    DCValue[] dcTitles=item.getDC(""String_Node_Str"",null,Item.ANY);
    if (dcTitles != null && dcTitles.length >= 1) {
      title=dcTitles[0].value;
    }
    String url=contextPath + ""String_Node_Str"" + item.getHandle();
    Row row=table.addRow();
    boolean canBeMapped=true;
    Collection[] collections=item.getCollections();
    for (    Collection c : collections) {
      if (c.getID() == collectionID) {
        canBeMapped=false;
      }
    }
    if (canBeMapped) {
      CheckBox select=row.addCell().addCheckBox(""String_Node_Str"");
      select.setLabel(""String_Node_Str"");
      select.addOption(itemID);
    }
 else {
      row.addCell().addContent(""String_Node_Str"");
    }
    row.addCellContent(owning);
    row.addCell().addXref(url,author);
    row.addCell().addXref(url,title);
  }
  actions=div.addPara();
  actions.addButton(""String_Node_Str"").setValue(T_submit_map);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.9000392003136025
3220,"/** 
 * Start the authentication process. This packages up the request that led to authentication being required, and then invokes the site-specific authentication method. If it returns true, the user was authenticated without any redirection (e.g. by an X.509 certificate or other implicit method) so the process that called this can continue and send its own response. A ""false"" result means this method has sent its own redirect.
 * @param context current DSpace context
 * @param request current HTTP request - the one that prompted authentication
 * @param response current HTTP response
 * @return true if authentication is already finished (implicit method)
 */
public static boolean startAuthentication(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  HttpSession session=request.getSession();
  if (AuthenticationManager.authenticateImplicit(context,null,null,null,request) == AuthenticationMethod.SUCCESS) {
    loggedIn(context,request,context.getCurrentUser());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    return true;
  }
 else {
    response.addDateHeader(""String_Node_Str"",1);
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    RequestInfo info=new RequestInfo(request);
    session.setAttribute(""String_Node_Str"",info);
    session.setAttribute(""String_Node_Str"",UIUtil.getOriginalURL(request));
    Iterator ai=AuthenticationManager.authenticationMethodIterator();
    AuthenticationMethod am;
    int count=0;
    String url=null;
    while (ai.hasNext()) {
      String s;
      am=(AuthenticationMethod)ai.next();
      s=am.loginPageURL(context,request,response);
      if (s != null) {
        url=s;
        ++count;
      }
    }
    if (count == 1) {
      response.sendRedirect(url);
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
  return false;
}","/** 
 * Start the authentication process. This packages up the request that led to authentication being required, and then invokes the site-specific authentication method. If it returns true, the user was authenticated without any redirection (e.g. by an X.509 certificate or other implicit method) so the process that called this can continue and send its own response. A ""false"" result means this method has sent its own redirect.
 * @param context current DSpace context
 * @param request current HTTP request - the one that prompted authentication
 * @param response current HTTP response
 * @return true if authentication is already finished (implicit method)
 */
public static boolean startAuthentication(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  HttpSession session=request.getSession();
  if (AuthenticationManager.authenticateImplicit(context,null,null,null,request) == AuthenticationMethod.SUCCESS) {
    loggedIn(context,request,context.getCurrentUser());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    if (context.getCurrentUser() != null) {
      Authenticate.resumeInterruptedRequest(request,response);
      return false;
    }
 else {
      return true;
    }
  }
 else {
    response.addDateHeader(""String_Node_Str"",1);
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    RequestInfo info=new RequestInfo(request);
    session.setAttribute(""String_Node_Str"",info);
    session.setAttribute(""String_Node_Str"",UIUtil.getOriginalURL(request));
    Iterator ai=AuthenticationManager.authenticationMethodIterator();
    AuthenticationMethod am;
    int count=0;
    String url=null;
    while (ai.hasNext()) {
      String s;
      am=(AuthenticationMethod)ai.next();
      s=am.loginPageURL(context,request,response);
      if (s != null) {
        url=s;
        ++count;
      }
    }
    if (count == 1) {
      response.sendRedirect(url);
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
  return false;
}",0.9581822576746436
3221,"public void setDefaultSort(boolean defaultSort){
  this.defaultSort=defaultSort;
}","public void setDefaultSort(DiscoverySortFieldConfiguration defaultSort){
  this.defaultSort=defaultSort;
}",0.851063829787234
3222,"/** 
 * Query DSpace for a list of all items / collections / or communities that match the given search query.
 * @param scope the dspace object parent
 */
public void performSearch(DSpaceObject scope) throws UIException, SearchServiceException {
  if (queryResults != null) {
    return;
  }
  String query=getQuery();
  int page=getParameterPage();
  List<String> filterQueries=new ArrayList<String>();
  String[] fqs=getFilterQueries();
  if (fqs != null) {
    filterQueries.addAll(Arrays.asList(fqs));
  }
  this.queryArgs=new DiscoverQuery();
  DiscoveryConfiguration discoveryConfiguration=SearchUtils.getDiscoveryConfiguration(scope);
  List<String> defaultFilterQueries=discoveryConfiguration.getDefaultFilterQueries();
  queryArgs.addFilterQueries(defaultFilterQueries.toArray(new String[defaultFilterQueries.size()]));
  if (filterQueries.size() > 0) {
    queryArgs.addFilterQueries(filterQueries.toArray(new String[filterQueries.size()]));
  }
  queryArgs.setMaxResults(getParameterRpp());
  String sortBy=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (sortBy == null) {
    sortBy=""String_Node_Str"";
    List<DiscoverySortConfiguration> searchSortFields=discoveryConfiguration.getSearchSortFields();
    for (    DiscoverySortConfiguration sortConfiguration : searchSortFields) {
      if (sortConfiguration.isDefaultSort()) {
        sortBy=SearchUtils.getSearchService().toSortFieldIndex(sortConfiguration.getMetadataField(),sortConfiguration.getType());
      }
    }
  }
  String sortOrder=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (sortOrder == null) {
    sortOrder=new DSpace().getConfigurationService().getProperty(""String_Node_Str"");
  }
  if (sortOrder == null || sortOrder.equals(""String_Node_Str"")) {
    queryArgs.setSortField(sortBy,DiscoverQuery.SORT_ORDER.desc);
  }
 else {
    queryArgs.setSortField(sortBy,DiscoverQuery.SORT_ORDER.asc);
  }
  String groupBy=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (groupBy != null && !groupBy.equalsIgnoreCase(""String_Node_Str"")) {
    queryArgs.addProperty(""String_Node_Str"",groupBy);
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.setSortField(""String_Node_Str"",DiscoverQuery.SORT_ORDER.asc);
  }
  queryArgs.setQuery(query != null && !query.trim().equals(""String_Node_Str"") ? query : null);
  if (page > 1) {
    queryArgs.setStart((page - 1) * queryArgs.getMaxResults());
  }
 else {
    queryArgs.setStart(0);
  }
  this.queryResults=SearchUtils.getSearchService().search(context,scope,queryArgs);
}","/** 
 * Query DSpace for a list of all items / collections / or communities that match the given search query.
 * @param scope the dspace object parent
 */
public void performSearch(DSpaceObject scope) throws UIException, SearchServiceException {
  if (queryResults != null) {
    return;
  }
  String query=getQuery();
  int page=getParameterPage();
  List<String> filterQueries=new ArrayList<String>();
  String[] fqs=getFilterQueries();
  if (fqs != null) {
    filterQueries.addAll(Arrays.asList(fqs));
  }
  this.queryArgs=new DiscoverQuery();
  DiscoveryConfiguration discoveryConfiguration=SearchUtils.getDiscoveryConfiguration(scope);
  List<String> defaultFilterQueries=discoveryConfiguration.getDefaultFilterQueries();
  queryArgs.addFilterQueries(defaultFilterQueries.toArray(new String[defaultFilterQueries.size()]));
  if (filterQueries.size() > 0) {
    queryArgs.addFilterQueries(filterQueries.toArray(new String[filterQueries.size()]));
  }
  queryArgs.setMaxResults(getParameterRpp());
  String sortBy=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  DiscoverySortConfiguration searchSortConfiguration=discoveryConfiguration.getSearchSortConfiguration();
  if (sortBy == null) {
    sortBy=""String_Node_Str"";
    if (searchSortConfiguration != null) {
      for (      DiscoverySortFieldConfiguration sortFieldConfiguration : searchSortConfiguration.getSortFields()) {
        if (sortFieldConfiguration.equals(searchSortConfiguration.getDefaultSort())) {
          sortBy=SearchUtils.getSearchService().toSortFieldIndex(sortFieldConfiguration.getMetadataField(),sortFieldConfiguration.getType());
        }
      }
    }
  }
  String sortOrder=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (sortOrder == null && searchSortConfiguration != null) {
    sortOrder=searchSortConfiguration.getDefaultSortOrder().toString();
  }
  if (sortOrder == null || sortOrder.equalsIgnoreCase(""String_Node_Str"")) {
    queryArgs.setSortField(sortBy,DiscoverQuery.SORT_ORDER.desc);
  }
 else {
    queryArgs.setSortField(sortBy,DiscoverQuery.SORT_ORDER.asc);
  }
  String groupBy=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (groupBy != null && !groupBy.equalsIgnoreCase(""String_Node_Str"")) {
    queryArgs.addProperty(""String_Node_Str"",groupBy);
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.addProperty(""String_Node_Str"",""String_Node_Str"");
    queryArgs.setSortField(""String_Node_Str"",DiscoverQuery.SORT_ORDER.asc);
  }
  queryArgs.setQuery(query != null && !query.trim().equals(""String_Node_Str"") ? query : null);
  if (page > 1) {
    queryArgs.setStart((page - 1) * queryArgs.getMaxResults());
  }
 else {
    queryArgs.setStart(0);
  }
  this.queryResults=SearchUtils.getSearchService().search(context,scope,queryArgs);
}",0.8915960451977402
3223,"protected String getParameterOrder(){
  String sortOrder=ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
  if (sortOrder == null) {
    sortOrder=new DSpace().getConfigurationService().getProperty(""String_Node_Str"");
  }
  return sortOrder;
}","protected String getParameterOrder(){
  return ObjectModelHelper.getRequest(objectModel).getParameter(""String_Node_Str"");
}",0.6122448979591837
3224,"protected void buildSearchControls(Division div) throws WingException, SQLException {
  org.dspace.app.xmlui.wing.element.List controlsList=div.addList(""String_Node_Str"",org.dspace.app.xmlui.wing.element.List.TYPE_FORM);
  controlsList.setHead(T_sort_head);
  org.dspace.app.xmlui.wing.element.Item controlsItem=controlsList.addItem();
  controlsItem.addContent(T_rpp);
  Select rppSelect=controlsItem.addSelect(""String_Node_Str"");
  for (  int i : RESULTS_PER_PAGE_PROGRESSION) {
    rppSelect.addOption((i == getParameterRpp()),i,Integer.toString(i));
  }
  controlsItem.addContent(T_sort_by);
  Select sortSelect=controlsItem.addSelect(""String_Node_Str"");
  sortSelect.addOption(false,""String_Node_Str"",T_sort_by_relevance);
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  DiscoveryConfiguration discoveryConfiguration=SearchUtils.getDiscoveryConfiguration(dso);
  for (  DiscoverySortConfiguration sortConfiguration : discoveryConfiguration.getSearchSortFields()) {
    String sortField=SearchUtils.getSearchService().toSortFieldIndex(sortConfiguration.getMetadataField(),sortConfiguration.getType());
    String currentSort=getParameterSortBy();
    sortSelect.addOption((sortField.equals(currentSort) || sortConfiguration.isDefaultSort()),sortField,message(""String_Node_Str"" + sortField));
  }
  controlsItem.addContent(T_order);
  Select orderSelect=controlsItem.addSelect(""String_Node_Str"");
  orderSelect.addOption(SortOption.ASCENDING.equals(getParameterOrder()),SortOption.ASCENDING,T_order_asc);
  orderSelect.addOption(SortOption.DESCENDING.equals(getParameterOrder()),SortOption.DESCENDING,T_order_desc);
  controlsItem.addButton(""String_Node_Str"").setValue(T_sort_button);
}","protected void buildSearchControls(Division div) throws WingException, SQLException {
  org.dspace.app.xmlui.wing.element.List controlsList=div.addList(""String_Node_Str"",org.dspace.app.xmlui.wing.element.List.TYPE_FORM);
  controlsList.setHead(T_sort_head);
  org.dspace.app.xmlui.wing.element.Item controlsItem=controlsList.addItem();
  controlsItem.addContent(T_rpp);
  Select rppSelect=controlsItem.addSelect(""String_Node_Str"");
  for (  int i : RESULTS_PER_PAGE_PROGRESSION) {
    rppSelect.addOption((i == getParameterRpp()),i,Integer.toString(i));
  }
  controlsItem.addContent(T_sort_by);
  Select sortSelect=controlsItem.addSelect(""String_Node_Str"");
  sortSelect.addOption(false,""String_Node_Str"",T_sort_by_relevance);
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  DiscoveryConfiguration discoveryConfiguration=SearchUtils.getDiscoveryConfiguration(dso);
  DiscoverySortConfiguration searchSortConfiguration=discoveryConfiguration.getSearchSortConfiguration();
  if (searchSortConfiguration != null) {
    for (    DiscoverySortFieldConfiguration sortFieldConfiguration : searchSortConfiguration.getSortFields()) {
      String sortField=SearchUtils.getSearchService().toSortFieldIndex(sortFieldConfiguration.getMetadataField(),sortFieldConfiguration.getType());
      String currentSort=getParameterSortBy();
      sortSelect.addOption((sortField.equals(currentSort) || sortFieldConfiguration.equals(searchSortConfiguration.getDefaultSort())),sortField,message(""String_Node_Str"" + sortField));
    }
  }
  controlsItem.addContent(T_order);
  Select orderSelect=controlsItem.addSelect(""String_Node_Str"");
  String parameterOrder=getParameterOrder();
  if (parameterOrder == null && searchSortConfiguration != null) {
    parameterOrder=searchSortConfiguration.getDefaultSortOrder().toString();
  }
  orderSelect.addOption(SortOption.ASCENDING.equalsIgnoreCase(parameterOrder),SortOption.ASCENDING,T_order_asc);
  orderSelect.addOption(SortOption.DESCENDING.equalsIgnoreCase(parameterOrder),SortOption.DESCENDING,T_order_desc);
  controlsItem.addButton(""String_Node_Str"").setValue(T_sort_button);
}",0.855197695731867
3225,"/** 
 * Generate a url to the simple search url.
 */
protected String generateURL(Map<String,String> parameters) throws UIException {
  String query=getQuery();
  if (!""String_Node_Str"".equals(query)) {
    parameters.put(""String_Node_Str"",encodeForURL(query));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterPage()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterRpp()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(this.getParameterGroup()));
  }
  if (getParameterSortBy() != null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterSortBy()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",getParameterOrder());
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterEtAl()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",getParameterScope());
  }
  return AbstractDSpaceTransformer.generateURL(""String_Node_Str"",parameters);
}","/** 
 * Generate a url to the simple search url.
 */
protected String generateURL(Map<String,String> parameters) throws UIException {
  String query=getQuery();
  if (!""String_Node_Str"".equals(query)) {
    parameters.put(""String_Node_Str"",encodeForURL(query));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterPage()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterRpp()));
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(this.getParameterGroup()));
  }
  if (parameters.get(""String_Node_Str"") == null && getParameterSortBy() != null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterSortBy()));
  }
  if (parameters.get(""String_Node_Str"") == null && getParameterOrder() != null) {
    parameters.put(""String_Node_Str"",getParameterOrder());
  }
  if (parameters.get(""String_Node_Str"") == null) {
    parameters.put(""String_Node_Str"",String.valueOf(getParameterEtAl()));
  }
  if (parameters.get(""String_Node_Str"") == null && getParameterScope() != null) {
    parameters.put(""String_Node_Str"",getParameterScope());
  }
  return AbstractDSpaceTransformer.generateURL(""String_Node_Str"",parameters);
}",0.9577242196760174
3226,"@Override public ActionResult execute(Context c,XmlWorkflowItem wfi,Step step,HttpServletRequest request) throws SQLException, AuthorizeException, IOException {
  if (request.getParameter(""String_Node_Str"") != null) {
    WorkflowRequirementsManager.addClaimedUser(c,wfi,step,c.getCurrentUser());
    return new ActionResult(ActionResult.TYPE.TYPE_OUTCOME,ActionResult.OUTCOME_COMPLETE);
  }
 else {
    return new ActionResult(ActionResult.TYPE.TYPE_CANCEL);
  }
}","@Override public ActionResult execute(Context c,XmlWorkflowItem wfi,Step step,HttpServletRequest request) throws SQLException, AuthorizeException, IOException {
  if (request.getParameter(""String_Node_Str"") != null || request.getParameter(""String_Node_Str"") != null) {
    WorkflowRequirementsManager.addClaimedUser(c,wfi,step,c.getCurrentUser());
    return new ActionResult(ActionResult.TYPE.TYPE_OUTCOME,ActionResult.OUTCOME_COMPLETE);
  }
 else {
    return new ActionResult(ActionResult.TYPE.TYPE_CANCEL);
  }
}",0.9480122324159022
3227,"/** 
 * If the user has any workflow tasks, either assigned to them or in an available pool of tasks, then build two tables listing each of these queues. If the user dosn't have any workflows then don't do anything.
 * @param division The division to add the two queues too.
 */
private void addWorkflowTasks(Division division) throws SQLException, WingException, AuthorizeException, IOException {
  @SuppressWarnings(""String_Node_Str"") java.util.List<ClaimedTask> ownedItems=ClaimedTask.findByEperson(context,context.getCurrentUser().getID());
  @SuppressWarnings(""String_Node_Str"") java.util.List<PoolTask> pooledItems=PoolTask.findByEperson(context,context.getCurrentUser().getID());
  if (!(ownedItems.size() > 0 || pooledItems.size() > 0))   return;
  Division workflow=division.addDivision(""String_Node_Str"");
  workflow.setHead(T_w_head1);
  workflow.addPara(T_w_info1);
  Table table=workflow.addTable(""String_Node_Str"",ownedItems.size() + 2,5);
  table.setHead(T_w_head2);
  Row header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_w_column1);
  header.addCellContent(T_w_column2);
  header.addCellContent(T_w_column3);
  header.addCellContent(T_w_column4);
  header.addCellContent(T_w_column5);
  boolean showReturnToPoolButton=false;
  if (ownedItems.size() > 0) {
    for (    ClaimedTask owned : ownedItems) {
      int workflowItemID=owned.getWorkflowItemID();
      String step_id=owned.getStepID();
      String action_id=owned.getActionID();
      XmlWorkflowItem item=null;
      try {
        item=XmlWorkflowItem.find(context,workflowItemID);
        Workflow wf=WorkflowFactory.getWorkflow(item.getCollection());
        Step step=wf.getStep(step_id);
        WorkflowActionConfig action=step.getActionConfig(action_id);
        String url=contextPath + ""String_Node_Str"" + item.getCollection().getHandle()+ ""String_Node_Str""+ workflowItemID+ ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id;
        DCValue[] titles=item.getItem().getDC(""String_Node_Str"",null,Item.ANY);
        String collectionName=item.getCollection().getMetadata(""String_Node_Str"");
        EPerson submitter=item.getSubmitter();
        String submitterName=submitter.getFullName();
        String submitterEmail=submitter.getEmail();
        boolean taskHasPool=step.getUserSelectionMethod().getProcessingAction().usesTaskPool();
        if (taskHasPool) {
          showReturnToPoolButton=true;
        }
        Row row=table.addRow();
        Cell firstCell=row.addCell();
        if (taskHasPool) {
          CheckBox remove=firstCell.addCheckBox(""String_Node_Str"");
          remove.setLabel(""String_Node_Str"");
          remove.addOption(workflowItemID + ""String_Node_Str"" + step.getId());
        }
        row.addCell().addXref(url,message(""String_Node_Str"" + wf.getID() + ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id));
        if (titles != null && titles.length > 0) {
          String displayTitle=titles[0].value;
          if (displayTitle.length() > 50)           displayTitle=displayTitle.substring(0,50) + ""String_Node_Str"";
          row.addCell().addXref(url,displayTitle);
        }
 else         row.addCell().addXref(url,T_untitled);
        row.addCell().addXref(url,collectionName);
        Cell cell=row.addCell();
        cell.addContent(T_email);
        cell.addXref(""String_Node_Str"" + submitterEmail,submitterName);
      }
 catch (      WorkflowConfigurationException e) {
        Row row=table.addRow();
        row.addCell().addContent(""String_Node_Str"");
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
    }
    if (showReturnToPoolButton) {
      Row row=table.addRow();
      row.addCell(0,5).addButton(""String_Node_Str"").setValue(T_w_submit_return);
    }
  }
 else {
    Row row=table.addRow();
    row.addCell(0,5).addHighlight(""String_Node_Str"").addContent(T_w_info2);
  }
  table=workflow.addTable(""String_Node_Str"",pooledItems.size() + 2,5);
  table.setHead(T_w_head3);
  header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_w_column2);
  header.addCellContent(T_w_column3);
  header.addCellContent(T_w_column4);
  header.addCellContent(T_w_column5);
  if (pooledItems.size() > 0) {
    for (    PoolTask pooled : pooledItems) {
      String step_id=pooled.getStepID();
      int workflowItemID=pooled.getWorkflowItemID();
      String action_id=pooled.getActionID();
      XmlWorkflowItem item;
      try {
        item=XmlWorkflowItem.find(context,workflowItemID);
        Workflow wf=WorkflowFactory.getWorkflow(item.getCollection());
        Step step=wf.getStep(step_id);
        String url=contextPath + ""String_Node_Str"" + item.getCollection().getHandle()+ ""String_Node_Str""+ workflowItemID+ ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id;
        DCValue[] titles=item.getItem().getDC(""String_Node_Str"",null,Item.ANY);
        String collectionName=item.getCollection().getMetadata(""String_Node_Str"");
        EPerson submitter=item.getSubmitter();
        String submitterName=submitter.getFullName();
        String submitterEmail=submitter.getEmail();
        Row row=table.addRow();
        row.addCell().addXref(url,message(""String_Node_Str"" + wf.getID() + ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id));
        if (titles != null && titles.length > 0) {
          String displayTitle=titles[0].value;
          if (displayTitle.length() > 50)           displayTitle=displayTitle.substring(0,50) + ""String_Node_Str"";
          row.addCell().addXref(url,displayTitle);
        }
 else         row.addCell().addXref(url,T_untitled);
        row.addCell().addXref(url,collectionName);
        Cell cell=row.addCell();
        cell.addContent(T_email);
        cell.addXref(""String_Node_Str"" + submitterEmail,submitterName);
      }
 catch (      WorkflowConfigurationException e) {
        Row row=table.addRow();
        row.addCell().addContent(""String_Node_Str"");
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
    }
  }
 else {
    Row row=table.addRow();
    row.addCell(0,4).addHighlight(""String_Node_Str"").addContent(T_w_info3);
  }
}","/** 
 * If the user has any workflow tasks, either assigned to them or in an available pool of tasks, then build two tables listing each of these queues. If the user dosn't have any workflows then don't do anything.
 * @param division The division to add the two queues too.
 */
private void addWorkflowTasks(Division division) throws SQLException, WingException, AuthorizeException, IOException {
  @SuppressWarnings(""String_Node_Str"") java.util.List<ClaimedTask> ownedItems=ClaimedTask.findByEperson(context,context.getCurrentUser().getID());
  @SuppressWarnings(""String_Node_Str"") java.util.List<PoolTask> pooledItems=PoolTask.findByEperson(context,context.getCurrentUser().getID());
  if (!(ownedItems.size() > 0 || pooledItems.size() > 0))   return;
  Division workflow=division.addDivision(""String_Node_Str"");
  workflow.setHead(T_w_head1);
  workflow.addPara(T_w_info1);
  Table table=workflow.addTable(""String_Node_Str"",ownedItems.size() + 2,5);
  table.setHead(T_w_head2);
  Row header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_w_column1);
  header.addCellContent(T_w_column2);
  header.addCellContent(T_w_column3);
  header.addCellContent(T_w_column4);
  header.addCellContent(T_w_column5);
  boolean showReturnToPoolButton=false;
  if (ownedItems.size() > 0) {
    for (    ClaimedTask owned : ownedItems) {
      int workflowItemID=owned.getWorkflowItemID();
      String step_id=owned.getStepID();
      String action_id=owned.getActionID();
      XmlWorkflowItem item=null;
      try {
        item=XmlWorkflowItem.find(context,workflowItemID);
        Workflow wf=WorkflowFactory.getWorkflow(item.getCollection());
        Step step=wf.getStep(step_id);
        WorkflowActionConfig action=step.getActionConfig(action_id);
        String url=contextPath + ""String_Node_Str"" + item.getCollection().getHandle()+ ""String_Node_Str""+ workflowItemID+ ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id;
        DCValue[] titles=item.getItem().getDC(""String_Node_Str"",null,Item.ANY);
        String collectionName=item.getCollection().getMetadata(""String_Node_Str"");
        EPerson submitter=item.getSubmitter();
        String submitterName=submitter.getFullName();
        String submitterEmail=submitter.getEmail();
        boolean taskHasPool=step.getUserSelectionMethod().getProcessingAction().usesTaskPool();
        if (taskHasPool) {
          showReturnToPoolButton=true;
        }
        Row row=table.addRow();
        Cell firstCell=row.addCell();
        if (taskHasPool) {
          CheckBox remove=firstCell.addCheckBox(""String_Node_Str"");
          remove.setLabel(""String_Node_Str"");
          remove.addOption(workflowItemID + ""String_Node_Str"" + step.getId());
        }
        row.addCell().addXref(url,message(""String_Node_Str"" + wf.getID() + ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id));
        if (titles != null && titles.length > 0) {
          String displayTitle=titles[0].value;
          if (displayTitle.length() > 50)           displayTitle=displayTitle.substring(0,50) + ""String_Node_Str"";
          row.addCell().addXref(url,displayTitle);
        }
 else         row.addCell().addXref(url,T_untitled);
        row.addCell().addXref(url,collectionName);
        Cell cell=row.addCell();
        cell.addContent(T_email);
        cell.addXref(""String_Node_Str"" + submitterEmail,submitterName);
      }
 catch (      WorkflowConfigurationException e) {
        Row row=table.addRow();
        row.addCell().addContent(""String_Node_Str"");
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
    }
    if (showReturnToPoolButton) {
      Row row=table.addRow();
      row.addCell(0,5).addButton(""String_Node_Str"").setValue(T_w_submit_return);
    }
  }
 else {
    Row row=table.addRow();
    row.addCell(0,5).addHighlight(""String_Node_Str"").addContent(T_w_info2);
  }
  table=workflow.addTable(""String_Node_Str"",pooledItems.size() + 2,5);
  table.setHead(T_w_head3);
  header=table.addRow(Row.ROLE_HEADER);
  header.addCellContent(T_w_column1);
  header.addCellContent(T_w_column2);
  header.addCellContent(T_w_column3);
  header.addCellContent(T_w_column4);
  header.addCellContent(T_w_column5);
  if (pooledItems.size() > 0) {
    for (    PoolTask pooled : pooledItems) {
      String step_id=pooled.getStepID();
      int workflowItemID=pooled.getWorkflowItemID();
      String action_id=pooled.getActionID();
      XmlWorkflowItem item;
      try {
        item=XmlWorkflowItem.find(context,workflowItemID);
        Workflow wf=WorkflowFactory.getWorkflow(item.getCollection());
        String url=contextPath + ""String_Node_Str"" + item.getCollection().getHandle()+ ""String_Node_Str""+ workflowItemID+ ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id;
        DCValue[] titles=item.getItem().getDC(""String_Node_Str"",null,Item.ANY);
        String collectionName=item.getCollection().getMetadata(""String_Node_Str"");
        EPerson submitter=item.getSubmitter();
        String submitterName=submitter.getFullName();
        String submitterEmail=submitter.getEmail();
        Row row=table.addRow();
        CheckBox claimTask=row.addCell().addCheckBox(""String_Node_Str"");
        claimTask.setLabel(""String_Node_Str"");
        claimTask.addOption(workflowItemID);
        row.addCell().addXref(url,message(""String_Node_Str"" + wf.getID() + ""String_Node_Str""+ step_id+ ""String_Node_Str""+ action_id));
        if (titles != null && titles.length > 0) {
          String displayTitle=titles[0].value;
          if (displayTitle.length() > 50)           displayTitle=displayTitle.substring(0,50) + ""String_Node_Str"";
          row.addCell().addXref(url,displayTitle);
        }
 else         row.addCell().addXref(url,T_untitled);
        row.addCell().addXref(url,collectionName);
        Cell cell=row.addCell();
        cell.addContent(T_email);
        cell.addXref(""String_Node_Str"" + submitterEmail,submitterName);
      }
 catch (      WorkflowConfigurationException e) {
        Row row=table.addRow();
        row.addCell().addContent(""String_Node_Str"");
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
catch (      Exception e) {
        log.error(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
      }
    }
    Row row=table.addRow();
    row.addCell(0,5).addButton(""String_Node_Str"").setValue(T_w_submit_take);
  }
 else {
    Row row=table.addRow();
    row.addCell(0,4).addHighlight(""String_Node_Str"").addContent(T_w_info3);
  }
}",0.9734486188690796
3228,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  String handle=parameters.getParameter(""String_Node_Str"",null);
  Division main=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  main.setHead(T_main_head.parameterize(handle));
  Request request=ObjectModelHelper.getRequest(objectModel);
  ServiceDocument serviceDoc=(ServiceDocument)request.getAttribute(""String_Node_Str"");
  java.util.List<Collection> collections=ServiceDocumentHelper.getCollections(serviceDoc);
  List collectionsList=main.addList(""String_Node_Str"",List.TYPE_SIMPLE);
  for (  Collection collection : collections) {
    List collectionList=collectionsList.addList(collection + ""String_Node_Str"",List.TYPE_FORM);
    collectionList.setHead(T_collection_head.parameterize(collection.getLocation()));
    List paramsList=collectionList.addList(collection + ""String_Node_Str"",List.TYPE_BULLETED);
    paramsList.addItem().addContent(T_collection_title.parameterize(collection.getTitle()));
    paramsList.addItem().addContent(T_collection_policy.parameterize(collection.getCollectionPolicy()));
    paramsList.addItem().addContent(T_collection_mediation.parameterize(Boolean.toString(collection.getMediation())));
    String[] fileTypes=collection.getAccepts();
    String fileTypesString=arrayToString(fileTypes);
    paramsList.addItem().addContent(T_collection_file_types.parameterize(fileTypesString));
    String[] packageFormats=ServiceDocumentHelper.getPackageFormats(collection);
    String packageFormatsString=arrayToString(packageFormats);
    paramsList.addItem().addContent(T_collection_package_formats.parameterize(packageFormatsString));
    if ((fileTypes.length > 0) && (packageFormats.length > 0)) {
      collectionList.addItem().addHidden(""String_Node_Str"").setValue(collection.getLocation());
      collectionList.addItem().addButton(""String_Node_Str"").setValue(T_collection_deposit_button);
    }
    if ((collection.getService() != null) && (collection.getService().length() > 0)) {
      collectionList.addItem().addContent(T_sub_service_target + collection.getService());
      collectionList.addItem().addHidden(""String_Node_Str"").setValue(collection.getService());
      collectionList.addItem().addButton(""String_Node_Str"").setValue(T_sub_service_target_button);
    }
  }
  Para buttonList=main.addPara();
  buttonList.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  main.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  String handle=parameters.getParameter(""String_Node_Str"",null);
  Division main=body.addDivision(""String_Node_Str"");
  main.setHead(T_main_head.parameterize(handle));
  Request request=ObjectModelHelper.getRequest(objectModel);
  ServiceDocument serviceDoc=(ServiceDocument)request.getAttribute(""String_Node_Str"");
  java.util.List<Collection> collections=ServiceDocumentHelper.getCollections(serviceDoc);
  for (  Collection collection : collections) {
    Division collectionDiv=main.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
    collectionDiv.setHead(T_collection_head.parameterize(collection.getLocation()));
    List paramsList=collectionDiv.addList(collection + ""String_Node_Str"",List.TYPE_BULLETED);
    paramsList.addItem().addContent(T_collection_title.parameterize(collection.getTitle()));
    paramsList.addItem().addContent(T_collection_policy.parameterize(collection.getCollectionPolicy()));
    paramsList.addItem().addContent(T_collection_mediation.parameterize(Boolean.toString(collection.getMediation())));
    String[] fileTypes=collection.getAccepts();
    String fileTypesString=arrayToString(fileTypes);
    paramsList.addItem().addContent(T_collection_file_types.parameterize(fileTypesString));
    String[] packageFormats=ServiceDocumentHelper.getPackageFormats(collection);
    String packageFormatsString=arrayToString(packageFormats);
    paramsList.addItem().addContent(T_collection_package_formats.parameterize(packageFormatsString));
    if ((fileTypes.length > 0) && (packageFormats.length > 0)) {
      collectionDiv.addPara().addButton(""String_Node_Str"").setValue(T_collection_deposit_button);
      collectionDiv.addHidden(""String_Node_Str"").setValue(collection.getLocation());
      collectionDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
    }
    if ((collection.getService() != null) && (collection.getService().length() > 0)) {
      collectionDiv.addPara(T_sub_service_target + collection.getService());
      collectionDiv.addPara().addButton(""String_Node_Str"").setValue(T_sub_service_target_button);
      collectionDiv.addHidden(""String_Node_Str"").setValue(collection.getService());
      collectionDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
    }
  }
  Division buttons=main.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  Para buttonList=buttons.addPara();
  buttonList.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  buttons.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.520805874599887
3229,"/** 
 * Set up the bitstream reader. See the class description for information on configuration options.
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    this.isSpider=par.getParameter(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"");
    Bitstream bitstream=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      dso=HandleManager.resolveToObject(context,handle);
      if (dso instanceof Item) {
        item=(Item)dso;
        if (sequence > -1) {
          bitstream=findBitstreamBySequence(item,sequence);
        }
 else         if (name != null) {
          bitstream=findBitstreamByName(item,name);
        }
      }
    }
    if ((sequence > -1 && bitstream == null) && name != null) {
      bitstream=findBitstreamByName(item,name);
      if (bitstream != null) {
        String redirectURL=""String_Node_Str"";
        if (item.getHandle() != null && item.getHandle().length() > 0) {
          redirectURL=request.getContextPath() + ""String_Node_Str"" + item.getHandle();
        }
 else {
          redirectURL=request.getContextPath() + ""String_Node_Str"" + item.getID();
        }
        redirectURL+=""String_Node_Str"" + name + ""String_Node_Str""+ bitstream.getSequenceID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redirectURL);
        return;
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (context.getCurrentUser() != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=item.getHandle();
        }
 else         if (dso != null) {
          redictURL+=dso.getHandle();
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (context.getCurrentUser() == null) {
      this.isAnonymouslyReadable=true;
    }
 else {
      this.isAnonymouslyReadable=false;
      for (      ResourcePolicy rp : AuthorizeManager.getPoliciesActionFilter(context,bitstream,Constants.READ)) {
        if (rp.getGroupID() == 0) {
          this.isAnonymouslyReadable=true;
        }
      }
    }
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf('/');
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    new DSpace().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW,ObjectModelHelper.getRequest(objectModel),ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)),bitstream));
    context.complete();
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}","/** 
 * Set up the bitstream reader. See the class description for information on configuration options.
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    boolean BistreamReaderOpenedContext=!ContextUtil.isContextAvailable(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    this.isSpider=par.getParameter(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"");
    Bitstream bitstream=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      dso=HandleManager.resolveToObject(context,handle);
      if (dso instanceof Item) {
        item=(Item)dso;
        if (sequence > -1) {
          bitstream=findBitstreamBySequence(item,sequence);
        }
 else         if (name != null) {
          bitstream=findBitstreamByName(item,name);
        }
      }
    }
    if ((sequence > -1 && bitstream == null) && name != null) {
      bitstream=findBitstreamByName(item,name);
      if (bitstream != null) {
        String redirectURL=""String_Node_Str"";
        if (item.getHandle() != null && item.getHandle().length() > 0) {
          redirectURL=request.getContextPath() + ""String_Node_Str"" + item.getHandle();
        }
 else {
          redirectURL=request.getContextPath() + ""String_Node_Str"" + item.getID();
        }
        redirectURL+=""String_Node_Str"" + name + ""String_Node_Str""+ bitstream.getSequenceID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redirectURL);
        return;
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (context.getCurrentUser() != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=item.getHandle();
        }
 else         if (dso != null) {
          redictURL+=dso.getHandle();
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (context.getCurrentUser() == null) {
      this.isAnonymouslyReadable=true;
    }
 else {
      this.isAnonymouslyReadable=false;
      for (      ResourcePolicy rp : AuthorizeManager.getPoliciesActionFilter(context,bitstream,Constants.READ)) {
        if (rp.getGroupID() == 0) {
          this.isAnonymouslyReadable=true;
        }
      }
    }
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf('/');
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    new DSpace().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW,ObjectModelHelper.getRequest(objectModel),ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)),bitstream));
    if (BistreamReaderOpenedContext)     context.complete();
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}",0.9879352623835214
3230,"/** 
 * Create a <div> element with <mptr> which references a child object via its handle (and via a local file name, when recursively disseminating all child objects).
 * @param type - type attr value for the <div>
 * @param dso - object for which to create the div
 * @param params
 * @return
 */
protected Div makeChildDiv(String type,DSpaceObject dso,PackageParameters params){
  String handle=dso.getHandle();
  Div div=new Div();
  div.setID(gensym(""String_Node_Str""));
  div.setTYPE(type);
  boolean emptyDiv=true;
  if (handle == null || handle.length() == 0) {
    log.warn(""String_Node_Str"" + type + ""String_Node_Str""+ dso.toString());
  }
 else {
    Mptr mptr=new Mptr();
    mptr.setID(gensym(""String_Node_Str""));
    mptr.setLOCTYPE(Loctype.HANDLE);
    mptr.setXlinkHref(handle);
    div.getContent().add(mptr);
    emptyDiv=false;
  }
  if (params.recursiveModeEnabled()) {
    String childFileExtension=(params.getBooleanProperty(""String_Node_Str"",false)) ? ""String_Node_Str"" : ""String_Node_Str"";
    Mptr mptr2=new Mptr();
    mptr2.setID(gensym(""String_Node_Str""));
    mptr2.setLOCTYPE(Loctype.URL);
    mptr2.setXlinkHref(PackageUtils.getPackageName(dso,childFileExtension));
    div.getContent().add(mptr2);
    emptyDiv=false;
  }
  if (emptyDiv) {
    return null;
  }
 else {
    return div;
  }
}","/** 
 * Create a <div> element with <mptr> which references a child object via its handle (and via a local file name, when recursively disseminating all child objects).
 * @param type - type attr value for the <div>
 * @param dso - object for which to create the div
 * @param params
 * @return
 */
protected Div makeChildDiv(String type,DSpaceObject dso,PackageParameters params){
  String handle=dso.getHandle();
  Div div=new Div();
  div.setID(gensym(""String_Node_Str""));
  div.setTYPE(type);
  if (handle == null || handle.length() == 0) {
    log.warn(""String_Node_Str"" + type + ""String_Node_Str""+ dso.toString());
  }
 else {
    Mptr mptr=new Mptr();
    mptr.setID(gensym(""String_Node_Str""));
    mptr.setLOCTYPE(Loctype.HANDLE);
    mptr.setXlinkHref(handle);
    div.getContent().add(mptr);
  }
  String childFileExtension=(params.getBooleanProperty(""String_Node_Str"",false)) ? ""String_Node_Str"" : ""String_Node_Str"";
  Mptr mptr2=new Mptr();
  mptr2.setID(gensym(""String_Node_Str""));
  mptr2.setLOCTYPE(Loctype.URL);
  mptr2.setXlinkHref(PackageUtils.getPackageName(dso,childFileExtension));
  div.getContent().add(mptr2);
  return div;
}",0.9202751922298664
3231,"/** 
 * Recursively create one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object is created under the indicated parent.  All other objects are created based on their relationship to the initial object. <p> For example, a scenario may be to create a Collection based on a collection-level package, and also create an Item for every item-level package referenced by the collection-level package. <p> The output of this method is one or more newly created <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>ingestAll</code>, or simply forward the call to <code>ingest</code> if it is unable to support recursive ingestion. <p> The deposit license (Only significant for Item) is passed explicitly as a string since there is no place for it in many package formats.  It is optional and may be given as <code>null</code>.
 * @param context  DSpace context.
 * @param parent parent under which to create the initial object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The initial package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return List of DSpaceObjects created
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>ingestAll</code>
 */
public List<DSpaceObject> ingestAll(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject dso=null;
  try {
    dso=ingest(context,parent,pkgFile,params,license);
  }
 catch (  IllegalStateException ie) {
    if (params.keepExistingModeEnabled()) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile));
    }
 else {
      throw ie;
    }
  }
  if (dso != null) {
    addToIngestedList(dso);
    if (dso.getType() != Constants.ITEM) {
      List<String> childPkgRefs=getPackageReferences(dso);
      if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
        for (        String childPkgRef : childPkgRefs) {
          int oldSize=dsoIngestedList.size();
          File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
          ingestAll(context,dso,childPkg,params,license);
          if (Constants.COLLECTION == dso.getType()) {
            Item childItem=(Item)dsoIngestedList.get(oldSize);
            Collection collection=(Collection)dso;
            if (!childItem.isIn(collection)) {
              collection.addItem(childItem);
            }
          }
        }
      }
    }
  }
  return getIngestedList();
}","/** 
 * Recursively create one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object is created under the indicated parent.  All other objects are created based on their relationship to the initial object. <p> For example, a scenario may be to create a Collection based on a collection-level package, and also create an Item for every item-level package referenced by the collection-level package. <p> The output of this method is one or more newly created <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>ingestAll</code>, or simply forward the call to <code>ingest</code> if it is unable to support recursive ingestion. <p> The deposit license (Only significant for Item) is passed explicitly as a string since there is no place for it in many package formats.  It is optional and may be given as <code>null</code>.
 * @param context  DSpace context.
 * @param parent parent under which to create the initial object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The initial package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return List of DSpaceObjects created
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>ingestAll</code>
 */
@Override public List<DSpaceObject> ingestAll(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject dso=null;
  try {
    dso=ingest(context,parent,pkgFile,params,license);
  }
 catch (  IllegalStateException ie) {
    if (params.keepExistingModeEnabled()) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile));
    }
 else {
      throw ie;
    }
  }
  if (dso != null) {
    addToIngestedList(dso);
    if (dso.getType() != Constants.ITEM) {
      List<String> childPkgRefs=getPackageReferences(dso);
      if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
        for (        String childPkgRef : childPkgRefs) {
          int oldSize=dsoIngestedList.size();
          File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
          ingestAll(context,dso,childPkg,params,license);
          if (Constants.COLLECTION == dso.getType() && dsoIngestedList.size() > oldSize) {
            Item childItem=(Item)dsoIngestedList.get(oldSize);
            Collection collection=(Collection)dso;
            if (!childItem.isIn(collection)) {
              collection.addItem(childItem);
            }
          }
        }
      }
    }
  }
  return getIngestedList();
}",0.9925348912690684
3232,"/** 
 * Recursively replace one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object to replace is indicated by <code>dso</code>.  All other objects are replaced based on information provided in the referenced packages. <p> For example, a scenario may be to replace a Collection based on a collection-level package, and also replace *every* Item in that collection based on the item-level packages referenced by the collection-level package. <p> Please note that since the <code>dso</code> input only specifies the initial object to replace, any additional objects to replace must be determined based on the referenced packages (or initial package itself). <p> The output of this method is one or more replaced <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>replaceAll</code>, since it somewhat contradicts the archival nature of DSpace. It also may choose to forward the call to <code>replace</code> if it is unable to support recursive replacement.
 * @param context  DSpace context.
 * @param dso initial existing DSpace Object to be replaced, may be nullif object to replace can be determined from package
 * @param pkgFile  The package file to ingest.
 * @param params Properties-style list of options specific to this packager
 * @return List of DSpaceObjects replaced
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>replaceAll</code>
 */
public List<DSpaceObject> replaceAll(Context context,DSpaceObject dso,File pkgFile,PackageParameters params) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject replacedDso=replace(context,dso,pkgFile,params);
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + Constants.typeText[replacedDso.getType()] + ""String_Node_Str""+ replacedDso.getHandle()));
  addToIngestedList(replacedDso);
  if (replacedDso.getType() != Constants.ITEM) {
    List<String> childPkgRefs=getPackageReferences(replacedDso);
    if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
      for (      String childPkgRef : childPkgRefs) {
        int oldSize=dsoIngestedList.size();
        File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
        replaceAll(context,null,childPkg,params);
        if (Constants.COLLECTION == replacedDso.getType()) {
          Item childItem=(Item)dsoIngestedList.get(oldSize);
          Collection collection=(Collection)replacedDso;
          if (!childItem.isIn(collection)) {
            collection.addItem(childItem);
          }
        }
      }
    }
  }
  return getIngestedList();
}","/** 
 * Recursively replace one or more DSpace Objects out of the contents of the ingested package (and all other referenced packages). The initial object to replace is indicated by <code>dso</code>.  All other objects are replaced based on information provided in the referenced packages. <p> For example, a scenario may be to replace a Collection based on a collection-level package, and also replace *every* Item in that collection based on the item-level packages referenced by the collection-level package. <p> Please note that since the <code>dso</code> input only specifies the initial object to replace, any additional objects to replace must be determined based on the referenced packages (or initial package itself). <p> The output of this method is one or more replaced <code>DspaceObject<code>s. <p> The packager <em>may</em> choose not to implement <code>replaceAll</code>, since it somewhat contradicts the archival nature of DSpace. It also may choose to forward the call to <code>replace</code> if it is unable to support recursive replacement.
 * @param context  DSpace context.
 * @param dso initial existing DSpace Object to be replaced, may be nullif object to replace can be determined from package
 * @param pkgFile  The package file to ingest.
 * @param params Properties-style list of options specific to this packager
 * @return List of DSpaceObjects replaced
 * @throws PackageValidationException if initial package (or any referenced package)is unacceptable or there is a fatal error in creating a DSpaceObject
 * @throws UnsupportedOperationException if this packager does notimplement <code>replaceAll</code>
 */
@Override public List<DSpaceObject> replaceAll(Context context,DSpaceObject dso,File pkgFile,PackageParameters params) throws PackageException, UnsupportedOperationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  DSpaceObject replacedDso=replace(context,dso,pkgFile,params);
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + Constants.typeText[replacedDso.getType()] + ""String_Node_Str""+ replacedDso.getHandle()));
  addToIngestedList(replacedDso);
  if (replacedDso.getType() != Constants.ITEM) {
    List<String> childPkgRefs=getPackageReferences(replacedDso);
    if (childPkgRefs != null && !childPkgRefs.isEmpty()) {
      for (      String childPkgRef : childPkgRefs) {
        int oldSize=dsoIngestedList.size();
        File childPkg=new File(pkgFile.getAbsoluteFile().getParent(),childPkgRef);
        replaceAll(context,null,childPkg,params);
        if (Constants.COLLECTION == replacedDso.getType()) {
          Item childItem=(Item)dsoIngestedList.get(oldSize);
          Collection collection=(Collection)replacedDso;
          if (!childItem.isIn(collection)) {
            collection.addItem(childItem);
          }
        }
      }
    }
  }
  return getIngestedList();
}",0.9983176312247644
3233,"/** 
 * Recursively export one or more DSpace Objects as a series of packages. This method will export the given DSpace Object as well as all referenced DSpaceObjects (e.g. child objects) into a series of packages. The initial object is exported to the location specified by the OutputStream. All other packages are exported to the same directory location. <p> Package is any serialized representation of the item, at the discretion of the implementing class.  It does not have to include content bitstreams. <br> Use the <code>params</code> parameter list to adjust the way the package is made, e.g. including a ""<code>metadataOnly</code>"" parameter might make the package a bare manifest in XML instead of a Zip file including manifest and contents. <br> Throws an exception of the initial object is not acceptable or there is a failure creating the package.
 * @param context  DSpace context.
 * @param dso  initial DSpace object
 * @param params Properties-style list of options specific to this packager
 * @param pkgFile File where initial package should be written. All otherpackages will be written to the same directory as this File.
 * @throws PackageValidationException if package cannot be created or there isa fatal error in creating it.
 */
public List<File> disseminateAll(Context context,DSpaceObject dso,PackageParameters params,File pkgFile) throws PackageException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  disseminate(context,dso,params,pkgFile);
  if (pkgFile.exists()) {
    addToPackageList(pkgFile);
    if (dso.getType() != Constants.ITEM) {
      String pkgDirectory=pkgFile.getCanonicalFile().getParent();
      if (!pkgDirectory.endsWith(File.separator)) {
        pkgDirectory+=File.separator;
      }
      String fileExtension=PackageUtils.getFileExtension(pkgFile.getName());
switch (dso.getType()) {
case Constants.COLLECTION:
        Collection collection=(Collection)dso;
      ItemIterator iterator=collection.getItems();
    while (iterator.hasNext()) {
      Item item=iterator.next();
      String childFileName=pkgDirectory + PackageUtils.getPackageName(item,fileExtension);
      disseminateAll(context,item,params,new File(childFileName));
    }
  break;
case Constants.COMMUNITY:
Community community=(Community)dso;
Community[] subcommunities=community.getSubcommunities();
for (int i=0; i < subcommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(subcommunities[i],fileExtension);
disseminateAll(context,subcommunities[i],params,new File(childFileName));
}
Collection[] collections=community.getCollections();
for (int i=0; i < collections.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(collections[i],fileExtension);
disseminateAll(context,collections[i],params,new File(childFileName));
}
break;
case Constants.SITE:
Community[] topCommunities=Community.findAllTop(context);
for (int i=0; i < topCommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(topCommunities[i],fileExtension);
disseminateAll(context,topCommunities[i],params,new File(childFileName));
}
break;
}
}
}
return getPackageList();
}","/** 
 * Recursively export one or more DSpace Objects as a series of packages. This method will export the given DSpace Object as well as all referenced DSpaceObjects (e.g. child objects) into a series of packages. The initial object is exported to the location specified by the OutputStream. All other packages are exported to the same directory location. <p> Package is any serialized representation of the item, at the discretion of the implementing class.  It does not have to include content bitstreams. <br> Use the <code>params</code> parameter list to adjust the way the package is made, e.g. including a ""<code>metadataOnly</code>"" parameter might make the package a bare manifest in XML instead of a Zip file including manifest and contents. <br> Throws an exception of the initial object is not acceptable or there is a failure creating the package.
 * @param context  DSpace context.
 * @param dso  initial DSpace object
 * @param params Properties-style list of options specific to this packager
 * @param pkgFile File where initial package should be written. All otherpackages will be written to the same directory as this File.
 * @throws PackageValidationException if package cannot be created or there isa fatal error in creating it.
 */
@Override public List<File> disseminateAll(Context context,DSpaceObject dso,PackageParameters params,File pkgFile) throws PackageException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (!params.recursiveModeEnabled()) {
    params.setRecursiveModeEnabled(true);
  }
  disseminate(context,dso,params,pkgFile);
  if (pkgFile.exists()) {
    addToPackageList(pkgFile);
    if (dso.getType() != Constants.ITEM) {
      String pkgDirectory=pkgFile.getCanonicalFile().getParent();
      if (!pkgDirectory.endsWith(File.separator)) {
        pkgDirectory+=File.separator;
      }
      String fileExtension=PackageUtils.getFileExtension(pkgFile.getName());
switch (dso.getType()) {
case Constants.COLLECTION:
        Collection collection=(Collection)dso;
      ItemIterator iterator=collection.getItems();
    while (iterator.hasNext()) {
      Item item=iterator.next();
      String childFileName=pkgDirectory + PackageUtils.getPackageName(item,fileExtension);
      disseminateAll(context,item,params,new File(childFileName));
    }
  break;
case Constants.COMMUNITY:
Community community=(Community)dso;
Community[] subcommunities=community.getSubcommunities();
for (int i=0; i < subcommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(subcommunities[i],fileExtension);
disseminateAll(context,subcommunities[i],params,new File(childFileName));
}
Collection[] collections=community.getCollections();
for (int i=0; i < collections.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(collections[i],fileExtension);
disseminateAll(context,collections[i],params,new File(childFileName));
}
break;
case Constants.SITE:
Community[] topCommunities=Community.findAllTop(context);
for (int i=0; i < topCommunities.length; i++) {
String childFileName=pkgDirectory + PackageUtils.getPackageName(topCommunities[i],fileExtension);
disseminateAll(context,topCommunities[i],params,new File(childFileName));
}
break;
}
}
}
return getPackageList();
}",0.9984718826405868
3234,"/** 
 * Add File to list of successfully disseminated package files
 * @param file File
 */
protected void addToPackageList(File f){
  packageFileList.add(f);
}","/** 
 * Add File to list of successfully disseminated package files
 * @param file File
 */
protected void addToPackageList(File f){
  if (!packageFileList.contains(f)) {
    packageFileList.add(f);
  }
}",0.8791208791208791
3235,"/** 
 * Gets all <code>file</code> elements which make up the item's content.
 * @return a List of <code>Element</code>s.
 */
public List<Element> getContentFiles() throws MetadataValidationException {
  if (contentFiles != null) {
    return contentFiles;
  }
  Element fileSec=mets.getChild(""String_Node_Str"",metsNS);
  if (fileSec == null) {
    throw new MetadataValidationException(""String_Node_Str"");
  }
  contentFiles=new ArrayList<Element>();
  Iterator fgi=fileSec.getChildren(""String_Node_Str"",metsNS).iterator();
  while (fgi.hasNext()) {
    Element fg=(Element)fgi.next();
    Iterator fi=fg.getChildren(""String_Node_Str"",metsNS).iterator();
    while (fi.hasNext()) {
      Element f=(Element)fi.next();
      contentFiles.add(f);
    }
  }
  return contentFiles;
}","/** 
 * Gets all <code>file</code> elements which make up the item's content.
 * @return a List of <code>Element</code>s.
 */
public List<Element> getContentFiles() throws MetadataValidationException {
  if (contentFiles != null) {
    return contentFiles;
  }
  contentFiles=new ArrayList<Element>();
  Element fileSec=mets.getChild(""String_Node_Str"",metsNS);
  if (fileSec != null) {
    Iterator fgi=fileSec.getChildren(""String_Node_Str"",metsNS).iterator();
    while (fgi.hasNext()) {
      Element fg=(Element)fgi.next();
      Iterator fi=fg.getChildren(""String_Node_Str"",metsNS).iterator();
      while (fi.hasNext()) {
        Element f=(Element)fi.next();
        contentFiles.add(f);
      }
    }
  }
  return contentFiles;
}",0.7058047493403694
3236,"/** 
 * Store original package on disk and companion file containing SWORD headers as found in the deposit object Also write companion file with header info from the deposit object.
 * @param deposit
 */
private void storePackageAsFile(Deposit deposit) throws IOException {
  String path=swordService.getSwordConfig().getFailedPackageDir();
  File dir=new File(path);
  if (!dir.exists() || !dir.isDirectory()) {
    throw new IOException(""String_Node_Str"");
  }
  String filenameBase=""String_Node_Str"" + deposit.getUsername() + ""String_Node_Str""+ (new Date()).getTime();
  File packageFile=new File(path,filenameBase);
  File headersFile=new File(path,filenameBase + ""String_Node_Str"");
  InputStream is=deposit.getFile();
  FileOutputStream fos=new FileOutputStream(packageFile);
  Utils.copy(is,fos);
  fos.close();
  is.close();
  PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter(headersFile)));
  pw.println(""String_Node_Str"" + deposit.getContentDisposition());
  pw.println(""String_Node_Str"" + deposit.getContentType());
  pw.println(""String_Node_Str"" + deposit.getPackaging());
  pw.println(""String_Node_Str"" + deposit.getLocation());
  pw.println(""String_Node_Str"" + deposit.getOnBehalfOf());
  pw.println(""String_Node_Str"" + deposit.getSlug());
  pw.println(""String_Node_Str"" + deposit.getUsername());
  pw.close();
}","/** 
 * Store original package on disk and companion file containing SWORD headers as found in the deposit object Also write companion file with header info from the deposit object.
 * @param deposit
 */
private void storePackageAsFile(Deposit deposit) throws IOException {
  String path=swordService.getSwordConfig().getFailedPackageDir();
  File dir=new File(path);
  if (!dir.exists() || !dir.isDirectory()) {
    throw new IOException(""String_Node_Str"");
  }
  String filenameBase=""String_Node_Str"" + deposit.getUsername() + ""String_Node_Str""+ (new Date()).getTime();
  File packageFile=new File(path,filenameBase);
  File headersFile=new File(path,filenameBase + ""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(deposit.getFile()));
  OutputStream fos=new BufferedOutputStream(new FileOutputStream(packageFile));
  Utils.copy(is,fos);
  fos.close();
  is.close();
  PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter(headersFile)));
  pw.println(""String_Node_Str"" + deposit.getContentDisposition());
  pw.println(""String_Node_Str"" + deposit.getContentType());
  pw.println(""String_Node_Str"" + deposit.getPackaging());
  pw.println(""String_Node_Str"" + deposit.getLocation());
  pw.println(""String_Node_Str"" + deposit.getOnBehalfOf());
  pw.println(""String_Node_Str"" + deposit.getSlug());
  pw.println(""String_Node_Str"" + deposit.getUsername());
  pw.close();
}",0.9542151162790696
3237,"/** 
 * Convert the current row in a ResultSet into a TableRow object.
 * @param results A ResultSet to process
 * @param table The name of the table
 * @return A TableRow object with the data from the ResultSet
 * @exception SQLException If a database error occurs
 */
static TableRow process(ResultSet results,String table) throws SQLException {
  ResultSetMetaData meta=results.getMetaData();
  int columns=meta.getColumnCount() + 1;
  List<String> columnNames=(table == null) ? getColumnNames(meta) : getColumnNames(table);
  TableRow row=new TableRow(canonicalize(table),columnNames);
  for (int i=1; i < columns; i++) {
    String name=meta.getColumnName(i);
    int jdbctype=meta.getColumnType(i);
    if (results.wasNull()) {
      row.setColumnNull(name);
    }
 else {
switch (jdbctype) {
case Types.BIT:
        row.setColumn(name,results.getBoolean(i));
      break;
case Types.INTEGER:
    if (isOracle) {
      long longValue=results.getLong(i);
      if (longValue <= (long)Integer.MAX_VALUE) {
        row.setColumn(name,(int)longValue);
      }
 else {
        row.setColumn(name,longValue);
      }
    }
 else {
      row.setColumn(name,results.getInt(i));
    }
  break;
case Types.NUMERIC:
case Types.DECIMAL:
case Types.BIGINT:
row.setColumn(name,results.getLong(i));
break;
case Types.DOUBLE:
row.setColumn(name,results.getDouble(i));
break;
case Types.CLOB:
if (isOracle) {
row.setColumn(name,results.getString(i));
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + jdbctype);
}
break;
case Types.VARCHAR:
try {
byte[] bytes=results.getBytes(i);
if (bytes != null) {
String mystring=new String(results.getBytes(i),""String_Node_Str"");
row.setColumn(name,mystring);
}
 else {
row.setColumn(name,results.getString(i));
}
}
 catch (UnsupportedEncodingException e) {
log.error(""String_Node_Str"",e);
}
break;
case Types.DATE:
row.setColumn(name,results.getDate(i));
break;
case Types.TIME:
row.setColumn(name,results.getTime(i));
break;
case Types.TIMESTAMP:
row.setColumn(name,results.getTimestamp(i));
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + jdbctype);
}
}
}
row.resetChanged();
return row;
}","/** 
 * Convert the current row in a ResultSet into a TableRow object.
 * @param results A ResultSet to process
 * @param table The name of the table
 * @return A TableRow object with the data from the ResultSet
 * @exception SQLException If a database error occurs
 */
static TableRow process(ResultSet results,String table) throws SQLException {
  ResultSetMetaData meta=results.getMetaData();
  int columns=meta.getColumnCount() + 1;
  List<String> columnNames=(table == null) ? getColumnNames(meta) : getColumnNames(table);
  TableRow row=new TableRow(canonicalize(table),columnNames);
  for (int i=1; i < columns; i++) {
    String name=meta.getColumnName(i);
    int jdbctype=meta.getColumnType(i);
switch (jdbctype) {
case Types.BIT:
      row.setColumn(name,results.getBoolean(i));
    break;
case Types.INTEGER:
  if (isOracle) {
    long longValue=results.getLong(i);
    if (longValue <= (long)Integer.MAX_VALUE) {
      row.setColumn(name,(int)longValue);
    }
 else {
      row.setColumn(name,longValue);
    }
  }
 else {
    row.setColumn(name,results.getInt(i));
  }
break;
case Types.NUMERIC:
case Types.DECIMAL:
case Types.BIGINT:
row.setColumn(name,results.getLong(i));
break;
case Types.DOUBLE:
row.setColumn(name,results.getDouble(i));
break;
case Types.CLOB:
if (isOracle) {
row.setColumn(name,results.getString(i));
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + jdbctype);
}
break;
case Types.VARCHAR:
try {
byte[] bytes=results.getBytes(i);
if (bytes != null) {
String mystring=new String(results.getBytes(i),""String_Node_Str"");
row.setColumn(name,mystring);
}
 else {
row.setColumn(name,results.getString(i));
}
}
 catch (UnsupportedEncodingException e) {
log.error(""String_Node_Str"",e);
}
break;
case Types.DATE:
row.setColumn(name,results.getDate(i));
break;
case Types.TIME:
row.setColumn(name,results.getTime(i));
break;
case Types.TIMESTAMP:
row.setColumn(name,results.getTimestamp(i));
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + jdbctype);
}
if (results.wasNull()) {
row.setColumnNull(name);
}
}
row.resetChanged();
return row;
}",0.96485473289597
3238,"String getStringColumnCanonicalized(String column){
  if (!hasColumnCanonicalized(column)) {
    throw new IllegalArgumentException(""String_Node_Str"" + column);
  }
  if (isColumnNull(column)) {
    return null;
  }
  Object value=data.get(column);
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + column + ""String_Node_Str"");
  }
  if (!(value instanceof String)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (String)value;
}","String getStringColumnCanonicalized(String column){
  if (!hasColumnCanonicalized(column)) {
    throw new IllegalArgumentException(""String_Node_Str"" + column);
  }
  if (isColumnNullCanonicalized(column)) {
    return null;
  }
  Object value=data.get(column);
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + column + ""String_Node_Str"");
  }
  if (!(value instanceof String)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (String)value;
}",0.98685540950455
3239,"/** 
 * Get the URL by which the METS manifest refers to a Bitstream member within the same package.  In other words, this is generally a relative path link to where the Bitstream file is within the Zipped up AIP. <p> For a manifest-only AIP, this is a reference to an HTTP URL where the bitstream should be able to be downloaded from. An external AIP names a file in the package with a relative URL, that is, relative pathname.
 * @param bitstream  the Bitstream
 * @param params Packager Parameters
 * @return String in URL format naming path to bitstream.
 */
@Override public String makeBitstreamURL(Bitstream bitstream,PackageParameters params){
  if (params != null && (params.getBooleanProperty(""String_Node_Str"",false))) {
    try {
      String handle=null;
      Bundle[] bn=bitstream.getBundles();
      if (bn.length > 0) {
        Item bi[]=bn[0].getItems();
        if (bi.length > 0) {
          handle=bi[0].getHandle();
        }
      }
      if (handle != null) {
        return ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"" + handle+ ""String_Node_Str""+ String.valueOf(bitstream.getSequenceID())+ ""String_Node_Str""+ URLEncoder.encode(bitstream.getName(),""String_Node_Str"");
      }
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
    }
catch (    UnsupportedEncodingException e) {
      log.error(""String_Node_Str"",e);
    }
    return bitstream.getName();
  }
 else {
    String base=""String_Node_Str"" + String.valueOf(bitstream.getID());
    String ext[]=bitstream.getFormat().getExtensions();
    return (ext.length > 0) ? base + ""String_Node_Str"" + ext[0] : base;
  }
}","/** 
 * Get the URL by which the METS manifest refers to a Bitstream member within the same package.  In other words, this is generally a relative path link to where the Bitstream file is within the Zipped up AIP. <p> For a manifest-only AIP, this is a reference to an HTTP URL where the bitstream should be able to be downloaded from. An external AIP names a file in the package with a relative URL, that is, relative pathname.
 * @param bitstream  the Bitstream
 * @param params Packager Parameters
 * @return String in URL format naming path to bitstream.
 */
@Override public String makeBitstreamURL(Bitstream bitstream,PackageParameters params){
  if (params != null && (params.getBooleanProperty(""String_Node_Str"",false))) {
    try {
      String handle=null;
      Bundle[] bn=bitstream.getBundles();
      if (bn.length > 0) {
        Item bi[]=bn[0].getItems();
        if (bi.length > 0) {
          handle=bi[0].getHandle();
        }
      }
      if (handle != null) {
        return ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"" + handle+ ""String_Node_Str""+ String.valueOf(bitstream.getSequenceID())+ ""String_Node_Str""+ URLEncoder.encode(bitstream.getName(),""String_Node_Str"");
      }
 else {
        return ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"" + String.valueOf(bitstream.getID());
      }
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
    }
catch (    UnsupportedEncodingException e) {
      log.error(""String_Node_Str"",e);
    }
    return bitstream.getName();
  }
 else {
    String base=""String_Node_Str"" + String.valueOf(bitstream.getID());
    String ext[]=bitstream.getFormat().getExtensions();
    return (ext.length > 0) ? base + ""String_Node_Str"" + ext[0] : base;
  }
}",0.9591598599766628
3240,"/** 
 * Do nothing, to prevent wrapped stream from being closed prematurely.
 */
public void close(){
}","/** 
 * Do nothing, to prevent wrapped stream from being closed prematurely.
 */
@Override public void close(){
}",0.9537037037037036
3241,"/** 
 * When DSpace creates Default Group Names they are of a very specific format, for example: <li> COMMUNITY_[ID]_ADMIN <li> COLLECTION_[ID]_ADMIN <li> COLLECTION_[ID]_SUBMIT <li> COLLECTION_[ID]_WORKFLOW_STEP_# <p> Although these names work fine within DSpace, the DSpace internal ID (represented by [ID] above) becomes meaningless when content is exported outside of DSpace.  In order to make these Group names meaningful outside of DSpace, they must be translated into a different format: <li> COMMUNITY_[HANDLE]_ADMIN (e.g. COMMUNITY_hdl:123456789/10_ADMIN), etc. <p> This format replaces the internal ID with an external Handle identifier (which is expected to be more meaningful even when content is exported from DSpace). <p> This method prepares group names for export by replacing any found internal IDs with the appropriate external Handle identifier.  If the group name either doesn't have an embedded internal ID, or the corresponding Handle cannot be determined, then it is returned as is. <p> This method may be useful to any Crosswalks/Packagers which deal with import/export of DSpace Groups. <p> Also see the translateGroupNameForImport() method which does the opposite of this method.
 * @param relatedDso DSpaceObject associated with group
 * @param groupName Group's name
 * @return the group name, with any internal IDs translated to Handles
 */
public static String translateGroupNameForExport(Context context,String groupName) throws PackageException {
  if (!groupName.matches(""String_Node_Str"")) {
    return groupName;
  }
  String objType=groupName.substring(0,groupName.indexOf('_'));
  String tmpEndString=groupName.substring(groupName.indexOf('_') + 1);
  String objID=tmpEndString.substring(0,tmpEndString.indexOf('_'));
  String groupType=tmpEndString.substring(tmpEndString.indexOf('_') + 1);
  try {
    DSpaceObject dso=DSpaceObject.find(context,Constants.getTypeID(objType),Integer.parseInt(objID));
    if (dso == null) {
      log.warn(""String_Node_Str"" + groupName + ""String_Node_Str""+ objID+ ""String_Node_Str""+ objType+ ""String_Node_Str"");
      return groupName;
    }
    return objType + ""String_Node_Str"" + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ groupType;
  }
 catch (  SQLException sqle) {
    throw new PackageException(""String_Node_Str"" + groupName + ""String_Node_Str"",sqle);
  }
}","/** 
 * When DSpace creates Default Group Names they are of a very specific format, for example: <li> COMMUNITY_[ID]_ADMIN <li> COLLECTION_[ID]_ADMIN <li> COLLECTION_[ID]_SUBMIT <li> COLLECTION_[ID]_WORKFLOW_STEP_# <p> Although these names work fine within DSpace, the DSpace internal ID (represented by [ID] above) becomes meaningless when content is exported outside of DSpace.  In order to make these Group names meaningful outside of DSpace, they must be translated into a different format: <li> COMMUNITY_[HANDLE]_ADMIN (e.g. COMMUNITY_hdl:123456789/10_ADMIN), etc. <p> This format replaces the internal ID with an external Handle identifier (which is expected to be more meaningful even when content is exported from DSpace). <p> This method prepares group names for export by replacing any found internal IDs with the appropriate external Handle identifier.  If the group name doesn't have an embedded internal ID, it is returned as is. If the group name contains an embedded internal ID, but the corresponding Handle cannot be determined, then null is returned (as the group name could not be translated). <p> This method may be useful to any Crosswalks/Packagers which deal with import/export of DSpace Groups. <p> Also see the translateGroupNameForImport() method which does the opposite of this method.
 * @param relatedDso DSpaceObject associated with group
 * @param groupName Group's name
 * @return the group name, with any internal IDs translated to Handles
 */
public static String translateGroupNameForExport(Context context,String groupName) throws PackageException {
  if (!groupName.matches(""String_Node_Str"")) {
    return groupName;
  }
  String objType=groupName.substring(0,groupName.indexOf('_'));
  String tmpEndString=groupName.substring(groupName.indexOf('_') + 1);
  String objID=tmpEndString.substring(0,tmpEndString.indexOf('_'));
  String groupType=tmpEndString.substring(tmpEndString.indexOf('_') + 1);
  try {
    DSpaceObject dso=DSpaceObject.find(context,Constants.getTypeID(objType),Integer.parseInt(objID));
    if (dso == null) {
      log.warn(""String_Node_Str"" + groupName + ""String_Node_Str""+ objID+ ""String_Node_Str""+ objType+ ""String_Node_Str"");
      return null;
    }
    return objType + ""String_Node_Str"" + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ groupType;
  }
 catch (  SQLException sqle) {
    throw new PackageException(""String_Node_Str"" + groupName + ""String_Node_Str"",sqle);
  }
}",0.962700562617212
3242,"/** 
 * Emit XML describing a single Group.
 * @param context the DSpace Context
 * @parm relatedObjectthe DSpaceObject related to this group (if any)
 * @param group the Group to describe
 * @param write the description to this stream
 */
private void writeGroup(Context context,DSpaceObject relatedObject,Group group,XMLStreamWriter writer) throws XMLStreamException, PackageException {
  writer.writeStartElement(GROUP);
  writer.writeAttribute(ID,String.valueOf(group.getID()));
  writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,group.getName()));
  String groupType=getGroupType(relatedObject,group);
  if (groupType != null && !groupType.isEmpty()) {
    writer.writeAttribute(TYPE,groupType);
  }
  if (group.getMembers().length > 0) {
    writer.writeStartElement(MEMBERS);
    for (    EPerson member : group.getMembers()) {
      writer.writeEmptyElement(MEMBER);
      writer.writeAttribute(ID,String.valueOf(member.getID()));
      writer.writeAttribute(NAME,member.getName());
    }
    writer.writeEndElement();
  }
  if (group.getMemberGroups().length > 0) {
    writer.writeStartElement(MEMBER_GROUPS);
    for (    Group member : group.getMemberGroups()) {
      writer.writeEmptyElement(MEMBER_GROUP);
      writer.writeAttribute(ID,String.valueOf(member.getID()));
      writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,member.getName()));
    }
    writer.writeEndElement();
  }
  writer.writeEndElement();
}","/** 
 * Emit XML describing a single Group.
 * @param context the DSpace Context
 * @parm relatedObjectthe DSpaceObject related to this group (if any)
 * @param group the Group to describe
 * @param write the description to this stream
 */
private void writeGroup(Context context,DSpaceObject relatedObject,Group group,XMLStreamWriter writer) throws XMLStreamException, PackageException {
  String exportGroupName=PackageUtils.translateGroupNameForExport(context,group.getName());
  if (exportGroupName == null)   return;
  writer.writeStartElement(GROUP);
  writer.writeAttribute(ID,String.valueOf(group.getID()));
  writer.writeAttribute(NAME,exportGroupName);
  String groupType=getGroupType(relatedObject,group);
  if (groupType != null && !groupType.isEmpty()) {
    writer.writeAttribute(TYPE,groupType);
  }
  if (group.getMembers().length > 0) {
    writer.writeStartElement(MEMBERS);
    for (    EPerson member : group.getMembers()) {
      writer.writeEmptyElement(MEMBER);
      writer.writeAttribute(ID,String.valueOf(member.getID()));
      writer.writeAttribute(NAME,member.getName());
    }
    writer.writeEndElement();
  }
  if (group.getMemberGroups().length > 0) {
    writer.writeStartElement(MEMBER_GROUPS);
    for (    Group member : group.getMemberGroups()) {
      String exportMemberName=PackageUtils.translateGroupNameForExport(context,member.getName());
      if (exportMemberName != null) {
        writer.writeEmptyElement(MEMBER_GROUP);
        writer.writeAttribute(ID,String.valueOf(member.getID()));
        writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,member.getName()));
      }
    }
    writer.writeEndElement();
  }
  writer.writeEndElement();
}",0.8921537980618943
3243,"public void run(){
  try {
    writeToStream(context,object,stream,emitPasswords);
    stream.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  PackageException e) {
    e.printStackTrace();
  }
}","@Override public void run(){
  try {
    writeToStream(context,object,stream,emitPasswords);
    stream.close();
  }
 catch (  IOException e) {
    log.error(e);
  }
catch (  PackageException e) {
    log.error(e);
  }
}",0.8198198198198198
3244,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  Bitstream bitstream=null;
  boolean displayLicense=ConfigurationManager.getBooleanProperty(""String_Node_Str"",false);
  boolean isLicense=false;
  String idString=request.getPathInfo();
  if (idString != null) {
    if (idString.startsWith(""String_Node_Str"")) {
      idString=idString.substring(1);
    }
    int slashIndex=idString.indexOf('/');
    if (slashIndex != -1) {
      idString=idString.substring(0,slashIndex);
    }
    try {
      int id=Integer.parseInt(idString);
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
    }
  }
  if (bitstream != null) {
    Bundle bundle=bitstream.getBundles()[0];
    if (bundle.getName().equals(Constants.LICENSE_BUNDLE_NAME) && bitstream.getName().equals(Constants.LICENSE_BITSTREAM_NAME)) {
      isLicense=true;
    }
    if (isLicense && !displayLicense && !AuthorizeManager.isAdmin(context)) {
      throw new AuthorizeException();
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
    new DSpace().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW,request,context,bitstream));
    InputStream is=bitstream.retrieve();
    response.setContentType(bitstream.getFormat().getMIMEType());
    response.setHeader(""String_Node_Str"",String.valueOf(bitstream.getSize()));
    if (threshold != -1 && bitstream.getSize() >= threshold) {
      UIUtil.setBitstreamDisposition(bitstream.getName(),request,response);
    }
    Utils.bufferedCopy(is,response.getOutputStream());
    is.close();
    response.getOutputStream().flush();
  }
 else {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + idString));
    JSPManager.showInvalidIDError(request,response,idString,Constants.BITSTREAM);
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  Bitstream bitstream=null;
  boolean displayLicense=ConfigurationManager.getBooleanProperty(""String_Node_Str"",false);
  boolean isLicense=false;
  String idString=request.getPathInfo();
  if (idString != null) {
    if (idString.startsWith(""String_Node_Str"")) {
      idString=idString.substring(1);
    }
    int slashIndex=idString.indexOf('/');
    if (slashIndex != -1) {
      idString=idString.substring(0,slashIndex);
    }
    try {
      int id=Integer.parseInt(idString);
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
    }
  }
  if (bitstream != null) {
    Bundle bundle=bitstream.getBundles().length > 0 ? bitstream.getBundles()[0] : null;
    if (bundle != null && bundle.getName().equals(Constants.LICENSE_BUNDLE_NAME) && bitstream.getName().equals(Constants.LICENSE_BITSTREAM_NAME)) {
      isLicense=true;
    }
    if (isLicense && !displayLicense && !AuthorizeManager.isAdmin(context)) {
      throw new AuthorizeException();
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
    new DSpace().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW,request,context,bitstream));
    InputStream is=bitstream.retrieve();
    response.setContentType(bitstream.getFormat().getMIMEType());
    response.setHeader(""String_Node_Str"",String.valueOf(bitstream.getSize()));
    if (threshold != -1 && bitstream.getSize() >= threshold) {
      UIUtil.setBitstreamDisposition(bitstream.getName(),request,response);
    }
    Utils.bufferedCopy(is,response.getOutputStream());
    is.close();
    response.getOutputStream().flush();
  }
 else {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + idString));
    JSPManager.showInvalidIDError(request,response,idString,Constants.BITSTREAM);
  }
}",0.984607620489528
3245,"private static void init(){
  if (hiddenElementSets == null) {
    hiddenElementSets=new HashMap<String,Set<String>>();
    hiddenElementMaps=new HashMap<String,Map<String,Set<String>>>();
    Enumeration pne=ConfigurationManager.propertyNames();
    while (pne.hasMoreElements()) {
      String key=(String)pne.nextElement();
      if (key.startsWith(CONFIG_PREFIX)) {
        String mdField=key.substring(CONFIG_PREFIX.length());
        String segment[]=mdField.split(""String_Node_Str"",3);
        if (segment.length == 3) {
          Map<String,Set<String>> eltMap=hiddenElementMaps.get(segment[0]);
          if (eltMap == null) {
            eltMap=new HashMap<String,Set<String>>();
            hiddenElementMaps.put(segment[0],eltMap);
          }
          if (!eltMap.containsKey(segment[1])) {
            eltMap.put(segment[1],new HashSet<String>());
          }
          eltMap.get(segment[1]).add(segment[2]);
        }
 else         if (segment.length == 2) {
          if (!hiddenElementSets.containsKey(segment[0])) {
            hiddenElementSets.put(segment[0],new HashSet<String>());
          }
          hiddenElementSets.get(segment[0]).add(segment[1]);
        }
 else {
          log.warn(""String_Node_Str"" + mdField + ""String_Node_Str""+ key);
        }
      }
    }
  }
}","private static synchronized void init(){
  if (!isInitialized()) {
    hiddenElementSets=new HashMap<String,Set<String>>();
    hiddenElementMaps=new HashMap<String,Map<String,Set<String>>>();
    Enumeration pne=ConfigurationManager.propertyNames();
    while (pne.hasMoreElements()) {
      String key=(String)pne.nextElement();
      if (key.startsWith(CONFIG_PREFIX)) {
        String mdField=key.substring(CONFIG_PREFIX.length());
        String segment[]=mdField.split(""String_Node_Str"",3);
        if (segment.length == 3) {
          Map<String,Set<String>> eltMap=hiddenElementMaps.get(segment[0]);
          if (eltMap == null) {
            eltMap=new HashMap<String,Set<String>>();
            hiddenElementMaps.put(segment[0],eltMap);
          }
          if (!eltMap.containsKey(segment[1])) {
            eltMap.put(segment[1],new HashSet<String>());
          }
          eltMap.get(segment[1]).add(segment[2]);
        }
 else         if (segment.length == 2) {
          if (!hiddenElementSets.containsKey(segment[0])) {
            hiddenElementSets.put(segment[0],new HashSet<String>());
          }
          hiddenElementSets.get(segment[0]).add(segment[1]);
        }
 else {
          log.warn(""String_Node_Str"" + mdField + ""String_Node_Str""+ key);
        }
      }
    }
  }
}",0.9792467332820908
3246,"public static boolean isHidden(Context context,String schema,String element,String qualifier) throws SQLException {
  if (context != null && AuthorizeManager.isAdmin(context))   return false;
  init();
  if (qualifier == null) {
    Set<String> elts=hiddenElementSets.get(schema);
    return elts == null ? false : elts.contains(element);
  }
 else {
    Map<String,Set<String>> elts=hiddenElementMaps.get(schema);
    if (elts == null)     return false;
    Set<String> quals=elts.get(element);
    return quals == null ? false : quals.contains(qualifier);
  }
}","public static boolean isHidden(Context context,String schema,String element,String qualifier) throws SQLException {
  if (context != null && AuthorizeManager.isAdmin(context))   return false;
  if (!isInitialized()) {
    init();
  }
  if (qualifier == null) {
    Set<String> elts=hiddenElementSets.get(schema);
    return elts == null ? false : elts.contains(element);
  }
 else {
    Map<String,Set<String>> elts=hiddenElementMaps.get(schema);
    if (elts == null)     return false;
    Set<String> quals=elts.get(element);
    return quals == null ? false : quals.contains(qualifier);
  }
}",0.9620034542314336
3247,"private static void initCache(Context context) throws SQLException {
  if (id2field != null)   return;
synchronized (MetadataField.class) {
    if (id2field == null) {
      HashMap new_id2field=new HashMap();
      log.info(""String_Node_Str"");
      TableRowIterator tri=DatabaseManager.queryTable(context,""String_Node_Str"",""String_Node_Str"");
      try {
        while (tri.hasNext()) {
          TableRow row=tri.next();
          int fieldID=row.getIntColumn(""String_Node_Str"");
          new_id2field.put(new Integer(fieldID),new MetadataField(row));
        }
      }
  finally {
        if (tri != null)         tri.close();
      }
      id2field=new_id2field;
    }
  }
}","private static synchronized void initCache(Context context) throws SQLException {
  if (!isCacheInitialized()) {
    HashMap new_id2field=new HashMap();
    log.info(""String_Node_Str"");
    TableRowIterator tri=DatabaseManager.queryTable(context,""String_Node_Str"",""String_Node_Str"");
    try {
      while (tri.hasNext()) {
        TableRow row=tri.next();
        int fieldID=row.getIntColumn(""String_Node_Str"");
        new_id2field.put(new Integer(fieldID),new MetadataField(row));
      }
    }
  finally {
      if (tri != null)       tri.close();
    }
    id2field=new_id2field;
  }
}",0.8056648308418568
3248,"/** 
 * Find the field corresponding to the given numeric ID.  The ID is a database key internal to DSpace.
 * @param context context, in case we need to read it in from DB
 * @param id the metadata field ID
 * @return the metadata field object
 * @throws SQLException
 */
public static MetadataField find(Context context,int id) throws SQLException {
  initCache(context);
  Integer iid=new Integer(id);
  if (!id2field.containsKey(iid))   return null;
  return (MetadataField)id2field.get(iid);
}","/** 
 * Find the field corresponding to the given numeric ID.  The ID is a database key internal to DSpace.
 * @param context context, in case we need to read it in from DB
 * @param id the metadata field ID
 * @return the metadata field object
 * @throws SQLException
 */
public static MetadataField find(Context context,int id) throws SQLException {
  if (!isCacheInitialized()) {
    initCache(context);
  }
  Integer iid=new Integer(id);
  if (!id2field.containsKey(iid))   return null;
  return (MetadataField)id2field.get(iid);
}",0.9583736689254598
3249,"private static void initCache(Context context) throws SQLException {
  if (id2schema != null && name2schema != null)   return;
synchronized (MetadataSchema.class) {
    if (id2schema == null && name2schema == null) {
      log.info(""String_Node_Str"");
      HashMap new_id2schema=new HashMap();
      HashMap new_name2schema=new HashMap();
      TableRowIterator tri=DatabaseManager.queryTable(context,""String_Node_Str"",""String_Node_Str"");
      try {
        while (tri.hasNext()) {
          TableRow row=tri.next();
          MetadataSchema s=new MetadataSchema(row);
          new_id2schema.put(new Integer(s.schemaID),s);
          new_name2schema.put(s.name,s);
        }
      }
  finally {
        if (tri != null)         tri.close();
      }
      id2schema=new_id2schema;
      name2schema=new_name2schema;
    }
  }
}","private static synchronized void initCache(Context context) throws SQLException {
  if (!isCacheInitialized()) {
    log.info(""String_Node_Str"");
    HashMap new_id2schema=new HashMap();
    HashMap new_name2schema=new HashMap();
    TableRowIterator tri=DatabaseManager.queryTable(context,""String_Node_Str"",""String_Node_Str"");
    try {
      while (tri.hasNext()) {
        TableRow row=tri.next();
        MetadataSchema s=new MetadataSchema(row);
        new_id2schema.put(new Integer(s.schemaID),s);
        new_name2schema.put(s.name,s);
      }
    }
  finally {
      if (tri != null)       tri.close();
    }
    id2schema=new_id2schema;
    name2schema=new_name2schema;
  }
}",0.6459709379128138
3250,"/** 
 * Get the schema corresponding with this short name.
 * @param context context, in case we need to read it in from DB
 * @param shortName the short name for the schema
 * @return the metadata schema object
 * @throws SQLException
 */
public static MetadataSchema find(Context context,String shortName) throws SQLException {
  if (shortName == null)   return null;
  initCache(context);
  if (!name2schema.containsKey(shortName))   return null;
  return (MetadataSchema)name2schema.get(shortName);
}","/** 
 * Get the schema corresponding with this short name.
 * @param context context, in case we need to read it in from DB
 * @param shortName the short name for the schema
 * @return the metadata schema object
 * @throws SQLException
 */
public static MetadataSchema find(Context context,String shortName) throws SQLException {
  if (shortName == null)   return null;
  if (!isCacheInitialized()) {
    initCache(context);
  }
  if (!name2schema.containsKey(shortName))   return null;
  return (MetadataSchema)name2schema.get(shortName);
}",0.9588516746411484
3251,"public static String[] getPluginNames(){
  if (pluginNames == null) {
    try {
      if (dci == null)       dci=new DCInputsReader();
    }
 catch (    DCInputsReaderException e) {
      log.error(""String_Node_Str"",e);
    }
    List<String> names=new ArrayList<String>();
    Iterator pi=dci.getPairsNameIterator();
    while (pi.hasNext())     names.add((String)pi.next());
    pluginNames=names.toArray(new String[names.size()]);
    log.debug(""String_Node_Str"" + Arrays.deepToString(pluginNames));
  }
  return pluginNames;
}","public static String[] getPluginNames(){
  if (pluginNames == null) {
    try {
      if (dci == null)       dci=new DCInputsReader();
    }
 catch (    DCInputsReaderException e) {
      log.error(""String_Node_Str"",e);
    }
    List<String> names=new ArrayList<String>();
    Iterator pi=dci.getPairsNameIterator();
    while (pi.hasNext()) {
      names.add((String)pi.next());
    }
    pluginNames=names.toArray(new String[names.size()]);
    log.debug(""String_Node_Str"" + Arrays.deepToString(pluginNames));
  }
  return pluginNames;
}",0.9906542056074766
3252,"/** 
 * Close any IndexSearcher that is currently open.
 */
public static void close(){
  if (searcher != null) {
    try {
      searcher.close();
      searcher=null;
    }
 catch (    IOException ioe) {
      log.error(""String_Node_Str"",ioe);
    }
  }
}","/** 
 * Close any IndexSearcher that is currently open.
 */
public static synchronized void close(){
  if (searcher != null) {
    try {
      searcher.close();
      searcher=null;
    }
 catch (    IOException ioe) {
      log.error(""String_Node_Str"",ioe);
    }
  }
}",0.9753320683111956
3253,"/** 
 * Return all the configured sort options
 * @return
 * @throws SortException
 */
public static Set<SortOption> getSortOptions() throws SortException {
  if (SortOption.sortOptionsSet != null)   return SortOption.sortOptionsSet;
synchronized (SortOption.class) {
    if (SortOption.sortOptionsSet == null) {
      Set<SortOption> newSortOptionsSet=new HashSet<SortOption>();
      int idx=1;
      String option;
      while (((option=ConfigurationManager.getProperty(""String_Node_Str"" + idx))) != null) {
        SortOption so=new SortOption(idx,option);
        newSortOptionsSet.add(so);
        idx++;
      }
      SortOption.sortOptionsSet=newSortOptionsSet;
    }
  }
  return SortOption.sortOptionsSet;
}","/** 
 * Return all the configured sort options
 * @return
 * @throws SortException
 */
public static Set<SortOption> getSortOptions() throws SortException {
  if (SortOption.sortOptionsSet == null) {
    throw new SortException(""String_Node_Str"");
  }
  return SortOption.sortOptionsSet;
}",0.4612326043737574
3254,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null && values.length > 0) {
              int minConfidence=MetadataAuthorityManager.getManager().getMinConfidence(values[0].schema,values[0].element,values[0].qualifier);
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  if (bis[i].isAuthorityIndex() && (values[x].authority == null || values[x].confidence < minConfidence)) {
                    log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ ""String_Node_Str""+ values[x].qualifier+ ""String_Node_Str""+ values[x].value+ ""String_Node_Str""+ values[x].authority+ ""String_Node_Str""+ values[x].confidence+ ""String_Node_Str"");
                    break;
                  }
                  if (values[x].authority != null && values[x].confidence >= minConfidence) {
                    boolean isValueVariants=false;
                    List<String> variants=ChoiceAuthorityManager.getManager().getVariants(values[x].schema,values[x].element,values[x].qualifier,values[x].authority,values[x].language);
                    if (variants != null) {
                      for (                      String var : variants) {
                        String nVal=OrderFormat.makeSortString(var,values[x].language,bis[i].getDataType());
                        distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),var,values[x].authority,nVal));
                        if (var.equals(values[x].value)) {
                          isValueVariants=true;
                        }
                      }
                    }
                    if (!isValueVariants) {
                      String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                      distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,values[x].authority,nVal));
                    }
                  }
 else {
                    String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                    distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,null,nVal));
                  }
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null && values.length > 0) {
              int minConfidence=MetadataAuthorityManager.getManager().getMinConfidence(values[0].schema,values[0].element,values[0].qualifier);
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  if (bis[i].isAuthorityIndex() && (values[x].authority == null || values[x].confidence < minConfidence)) {
                    log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ ""String_Node_Str""+ values[x].qualifier+ ""String_Node_Str""+ values[x].value+ ""String_Node_Str""+ values[x].authority+ ""String_Node_Str""+ values[x].confidence+ ""String_Node_Str"");
                    continue;
                  }
                  if (values[x].authority != null && values[x].confidence >= minConfidence) {
                    boolean isValueVariants=false;
                    List<String> variants=ChoiceAuthorityManager.getManager().getVariants(values[x].schema,values[x].element,values[x].qualifier,values[x].authority,values[x].language);
                    if (variants != null) {
                      for (                      String var : variants) {
                        String nVal=OrderFormat.makeSortString(var,values[x].language,bis[i].getDataType());
                        distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),var,values[x].authority,nVal));
                        if (var.equals(values[x].value)) {
                          isValueVariants=true;
                        }
                      }
                    }
                    if (!isValueVariants) {
                      String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                      distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,values[x].authority,nVal));
                    }
                  }
 else {
                    String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                    distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,null,nVal));
                  }
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9986891196934556
3255,"/** 
 * Take a node list of communities and build the structure from them, delegating to the relevant methods in this class for sub-communities and collections
 * @param context the context of the request
 * @param communities a nodelist of communities to create along with their subjstructures
 * @param parent the parent community of the nodelist of communities to create
 * @return an element array containing additional information regarding the created communities (e.g. the handles they have been assigned)
 */
private static Element[] handleCommunities(Context context,NodeList communities,Community parent) throws TransformerException, SQLException, Exception {
  Element[] elements=new Element[communities.getLength()];
  for (int i=0; i < communities.getLength(); i++) {
    Community community;
    Element element=new Element(""String_Node_Str"");
    if (parent != null) {
      community=parent.createSubcommunity();
    }
 else {
      community=Community.create(null,context);
    }
    community.setMetadata(""String_Node_Str"",""String_Node_Str"");
    Node tn=communities.item(i);
    Enumeration keys=communityMap.keys();
    while (keys.hasMoreElements()) {
      Node node=null;
      String key=(String)keys.nextElement();
      NodeList nl=XPathAPI.selectNodeList(tn,key);
      if (nl.getLength() == 1) {
        node=nl.item(0);
        community.setMetadata((String)communityMap.get(key),getStringValue(node));
      }
    }
    community.update();
    element.setAttribute(""String_Node_Str"",community.getHandle());
    Element nameElement=new Element(""String_Node_Str"");
    nameElement.setText(community.getMetadata(""String_Node_Str""));
    element.addContent(nameElement);
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element descriptionElement=new Element(""String_Node_Str"");
      descriptionElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(descriptionElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element introElement=new Element(""String_Node_Str"");
      introElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(introElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element copyrightElement=new Element(""String_Node_Str"");
      copyrightElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(copyrightElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element sidebarElement=new Element(""String_Node_Str"");
      sidebarElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(sidebarElement);
    }
    NodeList subCommunities=XPathAPI.selectNodeList(tn,""String_Node_Str"");
    Element[] subCommunityElements=handleCommunities(context,subCommunities,community);
    NodeList collections=XPathAPI.selectNodeList(tn,""String_Node_Str"");
    Element[] collectionElements=handleCollections(context,collections,community);
    int j;
    for (j=0; j < subCommunityElements.length; j++) {
      element.addContent(subCommunityElements[j]);
    }
    for (j=0; j < collectionElements.length; j++) {
      element.addContent(collectionElements[j]);
    }
    elements[i]=element;
  }
  return elements;
}","/** 
 * Take a node list of communities and build the structure from them, delegating to the relevant methods in this class for sub-communities and collections
 * @param context the context of the request
 * @param communities a nodelist of communities to create along with their sub-structures
 * @param parent the parent community of the nodelist of communities to create
 * @return an element array containing additional information regarding the created communities (e.g. the handles they have been assigned)
 */
private static Element[] handleCommunities(Context context,NodeList communities,Community parent) throws TransformerException, SQLException, Exception {
  Element[] elements=new Element[communities.getLength()];
  for (int i=0; i < communities.getLength(); i++) {
    Community community;
    Element element=new Element(""String_Node_Str"");
    if (parent != null) {
      community=parent.createSubcommunity();
    }
 else {
      community=Community.create(null,context);
    }
    community.setMetadata(""String_Node_Str"",""String_Node_Str"");
    Node tn=communities.item(i);
    Enumeration keys=communityMap.keys();
    while (keys.hasMoreElements()) {
      Node node=null;
      String key=(String)keys.nextElement();
      NodeList nl=XPathAPI.selectNodeList(tn,key);
      if (nl.getLength() == 1) {
        node=nl.item(0);
        community.setMetadata((String)communityMap.get(key),getStringValue(node));
      }
    }
    community.update();
    element.setAttribute(""String_Node_Str"",community.getHandle());
    Element nameElement=new Element(""String_Node_Str"");
    nameElement.setText(community.getMetadata(""String_Node_Str""));
    element.addContent(nameElement);
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element descriptionElement=new Element(""String_Node_Str"");
      descriptionElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(descriptionElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element introElement=new Element(""String_Node_Str"");
      introElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(introElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element copyrightElement=new Element(""String_Node_Str"");
      copyrightElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(copyrightElement);
    }
    if (community.getMetadata(""String_Node_Str"") != null) {
      Element sidebarElement=new Element(""String_Node_Str"");
      sidebarElement.setText(community.getMetadata(""String_Node_Str""));
      element.addContent(sidebarElement);
    }
    NodeList subCommunities=XPathAPI.selectNodeList(tn,""String_Node_Str"");
    Element[] subCommunityElements=handleCommunities(context,subCommunities,community);
    NodeList collections=XPathAPI.selectNodeList(tn,""String_Node_Str"");
    Element[] collectionElements=handleCollections(context,collections,community);
    int j;
    for (j=0; j < subCommunityElements.length; j++) {
      element.addContent(subCommunityElements[j]);
    }
    for (j=0; j < collectionElements.length; j++) {
      element.addContent(collectionElements[j]);
    }
    elements[i]=element;
  }
  return elements;
}",0.9996940960538392
3256,"/** 
 * Initalise a new change holder for an existing item
 * @param i The Item to store
 */
public BulkEditChange(Item i){
  item=i;
  newItem=false;
  empty=true;
  adds=new ArrayList<DCValue>();
  removes=new ArrayList<DCValue>();
  constant=new ArrayList<DCValue>();
  complete=new ArrayList<DCValue>();
  oldMappedCollections=new ArrayList<Collection>();
  newMappedCollections=new ArrayList<Collection>();
}","/** 
 * Initialise a new change holder for an existing item
 * @param i The Item to store
 */
public BulkEditChange(Item i){
  item=i;
  newItem=false;
  empty=true;
  adds=new ArrayList<DCValue>();
  removes=new ArrayList<DCValue>();
  constant=new ArrayList<DCValue>();
  complete=new ArrayList<DCValue>();
  oldMappedCollections=new ArrayList<Collection>();
  newMappedCollections=new ArrayList<Collection>();
}",0.9987908101571948
3257,"/** 
 * Initalise this class with values from dspace.cfg
 */
private void init(){
  setValueSeparator();
  setFieldSeparator();
  headings=new ArrayList<String>();
  lines=new ArrayList<DSpaceCSVLine>();
  counter=0;
  ignore=new Hashtable<String,String>();
  String toIgnore=ConfigurationManager.getProperty(""String_Node_Str"");
  if ((toIgnore == null) || (""String_Node_Str"".equals(toIgnore.trim()))) {
    toIgnore=""String_Node_Str"" + ""String_Node_Str"";
  }
  String[] toIgnoreArray=toIgnore.split(""String_Node_Str"");
  for (  String toIgnoreString : toIgnoreArray) {
    if (!""String_Node_Str"".equals(toIgnoreString.trim())) {
      ignore.put(toIgnoreString.trim(),toIgnoreString.trim());
    }
  }
}","/** 
 * Initialise this class with values from dspace.cfg
 */
private void init(){
  setValueSeparator();
  setFieldSeparator();
  headings=new ArrayList<String>();
  lines=new ArrayList<DSpaceCSVLine>();
  counter=0;
  ignore=new Hashtable<String,String>();
  String toIgnore=ConfigurationManager.getProperty(""String_Node_Str"");
  if ((toIgnore == null) || (""String_Node_Str"".equals(toIgnore.trim()))) {
    toIgnore=""String_Node_Str"" + ""String_Node_Str"";
  }
  String[] toIgnoreArray=toIgnore.split(""String_Node_Str"");
  for (  String toIgnoreString : toIgnoreArray) {
    if (!""String_Node_Str"".equals(toIgnoreString.trim())) {
      ignore.put(toIgnoreString.trim(),toIgnoreString.trim());
    }
  }
}",0.9992902767920512
3258,"/** 
 * Add an item to the CSV file, from a CSV line of elements
 * @param line The line of elements
 * @throws Exception Thrown if an error occurs when adding the item
 */
public void addItem(String line) throws Exception {
  boolean last=false;
  if (line.endsWith(fieldSeparator)) {
    last=true;
    line+=""String_Node_Str"";
  }
  String[] parts=line.split(escapedFieldSeparator);
  ArrayList<String> bits=new ArrayList<String>();
  bits.addAll(Arrays.asList(parts));
  boolean alldone=false;
  while (!alldone) {
    boolean found=false;
    int i=0;
    for (    String part : bits) {
      int bitcounter=part.length() - part.replaceAll(""String_Node_Str"",""String_Node_Str"").length();
      if ((part.startsWith(""String_Node_Str"")) && ((!part.endsWith(""String_Node_Str"")) || ((bitcounter % 2) == 1))) {
        found=true;
        String add=bits.get(i) + fieldSeparator + bits.get(i + 1);
        bits.remove(i);
        bits.add(i,add);
        bits.remove(i + 1);
        break;
      }
      i++;
    }
    alldone=!found;
  }
  int i=0;
  for (  String part : bits) {
    if ((part.startsWith(""String_Node_Str"")) && (part.endsWith(""String_Node_Str""))) {
      part=part.substring(1,part.length() - 1);
      bits.set(i,part);
    }
    i++;
  }
  i=0;
  for (  String part : bits) {
    if (part.contains(""String_Node_Str"")) {
      part=part.replaceAll(""String_Node_Str"",""String_Node_Str"");
      bits.set(i,part);
    }
    i++;
  }
  String id=parts[0].replaceAll(""String_Node_Str"",""String_Node_Str"");
  DSpaceCSVLine csvLine;
  if (""String_Node_Str"".equals(id)) {
    csvLine=new DSpaceCSVLine();
  }
 else {
    try {
      csvLine=new DSpaceCSVLine(Integer.parseInt(id));
    }
 catch (    NumberFormatException nfe) {
      System.err.println(""String_Node_Str"" + id);
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      throw (nfe);
    }
  }
  i=0;
  for (  String part : bits) {
    if (i > 0) {
      if ((last) && (i == headings.size())) {
        part=""String_Node_Str"";
      }
      csvLine.add(headings.get(i - 1),null);
      String[] elements=part.split(escpaedValueSeparator);
      for (      String element : elements) {
        if ((element != null) && (!""String_Node_Str"".equals(element))) {
          csvLine.add(headings.get(i - 1),element);
        }
      }
    }
    i++;
  }
  lines.add(csvLine);
  counter++;
}","/** 
 * Add an item to the CSV file, from a CSV line of elements
 * @param line The line of elements
 * @throws Exception Thrown if an error occurs when adding the item
 */
public void addItem(String line) throws Exception {
  boolean last=false;
  if (line.endsWith(fieldSeparator)) {
    last=true;
    line+=""String_Node_Str"";
  }
  String[] parts=line.split(escapedFieldSeparator);
  ArrayList<String> bits=new ArrayList<String>();
  bits.addAll(Arrays.asList(parts));
  boolean alldone=false;
  while (!alldone) {
    boolean found=false;
    int i=0;
    for (    String part : bits) {
      int bitcounter=part.length() - part.replaceAll(""String_Node_Str"",""String_Node_Str"").length();
      if ((part.startsWith(""String_Node_Str"")) && ((!part.endsWith(""String_Node_Str"")) || ((bitcounter % 2) == 1))) {
        found=true;
        String add=bits.get(i) + fieldSeparator + bits.get(i + 1);
        bits.remove(i);
        bits.add(i,add);
        bits.remove(i + 1);
        break;
      }
      i++;
    }
    alldone=!found;
  }
  int i=0;
  for (  String part : bits) {
    if ((part.startsWith(""String_Node_Str"")) && (part.endsWith(""String_Node_Str""))) {
      part=part.substring(1,part.length() - 1);
      bits.set(i,part);
    }
    i++;
  }
  i=0;
  for (  String part : bits) {
    if (part.contains(""String_Node_Str"")) {
      part=part.replaceAll(""String_Node_Str"",""String_Node_Str"");
      bits.set(i,part);
    }
    i++;
  }
  String id=parts[0].replaceAll(""String_Node_Str"",""String_Node_Str"");
  DSpaceCSVLine csvLine;
  if (""String_Node_Str"".equals(id)) {
    csvLine=new DSpaceCSVLine();
  }
 else {
    try {
      csvLine=new DSpaceCSVLine(Integer.parseInt(id));
    }
 catch (    NumberFormatException nfe) {
      System.err.println(""String_Node_Str"" + id);
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      throw (nfe);
    }
  }
  i=0;
  for (  String part : bits) {
    if (i > 0) {
      if ((last) && (i == headings.size())) {
        part=""String_Node_Str"";
      }
      csvLine.add(headings.get(i - 1),null);
      String[] elements=part.split(escapedValueSeparator);
      for (      String element : elements) {
        if ((element != null) && (!""String_Node_Str"".equals(element))) {
          csvLine.add(headings.get(i - 1),element);
        }
      }
    }
    i++;
  }
  lines.add(csvLine);
  counter++;
}",0.99915611814346
3259,"/** 
 * Set the value separator for multiple values stored in one csv value. Is set in dspace.cfg as bulkedit.valueseparator If not set, defaults to double pipe '||'
 */
private void setValueSeparator(){
  valueSeparator=ConfigurationManager.getProperty(""String_Node_Str"");
  if ((valueSeparator != null) && (!""String_Node_Str"".equals(valueSeparator.trim()))) {
    valueSeparator=valueSeparator.trim();
  }
 else {
    valueSeparator=""String_Node_Str"";
  }
  Pattern spchars=Pattern.compile(""String_Node_Str"");
  Matcher match=spchars.matcher(valueSeparator);
  escpaedValueSeparator=match.replaceAll(""String_Node_Str"");
}","/** 
 * Set the value separator for multiple values stored in one csv value. Is set in dspace.cfg as bulkedit.valueseparator If not set, defaults to double pipe '||'
 */
private void setValueSeparator(){
  valueSeparator=ConfigurationManager.getProperty(""String_Node_Str"");
  if ((valueSeparator != null) && (!""String_Node_Str"".equals(valueSeparator.trim()))) {
    valueSeparator=valueSeparator.trim();
  }
 else {
    valueSeparator=""String_Node_Str"";
  }
  Pattern spchars=Pattern.compile(""String_Node_Str"");
  Matcher match=spchars.matcher(valueSeparator);
  escapedValueSeparator=match.replaceAll(""String_Node_Str"");
}",0.9967897271268058
3260,"/** 
 * output the explanation of the stat block in the relevant format
 * @param explanation     the explanatory or clarification text for the stats
 * @return      a string contianing the formatted explanation
 */
abstract public String blockExplanation(String explanation);","/** 
 * output the explanation of the stat block in the relevant format
 * @param explanation     the explanatory or clarification text for the stats
 * @return      a string containing the formatted explanation
 */
abstract public String blockExplanation(String explanation);",0.9927536231884058
3261,"/** 
 * Syncronize the cached list of analysis / report files with the reports directory We synchronize if: 1) The number of files is different (ie. files have been added or removed) 2) We haven't cached anything yet 3) The cache was last generate over an hour ago
 */
private static void syncFileList(){
  File[] fileList=StatisticsLoader.getAnalysisAndReportFileList();
  if (fileList != null && fileList.length != fileCount)   StatisticsLoader.loadFileList(fileList);
 else   if (lastLoaded == null)   StatisticsLoader.loadFileList(fileList);
 else   if (DateUtils.addHours(lastLoaded,1).before(new Date()))   StatisticsLoader.loadFileList(fileList);
}","/** 
 * Synchronize the cached list of analysis / report files with the reports directory We synchronize if: 1) The number of files is different (ie. files have been added or removed) 2) We haven't cached anything yet 3) The cache was last generate over an hour ago
 */
private static void syncFileList(){
  File[] fileList=StatisticsLoader.getAnalysisAndReportFileList();
  if (fileList != null && fileList.length != fileCount)   StatisticsLoader.loadFileList(fileList);
 else   if (lastLoaded == null)   StatisticsLoader.loadFileList(fileList);
 else   if (DateUtils.addHours(lastLoaded,1).before(new Date()))   StatisticsLoader.loadFileList(fileList);
}",0.9992372234935164
3262,"/** 
 * The helper function to vaildate the DatePattern.
 * @param pstrPattern The DatePattern to be validated.
 * @return The validated date pattern or defautlt DATE_PATTERN
 */
private String checkPattern(String pstrPattern){
  String strRet=null;
  SimpleDateFormat objFmt=new SimpleDateFormat(DATE_PATTERN);
  try {
    this.mobjSDF=new SimpleDateFormat(pstrPattern);
    strRet=pstrPattern;
  }
 catch (  NullPointerException NPExIgnore) {
    LogLog.error(""String_Node_Str"" + pstrPattern,NPExIgnore);
    this.mobjSDF=objFmt;
    strRet=DATE_PATTERN;
  }
catch (  IllegalArgumentException IlArgExIgnore) {
    LogLog.error(""String_Node_Str"" + pstrPattern,IlArgExIgnore);
    this.mobjSDF=objFmt;
    strRet=DATE_PATTERN;
  }
 finally {
    objFmt=null;
  }
  return strRet;
}","/** 
 * The helper function to validate the DatePattern.
 * @param pstrPattern The DatePattern to be validated.
 * @return The validated date pattern or defautlt DATE_PATTERN
 */
private String checkPattern(String pstrPattern){
  String strRet=null;
  SimpleDateFormat objFmt=new SimpleDateFormat(DATE_PATTERN);
  try {
    this.mobjSDF=new SimpleDateFormat(pstrPattern);
    strRet=pstrPattern;
  }
 catch (  NullPointerException NPExIgnore) {
    LogLog.error(""String_Node_Str"" + pstrPattern,NPExIgnore);
    this.mobjSDF=objFmt;
    strRet=DATE_PATTERN;
  }
catch (  IllegalArgumentException IlArgExIgnore) {
    LogLog.error(""String_Node_Str"" + pstrPattern,IlArgExIgnore);
    this.mobjSDF=objFmt;
    strRet=DATE_PATTERN;
  }
 finally {
    objFmt=null;
  }
  return strRet;
}",0.997439180537772
3263,"/** 
 * Load necessary information to build the Progress Bar for the Item Submission Progress. This information is returned in the form of a HashMap (which is then stored as a part of the SubmissionInfo). The HashMap takes the following form: Keys - the number of the step, followed by the number of the page within the step (e.g. ""2.1"" = The first page of Step 2) (e.g. ""5.2"" = The second page of Step 5) Values - the headings to display for each step (e.g. ""Describe"", ""Verify"")
 * @param request The HTTP Servlet Request object
 * @param subInfo the SubmissionInfo object we are loading into
 * @param forceReload If true, this method reloads from stratch (and overwrites cached progress bar info)
 */
private static void loadProgressBar(HttpServletRequest request,SubmissionInfo subInfo,boolean forceReload){
  LinkedHashMap progressBarInfo=null;
  log.debug(""String_Node_Str"");
  if (!forceReload) {
    progressBarInfo=(LinkedHashMap)loadProgressBarFromCache(request.getSession());
  }
  if (progressBarInfo != null && log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + progressBarInfo.size() + ""String_Node_Str"");
  }
 else {
    progressBarInfo=new LinkedHashMap();
    for (int i=0; i < subInfo.submissionConfig.getNumberOfSteps(); i++) {
      SubmissionStepConfig currentStep=subInfo.submissionConfig.getStep(i);
      String stepNumber=Integer.toString(currentStep.getStepNumber());
      String stepHeading=currentStep.getHeading();
      if (currentStep.isVisible()) {
        int numPages=1;
        try {
          ClassLoader loader=subInfo.getClass().getClassLoader();
          Class stepClass=loader.loadClass(currentStep.getProcessingClassName());
          AbstractProcessingStep step=(AbstractProcessingStep)stepClass.newInstance();
          numPages=step.getNumberOfPages(request,subInfo);
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"" + currentStep.getProcessingClassName() + ""String_Node_Str"",e);
        }
        for (int j=1; j <= numPages; j++) {
          String pageNumber=Integer.toString(j);
          progressBarInfo.put(stepNumber + ""String_Node_Str"" + pageNumber,stepHeading);
        }
      }
    }
    log.debug(""String_Node_Str"" + progressBarInfo.size() + ""String_Node_Str"");
    saveProgressBarToCache(request.getSession(),progressBarInfo);
  }
  subInfo.progressBar=progressBarInfo;
}","/** 
 * Load necessary information to build the Progress Bar for the Item Submission Progress. This information is returned in the form of a HashMap (which is then stored as a part of the SubmissionInfo). The HashMap takes the following form: Keys - the number of the step, followed by the number of the page within the step (e.g. ""2.1"" = The first page of Step 2) (e.g. ""5.2"" = The second page of Step 5) Values - the headings to display for each step (e.g. ""Describe"", ""Verify"")
 * @param request The HTTP Servlet Request object
 * @param subInfo the SubmissionInfo object we are loading into
 * @param forceReload If true, this method reloads from scratch (and overwrites cached progress bar info)
 */
private static void loadProgressBar(HttpServletRequest request,SubmissionInfo subInfo,boolean forceReload){
  LinkedHashMap progressBarInfo=null;
  log.debug(""String_Node_Str"");
  if (!forceReload) {
    progressBarInfo=(LinkedHashMap)loadProgressBarFromCache(request.getSession());
  }
  if (progressBarInfo != null && log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + progressBarInfo.size() + ""String_Node_Str"");
  }
 else {
    progressBarInfo=new LinkedHashMap();
    for (int i=0; i < subInfo.submissionConfig.getNumberOfSteps(); i++) {
      SubmissionStepConfig currentStep=subInfo.submissionConfig.getStep(i);
      String stepNumber=Integer.toString(currentStep.getStepNumber());
      String stepHeading=currentStep.getHeading();
      if (currentStep.isVisible()) {
        int numPages=1;
        try {
          ClassLoader loader=subInfo.getClass().getClassLoader();
          Class stepClass=loader.loadClass(currentStep.getProcessingClassName());
          AbstractProcessingStep step=(AbstractProcessingStep)stepClass.newInstance();
          numPages=step.getNumberOfPages(request,subInfo);
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"" + currentStep.getProcessingClassName() + ""String_Node_Str"",e);
        }
        for (int j=1; j <= numPages; j++) {
          String pageNumber=Integer.toString(j);
          progressBarInfo.put(stepNumber + ""String_Node_Str"" + pageNumber,stepHeading);
        }
      }
    }
    log.debug(""String_Node_Str"" + progressBarInfo.size() + ""String_Node_Str"");
    saveProgressBarToCache(request.getSession(),progressBarInfo);
  }
  subInfo.progressBar=progressBarInfo;
}",0.9995777027027029
3264,"/** 
 * Loads SubmissionConfig object for the given submission info object. If a SubmissionConfig object cannot be loaded, a Servlet Error is thrown. <p> This method just loads this SubmissionConfig object internally, so that it is available via a call to ""getSubmissionConfig()""
 * @param request The HTTP Servlet Request object
 * @param subInfo the SubmissionInfo object we are loading into
 * @param forceReload If true, this method reloads from stratch (and overwrites cached SubmissionConfig)
 */
private static void loadSubmissionConfig(HttpServletRequest request,SubmissionInfo subInfo,boolean forceReload) throws ServletException {
  log.debug(""String_Node_Str"");
  if (!forceReload) {
    subInfo.submissionConfig=loadSubmissionConfigFromCache(request.getSession(),subInfo.getCollectionHandle(),subInfo.isInWorkflow());
  }
  if (subInfo.submissionConfig == null || forceReload) {
    subInfo.submissionConfig=submissionConfigReader.getSubmissionConfig(subInfo.getCollectionHandle(),subInfo.isInWorkflow());
    saveSubmissionConfigToCache(request.getSession(),subInfo.submissionConfig,subInfo.getCollectionHandle(),subInfo.isInWorkflow());
    loadProgressBar(request,subInfo,true);
  }
 else {
    log.debug(""String_Node_Str"");
    loadProgressBar(request,subInfo,false);
  }
}","/** 
 * Loads SubmissionConfig object for the given submission info object. If a SubmissionConfig object cannot be loaded, a Servlet Error is thrown. <p> This method just loads this SubmissionConfig object internally, so that it is available via a call to ""getSubmissionConfig()""
 * @param request The HTTP Servlet Request object
 * @param subInfo the SubmissionInfo object we are loading into
 * @param forceReload If true, this method reloads from scratch (and overwrites cached SubmissionConfig)
 */
private static void loadSubmissionConfig(HttpServletRequest request,SubmissionInfo subInfo,boolean forceReload) throws ServletException {
  log.debug(""String_Node_Str"");
  if (!forceReload) {
    subInfo.submissionConfig=loadSubmissionConfigFromCache(request.getSession(),subInfo.getCollectionHandle(),subInfo.isInWorkflow());
  }
  if (subInfo.submissionConfig == null || forceReload) {
    subInfo.submissionConfig=submissionConfigReader.getSubmissionConfig(subInfo.getCollectionHandle(),subInfo.isInWorkflow());
    saveSubmissionConfigToCache(request.getSession(),subInfo.submissionConfig,subInfo.getCollectionHandle(),subInfo.isInWorkflow());
    loadProgressBar(request,subInfo,true);
  }
 else {
    log.debug(""String_Node_Str"");
    loadProgressBar(request,subInfo,false);
  }
}",0.99922420480993
3265,"/** 
 * Formats the file size. Examples: - 50 = 50B - 1024 = 1KB - 1,024,000 = 1MB etc The numbers are formatted using java Locales
 * @param in The number to covnert
 * @return the file size as a String
 */
public static String formatFileSize(double in){
  NumberFormat nf=NumberFormat.getNumberInstance(Locale.getDefault());
  DecimalFormat df=(DecimalFormat)nf;
  df.applyPattern(""String_Node_Str"");
  if (in < 1024) {
    df.applyPattern(""String_Node_Str"");
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else   if (in < 1024000) {
    in=in / 1024;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else   if (in < 1024000000) {
    in=in / 1024000;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else {
    in=in / 1024000000;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
}","/** 
 * Formats the file size. Examples: - 50 = 50B - 1024 = 1KB - 1,024,000 = 1MB etc The numbers are formatted using java Locales
 * @param in The number to convert
 * @return the file size as a String
 */
public static String formatFileSize(double in){
  NumberFormat nf=NumberFormat.getNumberInstance(Locale.getDefault());
  DecimalFormat df=(DecimalFormat)nf;
  df.applyPattern(""String_Node_Str"");
  if (in < 1024) {
    df.applyPattern(""String_Node_Str"");
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else   if (in < 1024000) {
    in=in / 1024;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else   if (in < 1024000000) {
    in=in / 1024000;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
 else {
    in=in / 1024000000;
    return df.format(in) + ""String_Node_Str"" + ""String_Node_Str"";
  }
}",0.9988545246277204
3266,"/** 
 * So that any left over indices for items which have been deleted can be assured to have been removed, this method checks for indicies for items which are not in the item table. If it finds an index which does not have an associated item it removes it.
 * @param table		the index table to check
 * @param map		the name of the associated distinct mapping table
 * @param withdrawn TODO
 * @throws BrowseException
 */
public void pruneExcess(String table,String map,boolean withdrawn) throws BrowseException ;","/** 
 * So that any left over indices for items which have been deleted can be assured to have been removed, this method checks for indices for items which are not in the item table. If it finds an index which does not have an associated item it removes it.
 * @param table		the index table to check
 * @param map		the name of the associated distinct mapping table
 * @param withdrawn TODO
 * @throws BrowseException
 */
public void pruneExcess(String table,String map,boolean withdrawn) throws BrowseException ;",0.9990243902439024
3267,"/** 
 * Generate a url to the simple search url.
 */
protected String generateURL(Map<String,String> parameters) throws UIException {
  String query=getQuery();
  if (!""String_Node_Str"".equals(query))   parameters.put(""String_Node_Str"",URLEncode(query));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterPage()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterRpp()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterSortBy()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",getParameterOrder());
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterEtAl()));
  return super.generateURL(""String_Node_Str"",parameters);
}","/** 
 * Generate a url to the simple search url.
 */
protected String generateURL(Map<String,String> parameters) throws UIException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String scope=request.getParameter(""String_Node_Str"");
  if (scope != null)   parameters.put(""String_Node_Str"",scope);
  String query=getQuery();
  if (!""String_Node_Str"".equals(query))   parameters.put(""String_Node_Str"",URLEncode(query));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterPage()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterRpp()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterSortBy()));
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",getParameterOrder());
  if (parameters.get(""String_Node_Str"") == null)   parameters.put(""String_Node_Str"",String.valueOf(getParameterEtAl()));
  return super.generateURL(""String_Node_Str"",parameters);
}",0.9090909090909092
3268,"/** 
 * Actually Disseminate into METSRights schema.  This method locates all DSpace policies (permissions) for the provided object, and translates them into METSRights PermissionTypes.
 * @param dso DSpace Object
 * @return XML Element corresponding to the new <RightsDeclarationMD> translation
 * @throws CrosswalkException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
@Override public Element disseminateElement(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso == null)   return null;
 else   if (dso.getType() == Constants.SITE)   throw new CrosswalkObjectNotSupported(""String_Node_Str"");
  Element rightsMD=new Element(""String_Node_Str"",METSRights_NS);
  rightsMD.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Context context=new Context();
  List<ResourcePolicy> policies=AuthorizeManager.getPolicies(context,dso);
  for (  ResourcePolicy policy : policies) {
    Group group=policy.getGroup();
    EPerson person=policy.getEPerson();
    Element rightsContext=new Element(""String_Node_Str"",METSRights_NS);
    rightsMD.addContent(rightsContext);
    if (group != null) {
      String contextClass=GROUP_CONTEXTCLASS;
      if (group.getID() == 0)       contextClass=ANONYMOUS_CONTEXTCLASS;
 else       if (group.getID() == 1)       contextClass=ADMIN_CONTEXTCLASS;
      rightsContext.setAttribute(""String_Node_Str"",contextClass);
      if (contextClass.equals(GROUP_CONTEXTCLASS)) {
        try {
          Element rightsUser=new Element(""String_Node_Str"",METSRights_NS);
          rightsUser.setAttribute(""String_Node_Str"",GROUP_USERTYPE);
          rightsUser.addContent(PackageUtils.crosswalkDefaultGroupName(context,group.getName()));
          rightsContext.addContent(rightsUser);
        }
 catch (        PackageException pe) {
          throw new CrosswalkException(pe);
        }
      }
    }
 else     if (person != null) {
      rightsContext.setAttribute(""String_Node_Str"",PERSON_CONTEXTCLASS);
      Element rightsUser=new Element(""String_Node_Str"",METSRights_NS);
      rightsUser.setAttribute(""String_Node_Str"",PERSON_USERTYPE);
      rightsUser.addContent(person.getEmail());
      rightsContext.addContent(rightsUser);
    }
    Element rightsPerm=translatePermissions(policy);
    rightsContext.addContent(rightsPerm);
  }
  context.complete();
  return rightsMD;
}","/** 
 * Actually Disseminate into METSRights schema.  This method locates all DSpace policies (permissions) for the provided object, and translates them into METSRights PermissionTypes.
 * @param dso DSpace Object
 * @return XML Element corresponding to the new <RightsDeclarationMD> translation
 * @throws CrosswalkException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
@Override public Element disseminateElement(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso == null)   return null;
 else   if (dso.getType() == Constants.SITE)   throw new CrosswalkObjectNotSupported(""String_Node_Str"");
  Element rightsMD=new Element(""String_Node_Str"",METSRights_NS);
  rightsMD.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Context context=new Context();
  List<ResourcePolicy> policies=AuthorizeManager.getPolicies(context,dso);
  for (  ResourcePolicy policy : policies) {
    Group group=policy.getGroup();
    EPerson person=policy.getEPerson();
    Element rightsContext=new Element(""String_Node_Str"",METSRights_NS);
    rightsMD.addContent(rightsContext);
    if (group != null) {
      String contextClass=GROUP_CONTEXTCLASS;
      if (group.getID() == 0)       contextClass=ANONYMOUS_CONTEXTCLASS;
 else       if (group.getID() == 1)       contextClass=ADMIN_CONTEXTCLASS;
      rightsContext.setAttribute(""String_Node_Str"",contextClass);
      if (contextClass.equals(GROUP_CONTEXTCLASS)) {
        try {
          Element rightsUser=new Element(""String_Node_Str"",METSRights_NS);
          rightsUser.setAttribute(""String_Node_Str"",GROUP_USERTYPE);
          rightsUser.addContent(PackageUtils.translateGroupNameForExport(context,group.getName()));
          rightsContext.addContent(rightsUser);
        }
 catch (        PackageException pe) {
          throw new CrosswalkException(pe);
        }
      }
    }
 else     if (person != null) {
      rightsContext.setAttribute(""String_Node_Str"",PERSON_CONTEXTCLASS);
      Element rightsUser=new Element(""String_Node_Str"",METSRights_NS);
      rightsUser.setAttribute(""String_Node_Str"",PERSON_USERTYPE);
      rightsUser.addContent(person.getEmail());
      rightsContext.addContent(rightsUser);
    }
    Element rightsPerm=translatePermissions(policy);
    rightsContext.addContent(rightsPerm);
  }
  context.complete();
  return rightsMD;
}",0.9928900041823504
3269,"/** 
 * Ingest a List of XML elements <P> This method creates new DSpace Policies based on the parsed METSRights XML contents. These Policies assign permissions to DSpace Groups or EPeople. <P> NOTE: This crosswalk will NOT create missing DSpace Groups or EPeople. Therefore, it is recommended to use this METSRightsCrosswalk in conjunction with another Crosswalk which can create/restore missing Groups or EPeople (e.g. RoleCrosswalk).
 * @param context
 * @param dso
 * @param metadata
 * @throws CrosswalkException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 * @see RoleCrosswalk
 */
@Override public void ingest(Context context,DSpaceObject dso,List ml) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() == Constants.SITE)   throw new CrosswalkObjectNotSupported(""String_Node_Str"");
  if (!ml.isEmpty())   AuthorizeManager.removeAllPolicies(context,dso);
  Iterator mi=ml.iterator();
  while (mi.hasNext()) {
    Element element=(Element)mi.next();
    if (element.getName().equals(""String_Node_Str""))     ingest(context,dso,element.getChildren());
 else     if (element.getName().equals(""String_Node_Str"")) {
      String contextClass=element.getAttributeValue(""String_Node_Str"");
      Element permsElement=element.getChild(""String_Node_Str"",METSRights_NS);
      if (contextClass.equals(ANONYMOUS_CONTEXTCLASS)) {
        Group anonGroup=Group.find(context,0);
        if (anonGroup == null)         throw new CrosswalkInternalException(""String_Node_Str"");
        assignPermissions(context,dso,anonGroup,permsElement);
      }
 else       if (contextClass.equals(ADMIN_CONTEXTCLASS)) {
        Group adminGroup=Group.find(context,1);
        if (adminGroup == null)         throw new CrosswalkInternalException(""String_Node_Str"");
        assignPermissions(context,dso,adminGroup,permsElement);
      }
 else       if (contextClass.equals(GROUP_CONTEXTCLASS)) {
        try {
          String groupName=element.getChildTextTrim(""String_Node_Str"",METSRights_NS);
          groupName=PackageUtils.crosswalkDefaultGroupName(context,groupName);
          Group group=Group.findByName(context,groupName);
          if (group == null) {
            throw new CrosswalkInternalException(""String_Node_Str"" + ""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          assignPermissions(context,dso,group,permsElement);
        }
 catch (        PackageException pe) {
          throw new CrosswalkException(pe);
        }
      }
 else       if (contextClass.equals(PERSON_CONTEXTCLASS)) {
        String personEmail=element.getChildTextTrim(""String_Node_Str"",METSRights_NS);
        EPerson person=EPerson.findByEmail(context,personEmail);
        if (person == null)         person=EPerson.findByNetid(context,personEmail);
        if (person == null) {
          throw new CrosswalkInternalException(""String_Node_Str"" + ""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ personEmail+ ""String_Node_Str""+ ""String_Node_Str"");
        }
        assignPermissions(context,dso,person,permsElement);
      }
    }
  }
}","/** 
 * Ingest a List of XML elements <P> This method creates new DSpace Policies based on the parsed METSRights XML contents. These Policies assign permissions to DSpace Groups or EPeople. <P> NOTE: This crosswalk will NOT create missing DSpace Groups or EPeople. Therefore, it is recommended to use this METSRightsCrosswalk in conjunction with another Crosswalk which can create/restore missing Groups or EPeople (e.g. RoleCrosswalk).
 * @param context
 * @param dso
 * @param metadata
 * @throws CrosswalkException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 * @see RoleCrosswalk
 */
@Override public void ingest(Context context,DSpaceObject dso,List ml) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() == Constants.SITE)   throw new CrosswalkObjectNotSupported(""String_Node_Str"");
  if (!ml.isEmpty())   AuthorizeManager.removeAllPolicies(context,dso);
  Iterator mi=ml.iterator();
  while (mi.hasNext()) {
    Element element=(Element)mi.next();
    if (element.getName().equals(""String_Node_Str""))     ingest(context,dso,element.getChildren());
 else     if (element.getName().equals(""String_Node_Str"")) {
      String contextClass=element.getAttributeValue(""String_Node_Str"");
      Element permsElement=element.getChild(""String_Node_Str"",METSRights_NS);
      if (contextClass.equals(ANONYMOUS_CONTEXTCLASS)) {
        Group anonGroup=Group.find(context,0);
        if (anonGroup == null)         throw new CrosswalkInternalException(""String_Node_Str"");
        assignPermissions(context,dso,anonGroup,permsElement);
      }
 else       if (contextClass.equals(ADMIN_CONTEXTCLASS)) {
        Group adminGroup=Group.find(context,1);
        if (adminGroup == null)         throw new CrosswalkInternalException(""String_Node_Str"");
        assignPermissions(context,dso,adminGroup,permsElement);
      }
 else       if (contextClass.equals(GROUP_CONTEXTCLASS)) {
        try {
          String groupName=element.getChildTextTrim(""String_Node_Str"",METSRights_NS);
          groupName=PackageUtils.translateGroupNameForImport(context,groupName);
          Group group=Group.findByName(context,groupName);
          if (group == null) {
            throw new CrosswalkInternalException(""String_Node_Str"" + ""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ groupName+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          assignPermissions(context,dso,group,permsElement);
        }
 catch (        PackageException pe) {
          throw new CrosswalkException(pe);
        }
      }
 else       if (contextClass.equals(PERSON_CONTEXTCLASS)) {
        String personEmail=element.getChildTextTrim(""String_Node_Str"",METSRights_NS);
        EPerson person=EPerson.findByEmail(context,personEmail);
        if (person == null)         person=EPerson.findByNetid(context,personEmail);
        if (person == null) {
          throw new CrosswalkInternalException(""String_Node_Str"" + ""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ dso.getID()+ ""String_Node_Str""+ personEmail+ ""String_Node_Str""+ ""String_Node_Str"");
        }
        assignPermissions(context,dso,person,permsElement);
      }
    }
  }
}",0.9950263311878292
3270,"/** 
 * Emit XML describing a single Group.
 * @param context the DSpace Context
 * @parm relatedObjectthe DSpaceObject related to this group (if any)
 * @param group the Group to describe
 * @param write the description to this stream
 */
private void writeGroup(Context context,DSpaceObject relatedObject,Group group,XMLStreamWriter writer) throws XMLStreamException, PackageException {
  writer.writeStartElement(GROUP);
  writer.writeAttribute(ID,String.valueOf(group.getID()));
  writer.writeAttribute(NAME,PackageUtils.crosswalkDefaultGroupName(context,group.getName()));
  String groupType=getGroupType(relatedObject,group);
  if (groupType != null && !groupType.isEmpty())   writer.writeAttribute(TYPE,groupType);
  writer.writeStartElement(MEMBERS);
  for (  EPerson member : group.getMembers()) {
    writer.writeEmptyElement(MEMBER);
    writer.writeAttribute(ID,String.valueOf(member.getID()));
    writer.writeAttribute(NAME,member.getName());
  }
  writer.writeEndElement();
  writer.writeStartElement(MEMBER_GROUPS);
  for (  Group member : group.getMemberGroups()) {
    writer.writeEmptyElement(MEMBER_GROUP);
    writer.writeAttribute(ID,String.valueOf(member.getID()));
    writer.writeAttribute(NAME,PackageUtils.crosswalkDefaultGroupName(context,member.getName()));
  }
  writer.writeEndElement();
  writer.writeEndElement();
}","/** 
 * Emit XML describing a single Group.
 * @param context the DSpace Context
 * @parm relatedObjectthe DSpaceObject related to this group (if any)
 * @param group the Group to describe
 * @param write the description to this stream
 */
private void writeGroup(Context context,DSpaceObject relatedObject,Group group,XMLStreamWriter writer) throws XMLStreamException, PackageException {
  writer.writeStartElement(GROUP);
  writer.writeAttribute(ID,String.valueOf(group.getID()));
  writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,group.getName()));
  String groupType=getGroupType(relatedObject,group);
  if (groupType != null && !groupType.isEmpty())   writer.writeAttribute(TYPE,groupType);
  writer.writeStartElement(MEMBERS);
  for (  EPerson member : group.getMembers()) {
    writer.writeEmptyElement(MEMBER);
    writer.writeAttribute(ID,String.valueOf(member.getID()));
    writer.writeAttribute(NAME,member.getName());
  }
  writer.writeEndElement();
  writer.writeStartElement(MEMBER_GROUPS);
  for (  Group member : group.getMemberGroups()) {
    writer.writeEmptyElement(MEMBER_GROUP);
    writer.writeAttribute(ID,String.valueOf(member.getID()));
    writer.writeAttribute(NAME,PackageUtils.translateGroupNameForExport(context,member.getName()));
  }
  writer.writeEndElement();
  writer.writeEndElement();
}",0.9703703703703704
3271,"/** 
 * Common code to ingest roles from a Document.
 * @param context DSpace Context
 * @param parent the Parent DSpaceObject
 * @param document the XML Document
 * @throws SQLException
 * @throws AuthorizeException
 * @throws PackageException
 */
static void ingestDocument(Context context,DSpaceObject parent,PackageParameters params,Document document) throws SQLException, AuthorizeException, PackageException {
  String myEmail=context.getCurrentUser().getEmail();
  String myNetid=context.getCurrentUser().getNetid();
  NodeList users=document.getElementsByTagName(RoleDisseminator.EPERSON);
  for (int i=0; i < users.getLength(); i++) {
    Element user=(Element)users.item(i);
    NodeList emails=user.getElementsByTagName(RoleDisseminator.EMAIL);
    NodeList netids=user.getElementsByTagName(RoleDisseminator.NETID);
    EPerson eperson;
    EPerson collider;
    String email=null;
    String netid=null;
    String identity;
    if (emails.getLength() > 0) {
      email=emails.item(0).getTextContent();
      if (email.equals(myEmail))       continue;
      identity=email;
      collider=EPerson.findByEmail(context,identity);
    }
 else     if (netids.getLength() > 0) {
      netid=netids.item(0).getTextContent();
      if (netid.equals(myNetid))       continue;
      identity=netid;
      collider=EPerson.findByNetid(context,identity);
    }
 else     throw new PackageException(""String_Node_Str"");
    if (null != collider)     if (params.replaceModeEnabled()) {
      eperson=collider;
    }
 else     if (params.keepExistingModeEnabled()) {
      log.warn(""String_Node_Str"",identity);
      continue;
    }
 else     throw new PackageException(""String_Node_Str"" + identity + ""String_Node_Str"");
 else {
      eperson=EPerson.create(context);
      log.info(""String_Node_Str"",identity);
    }
    eperson.setEmail(email);
    eperson.setNetid(netid);
    NodeList data;
    data=user.getElementsByTagName(RoleDisseminator.FIRST_NAME);
    if (data.getLength() > 0)     eperson.setFirstName(data.item(0).getTextContent());
 else     eperson.setFirstName(null);
    data=user.getElementsByTagName(RoleDisseminator.LAST_NAME);
    if (data.getLength() > 0)     eperson.setLastName(data.item(0).getTextContent());
 else     eperson.setLastName(null);
    data=user.getElementsByTagName(RoleDisseminator.LANGUAGE);
    if (data.getLength() > 0)     eperson.setLanguage(data.item(0).getTextContent());
 else     eperson.setLanguage(null);
    data=user.getElementsByTagName(RoleDisseminator.CAN_LOGIN);
    eperson.setCanLogIn(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.REQUIRE_CERTIFICATE);
    eperson.setRequireCertificate(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.SELF_REGISTERED);
    eperson.setSelfRegistered(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.PASSWORD_HASH);
    if (data.getLength() > 0)     eperson.setPasswordHash(data.item(0).getTextContent());
 else     eperson.setPasswordHash(null);
    eperson.update();
  }
  NodeList groups=document.getElementsByTagName(RoleDisseminator.GROUP);
  for (int groupx=0; groupx < groups.getLength(); groupx++) {
    Element group=(Element)groups.item(groupx);
    String name=group.getAttribute(RoleDisseminator.NAME);
    name=PackageUtils.crosswalkDefaultGroupName(context,name);
    Group groupObj=null;
    Group collider=Group.findByName(context,name);
    if (null != collider) {
      if (params.replaceModeEnabled()) {
        for (        Group member : collider.getMemberGroups())         collider.removeMember(member);
        for (        EPerson member : collider.getMembers())         collider.removeMember(member);
        log.info(""String_Node_Str"",name);
        groupObj=collider;
      }
 else       if (params.keepExistingModeEnabled()) {
        log.warn(""String_Node_Str"",name);
        continue;
      }
 else       throw new PackageException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      String type=group.getAttribute(RoleDisseminator.TYPE);
      if (type != null && !type.isEmpty() && parent != null) {
        if (parent.getType() == Constants.COLLECTION) {
          Collection collection=(Collection)parent;
          if (type.equals(RoleDisseminator.GROUP_TYPE_ADMIN))           groupObj=collection.createAdministrators();
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_SUBMIT))           groupObj=collection.createSubmitters();
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_1))           groupObj=collection.createWorkflowGroup(1);
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_2))           groupObj=collection.createWorkflowGroup(2);
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_3))           groupObj=collection.createWorkflowGroup(3);
        }
 else         if (parent.getType() == Constants.COMMUNITY) {
          Community community=(Community)parent;
          if (type.equals(RoleDisseminator.GROUP_TYPE_ADMIN))           groupObj=community.createAdministrators();
        }
      }
      if (groupObj == null) {
        groupObj=Group.create(context);
        groupObj.setName(name);
      }
      log.info(""String_Node_Str"",groupObj.getName());
    }
    NodeList members=group.getElementsByTagName(RoleDisseminator.MEMBER);
    for (int memberx=0; memberx < members.getLength(); memberx++) {
      Element member=(Element)members.item(memberx);
      String memberName=member.getAttribute(RoleDisseminator.NAME);
      EPerson memberEPerson=EPerson.findByEmail(context,memberName);
      groupObj.addMember(memberEPerson);
    }
    groupObj.update();
  }
  for (int groupx=0; groupx < groups.getLength(); groupx++) {
    Element group=(Element)groups.item(groupx);
    String name=group.getAttribute(RoleDisseminator.NAME);
    name=PackageUtils.crosswalkDefaultGroupName(context,name);
    Group groupObj=Group.findByName(context,name);
    NodeList members=group.getElementsByTagName(RoleDisseminator.MEMBER_GROUP);
    for (int memberx=0; memberx < members.getLength(); memberx++) {
      Element member=(Element)members.item(memberx);
      String memberName=member.getAttribute(RoleDisseminator.NAME);
      memberName=PackageUtils.crosswalkDefaultGroupName(context,memberName);
      Group memberGroup=Group.findByName(context,memberName);
      groupObj.addMember(memberGroup);
    }
    groupObj.update();
  }
}","/** 
 * Common code to ingest roles from a Document.
 * @param context DSpace Context
 * @param parent the Parent DSpaceObject
 * @param document the XML Document
 * @throws SQLException
 * @throws AuthorizeException
 * @throws PackageException
 */
static void ingestDocument(Context context,DSpaceObject parent,PackageParameters params,Document document) throws SQLException, AuthorizeException, PackageException {
  String myEmail=context.getCurrentUser().getEmail();
  String myNetid=context.getCurrentUser().getNetid();
  NodeList users=document.getElementsByTagName(RoleDisseminator.EPERSON);
  for (int i=0; i < users.getLength(); i++) {
    Element user=(Element)users.item(i);
    NodeList emails=user.getElementsByTagName(RoleDisseminator.EMAIL);
    NodeList netids=user.getElementsByTagName(RoleDisseminator.NETID);
    EPerson eperson;
    EPerson collider;
    String email=null;
    String netid=null;
    String identity;
    if (emails.getLength() > 0) {
      email=emails.item(0).getTextContent();
      if (email.equals(myEmail))       continue;
      identity=email;
      collider=EPerson.findByEmail(context,identity);
    }
 else     if (netids.getLength() > 0) {
      netid=netids.item(0).getTextContent();
      if (netid.equals(myNetid))       continue;
      identity=netid;
      collider=EPerson.findByNetid(context,identity);
    }
 else     throw new PackageException(""String_Node_Str"");
    if (null != collider)     if (params.replaceModeEnabled()) {
      eperson=collider;
    }
 else     if (params.keepExistingModeEnabled()) {
      log.warn(""String_Node_Str"",identity);
      continue;
    }
 else     throw new PackageException(""String_Node_Str"" + identity + ""String_Node_Str"");
 else {
      eperson=EPerson.create(context);
      log.info(""String_Node_Str"",identity);
    }
    eperson.setEmail(email);
    eperson.setNetid(netid);
    NodeList data;
    data=user.getElementsByTagName(RoleDisseminator.FIRST_NAME);
    if (data.getLength() > 0)     eperson.setFirstName(data.item(0).getTextContent());
 else     eperson.setFirstName(null);
    data=user.getElementsByTagName(RoleDisseminator.LAST_NAME);
    if (data.getLength() > 0)     eperson.setLastName(data.item(0).getTextContent());
 else     eperson.setLastName(null);
    data=user.getElementsByTagName(RoleDisseminator.LANGUAGE);
    if (data.getLength() > 0)     eperson.setLanguage(data.item(0).getTextContent());
 else     eperson.setLanguage(null);
    data=user.getElementsByTagName(RoleDisseminator.CAN_LOGIN);
    eperson.setCanLogIn(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.REQUIRE_CERTIFICATE);
    eperson.setRequireCertificate(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.SELF_REGISTERED);
    eperson.setSelfRegistered(data.getLength() > 0);
    data=user.getElementsByTagName(RoleDisseminator.PASSWORD_HASH);
    if (data.getLength() > 0)     eperson.setPasswordHash(data.item(0).getTextContent());
 else     eperson.setPasswordHash(null);
    eperson.update();
  }
  NodeList groups=document.getElementsByTagName(RoleDisseminator.GROUP);
  for (int groupx=0; groupx < groups.getLength(); groupx++) {
    Element group=(Element)groups.item(groupx);
    String name=group.getAttribute(RoleDisseminator.NAME);
    try {
      name=PackageUtils.translateGroupNameForImport(context,name);
    }
 catch (    PackageException pe) {
      log.warn(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
      continue;
    }
    Group groupObj=null;
    Group collider=Group.findByName(context,name);
    if (null != collider) {
      if (params.replaceModeEnabled()) {
        for (        Group member : collider.getMemberGroups())         collider.removeMember(member);
        for (        EPerson member : collider.getMembers()) {
          if (!(collider.equals(Group.find(context,1)) && member.equals(context.getCurrentUser())))           collider.removeMember(member);
        }
        log.info(""String_Node_Str"",name);
        groupObj=collider;
      }
 else       if (params.keepExistingModeEnabled()) {
        log.warn(""String_Node_Str"",name);
        continue;
      }
 else       throw new PackageException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
 else {
      String type=group.getAttribute(RoleDisseminator.TYPE);
      if (type != null && !type.isEmpty() && parent != null) {
        if (parent.getType() == Constants.COLLECTION) {
          Collection collection=(Collection)parent;
          if (type.equals(RoleDisseminator.GROUP_TYPE_ADMIN))           groupObj=collection.createAdministrators();
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_SUBMIT))           groupObj=collection.createSubmitters();
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_1))           groupObj=collection.createWorkflowGroup(1);
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_2))           groupObj=collection.createWorkflowGroup(2);
 else           if (type.equals(RoleDisseminator.GROUP_TYPE_WORKFLOW_STEP_3))           groupObj=collection.createWorkflowGroup(3);
        }
 else         if (parent.getType() == Constants.COMMUNITY) {
          Community community=(Community)parent;
          if (type.equals(RoleDisseminator.GROUP_TYPE_ADMIN))           groupObj=community.createAdministrators();
        }
      }
      if (groupObj == null) {
        groupObj=Group.create(context);
        groupObj.setName(name);
      }
      log.info(""String_Node_Str"",groupObj.getName());
    }
    NodeList members=group.getElementsByTagName(RoleDisseminator.MEMBER);
    for (int memberx=0; memberx < members.getLength(); memberx++) {
      Element member=(Element)members.item(memberx);
      String memberName=member.getAttribute(RoleDisseminator.NAME);
      EPerson memberEPerson=EPerson.findByEmail(context,memberName);
      groupObj.addMember(memberEPerson);
    }
    groupObj.update();
  }
  for (int groupx=0; groupx < groups.getLength(); groupx++) {
    Element group=(Element)groups.item(groupx);
    String name=group.getAttribute(RoleDisseminator.NAME);
    try {
      name=PackageUtils.translateGroupNameForImport(context,name);
    }
 catch (    PackageException pe) {
      continue;
    }
    Group groupObj=Group.findByName(context,name);
    NodeList members=group.getElementsByTagName(RoleDisseminator.MEMBER_GROUP);
    for (int memberx=0; memberx < members.getLength(); memberx++) {
      Element member=(Element)members.item(memberx);
      String memberName=member.getAttribute(RoleDisseminator.NAME);
      memberName=PackageUtils.translateGroupNameForImport(context,memberName);
      Group memberGroup=Group.findByName(context,memberName);
      groupObj.addMember(memberGroup);
    }
    groupObj.update();
  }
}",0.959637872500943
3272,"/** 
 * When DSpace creates Default Group Names they are of a very specific format, for example: <li> COMMUNITY_[ID]_ADMIN <li> COLLECTION_[ID]_ADMIN <li> COLLECTION_[ID]_SUBMIT <li> COLLECTION_[ID]_WORKFLOW_STEP_# <p> Although these names work fine within DSpace, the DSpace internal ID (represented by [ID] above) becomes meaningless when content is exported outside of DSpace.  In order to make these Group names meaningful outside of DSpace, they must be translated into a different format: <li> COMMUNITY_[HANDLE]_ADMIN (e.g. COMMUNITY_hdl:123456789/10_ADMIN), etc. <p> This format replaces the internal ID with an external Handle identifier (which is expected to be more meaningful even when content is exported from DSpace). <p> This method translates between the two Group Name formats. In either case if the specified <code>groupDefaultName</code> looks to be a default group name with an identifier, its identifier is replaced with the value of <code>newGroupIdentifier</code>.  This allows you to more easily translate an internal group name to one that can have meaning external to DSpace (and visa versa). <p> This method may be useful to any Crosswalks/Packagers which deal with import/export of DSpace Groups.
 * @param relatedDso DSpaceObject associated with group
 * @param groupDefaultName Group's default name
 * @return a new default Group name, containing the newGroupIdentifier
 */
public static String crosswalkDefaultGroupName(Context context,String groupDefaultName) throws PackageException {
  if (!groupDefaultName.matches(""String_Node_Str"")) {
    return groupDefaultName;
  }
  String objType=groupDefaultName.substring(0,groupDefaultName.indexOf(""String_Node_Str""));
  String tmpEndString=groupDefaultName.substring(groupDefaultName.indexOf(""String_Node_Str"") + 1);
  String objID=tmpEndString.substring(0,tmpEndString.indexOf(""String_Node_Str""));
  String groupType=tmpEndString.substring(tmpEndString.indexOf(""String_Node_Str"") + 1);
  try {
    if (objID.contains(""String_Node_Str"")) {
      DSpaceObject dso=HandleManager.resolveToObject(context,objID.substring(4));
      if (dso == null)       throw new PackageException(""String_Node_Str"" + objID + ""String_Node_Str""+ groupDefaultName+ ""String_Node_Str"");
      if (Constants.getTypeID(objType) != dso.getType())       throw new PackageException(""String_Node_Str"" + objID + ""String_Node_Str""+ groupDefaultName+ ""String_Node_Str"");
      return objType + ""String_Node_Str"" + dso.getID()+ ""String_Node_Str""+ groupType;
    }
 else {
      DSpaceObject dso=DSpaceObject.find(context,Constants.getTypeID(objType),Integer.parseInt(objID));
      if (dso == null)       throw new PackageException(""String_Node_Str"" + objID + ""String_Node_Str""+ objType+ ""String_Node_Str""+ groupDefaultName+ ""String_Node_Str"");
      return objType + ""String_Node_Str"" + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ groupType;
    }
  }
 catch (  SQLException sqle) {
    throw new PackageException(""String_Node_Str"" + groupDefaultName + ""String_Node_Str"");
  }
}","/** 
 * When DSpace creates Default Group Names they are of a very specific format, for example: <li> COMMUNITY_[ID]_ADMIN <li> COLLECTION_[ID]_ADMIN <li> COLLECTION_[ID]_SUBMIT <li> COLLECTION_[ID]_WORKFLOW_STEP_# <p> Although these names work fine within DSpace, the DSpace internal ID (represented by [ID] above) becomes meaningless when content is exported outside of DSpace.  In order to make these Group names meaningful outside of DSpace, they must be translated into a different format: <li> COMMUNITY_[HANDLE]_ADMIN (e.g. COMMUNITY_hdl:123456789/10_ADMIN), etc. <p> This format replaces the internal ID with an external Handle identifier (which is expected to be more meaningful even when content is exported from DSpace). <p> This method translates between the two Group Name formats. In either case if the specified <code>groupDefaultName</code> looks to be a default group name with an identifier, its identifier is replaced with the value of <code>newGroupIdentifier</code>.  This allows you to more easily translate an internal group name to one that can have meaning external to DSpace (and visa versa). <p> This method may be useful to any Crosswalks/Packagers which deal with import/export of DSpace Groups.
 * @param relatedDso DSpaceObject associated with group
 * @param groupDefaultName Group's default name
 * @return a new default Group name, containing the newGroupIdentifier
 */
public static String crosswalkDefaultGroupName(Context context,String groupDefaultName) throws PackageException {
  if (!groupDefaultName.matches(""String_Node_Str"")) {
    return groupDefaultName;
  }
  String objType=groupDefaultName.substring(0,groupDefaultName.indexOf(""String_Node_Str""));
  String tmpEndString=groupDefaultName.substring(groupDefaultName.indexOf(""String_Node_Str"") + 1);
  String objID=tmpEndString.substring(0,tmpEndString.indexOf(""String_Node_Str""));
  String groupType=tmpEndString.substring(tmpEndString.indexOf(""String_Node_Str"") + 1);
  try {
    if (objID.contains(""String_Node_Str"")) {
      DSpaceObject dso=HandleManager.resolveToObject(context,objID.substring(4));
      if (dso == null) {
        log.warn(""String_Node_Str"" + groupDefaultName + ""String_Node_Str""+ objID+ ""String_Node_Str"");
        return groupDefaultName;
      }
      if (Constants.getTypeID(objType) != dso.getType())       throw new PackageException(""String_Node_Str"" + objID + ""String_Node_Str""+ groupDefaultName+ ""String_Node_Str"");
      return objType + ""String_Node_Str"" + dso.getID()+ ""String_Node_Str""+ groupType;
    }
 else {
      DSpaceObject dso=DSpaceObject.find(context,Constants.getTypeID(objType),Integer.parseInt(objID));
      if (dso == null) {
        log.warn(""String_Node_Str"" + groupDefaultName + ""String_Node_Str""+ objID+ ""String_Node_Str""+ objType+ ""String_Node_Str"");
        return groupDefaultName;
      }
      return objType + ""String_Node_Str"" + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ groupType;
    }
  }
 catch (  SQLException sqle) {
    throw new PackageException(""String_Node_Str"" + groupDefaultName + ""String_Node_Str"");
  }
}",0.9467668190725016
3273,"/** 
 * Return a Group Type string (see RoleDisseminator.GROUP_TYPE_* constants) which describes the type of group and its relation to the given object. <P> As a basic example, if the Group is a Collection Administration group, the Group Type string returned should be ""ADMIN"" <P> If type string cannot be determined, null is returned.
 * @param dso the related DSpaceObject
 * @param group the group
 * @return a group type string or null
 */
private String getGroupType(DSpaceObject dso,Group group){
  if (dso.getType() == Constants.COMMUNITY) {
    Community community=(Community)dso;
    if (community.getAdministrators().equals(group))     return GROUP_TYPE_ADMIN;
  }
 else   if (dso.getType() == Constants.COLLECTION) {
    Collection collection=(Collection)dso;
    if (collection.getAdministrators().equals(group))     return GROUP_TYPE_ADMIN;
 else     if (collection.getSubmitters().equals(group))     return GROUP_TYPE_SUBMIT;
 else     if (collection.getWorkflowGroup(1).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_1;
 else     if (collection.getWorkflowGroup(2).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_2;
 else     if (collection.getWorkflowGroup(3).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_3;
  }
  return null;
}","/** 
 * Return a Group Type string (see RoleDisseminator.GROUP_TYPE_* constants) which describes the type of group and its relation to the given object. <P> As a basic example, if the Group is a Collection Administration group, the Group Type string returned should be ""ADMIN"" <P> If type string cannot be determined, null is returned.
 * @param dso the related DSpaceObject
 * @param group the group
 * @return a group type string or null
 */
private String getGroupType(DSpaceObject dso,Group group){
  if (dso.getType() == Constants.COMMUNITY) {
    Community community=(Community)dso;
    if (community.getAdministrators() != null && community.getAdministrators().equals(group))     return GROUP_TYPE_ADMIN;
  }
 else   if (dso.getType() == Constants.COLLECTION) {
    Collection collection=(Collection)dso;
    if (collection.getAdministrators() != null && collection.getAdministrators().equals(group))     return GROUP_TYPE_ADMIN;
 else     if (collection.getSubmitters() != null && collection.getSubmitters().equals(group))     return GROUP_TYPE_SUBMIT;
 else     if (collection.getWorkflowGroup(1) != null && collection.getWorkflowGroup(1).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_1;
 else     if (collection.getWorkflowGroup(2) != null && collection.getWorkflowGroup(2).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_2;
 else     if (collection.getWorkflowGroup(3) != null && collection.getWorkflowGroup(3).equals(group))     return GROUP_TYPE_WORKFLOW_STEP_3;
  }
  return null;
}",0.9105396595436436
3274,"/** 
 * Create a new DSpace object out of a METS content package. All contents are dictated by the METS manifest. Package is a ZIP archive (or optionally bare manifest XML document). In a Zip, all files relative to top level and the manifest (as per spec) in mets.xml.
 * @param context  DSpace context.
 * @param parent parent under which to create new object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return DSpaceObject created by ingest.
 * @throws PackageValidationException if package is unacceptable or there isa fatal error turning it into a DSpaceObject.
 * @throws CrosswalkException
 * @throws AuthorizeException
 * @throws SQLException
 * @throws IOException
 */
public DSpaceObject ingest(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  METSManifest manifest=null;
  DSpaceObject dso=null;
  try {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile.getName()));
    manifest=parsePackage(context,pkgFile,params);
    if (manifest == null)     throw new PackageValidationException(""String_Node_Str"" + METSManifest.MANIFEST_FILE + ""String_Node_Str"");
    checkManifest(manifest);
    if (!params.restoreModeEnabled() && !params.containsKey(""String_Node_Str"")) {
      params.addProperty(""String_Node_Str"",""String_Node_Str"");
    }
    if (parent != null && !params.containsKey(""String_Node_Str"")) {
      params.addProperty(""String_Node_Str"",""String_Node_Str"");
    }
    dso=ingestObject(context,parent,manifest,pkgFile,params,license);
    String action=""String_Node_Str"";
    if (params.restoreModeEnabled())     action=""String_Node_Str"";
    log.info(LogManager.getHeader(context,action,""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ String.valueOf(dso.getID())));
    if (params.recursiveModeEnabled()) {
      String[] childFilePaths=manifest.getChildMetsFilePaths();
      for (int i=0; i < childFilePaths.length; i++)       addPackageReference(dso,childFilePaths[i]);
    }
    return dso;
  }
 catch (  SQLException se) {
    dso=null;
    throw se;
  }
}","/** 
 * Create a new DSpace object out of a METS content package. All contents are dictated by the METS manifest. Package is a ZIP archive (or optionally bare manifest XML document). In a Zip, all files relative to top level and the manifest (as per spec) in mets.xml.
 * @param context  DSpace context.
 * @param parent parent under which to create new object(may be null -- in which case ingester must determine parent from package or throw an error).
 * @param pkgFile  The package file to ingest
 * @param params Properties-style list of options (interpreted by each packager).
 * @param license  may be null, which takes default license.
 * @return DSpaceObject created by ingest.
 * @throws PackageValidationException if package is unacceptable or there isa fatal error turning it into a DSpaceObject.
 * @throws CrosswalkException
 * @throws AuthorizeException
 * @throws SQLException
 * @throws IOException
 */
public DSpaceObject ingest(Context context,DSpaceObject parent,File pkgFile,PackageParameters params,String license) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  METSManifest manifest=null;
  DSpaceObject dso=null;
  try {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + pkgFile.getName()));
    manifest=parsePackage(context,pkgFile,params);
    if (manifest == null)     throw new PackageValidationException(""String_Node_Str"" + METSManifest.MANIFEST_FILE + ""String_Node_Str"");
    checkManifest(manifest);
    if (!params.restoreModeEnabled() && !params.containsKey(""String_Node_Str"")) {
      params.addProperty(""String_Node_Str"",""String_Node_Str"");
    }
    if (parent != null && !params.containsKey(""String_Node_Str"")) {
      params.addProperty(""String_Node_Str"",""String_Node_Str"");
    }
    int type=getObjectType(manifest);
    if (type == Constants.SITE) {
      dso=Site.find(context,Site.SITE_ID);
    }
 else {
      dso=ingestObject(context,parent,manifest,pkgFile,params,license);
      String action=""String_Node_Str"";
      if (params.restoreModeEnabled())       action=""String_Node_Str"";
      log.info(LogManager.getHeader(context,action,""String_Node_Str"" + Constants.typeText[dso.getType()] + ""String_Node_Str""+ dso.getHandle()+ ""String_Node_Str""+ String.valueOf(dso.getID())));
    }
    if (params.recursiveModeEnabled()) {
      String[] childFilePaths=manifest.getChildMetsFilePaths();
      for (int i=0; i < childFilePaths.length; i++)       addPackageReference(dso,childFilePaths[i]);
    }
    return dso;
  }
 catch (  SQLException se) {
    dso=null;
    throw se;
  }
}",0.8363851151801536
3275,"/** 
 * Find the eperson by their email address
 * @return EPerson
 */
public static EPerson findByEmail(Context context,String email) throws SQLException, AuthorizeException {
  TableRow row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",email);
  if (row == null) {
    return null;
  }
 else {
    EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      return fromCache;
    }
 else {
      return new EPerson(context,row);
    }
  }
}","/** 
 * Find the eperson by their email address
 * @return EPerson
 */
public static EPerson findByEmail(Context context,String email) throws SQLException, AuthorizeException {
  if (email == null) {
    return null;
  }
  TableRow row=DatabaseManager.findByUnique(context,""String_Node_Str"",""String_Node_Str"",email.toLowerCase());
  if (row == null) {
    return null;
  }
 else {
    EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      return fromCache;
    }
 else {
      return new EPerson(context,row);
    }
  }
}",0.9491228070175438
3276,"/** 
 * Simple test program Usage:  java org.dspace.content.DCdate [DCDate | -l yyyy [mm [dd ..]]] ] (-l form tests local time parsing) Default is to use current time.
 */
public static void main(String args[]) throws Exception {
  DCDate d;
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      int val[]={-1,-1,-1,-1,-1,-1};
      for (int i=1; i < 7 && i < args.length; ++i)       val[i - 1]=Integer.parseInt(args[i]);
      d=new DCDate();
      d.setDateLocal(val[0],val[1],val[2],val[3],val[4],val[5]);
    }
 else     d=new DCDate(args[0]);
  }
 else   d=DCDate.getCurrent();
  System.out.println(""String_Node_Str"" + d.toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.toDate().toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.granularity);
  System.out.println(""String_Node_Str"" + d.getYear());
  System.out.println(""String_Node_Str"" + d.getMonth());
  System.out.println(""String_Node_Str"" + d.getDay());
  System.out.println(""String_Node_Str"" + d.getHour());
  System.out.println(""String_Node_Str"" + d.getMinute());
  System.out.println(""String_Node_Str"" + d.getSecond());
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.getYearGMT());
  System.out.println(""String_Node_Str"" + d.getMonthGMT());
  System.out.println(""String_Node_Str"" + d.getDayGMT());
  System.out.println(""String_Node_Str"" + d.getHourGMT());
  System.out.println(""String_Node_Str"" + d.getMinuteGMT());
  System.out.println(""String_Node_Str"" + d.getSecondGMT());
  DCDate hw=new DCDate();
  hw.setDateLocal(d.getYear(),d.getMonth(),d.getDay(),d.getHour(),d.getMinute(),d.getSecond());
  System.out.println(""String_Node_Str"" + hw.toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + DCDate.getMonthName(d.getMonth(),Locale.getDefault()) + ""String_Node_Str"");
}","/** 
 * Simple test program Usage:  java org.dspace.content.DCdate [DCDate | -l yyyy [mm [dd ..]]] ] where ""DCDate"" is the kind of value that would be in metadata, e.g. ""2006"", ""2006-02-03"", etc. (-l form tests local time parsing) Default is to use current time.
 */
public static void main(String args[]) throws Exception {
  DCDate d;
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      int val[]={-1,-1,-1,-1,-1,-1};
      for (int i=1; i < 7 && i < args.length; ++i)       val[i - 1]=Integer.parseInt(args[i]);
      d=new DCDate();
      d.setDateLocal(val[0],val[1],val[2],val[3],val[4],val[5]);
    }
 else     d=new DCDate(args[0]);
  }
 else   d=DCDate.getCurrent();
  System.out.println(""String_Node_Str"" + d.toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.toDate().toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.granularity);
  System.out.println(""String_Node_Str"" + d.getYear());
  System.out.println(""String_Node_Str"" + d.getMonth());
  System.out.println(""String_Node_Str"" + d.getDay());
  System.out.println(""String_Node_Str"" + d.getHour());
  System.out.println(""String_Node_Str"" + d.getMinute());
  System.out.println(""String_Node_Str"" + d.getSecond());
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + d.getYearGMT());
  System.out.println(""String_Node_Str"" + d.getMonthGMT());
  System.out.println(""String_Node_Str"" + d.getDayGMT());
  System.out.println(""String_Node_Str"" + d.getHourGMT());
  System.out.println(""String_Node_Str"" + d.getMinuteGMT());
  System.out.println(""String_Node_Str"" + d.getSecondGMT());
  DCDate hw=new DCDate();
  hw.setDateLocal(d.getYear(),d.getMonth(),d.getDay(),d.getHour(),d.getMinute(),d.getSecond());
  System.out.println(""String_Node_Str"" + hw.toString() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + DCDate.getMonthName(d.getMonth(),Locale.getDefault()) + ""String_Node_Str"");
}",0.9757095372027614
3277,"private synchronized String toStringInternal(){
  if (granularity == DateGran.YEAR)   return yearIso.format(calendar.getTime());
 else   if (granularity == DateGran.MONTH)   return yearMonthIso.format(calendar.getTime());
 else   if (granularity == DateGran.DAY)   return dateIso.format(calendar.getTime());
 else   return fullIso.format(calendar.getTime());
}","private synchronized String toStringInternal(){
  if (granularity == DateGran.YEAR)   return String.format(""String_Node_Str"",getYear());
 else   if (granularity == DateGran.MONTH)   return String.format(""String_Node_Str"",getYear(),getMonth());
 else   if (granularity == DateGran.DAY)   return String.format(""String_Node_Str"",getYear(),getMonth(),getDay());
 else   return fullIso.format(calendar.getTime());
}",0.7194805194805195
3278,"/** 
 * Construct a date from a Dublin Core value
 * @param fromDC the date string, in ISO 8601 (no timezone, always use UTC/GMT)
 */
public DCDate(String fromDC){
  super();
  if ((fromDC == null) || fromDC.equals(""String_Node_Str"")) {
    return;
  }
  granularity=DateGran.TIME;
  Date date=tryParse(fullIso,fromDC);
  if (date == null)   date=tryParse(fullIso2,fromDC);
  if (date == null)   date=tryParse(fullIso3,fromDC);
  if (date == null) {
    date=tryParse(dateIso,fromDC);
    granularity=DateGran.DAY;
  }
  if (date == null) {
    date=tryParse(yearMonthIso,fromDC);
    granularity=DateGran.MONTH;
  }
  if (date == null) {
    date=tryParse(yearIso,fromDC);
    granularity=DateGran.YEAR;
  }
  if (date == null)   log.warn(""String_Node_Str"" + fromDC + ""String_Node_Str"");
 else   setTime(date);
}","/** 
 * Construct a date from a Dublin Core value
 * @param fromDC the date string, in ISO 8601 (no timezone, always use UTC/GMT)
 */
public DCDate(String fromDC){
  super();
  if ((fromDC == null) || fromDC.equals(""String_Node_Str"")) {
    return;
  }
  granularity=DateGran.TIME;
  Date date=tryParse(fullIso,fromDC);
  if (date == null)   date=tryParse(fullIso2,fromDC);
  if (date == null)   date=tryParse(fullIso3,fromDC);
  if (date == null) {
    date=tryParse(dateIso,fromDC);
    if (date != null) {
      long ldate=date.getTime();
      date=new Date(ldate - localZone.getOffset(ldate));
      granularity=DateGran.DAY;
    }
  }
  if (date == null) {
    date=tryParse(yearMonthIso,fromDC);
    if (date != null) {
      long ldate=date.getTime();
      date=new Date(ldate - localZone.getOffset(ldate));
      granularity=DateGran.MONTH;
    }
  }
  if (date == null) {
    date=tryParse(yearIso,fromDC);
    if (date != null) {
      long ldate=date.getTime();
      date=new Date(ldate - localZone.getOffset(ldate));
      granularity=DateGran.YEAR;
    }
  }
  if (date == null)   log.warn(""String_Node_Str"" + fromDC + ""String_Node_Str"");
 else   setTime(date);
}",0.8162650602409639
3279,"/** 
 * Render a date field to the DRI document. The date field consists of three component fields, a 4 character text field for the year, a select box for the month, and a 2 character text field for the day.
 * @param form The form list to add the field too
 * @param fieldName The field's name.
 * @param dcInput The field's input deffinition
 * @param dcValues The field's pre-existing values.
 */
private void renderDateField(List form,String fieldName,DCInput dcInput,DCValue[] dcValues,boolean readonly) throws WingException {
  Composite fullDate=form.addItem().addComposite(fieldName,""String_Node_Str"");
  Text year=fullDate.addText(fieldName + ""String_Node_Str"");
  Select month=fullDate.addSelect(fieldName + ""String_Node_Str"");
  Text day=fullDate.addText(fieldName + ""String_Node_Str"");
  fullDate.setLabel(dcInput.getLabel());
  fullDate.setHelp(cleanHints(dcInput.getHints()));
  if (dcInput.isRequired())   fullDate.setRequired();
  if (isFieldInError(fieldName))   fullDate.addError(T_required_field);
  if (dcInput.isRepeatable() && !readonly)   fullDate.enableAddOperation();
  if ((dcInput.isRepeatable() || dcValues.length > 1) && !readonly)   fullDate.enableDeleteOperation();
  if (readonly) {
    year.setDisabled();
    month.setDisabled();
    day.setDisabled();
  }
  year.setLabel(T_year);
  year.setSize(4,4);
  month.setLabel(T_month);
  month.addOption(0,""String_Node_Str"");
  for (int i=1; i < 13; i++) {
    month.addOption(i,org.dspace.content.DCDate.getMonthName(i,Locale.getDefault()));
  }
  day.setLabel(T_day);
  day.setSize(2,2);
  if (dcInput.isRepeatable() || dcValues.length > 1) {
    for (    DCValue dcValue : dcValues) {
      DCDate dcDate=new DCDate(dcValue.value);
      year.addInstance().setValue(String.valueOf(dcDate.getYearGMT()));
      month.addInstance().setOptionSelected(dcDate.getMonthGMT());
      day.addInstance().setValue(String.valueOf(dcDate.getDayGMT()));
      fullDate.addInstance().setValue(dcDate.toString());
    }
  }
 else   if (dcValues.length == 1) {
    DCDate dcDate=new DCDate(dcValues[0].value);
    year.setValue(String.valueOf(dcDate.getYearGMT()));
    month.setOptionSelected(dcDate.getMonthGMT());
    if (dcDate.getDayGMT() == -1)     day.setValue(""String_Node_Str"");
 else     day.setValue(String.valueOf(dcDate.getDayGMT()));
  }
}","/** 
 * Render a date field to the DRI document. The date field consists of three component fields, a 4 character text field for the year, a select box for the month, and a 2 character text field for the day.
 * @param form The form list to add the field too
 * @param fieldName The field's name.
 * @param dcInput The field's input deffinition
 * @param dcValues The field's pre-existing values.
 */
private void renderDateField(List form,String fieldName,DCInput dcInput,DCValue[] dcValues,boolean readonly) throws WingException {
  Composite fullDate=form.addItem().addComposite(fieldName,""String_Node_Str"");
  Text year=fullDate.addText(fieldName + ""String_Node_Str"");
  Select month=fullDate.addSelect(fieldName + ""String_Node_Str"");
  Text day=fullDate.addText(fieldName + ""String_Node_Str"");
  fullDate.setLabel(dcInput.getLabel());
  fullDate.setHelp(cleanHints(dcInput.getHints()));
  if (dcInput.isRequired())   fullDate.setRequired();
  if (isFieldInError(fieldName))   fullDate.addError(T_required_field);
  if (dcInput.isRepeatable() && !readonly)   fullDate.enableAddOperation();
  if ((dcInput.isRepeatable() || dcValues.length > 1) && !readonly)   fullDate.enableDeleteOperation();
  if (readonly) {
    year.setDisabled();
    month.setDisabled();
    day.setDisabled();
  }
  year.setLabel(T_year);
  year.setSize(4,4);
  month.setLabel(T_month);
  month.addOption(0,""String_Node_Str"");
  for (int i=1; i < 13; i++) {
    month.addOption(i,org.dspace.content.DCDate.getMonthName(i,Locale.getDefault()));
  }
  day.setLabel(T_day);
  day.setSize(2,2);
  if (dcInput.isRepeatable() || dcValues.length > 1) {
    for (    DCValue dcValue : dcValues) {
      DCDate dcDate=new DCDate(dcValue.value);
      year.addInstance().setValue(String.valueOf(dcDate.getYear()));
      month.addInstance().setOptionSelected(dcDate.getMonth());
      day.addInstance().setValue(String.valueOf(dcDate.getDay()));
      fullDate.addInstance().setValue(dcDate.toString());
    }
  }
 else   if (dcValues.length == 1) {
    DCDate dcDate=new DCDate(dcValues[0].value);
    year.setValue(String.valueOf(dcDate.getYear()));
    month.setOptionSelected(dcDate.getMonth());
    if (dcDate.getDay() == -1)     day.setValue(""String_Node_Str"");
 else     day.setValue(String.valueOf(dcDate.getDay()));
  }
}",0.915312973792506
3280,"/** 
 * Generate the AJAX response Document. Looks for request parameters: field - MD field key, i.e. form key, REQUIRED - derivated from url. query - string to match collection - db ID of Collection ot serve as context start - index to start from, default 0. limit - max number of lines, default 1000. format - opt. result XML/XHTML format: ""select"", ""ul"", ""xml""(default) locale - explicit locale, pass to choice plugin
 */
private void process(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String[] paths=request.getPathInfo().split(""String_Node_Str"");
  String field=paths[paths.length - 1];
  ChoiceAuthorityManager cam=ChoiceAuthorityManager.getManager();
  String query=request.getParameter(""String_Node_Str"");
  String format=request.getParameter(""String_Node_Str"");
  int collection=UIUtil.getIntParameter(request,""String_Node_Str"");
  int start=UIUtil.getIntParameter(request,""String_Node_Str"");
  int limit=UIUtil.getIntParameter(request,""String_Node_Str"");
  Choices result=cam.getMatches(field,query,collection,start,limit,null);
  Writer writer=response.getWriter();
  Properties props=OutputPropertiesFactory.getDefaultMethodProperties(Method.XML);
  Serializer ser=SerializerFactory.getSerializer(props);
  ser.setWriter(writer);
  try {
    ChoicesXMLGenerator.generate(result,format,ser.asContentHandler());
  }
 catch (  SAXException e) {
    throw new IOException(e.toString());
  }
 finally {
    ser.reset();
  }
  writer.flush();
}","/** 
 * Generate the AJAX response Document. Looks for request parameters: field - MD field key, i.e. form key, REQUIRED - derivated from url. query - string to match collection - db ID of Collection ot serve as context start - index to start from, default 0. limit - max number of lines, default 1000. format - opt. result XML/XHTML format: ""select"", ""ul"", ""xml""(default) locale - explicit locale, pass to choice plugin
 */
private void process(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String[] paths=request.getPathInfo().split(""String_Node_Str"");
  String field=paths[paths.length - 1];
  ChoiceAuthorityManager cam=ChoiceAuthorityManager.getManager();
  String query=request.getParameter(""String_Node_Str"");
  String format=request.getParameter(""String_Node_Str"");
  int collection=UIUtil.getIntParameter(request,""String_Node_Str"");
  int start=UIUtil.getIntParameter(request,""String_Node_Str"");
  int limit=UIUtil.getIntParameter(request,""String_Node_Str"");
  Choices result=cam.getMatches(field,query,collection,start,limit,null);
  Writer writer=response.getWriter();
  response.setContentType(""String_Node_Str"");
  Properties props=OutputPropertiesFactory.getDefaultMethodProperties(Method.XML);
  Serializer ser=SerializerFactory.getSerializer(props);
  ser.setWriter(writer);
  try {
    ChoicesXMLGenerator.generate(result,format,ser.asContentHandler());
  }
 catch (  SAXException e) {
    throw new IOException(e.toString());
  }
 finally {
    ser.reset();
  }
  writer.flush();
}",0.985424588086185
3281,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null && values.length > 0) {
              int minConfidence=MetadataAuthorityManager.getManager().getMinConfidence(values[0].schema,values[0].element,values[0].qualifier);
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else                 if (bis[i].isAuthorityIndex()) {
                  if (values[x].authority != null && values[x].confidence >= minConfidence) {
                    boolean isValueVariants=false;
                    List<String> variants=ChoiceAuthorityManager.getManager().getVariants(values[x].schema,values[x].element,values[x].qualifier,values[x].authority,values[x].language);
                    if (variants != null) {
                      for (                      String var : variants) {
                        String nVal=OrderFormat.makeSortString(var,values[x].language,bis[i].getDataType());
                        distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),var,values[x].authority,nVal));
                        if (var.equals(values[x].value)) {
                          isValueVariants=true;
                        }
                      }
                    }
                    if (!isValueVariants) {
                      String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                      distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,values[x].authority,nVal));
                    }
                  }
 else {
                    log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ ""String_Node_Str""+ values[x].qualifier+ ""String_Node_Str""+ values[x].value+ ""String_Node_Str""+ values[x].authority+ ""String_Node_Str""+ values[x].confidence+ ""String_Node_Str"");
                  }
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,null,nVal));
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null && values.length > 0) {
              int minConfidence=MetadataAuthorityManager.getManager().getMinConfidence(values[0].schema,values[0].element,values[0].qualifier);
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  if (bis[i].isAuthorityIndex() && (values[x].authority == null || values[x].confidence < minConfidence)) {
                    log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ ""String_Node_Str""+ values[x].qualifier+ ""String_Node_Str""+ values[x].value+ ""String_Node_Str""+ values[x].authority+ ""String_Node_Str""+ values[x].confidence+ ""String_Node_Str"");
                    break;
                  }
                  if (values[x].authority != null && values[x].confidence >= minConfidence) {
                    boolean isValueVariants=false;
                    List<String> variants=ChoiceAuthorityManager.getManager().getVariants(values[x].schema,values[x].element,values[x].qualifier,values[x].authority,values[x].language);
                    if (variants != null) {
                      for (                      String var : variants) {
                        String nVal=OrderFormat.makeSortString(var,values[x].language,bis[i].getDataType());
                        distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),var,values[x].authority,nVal));
                        if (var.equals(values[x].value)) {
                          isValueVariants=true;
                        }
                      }
                    }
                    if (!isValueVariants) {
                      String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                      distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,values[x].authority,nVal));
                    }
                  }
 else {
                    String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                    distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,null,nVal));
                  }
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9160211985324092
3282,"/** 
 * Execute the DSpace script launcher
 * @param args Any parameters required to be passed to the scripts it executes
 * @throws Exception
 */
public static void main(String[] args){
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    display();
    System.exit(1);
  }
  try {
    kernelImpl=DSpaceKernelInit.getKernel(null);
    if (!kernelImpl.isRunning()) {
      kernelImpl.start(ConfigurationManager.getProperty(""String_Node_Str""));
    }
  }
 catch (  Exception e) {
    try {
      kernelImpl.destroy();
    }
 catch (    Exception e1) {
    }
    String message=""String_Node_Str"" + e.getMessage();
    System.err.println(message + ""String_Node_Str"" + e);
    throw new RuntimeException(message,e);
  }
  Document doc=getConfig();
  String request=args[0];
  Element root=doc.getRootElement();
  List<Element> commands=root.getChildren(""String_Node_Str"");
  for (  Element command : commands) {
    if (request.equalsIgnoreCase(command.getChild(""String_Node_Str"").getValue())) {
      List<Element> steps=command.getChildren(""String_Node_Str"");
      for (      Element step : steps) {
        Class target=null;
        String className=step.getChild(""String_Node_Str"").getValue();
        try {
          target=Class.forName(className,true,Thread.currentThread().getContextClassLoader());
        }
 catch (        ClassNotFoundException e) {
          System.err.println(""String_Node_Str"" + className);
          System.exit(1);
        }
        String[] useargs=args.clone();
        Class[] argTypes={useargs.getClass()};
        boolean passargs=true;
        if ((step.getAttribute(""String_Node_Str"") != null) && (""String_Node_Str"".equalsIgnoreCase(step.getAttribute(""String_Node_Str"").getValue()))) {
          passargs=false;
        }
        if ((args.length == 1) || (!passargs)) {
          useargs=new String[0];
        }
 else {
          String[] argsnew=new String[useargs.length - 1];
          for (int i=1; i < useargs.length; i++) {
            argsnew[i - 1]=useargs[i];
          }
          useargs=argsnew;
        }
        List<Element> bits=step.getChildren(""String_Node_Str"");
        if (step.getChild(""String_Node_Str"") != null) {
          String[] argsnew=new String[useargs.length + bits.size()];
          int i=0;
          for (          Element arg : bits) {
            argsnew[i++]=arg.getValue();
          }
          for (; i < bits.size() + useargs.length; i++) {
            argsnew[i]=useargs[i - bits.size()];
          }
          useargs=argsnew;
        }
        RequestService requestService=kernelImpl.getServiceManager().getServiceByName(RequestService.class.getName(),RequestService.class);
        if (requestService == null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        requestService.startRequest();
        try {
          Object[] arguments={useargs};
          Method main=target.getMethod(""String_Node_Str"",argTypes);
          Object output=main.invoke(null,arguments);
          requestService.endRequest(null);
        }
 catch (        Exception e) {
          requestService.endRequest(e);
          if (kernelImpl != null) {
            kernelImpl.destroy();
            kernelImpl=null;
          }
          System.err.println(""String_Node_Str"" + e.getMessage());
          System.exit(1);
        }
      }
      if (kernelImpl != null) {
        kernelImpl.destroy();
        kernelImpl=null;
      }
      System.exit(0);
    }
  }
  if (kernelImpl != null) {
    kernelImpl.destroy();
    kernelImpl=null;
  }
  System.err.println(""String_Node_Str"" + args[0]);
  display();
  System.exit(1);
}","/** 
 * Execute the DSpace script launcher
 * @param args Any parameters required to be passed to the scripts it executes
 * @throws Exception
 */
public static void main(String[] args){
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    display();
    System.exit(1);
  }
  try {
    kernelImpl=DSpaceKernelInit.getKernel(null);
    if (!kernelImpl.isRunning()) {
      kernelImpl.start(ConfigurationManager.getProperty(""String_Node_Str""));
    }
  }
 catch (  Exception e) {
    try {
      kernelImpl.destroy();
    }
 catch (    Exception e1) {
    }
    String message=""String_Node_Str"" + e.getMessage();
    System.err.println(message + ""String_Node_Str"" + e);
    throw new RuntimeException(message,e);
  }
  Document doc=getConfig();
  String request=args[0];
  Element root=doc.getRootElement();
  List<Element> commands=root.getChildren(""String_Node_Str"");
  for (  Element command : commands) {
    if (request.equalsIgnoreCase(command.getChild(""String_Node_Str"").getValue())) {
      List<Element> steps=command.getChildren(""String_Node_Str"");
      for (      Element step : steps) {
        Class target=null;
        String className=step.getChild(""String_Node_Str"").getValue();
        try {
          target=Class.forName(className,true,Thread.currentThread().getContextClassLoader());
        }
 catch (        ClassNotFoundException e) {
          System.err.println(""String_Node_Str"" + className);
          System.exit(1);
        }
        String[] useargs=args.clone();
        Class[] argTypes={useargs.getClass()};
        boolean passargs=true;
        if ((step.getAttribute(""String_Node_Str"") != null) && (""String_Node_Str"".equalsIgnoreCase(step.getAttribute(""String_Node_Str"").getValue()))) {
          passargs=false;
        }
        if ((args.length == 1) || (!passargs)) {
          useargs=new String[0];
        }
 else {
          String[] argsnew=new String[useargs.length - 1];
          for (int i=1; i < useargs.length; i++) {
            argsnew[i - 1]=useargs[i];
          }
          useargs=argsnew;
        }
        List<Element> bits=step.getChildren(""String_Node_Str"");
        if (step.getChild(""String_Node_Str"") != null) {
          String[] argsnew=new String[useargs.length + bits.size()];
          int i=0;
          for (          Element arg : bits) {
            argsnew[i++]=arg.getValue();
          }
          for (; i < bits.size() + useargs.length; i++) {
            argsnew[i]=useargs[i - bits.size()];
          }
          useargs=argsnew;
        }
        RequestService requestService=kernelImpl.getServiceManager().getServiceByName(RequestService.class.getName(),RequestService.class);
        if (requestService == null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        requestService.startRequest();
        try {
          Object[] arguments={useargs};
          Method main=target.getMethod(""String_Node_Str"",argTypes);
          Object output=main.invoke(null,arguments);
          requestService.endRequest(null);
        }
 catch (        Exception e) {
          requestService.endRequest(e);
          if (kernelImpl != null) {
            kernelImpl.destroy();
            kernelImpl=null;
          }
          Throwable cause=e.getCause();
          System.err.println(""String_Node_Str"" + cause.getMessage());
          cause.printStackTrace();
          System.exit(1);
        }
      }
      if (kernelImpl != null) {
        kernelImpl.destroy();
        kernelImpl=null;
      }
      System.exit(0);
    }
  }
  if (kernelImpl != null) {
    kernelImpl.destroy();
    kernelImpl=null;
  }
  System.err.println(""String_Node_Str"" + args[0]);
  display();
  System.exit(1);
}",0.9892619274160664
3283,"/** 
 * Write the actual data out to the response. Some implementation notes, 1) We set a short expires time just in the hopes of preventing someone from overloading the server by clicking reload a bunch of times. I realize that this is nowhere near 100% effective but it may help in some cases and shouldn't hurt anything. 2) We accept partial downloads, thus if you lose a connection half way through most web browser will enable you to resume downloading the bitstream.
 */
public void generate() throws IOException, SAXException, ProcessingException {
  if (this.bitstreamInputStream == null)   return;
  if (isSpider) {
    long modSince=request.getDateHeader(""String_Node_Str"");
    if (modSince != -1 && item.getLastModified().getTime() < modSince) {
      response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
      return;
    }
  }
  try {
    if (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null) {
      response.setDateHeader(""String_Node_Str"",item.getLastModified().getTime());
    }
  }
 catch (  SQLException e) {
    throw new ProcessingException(e);
  }
  byte[] buffer=new byte[BUFFER_SIZE];
  int length=-1;
  if (isAnonymouslyReadable)   response.setDateHeader(""String_Node_Str"",System.currentTimeMillis() + expires);
  int threshold=ConfigurationManager.getIntProperty(""String_Node_Str"");
  if (bitstreamSize > threshold && threshold != 0) {
    String name=bitstreamName;
    try {
      String agent=request.getHeader(""String_Node_Str"");
      if (agent != null && agent.contains(""String_Node_Str""))       name=URLEncoder.encode(name,""String_Node_Str"");
 else       if (agent != null && agent.contains(""String_Node_Str""))       name=MimeUtility.encodeText(name,""String_Node_Str"",""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException see) {
    }
    response.setHeader(""String_Node_Str"",""String_Node_Str"" + name);
  }
  String ranges=null;
  ByteRange byteRange=null;
  if (ranges != null) {
    try {
      ranges=ranges.substring(ranges.indexOf('=') + 1);
      byteRange=new ByteRange(ranges);
    }
 catch (    NumberFormatException e) {
      byteRange=null;
      if (response instanceof HttpResponse) {
        ((HttpResponse)response).setStatus(416);
      }
    }
  }
  if (byteRange != null) {
    String entityLength;
    String entityRange;
    if (this.bitstreamSize != -1) {
      entityLength=""String_Node_Str"" + this.bitstreamSize;
      entityRange=byteRange.intersection(new ByteRange(0,this.bitstreamSize)).toString();
    }
 else {
      entityLength=""String_Node_Str"";
      entityRange=byteRange.toString();
    }
    response.setHeader(""String_Node_Str"",entityRange + ""String_Node_Str"" + entityLength);
    if (response instanceof HttpResponse) {
      ((HttpResponse)response).setStatus(206);
    }
    int pos=0;
    int posEnd;
    while ((length=this.bitstreamInputStream.read(buffer)) > -1) {
      posEnd=pos + length - 1;
      ByteRange intersection=byteRange.intersection(new ByteRange(pos,posEnd));
      if (intersection != null) {
        out.write(buffer,(int)intersection.getStart() - pos,(int)intersection.length());
      }
      pos+=length;
    }
  }
 else {
    response.setHeader(""String_Node_Str"",String.valueOf(this.bitstreamSize));
    while ((length=this.bitstreamInputStream.read(buffer)) > -1) {
      out.write(buffer,0,length);
    }
    out.flush();
  }
}","/** 
 * Write the actual data out to the response. Some implementation notes, 1) We set a short expires time just in the hopes of preventing someone from overloading the server by clicking reload a bunch of times. I realize that this is nowhere near 100% effective but it may help in some cases and shouldn't hurt anything. 2) We accept partial downloads, thus if you lose a connection half way through most web browser will enable you to resume downloading the bitstream.
 */
public void generate() throws IOException, SAXException, ProcessingException {
  if (this.bitstreamInputStream == null)   return;
  if (isSpider) {
    long modSince=request.getDateHeader(""String_Node_Str"");
    if (modSince != -1 && item != null && item.getLastModified().getTime() < modSince) {
      response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
      return;
    }
  }
  try {
    if (item != null && (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null)) {
      response.setDateHeader(""String_Node_Str"",item.getLastModified().getTime());
    }
  }
 catch (  SQLException e) {
    throw new ProcessingException(e);
  }
  byte[] buffer=new byte[BUFFER_SIZE];
  int length=-1;
  if (isAnonymouslyReadable)   response.setDateHeader(""String_Node_Str"",System.currentTimeMillis() + expires);
  int threshold=ConfigurationManager.getIntProperty(""String_Node_Str"");
  if (bitstreamSize > threshold && threshold != 0) {
    String name=bitstreamName;
    try {
      String agent=request.getHeader(""String_Node_Str"");
      if (agent != null && agent.contains(""String_Node_Str""))       name=URLEncoder.encode(name,""String_Node_Str"");
 else       if (agent != null && agent.contains(""String_Node_Str""))       name=MimeUtility.encodeText(name,""String_Node_Str"",""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException see) {
    }
    response.setHeader(""String_Node_Str"",""String_Node_Str"" + name);
  }
  String ranges=null;
  ByteRange byteRange=null;
  if (ranges != null) {
    try {
      ranges=ranges.substring(ranges.indexOf('=') + 1);
      byteRange=new ByteRange(ranges);
    }
 catch (    NumberFormatException e) {
      byteRange=null;
      if (response instanceof HttpResponse) {
        ((HttpResponse)response).setStatus(416);
      }
    }
  }
  if (byteRange != null) {
    String entityLength;
    String entityRange;
    if (this.bitstreamSize != -1) {
      entityLength=""String_Node_Str"" + this.bitstreamSize;
      entityRange=byteRange.intersection(new ByteRange(0,this.bitstreamSize)).toString();
    }
 else {
      entityLength=""String_Node_Str"";
      entityRange=byteRange.toString();
    }
    response.setHeader(""String_Node_Str"",entityRange + ""String_Node_Str"" + entityLength);
    if (response instanceof HttpResponse) {
      ((HttpResponse)response).setStatus(206);
    }
    int pos=0;
    int posEnd;
    while ((length=this.bitstreamInputStream.read(buffer)) > -1) {
      posEnd=pos + length - 1;
      ByteRange intersection=byteRange.intersection(new ByteRange(pos,posEnd));
      if (intersection != null) {
        out.write(buffer,(int)intersection.getStart() - pos,(int)intersection.length());
      }
      pos+=length;
    }
  }
 else {
    response.setHeader(""String_Node_Str"",String.valueOf(this.bitstreamSize));
    while ((length=this.bitstreamInputStream.read(buffer)) > -1) {
      out.write(buffer,0,length);
    }
    out.flush();
  }
}",0.9949808089754946
3284,"/** 
 * Add a new eperson. This method will check that the email address,  first name, and last name are non empty. Also a check is preformed  to see if the requested email address is allready in use by another user.
 * @param context The current DSpace context
 * @param request The HTTP request parameters
 * @param objectModel Cocoon's object model
 * @return A process result's object.
 */
public static FlowResult processAddEPerson(Context context,Request request,Map objectModel) throws SQLException, AuthorizeException {
  FlowResult result=new FlowResult();
  result.setContinue(false);
  String email=request.getParameter(""String_Node_Str"");
  String first=request.getParameter(""String_Node_Str"");
  String last=request.getParameter(""String_Node_Str"");
  String phone=request.getParameter(""String_Node_Str"");
  boolean login=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  boolean certificate=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  if (email.length() == 0)   result.addError(""String_Node_Str"");
  if (first.length() == 0)   result.addError(""String_Node_Str"");
  if (last.length() == 0)   result.addError(""String_Node_Str"");
  EPerson potentialDupicate=EPerson.findByEmail(context,email);
  if (potentialDupicate != null) {
    result.addError(""String_Node_Str"");
  }
  if (result.getErrors() == null) {
    EPerson newPerson=AuthenticationUtil.createNewEperson(objectModel,email);
    newPerson.setFirstName(first);
    newPerson.setLastName(last);
    newPerson.setMetadata(""String_Node_Str"",phone);
    newPerson.setCanLogIn(login);
    newPerson.setRequireCertificate(certificate);
    newPerson.setSelfRegistered(false);
    newPerson.update();
    context.commit();
    result.setContinue(true);
    result.setOutcome(true);
    result.setMessage(T_add_eperson_success_notice);
    result.setParameter(""String_Node_Str"",newPerson.getID());
  }
  return result;
}","/** 
 * Add a new eperson. This method will check that the email address,  first name, and last name are non empty. Also a check is preformed  to see if the requested email address is allready in use by another user.
 * @param context The current DSpace context
 * @param request The HTTP request parameters
 * @param objectModel Cocoon's object model
 * @return A process result's object.
 */
public static FlowResult processAddEPerson(Context context,Request request,Map objectModel) throws SQLException, AuthorizeException {
  FlowResult result=new FlowResult();
  result.setContinue(false);
  String email=request.getParameter(""String_Node_Str"").trim();
  String first=request.getParameter(""String_Node_Str"").trim();
  String last=request.getParameter(""String_Node_Str"").trim();
  String phone=request.getParameter(""String_Node_Str"").trim();
  boolean login=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  boolean certificate=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  if (email.length() == 0)   result.addError(""String_Node_Str"");
  if (first.length() == 0)   result.addError(""String_Node_Str"");
  if (last.length() == 0)   result.addError(""String_Node_Str"");
  EPerson potentialDupicate=EPerson.findByEmail(context,email);
  if (potentialDupicate != null) {
    result.addError(""String_Node_Str"");
  }
  if (result.getErrors() == null) {
    EPerson newPerson=AuthenticationUtil.createNewEperson(objectModel,email);
    newPerson.setFirstName(first);
    newPerson.setLastName(last);
    newPerson.setMetadata(""String_Node_Str"",phone);
    newPerson.setCanLogIn(login);
    newPerson.setRequireCertificate(certificate);
    newPerson.setSelfRegistered(false);
    newPerson.update();
    context.commit();
    result.setContinue(true);
    result.setOutcome(true);
    result.setMessage(T_add_eperson_success_notice);
    result.setParameter(""String_Node_Str"",newPerson.getID());
  }
  return result;
}",0.9927797833935018
3285,"/** 
 * Compare changes between an items owning collections and what is in the CSV file
 * @param item The item in question
 * @param collections The collection handles fro mthe CSV file
 * @param actualCollections The Collections from the actual item
 * @param bechange The bulkedit change object for this item
 * @param change Whether or not to actuate a change
 * @throws SQLException if there is a problem accessing a Collection from the database, from its handle
 * @throws AuthorizeException if there is an authorization problem with permissions
 * @throws IOException Can be thrown when moving items in communities
 * @throws MetadataImportException If something goes wrong to be reported back to the user
 */
private void compare(Item item,ArrayList<String> collections,Collection[] actualCollections,BulkEditChange bechange,boolean change) throws SQLException, AuthorizeException, IOException, MetadataImportException {
  for (  String csvcollection : collections) {
    boolean found=false;
    for (    Collection collection : actualCollections) {
      if (csvcollection.equals(collection.getHandle())) {
        found=true;
      }
    }
    if (!found) {
      DSpaceObject dso=HandleManager.resolveToObject(c,csvcollection);
      if ((dso == null) || (dso.getType() != Constants.COLLECTION)) {
        throw new MetadataImportException(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ item.getHandle()+ ""String_Node_Str"");
      }
 else {
        Collection col=(Collection)dso;
        bechange.registerNewOwningCollection(col);
        if (change) {
          col.addItem(item);
        }
      }
    }
  }
  for (  Collection collection : actualCollections) {
    boolean found=false;
    for (    String csvcollection : collections) {
      if (collection.getHandle().equals(csvcollection)) {
        found=true;
      }
    }
    if (!found) {
      bechange.registerOldOwningCollection(collection);
      if (change) {
        if (item.getCollections().length > 1) {
          collection.removeItem(item);
        }
 else {
          throw new MetadataImportException(""String_Node_Str"" + item.getHandle() + ""String_Node_Str""+ collection.getHandle()+ ""String_Node_Str"");
        }
      }
    }
  }
}","/** 
 * Compare changes between an items owning collections and what is in the CSV file
 * @param item The item in question
 * @param collections The collection handles fro mthe CSV file
 * @param actualCollections The Collections from the actual item
 * @param bechange The bulkedit change object for this item
 * @param change Whether or not to actuate a change
 * @throws SQLException if there is a problem accessing a Collection from the database, from its handle
 * @throws AuthorizeException if there is an authorization problem with permissions
 * @throws IOException Can be thrown when moving items in communities
 * @throws MetadataImportException If something goes wrong to be reported back to the user
 */
private void compare(Item item,ArrayList<String> collections,Collection[] actualCollections,BulkEditChange bechange,boolean change) throws SQLException, AuthorizeException, IOException, MetadataImportException {
  for (  String csvcollection : collections) {
    boolean found=false;
    for (    Collection collection : actualCollections) {
      if (csvcollection.equals(collection.getHandle())) {
        found=true;
      }
    }
    if (!found) {
      DSpaceObject dso=HandleManager.resolveToObject(c,csvcollection);
      if ((dso == null) || (dso.getType() != Constants.COLLECTION)) {
        throw new MetadataImportException(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ item.getHandle()+ ""String_Node_Str"");
      }
 else {
        Collection col=(Collection)dso;
        bechange.registerNewOwningCollection(col);
        if (change) {
          col.addItem(item);
        }
      }
    }
  }
  for (  Collection collection : actualCollections) {
    boolean found=false;
    for (    String csvcollection : collections) {
      if (collection.getHandle().equals(csvcollection)) {
        found=true;
      }
    }
    if (!found) {
      bechange.registerOldOwningCollection(collection);
      if (change) {
        if (item.getCollections().length > 1) {
          collection.removeItem(item);
        }
 else {
          throw new MetadataImportException(""String_Node_Str"" + item.getHandle() + ""String_Node_Str""+ collection.getHandle()+ ""String_Node_Str"");
        }
      }
    }
  }
  if ((change) && (!collections.get(0).equals(item.getOwningCollection().getHandle()))) {
    Collection owner=(Collection)HandleManager.resolveToObject(c,collections.get(0));
    item.setOwningCollection(Collection.find(c,owner.getID()));
    item.update();
  }
}",0.944220572640509
3286,"/** 
 * Compare changes between an items owning collections and what is in the CSV file
 * @param item The item in question
 * @param collections The collection handles fro mthe CSV file
 * @param actualCollections The Collections from the actual item
 * @param bechange The bulkedit change object for this item
 * @param change Whether or not to actuate a change
 * @throws SQLException if there is a problem accessing a Collection from the database, from its handle
 * @throws AuthorizeException if there is an authorization problem with permissions
 * @throws IOException Can be thrown when moving items in communities 
 */
private void compare(Item item,ArrayList<String> collections,Collection[] actualCollections,BulkEditChange bechange,boolean change) throws SQLException, AuthorizeException, IOException, MetadataImportException {
  for (  String csvcollection : collections) {
    boolean found=false;
    for (    Collection collection : actualCollections) {
      if (csvcollection.equals(collection.getHandle())) {
        found=true;
      }
    }
    if (!found) {
      DSpaceObject dso=HandleManager.resolveToObject(c,csvcollection);
      if ((dso == null) || (dso.getType() != Constants.COLLECTION)) {
        throw new MetadataImportException(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ item.getHandle()+ ""String_Node_Str"");
      }
 else {
        Collection col=(Collection)dso;
        bechange.registerNewOwningCollection(col);
        if (change) {
          col.addItem(item);
        }
      }
    }
  }
  for (  Collection collection : actualCollections) {
    boolean found=false;
    for (    String csvcollection : collections) {
      if (collection.getHandle().equals(csvcollection)) {
        found=true;
      }
    }
    if (!found) {
      bechange.registerOldOwningCollection(collection);
      if (change) {
        if (item.getCollections().length > 1) {
          collection.removeItem(item);
        }
 else {
          throw new MetadataImportException(""String_Node_Str"" + item.getHandle() + ""String_Node_Str""+ collection.getHandle()+ ""String_Node_Str"");
        }
      }
    }
  }
}","/** 
 * Compare changes between an items owning collections and what is in the CSV file
 * @param item The item in question
 * @param collections The collection handles fro mthe CSV file
 * @param actualCollections The Collections from the actual item
 * @param bechange The bulkedit change object for this item
 * @param change Whether or not to actuate a change
 * @throws SQLException if there is a problem accessing a Collection from the database, from its handle
 * @throws AuthorizeException if there is an authorization problem with permissions
 * @throws IOException Can be thrown when moving items in communities
 * @throws MetadataImportException If something goes wrong to be reported back to the user
 */
private void compare(Item item,ArrayList<String> collections,Collection[] actualCollections,BulkEditChange bechange,boolean change) throws SQLException, AuthorizeException, IOException, MetadataImportException {
  for (  String csvcollection : collections) {
    boolean found=false;
    for (    Collection collection : actualCollections) {
      if (csvcollection.equals(collection.getHandle())) {
        found=true;
      }
    }
    if (!found) {
      DSpaceObject dso=HandleManager.resolveToObject(c,csvcollection);
      if ((dso == null) || (dso.getType() != Constants.COLLECTION)) {
        throw new MetadataImportException(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ item.getHandle()+ ""String_Node_Str"");
      }
 else {
        Collection col=(Collection)dso;
        bechange.registerNewOwningCollection(col);
        if (change) {
          col.addItem(item);
        }
      }
    }
  }
  for (  Collection collection : actualCollections) {
    boolean found=false;
    for (    String csvcollection : collections) {
      if (collection.getHandle().equals(csvcollection)) {
        found=true;
      }
    }
    if (!found) {
      bechange.registerOldOwningCollection(collection);
      if (change) {
        if (item.getCollections().length > 1) {
          collection.removeItem(item);
        }
 else {
          throw new MetadataImportException(""String_Node_Str"" + item.getHandle() + ""String_Node_Str""+ collection.getHandle()+ ""String_Node_Str"");
        }
      }
    }
  }
}",0.9789087574507108
3287,"/** 
 * Run an import. The import can either be read-only to detect changes, or can write changes as it goes.
 * @param change Whether or not to write the changes to the database
 * @param useWorkflow Whether the workflows should be used when creating new items
 * @param workflowNotify If the workflows should be used, whether to send notifications or not
 * @param useTemplate Use collection template if create new item
 * @return An array of BulkEditChange elements representing the items that have changed
 * @throws MetadataImportException if something goes wrong
 */
public ArrayList<BulkEditChange> runImport(boolean change,boolean useWorkflow,boolean workflowNotify,boolean useTemplate) throws MetadataImportException {
  ArrayList<BulkEditChange> changes=new ArrayList<BulkEditChange>();
  try {
    for (    DSpaceCSVLine line : toImport) {
      int id=line.getID();
      if (id != -1) {
        Item item=Item.find(c,id);
        BulkEditChange whatHasChanged=new BulkEditChange(item);
        ArrayList<String> collections=line.get(""String_Node_Str"");
        if (collections != null) {
          if (collections.size() == 0) {
            throw new MetadataImportException(""String_Node_Str"" + item.getHandle());
          }
          Collection[] actualCollections=item.getCollections();
          compare(item,collections,actualCollections,whatHasChanged,change);
        }
        Enumeration<String> e=line.keys();
        while (e.hasMoreElements()) {
          String md=e.nextElement();
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            compare(item,fromCSV,change,md,whatHasChanged);
          }
        }
        if (whatHasChanged.hasChanges()) {
          changes.add(whatHasChanged);
        }
      }
 else {
        if (c.getCurrentUser() == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        Enumeration<String> e=line.keys();
        BulkEditChange whatHasChanged=new BulkEditChange();
        while (e.hasMoreElements()) {
          String md=e.nextElement();
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            add(fromCSV,md,whatHasChanged);
          }
        }
        if (line.get(""String_Node_Str"") == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        ArrayList<String> collections=line.get(""String_Node_Str"");
        ArrayList<Collection> check=new ArrayList<Collection>();
        for (int i=0; i < collections.size(); i++) {
          String handle=collections.get(i);
          Collection collection;
          try {
            collection=(Collection)HandleManager.resolveToObject(c,handle);
            if (check.contains(collection)) {
              throw new MetadataImportException(""String_Node_Str"" + handle);
            }
 else {
              check.add(collection);
            }
          }
 catch (          Exception ex) {
            throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"");
          }
        }
        for (int i=0; i < collections.size(); i++) {
          String handle=collections.get(i);
          Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
          whatHasChanged.registerNewOwningCollection(extra);
        }
        if (change) {
          String collectionHandle=line.get(""String_Node_Str"").get(0);
          Collection collection=(Collection)HandleManager.resolveToObject(c,collectionHandle);
          WorkspaceItem wsItem=WorkspaceItem.create(c,collection,useTemplate);
          Item item=wsItem.getItem();
          for (          DCValue dcv : whatHasChanged.getAdds()) {
            item.addMetadata(dcv.schema,dcv.element,dcv.qualifier,dcv.language,dcv.value);
          }
          if ((useWorkflow) && (workflowNotify)) {
            WorkflowManager.start(c,wsItem);
          }
 else           if (useWorkflow) {
            WorkflowManager.startWithoutNotify(c,wsItem);
          }
 else {
            InstallItem.installItem(c,wsItem);
          }
          if (line.get(""String_Node_Str"").size() > 0) {
            for (int i=1; i < collections.size(); i++) {
              String handle=collections.get(i);
              Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
              extra.addItem(item);
            }
          }
          c.commit();
          whatHasChanged.setItem(item);
        }
        changes.add(whatHasChanged);
      }
    }
  }
 catch (  MetadataImportException mie) {
    throw mie;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return changes;
}","/** 
 * Run an import. The import can either be read-only to detect changes, or can write changes as it goes.
 * @param change Whether or not to write the changes to the database
 * @param useWorkflow Whether the workflows should be used when creating new items
 * @param workflowNotify If the workflows should be used, whether to send notifications or not
 * @param useTemplate Use collection template if create new item
 * @return An array of BulkEditChange elements representing the items that have changed
 * @throws MetadataImportException if something goes wrong
 */
public ArrayList<BulkEditChange> runImport(boolean change,boolean useWorkflow,boolean workflowNotify,boolean useTemplate) throws MetadataImportException {
  ArrayList<BulkEditChange> changes=new ArrayList<BulkEditChange>();
  try {
    for (    DSpaceCSVLine line : toImport) {
      int id=line.getID();
      if (id != -1) {
        Item item=Item.find(c,id);
        BulkEditChange whatHasChanged=new BulkEditChange(item);
        ArrayList<String> collections=line.get(""String_Node_Str"");
        if (collections != null) {
          if (collections.size() == 0) {
            throw new MetadataImportException(""String_Node_Str"" + item.getHandle());
          }
          Collection[] actualCollections=item.getCollections();
          compare(item,collections,actualCollections,whatHasChanged,change);
        }
        Enumeration<String> e=line.keys();
        while (e.hasMoreElements()) {
          String md=e.nextElement();
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            compare(item,fromCSV,change,md,whatHasChanged);
          }
        }
        if (whatHasChanged.hasChanges()) {
          changes.add(whatHasChanged);
        }
      }
 else {
        if (c.getCurrentUser() == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        Enumeration<String> e=line.keys();
        BulkEditChange whatHasChanged=new BulkEditChange();
        while (e.hasMoreElements()) {
          String md=e.nextElement();
          if (!""String_Node_Str"".equals(md)) {
            String[] fromCSV=line.get(md).toArray(new String[line.get(md).size()]);
            add(fromCSV,md,whatHasChanged);
          }
        }
        ArrayList<String> collections=line.get(""String_Node_Str"");
        if (collections == null) {
          throw new MetadataImportException(""String_Node_Str"");
        }
        ArrayList<Collection> check=new ArrayList<Collection>();
        Collection collection;
        for (        String handle : collections) {
          try {
            collection=(Collection)HandleManager.resolveToObject(c,handle);
            if (collection == null) {
              throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"");
            }
            if (check.contains(collection)) {
              throw new MetadataImportException(""String_Node_Str"" + handle);
            }
 else {
              check.add(collection);
            }
          }
 catch (          Exception ex) {
            throw new MetadataImportException(""String_Node_Str"" + handle + ""String_Node_Str"");
          }
        }
        for (        String handle : collections) {
          Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
          whatHasChanged.registerNewOwningCollection(extra);
        }
        if (change) {
          String collectionHandle=line.get(""String_Node_Str"").get(0);
          collection=(Collection)HandleManager.resolveToObject(c,collectionHandle);
          WorkspaceItem wsItem=WorkspaceItem.create(c,collection,useTemplate);
          Item item=wsItem.getItem();
          for (          DCValue dcv : whatHasChanged.getAdds()) {
            item.addMetadata(dcv.schema,dcv.element,dcv.qualifier,dcv.language,dcv.value);
          }
          if ((useWorkflow) && (workflowNotify)) {
            WorkflowManager.start(c,wsItem);
          }
 else           if (useWorkflow) {
            WorkflowManager.startWithoutNotify(c,wsItem);
          }
 else {
            InstallItem.installItem(c,wsItem);
          }
          if (line.get(""String_Node_Str"").size() > 0) {
            for (int i=1; i < collections.size(); i++) {
              String handle=collections.get(i);
              Collection extra=(Collection)HandleManager.resolveToObject(c,handle);
              extra.addItem(item);
            }
          }
          c.commit();
          whatHasChanged.setItem(item);
        }
        changes.add(whatHasChanged);
      }
    }
  }
 catch (  MetadataImportException mie) {
    throw mie;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return changes;
}",0.910759493670886
3288,"/** 
 * main method to run the metadata exporter
 * @param argv the command line arguments given
 * @throws Exception Thrown if something goes wrong with the import
 */
public static void main(String[] argv){
  CommandLineParser parser=new PosixParser();
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  CommandLine line;
  try {
    line=parser.parse(options,argv);
  }
 catch (  ParseException pe) {
    System.err.println(""String_Node_Str"" + pe.getMessage());
    System.exit(1);
    return;
  }
  if (line.hasOption('h')) {
    printHelp(options,0);
  }
  if (!line.hasOption('f')) {
    System.err.println(""String_Node_Str"");
    printHelp(options,1);
  }
  String filename=line.getOptionValue('f');
  boolean useTemplate=false;
  if (line.hasOption('t')) {
    useTemplate=true;
  }
  boolean useWorkflow=false;
  boolean workflowNotify=false;
  if (line.hasOption('w')) {
    useWorkflow=true;
    if (line.hasOption('n')) {
      workflowNotify=true;
    }
  }
 else   if (line.hasOption('n')) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  Context c;
  try {
    c=new Context();
    c.turnOffAuthorisationSystem();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  try {
    if (line.hasOption('e')) {
      EPerson eperson=null;
      String e=line.getOptionValue('e');
      if (e.indexOf('@') != -1) {
        eperson=EPerson.findByEmail(c,e);
      }
 else {
        eperson=EPerson.find(c,Integer.parseInt(e));
      }
      if (eperson == null) {
        System.out.println(""String_Node_Str"" + e);
        System.exit(1);
      }
      c.setCurrentUser(eperson);
    }
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  boolean change=false;
  DSpaceCSV csv;
  try {
    csv=new DSpaceCSV(new File(filename));
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  MetadataImport importer=new MetadataImport(c,csv.getCSVLines());
  ArrayList<BulkEditChange> changes;
  if (!line.hasOption('s')) {
    try {
      changes=importer.runImport(false,useWorkflow,workflowNotify,useTemplate);
    }
 catch (    MetadataImportException mie) {
      System.err.println(""String_Node_Str"" + mie.getMessage());
      System.exit(1);
      return;
    }
    int changeCounter=displayChanges(changes,false);
    if (changeCounter > 0) {
      try {
        System.out.println(""String_Node_Str"" + changeCounter + ""String_Node_Str"");
        System.out.print(""String_Node_Str"");
        String yn=(new BufferedReader(new InputStreamReader(System.in))).readLine();
        if (""String_Node_Str"".equalsIgnoreCase(yn)) {
          change=true;
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      IOException ioe) {
        System.err.println(""String_Node_Str"" + ioe.getMessage());
        System.err.println(""String_Node_Str"");
        System.exit(1);
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    change=true;
  }
  try {
    if (change) {
      try {
        changes=importer.runImport(true,useWorkflow,workflowNotify,useTemplate);
      }
 catch (      MetadataImportException mie) {
        System.err.println(""String_Node_Str"" + mie.getMessage());
        System.exit(1);
        return;
      }
      displayChanges(changes,true);
      c.commit();
    }
    c.restoreAuthSystemState();
    c.complete();
  }
 catch (  Exception e) {
    c.abort();
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
}","/** 
 * main method to run the metadata exporter
 * @param argv the command line arguments given
 */
public static void main(String[] argv){
  CommandLineParser parser=new PosixParser();
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  CommandLine line;
  try {
    line=parser.parse(options,argv);
  }
 catch (  ParseException pe) {
    System.err.println(""String_Node_Str"" + pe.getMessage());
    System.exit(1);
    return;
  }
  if (line.hasOption('h')) {
    printHelp(options,0);
  }
  if (!line.hasOption('f')) {
    System.err.println(""String_Node_Str"");
    printHelp(options,1);
  }
  String filename=line.getOptionValue('f');
  boolean useTemplate=false;
  if (line.hasOption('t')) {
    useTemplate=true;
  }
  boolean useWorkflow=false;
  boolean workflowNotify=false;
  if (line.hasOption('w')) {
    useWorkflow=true;
    if (line.hasOption('n')) {
      workflowNotify=true;
    }
  }
 else   if (line.hasOption('n')) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  Context c;
  try {
    c=new Context();
    c.turnOffAuthorisationSystem();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  try {
    if (line.hasOption('e')) {
      EPerson eperson;
      String e=line.getOptionValue('e');
      if (e.indexOf('@') != -1) {
        eperson=EPerson.findByEmail(c,e);
      }
 else {
        eperson=EPerson.find(c,Integer.parseInt(e));
      }
      if (eperson == null) {
        System.out.println(""String_Node_Str"" + e);
        System.exit(1);
      }
      c.setCurrentUser(eperson);
    }
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  boolean change=false;
  DSpaceCSV csv;
  try {
    csv=new DSpaceCSV(new File(filename));
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(1);
    return;
  }
  MetadataImport importer=new MetadataImport(c,csv.getCSVLines());
  ArrayList<BulkEditChange> changes;
  if (!line.hasOption('s')) {
    try {
      changes=importer.runImport(false,useWorkflow,workflowNotify,useTemplate);
    }
 catch (    MetadataImportException mie) {
      System.err.println(""String_Node_Str"" + mie.getMessage());
      System.exit(1);
      return;
    }
    int changeCounter=displayChanges(changes,false);
    if (changeCounter > 0) {
      try {
        System.out.println(""String_Node_Str"" + changeCounter + ""String_Node_Str"");
        System.out.print(""String_Node_Str"");
        String yn=(new BufferedReader(new InputStreamReader(System.in))).readLine();
        if (""String_Node_Str"".equalsIgnoreCase(yn)) {
          change=true;
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
 catch (      IOException ioe) {
        System.err.println(""String_Node_Str"" + ioe.getMessage());
        System.err.println(""String_Node_Str"");
        System.exit(1);
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    change=true;
  }
  try {
    if (change) {
      try {
        changes=importer.runImport(true,useWorkflow,workflowNotify,useTemplate);
      }
 catch (      MetadataImportException mie) {
        System.err.println(""String_Node_Str"" + mie.getMessage());
        System.exit(1);
        return;
      }
      displayChanges(changes,true);
      c.commit();
    }
    c.restoreAuthSystemState();
    c.complete();
  }
 catch (  Exception e) {
    c.abort();
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
}",0.9913945538135094
3289,"public void addBody(Body body) throws WingException {
  Division updated=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  updated.setHead(T_head);
  updated.addPara(T_para1);
  updated.addPara().addXref(contextPath,T_go_home);
}","public void addBody(Body body) throws WingException {
  Division updated=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  updated.setHead(T_head);
  updated.addPara(T_para1);
  updated.addPara().addXref(contextPath + ""String_Node_Str"",T_go_home);
}",0.959349593495935
3290,"/** 
 * Interpret named event type.
 * @param text name of event type.
 * @returns numeric value of event type or 0 for error.
 */
public static int parseEventType(String s){
  if (s.equals(""String_Node_Str"") | s.equalsIgnoreCase(""String_Node_Str"")) {
    int result=0;
    for (int i=0; i < eventTypeText.length; ++i)     result|=(1 << i);
    return result;
  }
  for (int i=0; i < eventTypeText.length; ++i)   if (eventTypeText[i].equalsIgnoreCase(s))   return 1 << i;
  return 0;
}","/** 
 * Interpret named event type.
 * @param text name of event type.
 * @returns numeric value of event type or 0 for error.
 */
public static int parseEventType(String s){
  if (""String_Node_Str"".equals(s) || ""String_Node_Str"".equalsIgnoreCase(s)) {
    int result=0;
    for (int i=0; i < eventTypeText.length; ++i)     result|=(1 << i);
    return result;
  }
  for (int i=0; i < eventTypeText.length; ++i)   if (eventTypeText[i].equalsIgnoreCase(s))   return 1 << i;
  return 0;
}",0.9392378990731204
3291,"/** 
 * Translate a textual DSpace Object type name into an event subject-type mask. NOTE: This returns a BIT-MASK, not a numeric type value; the mask is only used within the event system.
 * @param s text name of object type.
 * @returns numeric value of object type or 0 for error.
 */
public static int parseObjectType(String s){
  if (s.equals(""String_Node_Str"") | s.equalsIgnoreCase(""String_Node_Str""))   return ALL_OBJECTS_MASK;
 else {
    int id=Constants.getTypeID(s.toUpperCase());
    if (id >= 0)     return 1 << id;
  }
  return 0;
}","/** 
 * Translate a textual DSpace Object type name into an event subject-type mask. NOTE: This returns a BIT-MASK, not a numeric type value; the mask is only used within the event system.
 * @param s text name of object type.
 * @returns numeric value of object type or 0 for error.
 */
public static int parseObjectType(String s){
  if (""String_Node_Str"".equals(s) || ""String_Node_Str"".equalsIgnoreCase(s))   return ALL_OBJECTS_MASK;
 else {
    int id=Constants.getTypeID(s.toUpperCase());
    if (id >= 0)     return 1 << id;
  }
  return 0;
}",0.9460201280878316
3292,"private void sendFile(HttpServletRequest request,HttpServletResponse response,String file,String mimeType,boolean compressed) throws ServletException, IOException {
  File f=new File(ConfigurationManager.getProperty(""String_Node_Str""),file);
  if (!f.exists()) {
    response.setStatus(HttpServletResponse.SC_NOT_FOUND);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  long lastMod=f.lastModified();
  response.setDateHeader(""String_Node_Str"",lastMod);
  long modSince=request.getDateHeader(""String_Node_Str"");
  if (modSince != -1 && lastMod < modSince) {
    response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
    return;
  }
  if (compressed) {
    response.setHeader(""String_Node_Str"",""String_Node_Str"");
  }
  InputStream is=new FileInputStream(f);
  response.setContentType(mimeType);
  response.setHeader(""String_Node_Str"",String.valueOf(f.length()));
  Utils.bufferedCopy(is,response.getOutputStream());
  is.close();
  response.getOutputStream().flush();
}","private void sendFile(HttpServletRequest request,HttpServletResponse response,String file,String mimeType,boolean compressed) throws ServletException, IOException {
  File f=new File(ConfigurationManager.getProperty(""String_Node_Str""),file);
  if (!f.exists()) {
    response.setStatus(HttpServletResponse.SC_NOT_FOUND);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  long lastMod=f.lastModified();
  response.setDateHeader(""String_Node_Str"",lastMod);
  long modSince=request.getDateHeader(""String_Node_Str"");
  if (modSince != -1 && lastMod < modSince) {
    response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
    return;
  }
  if (compressed) {
    response.setHeader(""String_Node_Str"",""String_Node_Str"");
  }
  InputStream is=new FileInputStream(f);
  try {
    response.setContentType(mimeType);
    response.setHeader(""String_Node_Str"",String.valueOf(f.length()));
    Utils.bufferedCopy(is,response.getOutputStream());
  }
  finally {
    is.close();
  }
  response.getOutputStream().flush();
}",0.9823356231599608
3293,"/** 
 * Implement WebDAV PUT http request. This might be simpler with a real HTTP client library, but java.net.HttpURLConnection is part of the standard SDK and it demonstrates the concepts.
 * @param lni the lni
 * @param collHandle the coll handle
 * @param packager the packager
 * @param source the source
 * @param endpoint the endpoint
 * @throws RemoteException the remote exception
 * @throws ProtocolException the protocol exception
 * @throws IOException Signals that an I/O exception has occurred.
 * @throws FileNotFoundException the file not found exception
 */
private static void doPut(LNISoapServlet lni,String collHandle,String packager,String source,String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {
  String collURI=doLookup(lni,collHandle,null);
  URL url=LNIClientUtils.makeDAVURL(endpoint,collURI,packager);
  System.err.println(""String_Node_Str"" + source + ""String_Node_Str""+ url.toString());
  HttpURLConnection conn=(HttpURLConnection)url.openConnection();
  conn.setRequestMethod(""String_Node_Str"");
  conn.setDoOutput(true);
  fixBasicAuth(url,conn);
  conn.connect();
  InputStream in=new FileInputStream(source);
  OutputStream out=conn.getOutputStream();
  copyStream(in,out);
  in.close();
  out.close();
  int status=conn.getResponseCode();
  if (status < 200 || status >= 300) {
    die(status,""String_Node_Str"" + String.valueOf(status) + ""String_Node_Str""+ conn.getResponseMessage());
  }
  System.err.println(""String_Node_Str"" + source);
  System.err.println(""String_Node_Str"" + String.valueOf(conn.getResponseCode()) + ""String_Node_Str""+ conn.getResponseMessage());
  String loc=conn.getHeaderField(""String_Node_Str"");
  System.err.println(""String_Node_Str"" + ((loc == null) ? ""String_Node_Str"" : loc));
}","/** 
 * Implement WebDAV PUT http request. This might be simpler with a real HTTP client library, but java.net.HttpURLConnection is part of the standard SDK and it demonstrates the concepts.
 * @param lni the lni
 * @param collHandle the coll handle
 * @param packager the packager
 * @param source the source
 * @param endpoint the endpoint
 * @throws RemoteException the remote exception
 * @throws ProtocolException the protocol exception
 * @throws IOException Signals that an I/O exception has occurred.
 * @throws FileNotFoundException the file not found exception
 */
private static void doPut(LNISoapServlet lni,String collHandle,String packager,String source,String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {
  String collURI=doLookup(lni,collHandle,null);
  URL url=LNIClientUtils.makeDAVURL(endpoint,collURI,packager);
  System.err.println(""String_Node_Str"" + source + ""String_Node_Str""+ url.toString());
  HttpURLConnection conn=(HttpURLConnection)url.openConnection();
  conn.setRequestMethod(""String_Node_Str"");
  conn.setDoOutput(true);
  fixBasicAuth(url,conn);
  conn.connect();
  InputStream in=new FileInputStream(source);
  OutputStream out=conn.getOutputStream();
  try {
    copyStream(in,out);
  }
  finally {
    in.close();
    out.close();
  }
  int status=conn.getResponseCode();
  if (status < 200 || status >= 300) {
    die(status,""String_Node_Str"" + String.valueOf(status) + ""String_Node_Str""+ conn.getResponseMessage());
  }
  System.err.println(""String_Node_Str"" + source);
  System.err.println(""String_Node_Str"" + String.valueOf(conn.getResponseCode()) + ""String_Node_Str""+ conn.getResponseMessage());
  String loc=conn.getHeaderField(""String_Node_Str"");
  System.err.println(""String_Node_Str"" + ((loc == null) ? ""String_Node_Str"" : loc));
}",0.9889746416758544
3294,"/** 
 * Sets the cause1 value for this LNIRemoteException.
 * @param cause1
 */
public void setCause1(java.lang.Object cause1){
  this.cause1=cause1;
}","/** 
 * Sets the cause1 value for this LNIRemoteException.
 * @param cause1
 */
public synchronized void setCause1(java.lang.Object cause1){
  this.cause1=cause1;
}",0.9587301587301588
3295,"public synchronized boolean equals(java.lang.Object obj){
  if (!(obj instanceof LNIRemoteException))   return false;
  LNIRemoteException other=(LNIRemoteException)obj;
  if (obj == null)   return false;
  if (this == obj)   return true;
  if (__equalsCalc != null) {
    return (__equalsCalc == obj);
  }
  __equalsCalc=obj;
  boolean _equals;
  _equals=true && ((this.cause1 == null && other.getCause1() == null) || (this.cause1 != null && this.cause1.equals(other.getCause1()))) && ((this.message1 == null && other.getMessage1() == null) || (this.message1 != null && this.message1.equals(other.getMessage1())));
  __equalsCalc=null;
  return _equals;
}","public synchronized boolean equals(java.lang.Object obj){
  if (!(obj instanceof LNIRemoteException))   return false;
  LNIRemoteException other=(LNIRemoteException)obj;
  if (this == obj)   return true;
  if (__equalsCalc != null) {
    return (__equalsCalc == obj);
  }
  __equalsCalc=obj;
  boolean _equals;
  _equals=true && ((this.cause1 == null && other.getCause1() == null) || (this.cause1 != null && this.cause1.equals(other.getCause1()))) && ((this.message1 == null && other.getMessage1() == null) || (this.message1 != null && this.message1.equals(other.getMessage1())));
  __equalsCalc=null;
  return _equals;
}",0.9725920125293656
3296,"/** 
 * Gets the cause1 value for this LNIRemoteException.
 * @return cause1
 */
public java.lang.Object getCause1(){
  return cause1;
}","/** 
 * Gets the cause1 value for this LNIRemoteException.
 * @return cause1
 */
public synchronized java.lang.Object getCause1(){
  return cause1;
}",0.9543859649122808
3297,"/** 
 * Sets the message1 value for this LNIRemoteException.
 * @param message1
 */
public void setMessage1(java.lang.String message1){
  this.message1=message1;
}","/** 
 * Sets the message1 value for this LNIRemoteException.
 * @param message1
 */
public synchronized void setMessage1(java.lang.String message1){
  this.message1=message1;
}",0.9616519174041298
3298,"/** 
 * Gets the message1 value for this LNIRemoteException.
 * @return message1
 */
public java.lang.String getMessage1(){
  return message1;
}","/** 
 * Gets the message1 value for this LNIRemoteException.
 * @return message1
 */
public synchronized java.lang.String getMessage1(){
  return message1;
}",0.956810631229236
3299,"/** 
 * @param elements
 * @param attributes
 * @return
 */
protected SwordValidationInfo validate(SwordValidationInfo info,Properties validationContext){
  if (errorURI == null) {
    info.addValidationInfo(new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME,SwordValidationInfo.MISSING_ATTRIBUTE_WARNING,SwordValidationInfoType.WARNING));
  }
 else {
    boolean validUri=true;
    if (errorURI.startsWith(""String_Node_Str"")) {
      if (!(errorURI.equals(ErrorCodes.ERROR_CONTENT) | errorURI.equals(ErrorCodes.ERROR_CHECKSUM_MISMATCH) | errorURI.equals(ErrorCodes.ERROR_BAD_REQUEST)| errorURI.equals(ErrorCodes.TARGET_OWNER_UKNOWN)| errorURI.equals(ErrorCodes.MEDIATION_NOT_ALLOWED))) {
        info.addValidationInfo(new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME,""String_Node_Str"",SwordValidationInfoType.ERROR));
        validUri=false;
      }
    }
    if (validUri) {
      SwordValidationInfo item=new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME);
      item.setContentDescription(errorURI);
      info.addAttributeValidationInfo(item);
    }
  }
  return info;
}","/** 
 * @param elements
 * @param attributes
 * @return
 */
protected SwordValidationInfo validate(SwordValidationInfo info,Properties validationContext){
  if (errorURI == null) {
    info.addValidationInfo(new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME,SwordValidationInfo.MISSING_ATTRIBUTE_WARNING,SwordValidationInfoType.WARNING));
  }
 else {
    boolean validUri=true;
    if (errorURI.startsWith(""String_Node_Str"")) {
      if (!(errorURI.equals(ErrorCodes.ERROR_CONTENT) || errorURI.equals(ErrorCodes.ERROR_CHECKSUM_MISMATCH) || errorURI.equals(ErrorCodes.ERROR_BAD_REQUEST)|| errorURI.equals(ErrorCodes.TARGET_OWNER_UKNOWN)|| errorURI.equals(ErrorCodes.MEDIATION_NOT_ALLOWED))) {
        info.addValidationInfo(new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME,""String_Node_Str"",SwordValidationInfoType.ERROR));
        validUri=false;
      }
    }
    if (validUri) {
      SwordValidationInfo item=new SwordValidationInfo(xmlName,ATTRIBUTE_HREF_NAME);
      item.setContentDescription(errorURI);
      info.addAttributeValidationInfo(item);
    }
  }
  return info;
}",0.9981549815498156
3300,"/** 
 * Process a post request.
 */
protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  Deposit d=new Deposit();
  Date date=new Date();
  log.debug(""String_Node_Str"" + date.toString() + ""String_Node_Str""+ request.getRemoteAddr());
  String usernamePassword=getUsernamePassword(request);
  if ((usernamePassword != null) && (!usernamePassword.equals(""String_Node_Str""))) {
    int p=usernamePassword.indexOf(""String_Node_Str"");
    if (p != -1) {
      d.setUsername(usernamePassword.substring(0,p));
      d.setPassword(usernamePassword.substring(p + 1));
    }
  }
 else   if (authenticateWithBasic()) {
    String s=""String_Node_Str"";
    response.setHeader(""String_Node_Str"",s);
    response.setStatus(401);
    return;
  }
  String filename=null;
  File f=null;
  FileInputStream fis=null;
  try {
    filename=tempDirectory + ""String_Node_Str"" + request.getRemoteAddr()+ ""String_Node_Str""+ counter.addAndGet(1);
    InputStream inputStream=request.getInputStream();
    OutputStream outputStream=new FileOutputStream(filename);
    int data;
    while ((data=inputStream.read()) != -1) {
      outputStream.write(data);
    }
    inputStream.close();
    outputStream.close();
    File file=new File(filename);
    long fLength=file.length() / 1024;
    if ((maxUploadSize != -1) && (fLength > maxUploadSize)) {
      this.makeErrorDocument(ErrorCodes.MAX_UPLOAD_SIZE_EXCEEDED,HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE,""String_Node_Str"" + fLength + ""String_Node_Str""+ maxUploadSize+ ""String_Node_Str"",request,response);
      return;
    }
    String receivedMD5=ChecksumUtils.generateMD5(filename);
    log.debug(""String_Node_Str"" + receivedMD5);
    d.setMd5(receivedMD5);
    String md5=request.getHeader(""String_Node_Str"");
    log.debug(""String_Node_Str"" + md5);
    if ((md5 != null) && (!md5.equals(receivedMD5))) {
      this.makeErrorDocument(ErrorCodes.ERROR_CHECKSUM_MISMATCH,HttpServletResponse.SC_PRECONDITION_FAILED,""String_Node_Str"",request,response);
      log.debug(""String_Node_Str"");
      return;
    }
 else {
      f=new File(filename);
      fis=new FileInputStream(f);
      d.setFile(fis);
      String onBehalfOf=request.getHeader(HttpHeaders.X_ON_BEHALF_OF.toString());
      if ((onBehalfOf != null) && (onBehalfOf.equals(""String_Node_Str""))) {
        throw new SWORDErrorException(ErrorCodes.TARGET_OWNER_UKNOWN,""String_Node_Str"");
      }
 else {
        d.setOnBehalfOf(onBehalfOf);
      }
      d.setPackaging(request.getHeader(HttpHeaders.X_PACKAGING));
      String noop=request.getHeader(HttpHeaders.X_NO_OP);
      log.error(""String_Node_Str"" + noop);
      if ((noop != null) && (noop.equals(""String_Node_Str""))) {
        d.setNoOp(true);
      }
 else       if ((noop != null) && (noop.equals(""String_Node_Str""))) {
        d.setNoOp(false);
      }
 else       if (noop == null) {
        d.setNoOp(false);
      }
 else {
        throw new SWORDErrorException(ErrorCodes.ERROR_BAD_REQUEST,""String_Node_Str"");
      }
      String verbose=request.getHeader(HttpHeaders.X_VERBOSE);
      if ((verbose != null) && (verbose.equals(""String_Node_Str""))) {
        d.setVerbose(true);
      }
 else       if ((verbose != null) && (verbose.equals(""String_Node_Str""))) {
        d.setVerbose(false);
      }
 else       if (verbose == null) {
        d.setVerbose(false);
      }
 else {
        throw new SWORDErrorException(ErrorCodes.ERROR_BAD_REQUEST,""String_Node_Str"");
      }
      String slug=request.getHeader(HttpHeaders.SLUG);
      if (slug != null) {
        d.setSlug(slug);
      }
      d.setContentDisposition(request.getHeader(HttpHeaders.CONTENT_DISPOSITION));
      d.setIPAddress(request.getRemoteAddr());
      d.setLocation(getUrl(request));
      d.setContentType(request.getContentType());
      String cl=request.getHeader(HttpHeaders.CONTENT_LENGTH);
      if ((cl != null) && (!cl.equals(""String_Node_Str""))) {
        d.setContentLength(Integer.parseInt(cl));
      }
      DepositResponse dr=myRepository.doDeposit(d);
      if (request.getHeader(HttpHeaders.USER_AGENT.toString()) != null) {
        dr.getEntry().setUserAgent(request.getHeader(HttpHeaders.USER_AGENT.toString()));
      }
      if (request.getHeader(HttpHeaders.X_PACKAGING.toString()) != null) {
        dr.getEntry().setPackaging(request.getHeader(HttpHeaders.X_PACKAGING.toString()));
      }
      response.setStatus(dr.getHttpResponse());
      if ((dr.getLocation() != null) && (!dr.getLocation().equals(""String_Node_Str""))) {
        response.setHeader(""String_Node_Str"",dr.getLocation());
      }
      response.setContentType(""String_Node_Str"");
      PrintWriter out=response.getWriter();
      out.write(dr.marshall());
      out.flush();
    }
  }
 catch (  SWORDAuthenticationException sae) {
    if (authN.equals(""String_Node_Str"")) {
      String s=""String_Node_Str"";
      response.setHeader(""String_Node_Str"",s);
      response.setStatus(401);
    }
  }
catch (  SWORDErrorException see) {
    log.error(see.toString());
    this.makeErrorDocument(see.getErrorURI(),see.getStatus(),see.getDescription(),request,response);
    return;
  }
catch (  SWORDException se) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    log.error(se.toString());
  }
catch (  NoSuchAlgorithmException nsae) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    log.error(nsae.toString());
  }
 finally {
    if (fis != null) {
      fis.close();
    }
    if (filename != null) {
      f=new File(filename);
      f.delete();
    }
  }
}","/** 
 * Process a post request.
 */
protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  Deposit d=new Deposit();
  Date date=new Date();
  log.debug(""String_Node_Str"" + date.toString() + ""String_Node_Str""+ request.getRemoteAddr());
  String usernamePassword=getUsernamePassword(request);
  if ((usernamePassword != null) && (!usernamePassword.equals(""String_Node_Str""))) {
    int p=usernamePassword.indexOf(""String_Node_Str"");
    if (p != -1) {
      d.setUsername(usernamePassword.substring(0,p));
      d.setPassword(usernamePassword.substring(p + 1));
    }
  }
 else   if (authenticateWithBasic()) {
    String s=""String_Node_Str"";
    response.setHeader(""String_Node_Str"",s);
    response.setStatus(401);
    return;
  }
  String filename=null;
  File f=null;
  FileInputStream fis=null;
  try {
    filename=tempDirectory + ""String_Node_Str"" + request.getRemoteAddr()+ ""String_Node_Str""+ counter.addAndGet(1);
    InputStream inputStream=request.getInputStream();
    OutputStream outputStream=new FileOutputStream(filename);
    try {
      int data;
      while ((data=inputStream.read()) != -1) {
        outputStream.write(data);
      }
    }
  finally {
      inputStream.close();
      outputStream.close();
    }
    File file=new File(filename);
    long fLength=file.length() / 1024;
    if ((maxUploadSize != -1) && (fLength > maxUploadSize)) {
      this.makeErrorDocument(ErrorCodes.MAX_UPLOAD_SIZE_EXCEEDED,HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE,""String_Node_Str"" + fLength + ""String_Node_Str""+ maxUploadSize+ ""String_Node_Str"",request,response);
      return;
    }
    String receivedMD5=ChecksumUtils.generateMD5(filename);
    log.debug(""String_Node_Str"" + receivedMD5);
    d.setMd5(receivedMD5);
    String md5=request.getHeader(""String_Node_Str"");
    log.debug(""String_Node_Str"" + md5);
    if ((md5 != null) && (!md5.equals(receivedMD5))) {
      this.makeErrorDocument(ErrorCodes.ERROR_CHECKSUM_MISMATCH,HttpServletResponse.SC_PRECONDITION_FAILED,""String_Node_Str"",request,response);
      log.debug(""String_Node_Str"");
      return;
    }
 else {
      f=new File(filename);
      fis=new FileInputStream(f);
      d.setFile(fis);
      String onBehalfOf=request.getHeader(HttpHeaders.X_ON_BEHALF_OF.toString());
      if ((onBehalfOf != null) && (onBehalfOf.equals(""String_Node_Str""))) {
        throw new SWORDErrorException(ErrorCodes.TARGET_OWNER_UKNOWN,""String_Node_Str"");
      }
 else {
        d.setOnBehalfOf(onBehalfOf);
      }
      d.setPackaging(request.getHeader(HttpHeaders.X_PACKAGING));
      String noop=request.getHeader(HttpHeaders.X_NO_OP);
      log.error(""String_Node_Str"" + noop);
      if ((noop != null) && (noop.equals(""String_Node_Str""))) {
        d.setNoOp(true);
      }
 else       if ((noop != null) && (noop.equals(""String_Node_Str""))) {
        d.setNoOp(false);
      }
 else       if (noop == null) {
        d.setNoOp(false);
      }
 else {
        throw new SWORDErrorException(ErrorCodes.ERROR_BAD_REQUEST,""String_Node_Str"");
      }
      String verbose=request.getHeader(HttpHeaders.X_VERBOSE);
      if ((verbose != null) && (verbose.equals(""String_Node_Str""))) {
        d.setVerbose(true);
      }
 else       if ((verbose != null) && (verbose.equals(""String_Node_Str""))) {
        d.setVerbose(false);
      }
 else       if (verbose == null) {
        d.setVerbose(false);
      }
 else {
        throw new SWORDErrorException(ErrorCodes.ERROR_BAD_REQUEST,""String_Node_Str"");
      }
      String slug=request.getHeader(HttpHeaders.SLUG);
      if (slug != null) {
        d.setSlug(slug);
      }
      d.setContentDisposition(request.getHeader(HttpHeaders.CONTENT_DISPOSITION));
      d.setIPAddress(request.getRemoteAddr());
      d.setLocation(getUrl(request));
      d.setContentType(request.getContentType());
      String cl=request.getHeader(HttpHeaders.CONTENT_LENGTH);
      if ((cl != null) && (!cl.equals(""String_Node_Str""))) {
        d.setContentLength(Integer.parseInt(cl));
      }
      DepositResponse dr=myRepository.doDeposit(d);
      if (request.getHeader(HttpHeaders.USER_AGENT.toString()) != null) {
        dr.getEntry().setUserAgent(request.getHeader(HttpHeaders.USER_AGENT.toString()));
      }
      if (request.getHeader(HttpHeaders.X_PACKAGING.toString()) != null) {
        dr.getEntry().setPackaging(request.getHeader(HttpHeaders.X_PACKAGING.toString()));
      }
      response.setStatus(dr.getHttpResponse());
      if ((dr.getLocation() != null) && (!dr.getLocation().equals(""String_Node_Str""))) {
        response.setHeader(""String_Node_Str"",dr.getLocation());
      }
      response.setContentType(""String_Node_Str"");
      PrintWriter out=response.getWriter();
      out.write(dr.marshall());
      out.flush();
    }
  }
 catch (  SWORDAuthenticationException sae) {
    if (authN.equals(""String_Node_Str"")) {
      String s=""String_Node_Str"";
      response.setHeader(""String_Node_Str"",s);
      response.setStatus(401);
    }
  }
catch (  SWORDErrorException see) {
    log.error(see.toString());
    this.makeErrorDocument(see.getErrorURI(),see.getStatus(),see.getDescription(),request,response);
    return;
  }
catch (  SWORDException se) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    log.error(se.toString());
  }
catch (  NoSuchAlgorithmException nsae) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    log.error(nsae.toString());
  }
 finally {
    if (fis != null) {
      fis.close();
    }
    if (filename != null) {
      f=new File(filename);
      f.delete();
    }
  }
}",0.9941249777461278
3301,"/** 
 * Edit an eperson's metadata, the email address, first name, and last name are all required. The user's email address can be updated but it must remain unique, if the email address allready exists then the an error is produced.
 * @param context The current DSpace context
 * @param request The HTTP request parameters
 * @param objectModel Cocoon's object model
 * @param epersonID The unique id of the eperson being edited.
 * @return A process result's object.
 */
public static FlowResult processEditEPerson(Context context,Request request,Map ObjectModel,int epersonID) throws SQLException, AuthorizeException {
  FlowResult result=new FlowResult();
  result.setContinue(false);
  String email=request.getParameter(""String_Node_Str"");
  String first=request.getParameter(""String_Node_Str"");
  String last=request.getParameter(""String_Node_Str"");
  String phone=request.getParameter(""String_Node_Str"");
  boolean login=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  boolean certificate=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  if (email.length() == 0)   result.addError(""String_Node_Str"");
  if (first.length() == 0)   result.addError(""String_Node_Str"");
  if (last.length() == 0)   result.addError(""String_Node_Str"");
  if (result.getErrors() == null) {
    EPerson personModified=EPerson.find(context,epersonID);
    if (personModified.getEmail() != email) {
      EPerson potentialDupicate=EPerson.findByEmail(context,email);
      if (potentialDupicate == null) {
        personModified.setEmail(email);
      }
 else       if (potentialDupicate != personModified) {
        result.addError(""String_Node_Str"");
        return result;
      }
    }
    if (personModified.getFirstName() != first) {
      personModified.setFirstName(first);
    }
    if (personModified.getLastName() != last) {
      personModified.setLastName(last);
    }
    if (personModified.getMetadata(""String_Node_Str"") != phone) {
      personModified.setMetadata(""String_Node_Str"",phone);
    }
    personModified.setCanLogIn(login);
    personModified.setRequireCertificate(certificate);
    personModified.update();
    context.commit();
    result.setContinue(true);
    result.setOutcome(true);
    result.setMessage(T_edit_eperson_success_notice);
  }
  return result;
}","/** 
 * Edit an eperson's metadata, the email address, first name, and last name are all required. The user's email address can be updated but it must remain unique, if the email address allready exists then the an error is produced.
 * @param context The current DSpace context
 * @param request The HTTP request parameters
 * @param objectModel Cocoon's object model
 * @param epersonID The unique id of the eperson being edited.
 * @return A process result's object.
 */
public static FlowResult processEditEPerson(Context context,Request request,Map ObjectModel,int epersonID) throws SQLException, AuthorizeException {
  FlowResult result=new FlowResult();
  result.setContinue(false);
  String email=request.getParameter(""String_Node_Str"");
  String first=request.getParameter(""String_Node_Str"");
  String last=request.getParameter(""String_Node_Str"");
  String phone=request.getParameter(""String_Node_Str"");
  boolean login=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  boolean certificate=(request.getParameter(""String_Node_Str"") != null) ? true : false;
  if (email.length() == 0)   result.addError(""String_Node_Str"");
  if (first.length() == 0)   result.addError(""String_Node_Str"");
  if (last.length() == 0)   result.addError(""String_Node_Str"");
  if (result.getErrors() == null) {
    EPerson personModified=EPerson.find(context,epersonID);
    if (!personModified.getEmail().equals(email)) {
      EPerson potentialDupicate=EPerson.findByEmail(context,email);
      if (potentialDupicate == null) {
        personModified.setEmail(email);
      }
 else       if (potentialDupicate != personModified) {
        result.addError(""String_Node_Str"");
        return result;
      }
    }
    if (!personModified.getFirstName().equals(first)) {
      personModified.setFirstName(first);
    }
    if (!personModified.getLastName().equals(last)) {
      personModified.setLastName(last);
    }
    if (!personModified.getMetadata(""String_Node_Str"").equals(phone)) {
      personModified.setMetadata(""String_Node_Str"",phone);
    }
    personModified.setCanLogIn(login);
    personModified.setRequireCertificate(certificate);
    personModified.update();
    context.commit();
    result.setContinue(true);
    result.setOutcome(true);
    result.setMessage(T_edit_eperson_success_notice);
  }
  return result;
}",0.932043010752688
3302,"public String getServletPath(){
  return this.getServletPath();
}","public String getServletPath(){
  return this.cocoonRequest.getServletPath();
}",0.9027777777777778
3303,"public String getRequestURI(){
  return this.getRequestURI();
}","public String getRequestURI(){
  return this.cocoonRequest.getRequestURI();
}",0.9
3304,"public String getRemoteUser(){
  return this.getRemoteUser();
}","public String getRemoteUser(){
  return this.cocoonRequest.getRemoteUser();
}",0.9
3305,"public HttpSession getSession(boolean arg0){
  return this.getSession(arg0);
}","public HttpSession getSession(boolean arg0){
  return (HttpSession)this.cocoonRequest.getSession(arg0);
}",0.8524590163934426
3306,"public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Map<String,String> map=new HashMap<String,String>();
  String propertyFile=parameters.getParameter(""String_Node_Str"");
  Properties props=new Properties();
  InputStream in=new FileInputStream(propertyFile);
  props.load(in);
  in.close();
  final String[] parameterNames=parameters.getNames();
  for (int i=0; i < parameterNames.length; i++) {
    final String paramName=parameterNames[i];
    if (""String_Node_Str"".equals(paramName)) {
      continue;
    }
    map.put(parameters.getParameter(paramName),props.getProperty(paramName));
  }
  return map;
}","public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Map<String,String> map=new HashMap<String,String>();
  String propertyFile=parameters.getParameter(""String_Node_Str"");
  Properties props=new Properties();
  InputStream in=new FileInputStream(propertyFile);
  try {
    props.load(in);
  }
  finally {
    in.close();
  }
  final String[] parameterNames=parameters.getNames();
  for (int i=0; i < parameterNames.length; i++) {
    final String paramName=parameterNames[i];
    if (""String_Node_Str"".equals(paramName)) {
      continue;
    }
    map.put(parameters.getParameter(paramName),props.getProperty(paramName));
  }
  return map;
}",0.961864406779661
3307,"/** 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String page=request.getParameter(""String_Node_Str"");
  String address=request.getParameter(""String_Node_Str"");
  String agent=request.getHeader(""String_Node_Str"");
  String session=request.getSession().getId();
  String comments=request.getParameter(""String_Node_Str"");
  Context context=ContextUtil.obtainContext(objectModel);
  EPerson loggedin=context.getCurrentUser();
  String eperson=null;
  if (loggedin != null)   eperson=loggedin.getEmail();
  if (page == null || page.equals(""String_Node_Str"")) {
    page=request.getHeader(""String_Node_Str"");
  }
  if ((address == null) || address.equals(""String_Node_Str"") || (comments == null)|| comments.equals(""String_Node_Str"")) {
    Map<String,String> map=new HashMap<String,String>();
    map.put(""String_Node_Str"",page);
    if (address == null || address.equals(""String_Node_Str""))     map.put(""String_Node_Str"",eperson);
 else     map.put(""String_Node_Str"",address);
    map.put(""String_Node_Str"",comments);
    return map;
  }
  Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(context.getCurrentLocale(),""String_Node_Str""));
  email.addRecipient(ConfigurationManager.getProperty(""String_Node_Str""));
  email.addArgument(new Date());
  email.addArgument(address);
  email.addArgument(eperson);
  email.addArgument(page);
  email.addArgument(agent);
  email.addArgument(session);
  email.addArgument(comments);
  email.setReplyTo(address);
  email.send();
  return null;
}","/** 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String page=request.getParameter(""String_Node_Str"");
  String address=request.getParameter(""String_Node_Str"");
  String agent=request.getHeader(""String_Node_Str"");
  String session=request.getSession().getId();
  String comments=request.getParameter(""String_Node_Str"");
  String fromPage=request.getHeader(""String_Node_Str"");
  String host=ConfigurationManager.getProperty(""String_Node_Str"");
  String basicHost=""String_Node_Str"";
  if (host.equals(""String_Node_Str"") || host.equals(""String_Node_Str"") || host.equals(InetAddress.getLocalHost().getHostAddress()))   basicHost=host;
 else {
    int lastDot=host.lastIndexOf(""String_Node_Str"");
    basicHost=host.substring(host.substring(0,lastDot).lastIndexOf(""String_Node_Str""));
  }
  if (fromPage == null || fromPage.indexOf(basicHost) == -1) {
    throw new AuthorizeException();
  }
  Context context=ContextUtil.obtainContext(objectModel);
  EPerson loggedin=context.getCurrentUser();
  String eperson=null;
  if (loggedin != null)   eperson=loggedin.getEmail();
  if (page == null || page.equals(""String_Node_Str"")) {
    page=fromPage;
  }
  if ((address == null) || address.equals(""String_Node_Str"") || (comments == null)|| comments.equals(""String_Node_Str"")) {
    Map<String,String> map=new HashMap<String,String>();
    map.put(""String_Node_Str"",page);
    if (address == null || address.equals(""String_Node_Str""))     map.put(""String_Node_Str"",eperson);
 else     map.put(""String_Node_Str"",address);
    map.put(""String_Node_Str"",comments);
    return map;
  }
  Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(context.getCurrentLocale(),""String_Node_Str""));
  email.addRecipient(ConfigurationManager.getProperty(""String_Node_Str""));
  email.addArgument(new Date());
  email.addArgument(address);
  email.addArgument(eperson);
  email.addArgument(page);
  email.addArgument(agent);
  email.addArgument(session);
  email.addArgument(comments);
  email.setReplyTo(address);
  email.send();
  return null;
}",0.8410096278948738
3308,"/** 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String page=request.getParameter(""String_Node_Str"");
  String address=request.getParameter(""String_Node_Str"");
  String agent=request.getHeader(""String_Node_Str"");
  String session=request.getSession().getId();
  String comments=request.getParameter(""String_Node_Str"");
  Context context=ContextUtil.obtainContext(objectModel);
  EPerson loggedin=context.getCurrentUser();
  String eperson=null;
  if (loggedin != null)   eperson=loggedin.getEmail();
  if (page == null || page.equals(""String_Node_Str"")) {
    page=request.getHeader(""String_Node_Str"");
  }
  if ((address == null) || address.equals(""String_Node_Str"") || (comments == null)|| comments.equals(""String_Node_Str"")) {
    Map<String,String> map=new HashMap<String,String>();
    map.put(""String_Node_Str"",page);
    if (address == null || address.equals(""String_Node_Str""))     map.put(""String_Node_Str"",eperson);
 else     map.put(""String_Node_Str"",address);
    map.put(""String_Node_Str"",comments);
    return map;
  }
  Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(context.getCurrentLocale(),""String_Node_Str""));
  email.addRecipient(ConfigurationManager.getProperty(""String_Node_Str""));
  email.addArgument(new Date());
  email.addArgument(address);
  email.addArgument(eperson);
  email.addArgument(page);
  email.addArgument(agent);
  email.addArgument(session);
  email.addArgument(comments);
  email.setReplyTo(address);
  email.send();
  return null;
}","/** 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String page=request.getParameter(""String_Node_Str"");
  String address=request.getParameter(""String_Node_Str"");
  String agent=request.getHeader(""String_Node_Str"");
  String session=request.getSession().getId();
  String comments=request.getParameter(""String_Node_Str"");
  String fromPage=request.getHeader(""String_Node_Str"");
  String host=ConfigurationManager.getProperty(""String_Node_Str"");
  String basicHost=""String_Node_Str"";
  if (host.equals(""String_Node_Str"") || host.equals(""String_Node_Str"") || host.equals(InetAddress.getLocalHost().getHostAddress()))   basicHost=host;
 else {
    int lastDot=host.lastIndexOf(""String_Node_Str"");
    basicHost=host.substring(host.substring(0,lastDot).lastIndexOf(""String_Node_Str""));
  }
  if (fromPage == null || fromPage.indexOf(basicHost) == -1) {
    throw new AuthorizeException();
  }
  Context context=ContextUtil.obtainContext(objectModel);
  EPerson loggedin=context.getCurrentUser();
  String eperson=null;
  if (loggedin != null)   eperson=loggedin.getEmail();
  if (page == null || page.equals(""String_Node_Str"")) {
    page=fromPage;
  }
  if ((address == null) || address.equals(""String_Node_Str"") || (comments == null)|| comments.equals(""String_Node_Str"")) {
    Map<String,String> map=new HashMap<String,String>();
    map.put(""String_Node_Str"",page);
    if (address == null || address.equals(""String_Node_Str""))     map.put(""String_Node_Str"",eperson);
 else     map.put(""String_Node_Str"",address);
    map.put(""String_Node_Str"",comments);
    return map;
  }
  Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(context.getCurrentLocale(),""String_Node_Str""));
  email.addRecipient(ConfigurationManager.getProperty(""String_Node_Str""));
  email.addArgument(new Date());
  email.addArgument(address);
  email.addArgument(eperson);
  email.addArgument(page);
  email.addArgument(agent);
  email.addArgument(session);
  email.addArgument(comments);
  email.setReplyTo(address);
  email.send();
  return null;
}",0.8410096278948738
3309,"/** 
 * Compare these two activity events based upon the given sort parameter. In the case of a tie, allways fallback to sorting based upon the timestamp.
 */
public int compare(E a,E b){
  if (EventSort.URL == sortBy) {
    String aURL=a.getURL();
    String bURL=b.getURL();
    int cmp=aURL.compareTo(bURL);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.AGENT == sortBy) {
    String aAgent=a.getDectectedBrowser();
    String bAgent=b.getDectectedBrowser();
    int cmp=aAgent.compareTo(bAgent);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.IP == sortBy) {
    String aIP=a.getIP();
    String bIP=b.getIP();
    int cmp=aIP.compareTo(bIP);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.SESSION == sortBy) {
    String aSession=a.getSessionID();
    String bSession=b.getSessionID();
    int cmp=aSession.compareTo(bSession);
    if (cmp != 0)     return cmp;
  }
  if (a.getTimeStamp() > b.getTimeStamp())   return 1;
 else   if (a.getTimeStamp() > b.getTimeStamp())   return -1;
  return 0;
}","/** 
 * Compare these two activity events based upon the given sort parameter. In the case of a tie, allways fallback to sorting based upon the timestamp.
 */
public int compare(E a,E b){
  if (a != null && b == null)   return 1;
 else   if (a == null && b != null)   return -1;
 else   if (a == null && b == null)   return 0;
  if (EventSort.URL == sortBy) {
    String aURL=a.getURL();
    String bURL=b.getURL();
    int cmp=aURL.compareTo(bURL);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.AGENT == sortBy) {
    String aAgent=a.getDectectedBrowser();
    String bAgent=b.getDectectedBrowser();
    int cmp=aAgent.compareTo(bAgent);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.IP == sortBy) {
    String aIP=a.getIP();
    String bIP=b.getIP();
    int cmp=aIP.compareTo(bIP);
    if (cmp != 0)     return cmp;
  }
 else   if (EventSort.SESSION == sortBy) {
    if (a.getEPersonID() > 0 && b.getEPersonID() < 0)     return 1;
 else     if (a.getEPersonID() < 0 && b.getEPersonID() > 0)     return -1;
    String aSession=a.getSessionID();
    String bSession=b.getSessionID();
    int cmp=aSession.compareTo(bSession);
    if (cmp != 0)     return cmp;
  }
  if (a.getTimeStamp() > b.getTimeStamp())   return 1;
 else   if (a.getTimeStamp() > b.getTimeStamp())   return -1;
  return 0;
}",0.6852791878172588
3310,"/** 
 * Create a list of all activity.
 */
private void addActivity(Division div) throws WingException, SQLException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showSelf=request.getParameter(""String_Node_Str"");
  if (showSelf == null || !showSelf.equals(""String_Node_Str""))   showSelf=""String_Node_Str"";
  EventSort sortBy=EventSort.TIME;
  String sortByString=request.getParameter(""String_Node_Str"");
  if (EventSort.TIME.toString().equals(sortByString))   sortBy=EventSort.TIME;
  if (EventSort.URL.toString().equals(sortByString))   sortBy=EventSort.URL;
  if (EventSort.SESSION.toString().equals(sortByString))   sortBy=EventSort.SESSION;
  if (EventSort.AGENT.toString().equals(sortByString))   sortBy=EventSort.AGENT;
  if (EventSort.IP.toString().equals(sortByString))   sortBy=EventSort.IP;
  java.util.List<CurrentActivityAction.Event> events=CurrentActivityAction.getEvents();
  Collections.sort(events,new ActivitySort<CurrentActivityAction.Event>(sortBy));
  Collections.reverse(events);
  if (showSelf.equals(""String_Node_Str""))   div.addPara().addXref(""String_Node_Str"" + sortBy + ""String_Node_Str"").addContent(T_activity_hideself);
 else   div.addPara().addXref(""String_Node_Str"" + sortBy + ""String_Node_Str"").addContent(T_activity_showself);
  Table activeUsers=div.addTable(""String_Node_Str"",1,1);
  activeUsers.setHead(T_activity_head);
  Row row=activeUsers.addRow(Row.ROLE_HEADER);
  if (sortBy == EventSort.TIME)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.TIME + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_time);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.TIME + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_time);
  if (sortBy == EventSort.SESSION)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.SESSION + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_user);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.SESSION + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_user);
  if (sortBy == EventSort.IP)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.IP + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_ip);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.IP + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_ip);
  if (sortBy == EventSort.URL)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.URL + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_url);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.URL + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_url);
  if (sortBy == EventSort.AGENT)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.AGENT + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_agent);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.AGENT + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_agent);
  HashMap<String,Integer> anonymousHash=new HashMap<String,Integer>();
  int anonymousCount=1;
  int shown=0;
  for (  CurrentActivityAction.Event event : events) {
    if (showSelf.equals(""String_Node_Str"") && event.getEPersonID() == context.getCurrentUser().getID())     continue;
    shown++;
    Message timeStampMessage=null;
    long ago=System.currentTimeMillis() - event.getTimeStamp();
    if (ago > 2 * 60 * 60* 1000)     timeStampMessage=T_hours.parameterize((ago / (60 * 60 * 1000)));
 else     if (ago > 60 * 1000)     timeStampMessage=T_minutes.parameterize((ago / (60 * 1000)));
 else     timeStampMessage=T_seconds.parameterize((ago / (1000)));
    Row eventRow=activeUsers.addRow();
    eventRow.addCellContent(timeStampMessage);
    int eid=event.getEPersonID();
    EPerson eperson=EPerson.find(context,eid);
    if (eperson != null) {
      String name=eperson.getFullName();
      eventRow.addCellContent(name);
    }
 else {
      if (!anonymousHash.containsKey(event.getSessionID()))       anonymousHash.put(event.getSessionID(),anonymousCount++);
      eventRow.addCellContent(T_activity_anonymous.parameterize(anonymousHash.get(event.getSessionID())));
    }
    eventRow.addCellContent(event.getIP());
    eventRow.addCell().addXref(contextPath + ""String_Node_Str"" + event.getURL()).addContent(""String_Node_Str"" + event.getURL());
    eventRow.addCellContent(event.getDectectedBrowser());
  }
  if (shown == 0) {
    activeUsers.addRow().addCell(1,5).addContent(T_activity_none.parameterize(CurrentActivityAction.MAX_EVENTS));
  }
}","/** 
 * Create a list of all activity.
 */
private void addActivity(Division div) throws WingException, SQLException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showSelf=request.getParameter(""String_Node_Str"");
  if (showSelf == null || !showSelf.equals(""String_Node_Str""))   showSelf=""String_Node_Str"";
  EventSort sortBy=EventSort.TIME;
  String sortByString=request.getParameter(""String_Node_Str"");
  if (EventSort.TIME.toString().equals(sortByString))   sortBy=EventSort.TIME;
  if (EventSort.URL.toString().equals(sortByString))   sortBy=EventSort.URL;
  if (EventSort.SESSION.toString().equals(sortByString))   sortBy=EventSort.SESSION;
  if (EventSort.AGENT.toString().equals(sortByString))   sortBy=EventSort.AGENT;
  if (EventSort.IP.toString().equals(sortByString))   sortBy=EventSort.IP;
  java.util.List<CurrentActivityAction.Event> events=CurrentActivityAction.getEvents();
  Collections.sort(events,new ActivitySort<CurrentActivityAction.Event>(sortBy));
  Collections.reverse(events);
  if (showSelf.equals(""String_Node_Str""))   div.addPara().addXref(""String_Node_Str"" + sortBy + ""String_Node_Str"").addContent(T_activity_hideself);
 else   div.addPara().addXref(""String_Node_Str"" + sortBy + ""String_Node_Str"").addContent(T_activity_showself);
  Table activeUsers=div.addTable(""String_Node_Str"",1,1);
  activeUsers.setHead(T_activity_head.parameterize(CurrentActivityAction.MAX_EVENTS));
  Row row=activeUsers.addRow(Row.ROLE_HEADER);
  if (sortBy == EventSort.TIME)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.TIME + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_time);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.TIME + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_time);
  if (sortBy == EventSort.SESSION)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.SESSION + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_user);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.SESSION + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_user);
  if (sortBy == EventSort.IP)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.IP + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_ip);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.IP + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_ip);
  if (sortBy == EventSort.URL)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.URL + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_url);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.URL + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_url);
  if (sortBy == EventSort.AGENT)   row.addCell().addHighlight(""String_Node_Str"").addXref(""String_Node_Str"" + EventSort.AGENT + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_agent);
 else   row.addCell().addXref(""String_Node_Str"" + EventSort.AGENT + ""String_Node_Str""+ showSelf).addContent(T_activity_sort_agent);
  HashMap<String,Integer> anonymousHash=new HashMap<String,Integer>();
  int anonymousCount=1;
  int shown=0;
  for (  CurrentActivityAction.Event event : events) {
    if (event == null)     continue;
    if (showSelf.equals(""String_Node_Str"") && event.getEPersonID() == context.getCurrentUser().getID())     continue;
    shown++;
    Message timeStampMessage=null;
    long ago=System.currentTimeMillis() - event.getTimeStamp();
    if (ago > 2 * 60 * 60* 1000)     timeStampMessage=T_hours.parameterize((ago / (60 * 60 * 1000)));
 else     if (ago > 60 * 1000)     timeStampMessage=T_minutes.parameterize((ago / (60 * 1000)));
 else     timeStampMessage=T_seconds.parameterize((ago / (1000)));
    Row eventRow=activeUsers.addRow();
    eventRow.addCellContent(timeStampMessage);
    int eid=event.getEPersonID();
    EPerson eperson=EPerson.find(context,eid);
    if (eperson != null) {
      String name=eperson.getFullName();
      eventRow.addCellContent(name);
    }
 else {
      if (!anonymousHash.containsKey(event.getSessionID()))       anonymousHash.put(event.getSessionID(),anonymousCount++);
      eventRow.addCellContent(T_activity_anonymous.parameterize(anonymousHash.get(event.getSessionID())));
    }
    eventRow.addCellContent(event.getIP());
    eventRow.addCell().addXref(contextPath + ""String_Node_Str"" + event.getURL()).addContent(""String_Node_Str"" + event.getURL());
    eventRow.addCellContent(event.getDectectedBrowser());
  }
  if (shown == 0) {
    activeUsers.addRow().addCell(1,5).addContent(T_activity_none.parameterize(CurrentActivityAction.MAX_EVENTS));
  }
}",0.9909071227538429
3311,"/** 
 * @return a list of all current events.
 */
public static List<Event> getEvents(){
  List<Event> list=new ArrayList<Event>();
  list.addAll(events);
  return list;
}","/** 
 * @return a list of all current events.
 */
public static List<Event> getEvents(){
  List<Event> list=new ArrayList<Event>();
synchronized (events) {
    list.addAll(events);
  }
  return list;
}",0.9193548387096774
3312,"/** 
 * Record this current event.
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  Context context=ContextUtil.obtainContext(objectModel);
  Event event=new Event(context,request);
  events.add(event);
  while (events.size() > MAX_EVENTS)   events.poll();
  return null;
}","/** 
 * Record this current event.
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  Context context=ContextUtil.obtainContext(objectModel);
synchronized (events) {
    Event event=new Event(context,request);
    events.add(event);
    while (events.size() > MAX_EVENTS)     events.poll();
  }
  return null;
}",0.8484162895927602
3313,"/** 
 * Take an InProgressSubmission and turn it into a fully-archived Item.
 * @param c  current context
 * @param is submission to install
 * @param suppliedHandle the existing Handle to give the installed item
 * @return the fully archived Item
 */
public static Item installItem(Context c,InProgressSubmission is,String suppliedHandle) throws SQLException, IOException, AuthorizeException {
  Item item=is.getItem();
  String handle;
  DCDate now=DCDate.getCurrent();
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  DCValue[] currentDateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (currentDateIssued.length == 0) {
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  }
  if (suppliedHandle == null) {
    handle=HandleManager.createHandle(c,item);
  }
 else {
    handle=HandleManager.createHandle(c,item,suppliedHandle);
  }
  String handleref=HandleManager.getCanonicalForm(handle);
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,handleref);
  String provDescription=""String_Node_Str"" + now + ""String_Node_Str""+ getBitstreamProvenanceMessage(item);
  if (currentDateIssued.length != 0) {
    DCDate d=new DCDate(currentDateIssued[0].value);
    provDescription=provDescription + ""String_Node_Str"" + d.toString();
  }
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  is.getCollection().addItem(item);
  item.setOwningCollection(is.getCollection());
  item.setArchived(true);
  item.update();
  is.deleteWrapper();
  item.inheritCollectionDefaultPolicies(is.getCollection());
  return item;
}","/** 
 * Take an InProgressSubmission and turn it into a fully-archived Item.
 * @param c  current context
 * @param is submission to install
 * @param suppliedHandle the existing Handle to give the installed item
 * @return the fully archived Item
 */
public static Item installItem(Context c,InProgressSubmission is,String suppliedHandle) throws SQLException, IOException, AuthorizeException {
  Item item=is.getItem();
  String handle;
  DCDate now=DCDate.getCurrent();
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  DCValue[] currentDateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (currentDateIssued.length == 0) {
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  }
  if (suppliedHandle == null) {
    handle=HandleManager.createHandle(c,item);
  }
 else {
    handle=HandleManager.createHandle(c,item,suppliedHandle);
  }
  String handleref=HandleManager.getCanonicalForm(handle);
  boolean identifierExists=false;
  DCValue[] identifiers=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  for (  DCValue identifier : identifiers)   if (handleref.equals(identifier.value))   identifierExists=true;
  if (!identifierExists)   item.addDC(""String_Node_Str"",""String_Node_Str"",null,handleref);
  String provDescription=""String_Node_Str"" + now + ""String_Node_Str""+ getBitstreamProvenanceMessage(item);
  if (currentDateIssued.length != 0) {
    DCDate d=new DCDate(currentDateIssued[0].value);
    provDescription=provDescription + ""String_Node_Str"" + d.toString();
  }
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  is.getCollection().addItem(item);
  item.setOwningCollection(is.getCollection());
  item.setArchived(true);
  item.update();
  is.deleteWrapper();
  item.inheritCollectionDefaultPolicies(is.getCollection());
  return item;
}",0.930720397460668
3314,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  int currentPage=getCurrentPage(request);
  Collection c=subInfo.getSubmissionItem().getCollection();
  DCInput[] inputs=inputsReader.getInputs(c.getHandle()).getPageRows(currentPage - 1,subInfo.getSubmissionItem().hasMultipleTitles(),subInfo.getSubmissionItem().isPublishedBefore());
  for (int i=0; i < inputs.length; i++) {
    String qualifier=inputs[i].getQualifier();
    if (qualifier == null && inputs[i].getInputType().equals(""String_Node_Str"")) {
      qualifier=Item.ANY;
    }
    item.clearMetadata(inputs[i].getSchema(),inputs[i].getElement(),qualifier,Item.ANY);
  }
  String fieldName;
  boolean moreInput=false;
  for (int j=0; j < inputs.length; j++) {
    String element=inputs[j].getElement();
    String qualifier=inputs[j].getQualifier();
    String schema=inputs[j].getSchema();
    if (qualifier != null && !qualifier.equals(Item.ANY)) {
      fieldName=schema + ""String_Node_Str"" + element+ '_'+ qualifier;
    }
 else {
      fieldName=schema + ""String_Node_Str"" + element;
    }
    String inputType=inputs[j].getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      readNames(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readDate(request,item,schema,element,qualifier);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readSeriesNumbers(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      List quals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      List vals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      for (int z=0; z < vals.size(); z++) {
        String thisQual=(String)quals.get(z);
        if (""String_Node_Str"".equals(thisQual)) {
          thisQual=null;
        }
        String thisVal=(String)vals.get(z);
        if (!buttonPressed.equals(""String_Node_Str"" + schema + ""String_Node_Str""+ element+ ""String_Node_Str""+ z) && !thisVal.equals(""String_Node_Str"")) {
          item.addMetadata(schema,element,thisQual,null,thisVal);
        }
      }
    }
 else     if (inputType.equals(""String_Node_Str"") || inputType.equals(""String_Node_Str"")) {
      String[] vals=request.getParameterValues(fieldName);
      if (vals != null) {
        for (int z=0; z < vals.length; z++) {
          if (!vals[z].equals(""String_Node_Str"")) {
            item.addMetadata(schema,element,qualifier,LANGUAGE_QUALIFIER,vals[z]);
          }
        }
      }
    }
 else     if ((inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str""))) {
      readText(request,item,schema,element,qualifier,inputs[j].getRepeatable(),LANGUAGE_QUALIFIER);
    }
 else {
      throw new ServletException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ inputType);
    }
    if (!moreInput && buttonPressed.equals(""String_Node_Str"" + fieldName + ""String_Node_Str"")) {
      subInfo.setMoreBoxesFor(fieldName);
      subInfo.setJumpToField(fieldName);
      moreInput=true;
    }
  }
  clearErrorFields(request);
  for (int i=0; i < inputs.length; i++) {
    DCValue[] values=item.getMetadata(inputs[i].getSchema(),inputs[i].getElement(),inputs[i].getQualifier(),Item.ANY);
    if (inputs[i].isRequired() && values.length == 0) {
      addErrorField(request,getFieldName(inputs[i]));
    }
  }
  subInfo.getSubmissionItem().update();
  context.commit();
  if (moreInput) {
    return STATUS_MORE_INPUT_REQUESTED;
  }
 else   if (getErrorFields(request) != null && getErrorFields(request).size() > 0) {
    return STATUS_MISSING_REQUIRED_FIELDS;
  }
  return STATUS_COMPLETE;
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  int currentPage=getCurrentPage(request);
  Collection c=subInfo.getSubmissionItem().getCollection();
  DCInput[] inputs=inputsReader.getInputs(c.getHandle()).getPageRows(currentPage - 1,subInfo.getSubmissionItem().hasMultipleTitles(),subInfo.getSubmissionItem().isPublishedBefore());
  for (int i=0; i < inputs.length; i++) {
    String qualifier=inputs[i].getQualifier();
    if (qualifier == null && inputs[i].getInputType().equals(""String_Node_Str"")) {
      qualifier=Item.ANY;
    }
    item.clearMetadata(inputs[i].getSchema(),inputs[i].getElement(),qualifier,Item.ANY);
  }
  String fieldName;
  boolean moreInput=false;
  for (int j=0; j < inputs.length; j++) {
    String element=inputs[j].getElement();
    String qualifier=inputs[j].getQualifier();
    String schema=inputs[j].getSchema();
    if (qualifier != null && !qualifier.equals(Item.ANY)) {
      fieldName=schema + ""String_Node_Str"" + element+ '_'+ qualifier;
    }
 else {
      fieldName=schema + ""String_Node_Str"" + element;
    }
    String inputType=inputs[j].getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      readNames(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readDate(request,item,schema,element,qualifier);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readSeriesNumbers(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      List quals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      List vals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      for (int z=0; z < vals.size(); z++) {
        String thisQual=(String)quals.get(z);
        if (""String_Node_Str"".equals(thisQual)) {
          thisQual=null;
        }
        String thisVal=(String)vals.get(z);
        if (!buttonPressed.equals(""String_Node_Str"" + schema + ""String_Node_Str""+ element+ ""String_Node_Str""+ z) && !thisVal.equals(""String_Node_Str"")) {
          item.addMetadata(schema,element,thisQual,null,thisVal);
        }
      }
    }
 else     if (inputType.equals(""String_Node_Str"") || inputType.equals(""String_Node_Str"")) {
      String[] vals=request.getParameterValues(fieldName);
      if (vals != null) {
        for (int z=0; z < vals.length; z++) {
          if (!vals[z].equals(""String_Node_Str"")) {
            item.addMetadata(schema,element,qualifier,LANGUAGE_QUALIFIER,vals[z]);
          }
        }
      }
    }
 else     if ((inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str""))) {
      readText(request,item,schema,element,qualifier,inputs[j].getRepeatable(),LANGUAGE_QUALIFIER);
    }
 else {
      throw new ServletException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ inputType);
    }
    if (!moreInput && buttonPressed.equals(""String_Node_Str"" + fieldName + ""String_Node_Str"")) {
      subInfo.setMoreBoxesFor(fieldName);
      subInfo.setJumpToField(fieldName);
      moreInput=true;
    }
  }
  if (buttonPressed.equals(NEXT_BUTTON) || buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    clearErrorFields(request);
    for (int i=0; i < inputs.length; i++) {
      DCValue[] values=item.getMetadata(inputs[i].getSchema(),inputs[i].getElement(),inputs[i].getQualifier(),Item.ANY);
      if (inputs[i].isRequired() && values.length == 0) {
        addErrorField(request,getFieldName(inputs[i]));
      }
    }
  }
  subInfo.getSubmissionItem().update();
  context.commit();
  if (moreInput) {
    return STATUS_MORE_INPUT_REQUESTED;
  }
 else   if (getErrorFields(request) != null && getErrorFields(request).size() > 0) {
    return STATUS_MISSING_REQUIRED_FIELDS;
  }
  return STATUS_COMPLETE;
}",0.9870993751259828
3315,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  WorkspaceItemDAO wsiDAO=WorkspaceItemDAOFactory.getInstance(context);
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  int currentPage=getCurrentPage(request);
  Collection c=subInfo.getSubmissionItem().getCollection();
  DCInput[] inputs=inputsReader.getInputs(c.getIdentifier().getCanonicalForm()).getPageRows(currentPage - 1,subInfo.getSubmissionItem().hasMultipleTitles(),subInfo.getSubmissionItem().isPublishedBefore());
  for (int i=0; i < inputs.length; i++) {
    String qualifier=inputs[i].getQualifier();
    if (qualifier == null && inputs[i].getInputType().equals(""String_Node_Str"")) {
      qualifier=Item.ANY;
    }
    item.clearMetadata(inputs[i].getSchema(),inputs[i].getElement(),qualifier,Item.ANY);
  }
  String fieldName;
  boolean moreInput=false;
  for (int j=0; j < inputs.length; j++) {
    String element=inputs[j].getElement();
    String qualifier=inputs[j].getQualifier();
    String schema=inputs[j].getSchema();
    if (qualifier != null && !qualifier.equals(Item.ANY)) {
      fieldName=schema + ""String_Node_Str"" + element+ '_'+ qualifier;
    }
 else {
      fieldName=schema + ""String_Node_Str"" + element;
    }
    String inputType=inputs[j].getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      readNames(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readDate(request,item,schema,element,qualifier);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readSeriesNumbers(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      List quals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      List vals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      for (int z=0; z < vals.size(); z++) {
        String thisQual=(String)quals.get(z);
        if (""String_Node_Str"".equals(thisQual)) {
          thisQual=null;
        }
        String thisVal=(String)vals.get(z);
        if (!buttonPressed.equals(""String_Node_Str"" + schema + ""String_Node_Str""+ element+ ""String_Node_Str""+ z) && !thisVal.equals(""String_Node_Str"")) {
          item.addMetadata(schema,element,thisQual,null,thisVal);
        }
      }
    }
 else     if (inputType.equals(""String_Node_Str"") || inputType.equals(""String_Node_Str"")) {
      String[] vals=request.getParameterValues(fieldName);
      if (vals != null) {
        for (int z=0; z < vals.length; z++) {
          if (!vals[z].equals(""String_Node_Str"")) {
            item.addMetadata(schema,element,qualifier,""String_Node_Str"",vals[z]);
          }
        }
      }
    }
 else     if ((inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str""))) {
      readText(request,item,schema,element,qualifier,inputs[j].getRepeatable(),""String_Node_Str"");
    }
 else {
      throw new ServletException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ inputType);
    }
    if (!moreInput && buttonPressed.equals(""String_Node_Str"" + fieldName + ""String_Node_Str"")) {
      subInfo.setMoreBoxesFor(fieldName);
      subInfo.setJumpToField(fieldName);
      moreInput=true;
    }
  }
  clearErrorFields(request);
  for (int i=0; i < inputs.length; i++) {
    DCValue[] values=item.getMetadata(inputs[i].getSchema(),inputs[i].getElement(),inputs[i].getQualifier(),Item.ANY);
    if (inputs[i].isRequired() && values.length == 0) {
      addErrorField(request,getFieldName(inputs[i]));
    }
  }
  wsiDAO.update((WorkspaceItem)subInfo.getSubmissionItem());
  context.commit();
  if (moreInput) {
    return STATUS_MORE_INPUT_REQUESTED;
  }
 else   if (getErrorFields(request) != null && getErrorFields(request).size() > 0) {
    return STATUS_MISSING_REQUIRED_FIELDS;
  }
  return STATUS_COMPLETE;
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  WorkspaceItemDAO wsiDAO=WorkspaceItemDAOFactory.getInstance(context);
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  int currentPage=getCurrentPage(request);
  Collection c=subInfo.getSubmissionItem().getCollection();
  DCInput[] inputs=inputsReader.getInputs(c.getIdentifier().getCanonicalForm()).getPageRows(currentPage - 1,subInfo.getSubmissionItem().hasMultipleTitles(),subInfo.getSubmissionItem().isPublishedBefore());
  for (int i=0; i < inputs.length; i++) {
    String qualifier=inputs[i].getQualifier();
    if (qualifier == null && inputs[i].getInputType().equals(""String_Node_Str"")) {
      qualifier=Item.ANY;
    }
    item.clearMetadata(inputs[i].getSchema(),inputs[i].getElement(),qualifier,Item.ANY);
  }
  String fieldName;
  boolean moreInput=false;
  for (int j=0; j < inputs.length; j++) {
    String element=inputs[j].getElement();
    String qualifier=inputs[j].getQualifier();
    String schema=inputs[j].getSchema();
    if (qualifier != null && !qualifier.equals(Item.ANY)) {
      fieldName=schema + ""String_Node_Str"" + element+ '_'+ qualifier;
    }
 else {
      fieldName=schema + ""String_Node_Str"" + element;
    }
    String inputType=inputs[j].getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      readNames(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readDate(request,item,schema,element,qualifier);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      readSeriesNumbers(request,item,schema,element,qualifier,inputs[j].getRepeatable());
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      List quals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      List vals=getRepeatedParameter(request,schema + ""String_Node_Str"" + element,schema + ""String_Node_Str"" + element+ ""String_Node_Str"");
      for (int z=0; z < vals.size(); z++) {
        String thisQual=(String)quals.get(z);
        if (""String_Node_Str"".equals(thisQual)) {
          thisQual=null;
        }
        String thisVal=(String)vals.get(z);
        if (!buttonPressed.equals(""String_Node_Str"" + schema + ""String_Node_Str""+ element+ ""String_Node_Str""+ z) && !thisVal.equals(""String_Node_Str"")) {
          item.addMetadata(schema,element,thisQual,null,thisVal);
        }
      }
    }
 else     if (inputType.equals(""String_Node_Str"") || inputType.equals(""String_Node_Str"")) {
      String[] vals=request.getParameterValues(fieldName);
      if (vals != null) {
        for (int z=0; z < vals.length; z++) {
          if (!vals[z].equals(""String_Node_Str"")) {
            item.addMetadata(schema,element,qualifier,""String_Node_Str"",vals[z]);
          }
        }
      }
    }
 else     if ((inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str"")) || (inputType.equals(""String_Node_Str""))) {
      readText(request,item,schema,element,qualifier,inputs[j].getRepeatable(),""String_Node_Str"");
    }
 else {
      throw new ServletException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ inputType);
    }
    if (!moreInput && buttonPressed.equals(""String_Node_Str"" + fieldName + ""String_Node_Str"")) {
      subInfo.setMoreBoxesFor(fieldName);
      subInfo.setJumpToField(fieldName);
      moreInput=true;
    }
  }
  if (buttonPressed.equals(NEXT_BUTTON) || buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    clearErrorFields(request);
    for (int i=0; i < inputs.length; i++) {
      DCValue[] values=item.getMetadata(inputs[i].getSchema(),inputs[i].getElement(),inputs[i].getQualifier(),Item.ANY);
      if (inputs[i].isRequired() && values.length == 0) {
        addErrorField(request,getFieldName(inputs[i]));
      }
    }
  }
  wsiDAO.update((WorkspaceItem)subInfo.getSubmissionItem());
  context.commit();
  if (moreInput) {
    return STATUS_MORE_INPUT_REQUESTED;
  }
 else   if (getErrorFields(request) != null && getErrorFields(request).size() > 0) {
    return STATUS_MISSING_REQUIRED_FIELDS;
  }
  return STATUS_COMPLETE;
}",0.9873891625615764
3316,"/** 
 * Get repeated values from a form. If ""foo"" is passed in as the parameter, values in the form of parameters ""foo"", ""foo_1"", ""foo_2"", etc. are returned. <P> This method can also handle ""composite fields"" (metadata fields which may require multiple params, etc. a first name and last name).
 * @param request the HTTP request containing the form information
 * @param metadataField the metadata field which can store repeated values
 * @param param the repeated parameter on the page (used to fill out the metadataField)
 * @return a List of Strings
 */
protected List getRepeatedParameter(HttpServletRequest request,String metadataField,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  log.debug(""String_Node_Str"" + metadataField + ""String_Node_Str""+ metadataField);
  while (!foundLast) {
    String s=null;
    if (i == 0)     s=request.getParameter(param);
 else     s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      boolean addValue=true;
      String[] selected=request.getParameterValues(metadataField + ""String_Node_Str"");
      if (selected != null) {
        for (int j=0; j < selected.length; j++) {
          if (selected[j].equals(metadataField + ""String_Node_Str"" + i)) {
            addValue=false;
          }
        }
      }
      if (addValue)       vals.add(s.trim());
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}","/** 
 * Get repeated values from a form. If ""foo"" is passed in as the parameter, values in the form of parameters ""foo"", ""foo_1"", ""foo_2"", etc. are returned. <P> This method can also handle ""composite fields"" (metadata fields which may require multiple params, etc. a first name and last name).
 * @param request the HTTP request containing the form information
 * @param metadataField the metadata field which can store repeated values
 * @param param the repeated parameter on the page (used to fill out the metadataField)
 * @return a List of Strings
 */
protected List getRepeatedParameter(HttpServletRequest request,String metadataField,String param){
  List vals=new LinkedList();
  int i=1;
  boolean foundLast=false;
  log.debug(""String_Node_Str"" + metadataField + ""String_Node_Str""+ metadataField);
  while (!foundLast) {
    String s=null;
    s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s == null) {
      s=request.getParameter(param);
      foundLast=true;
    }
    if (s != null) {
      boolean addValue=true;
      String[] selected=request.getParameterValues(metadataField + ""String_Node_Str"");
      if (selected != null) {
        for (int j=0; j < selected.length; j++) {
          if (selected[j].equals(metadataField + ""String_Node_Str"" + i)) {
            addValue=false;
          }
        }
      }
      if (addValue)       vals.add(s.trim());
    }
    i++;
  }
  return vals;
}",0.9282966072053166
3317,"/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}","/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    if (encodedString.contains(""String_Node_Str"")) {
      encodedString=encodedString.replace(""String_Node_Str"",""String_Node_Str"");
    }
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}",0.8580183861082737
3318,"/** 
 * Create both the bitstreams and the contents file. Any bitstreams that were originally registered will be marked in the contents file as such. However, the export directory will contain actual copies of the content files being exported.
 * @param c the DSpace context
 * @param i the item being exported
 * @param destDir the item's export directory
 * @throws Exception if there is any problem writing to the export directory
 */
private static void writeBitstreams(Context c,Item i,File destDir) throws Exception {
  File outFile=new File(destDir,""String_Node_Str"");
  if (outFile.createNewFile()) {
    PrintWriter out=new PrintWriter(new FileWriter(outFile));
    Bundle[] bundles=i.getBundles();
    for (int j=0; j < bundles.length; j++) {
      Bitstream[] bitstreams=bundles[j].getBitstreams();
      String bundleName=bundles[j].getName();
      for (int k=0; k < bitstreams.length; k++) {
        Bitstream b=bitstreams[k];
        String myName=b.getName();
        String oldName=myName;
        int myPrefix=1;
        InputStream is=b.retrieve();
        boolean isDone=false;
        while (!isDone) {
          File fout=new File(destDir,myName);
          if (fout.createNewFile()) {
            FileOutputStream fos=new FileOutputStream(fout);
            Utils.bufferedCopy(is,fos);
            is.close();
            fos.close();
            if (b.isRegisteredBitstream()) {
              out.println(""String_Node_Str"" + b.getStoreNumber() + ""String_Node_Str""+ myName+ ""String_Node_Str""+ bundleName);
            }
 else {
              out.println(myName + ""String_Node_Str"" + bundleName);
            }
            isDone=true;
          }
 else {
            myName=myPrefix + ""String_Node_Str"" + oldName;
            myPrefix++;
          }
        }
      }
    }
    out.close();
  }
 else {
    throw new Exception(""String_Node_Str"" + destDir);
  }
}","/** 
 * Create both the bitstreams and the contents file. Any bitstreams that were originally registered will be marked in the contents file as such. However, the export directory will contain actual copies of the content files being exported.
 * @param c the DSpace context
 * @param i the item being exported
 * @param destDir the item's export directory
 * @throws Exception if there is any problem writing to the export directory
 */
private static void writeBitstreams(Context c,Item i,File destDir) throws Exception {
  File outFile=new File(destDir,""String_Node_Str"");
  if (outFile.createNewFile()) {
    PrintWriter out=new PrintWriter(new FileWriter(outFile));
    Bundle[] bundles=i.getBundles();
    for (int j=0; j < bundles.length; j++) {
      Bitstream[] bitstreams=bundles[j].getBitstreams();
      String bundleName=bundles[j].getName();
      for (int k=0; k < bitstreams.length; k++) {
        Bitstream b=bitstreams[k];
        String myName=b.getName();
        String oldName=myName;
        int myPrefix=1;
        InputStream is=b.retrieve();
        boolean isDone=false;
        while (!isDone) {
          if (myName.contains(File.separator)) {
            String dirs=myName.substring(0,myName.lastIndexOf(File.separator));
            File fdirs=new File(destDir + File.separator + dirs);
            fdirs.mkdirs();
          }
          File fout=new File(destDir,myName);
          if (fout.createNewFile()) {
            FileOutputStream fos=new FileOutputStream(fout);
            Utils.bufferedCopy(is,fos);
            is.close();
            fos.close();
            if (b.isRegisteredBitstream()) {
              out.println(""String_Node_Str"" + b.getStoreNumber() + ""String_Node_Str""+ myName+ ""String_Node_Str""+ bundleName);
            }
 else {
              out.println(myName + ""String_Node_Str"" + bundleName);
            }
            isDone=true;
          }
 else {
            myName=myPrefix + ""String_Node_Str"" + oldName;
            myPrefix++;
          }
        }
      }
    }
    out.close();
  }
 else {
    throw new Exception(""String_Node_Str"" + destDir);
  }
}",0.9413233458177278
3319,"/** 
 * Get the file size of the export archive represented by the file name
 * @param fileName name of the file to get the size
 * @param eperson the eperson requesting file
 * @return
 * @throws Exception
 */
public static long getExportFileSize(String fileName) throws Exception {
  String strID=fileName.substring(fileName.lastIndexOf('_') + 1,fileName.lastIndexOf('.'));
  File file=new File(getExportDownloadDirectory(Integer.parseInt(strID)) + System.getProperty(""String_Node_Str"") + fileName);
  if (!file.exists() || !file.isFile()) {
    throw new FileNotFoundException(""String_Node_Str"" + getExportDownloadDirectory(Integer.parseInt(strID)) + System.getProperty(""String_Node_Str"")+ fileName+ ""String_Node_Str"");
  }
  return file.length();
}","/** 
 * Get the file size of the export archive represented by the file name
 * @param fileName name of the file to get the size
 * @return
 * @throws Exception
 */
public static long getExportFileSize(String fileName) throws Exception {
  String strID=fileName.substring(fileName.lastIndexOf('_') + 1,fileName.lastIndexOf('.'));
  File file=new File(getExportDownloadDirectory(Integer.parseInt(strID)) + System.getProperty(""String_Node_Str"") + fileName);
  if (!file.exists() || !file.isFile()) {
    throw new FileNotFoundException(""String_Node_Str"" + getExportDownloadDirectory(Integer.parseInt(strID)) + System.getProperty(""String_Node_Str"")+ fileName+ ""String_Node_Str"");
  }
  return file.length();
}",0.9684499314128944
3320,"/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send an error email if the export archive fails
 * @param toMail -email to send message to
 * @param fromMail -email for the from field
 * @param ccMail -carbon copy email
 * @param fileName -the file name to be downloaded. It is added to the url in the email
 * @throws MessagingException
 */
public static void emailErrorMessage(String toMail,String fromMail,String ccMail,String error) throws MessagingException {
  StringBuffer content=new StringBuffer();
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(error);
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  sendMessage(toMail,fromMail,ccMail,""String_Node_Str"",content);
}","/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send an error email if the export archive fails
 * @param toMail -email to send message to
 * @param fromMail -email for the from field
 * @param ccMail -carbon copy email
 * @param error -the error message
 * @throws MessagingException
 */
public static void emailErrorMessage(String toMail,String fromMail,String ccMail,String error) throws MessagingException {
  StringBuffer content=new StringBuffer();
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(error);
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  sendMessage(toMail,fromMail,ccMail,""String_Node_Str"",content);
}",0.9627459187944748
3321,"public void run(){
  Context context;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setIgnoreAuthorization(true);
    iitems=new ItemIterator(context,items);
    String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
    String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
    String downloadDir=getExportDownloadDirectory(eperson.getID());
    File wkDir=new File(workDir);
    if (!wkDir.exists()) {
      wkDir.mkdirs();
    }
    File dnDir=new File(downloadDir);
    if (!dnDir.exists()) {
      dnDir.mkdirs();
    }
    exportItem(context,iitems,workDir,1);
    zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
    emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new RuntimeException(e1);
  }
 finally {
    if (iitems != null)     iitems.close();
  }
}","public void run(){
  Context context=null;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setIgnoreAuthorization(true);
    iitems=new ItemIterator(context,items);
    String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
    String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
    String downloadDir=getExportDownloadDirectory(eperson.getID());
    File wkDir=new File(workDir);
    if (!wkDir.exists()) {
      wkDir.mkdirs();
    }
    File dnDir=new File(downloadDir);
    if (!dnDir.exists()) {
      dnDir.mkdirs();
    }
    exportItem(context,iitems,workDir,1);
    zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
    emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new RuntimeException(e1);
  }
 finally {
    if (iitems != null)     iitems.close();
    try {
      context.complete();
    }
 catch (    SQLException sqle) {
      context.abort();
    }
  }
}",0.9525468001741402
3322,"/** 
 * Does the work creating a List with all the Items in the Community or Collection It then kicks off a new Thread to export the items, zip the export directory and send confirmation email
 * @param dsObjects - List of dspace objects to process
 * @param context - the dspace context
 * @param additionalEmail - email address to cc in addition the the current user email
 * @throws Exception
 */
private static void processDownloadableExport(List<DSpaceObject> dsObjects,Context context,final String additionalEmail) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  deleteOldExportArchives(eperson.getID());
  float size=0;
  final ArrayList<Integer> items=new ArrayList<Integer>();
  for (  DSpaceObject dso : dsObjects) {
    if (dso.getType() == Constants.COMMUNITY) {
      Community community=(Community)dso;
      Collection[] collections=community.getCollections();
      for (      Collection collection : collections) {
        ItemIterator iitems=collection.getItems();
        try {
          while (iitems.hasNext()) {
            Item item=iitems.next();
            Bundle[] bundles=item.getBundles();
            for (            Bundle bundle : bundles) {
              Bitstream[] bitstreams=bundle.getBitstreams();
              for (              Bitstream bit : bitstreams) {
                size+=bit.getSize();
              }
            }
            items.add(item.getID());
          }
        }
  finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
 else     if (dso.getType() == Constants.COLLECTION) {
      Collection collection=(Collection)dso;
      ItemIterator iitems=collection.getItems();
      try {
        while (iitems.hasNext()) {
          Item item=iitems.next();
          Bundle[] bundles=item.getBundles();
          for (          Bundle bundle : bundles) {
            Bitstream[] bitstreams=bundle.getBitstreams();
            for (            Bitstream bit : bitstreams) {
              size+=bit.getSize();
            }
          }
          items.add(item.getID());
        }
      }
  finally {
        if (iitems != null)         iitems.close();
      }
    }
 else     if (dso.getType() == Constants.ITEM) {
      Item item=(Item)dso;
      Bundle[] bundles=item.getBundles();
      for (      Bundle bundle : bundles) {
        Bitstream[] bitstreams=bundle.getBitstreams();
        for (        Bitstream bit : bitstreams) {
          size+=bit.getSize();
        }
      }
      items.add(item.getID());
    }
 else {
    }
  }
  String megaBytes=ConfigurationManager.getProperty(""String_Node_Str"");
  if (megaBytes != null) {
    float maxSize=0;
    try {
      maxSize=Float.parseFloat(megaBytes);
    }
 catch (    Exception e) {
    }
    if (maxSize > 0) {
      if (maxSize < (size / 1048576.00)) {
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  if (items.size() > 0) {
    Thread go=new Thread(){
      public void run(){
        Context context;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setIgnoreAuthorization(true);
          iitems=new ItemIterator(context,items);
          String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
          String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
          String downloadDir=getExportDownloadDirectory(eperson.getID());
          File wkDir=new File(workDir);
          if (!wkDir.exists()) {
            wkDir.mkdirs();
          }
          File dnDir=new File(downloadDir);
          if (!dnDir.exists()) {
            dnDir.mkdirs();
          }
          exportItem(context,iitems,workDir,1);
          zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
          emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new RuntimeException(e1);
        }
 finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
}","/** 
 * Does the work creating a List with all the Items in the Community or Collection It then kicks off a new Thread to export the items, zip the export directory and send confirmation email
 * @param dsObjects - List of dspace objects to process
 * @param context - the dspace context
 * @param additionalEmail - email address to cc in addition the the current user email
 * @throws Exception
 */
private static void processDownloadableExport(List<DSpaceObject> dsObjects,Context context,final String additionalEmail) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  deleteOldExportArchives(eperson.getID());
  float size=0;
  final ArrayList<Integer> items=new ArrayList<Integer>();
  for (  DSpaceObject dso : dsObjects) {
    if (dso.getType() == Constants.COMMUNITY) {
      Community community=(Community)dso;
      Collection[] collections=community.getCollections();
      for (      Collection collection : collections) {
        ItemIterator iitems=collection.getItems();
        try {
          while (iitems.hasNext()) {
            Item item=iitems.next();
            Bundle[] bundles=item.getBundles();
            for (            Bundle bundle : bundles) {
              Bitstream[] bitstreams=bundle.getBitstreams();
              for (              Bitstream bit : bitstreams) {
                size+=bit.getSize();
              }
            }
            items.add(item.getID());
          }
        }
  finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
 else     if (dso.getType() == Constants.COLLECTION) {
      Collection collection=(Collection)dso;
      ItemIterator iitems=collection.getItems();
      try {
        while (iitems.hasNext()) {
          Item item=iitems.next();
          Bundle[] bundles=item.getBundles();
          for (          Bundle bundle : bundles) {
            Bitstream[] bitstreams=bundle.getBitstreams();
            for (            Bitstream bit : bitstreams) {
              size+=bit.getSize();
            }
          }
          items.add(item.getID());
        }
      }
  finally {
        if (iitems != null)         iitems.close();
      }
    }
 else     if (dso.getType() == Constants.ITEM) {
      Item item=(Item)dso;
      Bundle[] bundles=item.getBundles();
      for (      Bundle bundle : bundles) {
        Bitstream[] bitstreams=bundle.getBitstreams();
        for (        Bitstream bit : bitstreams) {
          size+=bit.getSize();
        }
      }
      items.add(item.getID());
    }
 else {
    }
  }
  String megaBytes=ConfigurationManager.getProperty(""String_Node_Str"");
  if (megaBytes != null) {
    float maxSize=0;
    try {
      maxSize=Float.parseFloat(megaBytes);
    }
 catch (    Exception e) {
    }
    if (maxSize > 0) {
      if (maxSize < (size / 1048576.00)) {
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  if (items.size() > 0) {
    Thread go=new Thread(){
      public void run(){
        Context context=null;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setIgnoreAuthorization(true);
          iitems=new ItemIterator(context,items);
          String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
          String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
          String downloadDir=getExportDownloadDirectory(eperson.getID());
          File wkDir=new File(workDir);
          if (!wkDir.exists()) {
            wkDir.mkdirs();
          }
          File dnDir=new File(downloadDir);
          if (!dnDir.exists()) {
            dnDir.mkdirs();
          }
          exportItem(context,iitems,workDir,1);
          zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
          emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new RuntimeException(e1);
        }
 finally {
          if (iitems != null)           iitems.close();
          try {
            context.complete();
          }
 catch (          SQLException sqle) {
            context.abort();
          }
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
}",0.9834266773345524
3323,"/** 
 * Get repeated values from a form. If ""foo"" is passed in as the parameter, values in the form of parameters ""foo"", ""foo_1"", ""foo_2"", etc. are returned. <P> This method can also handle ""composite fields"" (metadata fields which may require multiple params, etc. a first name and last name).
 * @param request the HTTP request containing the form information
 * @param metadataField the metadata field which can store repeated values
 * @param param the repeated parameter on the page (used to fill out the metadataField)
 * @return a List of Strings
 */
protected List getRepeatedParameter(HttpServletRequest request,String metadataField,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  log.debug(""String_Node_Str"" + metadataField + ""String_Node_Str""+ metadataField);
  while (!foundLast) {
    String s=null;
    if (i == 0)     s=request.getParameter(param);
 else     s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      boolean addValue=true;
      String[] selected=request.getParameterValues(metadataField + ""String_Node_Str"");
      if (selected != null) {
        for (int j=0; j < selected.length; j++) {
          if (selected[j].equals(metadataField + ""String_Node_Str"" + i)) {
            addValue=false;
          }
        }
      }
      if (addValue)       vals.add(s.trim());
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}","/** 
 * Get repeated values from a form. If ""foo"" is passed in as the parameter, values in the form of parameters ""foo"", ""foo_1"", ""foo_2"", etc. are returned. <P> This method can also handle ""composite fields"" (metadata fields which may require multiple params, etc. a first name and last name).
 * @param request the HTTP request containing the form information
 * @param metadataField the metadata field which can store repeated values
 * @param param the repeated parameter on the page (used to fill out the metadataField)
 * @return a List of Strings
 */
protected List getRepeatedParameter(HttpServletRequest request,String metadataField,String param){
  List vals=new LinkedList();
  int i=1;
  boolean foundLast=false;
  log.debug(""String_Node_Str"" + metadataField + ""String_Node_Str""+ metadataField);
  while (!foundLast) {
    String s=null;
    s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s == null) {
      s=request.getParameter(param);
      foundLast=true;
    }
    if (s != null) {
      boolean addValue=true;
      String[] selected=request.getParameterValues(metadataField + ""String_Node_Str"");
      if (selected != null) {
        for (int j=0; j < selected.length; j++) {
          if (selected[j].equals(metadataField + ""String_Node_Str"" + i)) {
            addValue=false;
          }
        }
      }
      if (addValue)       vals.add(s.trim());
    }
    i++;
  }
  return vals;
}",0.9282966072053166
3324,"/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}","/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    if (encodedString.contains(""String_Node_Str"")) {
      encodedString=encodedString.replace(""String_Node_Str"",""String_Node_Str"");
    }
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}",0.8580183861082737
3325,"/** 
 * What to add at the end of the body 
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.bodyEmpty) {
    Division notFound=body.addDivision(""String_Node_Str"",""String_Node_Str"");
    notFound.setHead(T_head);
    notFound.addPara(T_para1);
    notFound.addPara().addXref(contextPath,T_go_home);
  }
}","/** 
 * What to add at the end of the body 
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.bodyEmpty) {
    Division notFound=body.addDivision(""String_Node_Str"",""String_Node_Str"");
    notFound.setHead(T_head);
    notFound.addPara(T_para1);
    notFound.addPara().addXref(contextPath,T_go_home);
    HttpServletResponse response=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
    response.setStatus(HttpServletResponse.SC_NOT_FOUND);
  }
}",0.8265835929387332
3326,"/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send a success email once the export archive is complete and ready for download
 * @param toMail - email to send message to
 * @param fromMail - email for the from field
 * @param ccMail - carbon copy email
 * @param fileName - the file name to be downloaded. It is added to the url in the email
 * @throws MessagingException
 */
public static void emailSuccessMessage(String toMail,String fromMail,String ccMail,String fileName) throws MessagingException {
  StringBuffer content=new StringBuffer();
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(ConfigurationManager.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(fileName);
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(ConfigurationManager.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  sendMessage(toMail,fromMail,ccMail,""String_Node_Str"",content);
}","/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send a success email once the export archive is complete and ready for download
 * @param context - the current Context
 * @param eperson - eperson to send the email to
 * @param fileName - the file name to be downloaded. It is added to the url in the email
 * @throws MessagingException
 */
public static void emailSuccessMessage(Context context,EPerson eperson,String fileName) throws MessagingException {
  try {
    Locale supportedLocale=I18nUtil.getEPersonLocale(eperson);
    Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(supportedLocale,""String_Node_Str""));
    email.addRecipient(eperson.getEmail());
    email.addArgument(ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"" + fileName);
    email.addArgument(ConfigurationManager.getProperty(""String_Node_Str""));
    email.send();
  }
 catch (  Exception e) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),e);
  }
}",0.47976011994003
3327,"public void run(){
  Context context;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setIgnoreAuthorization(true);
    iitems=new ItemIterator(context,items);
    String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
    String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
    String downloadDir=getExportDownloadDirectory(eperson.getID());
    File wkDir=new File(workDir);
    if (!wkDir.exists()) {
      wkDir.mkdirs();
    }
    File dnDir=new File(downloadDir);
    if (!dnDir.exists()) {
      dnDir.mkdirs();
    }
    exportItem(context,iitems,workDir,1);
    zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
    emailSuccessMessage(eperson.getEmail(),ConfigurationManager.getProperty(""String_Node_Str""),additionalEmail,fileName + ""String_Node_Str"");
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson.getEmail(),ConfigurationManager.getProperty(""String_Node_Str""),additionalEmail,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new RuntimeException(e1);
  }
 finally {
    if (iitems != null)     iitems.close();
  }
}","public void run(){
  Context context;
  ItemIterator iitems=null;
  try {
    context=new Context();
    context.setIgnoreAuthorization(true);
    iitems=new ItemIterator(context,items);
    String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
    String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
    String downloadDir=getExportDownloadDirectory(eperson.getID());
    File wkDir=new File(workDir);
    if (!wkDir.exists()) {
      wkDir.mkdirs();
    }
    File dnDir=new File(downloadDir);
    if (!dnDir.exists()) {
      dnDir.mkdirs();
    }
    exportItem(context,iitems,workDir,1);
    zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
    emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
    context.setIgnoreAuthorization(false);
  }
 catch (  Exception e1) {
    try {
      emailErrorMessage(eperson,e1.getMessage());
    }
 catch (    Exception e) {
    }
    throw new RuntimeException(e1);
  }
 finally {
    if (iitems != null)     iitems.close();
  }
}",0.9153122326775022
3328,"/** 
 * Does the work creating a List with all the Items in the Community or Collection It then kicks off a new Thread to export the items, zip the export directory and send confirmation email
 * @param dsObjects - List of dspace objects to process
 * @param context - the dspace context
 * @param additionalEmail - email address to cc in addition the the current user email
 * @throws Exception
 */
private static void processDownloadableExport(List<DSpaceObject> dsObjects,Context context,final String additionalEmail) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  deleteOldExportArchives(eperson.getID());
  float size=0;
  final ArrayList<Integer> items=new ArrayList<Integer>();
  for (  DSpaceObject dso : dsObjects) {
    if (dso.getType() == Constants.COMMUNITY) {
      Community community=(Community)dso;
      Collection[] collections=community.getCollections();
      for (      Collection collection : collections) {
        ItemIterator iitems=collection.getItems();
        try {
          while (iitems.hasNext()) {
            Item item=iitems.next();
            Bundle[] bundles=item.getBundles();
            for (            Bundle bundle : bundles) {
              Bitstream[] bitstreams=bundle.getBitstreams();
              for (              Bitstream bit : bitstreams) {
                size+=bit.getSize();
              }
            }
            items.add(item.getID());
          }
        }
  finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
 else     if (dso.getType() == Constants.COLLECTION) {
      Collection collection=(Collection)dso;
      ItemIterator iitems=collection.getItems();
      try {
        while (iitems.hasNext()) {
          Item item=iitems.next();
          Bundle[] bundles=item.getBundles();
          for (          Bundle bundle : bundles) {
            Bitstream[] bitstreams=bundle.getBitstreams();
            for (            Bitstream bit : bitstreams) {
              size+=bit.getSize();
            }
          }
          items.add(item.getID());
        }
      }
  finally {
        if (iitems != null)         iitems.close();
      }
    }
 else     if (dso.getType() == Constants.ITEM) {
      Item item=(Item)dso;
      Bundle[] bundles=item.getBundles();
      for (      Bundle bundle : bundles) {
        Bitstream[] bitstreams=bundle.getBitstreams();
        for (        Bitstream bit : bitstreams) {
          size+=bit.getSize();
        }
      }
      items.add(item.getID());
    }
 else {
    }
  }
  String megaBytes=ConfigurationManager.getProperty(""String_Node_Str"");
  if (megaBytes != null) {
    float maxSize=0;
    try {
      maxSize=Float.parseFloat(megaBytes);
    }
 catch (    Exception e) {
    }
    if (maxSize > 0) {
      if (maxSize < (size / 1048576.00)) {
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  if (items.size() > 0) {
    Thread go=new Thread(){
      public void run(){
        Context context;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setIgnoreAuthorization(true);
          iitems=new ItemIterator(context,items);
          String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
          String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
          String downloadDir=getExportDownloadDirectory(eperson.getID());
          File wkDir=new File(workDir);
          if (!wkDir.exists()) {
            wkDir.mkdirs();
          }
          File dnDir=new File(downloadDir);
          if (!dnDir.exists()) {
            dnDir.mkdirs();
          }
          exportItem(context,iitems,workDir,1);
          zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
          emailSuccessMessage(eperson.getEmail(),ConfigurationManager.getProperty(""String_Node_Str""),additionalEmail,fileName + ""String_Node_Str"");
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson.getEmail(),ConfigurationManager.getProperty(""String_Node_Str""),additionalEmail,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new RuntimeException(e1);
        }
 finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
}","/** 
 * Does the work creating a List with all the Items in the Community or Collection It then kicks off a new Thread to export the items, zip the export directory and send confirmation email
 * @param dsObjects - List of dspace objects to process
 * @param context - the dspace context
 * @param additionalEmail - email address to cc in addition the the current user email
 * @throws Exception
 */
private static void processDownloadableExport(List<DSpaceObject> dsObjects,Context context,final String additionalEmail) throws Exception {
  final EPerson eperson=context.getCurrentUser();
  deleteOldExportArchives(eperson.getID());
  float size=0;
  final ArrayList<Integer> items=new ArrayList<Integer>();
  for (  DSpaceObject dso : dsObjects) {
    if (dso.getType() == Constants.COMMUNITY) {
      Community community=(Community)dso;
      Collection[] collections=community.getCollections();
      for (      Collection collection : collections) {
        ItemIterator iitems=collection.getItems();
        try {
          while (iitems.hasNext()) {
            Item item=iitems.next();
            Bundle[] bundles=item.getBundles();
            for (            Bundle bundle : bundles) {
              Bitstream[] bitstreams=bundle.getBitstreams();
              for (              Bitstream bit : bitstreams) {
                size+=bit.getSize();
              }
            }
            items.add(item.getID());
          }
        }
  finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
 else     if (dso.getType() == Constants.COLLECTION) {
      Collection collection=(Collection)dso;
      ItemIterator iitems=collection.getItems();
      try {
        while (iitems.hasNext()) {
          Item item=iitems.next();
          Bundle[] bundles=item.getBundles();
          for (          Bundle bundle : bundles) {
            Bitstream[] bitstreams=bundle.getBitstreams();
            for (            Bitstream bit : bitstreams) {
              size+=bit.getSize();
            }
          }
          items.add(item.getID());
        }
      }
  finally {
        if (iitems != null)         iitems.close();
      }
    }
 else     if (dso.getType() == Constants.ITEM) {
      Item item=(Item)dso;
      Bundle[] bundles=item.getBundles();
      for (      Bundle bundle : bundles) {
        Bitstream[] bitstreams=bundle.getBitstreams();
        for (        Bitstream bit : bitstreams) {
          size+=bit.getSize();
        }
      }
      items.add(item.getID());
    }
 else {
    }
  }
  String megaBytes=ConfigurationManager.getProperty(""String_Node_Str"");
  if (megaBytes != null) {
    float maxSize=0;
    try {
      maxSize=Float.parseFloat(megaBytes);
    }
 catch (    Exception e) {
    }
    if (maxSize > 0) {
      if (maxSize < (size / 1048576.00)) {
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  if (items.size() > 0) {
    Thread go=new Thread(){
      public void run(){
        Context context;
        ItemIterator iitems=null;
        try {
          context=new Context();
          context.setIgnoreAuthorization(true);
          iitems=new ItemIterator(context,items);
          String fileName=assembleFileName(""String_Node_Str"",eperson,new Date());
          String workDir=getExportWorkDirectory() + System.getProperty(""String_Node_Str"") + fileName;
          String downloadDir=getExportDownloadDirectory(eperson.getID());
          File wkDir=new File(workDir);
          if (!wkDir.exists()) {
            wkDir.mkdirs();
          }
          File dnDir=new File(downloadDir);
          if (!dnDir.exists()) {
            dnDir.mkdirs();
          }
          exportItem(context,iitems,workDir,1);
          zip(workDir,downloadDir + System.getProperty(""String_Node_Str"") + fileName+ ""String_Node_Str"");
          emailSuccessMessage(context,eperson,fileName + ""String_Node_Str"");
          context.setIgnoreAuthorization(false);
        }
 catch (        Exception e1) {
          try {
            emailErrorMessage(eperson,e1.getMessage());
          }
 catch (          Exception e) {
          }
          throw new RuntimeException(e1);
        }
 finally {
          if (iitems != null)           iitems.close();
        }
      }
    }
;
    go.isDaemon();
    go.start();
  }
}",0.9789810372401188
3329,"/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send an error email if the export archive fails
 * @param toMail - email to send message to
 * @param fromMail - email for the from field
 * @param ccMail - carbon copy email
 * @param error - the error message
 * @throws MessagingException
 */
public static void emailErrorMessage(String toMail,String fromMail,String ccMail,String error) throws MessagingException {
  StringBuffer content=new StringBuffer();
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  content.append(error);
  content.append(System.getProperty(""String_Node_Str""));
  content.append(System.getProperty(""String_Node_Str""));
  content.append(""String_Node_Str"");
  sendMessage(toMail,fromMail,ccMail,""String_Node_Str"",content);
}","/** 
 * Since the archive is created in a new thread we are unable to communicate with calling method about success or failure. We accomplis this communication with email instead. Send an error email if the export archive fails
 * @param eperson - EPerson to send the error message to
 * @param error - the error message
 * @throws MessagingException
 */
public static void emailErrorMessage(EPerson eperson,String error) throws MessagingException {
  log.warn(""String_Node_Str"" + error);
  try {
    Locale supportedLocale=I18nUtil.getEPersonLocale(eperson);
    Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(supportedLocale,""String_Node_Str""));
    email.addRecipient(eperson.getEmail());
    email.addArgument(error);
    email.addArgument(ConfigurationManager.getProperty(""String_Node_Str"") + ""String_Node_Str"");
    email.send();
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"",e);
  }
}",0.4537654909437559
3330,"/** 
 * Add a single link to the view item page that allows the user  to submit to the collection.
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (!(dso instanceof Collection))   return;
  Collection collection=(Collection)dso;
  if (AuthorizeManager.authorizeActionBoolean(context,collection,Constants.ADD)) {
    Division home=body.addDivision(""String_Node_Str"",""String_Node_Str"");
    Division viewer=home.addDivision(""String_Node_Str"",""String_Node_Str"");
    String submitURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
    viewer.addPara().addXref(submitURL,""String_Node_Str"");
  }
}","/** 
 * Add a single link to the view item page that allows the user  to submit to the collection.
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (!(dso instanceof Collection))   return;
  Collection collection=(Collection)dso;
  if (AuthorizeManager.authorizeActionBoolean(context,collection,Constants.ADD)) {
    Division home=body.addDivision(""String_Node_Str"",""String_Node_Str"");
    Division viewer=home.addDivision(""String_Node_Str"",""String_Node_Str"");
    String submitURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
    viewer.addPara().addXref(submitURL,T_submit);
  }
}",0.9836280288146692
3331,"/** 
 * Sends an email to the given e-person with details of new items in the given collections, items that appeared yesterday. No e-mail is sent if there aren't any new items in any of the collections.
 * @param context DSpace context object
 * @param eperson eperson to send to
 * @param collections List of collection IDs (Integers)
 * @param test 
 */
public static void sendEmail(Context context,EPerson eperson,List collections,boolean test) throws IOException, MessagingException, SQLException {
  Locale supportedLocale=I18nUtil.getEPersonLocale(eperson);
  ResourceBundle labels=ResourceBundle.getBundle(""String_Node_Str"",supportedLocale);
  Date thisTimeYesterday=new Date(System.currentTimeMillis() - (24 * 60 * 60* 1000));
  DCDate dcDateYesterday=new DCDate(thisTimeYesterday);
  String isoDateYesterday=dcDateYesterday.toString().substring(0,10);
  String startDate=isoDateYesterday;
  String endDate=isoDateYesterday + ""String_Node_Str"";
  StringBuffer emailText=new StringBuffer();
  boolean isFirst=true;
  for (int i=0; i < collections.size(); i++) {
    Collection c=(Collection)collections.get(i);
    try {
      List itemInfos=Harvest.harvest(context,c,startDate,endDate,0,0,true,false,false);
      if (ConfigurationManager.getBooleanProperty(""String_Node_Str"",false)) {
        itemInfos=filterOutModified(itemInfos);
      }
      if (itemInfos.size() > 0) {
        if (!isFirst) {
          emailText.append(""String_Node_Str"");
        }
 else {
          isFirst=false;
        }
        emailText.append(labels.getString(""String_Node_Str"")).append(c.getMetadata(""String_Node_Str"")).append(""String_Node_Str"").append(itemInfos.size()).append(""String_Node_Str"");
        for (int j=0; j < itemInfos.size(); j++) {
          HarvestedItemInfo hii=(HarvestedItemInfo)itemInfos.get(j);
          DCValue[] titles=hii.item.getDC(""String_Node_Str"",null,Item.ANY);
          emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(""String_Node_Str"");
          if (titles.length > 0) {
            emailText.append(titles[0].value);
          }
 else {
            emailText.append(labels.getString(""String_Node_Str""));
          }
          DCValue[] authors=hii.item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
          if (authors.length > 0) {
            emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(authors[0].value);
            for (int k=1; k < authors.length; k++) {
              emailText.append(""String_Node_Str"").append(authors[k].value);
            }
          }
          emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(HandleManager.getCanonicalForm(hii.handle)).append(""String_Node_Str"");
        }
      }
    }
 catch (    ParseException pe) {
    }
  }
  if (emailText.length() > 0) {
    if (test) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + emailText.toString()));
    }
 else {
      Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(supportedLocale,""String_Node_Str""));
      email.addRecipient(eperson.getEmail());
      email.addArgument(emailText.toString());
      email.send();
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getID()));
    }
  }
}","/** 
 * Sends an email to the given e-person with details of new items in the given collections, items that appeared yesterday. No e-mail is sent if there aren't any new items in any of the collections.
 * @param context DSpace context object
 * @param eperson eperson to send to
 * @param collections List of collection IDs (Integers)
 * @param test 
 */
public static void sendEmail(Context context,EPerson eperson,List collections,boolean test) throws IOException, MessagingException, SQLException {
  Locale supportedLocale=I18nUtil.getEPersonLocale(eperson);
  ResourceBundle labels=ResourceBundle.getBundle(""String_Node_Str"",supportedLocale);
  Date thisTimeYesterday=new Date(System.currentTimeMillis() - (24 * 60 * 60* 1000));
  DCDate dcDateYesterday=new DCDate(thisTimeYesterday);
  String isoDateYesterday=dcDateYesterday.toString().substring(0,10);
  String startDate=isoDateYesterday;
  String endDate=isoDateYesterday + ""String_Node_Str"";
  StringBuffer emailText=new StringBuffer();
  boolean isFirst=true;
  for (int i=0; i < collections.size(); i++) {
    Collection c=(Collection)collections.get(i);
    try {
      boolean includeAll=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
      List itemInfos=Harvest.harvest(context,c,startDate,endDate,0,0,true,false,false,includeAll);
      if (ConfigurationManager.getBooleanProperty(""String_Node_Str"",false)) {
        itemInfos=filterOutModified(itemInfos);
      }
      if (itemInfos.size() > 0) {
        if (!isFirst) {
          emailText.append(""String_Node_Str"");
        }
 else {
          isFirst=false;
        }
        emailText.append(labels.getString(""String_Node_Str"")).append(c.getMetadata(""String_Node_Str"")).append(""String_Node_Str"").append(itemInfos.size()).append(""String_Node_Str"");
        for (int j=0; j < itemInfos.size(); j++) {
          HarvestedItemInfo hii=(HarvestedItemInfo)itemInfos.get(j);
          DCValue[] titles=hii.item.getDC(""String_Node_Str"",null,Item.ANY);
          emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(""String_Node_Str"");
          if (titles.length > 0) {
            emailText.append(titles[0].value);
          }
 else {
            emailText.append(labels.getString(""String_Node_Str""));
          }
          DCValue[] authors=hii.item.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
          if (authors.length > 0) {
            emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(authors[0].value);
            for (int k=1; k < authors.length; k++) {
              emailText.append(""String_Node_Str"").append(authors[k].value);
            }
          }
          emailText.append(""String_Node_Str"").append(labels.getString(""String_Node_Str"")).append(HandleManager.getCanonicalForm(hii.handle)).append(""String_Node_Str"");
        }
      }
    }
 catch (    ParseException pe) {
    }
  }
  if (emailText.length() > 0) {
    if (test) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + emailText.toString()));
    }
 else {
      Email email=ConfigurationManager.getEmail(I18nUtil.getEmailFilename(supportedLocale,""String_Node_Str""));
      email.addRecipient(eperson.getEmail());
      email.addArgument(emailText.toString());
      email.send();
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getID()));
    }
  }
}",0.9854319919226886
3332,"/** 
 * Obtain information about items that have been created, modified or withdrawn within a given date range. You can also specify 'offset' and 'limit' so that a big harvest can be split up into smaller sections. <P> Note that dates are passed in the standard ISO8601 format used by DSpace (and OAI-PMH). <P> FIXME: Assumes all in_archive items have public metadata
 * @param context DSpace context
 * @param scope a Collection, Community, or <code>null</code> indicating the scope is all of DSpace
 * @param startDate start of date range, or <code>null</code>
 * @param endDate end of date range, or <code>null</code>
 * @param offset for a partial harvest, the point in the overall list of matching items to start at. 0 means just start at the beginning.
 * @param limit the number of matching items to return in a partial harvest. Specify 0 to return the whole list (or the rest of the list if an offset was specified.)
 * @param items if <code>true</code> the <code>item</code> field of each <code>HarvestedItemInfo</code> object is filled out
 * @param collections if <code>true</code> the <code>collectionHandles</code> field of each <code>HarvestedItemInfo</code> object is filled out
 * @param withdrawn If <code>true</code>, information about withdrawn items is included
 * @return List of <code>HarvestedItemInfo</code> objects
 * @throws SQLException
 * @throws ParseException If the date is not in a supported format
 */
public static List harvest(Context context,DSpaceObject scope,String startDate,String endDate,int offset,int limit,boolean items,boolean collections,boolean withdrawn) throws SQLException, ParseException {
  String query=""String_Node_Str"";
  List parameters=new ArrayList();
  if (scope != null) {
    if (scope.getType() == Constants.COLLECTION) {
      query+=""String_Node_Str"";
    }
 else     if (scope.getType() == Constants.COMMUNITY) {
      query+=""String_Node_Str"";
    }
  }
  query+=""String_Node_Str"" + Constants.ITEM + ""String_Node_Str"";
  if (scope != null) {
    if (scope.getType() == Constants.COLLECTION) {
      query+=""String_Node_Str"" + ""String_Node_Str"";
      parameters.add(new Integer(scope.getID()));
    }
 else     if (scope.getType() == Constants.COMMUNITY) {
      query+=""String_Node_Str"" + ""String_Node_Str"";
      parameters.add(new Integer(scope.getID()));
    }
  }
  if (startDate != null) {
    query=query + ""String_Node_Str"";
    parameters.add(toTimestamp(startDate,false));
  }
  if (endDate != null) {
    boolean selfGenerated=false;
    if (endDate.length() == 20) {
      endDate=endDate.substring(0,19) + ""String_Node_Str"";
      selfGenerated=true;
    }
    query+=""String_Node_Str"";
    parameters.add(toTimestamp(endDate,selfGenerated));
  }
  if (withdrawn == false) {
    if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
      query+=""String_Node_Str"";
    }
 else {
      query+=""String_Node_Str"";
    }
  }
  query+=""String_Node_Str"";
  log.debug(LogManager.getHeader(context,""String_Node_Str"",query));
  Object[] parametersArray=parameters.toArray();
  TableRowIterator tri=DatabaseManager.query(context,query,parametersArray);
  List infoObjects=new LinkedList();
  int index=0;
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      if ((index >= offset) && ((limit == 0) || (index < (offset + limit)))) {
        HarvestedItemInfo itemInfo=new HarvestedItemInfo();
        itemInfo.context=context;
        itemInfo.handle=row.getStringColumn(""String_Node_Str"");
        itemInfo.itemID=row.getIntColumn(""String_Node_Str"");
        itemInfo.datestamp=row.getDateColumn(""String_Node_Str"");
        itemInfo.withdrawn=row.getBooleanColumn(""String_Node_Str"");
        if (collections) {
          fillCollections(context,itemInfo);
        }
        if (items) {
          itemInfo.item=Item.find(context,itemInfo.itemID);
        }
        infoObjects.add(itemInfo);
      }
      index++;
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return infoObjects;
}","/** 
 * Obtain information about items that have been created, modified or withdrawn within a given date range. You can also specify 'offset' and 'limit' so that a big harvest can be split up into smaller sections. <P> Note that dates are passed in the standard ISO8601 format used by DSpace (and OAI-PMH). <P> FIXME: Assumes all in_archive items have public metadata
 * @param context DSpace context
 * @param scope a Collection, Community, or <code>null</code> indicating the scope is all of DSpace
 * @param startDate start of date range, or <code>null</code>
 * @param endDate end of date range, or <code>null</code>
 * @param offset for a partial harvest, the point in the overall list of matching items to start at. 0 means just start at the beginning.
 * @param limit the number of matching items to return in a partial harvest. Specify 0 to return the whole list (or the rest of the list if an offset was specified.)
 * @param items if <code>true</code> the <code>item</code> field of each <code>HarvestedItemInfo</code> object is filled out
 * @param collections if <code>true</code> the <code>collectionHandles</code> field of each <code>HarvestedItemInfo</code> object is filled out
 * @param withdrawn If <code>true</code>, information about withdrawn items is included
 * @param nonAnon If items without anonymous access should be included or not
 * @return List of <code>HarvestedItemInfo</code> objects
 * @throws SQLException
 * @throws ParseException If the date is not in a supported format
 */
public static List harvest(Context context,DSpaceObject scope,String startDate,String endDate,int offset,int limit,boolean items,boolean collections,boolean withdrawn,boolean nonAnon) throws SQLException, ParseException {
  String query=""String_Node_Str"";
  List parameters=new ArrayList();
  if (scope != null) {
    if (scope.getType() == Constants.COLLECTION) {
      query+=""String_Node_Str"";
    }
 else     if (scope.getType() == Constants.COMMUNITY) {
      query+=""String_Node_Str"";
    }
  }
  query+=""String_Node_Str"" + Constants.ITEM + ""String_Node_Str"";
  if (scope != null) {
    if (scope.getType() == Constants.COLLECTION) {
      query+=""String_Node_Str"" + ""String_Node_Str"";
      parameters.add(new Integer(scope.getID()));
    }
 else     if (scope.getType() == Constants.COMMUNITY) {
      query+=""String_Node_Str"" + ""String_Node_Str"";
      parameters.add(new Integer(scope.getID()));
    }
  }
  if (startDate != null) {
    query=query + ""String_Node_Str"";
    parameters.add(toTimestamp(startDate,false));
  }
  if (endDate != null) {
    boolean selfGenerated=false;
    if (endDate.length() == 20) {
      endDate=endDate.substring(0,19) + ""String_Node_Str"";
      selfGenerated=true;
    }
    query+=""String_Node_Str"";
    parameters.add(toTimestamp(endDate,selfGenerated));
  }
  if (withdrawn == false) {
    if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
      query+=""String_Node_Str"";
    }
 else {
      query+=""String_Node_Str"";
    }
  }
  query+=""String_Node_Str"";
  log.debug(LogManager.getHeader(context,""String_Node_Str"",query));
  Object[] parametersArray=parameters.toArray();
  TableRowIterator tri=DatabaseManager.query(context,query,parametersArray);
  List infoObjects=new LinkedList();
  int index=0;
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      if ((index >= offset) && ((limit == 0) || (index < (offset + limit)))) {
        HarvestedItemInfo itemInfo=new HarvestedItemInfo();
        itemInfo.context=context;
        itemInfo.handle=row.getStringColumn(""String_Node_Str"");
        itemInfo.itemID=row.getIntColumn(""String_Node_Str"");
        itemInfo.datestamp=row.getDateColumn(""String_Node_Str"");
        itemInfo.withdrawn=row.getBooleanColumn(""String_Node_Str"");
        if (collections) {
          fillCollections(context,itemInfo);
        }
        if (items) {
          itemInfo.item=Item.find(context,itemInfo.itemID);
        }
        if (nonAnon) {
          infoObjects.add(itemInfo);
        }
 else {
          Group[] authorizedGroups=AuthorizeManager.getAuthorizedGroups(context,itemInfo.item,Constants.READ);
          boolean added=false;
          for (int i=0; i < authorizedGroups.length; i++) {
            if ((authorizedGroups[i].getID() == 0) && (!added)) {
              infoObjects.add(itemInfo);
              added=true;
            }
          }
        }
      }
      index++;
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return infoObjects;
}",0.9405847953216374
3333,"private boolean itemsChanged(Context context,DSpaceObject dso,long timeStamp) throws SQLException {
  DCDate dcStartDate=new DCDate(new Date(timeStamp));
  DCDate dcEndDate=new DCDate(new Date(System.currentTimeMillis()));
  String startDate=dcStartDate.toString().substring(0,10);
  String endDate=dcEndDate.toString().substring(0,10);
  try {
    return (Harvest.harvest(context,dso,startDate,endDate,0,1,false,false,false).size() > 0);
  }
 catch (  ParseException pe) {
    return false;
  }
}","private boolean itemsChanged(Context context,DSpaceObject dso,long timeStamp) throws SQLException {
  DCDate dcStartDate=new DCDate(new Date(timeStamp));
  DCDate dcEndDate=new DCDate(new Date(System.currentTimeMillis()));
  String startDate=dcStartDate.toString().substring(0,10);
  String endDate=dcEndDate.toString().substring(0,10);
  try {
    boolean includeAll=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
    return (Harvest.harvest(context,dso,startDate,endDate,0,1,false,false,false,includeAll).size() > 0);
  }
 catch (  ParseException pe) {
    return false;
  }
}",0.909423604757548
3334,"/** 
 * Method to do the actual harvest of records
 * @param from OAI 'from' parameter
 * @param until OAI 'until' parameter
 * @param set OAI 'set' parameter
 * @param metadataPrefix OAI 'metadataPrefix' parameter
 * @param offset where to start this harvest
 * @return the Map for listRecords to return, or null if the metadataPrefixis invalid
 */
private Map doRecordHarvest(String from,String until,String set,String metadataPrefix,int offset) throws OAIInternalServerError, BadArgumentException {
  Context context=null;
  String schemaURL=getCrosswalks().getSchemaURL(metadataPrefix);
  Map results=new HashMap();
  if (schemaURL == null) {
    return null;
  }
  List records=new LinkedList();
  try {
    context=new Context();
    DSpaceObject scope=resolveSet(context,set);
    List itemInfos=Harvest.harvest(context,scope,from,until,offset,MAX_RECORDS,true,true,true);
    Iterator i=itemInfos.iterator();
    while (i.hasNext()) {
      HarvestedItemInfo itemInfo=(HarvestedItemInfo)i.next();
      try {
        String recordXML=getRecordFactory().create(itemInfo,schemaURL,metadataPrefix);
        records.add(recordXML);
      }
 catch (      CannotDisseminateFormatException cdfe) {
        if (log.isDebugEnabled()) {
          log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + metadataPrefix + ""String_Node_Str""+ itemInfo.handle));
        }
      }
    }
    results.put(""String_Node_Str"",records.iterator());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + records.size()));
    if (records.size() >= MAX_RECORDS) {
      String resumptionToken=makeResumptionToken(from,until,set,metadataPrefix,offset + MAX_RECORDS);
      if (log.isDebugEnabled()) {
        log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + resumptionToken));
      }
      results.put(""String_Node_Str"",getResumptionMap(resumptionToken));
    }
  }
 catch (  SQLException se) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),se);
    throw new OAIInternalServerError(se.toString());
  }
catch (  ParseException pe) {
    throw new OAIInternalServerError(pe.toString());
  }
 finally {
    if (context != null) {
      context.abort();
    }
  }
  return results;
}","/** 
 * Method to do the actual harvest of records
 * @param from OAI 'from' parameter
 * @param until OAI 'until' parameter
 * @param set OAI 'set' parameter
 * @param metadataPrefix OAI 'metadataPrefix' parameter
 * @param offset where to start this harvest
 * @return the Map for listRecords to return, or null if the metadataPrefixis invalid
 */
private Map doRecordHarvest(String from,String until,String set,String metadataPrefix,int offset) throws OAIInternalServerError, BadArgumentException {
  Context context=null;
  String schemaURL=getCrosswalks().getSchemaURL(metadataPrefix);
  Map results=new HashMap();
  if (schemaURL == null) {
    return null;
  }
  List records=new LinkedList();
  try {
    context=new Context();
    DSpaceObject scope=resolveSet(context,set);
    boolean includeAll=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
    List itemInfos=Harvest.harvest(context,scope,from,until,offset,MAX_RECORDS,true,true,true,includeAll);
    Iterator i=itemInfos.iterator();
    while (i.hasNext()) {
      HarvestedItemInfo itemInfo=(HarvestedItemInfo)i.next();
      try {
        String recordXML=getRecordFactory().create(itemInfo,schemaURL,metadataPrefix);
        records.add(recordXML);
      }
 catch (      CannotDisseminateFormatException cdfe) {
        if (log.isDebugEnabled()) {
          log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + metadataPrefix + ""String_Node_Str""+ itemInfo.handle));
        }
      }
    }
    results.put(""String_Node_Str"",records.iterator());
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + records.size()));
    if (records.size() >= MAX_RECORDS) {
      String resumptionToken=makeResumptionToken(from,until,set,metadataPrefix,offset + MAX_RECORDS);
      if (log.isDebugEnabled()) {
        log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + resumptionToken));
      }
      results.put(""String_Node_Str"",getResumptionMap(resumptionToken));
    }
  }
 catch (  SQLException se) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),se);
    throw new OAIInternalServerError(se.toString());
  }
catch (  ParseException pe) {
    throw new OAIInternalServerError(pe.toString());
  }
 finally {
    if (context != null) {
      context.abort();
    }
  }
  return results;
}",0.9786775791514108
3335,"public boolean canDisseminate(DSpaceObject dso){
  return true;
}","public boolean canDisseminate(DSpaceObject dso){
  if (dso.getType() == Constants.BITSTREAM)   return true;
 else   return false;
}",0.6632653061224489
3336,"/** 
 * Determine which type of adatper to use for this object, either a community, collection, item, or repository adatpter. The decisios is based upon the two supplied identifiers: a handle or an internal id. If the handle is supplied then this is resolved and the approprate adapter is picked. Otherwise the internal identifier is used to resolve the correct type of adapter. The internal identifier must be of the form ""type:id"" i.g. item:255 or collection:99. In the case of a repository the handle prefix must be used.
 * @return Return the correct adaptor or null if none found.
 */
private AbstractAdapter resolveAdapter(Context context) throws SQLException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String contextPath=request.getContextPath();
  String handle=parameters.getParameter(""String_Node_Str"",null);
  String internal=parameters.getParameter(""String_Node_Str"",null);
  AbstractAdapter adapter=null;
  if (handle != null) {
    DSpaceObject dso=HandleManager.resolveToObject(context,handle);
    if (dso instanceof Item)     adapter=new ItemAdapter((Item)dso,contextPath);
 else     if (dso instanceof Collection || dso instanceof Community)     adapter=new ContainerAdapter(context,dso,contextPath);
  }
 else   if (internal != null) {
    String[] parts=internal.split(""String_Node_Str"");
    if (parts.length == 2) {
      String type=parts[0];
      int id=Integer.valueOf(parts[1]);
      if (""String_Node_Str"".equals(type)) {
        Item item=Item.find(context,id);
        if (item != null)         adapter=new ItemAdapter(item,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        Collection collection=Collection.find(context,id);
        if (collection != null)         adapter=new ContainerAdapter(context,collection,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        Community community=Community.find(context,id);
        if (community != null)         adapter=new ContainerAdapter(context,community,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        if (ConfigurationManager.getProperty(""String_Node_Str"").equals(id))         adapter=new RepositoryAdapter(context,contextPath);
      }
    }
  }
  return adapter;
}","/** 
 * Determine which type of adatper to use for this object, either a community, collection, item, or repository adatpter. The decisios is based upon the two supplied identifiers: a handle or an internal id. If the handle is supplied then this is resolved and the approprate adapter is picked. Otherwise the internal identifier is used to resolve the correct type of adapter. The internal identifier must be of the form ""type:id"" i.g. item:255 or collection:99. In the case of a repository the handle prefix must be used.
 * @return Return the correct adaptor or null if none found.
 */
private AbstractAdapter resolveAdapter(Context context) throws SQLException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String contextPath=request.getContextPath();
  String handle=parameters.getParameter(""String_Node_Str"",null);
  String internal=parameters.getParameter(""String_Node_Str"",null);
  AbstractAdapter adapter=null;
  if (handle != null) {
    DSpaceObject dso=HandleManager.resolveToObject(context,handle);
    if (dso instanceof Item)     adapter=new ItemAdapter((Item)dso,contextPath);
 else     if (dso instanceof Collection || dso instanceof Community)     adapter=new ContainerAdapter(context,dso,contextPath);
  }
 else   if (internal != null) {
    String[] parts=internal.split(""String_Node_Str"");
    if (parts.length == 2) {
      String type=parts[0];
      int id=Integer.valueOf(parts[1]);
      if (""String_Node_Str"".equals(type)) {
        Item item=Item.find(context,id);
        if (item != null)         adapter=new ItemAdapter(item,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        Collection collection=Collection.find(context,id);
        if (collection != null)         adapter=new ContainerAdapter(context,collection,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        Community community=Community.find(context,id);
        if (community != null)         adapter=new ContainerAdapter(context,community,contextPath);
      }
 else       if (""String_Node_Str"".equals(type)) {
        if (ConfigurationManager.getProperty(""String_Node_Str"").equals(String.valueOf(id)))         adapter=new RepositoryAdapter(context,contextPath);
      }
    }
  }
  return adapter;
}",0.995579133510168
3337,"static String checkEmptyQuery(String myquery){
  if (myquery.equals(""String_Node_Str"")) {
    myquery=""String_Node_Str"";
  }
  return myquery;
}","static String checkEmptyQuery(String myquery){
  if (myquery == null || myquery.equals(""String_Node_Str"") || myquery.equals(""String_Node_Str"")) {
    myquery=""String_Node_Str"";
  }
  return myquery;
}",0.7441860465116279
3338,"public boolean canDisseminate(DSpaceObject dso){
  return true;
}","public boolean canDisseminate(DSpaceObject dso){
  if (dso.getType() == Constants.BITSTREAM)   return true;
 else   return false;
}",0.6632653061224489
3339,"/** 
 * Set the DSpace context to use
 * @param context
 */
public void setContext(Context context){
  this.context=context;
}","/** 
 * Set the DSpace context to use
 * @param context the context
 */
public void setContext(Context context){
  this.context=context;
}",0.9545454545454546
3340,"/** 
 * add group to this group
 * @param g
 */
public void addMember(Group g){
  loadData();
  if (isMember(g)) {
    return;
  }
  groups.add(g);
  groupsChanged=true;
  myContext.addEvent(new Event(Event.ADD,Constants.GROUP,getID(),Constants.GROUP,g.getID(),g.getName()));
}","/** 
 * add group to this group
 * @param g
 */
public void addMember(Group g){
  loadData();
  if (isMember(g) || getID() == g.getID()) {
    return;
  }
  groups.add(g);
  groupsChanged=true;
  myContext.addEvent(new Event(Event.ADD,Constants.GROUP,getID(),Constants.GROUP,g.getID(),g.getName()));
}",0.9584775086505192
3341,"/** 
 * Close the context, without committing any of the changes performed using this context. The database connection is freed. No exception is thrown if there is an error freeing the database connection, since this method may be called as part of an error-handling routine where an SQLException has already been thrown.
 */
public void abort(){
  try {
    connection.rollback();
  }
 catch (  SQLException se) {
    log.error(se.getMessage());
    se.printStackTrace();
  }
 finally {
    DatabaseManager.freeConnection(connection);
    connection=null;
    events=null;
  }
}","/** 
 * Close the context, without committing any of the changes performed using this context. The database connection is freed. No exception is thrown if there is an error freeing the database connection, since this method may be called as part of an error-handling routine where an SQLException has already been thrown.
 */
public void abort(){
  try {
    if (!connection.isClosed())     connection.rollback();
  }
 catch (  SQLException se) {
    log.error(se.getMessage());
    se.printStackTrace();
  }
 finally {
    try {
      if (!connection.isClosed())       DatabaseManager.freeConnection(connection);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
    connection=null;
    events=null;
  }
}",0.8880368098159509
3342,"/** 
 * Determine which type of adatper to use for this object, either a community, collection, item, or repository adatpter. The decisios is based upon the two supplied identifiers: a handle or an internal id. If the handle is supplied then this is resolved and the approprate adapter is picked. Otherwise the internal identifier is used to resolve the correct type of adapter. The internal identifier must be of the form ""type:id"" i.g. item:255 or collection:99. In the case of a repository the handle prefix must be used.
 * @return Return the correct adaptor or null if none found.
 */
private AbstractAdapter resolveAdapter(Context context) throws SQLException {
  try {
    Request request=ObjectModelHelper.getRequest(objectModel);
    String contextPath=request.getContextPath();
    String uri=parameters.getParameter(""String_Node_Str"",null);
    String internal=parameters.getParameter(""String_Node_Str"",null);
    AbstractAdapter adapter=null;
    if (uri != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,uri);
      DSpaceObject dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item)       adapter=new ItemAdapter((Item)dso,contextPath);
 else       if (dso instanceof Collection || dso instanceof Community)       adapter=new ContainerAdapter(context,dso,contextPath);
    }
 else     if (internal != null) {
      String[] parts=internal.split(""String_Node_Str"");
      if (parts.length == 2) {
        String type=parts[0];
        int id=Integer.valueOf(parts[1]);
        if (""String_Node_Str"".equals(type)) {
          Item item=Item.find(context,id);
          if (item != null)           adapter=new ItemAdapter(item,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          Collection collection=Collection.find(context,id);
          if (collection != null)           adapter=new ContainerAdapter(context,collection,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          Community community=Community.find(context,id);
          if (community != null)           adapter=new ContainerAdapter(context,community,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          if (ConfigurationManager.getProperty(""String_Node_Str"").equals(id))           adapter=new RepositoryAdapter(context,contextPath);
        }
      }
    }
    return adapter;
  }
 catch (  IdentifierException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Determine which type of adatper to use for this object, either a community, collection, item, or repository adatpter. The decisios is based upon the two supplied identifiers: a handle or an internal id. If the handle is supplied then this is resolved and the approprate adapter is picked. Otherwise the internal identifier is used to resolve the correct type of adapter. The internal identifier must be of the form ""type:id"" i.g. item:255 or collection:99. In the case of a repository the handle prefix must be used.
 * @return Return the correct adaptor or null if none found.
 */
private AbstractAdapter resolveAdapter(Context context) throws SQLException {
  try {
    Request request=ObjectModelHelper.getRequest(objectModel);
    String contextPath=request.getContextPath();
    String uri=parameters.getParameter(""String_Node_Str"",null);
    String internal=parameters.getParameter(""String_Node_Str"",null);
    AbstractAdapter adapter=null;
    if (uri != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,uri);
      DSpaceObject dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item)       adapter=new ItemAdapter((Item)dso,contextPath);
 else       if (dso instanceof Collection || dso instanceof Community)       adapter=new ContainerAdapter(context,dso,contextPath);
    }
 else     if (internal != null) {
      String[] parts=internal.split(""String_Node_Str"");
      if (parts.length == 2) {
        String type=parts[0];
        int id=Integer.valueOf(parts[1]);
        if (""String_Node_Str"".equals(type)) {
          Item item=Item.find(context,id);
          if (item != null)           adapter=new ItemAdapter(item,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          Collection collection=Collection.find(context,id);
          if (collection != null)           adapter=new ContainerAdapter(context,collection,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          Community community=Community.find(context,id);
          if (community != null)           adapter=new ContainerAdapter(context,community,contextPath);
        }
 else         if (""String_Node_Str"".equals(type)) {
          if (ConfigurationManager.getProperty(""String_Node_Str"").equals(String.valueOf(id)))           adapter=new RepositoryAdapter(context,contextPath);
        }
      }
    }
    return adapter;
  }
 catch (  IdentifierException e) {
    throw new RuntimeException(e);
  }
}",0.996
3343,"/** 
 * output the report block based on the passed mapping, where the mapping sould be ""name of report element"" => ""value"", where both sides of the mapping should be Strings.  This class also assumes that the reference is a linkable URL to the resource
 * @param content     the statistic object array to be displayed
 * @return              a string containing the statistics block HTML formatted
 */
public String statBlock(Statistics content){
  StringBuffer frag=new StringBuffer();
  Stat[] stats=content.getStats();
  frag.append(""String_Node_Str"");
  if (content.getStatName() != null || content.getResultName() != null) {
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (content.getStatName() != null) {
      frag.append(""String_Node_Str"" + content.getStatName() + ""String_Node_Str"");
    }
 else {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (content.getResultName() != null) {
      frag.append(""String_Node_Str"" + content.getResultName() + ""String_Node_Str"");
    }
 else {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
  }
  for (int i=0; i < stats.length; i++) {
    String style=null;
    if ((i % 2) == 1) {
      style=""String_Node_Str"";
    }
 else {
      style=""String_Node_Str"";
    }
    frag.append(""String_Node_Str"" + style + ""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (stats[i].getReference() != null) {
      frag.append(""String_Node_Str"" + stats[i].getReference() + ""String_Node_Str"");
      frag.append(""String_Node_Str"");
    }
    frag.append(stats[i].getKey());
    if (stats[i].getReference() != null) {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"" + ReportTools.numberFormat(stats[i].getValue()));
    if (stats[i].getUnits() != null) {
      frag.append(""String_Node_Str"" + stats[i].getUnits());
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
  }
  frag.append(""String_Node_Str"");
  return frag.toString();
}","/** 
 * output the report block based on the passed mapping, where the mapping sould be ""name of report element"" => ""value"", where both sides of the mapping should be Strings.  This class also assumes that the reference is a linkable URL to the resource
 * @param content     the statistic object array to be displayed
 * @return              a string containing the statistics block HTML formatted
 */
public String statBlock(Statistics content){
  StringBuffer frag=new StringBuffer();
  Stat[] stats=content.getStats();
  frag.append(""String_Node_Str"");
  if (content.getStatName() != null || content.getResultName() != null) {
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (content.getStatName() != null) {
      frag.append(""String_Node_Str"" + content.getStatName() + ""String_Node_Str"");
    }
 else {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (content.getResultName() != null) {
      frag.append(""String_Node_Str"" + content.getResultName() + ""String_Node_Str"");
    }
 else {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
  }
  for (int i=0; i < stats.length; i++) {
    String style=null;
    if ((i % 2) == 1) {
      style=""String_Node_Str"";
    }
 else {
      style=""String_Node_Str"";
    }
    frag.append(""String_Node_Str"" + style + ""String_Node_Str"");
    frag.append(""String_Node_Str"");
    if (stats[i].getReference() != null) {
      frag.append(""String_Node_Str"" + stats[i].getReference() + ""String_Node_Str"");
      frag.append(""String_Node_Str"");
    }
    frag.append(this.clean(stats[i].getKey()));
    if (stats[i].getReference() != null) {
      frag.append(""String_Node_Str"");
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"" + ReportTools.numberFormat(stats[i].getValue()));
    if (stats[i].getUnits() != null) {
      frag.append(""String_Node_Str"" + stats[i].getUnits());
    }
    frag.append(""String_Node_Str"");
    frag.append(""String_Node_Str"");
  }
  frag.append(""String_Node_Str"");
  return frag.toString();
}",0.997254004576659
3344,"public int[] getSpecialGroups(Context context,HttpServletRequest request){
  if ((context.getCurrentUser() != null) && (!context.getCurrentUser().getNetid().equals(""String_Node_Str""))) {
    if (ldapGroup == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      return new int[0];
    }
 else {
      return new int[]{ldapGroup.getID()};
    }
  }
  return new int[0];
}","public int[] getSpecialGroups(Context context,HttpServletRequest request){
  try {
    if (!context.getCurrentUser().getNetid().equals(""String_Node_Str"")) {
      if (ldapGroup == null) {
        log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        return new int[0];
      }
 else {
        return new int[]{ldapGroup.getID()};
      }
    }
  }
 catch (  NullPointerException npe) {
  }
  return new int[0];
}",0.8364485981308412
3345,"protected String getDNOfUser(String adminUser,String adminPassword,Context context,String netid){
  String resultDN;
  int ldap_search_scope_value=0;
  try {
    ldap_search_scope_value=Integer.parseInt(ldap_search_scope.trim());
  }
 catch (  Exception e) {
    if (ldap_search_scope != null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ldap_search_scope));
    }
  }
  Hashtable env=new Hashtable(11);
  env.put(javax.naming.Context.INITIAL_CONTEXT_FACTORY,""String_Node_Str"");
  env.put(javax.naming.Context.PROVIDER_URL,ldap_provider_url);
  env.put(javax.naming.Context.SECURITY_AUTHENTICATION,""String_Node_Str"");
  env.put(javax.naming.Context.SECURITY_PRINCIPAL,adminUser);
  env.put(javax.naming.Context.SECURITY_CREDENTIALS,adminPassword);
  DirContext ctx=null;
  try {
    ctx=new InitialDirContext(env);
    Attributes matchAttrs=new BasicAttributes(true);
    matchAttrs.put(new BasicAttribute(ldap_id_field,netid));
    try {
      SearchControls ctrls=new SearchControls();
      ctrls.setSearchScope(ldap_search_scope_value);
      NamingEnumeration<SearchResult> answer=ctx.search(ldap_provider_url + ldap_search_context,""String_Node_Str"",new Object[]{ldap_id_field,netid},ctrls);
      while (answer.hasMoreElements()) {
        SearchResult sr=answer.next();
        resultDN=(sr.getName() + ""String_Node_Str"" + ldap_search_context);
        String attlist[]={ldap_email_field,ldap_givenname_field,ldap_surname_field,ldap_phone_field};
        Attributes atts=sr.getAttributes();
        Attribute att;
        if (attlist[0] != null) {
          att=atts.get(attlist[0]);
          if (att != null)           ldapEmail=(String)att.get();
        }
        if (attlist[1] != null) {
          att=atts.get(attlist[1]);
          if (att != null)           ldapGivenName=(String)att.get();
        }
        if (attlist[2] != null) {
          att=atts.get(attlist[2]);
          if (att != null)           ldapSurname=(String)att.get();
        }
        if (attlist[3] != null) {
          att=atts.get(attlist[3]);
          if (att != null)           ldapPhone=(String)att.get();
        }
        if (answer.hasMoreElements()) {
        }
 else {
          log.warn(LogManager.getHeader(context,""String_Node_Str"",resultDN));
          return resultDN;
        }
      }
    }
 catch (    NamingException e) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + e));
    }
  }
 catch (  NamingException e) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + e));
  }
 finally {
    try {
      if (ctx != null)       ctx.close();
    }
 catch (    NamingException e) {
    }
  }
  return null;
}","protected String getDNOfUser(String adminUser,String adminPassword,Context context,String netid){
  String resultDN;
  int ldap_search_scope_value=0;
  try {
    ldap_search_scope_value=Integer.parseInt(ldap_search_scope.trim());
  }
 catch (  Exception e) {
    if (ldap_search_scope != null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ldap_search_scope));
    }
  }
  Hashtable env=new Hashtable(11);
  env.put(javax.naming.Context.INITIAL_CONTEXT_FACTORY,""String_Node_Str"");
  env.put(javax.naming.Context.PROVIDER_URL,ldap_provider_url);
  env.put(javax.naming.Context.SECURITY_AUTHENTICATION,""String_Node_Str"");
  env.put(javax.naming.Context.SECURITY_PRINCIPAL,adminUser);
  env.put(javax.naming.Context.SECURITY_CREDENTIALS,adminPassword);
  DirContext ctx=null;
  try {
    ctx=new InitialDirContext(env);
    Attributes matchAttrs=new BasicAttributes(true);
    matchAttrs.put(new BasicAttribute(ldap_id_field,netid));
    try {
      SearchControls ctrls=new SearchControls();
      ctrls.setSearchScope(ldap_search_scope_value);
      NamingEnumeration<SearchResult> answer=ctx.search(ldap_provider_url + ldap_search_context,""String_Node_Str"",new Object[]{ldap_id_field,netid},ctrls);
      while (answer.hasMoreElements()) {
        SearchResult sr=answer.next();
        resultDN=(sr.getName() + ""String_Node_Str"" + ldap_search_context);
        String attlist[]={ldap_email_field,ldap_givenname_field,ldap_surname_field,ldap_phone_field};
        Attributes atts=sr.getAttributes();
        Attribute att;
        if (attlist[0] != null) {
          att=atts.get(attlist[0]);
          if (att != null)           ldapEmail=(String)att.get();
        }
        if (attlist[1] != null) {
          att=atts.get(attlist[1]);
          if (att != null)           ldapGivenName=(String)att.get();
        }
        if (attlist[2] != null) {
          att=atts.get(attlist[2]);
          if (att != null)           ldapSurname=(String)att.get();
        }
        if (attlist[3] != null) {
          att=atts.get(attlist[3]);
          if (att != null)           ldapPhone=(String)att.get();
        }
        if (answer.hasMoreElements()) {
        }
 else {
          log.debug(LogManager.getHeader(context,""String_Node_Str"",resultDN));
          return resultDN;
        }
      }
    }
 catch (    NamingException e) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + e));
    }
  }
 catch (  NamingException e) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + e));
  }
 finally {
    try {
      if (ctx != null)       ctx.close();
    }
 catch (    NamingException e) {
    }
  }
  return null;
}",0.9983434566537824
3346,"public int[] getSpecialGroups(Context context,HttpServletRequest request){
  try {
    if (!context.getCurrentUser().getNetid().equals(""String_Node_Str"")) {
      if (ldapGroup == null) {
        log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        return new int[0];
      }
 else {
        return new int[]{ldapGroup.getID()};
      }
    }
  }
 catch (  NullPointerException npe) {
  }
  return new int[0];
}","public int[] getSpecialGroups(Context context,HttpServletRequest request){
  try {
    if (!context.getCurrentUser().getNetid().equals(""String_Node_Str"")) {
      String groupName=ConfigurationManager.getProperty(""String_Node_Str"");
      if ((groupName != null) && (!groupName.trim().equals(""String_Node_Str""))) {
        ldapGroup=Group.findByName(new Context(),groupName);
        if (ldapGroup == null) {
          log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          return new int[0];
        }
 else {
          return new int[]{ldapGroup.getID()};
        }
      }
    }
  }
 catch (  Exception npe) {
  }
  return new int[0];
}",0.7755834829443446
3347,"/** 
 * Generate the validity for this cached entry
 * @return
 */
public SourceValidity getValidity(){
  if (validity == null) {
    try {
      initialise();
      boolean showReport=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
      if (!showReport) {
        try {
          showReport=AuthorizeManager.isAdmin(context);
        }
 catch (        SQLException sqle) {
          log.error(""String_Node_Str"",sqle);
        }
      }
      if (showReport) {
        File analysisFile=null;
        if (reportDate != null)         analysisFile=StatisticsLoader.getAnalysisFor(reportDate);
 else         analysisFile=StatisticsLoader.getGeneralAnalysis();
        if (analysisFile != null) {
          DSpaceValidity newValidity=new DSpaceValidity();
          newValidity.add(Long.toString(analysisFile.lastModified()));
          newValidity.add(""String_Node_Str"");
          newValidity.add(Long.toString(analysisFile.length()));
          validity=newValidity.complete();
        }
      }
    }
 catch (    Exception e) {
    }
  }
  return validity;
}","/** 
 * Generate the validity for this cached entry
 * @return
 */
public SourceValidity getValidity(){
  if (validity == null) {
    try {
      initialise();
      boolean showReport=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
      if (!showReport) {
        showReport=AuthorizeManager.isAdmin(context);
      }
      if (showReport) {
        File analysisFile=null;
        if (reportDate != null)         analysisFile=StatisticsLoader.getAnalysisFor(reportDate);
 else         analysisFile=StatisticsLoader.getGeneralAnalysis();
        if (analysisFile != null) {
          DSpaceValidity newValidity=new DSpaceValidity();
          newValidity.add(Long.toString(analysisFile.lastModified()));
          newValidity.add(""String_Node_Str"");
          newValidity.add(Long.toString(analysisFile.length()));
          validity=newValidity.complete();
        }
      }
    }
 catch (    Exception e) {
    }
  }
  return validity;
}",0.3685770750988142
3348,"/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    String h=dso.getHandle();
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]+ ""String_Node_Str""+ (h == null ? ""String_Node_Str"" : h));
  }
  Item item=(Item)dso;
  String handle=item.getHandle();
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + (handle == null ? String.valueOf(dso.getID()) : handle) + ""String_Node_Str""+ originalKey);
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      if (v.value == null) {
        e.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 else {
        String reason=Verifier.checkCharacterData(v.value);
        if (reason == null) {
          e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
        }
 else {
          log.warn(""String_Node_Str"" + reason);
          String simpleText=v.value.replaceAll(""String_Node_Str"",""String_Node_Str"");
          if (Verifier.checkCharacterData(simpleText) == null)           e.setAttribute(""String_Node_Str"",simpleText);
        }
      }
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}","/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    String h=dso.getHandle();
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]+ ""String_Node_Str""+ (h == null ? ""String_Node_Str"" : h));
  }
  Item item=(Item)dso;
  String handle=item.getHandle();
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    boolean provenance=""String_Node_Str"".equals(v.element) && ""String_Node_Str"".equals(v.qualifier);
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + (handle == null ? String.valueOf(dso.getID()) : handle) + ""String_Node_Str""+ originalKey);
      }
    }
 else     if (provenance != true) {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      if (v.value == null) {
        e.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 else {
        String reason=Verifier.checkCharacterData(v.value);
        if (reason == null) {
          e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
        }
 else {
          log.warn(""String_Node_Str"" + reason);
          String simpleText=v.value.replaceAll(""String_Node_Str"",""String_Node_Str"");
          if (Verifier.checkCharacterData(simpleText) == null)           e.setAttribute(""String_Node_Str"",simpleText);
        }
      }
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}",0.975964225824483
3349,"/** 
 * Attempt to authenticate the user. 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String email=request.getParameter(""String_Node_Str"");
  String password=request.getParameter(""String_Node_Str"");
  String realm=request.getParameter(""String_Node_Str"");
  if (email == null)   email=""String_Node_Str"";
  if (password == null)   password=""String_Node_Str"";
  try {
    Context context=AuthenticationUtil.Authenticate(objectModel,email,password,realm);
    EPerson eperson=context.getCurrentUser();
    if (eperson != null) {
      String redirectURL=request.getContextPath();
      if (AuthenticationUtil.isInterupptedRequest(objectModel)) {
        redirectURL+=AuthenticationUtil.resumeInterruptedRequest(objectModel);
      }
 else {
        String loginRedirect=ConfigurationManager.getProperty(""String_Node_Str"");
        redirectURL+=(loginRedirect != null) ? loginRedirect.trim() : ""String_Node_Str"";
      }
      final HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
      httpResponse.sendRedirect(redirectURL);
      context.setCurrentUser(null);
      return new HashMap();
    }
  }
 catch (  SQLException sqle) {
    throw new PatternException(""String_Node_Str"",sqle);
  }
  return null;
}","/** 
 * Attempt to authenticate the user. 
 */
public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String email=request.getParameter(""String_Node_Str"");
  String password=request.getParameter(""String_Node_Str"");
  String realm=request.getParameter(""String_Node_Str"");
  if ((email == null) || (password == null)) {
    return null;
  }
  try {
    Context context=AuthenticationUtil.Authenticate(objectModel,email,password,realm);
    EPerson eperson=context.getCurrentUser();
    if (eperson != null) {
      String redirectURL=request.getContextPath();
      if (AuthenticationUtil.isInterupptedRequest(objectModel)) {
        redirectURL+=AuthenticationUtil.resumeInterruptedRequest(objectModel);
      }
 else {
        String loginRedirect=ConfigurationManager.getProperty(""String_Node_Str"");
        redirectURL+=(loginRedirect != null) ? loginRedirect.trim() : ""String_Node_Str"";
      }
      final HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
      httpResponse.sendRedirect(redirectURL);
      context.setCurrentUser(null);
      return new HashMap();
    }
  }
 catch (  SQLException sqle) {
    throw new PatternException(""String_Node_Str"",sqle);
  }
  return null;
}",0.9686609686609686
3350,"public void addBody(Body body) throws WingException, SQLException {
  int groupID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  String currentName=URLDecode(parameters.getParameter(""String_Node_Str"",null));
  if (currentName == null || currentName.length() == 0)   currentName=FlowGroupUtils.getName(context,groupID);
  Group group=null;
  if (groupID >= 0)   group=Group.find(context,groupID);
  Collection collection=null;
  if (group != null) {
    int collectionID=FlowGroupUtils.getCollectionId(group.getName());
    if (collectionID > -1)     collection=Collection.find(context,collectionID);
    if (collection == null)     collectionID=-1;
  }
  String memberGroupIDsString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<Integer> memberGroupIDs=new ArrayList<Integer>();
  if (memberGroupIDsString != null) {
    for (    String id : memberGroupIDsString.split(""String_Node_Str"")) {
      if (id.length() > 0)       memberGroupIDs.add(Integer.valueOf(id));
    }
  }
  String memberEPeopleIDsString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<Integer> memberEPeopleIDs=new ArrayList<Integer>();
  if (memberEPeopleIDsString != null) {
    for (    String id : memberEPeopleIDsString.split(""String_Node_Str""))     if (id.length() > 0)     memberEPeopleIDs.add(Integer.valueOf(id));
  }
  int highlightEPersonID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  int highlightGroupID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  String query=URLDecode(parameters.getParameter(""String_Node_Str"",null));
  int page=parameters.getParameterAsInteger(""String_Node_Str"",0);
  String type=parameters.getParameter(""String_Node_Str"",null);
  String errorString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<String> errors=new ArrayList<String>();
  if (errorString != null)   for (  String error : errorString.split(""String_Node_Str""))   errors.add(error);
  Division main=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  if (group == null)   main.setHead(T_main_head_new);
 else   main.setHead(T_main_head.parameterize(group.getName(),groupID));
  if (collection != null) {
    Para para=main.addPara();
    para.addContent(T_collection_para);
    para.addXref(contextPath + ""String_Node_Str"" + collection.getHandle(),collection.getMetadata(""String_Node_Str""));
  }
  Division actions=main.addDivision(""String_Node_Str"");
  Para groupName=actions.addPara();
  groupName.addContent(T_label_name);
  Text groupText=groupName.addText(""String_Node_Str"");
  groupText.setValue(currentName);
  if (collection != null) {
    groupText.setDisabled();
    groupText.setHelp(T_label_instructions);
  }
 else   if (errors.contains(""String_Node_Str"") || errors.contains(""String_Node_Str""))   groupText.addError(""String_Node_Str"");
  Para searchBoxes=actions.addPara();
  searchBoxes.addContent(T_label_search);
  Text queryField=searchBoxes.addText(""String_Node_Str"");
  queryField.setValue(query);
  queryField.setSize(15);
  searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_search_people);
  searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_search_groups);
  if (query != null) {
    if (""String_Node_Str"".equals(type)) {
      searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_clear);
      addEPeopleSearch(main,query,page,group,memberEPeopleIDs);
    }
 else     if (""String_Node_Str"".equals(type)) {
      searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_clear);
      addGroupSearch(main,group,query,page,group,memberGroupIDs);
    }
  }
  boolean changes=false;
  if (group != null)   changes=addMemberList(main,group,memberGroupIDs,memberEPeopleIDs,highlightEPersonID,highlightGroupID);
  Para buttons=main.addPara();
  buttons.addButton(""String_Node_Str"").setValue(T_submit_save);
  buttons.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  if (changes)   main.addPara().addHighlight(""String_Node_Str"").addContent(""String_Node_Str"");
  main.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws WingException, SQLException {
  int groupID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  String currentName=URLDecode(parameters.getParameter(""String_Node_Str"",null));
  if (currentName == null || currentName.length() == 0)   currentName=FlowGroupUtils.getName(context,groupID);
  Group group=null;
  if (groupID >= 0)   group=Group.find(context,groupID);
  Collection collection=null;
  if (group != null) {
    int collectionID=FlowGroupUtils.getCollectionId(group.getName());
    if (collectionID > -1)     collection=Collection.find(context,collectionID);
    if (collection == null)     collectionID=-1;
  }
  String memberGroupIDsString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<Integer> memberGroupIDs=new ArrayList<Integer>();
  if (memberGroupIDsString != null) {
    for (    String id : memberGroupIDsString.split(""String_Node_Str"")) {
      if (id.length() > 0)       memberGroupIDs.add(Integer.valueOf(id));
    }
  }
  String memberEPeopleIDsString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<Integer> memberEPeopleIDs=new ArrayList<Integer>();
  if (memberEPeopleIDsString != null) {
    for (    String id : memberEPeopleIDsString.split(""String_Node_Str""))     if (id.length() > 0)     memberEPeopleIDs.add(Integer.valueOf(id));
  }
  int highlightEPersonID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  int highlightGroupID=parameters.getParameterAsInteger(""String_Node_Str"",-1);
  String query=URLDecode(parameters.getParameter(""String_Node_Str"",null));
  int page=parameters.getParameterAsInteger(""String_Node_Str"",0);
  String type=parameters.getParameter(""String_Node_Str"",null);
  String errorString=parameters.getParameter(""String_Node_Str"",null);
  ArrayList<String> errors=new ArrayList<String>();
  if (errorString != null)   for (  String error : errorString.split(""String_Node_Str""))   errors.add(error);
  Division main=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  if (group == null)   main.setHead(T_main_head_new);
 else   main.setHead(T_main_head.parameterize(group.getName(),groupID));
  if (collection != null) {
    Para para=main.addPara();
    para.addContent(T_collection_para);
    para.addXref(contextPath + ""String_Node_Str"" + collection.getHandle(),collection.getMetadata(""String_Node_Str""));
  }
  Division actions=main.addDivision(""String_Node_Str"");
  Para groupName=actions.addPara();
  groupName.addContent(T_label_name);
  Text groupText=groupName.addText(""String_Node_Str"");
  groupText.setValue(currentName);
  if (collection != null) {
    groupText.setDisabled();
    groupText.setHelp(T_label_instructions);
  }
 else   if (errors.contains(""String_Node_Str"") || errors.contains(""String_Node_Str""))   groupText.addError(""String_Node_Str"");
  Para searchBoxes=actions.addPara();
  searchBoxes.addContent(T_label_search);
  Text queryField=searchBoxes.addText(""String_Node_Str"");
  queryField.setValue(query);
  queryField.setSize(15);
  searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_search_people);
  searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_search_groups);
  if (query != null) {
    if (""String_Node_Str"".equals(type)) {
      searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_clear);
      addEPeopleSearch(main,query,page,group,memberEPeopleIDs);
    }
 else     if (""String_Node_Str"".equals(type)) {
      searchBoxes.addButton(""String_Node_Str"").setValue(T_submit_clear);
      addGroupSearch(main,group,query,page,group,memberGroupIDs);
    }
  }
  boolean changes=false;
  if (group != null)   changes=addMemberList(main,group,memberGroupIDs,memberEPeopleIDs,highlightEPersonID,highlightGroupID);
  Para buttons=main.addPara();
  buttons.addButton(""String_Node_Str"").setValue(T_submit_save);
  buttons.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  if (changes)   main.addPara().addHighlight(""String_Node_Str"").addContent(T_pending_warn);
  main.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.9962070231249236
3351,"/** 
 * Authenticate the given username/password pair, in conjunction with the onBehalfOf user.  The rules are that the username/password pair must successfully authenticate the user, and the onBehalfOf user must exist in the user database.
 * @param un
 * @param pw
 * @param obo
 * @return	a SWORD context holding the various user information
 * @throws SWORDAuthenticationException
 * @throws SWORDException
 */
private SWORDContext authenticate(Context context,String un,String pw,String obo) throws SWORDAuthenticationException, SWORDException {
  if (""String_Node_Str"".equals(obo)) {
    obo=null;
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
  SWORDContext sc=new SWORDContext();
  SWORDAuthentication auth=new SWORDAuthentication();
  EPerson ep=null;
  boolean authenticated=false;
  if (auth.authenticates(this.context,un,pw)) {
    ep=EPerson.findByEmail(context,un);
    if (ep != null) {
      authenticated=true;
      sc.setAuthenticated(ep);
    }
    if (obo != null) {
      EPerson epObo=EPerson.findByEmail(this.context,obo);
      if (epObo != null) {
        sc.setOnBehalfOf(epObo);
      }
 else {
        authenticated=false;
      }
    }
  }
  if (ep != null && authenticated) {
    this.context.setCurrentUser(ep);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ep.getID()));
  }
 else {
    if (ep != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un));
      throw new SWORDAuthenticationException(""String_Node_Str"");
    }
 else {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
      throw new SWORDAuthenticationException(""String_Node_Str"");
    }
  }
  return sc;
}","/** 
 * Authenticate the given username/password pair, in conjunction with the onBehalfOf user.  The rules are that the username/password pair must successfully authenticate the user, and the onBehalfOf user must exist in the user database.
 * @param un
 * @param pw
 * @param obo
 * @return	a SWORD context holding the various user information
 * @throws SWORDAuthenticationException
 * @throws SWORDException
 */
private SWORDContext authenticate(Context context,String un,String pw,String obo) throws SWORDAuthenticationException, SWORDException {
  if (""String_Node_Str"".equals(obo)) {
    obo=null;
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
  SWORDContext sc=new SWORDContext();
  SWORDAuthentication auth=new SWORDAuthentication();
  EPerson ep=null;
  boolean authenticated=false;
  if (auth.authenticates(context,un,pw)) {
    ep=EPerson.findByEmail(context,un);
    if (ep != null) {
      authenticated=true;
      sc.setAuthenticated(ep);
    }
    if (obo != null) {
      EPerson epObo=EPerson.findByEmail(context,obo);
      if (epObo != null) {
        sc.setOnBehalfOf(epObo);
      }
 else {
        authenticated=false;
      }
    }
  }
  if (ep != null && authenticated) {
    context.setCurrentUser(ep);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ep.getID()));
  }
 else {
    if (ep != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un));
      throw new SWORDAuthenticationException(""String_Node_Str"");
    }
 else {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
      throw new SWORDAuthenticationException(""String_Node_Str"");
    }
  }
  return sc;
}",0.995834490419328
3352,"/** 
 * Generate the cache validity object. The validity object will include the item being viewed, along with all bundles & bitstreams.
 */
public SourceValidity getValidity(){
  DSpaceObject dso=null;
  if (this.validity == null) {
    try {
      dso=URIUtil.resolve(objectModel);
      DSpaceValidity validity=new DSpaceValidity();
      validity.add(dso);
      this.validity=validity.complete();
    }
 catch (    Exception e) {
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + (dso == null ? ""String_Node_Str"" : dso.getHandle())));
  }
  return this.validity;
}","/** 
 * Generate the cache validity object. The validity object will include the item being viewed, along with all bundles & bitstreams.
 */
public SourceValidity getValidity(){
  DSpaceObject dso=null;
  if (this.validity == null) {
    try {
      dso=URIUtil.resolve(objectModel);
      DSpaceValidity validity=new DSpaceValidity();
      validity.add(dso);
      this.validity=validity.complete();
    }
 catch (    Exception e) {
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + (dso == null ? ""String_Node_Str"" : IdentifierService.getCanonicalForm(dso))));
  }
  return this.validity;
}",0.9578606158833064
3353,"/** 
 * Set up the bitstream reader. See the class description for information on configuration options. FIXME: This should use the parameter ""uri"" rather than ""handle"" to be consistent with the JSPUI. Unfortunately, I have no idea how this works right now, so I'll have to do that later. It should still work for now though. --JR
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,handle);
      dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item && sequence > -1) {
        bitstream=findBitstreamBySequence((Item)dso,sequence);
      }
 else       if (dso instanceof Item && name != null) {
        bitstream=findBitstreamByName((Item)dso,name);
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=IdentifierService.getCanonicalForm(item);
        }
 else         if (dso != null) {
          redictURL+=IdentifierService.getCanonicalForm(dso);
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  IdentifierException e) {
    log.error(""String_Node_Str"",e);
    throw new ProcessingException(""String_Node_Str"",e);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}","/** 
 * Set up the bitstream reader. See the class description for information on configuration options. FIXME: This should use the parameter ""uri"" rather than ""handle"" to be consistent with the JSPUI. Unfortunately, I have no idea how this works right now, so I'll have to do that later. It should still work for now though. --JR
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,handle);
      dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item && sequence > -1) {
        bitstream=findBitstreamBySequence((Item)dso,sequence);
      }
 else       if (dso instanceof Item && name != null) {
        bitstream=findBitstreamByName((Item)dso,name);
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + IdentifierService.getCanonicalForm(item) + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=IdentifierService.getCanonicalForm(item);
        }
 else         if (dso != null) {
          redictURL+=IdentifierService.getCanonicalForm(dso);
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  IdentifierException e) {
    log.error(""String_Node_Str"",e);
    throw new ProcessingException(""String_Node_Str"",e);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}",0.9936440677966102
3354,"/** 
 * Do the beginning of a Step. First do pre-processing, then display the JSP (if there is one). If there's no JSP, just End the step immediately.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return true if the step is completed (no JSP was loaded), falseotherwise
 */
private boolean doStepStart(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  log.debug(""String_Node_Str"" + this.getClass().getName());
  stepJSPUI.doPreProcessing(context,request,response,subInfo);
  if (!response.isCommitted()) {
    log.debug(""String_Node_Str"" + this.getClass().getName());
    int errorFlag=stepProcessing.doProcessing(context,request,response,subInfo);
    if (errorFlag != AbstractProcessingStep.STATUS_COMPLETE) {
      String errorMessage=stepProcessing.getErrorMessage(errorFlag);
      if (errorMessage == null) {
        errorMessage=""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ errorFlag+ ""String_Node_Str""+ ""String_Node_Str"";
      }
      log.error(errorMessage);
    }
    return completeStep(context,request,response,subInfo);
  }
 else   return false;
}","/** 
 * Do the beginning of a Step. First do pre-processing, then display the JSP (if there is one). If there's no JSP, just End the step immediately.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return true if the step is completed (no JSP was loaded), falseotherwise
 */
private boolean doStepStart(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  log.debug(""String_Node_Str"" + this.getClass().getName());
  if (stepJSPUI != null)   stepJSPUI.doPreProcessing(context,request,response,subInfo);
  if (!response.isCommitted()) {
    log.debug(""String_Node_Str"" + this.getClass().getName());
    int errorFlag=stepProcessing.doProcessing(context,request,response,subInfo);
    if (errorFlag != AbstractProcessingStep.STATUS_COMPLETE) {
      String errorMessage=stepProcessing.getErrorMessage(errorFlag);
      if (errorMessage == null) {
        errorMessage=""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ errorFlag+ ""String_Node_Str""+ ""String_Node_Str"";
      }
      log.error(errorMessage);
    }
    return completeStep(context,request,response,subInfo);
  }
 else   return false;
}",0.9907851087357168
3355,"/** 
 * Initialize the current JSPStepManager object, by loading the  specified step class.
 * @param stepConfig the SubmissionStepConfig object which describes this step's configuration in the item-submission.xml
 * @throws Exception if the JSPStep cannot be loaded or the class specified doesn't implement the JSPStep interface
 */
public static JSPStepManager loadStep(SubmissionStepConfig stepConfig) throws Exception {
  JSPStepManager stepManager=new JSPStepManager();
  stepManager.stepConfig=stepConfig;
  ClassLoader loader=stepManager.getClass().getClassLoader();
  Class stepClass=loader.loadClass(stepConfig.getProcessingClassName());
  Object stepInstance=stepClass.newInstance();
  if (stepInstance instanceof AbstractProcessingStep) {
    stepManager.stepProcessing=(AbstractProcessingStep)stepClass.newInstance();
  }
 else {
    throw new Exception(""String_Node_Str"" + stepConfig.getProcessingClassName() + ""String_Node_Str""+ ""String_Node_Str"");
  }
  stepClass=loader.loadClass(stepConfig.getJSPUIClassName());
  stepInstance=stepClass.newInstance();
  if (stepInstance instanceof JSPStep) {
    stepManager.stepJSPUI=(JSPStep)stepClass.newInstance();
  }
 else {
    throw new Exception(""String_Node_Str"" + stepConfig.getJSPUIClassName() + ""String_Node_Str""+ ""String_Node_Str"");
  }
  return stepManager;
}","/** 
 * Initialize the current JSPStepManager object, by loading the  specified step class.
 * @param stepConfig the SubmissionStepConfig object which describes this step's configuration in the item-submission.xml
 * @throws Exception if the JSPStep cannot be loaded or the class specified doesn't implement the JSPStep interface
 */
public static JSPStepManager loadStep(SubmissionStepConfig stepConfig) throws Exception {
  JSPStepManager stepManager=new JSPStepManager();
  stepManager.stepConfig=stepConfig;
  ClassLoader loader=stepManager.getClass().getClassLoader();
  Class stepClass=loader.loadClass(stepConfig.getProcessingClassName());
  Object stepInstance=stepClass.newInstance();
  if (stepInstance instanceof AbstractProcessingStep) {
    stepManager.stepProcessing=(AbstractProcessingStep)stepClass.newInstance();
  }
 else {
    throw new Exception(""String_Node_Str"" + stepConfig.getProcessingClassName() + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (stepConfig.getJSPUIClassName() != null && stepConfig.getJSPUIClassName().length() > 0) {
    stepClass=loader.loadClass(stepConfig.getJSPUIClassName());
    stepInstance=stepClass.newInstance();
    if (stepInstance instanceof JSPStep) {
      stepManager.stepJSPUI=(JSPStep)stepClass.newInstance();
    }
 else {
      throw new Exception(""String_Node_Str"" + stepConfig.getJSPUIClassName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  return stepManager;
}",0.9402823018458196
3356,"/** 
 * Method for invoking subscriptions via the command line
 * @param argv command-line arguments, none used yet
 */
public static void main(String[] argv){
  Options options=new Options();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine line=null;
  options.addOption(OptionBuilder.isRequired(false).withDescription(""String_Node_Str"").withLongOpt(""String_Node_Str"").create(""String_Node_Str""));
  boolean test=options.hasOption(""String_Node_Str"");
  if (test)   log.setLevel(Level.DEBUG);
  Context context=null;
  try {
    context=new Context();
    processDaily(context,test);
    context.complete();
  }
 catch (  Exception e) {
    log.fatal(e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}","/** 
 * Method for invoking subscriptions via the command line
 * @param argv command-line arguments, none used yet
 */
public static void main(String[] argv){
  String usage=""String_Node_Str"";
  Options options=new Options();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine line=null;
{
    Option opt=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    opt.setRequired(false);
    options.addOption(opt);
  }
{
    Option opt=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    opt.setRequired(false);
    options.addOption(opt);
  }
  try {
    line=new PosixParser().parse(options,argv);
  }
 catch (  Exception e) {
    formatter.printHelp(usage,e.getMessage(),options,""String_Node_Str"");
    System.exit(1);
  }
  if (line.hasOption(""String_Node_Str"")) {
    formatter.printHelp(usage,options);
    System.exit(1);
  }
  boolean test=line.hasOption(""String_Node_Str"");
  if (test)   log.setLevel(Level.DEBUG);
  Context context=null;
  try {
    context=new Context();
    processDaily(context,test);
    context.complete();
  }
 catch (  Exception e) {
    log.fatal(e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}",0.6813186813186813
3357,"/** 
 * Method for invoking subscriptions via the command line
 * @param argv command-line arguments, none used yet
 */
public static void main(String[] argv){
  Options options=new Options();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine line=null;
  options.addOption(OptionBuilder.isRequired(false).withDescription(""String_Node_Str"").withLongOpt(""String_Node_Str"").create(""String_Node_Str""));
  boolean test=options.hasOption(""String_Node_Str"");
  if (test)   log.setLevel(Level.DEBUG);
  Context context=null;
  try {
    context=new Context();
    processDaily(context,test);
    context.complete();
  }
 catch (  Exception e) {
    log.fatal(e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}","/** 
 * Method for invoking subscriptions via the command line
 * @param argv command-line arguments, none used yet
 */
public static void main(String[] argv){
  String usage=""String_Node_Str"";
  Options options=new Options();
  HelpFormatter formatter=new HelpFormatter();
  CommandLine line=null;
{
    Option opt=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    opt.setRequired(false);
    options.addOption(opt);
  }
{
    Option opt=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    opt.setRequired(false);
    options.addOption(opt);
  }
  try {
    line=new PosixParser().parse(options,argv);
  }
 catch (  Exception e) {
    formatter.printHelp(usage,e.getMessage(),options,""String_Node_Str"");
    System.exit(1);
  }
  if (line.hasOption(""String_Node_Str"")) {
    formatter.printHelp(usage,options);
    System.exit(1);
  }
  boolean test=line.hasOption(""String_Node_Str"");
  if (test)   log.setLevel(Level.DEBUG);
  Context context=null;
  try {
    context=new Context();
    processDaily(context,test);
    context.complete();
  }
 catch (  Exception e) {
    log.fatal(e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}",0.6813186813186813
3358,"public int authenticate(Context context,String netid,String password,String realm,HttpServletRequest request) throws SQLException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid));
  if (netid == null || password == null)   return BAD_ARGS;
  EPerson eperson=null;
  try {
    eperson=EPerson.findByNetid(context,netid.toLowerCase());
  }
 catch (  SQLException e) {
  }
  boolean loggedIn=false;
  SpeakerToLDAP ldap=new SpeakerToLDAP(log);
  if (eperson != null) {
    if (eperson.getRequireCertificate())     return CERT_REQUIRED;
 else     if (!eperson.canLogIn())     return BAD_ARGS;
{
      if (ldap.ldapAuthenticate(netid,password,context)) {
        context.setCurrentUser(eperson=EPerson.findByNetid(context,netid.toLowerCase()));
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        return SUCCESS;
      }
 else       return BAD_CREDENTIALS;
    }
  }
 else {
    if (ldap.ldapAuthenticate(netid,password,context)) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid));
      if ((ldap.ldapEmail != null) && (!ldap.ldapEmail.equals(""String_Node_Str""))) {
        try {
          eperson=EPerson.findByEmail(context,ldap.ldapEmail);
          if (eperson != null) {
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
            context.setIgnoreAuthorization(true);
            eperson.setNetid(netid);
            eperson.update();
            context.commit();
            context.setIgnoreAuthorization(false);
            context.setCurrentUser(eperson);
            return SUCCESS;
          }
 else {
            if (canSelfRegister(context,request,netid)) {
              try {
                context.setIgnoreAuthorization(true);
                eperson=EPerson.create(context);
                if ((ldap.ldapEmail != null) && (!ldap.ldapEmail.equals(""String_Node_Str"")))                 eperson.setEmail(ldap.ldapEmail);
 else                 eperson.setEmail(netid);
                if ((ldap.ldapGivenName != null) && (!ldap.ldapGivenName.equals(""String_Node_Str"")))                 eperson.setFirstName(ldap.ldapGivenName);
                if ((ldap.ldapSurname != null) && (!ldap.ldapSurname.equals(""String_Node_Str"")))                 eperson.setLastName(ldap.ldapSurname);
                if ((ldap.ldapPhone != null) && (!ldap.ldapPhone.equals(""String_Node_Str"")))                 eperson.setMetadata(""String_Node_Str"",ldap.ldapPhone);
                eperson.setNetid(netid);
                eperson.setCanLogIn(true);
                AuthenticationManager.initEPerson(context,request,eperson);
                eperson.update();
                context.commit();
              }
 catch (              AuthorizeException e) {
                return NO_SUCH_USER;
              }
 finally {
                context.setIgnoreAuthorization(false);
              }
              log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
              return SUCCESS;
            }
 else {
              log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
              return NO_SUCH_USER;
            }
          }
        }
 catch (        AuthorizeException e) {
          eperson=null;
        }
 finally {
          context.setIgnoreAuthorization(false);
        }
      }
    }
  }
  return BAD_ARGS;
}","public int authenticate(Context context,String netid,String password,String realm,HttpServletRequest request) throws SQLException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid));
  if (netid == null || password == null)   return BAD_ARGS;
  EPerson eperson=null;
  try {
    eperson=EPerson.findByNetid(context,netid.toLowerCase());
  }
 catch (  SQLException e) {
  }
  boolean loggedIn=false;
  SpeakerToLDAP ldap=new SpeakerToLDAP(log);
  if (eperson != null) {
    if (eperson.getRequireCertificate())     return CERT_REQUIRED;
 else     if (!eperson.canLogIn())     return BAD_ARGS;
{
      if (ldap.ldapAuthenticate(netid,password,context)) {
        context.setCurrentUser(eperson=EPerson.findByNetid(context,netid.toLowerCase()));
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        return SUCCESS;
      }
 else       return BAD_CREDENTIALS;
    }
  }
 else {
    if (ldap.ldapAuthenticate(netid,password,context)) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + netid));
      if ((ldap.ldapEmail != null) && (!ldap.ldapEmail.equals(""String_Node_Str""))) {
        try {
          eperson=EPerson.findByEmail(context,ldap.ldapEmail);
          if (eperson != null) {
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
            context.setIgnoreAuthorization(true);
            eperson.setNetid(netid);
            eperson.update();
            context.commit();
            context.setIgnoreAuthorization(false);
            context.setCurrentUser(eperson);
            return SUCCESS;
          }
 else {
            if (canSelfRegister(context,request,netid)) {
              try {
                context.setIgnoreAuthorization(true);
                eperson=EPerson.create(context);
                if ((ldap.ldapEmail != null) && (!ldap.ldapEmail.equals(""String_Node_Str"")))                 eperson.setEmail(ldap.ldapEmail);
 else                 eperson.setEmail(netid);
                if ((ldap.ldapGivenName != null) && (!ldap.ldapGivenName.equals(""String_Node_Str"")))                 eperson.setFirstName(ldap.ldapGivenName);
                if ((ldap.ldapSurname != null) && (!ldap.ldapSurname.equals(""String_Node_Str"")))                 eperson.setLastName(ldap.ldapSurname);
                if ((ldap.ldapPhone != null) && (!ldap.ldapPhone.equals(""String_Node_Str"")))                 eperson.setMetadata(""String_Node_Str"",ldap.ldapPhone);
                eperson.setNetid(netid);
                eperson.setCanLogIn(true);
                AuthenticationManager.initEPerson(context,request,eperson);
                eperson.update();
                context.commit();
                context.setCurrentUser(eperson);
              }
 catch (              AuthorizeException e) {
                return NO_SUCH_USER;
              }
 finally {
                context.setIgnoreAuthorization(false);
              }
              log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
              return SUCCESS;
            }
 else {
              log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
              return NO_SUCH_USER;
            }
          }
        }
 catch (        AuthorizeException e) {
          eperson=null;
        }
 finally {
          context.setIgnoreAuthorization(false);
        }
      }
    }
  }
  return BAD_ARGS;
}",0.9929098538561714
3359,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String workspaceID=request.getParameter(""String_Node_Str"");
  String workflowID=request.getParameter(""String_Node_Str"");
  if (workspaceID != null) {
    try {
      WorkspaceItem wi=WorkspaceItem.find(context,Integer.parseInt(workspaceID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      if (getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps()) {
        int lastStep=si.getSubmissionConfig().getNumberOfSteps() - 1;
        wi.setStageReached(lastStep);
        wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);
        wi.update();
        context.commit();
        si.setSubmissionItem(wi);
      }
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceID));
      JSPManager.showInvalidIDError(request,response,workspaceID,-1);
    }
  }
 else   if (workflowID != null) {
    try {
      WorkflowItem wi=WorkflowItem.find(context,Integer.parseInt(workflowID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      FIRST_STEP=0;
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workflowID));
      JSPManager.showInvalidIDError(request,response,workflowID,-1);
    }
  }
 else {
    doDSPost(context,request,response);
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String workspaceID=request.getParameter(""String_Node_Str"");
  String workflowID=request.getParameter(""String_Node_Str"");
  if (workspaceID != null) {
    try {
      WorkspaceItem wi=WorkspaceItem.find(context,Integer.parseInt(workspaceID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      if (getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps()) {
        int lastStep=si.getSubmissionConfig().getNumberOfSteps() - 1;
        wi.setStageReached(lastStep);
        wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);
        wi.update();
        context.commit();
        si.setSubmissionItem(wi);
      }
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceID));
      JSPManager.showInvalidIDError(request,response,workspaceID,-1);
    }
  }
 else   if (workflowID != null) {
    try {
      WorkflowItem wi=WorkflowItem.find(context,Integer.parseInt(workflowID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,WORKFLOW_FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workflowID));
      JSPManager.showInvalidIDError(request,response,workflowID,-1);
    }
  }
 else {
    doDSPost(context,request,response);
  }
}",0.9472443265546714
3360,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String workspaceID=request.getParameter(""String_Node_Str"");
  String workflowID=request.getParameter(""String_Node_Str"");
  if (workspaceID != null) {
    try {
      WorkspaceItem wi=WorkspaceItem.find(context,Integer.parseInt(workspaceID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      if (getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps()) {
        int lastStep=si.getSubmissionConfig().getNumberOfSteps() - 1;
        wi.setStageReached(lastStep);
        wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);
        wi.update();
        context.commit();
        si.setSubmissionItem(wi);
      }
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceID));
      JSPManager.showInvalidIDError(request,response,workspaceID,-1);
    }
  }
 else   if (workflowID != null) {
    try {
      WorkflowItem wi=WorkflowItem.find(context,Integer.parseInt(workflowID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      FIRST_STEP=0;
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workflowID));
      JSPManager.showInvalidIDError(request,response,workflowID,-1);
    }
  }
 else {
    doDSPost(context,request,response);
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String workspaceID=request.getParameter(""String_Node_Str"");
  String workflowID=request.getParameter(""String_Node_Str"");
  if (workspaceID != null) {
    try {
      WorkspaceItem wi=WorkspaceItem.find(context,Integer.parseInt(workspaceID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      if (getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps()) {
        int lastStep=si.getSubmissionConfig().getNumberOfSteps() - 1;
        wi.setStageReached(lastStep);
        wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);
        wi.update();
        context.commit();
        si.setSubmissionItem(wi);
      }
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceID));
      JSPManager.showInvalidIDError(request,response,workspaceID,-1);
    }
  }
 else   if (workflowID != null) {
    try {
      WorkflowItem wi=WorkflowItem.find(context,Integer.parseInt(workflowID));
      SubmissionInfo si=SubmissionInfo.load(request,wi);
      setBeginningOfStep(request,true);
      doStep(context,request,response,si,WORKFLOW_FIRST_STEP);
    }
 catch (    NumberFormatException nfe) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workflowID));
      JSPManager.showInvalidIDError(request,response,workflowID,-1);
    }
  }
 else {
    doDSPost(context,request,response);
  }
}",0.9472443265546714
3361,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  boolean https=request.isSecure();
  String server=request.getServerName();
  int port=request.getServerPort();
  String exitURL=(https) ? ""String_Node_Str"" : ""String_Node_Str"";
  exitURL+=server;
  if (!(port == 80 || port == 443))   exitURL+=""String_Node_Str"" + port;
  exitURL+=actionURL + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  div.setHead(T_submission_head);
  Division progressDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  addSubmissionProgressList(progressDiv);
  progressDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  Division offsiteDiv=div.addInteractiveDivision(""String_Node_Str"",CREATIVE_COMMONS_URL,Division.METHOD_POST);
  offsiteDiv.setHead(T_head);
  offsiteDiv.addPara(T_info1);
  offsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  offsiteDiv.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  offsiteDiv.addHidden(""String_Node_Str"").setValue(exitURL);
  Para ccPara=offsiteDiv.addPara(""String_Node_Str"",""String_Node_Str"");
  ccPara.addButton(""String_Node_Str"").setValue(T_submit_to_creative_commons);
  Division onsiteDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  List form=onsiteDiv.addList(""String_Node_Str"",List.TYPE_FORM);
  form.addLabel(T_license);
  if (CreativeCommons.hasLicense(context,item)) {
    String url=CreativeCommons.getLicenseURL(item);
    form.addItem().addXref(url,url);
    form.addItem().addButton(""String_Node_Str"").setValue(T_submit_remove);
    form.addItem().addHidden(""String_Node_Str"").setValue(url);
  }
 else {
    form.addItem().addHighlight(""String_Node_Str"").addContent(T_no_license);
  }
  addControlButtons(form);
  onsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  boolean https=request.isSecure();
  String server=request.getServerName();
  int port=request.getServerPort();
  String exitURL=(https) ? ""String_Node_Str"" : ""String_Node_Str"";
  exitURL+=server;
  if (!(port == 80 || port == 443))   exitURL+=""String_Node_Str"" + port;
  exitURL+=actionURL + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  div.setHead(T_submission_head);
  Division progressDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  addSubmissionProgressList(progressDiv);
  progressDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  Division offsiteDiv=div.addInteractiveDivision(""String_Node_Str"",CREATIVE_COMMONS_URL,Division.METHOD_POST);
  offsiteDiv.setHead(T_head);
  offsiteDiv.addPara(T_info1);
  offsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  offsiteDiv.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  offsiteDiv.addHidden(""String_Node_Str"").setValue(exitURL);
  Para ccPara=offsiteDiv.addPara(""String_Node_Str"",""String_Node_Str"");
  ccPara.addButton(""String_Node_Str"").setValue(T_submit_to_creative_commons);
  Division onsiteDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  List form=onsiteDiv.addList(""String_Node_Str"",List.TYPE_FORM);
  form.addLabel(T_license);
  if (CreativeCommons.hasLicense(context,item)) {
    String url=CreativeCommons.getLicenseURL(item);
    form.addItem().addXref(url,url);
    form.addItem().addButton(""String_Node_Str"").setValue(T_submit_remove);
    form.addItem().addHidden(""String_Node_Str"").setValue(url);
  }
 else {
    form.addItem().addHighlight(""String_Node_Str"").addContent(T_no_license);
  }
  addControlButtons(form);
}",0.9776255707762556
3362,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  addControlButtons(form);
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  addControlButtons(form);
}",0.9845585767035918
3363,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  BitstreamFormat currentFormat=bitstream.getFormat();
  BitstreamFormat guessedFormat=FormatIdentifier.guessFormat(context,bitstream);
  BitstreamFormat[] bitstreamFormats=BitstreamFormat.findNonInternal(context);
  int itemID=submissionInfo.getSubmissionItem().getItem().getID();
  String fileUrl=contextPath + ""String_Node_Str"" + itemID+ ""String_Node_Str""+ bitstream.getName();
  String fileName=bitstream.getName();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List edit=div.addList(""String_Node_Str"",List.TYPE_FORM);
  edit.setHead(T_head);
  edit.addLabel(T_file);
  edit.addItem().addXref(fileUrl,fileName);
  Text description=edit.addItem().addText(""String_Node_Str"");
  description.setLabel(T_description);
  description.setHelp(T_description_help);
  description.setValue(bitstream.getDescription());
  edit.addItem(T_info1);
  if (guessedFormat != null) {
    edit.addLabel(T_format_detected);
    edit.addItem(guessedFormat.getShortDescription());
  }
  Select format=edit.addItem().addSelect(""String_Node_Str"");
  format.setLabel(T_format_selected);
  format.addOption(-1,T_format_default);
  for (  BitstreamFormat bitstreamFormat : bitstreamFormats) {
    String supportLevel=""String_Node_Str"";
    if (bitstreamFormat.getSupportLevel() == BitstreamFormat.KNOWN)     supportLevel=""String_Node_Str"";
 else     if (bitstreamFormat.getSupportLevel() == BitstreamFormat.SUPPORTED)     supportLevel=""String_Node_Str"";
    String name=bitstreamFormat.getShortDescription() + ""String_Node_Str"" + supportLevel+ ""String_Node_Str"";
    int id=bitstreamFormat.getID();
    format.addOption(id,name);
  }
  if (currentFormat != null) {
    format.setOptionSelected(currentFormat.getID());
  }
 else   if (guessedFormat != null) {
    format.setOptionSelected(guessedFormat.getID());
  }
 else {
    format.setOptionSelected(-1);
  }
  edit.addItem(T_info2);
  Text userFormat=edit.addItem().addText(""String_Node_Str"");
  userFormat.setLabel(T_format_user);
  userFormat.setHelp(T_format_user_help);
  userFormat.setValue(bitstream.getUserFormatDescription());
  div.addHidden(""String_Node_Str"").setValue(bitstream.getID());
  org.dspace.app.xmlui.wing.element.Item actions=edit.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  BitstreamFormat currentFormat=bitstream.getFormat();
  BitstreamFormat guessedFormat=FormatIdentifier.guessFormat(context,bitstream);
  BitstreamFormat[] bitstreamFormats=BitstreamFormat.findNonInternal(context);
  int itemID=submissionInfo.getSubmissionItem().getItem().getID();
  String fileUrl=contextPath + ""String_Node_Str"" + itemID+ ""String_Node_Str""+ bitstream.getName();
  String fileName=bitstream.getName();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List edit=div.addList(""String_Node_Str"",List.TYPE_FORM);
  edit.setHead(T_head);
  edit.addLabel(T_file);
  edit.addItem().addXref(fileUrl,fileName);
  Text description=edit.addItem().addText(""String_Node_Str"");
  description.setLabel(T_description);
  description.setHelp(T_description_help);
  description.setValue(bitstream.getDescription());
  edit.addItem(T_info1);
  if (guessedFormat != null) {
    edit.addLabel(T_format_detected);
    edit.addItem(guessedFormat.getShortDescription());
  }
  Select format=edit.addItem().addSelect(""String_Node_Str"");
  format.setLabel(T_format_selected);
  format.addOption(-1,T_format_default);
  for (  BitstreamFormat bitstreamFormat : bitstreamFormats) {
    String supportLevel=""String_Node_Str"";
    if (bitstreamFormat.getSupportLevel() == BitstreamFormat.KNOWN)     supportLevel=""String_Node_Str"";
 else     if (bitstreamFormat.getSupportLevel() == BitstreamFormat.SUPPORTED)     supportLevel=""String_Node_Str"";
    String name=bitstreamFormat.getShortDescription() + ""String_Node_Str"" + supportLevel+ ""String_Node_Str"";
    int id=bitstreamFormat.getID();
    format.addOption(id,name);
  }
  if (currentFormat != null) {
    format.setOptionSelected(currentFormat.getID());
  }
 else   if (guessedFormat != null) {
    format.setOptionSelected(guessedFormat.getID());
  }
 else {
    format.setOptionSelected(-1);
  }
  edit.addItem(T_info2);
  Text userFormat=edit.addItem().addText(""String_Node_Str"");
  userFormat.setLabel(T_format_user);
  userFormat.setHelp(T_format_user_help);
  userFormat.setValue(bitstream.getUserFormatDescription());
  div.addHidden(""String_Node_Str"").setValue(bitstream.getID());
  org.dspace.app.xmlui.wing.element.Item actions=edit.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
}",0.9834651329978432
3364,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  DCValue[] titles=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] citation=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] publisher=item.getDC(""String_Node_Str"",null,Item.ANY);
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  CheckBox multipleTitles=form.addItem().addCheckBox(""String_Node_Str"");
  multipleTitles.setLabel(T_multiple_titles);
  multipleTitles.setHelp(T_multiple_titles_help);
  multipleTitles.addOption(""String_Node_Str"");
  if (submission.hasMultipleTitles()) {
    multipleTitles.setOptionSelected(""String_Node_Str"");
  }
  if (titles.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_multiple_titles_note);
    for (int i=0; i < titles.length; i++) {
      if (i > 0)       note.addContent(T_separator);
      note.addContent(""String_Node_Str"");
      note.addHighlight(""String_Node_Str"").addContent(titles[i].value);
      note.addContent(""String_Node_Str"");
    }
  }
  CheckBox publishedBefore=form.addItem().addCheckBox(""String_Node_Str"");
  publishedBefore.setLabel(T_published_before);
  publishedBefore.setHelp(T_published_before_help);
  publishedBefore.addOption(""String_Node_Str"");
  if (submission.isPublishedBefore()) {
    publishedBefore.setOptionSelected(""String_Node_Str"");
  }
  if (dateIssued.length > 0 || citation.length > 0 || publisher.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_published_before_note);
    if (dateIssued.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_date_issued);
      note.addContent(T_open);
      for (int i=0; i < dateIssued.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(dateIssued[i].value);
      }
      note.addContent(T_close);
    }
    if (dateIssued.length > 0 && (citation.length > 0 || publisher.length > 0))     note.addContent(T_separator);
    if (dateIssued.length > 0 && citation.length > 0 && publisher.length == 0) {
      note.addContent(T_and);
    }
    if (citation.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_citation);
      note.addContent(T_open);
      for (int i=0; i < citation.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(citation[i].value);
      }
      note.addContent(T_close);
    }
    if (citation.length > 0 && publisher.length > 0) {
      note.addContent(T_separator);
    }
    if ((dateIssued.length > 0 || citation.length > 0) && publisher.length > 0) {
      note.addContent(T_and);
    }
    if (publisher.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_publisher);
      note.addContent(T_open);
      for (int i=0; i < publisher.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(publisher[i].value);
      }
      note.addContent(T_close);
    }
  }
  addControlButtons(form);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  DCValue[] titles=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] citation=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] publisher=item.getDC(""String_Node_Str"",null,Item.ANY);
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  CheckBox multipleTitles=form.addItem().addCheckBox(""String_Node_Str"");
  multipleTitles.setLabel(T_multiple_titles);
  multipleTitles.setHelp(T_multiple_titles_help);
  multipleTitles.addOption(""String_Node_Str"");
  if (submission.hasMultipleTitles()) {
    multipleTitles.setOptionSelected(""String_Node_Str"");
  }
  if (titles.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_multiple_titles_note);
    for (int i=0; i < titles.length; i++) {
      if (i > 0)       note.addContent(T_separator);
      note.addContent(""String_Node_Str"");
      note.addHighlight(""String_Node_Str"").addContent(titles[i].value);
      note.addContent(""String_Node_Str"");
    }
  }
  CheckBox publishedBefore=form.addItem().addCheckBox(""String_Node_Str"");
  publishedBefore.setLabel(T_published_before);
  publishedBefore.setHelp(T_published_before_help);
  publishedBefore.addOption(""String_Node_Str"");
  if (submission.isPublishedBefore()) {
    publishedBefore.setOptionSelected(""String_Node_Str"");
  }
  if (dateIssued.length > 0 || citation.length > 0 || publisher.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_published_before_note);
    if (dateIssued.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_date_issued);
      note.addContent(T_open);
      for (int i=0; i < dateIssued.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(dateIssued[i].value);
      }
      note.addContent(T_close);
    }
    if (dateIssued.length > 0 && (citation.length > 0 || publisher.length > 0))     note.addContent(T_separator);
    if (dateIssued.length > 0 && citation.length > 0 && publisher.length == 0) {
      note.addContent(T_and);
    }
    if (citation.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_citation);
      note.addContent(T_open);
      for (int i=0; i < citation.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(citation[i].value);
      }
      note.addContent(T_close);
    }
    if (citation.length > 0 && publisher.length > 0) {
      note.addContent(T_separator);
    }
    if ((dateIssued.length > 0 || citation.length > 0) && publisher.length > 0) {
      note.addContent(T_and);
    }
    if (publisher.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_publisher);
      note.addContent(T_open);
      for (int i=0; i < publisher.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(publisher[i].value);
      }
      note.addContent(T_close);
    }
  }
  addControlButtons(form);
  div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
}",0.987958115183246
3365,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (CreativeCommons.isEnabled() && ccLicenseStep != null) {
    ccLicenseStep.addBody(body);
    return;
  }
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  String licenseText=collection.getLicense();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  Division inner=div.addDivision(""String_Node_Str"");
  inner.setHead(T_head);
  inner.addPara(T_info1);
  inner.addPara(T_info2);
  Division displayLicense=inner.addDivision(""String_Node_Str"",""String_Node_Str"");
  displayLicense.addSimpleHTMLFragment(true,licenseText);
  inner.addPara(T_info3);
  List controls=inner.addList(""String_Node_Str"",List.TYPE_FORM);
  CheckBox decision=controls.addItem().addCheckBox(""String_Node_Str"");
  decision.setLabel(T_decision_label);
  decision.addOption(""String_Node_Str"",T_decision_checkbox);
  if (this.errorFlag == org.dspace.submit.step.LicenseStep.STATUS_LICENSE_REJECTED) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",submissionInfo.getSubmissionLogInfo()));
    decision.addError(T_decision_error);
  }
  addControlButtons(controls);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (CreativeCommons.isEnabled() && ccLicenseStep != null) {
    ccLicenseStep.addBody(body);
    return;
  }
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  String licenseText=collection.getLicense();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  Division inner=div.addDivision(""String_Node_Str"");
  inner.setHead(T_head);
  inner.addPara(T_info1);
  inner.addPara(T_info2);
  Division displayLicense=inner.addDivision(""String_Node_Str"",""String_Node_Str"");
  displayLicense.addSimpleHTMLFragment(true,licenseText);
  inner.addPara(T_info3);
  List controls=inner.addList(""String_Node_Str"",List.TYPE_FORM);
  CheckBox decision=controls.addItem().addCheckBox(""String_Node_Str"");
  decision.setLabel(T_decision_label);
  decision.addOption(""String_Node_Str"",T_decision_checkbox);
  if (this.errorFlag == org.dspace.submit.step.LicenseStep.STATUS_LICENSE_REJECTED) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",submissionInfo.getSubmissionLogInfo()));
    decision.addError(T_decision_error);
  }
  addControlButtons(controls);
}",0.968384879725086
3366,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  org.dspace.app.xmlui.wing.element.Item actions=form.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_resume);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  org.dspace.app.xmlui.wing.element.Item actions=form.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_resume);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
}",0.9692101740294512
3367,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  SubmissionConfig subConfig=submissionInfo.getSubmissionConfig();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List review=div.addList(""String_Node_Str"",List.TYPE_FORM);
  review.setHead(T_head);
  Set submissionPagesSet=submissionInfo.getProgressBarInfo().keySet();
  String[] submissionPages=(String[])submissionPagesSet.toArray(new String[submissionPagesSet.size()]);
  for (int i=0; i < submissionPages.length; i++) {
    double currentStepAndPage=Double.valueOf(submissionPages[i]).doubleValue();
    if (currentStepAndPage == this.stepAndPage) {
      break;
    }
    SubmissionStepConfig stepConfig=subConfig.getStep(FlowUtils.getStep(currentStepAndPage));
    AbstractStep stepUIClass=loadXMLUIClass(stepConfig.getXMLUIClassName());
    try {
      parameters.setParameter(""String_Node_Str"",Double.toString(currentStepAndPage));
      stepUIClass.setup(resolver,objectModel,src,parameters);
    }
 catch (    Exception e) {
      throw new UIException(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"",e);
    }
    if (stepUIClass instanceof AbstractSubmissionStep) {
      List stepSection=((AbstractSubmissionStep)stepUIClass).addReviewSection(review);
      if (stepSection != null) {
        addJumpButton(stepSection,T_submit_jump,currentStepAndPage);
      }
    }
 else {
      log.warn(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"");
    }
  }
  addControlButtons(review);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  SubmissionConfig subConfig=submissionInfo.getSubmissionConfig();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List review=div.addList(""String_Node_Str"",List.TYPE_FORM);
  review.setHead(T_head);
  Set submissionPagesSet=submissionInfo.getProgressBarInfo().keySet();
  String[] submissionPages=(String[])submissionPagesSet.toArray(new String[submissionPagesSet.size()]);
  for (int i=0; i < submissionPages.length; i++) {
    double currentStepAndPage=Double.valueOf(submissionPages[i]).doubleValue();
    if (currentStepAndPage == this.stepAndPage) {
      break;
    }
    SubmissionStepConfig stepConfig=subConfig.getStep(FlowUtils.getStep(currentStepAndPage));
    AbstractStep stepUIClass=loadXMLUIClass(stepConfig.getXMLUIClassName());
    try {
      parameters.setParameter(""String_Node_Str"",Double.toString(currentStepAndPage));
      stepUIClass.setup(resolver,objectModel,src,parameters);
    }
 catch (    Exception e) {
      throw new UIException(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"",e);
    }
    if (stepUIClass instanceof AbstractSubmissionStep) {
      List stepSection=((AbstractSubmissionStep)stepUIClass).addReviewSection(review);
      if (stepSection != null) {
        addJumpButton(stepSection,T_submit_jump,currentStepAndPage);
      }
    }
 else {
      log.warn(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"");
    }
  }
  addControlButtons(review);
}",0.975763962065332
3368,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List saveOrCancel=div.addList(""String_Node_Str"",List.TYPE_FORM);
  saveOrCancel.setHead(T_head);
  saveOrCancel.addItem(T_info1);
  saveOrCancel.addItem().addButton(""String_Node_Str"").setValue(T_submit_back);
  org.dspace.app.xmlui.wing.element.Item actions=saveOrCancel.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_remove);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List saveOrCancel=div.addList(""String_Node_Str"",List.TYPE_FORM);
  saveOrCancel.setHead(T_head);
  saveOrCancel.addItem(T_info1);
  saveOrCancel.addItem().addButton(""String_Node_Str"").setValue(T_submit_back);
  org.dspace.app.xmlui.wing.element.Item actions=saveOrCancel.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_remove);
}",0.9498364231188658
3369,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection[] collections;
  DSpaceObject dso=HandleManager.resolveToObject(context,handle);
  if (dso != null && dso instanceof Community) {
    collections=Collection.findAuthorized(context,((Community)dso),Constants.ADD);
  }
 else {
    collections=Collection.findAuthorized(context,null,Constants.ADD);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  List list=div.addList(""String_Node_Str"",List.TYPE_FORM);
  list.setHead(T_head);
  Select select=list.addItem().addSelect(""String_Node_Str"");
  select.setLabel(T_collection);
  select.setHelp(T_collection_help);
  select.addOption(""String_Node_Str"",T_collection_default);
  for (  Collection collection : collections) {
    String name=collection.getMetadata(""String_Node_Str"");
    if (name.length() > 50)     name=name.substring(0,47) + ""String_Node_Str"";
    select.addOption(collection.getHandle(),name);
  }
  Button submit=list.addItem().addButton(""String_Node_Str"");
  submit.setValue(T_submit_next);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection[] collections;
  String actionURL=contextPath + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  DSpaceObject dso=HandleManager.resolveToObject(context,handle);
  if (dso != null && dso instanceof Community) {
    collections=Collection.findAuthorized(context,((Community)dso),Constants.ADD);
  }
 else {
    collections=Collection.findAuthorized(context,null,Constants.ADD);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  List list=div.addList(""String_Node_Str"",List.TYPE_FORM);
  list.setHead(T_head);
  Select select=list.addItem().addSelect(""String_Node_Str"");
  select.setLabel(T_collection);
  select.setHelp(T_collection_help);
  select.addOption(""String_Node_Str"",T_collection_default);
  for (  Collection collection : collections) {
    String name=collection.getMetadata(""String_Node_Str"");
    if (name.length() > 50)     name=name.substring(0,47) + ""String_Node_Str"";
    select.addOption(collection.getHandle(),name);
  }
  Button submit=list.addItem().addButton(""String_Node_Str"");
  submit.setValue(T_submit_next);
}",0.927818962153726
3370,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.editFile != null) {
    editFile.addBody(body);
    return;
  }
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  boolean workflow=submission instanceof WorkflowItem;
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  Bitstream[] bitstreams=new Bitstream[0];
  if (bundles.length > 0) {
    bitstreams=bundles[0].getBitstreams();
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_MULTIPART,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List upload=null;
  if (!workflow) {
    upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
    upload.setHead(T_head);
    File file=upload.addItem().addFile(""String_Node_Str"");
    file.setLabel(T_file);
    file.setHelp(T_file_help);
    file.setRequired();
    if (this.errorFlag == org.dspace.submit.step.UploadStep.STATUS_NO_FILES_ERROR)     file.addError(T_file_error);
    Text description=upload.addItem().addText(""String_Node_Str"");
    description.setLabel(T_description);
    description.setHelp(T_description_help);
    Button uploadSubmit=upload.addItem().addButton(""String_Node_Str"");
    uploadSubmit.setValue(T_submit_upload);
  }
  if (bitstreams.length > 0 || workflow) {
    Table summary=div.addTable(""String_Node_Str"",(bitstreams.length * 2) + 2,7);
    summary.setHead(T_head2);
    Row header=summary.addRow(Row.ROLE_HEADER);
    header.addCellContent(T_column1);
    header.addCellContent(T_column2);
    header.addCellContent(T_column3);
    header.addCellContent(T_column4);
    header.addCellContent(T_column5);
    header.addCellContent(T_column6);
    for (    Bitstream bitstream : bitstreams) {
      int id=bitstream.getID();
      String name=bitstream.getName();
      String url=contextPath + ""String_Node_Str"" + item.getID()+ ""String_Node_Str""+ name;
      long bytes=bitstream.getSize();
      String desc=bitstream.getDescription();
      String algorithm=bitstream.getChecksumAlgorithm();
      String checksum=bitstream.getChecksum();
      BitstreamFormat format=bitstream.getFormat();
      int support=format.getSupportLevel();
      Row row=summary.addRow();
      if (!workflow) {
        CheckBox remove=row.addCell().addCheckBox(""String_Node_Str"");
        remove.setLabel(""String_Node_Str"");
        remove.addOption(id);
      }
 else {
        row.addCell();
      }
      row.addCell().addXref(url,name);
      row.addCellContent(bytes + ""String_Node_Str"");
      if (desc == null || desc.length() == 0)       row.addCellContent(T_unknown_name);
 else       row.addCellContent(desc);
      if (format == null) {
        row.addCellContent(T_unknown_format);
      }
 else {
        Cell cell=row.addCell();
        cell.addContent(format.getMIMEType());
        cell.addContent(""String_Node_Str"");
switch (support) {
case 1:
          cell.addContent(T_supported);
        break;
case 2:
      cell.addContent(T_known);
    break;
case 3:
  cell.addContent(T_unsupported);
break;
}
}
Button edit=row.addCell().addButton(""String_Node_Str"" + id);
edit.setValue(T_submit_edit);
Row checksumRow=summary.addRow();
checksumRow.addCell();
Cell checksumCell=checksumRow.addCell(null,null,0,6,null);
checksumCell.addHighlight(""String_Node_Str"").addContent(T_checksum);
checksumCell.addContent(""String_Node_Str"");
checksumCell.addContent(algorithm + ""String_Node_Str"" + checksum);
}
if (!workflow) {
Row actionRow=summary.addRow();
actionRow.addCell();
Button removeSeleceted=actionRow.addCell(null,null,0,6,null).addButton(""String_Node_Str"");
removeSeleceted.setValue(T_submit_remove);
}
upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
}
addControlButtons(upload);
div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.editFile != null) {
    editFile.addBody(body);
    return;
  }
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str""+ knot.getId()+ ""String_Node_Str"";
  boolean workflow=submission instanceof WorkflowItem;
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  Bitstream[] bitstreams=new Bitstream[0];
  if (bundles.length > 0) {
    bitstreams=bundles[0].getBitstreams();
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_MULTIPART,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List upload=null;
  if (!workflow) {
    upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
    upload.setHead(T_head);
    File file=upload.addItem().addFile(""String_Node_Str"");
    file.setLabel(T_file);
    file.setHelp(T_file_help);
    file.setRequired();
    if (this.errorFlag == org.dspace.submit.step.UploadStep.STATUS_NO_FILES_ERROR)     file.addError(T_file_error);
    Text description=upload.addItem().addText(""String_Node_Str"");
    description.setLabel(T_description);
    description.setHelp(T_description_help);
    Button uploadSubmit=upload.addItem().addButton(""String_Node_Str"");
    uploadSubmit.setValue(T_submit_upload);
  }
  if (bitstreams.length > 0 || workflow) {
    Table summary=div.addTable(""String_Node_Str"",(bitstreams.length * 2) + 2,7);
    summary.setHead(T_head2);
    Row header=summary.addRow(Row.ROLE_HEADER);
    header.addCellContent(T_column1);
    header.addCellContent(T_column2);
    header.addCellContent(T_column3);
    header.addCellContent(T_column4);
    header.addCellContent(T_column5);
    header.addCellContent(T_column6);
    for (    Bitstream bitstream : bitstreams) {
      int id=bitstream.getID();
      String name=bitstream.getName();
      String url=contextPath + ""String_Node_Str"" + item.getID()+ ""String_Node_Str""+ name;
      long bytes=bitstream.getSize();
      String desc=bitstream.getDescription();
      String algorithm=bitstream.getChecksumAlgorithm();
      String checksum=bitstream.getChecksum();
      BitstreamFormat format=bitstream.getFormat();
      int support=format.getSupportLevel();
      Row row=summary.addRow();
      if (!workflow) {
        CheckBox remove=row.addCell().addCheckBox(""String_Node_Str"");
        remove.setLabel(""String_Node_Str"");
        remove.addOption(id);
      }
 else {
        row.addCell();
      }
      row.addCell().addXref(url,name);
      row.addCellContent(bytes + ""String_Node_Str"");
      if (desc == null || desc.length() == 0)       row.addCellContent(T_unknown_name);
 else       row.addCellContent(desc);
      if (format == null) {
        row.addCellContent(T_unknown_format);
      }
 else {
        Cell cell=row.addCell();
        cell.addContent(format.getMIMEType());
        cell.addContent(""String_Node_Str"");
switch (support) {
case 1:
          cell.addContent(T_supported);
        break;
case 2:
      cell.addContent(T_known);
    break;
case 3:
  cell.addContent(T_unsupported);
break;
}
}
Button edit=row.addCell().addButton(""String_Node_Str"" + id);
edit.setValue(T_submit_edit);
Row checksumRow=summary.addRow();
checksumRow.addCell();
Cell checksumCell=checksumRow.addCell(null,null,0,6,null);
checksumCell.addHighlight(""String_Node_Str"").addContent(T_checksum);
checksumCell.addContent(""String_Node_Str"");
checksumCell.addContent(algorithm + ""String_Node_Str"" + checksum);
}
if (!workflow) {
Row actionRow=summary.addRow();
actionRow.addCell();
Button removeSeleceted=actionRow.addCell(null,null,0,6,null).addButton(""String_Node_Str"");
removeSeleceted.setValue(T_submit_remove);
}
upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
}
addControlButtons(upload);
}",0.9886449659348978
3371,"/** 
 * Initialise various variables, read in config etc.
 * @param context DSpace context
 */
private static void init(Context context) throws SQLException, IOException {
  if (licenseFormat != -1) {
    return;
  }
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(context,""String_Node_Str"");
  licenseFormat=bf.getID();
  String configFile=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  InputStream is=new FileInputStream(configFile);
  dcToMODS=new Properties();
  dcToMODS.load(is);
}","/** 
 * Initialise various variables, read in config etc.
 * @param context DSpace context
 */
private static void init(Context context) throws SQLException, IOException {
  if (licenseFormat != -1) {
    return;
  }
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(context,""String_Node_Str"");
  licenseFormat=bf.getID();
  String configFile=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  InputStream is=null;
  try {
    is=new FileInputStream(configFile);
    dcToMODS=new Properties();
    dcToMODS.load(is);
  }
  finally {
    if (is != null)     try {
      is.close();
    }
 catch (    IOException ioe) {
    }
  }
}",0.8948995363214838
3372,"/** 
 * read in the action map file which converts log file line actions into actions which are more understandable to humans
 * @param map     the map file
 */
public static void readMap(String map) throws IOException {
  FileReader fr=null;
  BufferedReader br=null;
  String record=null;
  try {
    fr=new FileReader(map);
    br=new BufferedReader(fr);
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
    return;
  }
  while ((record=br.readLine()) != null) {
    Matcher matchReal=real.matcher(record);
    if (matchReal.matches()) {
      actionMap.put(matchReal.group(1).trim(),matchReal.group(2).trim());
    }
  }
}","/** 
 * read in the action map file which converts log file line actions into actions which are more understandable to humans
 * @param map     the map file
 */
public static void readMap(String map) throws IOException {
  FileReader fr=null;
  BufferedReader br=null;
  try {
    String record=null;
    try {
      fr=new FileReader(map);
      br=new BufferedReader(fr);
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"");
      return;
    }
    while ((record=br.readLine()) != null) {
      Matcher matchReal=real.matcher(record);
      if (matchReal.matches()) {
        actionMap.put(matchReal.group(1).trim(),matchReal.group(2).trim());
      }
    }
  }
  finally {
    if (br != null)     try {
      br.close();
    }
 catch (    IOException ioe) {
    }
    if (fr != null)     try {
      fr.close();
    }
 catch (    IOException ioe) {
    }
  }
}",0.8067444876783398
3373,"/** 
 * Return a List of the policies for a group
 * @param c  current context
 * @param g  group to retrieve policies for
 * @return List of <code>ResourcePolicy</code> objects
 */
public static List<ResourcePolicy> getPoliciesForGroup(Context c,Group g) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",g.getID());
  List<ResourcePolicy> policies=new ArrayList<ResourcePolicy>();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
    if (cachepolicy != null) {
      policies.add(cachepolicy);
    }
 else {
      policies.add(new ResourcePolicy(c,row));
    }
  }
  tri.close();
  return policies;
}","/** 
 * Return a List of the policies for a group
 * @param c  current context
 * @param g  group to retrieve policies for
 * @return List of <code>ResourcePolicy</code> objects
 */
public static List<ResourcePolicy> getPoliciesForGroup(Context c,Group g) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",g.getID());
  List<ResourcePolicy> policies=new ArrayList<ResourcePolicy>();
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
      if (cachepolicy != null) {
        policies.add(cachepolicy);
      }
 else {
        policies.add(new ResourcePolicy(c,row));
      }
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return policies;
}",0.9579524680073126
3374,"/** 
 * Return a list of policies for an object that match the action
 * @param c context
 * @param o DSpaceObject policies relate to
 * @param actionID action (defined in class Constants)
 * @throws SQLException if there's a database problem
 */
public static List<ResourcePolicy> getPoliciesActionFilter(Context c,DSpaceObject o,int actionID) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",o.getType(),o.getID(),actionID);
  List<ResourcePolicy> policies=new ArrayList<ResourcePolicy>();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
    if (cachepolicy != null) {
      policies.add(cachepolicy);
    }
 else {
      policies.add(new ResourcePolicy(c,row));
    }
  }
  tri.close();
  return policies;
}","/** 
 * Return a list of policies for an object that match the action
 * @param c context
 * @param o DSpaceObject policies relate to
 * @param actionID action (defined in class Constants)
 * @throws SQLException if there's a database problem
 */
public static List<ResourcePolicy> getPoliciesActionFilter(Context c,DSpaceObject o,int actionID) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",o.getType(),o.getID(),actionID);
  List<ResourcePolicy> policies=new ArrayList<ResourcePolicy>();
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
      if (cachepolicy != null) {
        policies.add(cachepolicy);
      }
 else {
        policies.add(new ResourcePolicy(c,row));
      }
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return policies;
}",0.9637033140452392
3375,"/** 
 * Returns all groups authorized to perform an action on an object. Returns empty array if no matches.
 * @param c current context
 * @param o object
 * @param actionID ID of action frm <code>org.dspace.core.Constants</code>
 * @return array of <code>Group</code>s that can perform the specifiedaction on the specified object
 * @throws java.sql.SQLException if there's a database problem
 */
public static Group[] getAuthorizedGroups(Context c,DSpaceObject o,int actionID) throws java.sql.SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",o.getType(),o.getID(),actionID);
  List<Group> groups=new ArrayList<Group>();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
    ResourcePolicy myPolicy=null;
    if (cachepolicy != null) {
      myPolicy=cachepolicy;
    }
 else {
      myPolicy=new ResourcePolicy(c,row);
    }
    Group myGroup=myPolicy.getGroup();
    if (myGroup != null) {
      groups.add(myGroup);
    }
  }
  tri.close();
  Group[] groupArray=new Group[groups.size()];
  groupArray=groups.toArray(groupArray);
  return groupArray;
}","/** 
 * Returns all groups authorized to perform an action on an object. Returns empty array if no matches.
 * @param c current context
 * @param o object
 * @param actionID ID of action frm <code>org.dspace.core.Constants</code>
 * @return array of <code>Group</code>s that can perform the specifiedaction on the specified object
 * @throws java.sql.SQLException if there's a database problem
 */
public static Group[] getAuthorizedGroups(Context c,DSpaceObject o,int actionID) throws java.sql.SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",o.getType(),o.getID(),actionID);
  List<Group> groups=new ArrayList<Group>();
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
      ResourcePolicy myPolicy=null;
      if (cachepolicy != null) {
        myPolicy=cachepolicy;
      }
 else {
        myPolicy=new ResourcePolicy(c,row);
      }
      Group myGroup=myPolicy.getGroup();
      if (myGroup != null) {
        groups.add(myGroup);
      }
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  Group[] groupArray=new Group[groups.size()];
  groupArray=groups.toArray(groupArray);
  return groupArray;
}",0.9694154084397988
3376,"/** 
 * Return a List of the policies for an object
 * @param c  current context
 * @param o  object to retrieve policies for
 * @return List of <code>ResourcePolicy</code> objects
 */
public static List<ResourcePolicy> getPolicies(Context c,DSpaceObject o) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",o.getType(),o.getID());
  List<ResourcePolicy> policies=new ArrayList();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
    if (cachepolicy != null) {
      policies.add(cachepolicy);
    }
 else {
      policies.add(new ResourcePolicy(c,row));
    }
  }
  tri.close();
  return policies;
}","/** 
 * Return a List of the policies for an object
 * @param c  current context
 * @param o  object to retrieve policies for
 * @return List of <code>ResourcePolicy</code> objects
 */
public static List<ResourcePolicy> getPolicies(Context c,DSpaceObject o) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",o.getType(),o.getID());
  List<ResourcePolicy> policies=new ArrayList();
  try {
    while (tri.hasNext()) {
      TableRow row=tri.next();
      ResourcePolicy cachepolicy=(ResourcePolicy)c.fromCache(ResourcePolicy.class,row.getIntColumn(""String_Node_Str""));
      if (cachepolicy != null) {
        policies.add(cachepolicy);
      }
 else {
        policies.add(new ResourcePolicy(c,row));
      }
    }
  }
  finally {
    if (tri != null)     tri.close();
  }
  return policies;
}",0.9578497251069028
3377,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  boolean https=request.isSecure();
  String server=request.getServerName();
  int port=request.getServerPort();
  String exitURL=(https) ? ""String_Node_Str"" : ""String_Node_Str"";
  exitURL+=server;
  if (!(port == 80 || port == 443))   exitURL+=""String_Node_Str"" + port;
  exitURL+=actionURL + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  div.setHead(T_submission_head);
  Division progressDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  addSubmissionProgressList(progressDiv);
  progressDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  Division offsiteDiv=div.addInteractiveDivision(""String_Node_Str"",CREATIVE_COMMONS_URL,Division.METHOD_POST);
  offsiteDiv.setHead(T_head);
  offsiteDiv.addPara(T_info1);
  offsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  offsiteDiv.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  offsiteDiv.addHidden(""String_Node_Str"").setValue(exitURL);
  Para ccPara=offsiteDiv.addPara(""String_Node_Str"",""String_Node_Str"");
  ccPara.addButton(""String_Node_Str"").setValue(T_submit_to_creative_commons);
  Division onsiteDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  List form=onsiteDiv.addList(""String_Node_Str"",List.TYPE_FORM);
  form.addLabel(T_license);
  if (CreativeCommons.hasLicense(context,item)) {
    String url=CreativeCommons.getLicenseURL(item);
    form.addItem().addXref(url,url);
    form.addItem().addButton(""String_Node_Str"").setValue(T_submit_remove);
    form.addItem().addHidden(""String_Node_Str"").setValue(url);
  }
 else {
    form.addItem().addHighlight(""String_Node_Str"").addContent(T_no_license);
  }
  addControlButtons(form);
  onsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  boolean https=request.isSecure();
  String server=request.getServerName();
  int port=request.getServerPort();
  String exitURL=(https) ? ""String_Node_Str"" : ""String_Node_Str"";
  exitURL+=server;
  if (!(port == 80 || port == 443))   exitURL+=""String_Node_Str"" + port;
  exitURL+=actionURL + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  div.setHead(T_submission_head);
  Division progressDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  addSubmissionProgressList(progressDiv);
  progressDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  Division offsiteDiv=div.addInteractiveDivision(""String_Node_Str"",CREATIVE_COMMONS_URL,Division.METHOD_POST);
  offsiteDiv.setHead(T_head);
  offsiteDiv.addPara(T_info1);
  offsiteDiv.addHidden(""String_Node_Str"").setValue(knot.getId());
  offsiteDiv.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  offsiteDiv.addHidden(""String_Node_Str"").setValue(exitURL);
  Para ccPara=offsiteDiv.addPara(""String_Node_Str"",""String_Node_Str"");
  ccPara.addButton(""String_Node_Str"").setValue(T_submit_to_creative_commons);
  Division onsiteDiv=div.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST);
  List form=onsiteDiv.addList(""String_Node_Str"",List.TYPE_FORM);
  form.addLabel(T_license);
  if (CreativeCommons.hasLicense(context,item)) {
    String url=CreativeCommons.getLicenseURL(item);
    form.addItem().addXref(url,url);
    form.addItem().addButton(""String_Node_Str"").setValue(T_submit_remove);
    form.addItem().addHidden(""String_Node_Str"").setValue(url);
  }
 else {
    form.addItem().addHighlight(""String_Node_Str"").addContent(T_no_license);
  }
  addControlButtons(form);
}",0.977319587628866
3378,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(IdentifierService.getCanonicalForm(submission.getCollection()));
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  addControlButtons(form);
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(IdentifierService.getCanonicalForm(submission.getCollection()));
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  addControlButtons(form);
}",0.9844767150726088
3379,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  BitstreamFormat currentFormat=bitstream.getFormat();
  BitstreamFormat guessedFormat=FormatIdentifier.guessFormat(context,bitstream);
  BitstreamFormat[] bitstreamFormats=BitstreamFormat.findNonInternal(context);
  int itemID=submissionInfo.getSubmissionItem().getItem().getID();
  String fileUrl=contextPath + ""String_Node_Str"" + itemID+ ""String_Node_Str""+ bitstream.getName();
  String fileName=bitstream.getName();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List edit=div.addList(""String_Node_Str"",List.TYPE_FORM);
  edit.setHead(T_head);
  edit.addLabel(T_file);
  edit.addItem().addXref(fileUrl,fileName);
  Text description=edit.addItem().addText(""String_Node_Str"");
  description.setLabel(T_description);
  description.setHelp(T_description_help);
  description.setValue(bitstream.getDescription());
  edit.addItem(T_info1);
  if (guessedFormat != null) {
    edit.addLabel(T_format_detected);
    edit.addItem(guessedFormat.getShortDescription());
  }
  Select format=edit.addItem().addSelect(""String_Node_Str"");
  format.setLabel(T_format_selected);
  format.addOption(-1,T_format_default);
  for (  BitstreamFormat bitstreamFormat : bitstreamFormats) {
    String supportLevel=""String_Node_Str"";
    if (bitstreamFormat.getSupportLevel() == BitstreamFormat.KNOWN)     supportLevel=""String_Node_Str"";
 else     if (bitstreamFormat.getSupportLevel() == BitstreamFormat.SUPPORTED)     supportLevel=""String_Node_Str"";
    String name=bitstreamFormat.getShortDescription() + ""String_Node_Str"" + supportLevel+ ""String_Node_Str"";
    int id=bitstreamFormat.getID();
    format.addOption(id,name);
  }
  if (currentFormat != null) {
    format.setOptionSelected(currentFormat.getID());
  }
 else   if (guessedFormat != null) {
    format.setOptionSelected(guessedFormat.getID());
  }
 else {
    format.setOptionSelected(-1);
  }
  edit.addItem(T_info2);
  Text userFormat=edit.addItem().addText(""String_Node_Str"");
  userFormat.setLabel(T_format_user);
  userFormat.setHelp(T_format_user_help);
  userFormat.setValue(bitstream.getUserFormatDescription());
  div.addHidden(""String_Node_Str"").setValue(bitstream.getID());
  org.dspace.app.xmlui.wing.element.Item actions=edit.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  BitstreamFormat currentFormat=bitstream.getFormat();
  BitstreamFormat guessedFormat=FormatIdentifier.guessFormat(context,bitstream);
  BitstreamFormat[] bitstreamFormats=BitstreamFormat.findNonInternal(context);
  int itemID=submissionInfo.getSubmissionItem().getItem().getID();
  String fileUrl=contextPath + ""String_Node_Str"" + itemID+ ""String_Node_Str""+ bitstream.getName();
  String fileName=bitstream.getName();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List edit=div.addList(""String_Node_Str"",List.TYPE_FORM);
  edit.setHead(T_head);
  edit.addLabel(T_file);
  edit.addItem().addXref(fileUrl,fileName);
  Text description=edit.addItem().addText(""String_Node_Str"");
  description.setLabel(T_description);
  description.setHelp(T_description_help);
  description.setValue(bitstream.getDescription());
  edit.addItem(T_info1);
  if (guessedFormat != null) {
    edit.addLabel(T_format_detected);
    edit.addItem(guessedFormat.getShortDescription());
  }
  Select format=edit.addItem().addSelect(""String_Node_Str"");
  format.setLabel(T_format_selected);
  format.addOption(-1,T_format_default);
  for (  BitstreamFormat bitstreamFormat : bitstreamFormats) {
    String supportLevel=""String_Node_Str"";
    if (bitstreamFormat.getSupportLevel() == BitstreamFormat.KNOWN)     supportLevel=""String_Node_Str"";
 else     if (bitstreamFormat.getSupportLevel() == BitstreamFormat.SUPPORTED)     supportLevel=""String_Node_Str"";
    String name=bitstreamFormat.getShortDescription() + ""String_Node_Str"" + supportLevel+ ""String_Node_Str"";
    int id=bitstreamFormat.getID();
    format.addOption(id,name);
  }
  if (currentFormat != null) {
    format.setOptionSelected(currentFormat.getID());
  }
 else   if (guessedFormat != null) {
    format.setOptionSelected(guessedFormat.getID());
  }
 else {
    format.setOptionSelected(-1);
  }
  edit.addItem(T_info2);
  Text userFormat=edit.addItem().addText(""String_Node_Str"");
  userFormat.setLabel(T_format_user);
  userFormat.setHelp(T_format_user_help);
  userFormat.setValue(bitstream.getUserFormatDescription());
  div.addHidden(""String_Node_Str"").setValue(bitstream.getID());
  org.dspace.app.xmlui.wing.element.Item actions=edit.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
}",0.9832402234636872
3380,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  DCValue[] titles=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] citation=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] publisher=item.getDC(""String_Node_Str"",null,Item.ANY);
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  CheckBox multipleTitles=form.addItem().addCheckBox(""String_Node_Str"");
  multipleTitles.setLabel(T_multiple_titles);
  multipleTitles.setHelp(T_multiple_titles_help);
  multipleTitles.addOption(""String_Node_Str"");
  if (submission.hasMultipleTitles()) {
    multipleTitles.setOptionSelected(""String_Node_Str"");
  }
  if (titles.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_multiple_titles_note);
    for (int i=0; i < titles.length; i++) {
      if (i > 0)       note.addContent(T_separator);
      note.addContent(""String_Node_Str"");
      note.addHighlight(""String_Node_Str"").addContent(titles[i].value);
      note.addContent(""String_Node_Str"");
    }
  }
  CheckBox publishedBefore=form.addItem().addCheckBox(""String_Node_Str"");
  publishedBefore.setLabel(T_published_before);
  publishedBefore.setHelp(T_published_before_help);
  publishedBefore.addOption(""String_Node_Str"");
  if (submission.isPublishedBefore()) {
    publishedBefore.setOptionSelected(""String_Node_Str"");
  }
  if (dateIssued.length > 0 || citation.length > 0 || publisher.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_published_before_note);
    if (dateIssued.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_date_issued);
      note.addContent(T_open);
      for (int i=0; i < dateIssued.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(dateIssued[i].value);
      }
      note.addContent(T_close);
    }
    if (dateIssued.length > 0 && (citation.length > 0 || publisher.length > 0))     note.addContent(T_separator);
    if (dateIssued.length > 0 && citation.length > 0 && publisher.length == 0) {
      note.addContent(T_and);
    }
    if (citation.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_citation);
      note.addContent(T_open);
      for (int i=0; i < citation.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(citation[i].value);
      }
      note.addContent(T_close);
    }
    if (citation.length > 0 && publisher.length > 0) {
      note.addContent(T_separator);
    }
    if ((dateIssued.length > 0 || citation.length > 0) && publisher.length > 0) {
      note.addContent(T_and);
    }
    if (publisher.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_publisher);
      note.addContent(T_open);
      for (int i=0; i < publisher.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(publisher[i].value);
      }
      note.addContent(T_close);
    }
  }
  addControlButtons(form);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  DCValue[] titles=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] citation=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCValue[] publisher=item.getDC(""String_Node_Str"",null,Item.ANY);
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  CheckBox multipleTitles=form.addItem().addCheckBox(""String_Node_Str"");
  multipleTitles.setLabel(T_multiple_titles);
  multipleTitles.setHelp(T_multiple_titles_help);
  multipleTitles.addOption(""String_Node_Str"");
  if (submission.hasMultipleTitles()) {
    multipleTitles.setOptionSelected(""String_Node_Str"");
  }
  if (titles.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_multiple_titles_note);
    for (int i=0; i < titles.length; i++) {
      if (i > 0)       note.addContent(T_separator);
      note.addContent(""String_Node_Str"");
      note.addHighlight(""String_Node_Str"").addContent(titles[i].value);
      note.addContent(""String_Node_Str"");
    }
  }
  CheckBox publishedBefore=form.addItem().addCheckBox(""String_Node_Str"");
  publishedBefore.setLabel(T_published_before);
  publishedBefore.setHelp(T_published_before_help);
  publishedBefore.addOption(""String_Node_Str"");
  if (submission.isPublishedBefore()) {
    publishedBefore.setOptionSelected(""String_Node_Str"");
  }
  if (dateIssued.length > 0 || citation.length > 0 || publisher.length > 0) {
    org.dspace.app.xmlui.wing.element.Item note=form.addItem();
    note.addHighlight(""String_Node_Str"").addContent(T_important_note);
    note.addContent(T_published_before_note);
    if (dateIssued.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_date_issued);
      note.addContent(T_open);
      for (int i=0; i < dateIssued.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(dateIssued[i].value);
      }
      note.addContent(T_close);
    }
    if (dateIssued.length > 0 && (citation.length > 0 || publisher.length > 0))     note.addContent(T_separator);
    if (dateIssued.length > 0 && citation.length > 0 && publisher.length == 0) {
      note.addContent(T_and);
    }
    if (citation.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_citation);
      note.addContent(T_open);
      for (int i=0; i < citation.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(citation[i].value);
      }
      note.addContent(T_close);
    }
    if (citation.length > 0 && publisher.length > 0) {
      note.addContent(T_separator);
    }
    if ((dateIssued.length > 0 || citation.length > 0) && publisher.length > 0) {
      note.addContent(T_and);
    }
    if (publisher.length > 0) {
      note.addHighlight(""String_Node_Str"").addContent(T_publisher);
      note.addContent(T_open);
      for (int i=0; i < publisher.length; i++) {
        if (i > 0)         note.addContent(T_separator);
        note.addContent(publisher[i].value);
      }
      note.addContent(T_close);
    }
  }
  addControlButtons(form);
  div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
}",0.9878032786885246
3381,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (CreativeCommons.isEnabled() && ccLicenseStep != null) {
    ccLicenseStep.addBody(body);
    return;
  }
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  String licenseText=collection.getLicense();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  Division inner=div.addDivision(""String_Node_Str"");
  inner.setHead(T_head);
  inner.addPara(T_info1);
  inner.addPara(T_info2);
  Division displayLicense=inner.addDivision(""String_Node_Str"",""String_Node_Str"");
  displayLicense.addSimpleHTMLFragment(true,licenseText);
  inner.addPara(T_info3);
  List controls=inner.addList(""String_Node_Str"",List.TYPE_FORM);
  CheckBox decision=controls.addItem().addCheckBox(""String_Node_Str"");
  decision.setLabel(T_decision_label);
  decision.addOption(""String_Node_Str"",T_decision_checkbox);
  if (this.errorFlag == org.dspace.submit.step.LicenseStep.STATUS_LICENSE_REJECTED) {
    decision.addError(T_decision_error);
  }
  addControlButtons(controls);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (CreativeCommons.isEnabled() && ccLicenseStep != null) {
    ccLicenseStep.addBody(body);
    return;
  }
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  String licenseText=collection.getLicense();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  Division inner=div.addDivision(""String_Node_Str"");
  inner.setHead(T_head);
  inner.addPara(T_info1);
  inner.addPara(T_info2);
  Division displayLicense=inner.addDivision(""String_Node_Str"",""String_Node_Str"");
  displayLicense.addSimpleHTMLFragment(true,licenseText);
  inner.addPara(T_info3);
  List controls=inner.addList(""String_Node_Str"",List.TYPE_FORM);
  CheckBox decision=controls.addItem().addCheckBox(""String_Node_Str"");
  decision.setLabel(T_decision_label);
  decision.addOption(""String_Node_Str"",T_decision_checkbox);
  if (this.errorFlag == org.dspace.submit.step.LicenseStep.STATUS_LICENSE_REJECTED) {
    decision.addError(T_decision_error);
  }
  addControlButtons(controls);
}",0.9654660230226512
3382,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  org.dspace.app.xmlui.wing.element.Item actions=form.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_resume);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  org.dspace.app.xmlui.wing.element.Item actions=form.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_resume);
  actions.addButton(""String_Node_Str"").setValue(T_submit_cancel);
}",0.968718466195762
3383,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  SubmissionConfig subConfig=submissionInfo.getSubmissionConfig();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List review=div.addList(""String_Node_Str"",List.TYPE_FORM);
  review.setHead(T_head);
  Set submissionPagesSet=submissionInfo.getProgressBarInfo().keySet();
  String[] submissionPages=(String[])submissionPagesSet.toArray(new String[submissionPagesSet.size()]);
  for (int i=0; i < submissionPages.length; i++) {
    double currentStepAndPage=Double.valueOf(submissionPages[i]).doubleValue();
    if (currentStepAndPage == this.stepAndPage) {
      break;
    }
    SubmissionStepConfig stepConfig=subConfig.getStep(FlowUtils.getStep(currentStepAndPage));
    AbstractStep stepUIClass=loadXMLUIClass(stepConfig.getXMLUIClassName());
    try {
      parameters.setParameter(""String_Node_Str"",Double.toString(currentStepAndPage));
      stepUIClass.setup(resolver,objectModel,src,parameters);
    }
 catch (    Exception e) {
      throw new UIException(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"",e);
    }
    if (stepUIClass instanceof AbstractSubmissionStep) {
      List stepSection=((AbstractSubmissionStep)stepUIClass).addReviewSection(review);
      if (stepSection != null) {
        addJumpButton(stepSection,T_submit_jump,currentStepAndPage);
      }
    }
 else {
      log.warn(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"");
    }
  }
  addControlButtons(review);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  SubmissionConfig subConfig=submissionInfo.getSubmissionConfig();
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List review=div.addList(""String_Node_Str"",List.TYPE_FORM);
  review.setHead(T_head);
  Set submissionPagesSet=submissionInfo.getProgressBarInfo().keySet();
  String[] submissionPages=(String[])submissionPagesSet.toArray(new String[submissionPagesSet.size()]);
  for (int i=0; i < submissionPages.length; i++) {
    double currentStepAndPage=Double.valueOf(submissionPages[i]).doubleValue();
    if (currentStepAndPage == this.stepAndPage) {
      break;
    }
    SubmissionStepConfig stepConfig=subConfig.getStep(FlowUtils.getStep(currentStepAndPage));
    AbstractStep stepUIClass=loadXMLUIClass(stepConfig.getXMLUIClassName());
    try {
      parameters.setParameter(""String_Node_Str"",Double.toString(currentStepAndPage));
      stepUIClass.setup(resolver,objectModel,src,parameters);
    }
 catch (    Exception e) {
      throw new UIException(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"",e);
    }
    if (stepUIClass instanceof AbstractSubmissionStep) {
      List stepSection=((AbstractSubmissionStep)stepUIClass).addReviewSection(review);
      if (stepSection != null) {
        addJumpButton(stepSection,T_submit_jump,currentStepAndPage);
      }
    }
 else {
      log.warn(""String_Node_Str"" + stepConfig.getXMLUIClassName() + ""String_Node_Str"");
    }
  }
  addControlButtons(review);
}",0.9754033324517324
3384,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List saveOrCancel=div.addList(""String_Node_Str"",List.TYPE_FORM);
  saveOrCancel.setHead(T_head);
  saveOrCancel.addItem(T_info1);
  saveOrCancel.addItem().addButton(""String_Node_Str"").setValue(T_submit_back);
  org.dspace.app.xmlui.wing.element.Item actions=saveOrCancel.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_remove);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List saveOrCancel=div.addList(""String_Node_Str"",List.TYPE_FORM);
  saveOrCancel.setHead(T_head);
  saveOrCancel.addItem(T_info1);
  saveOrCancel.addItem().addButton(""String_Node_Str"").setValue(T_submit_back);
  org.dspace.app.xmlui.wing.element.Item actions=saveOrCancel.addItem();
  actions.addButton(""String_Node_Str"").setValue(T_submit_save);
  actions.addButton(""String_Node_Str"").setValue(T_submit_remove);
}",0.948873007146784
3385,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  try {
    Collection[] collections;
    ResolvableIdentifier eid=IdentifierService.resolve(context,handle);
    DSpaceObject dso=null;
    if (eid != null) {
      dso=(DSpaceObject)IdentifierService.getResource(context,eid);
    }
    if (dso != null && dso instanceof Community) {
      collections=Collection.findAuthorized(context,((Community)dso),Constants.ADD);
    }
 else {
      collections=Collection.findAuthorized(context,null,Constants.ADD);
    }
    Division div=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
    div.setHead(T_submission_head);
    List list=div.addList(""String_Node_Str"",List.TYPE_FORM);
    list.setHead(T_head);
    Select select=list.addItem().addSelect(""String_Node_Str"");
    select.setLabel(T_collection);
    select.setHelp(T_collection_help);
    select.addOption(""String_Node_Str"",T_collection_default);
    for (    Collection collection : collections) {
      String name=collection.getMetadata(""String_Node_Str"");
      if (name.length() > 50)       name=name.substring(0,47) + ""String_Node_Str"";
      select.addOption(IdentifierService.getCanonicalForm(collection),name);
    }
    Button submit=list.addItem().addButton(""String_Node_Str"");
    submit.setValue(T_submit_next);
    div.addHidden(""String_Node_Str"").setValue(knot.getId());
  }
 catch (  IdentifierException e) {
    throw new RuntimeException(e);
  }
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  try {
    Collection[] collections;
    String actionURL=contextPath + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
    ResolvableIdentifier eid=IdentifierService.resolve(context,handle);
    DSpaceObject dso=null;
    if (eid != null) {
      dso=(DSpaceObject)IdentifierService.getResource(context,eid);
    }
    if (dso != null && dso instanceof Community) {
      collections=Collection.findAuthorized(context,((Community)dso),Constants.ADD);
    }
 else {
      collections=Collection.findAuthorized(context,null,Constants.ADD);
    }
    Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
    div.setHead(T_submission_head);
    List list=div.addList(""String_Node_Str"",List.TYPE_FORM);
    list.setHead(T_head);
    Select select=list.addItem().addSelect(""String_Node_Str"");
    select.setLabel(T_collection);
    select.setHelp(T_collection_help);
    select.addOption(""String_Node_Str"",T_collection_default);
    for (    Collection collection : collections) {
      String name=collection.getMetadata(""String_Node_Str"");
      if (name.length() > 50)       name=name.substring(0,47) + ""String_Node_Str"";
      select.addOption(IdentifierService.getCanonicalForm(collection),name);
    }
    Button submit=list.addItem().addButton(""String_Node_Str"");
    submit.setValue(T_submit_next);
  }
 catch (  IdentifierException e) {
    throw new RuntimeException(e);
  }
}",0.9397897419560368
3386,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.editFile != null) {
    editFile.addBody(body);
    return;
  }
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  boolean workflow=submission instanceof WorkflowItem;
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  Bitstream[] bitstreams=new Bitstream[0];
  if (bundles.length > 0) {
    bitstreams=bundles[0].getBitstreams();
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_MULTIPART,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List upload=null;
  if (!workflow) {
    upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
    upload.setHead(T_head);
    File file=upload.addItem().addFile(""String_Node_Str"");
    file.setLabel(T_file);
    file.setHelp(T_file_help);
    file.setRequired();
    if (this.errorFlag == org.dspace.submit.step.UploadStep.STATUS_NO_FILES_ERROR)     file.addError(T_file_error);
    Text description=upload.addItem().addText(""String_Node_Str"");
    description.setLabel(T_description);
    description.setHelp(T_description_help);
    Button uploadSubmit=upload.addItem().addButton(""String_Node_Str"");
    uploadSubmit.setValue(T_submit_upload);
  }
  if (bitstreams.length > 0 || workflow) {
    Table summary=div.addTable(""String_Node_Str"",(bitstreams.length * 2) + 2,7);
    summary.setHead(T_head2);
    Row header=summary.addRow(Row.ROLE_HEADER);
    header.addCellContent(T_column1);
    header.addCellContent(T_column2);
    header.addCellContent(T_column3);
    header.addCellContent(T_column4);
    header.addCellContent(T_column5);
    header.addCellContent(T_column6);
    for (    Bitstream bitstream : bitstreams) {
      int id=bitstream.getID();
      String name=bitstream.getName();
      String url=contextPath + ""String_Node_Str"" + item.getID()+ ""String_Node_Str""+ name;
      long bytes=bitstream.getSize();
      String desc=bitstream.getDescription();
      String algorithm=bitstream.getChecksumAlgorithm();
      String checksum=bitstream.getChecksum();
      BitstreamFormat format=bitstream.getFormat();
      int support=format.getSupportLevel();
      Row row=summary.addRow();
      if (!workflow) {
        CheckBox remove=row.addCell().addCheckBox(""String_Node_Str"");
        remove.setLabel(""String_Node_Str"");
        remove.addOption(id);
      }
 else {
        row.addCell();
      }
      row.addCell().addXref(url,name);
      row.addCellContent(bytes + ""String_Node_Str"");
      if (desc == null || desc.length() == 0)       row.addCellContent(T_unknown_name);
 else       row.addCellContent(desc);
      if (format == null) {
        row.addCellContent(T_unknown_format);
      }
 else {
        Cell cell=row.addCell();
        cell.addContent(format.getMIMEType());
        cell.addContent(""String_Node_Str"");
switch (support) {
case 1:
          cell.addContent(T_supported);
        break;
case 2:
      cell.addContent(T_known);
    break;
case 3:
  cell.addContent(T_unsupported);
break;
}
}
Button edit=row.addCell().addButton(""String_Node_Str"" + id);
edit.setValue(T_submit_edit);
Row checksumRow=summary.addRow();
checksumRow.addCell();
Cell checksumCell=checksumRow.addCell(null,null,0,6,null);
checksumCell.addHighlight(""String_Node_Str"").addContent(T_checksum);
checksumCell.addContent(""String_Node_Str"");
checksumCell.addContent(algorithm + ""String_Node_Str"" + checksum);
}
if (!workflow) {
Row actionRow=summary.addRow();
actionRow.addCell();
Button removeSeleceted=actionRow.addCell(null,null,0,6,null).addButton(""String_Node_Str"");
removeSeleceted.setValue(T_submit_remove);
}
upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
}
addControlButtons(upload);
div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  if (this.editFile != null) {
    editFile.addBody(body);
    return;
  }
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"" + knot.getId()+ ""String_Node_Str"";
  boolean workflow=submission instanceof WorkflowItem;
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  Bitstream[] bitstreams=new Bitstream[0];
  if (bundles.length > 0) {
    bitstreams=bundles[0].getBitstreams();
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_MULTIPART,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List upload=null;
  if (!workflow) {
    upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
    upload.setHead(T_head);
    File file=upload.addItem().addFile(""String_Node_Str"");
    file.setLabel(T_file);
    file.setHelp(T_file_help);
    file.setRequired();
    if (this.errorFlag == org.dspace.submit.step.UploadStep.STATUS_NO_FILES_ERROR)     file.addError(T_file_error);
    Text description=upload.addItem().addText(""String_Node_Str"");
    description.setLabel(T_description);
    description.setHelp(T_description_help);
    Button uploadSubmit=upload.addItem().addButton(""String_Node_Str"");
    uploadSubmit.setValue(T_submit_upload);
  }
  if (bitstreams.length > 0 || workflow) {
    Table summary=div.addTable(""String_Node_Str"",(bitstreams.length * 2) + 2,7);
    summary.setHead(T_head2);
    Row header=summary.addRow(Row.ROLE_HEADER);
    header.addCellContent(T_column1);
    header.addCellContent(T_column2);
    header.addCellContent(T_column3);
    header.addCellContent(T_column4);
    header.addCellContent(T_column5);
    header.addCellContent(T_column6);
    for (    Bitstream bitstream : bitstreams) {
      int id=bitstream.getID();
      String name=bitstream.getName();
      String url=contextPath + ""String_Node_Str"" + item.getID()+ ""String_Node_Str""+ name;
      long bytes=bitstream.getSize();
      String desc=bitstream.getDescription();
      String algorithm=bitstream.getChecksumAlgorithm();
      String checksum=bitstream.getChecksum();
      BitstreamFormat format=bitstream.getFormat();
      int support=format.getSupportLevel();
      Row row=summary.addRow();
      if (!workflow) {
        CheckBox remove=row.addCell().addCheckBox(""String_Node_Str"");
        remove.setLabel(""String_Node_Str"");
        remove.addOption(id);
      }
 else {
        row.addCell();
      }
      row.addCell().addXref(url,name);
      row.addCellContent(bytes + ""String_Node_Str"");
      if (desc == null || desc.length() == 0)       row.addCellContent(T_unknown_name);
 else       row.addCellContent(desc);
      if (format == null) {
        row.addCellContent(T_unknown_format);
      }
 else {
        Cell cell=row.addCell();
        cell.addContent(format.getMIMEType());
        cell.addContent(""String_Node_Str"");
switch (support) {
case 1:
          cell.addContent(T_supported);
        break;
case 2:
      cell.addContent(T_known);
    break;
case 3:
  cell.addContent(T_unsupported);
break;
}
}
Button edit=row.addCell().addButton(""String_Node_Str"" + id);
edit.setValue(T_submit_edit);
Row checksumRow=summary.addRow();
checksumRow.addCell();
Cell checksumCell=checksumRow.addCell(null,null,0,6,null);
checksumCell.addHighlight(""String_Node_Str"").addContent(T_checksum);
checksumCell.addContent(""String_Node_Str"");
checksumCell.addContent(algorithm + ""String_Node_Str"" + checksum);
}
if (!workflow) {
Row actionRow=summary.addRow();
actionRow.addCell();
Button removeSeleceted=actionRow.addCell(null,null,0,6,null).addButton(""String_Node_Str"");
removeSeleceted.setValue(T_submit_remove);
}
upload=div.addList(""String_Node_Str"",List.TYPE_FORM);
}
addControlButtons(upload);
}",0.9884970294526608
3387,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  int state=((WorkflowItem)submission).getState();
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_workflow_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  Table table=div.addTable(""String_Node_Str"",1,1);
  table.setHead(T_info1);
  Row row;
  if (state == WFSTATE_STEP1POOL || state == WFSTATE_STEP2POOL || state == WFSTATE_STEP3POOL) {
    row=table.addRow();
    row.addCellContent(T_take_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_take_submit);
    row=table.addRow();
    row.addCellContent(T_leave_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_leave_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_approve_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_approve_submit);
  }
  if (state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_commit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_commit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_reject_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_reject_submit);
  }
  if (state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_edit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_edit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_return_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_return_submit);
  }
  row=table.addRow();
  row.addCell(0,2).addButton(""String_Node_Str"").setValue(T_cancel_submit);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=IdentifierService.getURL(collection).toString() + ""String_Node_Str"";
  int state=((WorkflowItem)submission).getState();
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_workflow_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  Table table=div.addTable(""String_Node_Str"",1,1);
  table.setHead(T_info1);
  Row row;
  if (state == WFSTATE_STEP1POOL || state == WFSTATE_STEP2POOL || state == WFSTATE_STEP3POOL) {
    row=table.addRow();
    row.addCellContent(T_take_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_take_submit);
    row=table.addRow();
    row.addCellContent(T_leave_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_leave_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_approve_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_approve_submit);
  }
  if (state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_commit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_commit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_reject_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_reject_submit);
  }
  if (state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_edit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_edit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_return_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_return_submit);
  }
  row=table.addRow();
  row.addCell(0,2).addButton(""String_Node_Str"").setValue(T_cancel_submit);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.9953982300884956
3388,"public ServiceDocument doServiceDocument(ServiceDocumentRequest request) throws SWORDAuthenticationException, SWORDException {
  if (log.isDebugEnabled()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  }
  try {
    SWORDContext sc=this.authenticate(request);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + request.getUsername() + ""String_Node_Str""+ request.getOnBehalfOf()));
    SWORDService service=new SWORDService();
    service.setContext(context);
    service.setSWORDContext(sc);
    ServiceDocument doc=service.getServiceDocument();
    return doc;
  }
 catch (  DSpaceSWORDException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
 finally {
    if (context != null) {
      context.abort();
    }
  }
}","public ServiceDocument doServiceDocument(ServiceDocumentRequest request) throws SWORDAuthenticationException, SWORDException {
  Context context=constructContext(request.getIPAddress());
  if (log.isDebugEnabled()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  }
  try {
    SWORDContext sc=this.authenticate(context,request);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + request.getUsername() + ""String_Node_Str""+ request.getOnBehalfOf()));
    SWORDService service=new SWORDService();
    service.setContext(context);
    service.setSWORDContext(sc);
    ServiceDocument doc=service.getServiceDocument();
    return doc;
  }
 catch (  DSpaceSWORDException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
 finally {
    if (context != null) {
      context.abort();
    }
  }
}",0.9607843137254902
3389,"/** 
 * Construct the context object member variable of this class using the passed IP address as part of the loggable information
 * @param ip	the ip address of the incoming request
 * @throws SWORDException
 */
private void constructContext(String ip) throws SWORDException {
  try {
    this.context=new Context();
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
  this.context.setExtraLogInfo(""String_Node_Str"" + ip);
}","/** 
 * Construct the context object member variable of this class using the passed IP address as part of the loggable information
 * @param ip	the ip address of the incoming request
 * @throws SWORDException
 */
private Context constructContext(String ip) throws SWORDException {
  try {
    Context context=new Context();
    context.setExtraLogInfo(""String_Node_Str"" + ip);
    return context;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
}",0.8498527968596663
3390,"/** 
 * Authenticate the given username/password pair, in conjunction with the onBehalfOf user.  The rules are that the username/password pair must successfully authenticate the user, and the onBehalfOf user must exist in the user database.
 * @param un
 * @param pw
 * @param obo
 * @return	a SWORD context holding the various user information
 * @throws SWORDAuthenticationException
 * @throws SWORDException
 */
private SWORDContext authenticate(String un,String pw,String obo) throws SWORDAuthenticationException, SWORDException {
  if (""String_Node_Str"".equals(obo)) {
    obo=null;
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
  try {
    SWORDContext sc=new SWORDContext();
    SWORDAuthentication auth=new SWORDAuthentication();
    EPerson ep=null;
    boolean authenticated=false;
    if (auth.authenticates(this.context,un,pw)) {
      ep=context.getCurrentUser();
      if (ep != null) {
        authenticated=true;
        sc.setAuthenticated(ep);
      }
      if (obo != null) {
        EPerson epObo=EPerson.findByEmail(this.context,obo);
        if (epObo != null) {
          sc.setOnBehalfOf(epObo);
        }
 else {
          authenticated=false;
        }
      }
    }
    if (ep != null && authenticated) {
      this.context.setCurrentUser(ep);
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ep.getID()));
    }
 else {
      if (ep != null) {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un));
        throw new SWORDAuthenticationException(""String_Node_Str"");
      }
 else {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
        throw new SWORDAuthenticationException(""String_Node_Str"");
      }
    }
    return sc;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
catch (  AuthorizeException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDAuthenticationException(""String_Node_Str"",e);
  }
}","/** 
 * Authenticate the given username/password pair, in conjunction with the onBehalfOf user.  The rules are that the username/password pair must successfully authenticate the user, and the onBehalfOf user must exist in the user database.
 * @param un
 * @param pw
 * @param obo
 * @return	a SWORD context holding the various user information
 * @throws SWORDAuthenticationException
 * @throws SWORDException
 */
private SWORDContext authenticate(Context context,String un,String pw,String obo) throws SWORDAuthenticationException, SWORDException {
  if (""String_Node_Str"".equals(obo)) {
    obo=null;
  }
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
  try {
    SWORDContext sc=new SWORDContext();
    SWORDAuthentication auth=new SWORDAuthentication();
    EPerson ep=null;
    boolean authenticated=false;
    if (auth.authenticates(context,un,pw)) {
      ep=context.getCurrentUser();
      if (ep != null) {
        authenticated=true;
        sc.setAuthenticated(ep);
      }
      if (obo != null) {
        EPerson epObo=EPerson.findByEmail(context,obo);
        if (epObo != null) {
          sc.setOnBehalfOf(epObo);
        }
 else {
          authenticated=false;
        }
      }
    }
    if (ep != null && authenticated) {
      context.setCurrentUser(ep);
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + ep.getID()));
    }
 else {
      if (ep != null) {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un));
        throw new SWORDAuthenticationException(""String_Node_Str"");
      }
 else {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + un + ""String_Node_Str""+ obo));
        throw new SWORDAuthenticationException(""String_Node_Str"");
      }
    }
    return sc;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
catch (  AuthorizeException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDAuthenticationException(""String_Node_Str"",e);
  }
}",0.9926835024781684
3391,"public DepositResponse doDeposit(Deposit deposit) throws SWORDAuthenticationException, SWORDException {
  try {
    if (log.isDebugEnabled()) {
      log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    }
    SWORDContext sc=this.authenticate(deposit);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + deposit.getUsername() + ""String_Node_Str""+ deposit.getOnBehalfOf()));
    DepositManager dm=new DepositManager();
    dm.setContext(context);
    dm.setDeposit(deposit);
    dm.setSWORDContext(sc);
    DepositResponse response=dm.deposit();
    if (context != null && context.isValid()) {
      context.commit();
    }
    return response;
  }
 catch (  DSpaceSWORDException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDAuthenticationException(""String_Node_Str"",e);
  }
catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}","public DepositResponse doDeposit(Deposit deposit) throws SWORDAuthenticationException, SWORDException {
  Context context=constructContext(deposit.getIPAddress());
  try {
    if (log.isDebugEnabled()) {
      log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    }
    SWORDContext sc=this.authenticate(context,deposit);
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + deposit.getUsername() + ""String_Node_Str""+ deposit.getOnBehalfOf()));
    DepositManager dm=new DepositManager();
    dm.setContext(context);
    dm.setDeposit(deposit);
    dm.setSWORDContext(sc);
    DepositResponse response=dm.deposit();
    if (context != null && context.isValid()) {
      context.commit();
    }
    return response;
  }
 catch (  DSpaceSWORDException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDAuthenticationException(""String_Node_Str"",e);
  }
catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new SWORDException(""String_Node_Str"",e);
  }
 finally {
    if (context != null && context.isValid()) {
      context.abort();
    }
  }
}",0.9688644688644688
3392,"/** 
 * Moves the item from one collection to another one
 * @throws SQLException
 * @throws AuthorizeException
 * @throws IOException
 */
public void move(Collection from,Collection to) throws SQLException, AuthorizeException, IOException {
  if (isOwningCollection(from)) {
    setOwningCollection(to);
    update();
  }
  to.addItem(this);
  from.removeItem(this);
}","/** 
 * Moves the item from one collection to another one
 * @throws SQLException
 * @throws AuthorizeException
 * @throws IOException
 */
public void move(Collection from,Collection to) throws SQLException, AuthorizeException, IOException {
  to.addItem(this);
  from.removeItem(this);
  if (isOwningCollection(from)) {
    setOwningCollection(to);
    update();
  }
 else {
    ourContext.addEvent(new Event(Event.MODIFY,Constants.ITEM,getID(),null));
  }
}",0.6956521739130435
3393,"/** 
 * Log the given user in as a real authenticated user. This should only be used after  a user has presented their credintals and they have been validated. 
 * @param context DSpace context
 * @param request HTTP request
 * @param eperson the eperson logged in
 */
private static void logIn(Context context,HttpServletRequest request,EPerson eperson) throws SQLException {
  if (eperson == null)   return;
  HttpSession session=request.getSession();
  context.setCurrentUser(eperson);
  if (!AuthorizeManager.isAdmin(context) && !SystemwideAlerts.canUserStartSession()) {
    context.setCurrentUser(null);
    return;
  }
  int[] groupIDs=AuthenticationManager.getSpecialGroups(context,request);
  for (  int groupID : groupIDs)   context.setSpecialGroup(groupID);
  session.setAttribute(CURRENT_IP_ADDRESS,request.getRemoteAddr());
  session.setAttribute(EFFECTIVE_USER_ID,eperson.getID());
  session.setAttribute(AUTHENTICATED_USER_ID,eperson.getID());
}","/** 
 * Log the given user in as a real authenticated user. This should only be used after  a user has presented their credintals and they have been validated. This method  signature is provided to be easier to call from flow scripts.
 * @param objectModel The cocoon object model.
 * @param eperson the eperson logged in
 */
public static void logIn(Map objectModel,EPerson eperson) throws SQLException {
  final HttpServletRequest request=(HttpServletRequest)objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
  Context context=ContextUtil.obtainContext(objectModel);
  logIn(context,request,eperson);
}",0.3903061224489796
3394,"/** 
 * Log the given user in as a real authenticated user. This should only be used after  a user has presented their credintals and they have been validated. 
 * @param context DSpace context
 * @param request HTTP request
 * @param eperson the eperson logged in
 */
private static void logIn(Context context,HttpServletRequest request,EPerson eperson) throws SQLException {
  if (eperson == null)   return;
  HttpSession session=request.getSession();
  context.setCurrentUser(eperson);
  if (!AuthorizeManager.isAdmin(context) && !SystemwideAlerts.canUserStartSession()) {
    context.setCurrentUser(null);
    return;
  }
  int[] groupIDs=AuthenticationManager.getSpecialGroups(context,request);
  for (  int groupID : groupIDs)   context.setSpecialGroup(groupID);
  session.setAttribute(CURRENT_IP_ADDRESS,request.getRemoteAddr());
  session.setAttribute(EFFECTIVE_USER_ID,eperson.getID());
  session.setAttribute(AUTHENTICATED_USER_ID,eperson.getID());
}","/** 
 * Log the given user in as a real authenticated user. This should only be used after  a user has presented their credintals and they have been validated. This method  signature is provided to be easier to call from flow scripts.
 * @param objectModel The cocoon object model.
 * @param eperson the eperson logged in
 */
public static void logIn(Map objectModel,EPerson eperson) throws SQLException {
  final HttpServletRequest request=(HttpServletRequest)objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
  Context context=ContextUtil.obtainContext(objectModel);
  logIn(context,request,eperson);
}",0.3903061224489796
3395,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  int state=((WorkflowItem)submission).getState();
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_workflow_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  Table table=div.addTable(""String_Node_Str"",1,1);
  table.setHead(T_info1);
  Row row;
  if (state == WFSTATE_STEP1POOL || state == WFSTATE_STEP2POOL || state == WFSTATE_STEP3POOL) {
    row=table.addRow();
    row.addCellContent(T_take_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_take_submit);
    row=table.addRow();
    row.addCellContent(T_leave_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_leave_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_approve_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_approve_submit);
  }
  if (state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_commit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_commit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_reject_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_reject_submit);
  }
  if (state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_edit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_edit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_return_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_return_submit);
  }
  row=table.addRow();
  row.addCell(0,2).addButton(""String_Node_Str"").setValue(T_cancel_submit);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  int state=((WorkflowItem)submission).getState();
  Request request=ObjectModelHelper.getRequest(objectModel);
  String showfull=request.getParameter(""String_Node_Str"");
  if (showfull != null && request.getParameter(""String_Node_Str"") != null)   showfull=null;
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_workflow_head);
  if (showfull == null) {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_SUMMARY_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showfull);
  }
 else {
    ReferenceSet referenceSet=div.addReferenceSet(""String_Node_Str"",ReferenceSet.TYPE_DETAIL_VIEW);
    referenceSet.addReference(item);
    div.addPara().addButton(""String_Node_Str"").setValue(T_showsimple);
    div.addHidden(""String_Node_Str"").setValue(""String_Node_Str"");
  }
  Table table=div.addTable(""String_Node_Str"",1,1);
  table.setHead(T_info1);
  Row row;
  if (state == WFSTATE_STEP1POOL || state == WFSTATE_STEP2POOL || state == WFSTATE_STEP3POOL) {
    row=table.addRow();
    row.addCellContent(T_take_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_take_submit);
    row=table.addRow();
    row.addCellContent(T_leave_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_leave_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_approve_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_approve_submit);
  }
  if (state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_commit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_commit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2) {
    row=table.addRow();
    row.addCellContent(T_reject_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_reject_submit);
  }
  if (state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_edit_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_edit_submit);
  }
  if (state == WFSTATE_STEP1 || state == WFSTATE_STEP2 || state == WFSTATE_STEP3) {
    row=table.addRow();
    row.addCellContent(T_return_help);
    row.addCell().addButton(""String_Node_Str"").setValue(T_return_submit);
  }
  row=table.addRow();
  row.addCell(0,2).addButton(""String_Node_Str"").setValue(T_cancel_submit);
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
}",0.9954112248499823
3396,"/** 
 * Set up the bitstream reader. See the class description for information on configuration options.
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      dso=HandleManager.resolveToObject(context,handle);
      if (dso instanceof Item) {
        item=(Item)dso;
        if (sequence > -1) {
          bitstream=findBitstreamBySequence(item,sequence);
        }
 else         if (name != null) {
          bitstream=findBitstreamByName(item,name);
        }
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=item.getHandle();
        }
 else         if (dso != null) {
          redictURL+=dso.getHandle();
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}","/** 
 * Set up the bitstream reader. See the class description for information on configuration options.
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      dso=HandleManager.resolveToObject(context,handle);
      if (dso instanceof Item) {
        item=(Item)dso;
        if (sequence > -1) {
          bitstream=findBitstreamBySequence(item,sequence);
        }
 else         if (name != null) {
          bitstream=findBitstreamByName(item,name);
        }
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    boolean isAuthorized=AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ);
    if (item != null && item.isWithdrawn() && !AuthorizeManager.isAdmin(context)) {
      isAuthorized=false;
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + item.getHandle() + ""String_Node_Str""));
    }
    if (!isAuthorized) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=item.getHandle();
        }
 else         if (dso != null) {
          redictURL+=dso.getHandle();
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}",0.9888695185731528
3397,"/** 
 * Makes the jump-list navigation for the results
 * @param div
 * @param info
 * @param params
 * @throws WingException
 */
private void addBrowseJumpNavigation(Division div,BrowseInfo info,BrowseParams params) throws WingException {
  String type=info.getBrowseIndex().getName();
  Map<String,String> queryParams=new HashMap<String,String>();
  queryParams.putAll(params.getCommonParameters());
  queryParams.putAll(params.getControlParameters());
  Division jump=div.addInteractiveDivision(""String_Node_Str"",WITHDRAWN_URL_BASE,Division.METHOD_POST,""String_Node_Str"");
  for (  String key : queryParams.keySet())   jump.addHidden(key).setValue(queryParams.get(key));
  if (isSortedByDate(info)) {
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_select);
    Select month=jumpForm.addSelect(BrowseParams.MONTH);
    month.addOption(false,""String_Node_Str"",T_choose_month);
    for (int i=1; i <= 12; i++) {
      month.addOption(false,String.valueOf(i),DCDate.getMonthName(i,Locale.getDefault()));
    }
    Select year=jumpForm.addSelect(BrowseParams.YEAR);
    year.addOption(false,""String_Node_Str"",T_choose_year);
    int currentYear=DCDate.getCurrent().getYear();
    int i=currentYear;
    int oneYearBreak=((currentYear - ONE_YEAR_LIMIT) / 5) * 5;
    int fiveYearBreak=((currentYear - FIVE_YEAR_LIMIT) / 10) * 10;
    int tenYearBreak=(currentYear - TEN_YEAR_LIMIT);
    do {
      year.addOption(false,String.valueOf(i),String.valueOf(i));
      if (i <= fiveYearBreak)       i-=10;
 else       if (i <= oneYearBreak)       i-=5;
 else       i--;
    }
 while (i > tenYearBreak);
    jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_year);
    jumpForm.addText(""String_Node_Str"").setHelp(T_jump_year_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
 else {
    List jumpList=jump.addList(""String_Node_Str"",List.TYPE_SIMPLE,""String_Node_Str"");
    for (char c='A'; c <= 'Z'; c++) {
      Map<String,String> cQuery=new HashMap<String,String>(queryParams);
      cQuery.put(BrowseParams.STARTS_WITH,Character.toString(c));
      jumpList.addItemXref(super.generateURL(WITHDRAWN_URL_BASE,cQuery),Character.toString(c));
    }
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_starts_with);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_starts_with_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
}","/** 
 * Makes the jump-list navigation for the results
 * @param div
 * @param info
 * @param params
 * @throws WingException
 */
private void addBrowseJumpNavigation(Division div,BrowseInfo info,BrowseParams params) throws WingException {
  String type=info.getBrowseIndex().getName();
  Map<String,String> queryParams=new HashMap<String,String>();
  queryParams.putAll(params.getCommonParameters());
  queryParams.putAll(params.getControlParameters());
  Division jump=div.addInteractiveDivision(""String_Node_Str"",WITHDRAWN_URL_BASE,Division.METHOD_POST,""String_Node_Str"");
  for (  String key : queryParams.keySet())   jump.addHidden(key).setValue(queryParams.get(key));
  if (isSortedByDate(info)) {
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_select);
    Select month=jumpForm.addSelect(BrowseParams.MONTH);
    month.addOption(false,""String_Node_Str"",T_choose_month);
    for (int i=1; i <= 12; i++) {
      month.addOption(false,String.valueOf(i),DCDate.getMonthName(i,Locale.getDefault()));
    }
    Select year=jumpForm.addSelect(BrowseParams.YEAR);
    year.addOption(false,""String_Node_Str"",T_choose_year);
    int currentYear=DCDate.getCurrent().getYear();
    int i=currentYear;
    int oneYearBreak=((currentYear - ONE_YEAR_LIMIT) / 5) * 5;
    int fiveYearBreak=((currentYear - FIVE_YEAR_LIMIT) / 10) * 10;
    int tenYearBreak=(currentYear - TEN_YEAR_LIMIT);
    do {
      year.addOption(false,String.valueOf(i),String.valueOf(i));
      if (i <= fiveYearBreak)       i-=10;
 else       if (i <= oneYearBreak)       i-=5;
 else       i--;
    }
 while (i > tenYearBreak);
    jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_year);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_jump_year_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
 else {
    List jumpList=jump.addList(""String_Node_Str"",List.TYPE_SIMPLE,""String_Node_Str"");
    for (char c='A'; c <= 'Z'; c++) {
      Map<String,String> cQuery=new HashMap<String,String>(queryParams);
      cQuery.put(BrowseParams.STARTS_WITH,Character.toString(c));
      jumpList.addItemXref(super.generateURL(WITHDRAWN_URL_BASE,cQuery),Character.toString(c));
    }
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_starts_with);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_starts_with_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
}",0.9914494264859228
3398,"/** 
 * Makes the jump-list navigation for the results
 * @param div
 * @param info
 * @param params
 * @throws WingException
 */
private void addBrowseJumpNavigation(Division div,BrowseInfo info,BrowseParams params) throws WingException {
  String type=info.getBrowseIndex().getName();
  Map<String,String> queryParams=new HashMap<String,String>();
  queryParams.putAll(params.getCommonParameters());
  queryParams.putAll(params.getControlParameters());
  Division jump=div.addInteractiveDivision(""String_Node_Str"",BROWSE_URL_BASE,Division.METHOD_POST,""String_Node_Str"");
  for (  String key : queryParams.keySet())   jump.addHidden(key).setValue(queryParams.get(key));
  if (isSortedByDate(info)) {
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_select);
    Select month=jumpForm.addSelect(BrowseParams.MONTH);
    month.addOption(false,""String_Node_Str"",T_choose_month);
    for (int i=1; i <= 12; i++) {
      month.addOption(false,String.valueOf(i),DCDate.getMonthName(i,Locale.getDefault()));
    }
    Select year=jumpForm.addSelect(BrowseParams.YEAR);
    year.addOption(false,""String_Node_Str"",T_choose_year);
    int currentYear=DCDate.getCurrent().getYear();
    int i=currentYear;
    int oneYearBreak=((currentYear - ONE_YEAR_LIMIT) / 5) * 5;
    int fiveYearBreak=((currentYear - FIVE_YEAR_LIMIT) / 10) * 10;
    int tenYearBreak=(currentYear - TEN_YEAR_LIMIT);
    do {
      year.addOption(false,String.valueOf(i),String.valueOf(i));
      if (i <= fiveYearBreak)       i-=10;
 else       if (i <= oneYearBreak)       i-=5;
 else       i--;
    }
 while (i > tenYearBreak);
    jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_year);
    jumpForm.addText(""String_Node_Str"").setHelp(T_jump_year_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
 else {
    List jumpList=jump.addList(""String_Node_Str"",List.TYPE_SIMPLE,""String_Node_Str"");
    Map<String,String> zeroQuery=new HashMap<String,String>(queryParams);
    zeroQuery.put(BrowseParams.STARTS_WITH,""String_Node_Str"");
    jumpList.addItemXref(super.generateURL(BROWSE_URL_BASE,zeroQuery),""String_Node_Str"");
    for (char c='A'; c <= 'Z'; c++) {
      Map<String,String> cQuery=new HashMap<String,String>(queryParams);
      cQuery.put(BrowseParams.STARTS_WITH,Character.toString(c));
      jumpList.addItemXref(super.generateURL(BROWSE_URL_BASE,cQuery),Character.toString(c));
    }
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_starts_with);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_starts_with_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
}","/** 
 * Makes the jump-list navigation for the results
 * @param div
 * @param info
 * @param params
 * @throws WingException
 */
private void addBrowseJumpNavigation(Division div,BrowseInfo info,BrowseParams params) throws WingException {
  String type=info.getBrowseIndex().getName();
  Map<String,String> queryParams=new HashMap<String,String>();
  queryParams.putAll(params.getCommonParameters());
  queryParams.putAll(params.getControlParameters());
  Division jump=div.addInteractiveDivision(""String_Node_Str"",BROWSE_URL_BASE,Division.METHOD_POST,""String_Node_Str"");
  for (  String key : queryParams.keySet())   jump.addHidden(key).setValue(queryParams.get(key));
  if (isSortedByDate(info)) {
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_select);
    Select month=jumpForm.addSelect(BrowseParams.MONTH);
    month.addOption(false,""String_Node_Str"",T_choose_month);
    for (int i=1; i <= 12; i++) {
      month.addOption(false,String.valueOf(i),DCDate.getMonthName(i,Locale.getDefault()));
    }
    Select year=jumpForm.addSelect(BrowseParams.YEAR);
    year.addOption(false,""String_Node_Str"",T_choose_year);
    int currentYear=DCDate.getCurrent().getYear();
    int i=currentYear;
    int oneYearBreak=((currentYear - ONE_YEAR_LIMIT) / 5) * 5;
    int fiveYearBreak=((currentYear - FIVE_YEAR_LIMIT) / 10) * 10;
    int tenYearBreak=(currentYear - TEN_YEAR_LIMIT);
    do {
      year.addOption(false,String.valueOf(i),String.valueOf(i));
      if (i <= fiveYearBreak)       i-=10;
 else       if (i <= oneYearBreak)       i-=5;
 else       i--;
    }
 while (i > tenYearBreak);
    jumpForm=jump.addPara();
    jumpForm.addContent(T_jump_year);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_jump_year_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
 else {
    List jumpList=jump.addList(""String_Node_Str"",List.TYPE_SIMPLE,""String_Node_Str"");
    Map<String,String> zeroQuery=new HashMap<String,String>(queryParams);
    zeroQuery.put(BrowseParams.STARTS_WITH,""String_Node_Str"");
    jumpList.addItemXref(super.generateURL(BROWSE_URL_BASE,zeroQuery),""String_Node_Str"");
    for (char c='A'; c <= 'Z'; c++) {
      Map<String,String> cQuery=new HashMap<String,String>(queryParams);
      cQuery.put(BrowseParams.STARTS_WITH,Character.toString(c));
      jumpList.addItemXref(super.generateURL(BROWSE_URL_BASE,cQuery),Character.toString(c));
    }
    Para jumpForm=jump.addPara();
    jumpForm.addContent(T_starts_with);
    jumpForm.addText(BrowseParams.STARTS_WITH).setHelp(T_starts_with_help);
    jumpForm.addButton(""String_Node_Str"").setValue(T_go);
  }
}",0.9921710903188848
3399,"/** 
 * Set up the bitstream reader. See the class description for information on configuration options. FIXME: This should use the parameter ""uri"" rather than ""handle"" to be consistent with the JSPUI. Unfortunately, I have no idea how this works right now, so I'll have to do that later. It should still work for now though. --JR
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,handle);
      dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item && sequence > -1) {
        bitstream=findBitstreamBySequence((Item)dso,sequence);
      }
 else       if (dso instanceof Item && name != null) {
        bitstream=findBitstreamByName((Item)dso,name);
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    if (!AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ)) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=IdentifierService.getCanonicalForm(item);
        }
 else         if (dso != null) {
          redictURL+=IdentifierService.getCanonicalForm(dso);
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  IdentifierException e) {
    log.error(""String_Node_Str"",e);
    throw new ProcessingException(""String_Node_Str"",e);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}","/** 
 * Set up the bitstream reader. See the class description for information on configuration options. FIXME: This should use the parameter ""uri"" rather than ""handle"" to be consistent with the JSPUI. Unfortunately, I have no idea how this works right now, so I'll have to do that later. It should still work for now though. --JR
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  super.setup(resolver,objectModel,src,par);
  try {
    this.request=ObjectModelHelper.getRequest(objectModel);
    this.response=ObjectModelHelper.getResponse(objectModel);
    Context context=ContextUtil.obtainContext(objectModel);
    int itemID=par.getParameterAsInteger(""String_Node_Str"",-1);
    int bitstreamID=par.getParameterAsInteger(""String_Node_Str"",-1);
    String handle=par.getParameter(""String_Node_Str"",null);
    int sequence=par.getParameterAsInteger(""String_Node_Str"",-1);
    String name=par.getParameter(""String_Node_Str"",null);
    Bitstream bitstream=null;
    Item item=null;
    DSpaceObject dso=null;
    if (bitstreamID > -1) {
      bitstream=Bitstream.find(context,bitstreamID);
    }
 else     if (itemID > -1) {
      item=Item.find(context,itemID);
      if (sequence > -1) {
        bitstream=findBitstreamBySequence(item,sequence);
      }
 else       if (name != null) {
        bitstream=findBitstreamByName(item,name);
      }
    }
 else     if (handle != null) {
      ResolvableIdentifier ri=IdentifierService.resolve(context,handle);
      dso=(DSpaceObject)IdentifierService.getResource(context,ri);
      if (dso instanceof Item && sequence > -1) {
        bitstream=findBitstreamBySequence((Item)dso,sequence);
      }
 else       if (dso instanceof Item && name != null) {
        bitstream=findBitstreamByName((Item)dso,name);
      }
    }
    if (bitstream == null) {
      throw new ResourceNotFoundException(""String_Node_Str"");
    }
    if (!AuthorizeManager.authorizeActionBoolean(context,bitstream,Constants.READ)) {
      if (this.request.getSession().getAttribute(""String_Node_Str"") != null) {
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        if (item != null) {
          redictURL+=IdentifierService.getCanonicalForm(item);
        }
 else         if (dso != null) {
          redictURL+=IdentifierService.getCanonicalForm(dso);
        }
        redictURL+=""String_Node_Str"" + bitstream.getID();
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
 else {
        AuthenticationUtil.interruptRequest(objectModel,AUTH_REQUIRED_HEADER,AUTH_REQUIRED_MESSAGE,null);
        String redictURL=request.getContextPath() + ""String_Node_Str"";
        HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
        httpResponse.sendRedirect(redictURL);
        return;
      }
    }
    this.bitstreamInputStream=bitstream.retrieve();
    this.bitstreamSize=bitstream.getSize();
    this.bitstreamMimeType=bitstream.getFormat().getMIMEType();
    this.bitstreamName=bitstream.getName();
    if (bitstreamName != null && bitstreamName.length() > 0) {
      int finalSlashIndex=bitstreamName.lastIndexOf(""String_Node_Str"");
      if (finalSlashIndex > 0) {
        bitstreamName=bitstreamName.substring(finalSlashIndex + 1);
      }
    }
 else {
      bitstreamName=""String_Node_Str"";
    }
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bitstream.getID()));
  }
 catch (  SQLException sqle) {
    throw new ProcessingException(""String_Node_Str"",sqle);
  }
catch (  IdentifierException e) {
    log.error(""String_Node_Str"",e);
    throw new ProcessingException(""String_Node_Str"",e);
  }
catch (  AuthorizeException ae) {
    throw new ProcessingException(""String_Node_Str"",ae);
  }
}",0.9894065092533504
3400,"public int doStartTag() throws JspException {
  try {
    if (ids.size() < 1) {
      return SKIP_BODY;
    }
    JspWriter out=pageContext.getOut();
    String header=this.getHeaderText();
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"" + header + ""String_Node_Str"");
    for (    ExternalIdentifier eid : ids) {
      writeIdentifier(eid,out);
    }
    return SKIP_BODY;
  }
 catch (  IOException e) {
    throw new JspException(e);
  }
}","public int doStartTag() throws JspException {
  try {
    if (ids.size() < 1) {
      return SKIP_BODY;
    }
    JspWriter out=pageContext.getOut();
    String header=this.getHeaderText();
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"" + header + ""String_Node_Str"");
    for (    ExternalIdentifier eid : ids) {
      writeIdentifier(eid,out);
    }
    out.println(""String_Node_Str"");
    return SKIP_BODY;
  }
 catch (  IOException e) {
    throw new JspException(e);
  }
}",0.9625779625779626
3401,"public static Identifiable getResource(Context context,ResolvableIdentifier ri) throws IdentifierException {
  try {
    ObjectIdentifier oid=ri.getObjectIdentifier();
    if (oid.getResourceTypeID() == -1 || oid.getResourceID() == -1) {
      ObjectIdentifierDAO dao=ObjectIdentifierDAOFactory.getInstance(context);
      ObjectIdentifier noid=dao.retrieve(oid.getUUID());
      if (noid == null) {
        return null;
      }
    }
    return IdentifierService.getObjectByResourceID(context,oid);
  }
 catch (  ObjectIdentifierStorageException e) {
    log.error(""String_Node_Str"",e);
    throw new IdentifierException(e);
  }
}","public static Identifiable getResource(Context context,ResolvableIdentifier ri) throws IdentifierException {
  try {
    ObjectIdentifier oid=ri.getObjectIdentifier();
    if (oid.getResourceTypeID() == -1 || oid.getResourceID() == -1) {
      ObjectIdentifierDAO dao=ObjectIdentifierDAOFactory.getInstance(context);
      ObjectIdentifier noid=dao.retrieve(oid.getUUID());
      if (noid == null) {
        return null;
      }
      oid=noid;
    }
    return IdentifierService.getObjectByResourceID(context,oid);
  }
 catch (  ObjectIdentifierStorageException e) {
    log.error(""String_Node_Str"",e);
    throw new IdentifierException(e);
  }
}",0.9874804381846636
3402,"/** 
 * The metadata fields of the given item will be added to the given feed.
 * @param context	DSpace context object
 * @param dspaceItem	DSpace Item
 * @return an object representing a feed entry
 */
private com.sun.syndication.feed.rss.Item itemFromDSpaceItem(Context context,Item dspaceItem) throws SQLException {
  com.sun.syndication.feed.rss.Item rssItem=new com.sun.syndication.feed.rss.Item();
  String titleField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleField == null) {
    titleField=""String_Node_Str"";
  }
  String dateField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateField == null) {
    dateField=""String_Node_Str"";
  }
  String link=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? IdentifierService.getURL(dspaceItem).toString() : dspaceItem.getExternalIdentifier().getURI().toString();
  rssItem.setLink(link);
  String title=null;
  try {
    title=dspaceItem.getMetadata(titleField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    title=labels.getString(clazz + ""String_Node_Str"");
  }
  rssItem.setTitle(title);
  String descriptionFields=ConfigurationManager.getProperty(""String_Node_Str"");
  if (descriptionFields == null) {
    descriptionFields=defaultDescriptionFields;
  }
  StringBuffer descBuf=new StringBuffer();
  StringTokenizer st=new StringTokenizer(descriptionFields,""String_Node_Str"");
  while (st.hasMoreTokens()) {
    String field=st.nextToken().trim();
    boolean isDate=false;
    if (field.indexOf(""String_Node_Str"") > 0) {
      field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
      isDate=true;
    }
    DCValue[] values=dspaceItem.getMetadata(field);
    if (values != null && values.length > 0) {
      if (descBuf.length() > 0) {
        descBuf.append(""String_Node_Str"");
        descBuf.append(""String_Node_Str"");
      }
      String fieldLabel=null;
      try {
        fieldLabel=labels.getString(""String_Node_Str"" + field);
      }
 catch (      java.util.MissingResourceException e) {
      }
      if (fieldLabel != null && fieldLabel.length() > 0)       descBuf.append(fieldLabel + ""String_Node_Str"");
      for (int i=0; i < values.length; i++) {
        String fieldValue=values[i].value;
        if (isDate)         fieldValue=(new DCDate(fieldValue)).toString();
        descBuf.append(fieldValue);
        if (i < values.length - 1) {
          descBuf.append(""String_Node_Str"");
        }
      }
    }
  }
  Description descrip=new Description();
  descrip.setValue(descBuf.toString());
  rssItem.setDescription(descrip);
  String dcDate=null;
  try {
    dcDate=dspaceItem.getMetadata(dateField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
  }
  if (dcDate != null) {
    rssItem.setPubDate((new DCDate(dcDate)).toDate());
  }
  return rssItem;
}","/** 
 * The metadata fields of the given item will be added to the given feed.
 * @param context	DSpace context object
 * @param dspaceItem	DSpace Item
 * @return an object representing a feed entry
 */
private com.sun.syndication.feed.rss.Item itemFromDSpaceItem(Context context,Item dspaceItem) throws SQLException {
  com.sun.syndication.feed.rss.Item rssItem=new com.sun.syndication.feed.rss.Item();
  String titleField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleField == null) {
    titleField=""String_Node_Str"";
  }
  String dateField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateField == null) {
    dateField=""String_Node_Str"";
  }
  String link=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? IdentifierService.getURL(dspaceItem).toString() : dspaceItem.getExternalIdentifier().getURI().toString();
  rssItem.setLink(link);
  String title=null;
  try {
    title=dspaceItem.getMetadata(titleField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    title=labels.getString(clazz + ""String_Node_Str"");
  }
  rssItem.setTitle(title);
  String descriptionFields=ConfigurationManager.getProperty(""String_Node_Str"");
  if (descriptionFields == null) {
    descriptionFields=defaultDescriptionFields;
  }
  StringBuffer descBuf=new StringBuffer();
  StringTokenizer st=new StringTokenizer(descriptionFields,""String_Node_Str"");
  while (st.hasMoreTokens()) {
    String field=st.nextToken().trim();
    boolean isDate=false;
    if (field.indexOf(""String_Node_Str"") > 0) {
      field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
      isDate=true;
    }
    DCValue[] values=dspaceItem.getMetadata(field);
    if (values != null && values.length > 0) {
      if (descBuf.length() > 0) {
        descBuf.append(""String_Node_Str"");
        descBuf.append(""String_Node_Str"");
      }
      String fieldLabel=null;
      try {
        fieldLabel=labels.getString(""String_Node_Str"" + field);
      }
 catch (      java.util.MissingResourceException e) {
      }
      if (fieldLabel != null && fieldLabel.length() > 0)       descBuf.append(fieldLabel + ""String_Node_Str"");
      for (int i=0; i < values.length; i++) {
        String fieldValue=values[i].value;
        if (isDate)         fieldValue=(new DCDate(fieldValue)).toString();
        descBuf.append(fieldValue);
        if (i < values.length - 1) {
          descBuf.append(""String_Node_Str"");
        }
      }
    }
  }
  Description descrip=new Description();
  descrip.setValue(descBuf.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
  rssItem.setDescription(descrip);
  String dcDate=null;
  try {
    dcDate=dspaceItem.getMetadata(dateField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
  }
  if (dcDate != null) {
    rssItem.setPubDate((new DCDate(dcDate)).toDate());
  }
  return rssItem;
}",0.9915403595347198
3403,"/** 
 * Generate a syndication feed for a collection or community or community
 * @param context	the DSpace context object
 * @param dso		DSpace object - collection or community
 * @return		an object representing the feed
 */
private Channel generateFeed(Context context,DSpaceObject dso) throws IOException, SQLException {
  try {
    String dspaceUrl=ConfigurationManager.getProperty(""String_Node_Str"");
    String type=null;
    String description=null;
    String title=null;
    Bitstream logo=null;
    String idx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (idx == null) {
      throw new IOException(""String_Node_Str"");
    }
    BrowseIndex bix=BrowseIndex.getItemBrowseIndex();
    if (bix == null) {
      throw new IOException(""String_Node_Str"" + idx);
    }
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bix);
    for (    SortOption so : SortOption.getSortOptions()) {
      if (so.getName().equals(idx))       scope.setSortBy(so.getNumber());
    }
    scope.setOrder(SortOption.DESCENDING);
    Channel channel=new Channel();
    if (dso == null) {
      channel.setTitle(ConfigurationManager.getProperty(""String_Node_Str""));
      channel.setLink(dspaceUrl);
      channel.setDescription(labels.getString(clazz + ""String_Node_Str""));
    }
 else {
      if (dso.getType() == Constants.COLLECTION) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Collection col=(Collection)dso;
        description=col.getMetadata(""String_Node_Str"");
        title=col.getMetadata(""String_Node_Str"");
        logo=col.getLogo();
        scope.setBrowseContainer(col);
      }
 else       if (dso.getType() == Constants.COMMUNITY) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Community comm=(Community)dso;
        description=comm.getMetadata(""String_Node_Str"");
        title=comm.getMetadata(""String_Node_Str"");
        logo=comm.getLogo();
        scope.setBrowseContainer(comm);
      }
      String objectUrl=""String_Node_Str"";
      if (dso.getExternalIdentifier() != null) {
        objectUrl=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? IdentifierService.getURL(dso).toString() : dso.getExternalIdentifier().getURI().toString();
      }
 else {
        objectUrl=IdentifierService.getURL(dso).toString();
      }
      channel.setDescription(description);
      channel.setLink(objectUrl);
      String channelTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type,title});
      channel.setTitle(channelTitle);
      if (logo != null) {
        Image image=new Image();
        image.setLink(objectUrl);
        image.setTitle(labels.getString(clazz + ""String_Node_Str""));
        image.setUrl(dspaceUrl + ""String_Node_Str"" + logo.getID());
        channel.setImage(image);
      }
    }
    TextInput input=new TextInput();
    input.setLink(dspaceUrl + ""String_Node_Str"");
    input.setDescription(labels.getString(clazz + ""String_Node_Str""));
    String searchTitle=""String_Node_Str"";
    if (type != null) {
      searchTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type});
    }
 else {
      searchTitle=labels.getString(clazz + ""String_Node_Str"");
    }
    input.setTitle(searchTitle);
    input.setName(labels.getString(clazz + ""String_Node_Str""));
    channel.setTextInput(input);
    scope.setResultsPerPage(itemCount);
    BrowseEngine be=new BrowseEngine(context);
    BrowseInfo bi=be.browseMini(scope);
    Item[] results=bi.getBrowseItemResults(context);
    List items=new ArrayList();
    for (int i=0; i < results.length; i++) {
      items.add(itemFromDSpaceItem(context,results[i]));
    }
    channel.setItems(items);
    if (channel.getDescription() == null)     channel.setDescription(""String_Node_Str"");
    return channel;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new IOException(se.getMessage());
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new IOException(e.getMessage());
  }
}","/** 
 * Generate a syndication feed for a collection or community or community
 * @param context	the DSpace context object
 * @param dso		DSpace object - collection or community
 * @return		an object representing the feed
 */
private Channel generateFeed(Context context,DSpaceObject dso) throws IOException, SQLException {
  try {
    String dspaceUrl=ConfigurationManager.getProperty(""String_Node_Str"");
    String type=null;
    String description=null;
    String title=null;
    Bitstream logo=null;
    String idx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (idx == null) {
      throw new IOException(""String_Node_Str"");
    }
    BrowseIndex bix=BrowseIndex.getItemBrowseIndex();
    if (bix == null) {
      throw new IOException(""String_Node_Str"" + idx);
    }
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bix);
    for (    SortOption so : SortOption.getSortOptions()) {
      if (so.getName().equals(idx))       scope.setSortBy(so.getNumber());
    }
    scope.setOrder(SortOption.DESCENDING);
    Channel channel=new Channel();
    if (dso == null) {
      channel.setTitle(ConfigurationManager.getProperty(""String_Node_Str""));
      channel.setLink(dspaceUrl);
      channel.setDescription(labels.getString(clazz + ""String_Node_Str""));
    }
 else {
      if (dso.getType() == Constants.COLLECTION) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Collection col=(Collection)dso;
        description=col.getMetadata(""String_Node_Str"");
        title=col.getMetadata(""String_Node_Str"");
        logo=col.getLogo();
        scope.setBrowseContainer(col);
      }
 else       if (dso.getType() == Constants.COMMUNITY) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Community comm=(Community)dso;
        description=comm.getMetadata(""String_Node_Str"");
        title=comm.getMetadata(""String_Node_Str"");
        logo=comm.getLogo();
        scope.setBrowseContainer(comm);
      }
      String objectUrl=""String_Node_Str"";
      if (dso.getExternalIdentifier() != null) {
        objectUrl=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? IdentifierService.getURL(dso).toString() : dso.getExternalIdentifier().getURI().toString();
      }
 else {
        objectUrl=IdentifierService.getURL(dso).toString();
      }
      channel.setDescription(description.replaceAll(""String_Node_Str"",""String_Node_Str""));
      channel.setLink(objectUrl);
      String channelTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type,title});
      channel.setTitle(channelTitle);
      if (logo != null) {
        Image image=new Image();
        image.setLink(objectUrl);
        image.setTitle(labels.getString(clazz + ""String_Node_Str""));
        image.setUrl(dspaceUrl + ""String_Node_Str"" + logo.getID());
        channel.setImage(image);
      }
    }
    TextInput input=new TextInput();
    input.setLink(dspaceUrl + ""String_Node_Str"");
    input.setDescription(labels.getString(clazz + ""String_Node_Str""));
    String searchTitle=""String_Node_Str"";
    if (type != null) {
      searchTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type});
    }
 else {
      searchTitle=labels.getString(clazz + ""String_Node_Str"");
    }
    input.setTitle(searchTitle);
    input.setName(labels.getString(clazz + ""String_Node_Str""));
    channel.setTextInput(input);
    scope.setResultsPerPage(itemCount);
    BrowseEngine be=new BrowseEngine(context);
    BrowseInfo bi=be.browseMini(scope);
    Item[] results=bi.getBrowseItemResults(context);
    List items=new ArrayList();
    for (int i=0; i < results.length; i++) {
      items.add(itemFromDSpaceItem(context,results[i]));
    }
    channel.setItems(items);
    if (channel.getDescription() == null)     channel.setDescription(""String_Node_Str"");
    return channel;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new IOException(se.getMessage());
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new IOException(e.getMessage());
  }
}",0.9941320293398532
3404,"public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  TableRowIterator tri=null;
  try {
    List paramsList=new ArrayList();
    StringBuffer queryBuf=new StringBuffer();
    queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
    buildSelectStatement(queryBuf,paramsList);
    if (isAscending) {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value);
    }
 else {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value + Character.MAX_VALUE);
    }
    if (containerTable != null || (value != null && valueField != null && tableDis != null && tableMap != null)) {
      queryBuf.append(""String_Node_Str"").append(""String_Node_Str"");
      queryBuf.append(table).append(""String_Node_Str"");
    }
    tri=DatabaseManager.query(context,queryBuf.toString(),paramsList.toArray());
    TableRow row;
    if (tri.hasNext()) {
      row=tri.next();
      return row.getIntColumn(""String_Node_Str"");
    }
 else {
      return 0;
    }
  }
 catch (  SQLException e) {
    throw new BrowseException(e);
  }
 finally {
    if (tri != null) {
      tri.close();
    }
  }
}","public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  TableRowIterator tri=null;
  if (column == null || value == null)   return 0;
  try {
    List paramsList=new ArrayList();
    StringBuffer queryBuf=new StringBuffer();
    queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
    buildSelectStatement(queryBuf,paramsList);
    if (isAscending) {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value);
    }
 else {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value + Character.MAX_VALUE);
    }
    if (containerTable != null || (value != null && valueField != null && tableDis != null && tableMap != null)) {
      queryBuf.append(""String_Node_Str"").append(""String_Node_Str"");
      queryBuf.append(table).append(""String_Node_Str"");
    }
    tri=DatabaseManager.query(context,queryBuf.toString(),paramsList.toArray());
    TableRow row;
    if (tri.hasNext()) {
      row=tri.next();
      return row.getIntColumn(""String_Node_Str"");
    }
 else {
      return 0;
    }
  }
 catch (  SQLException e) {
    throw new BrowseException(e);
  }
 finally {
    if (tri != null) {
      tri.close();
    }
  }
}",0.9799449469130947
3405,"public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  TableRowIterator tri=null;
  try {
    List paramsList=new ArrayList();
    StringBuffer queryBuf=new StringBuffer();
    queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
    buildSelectStatement(queryBuf,paramsList);
    if (isAscending) {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value);
    }
 else {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value + Character.MAX_VALUE);
    }
    if (containerTable != null || (value != null && valueField != null && tableDis != null && tableMap != null)) {
      queryBuf.append(""String_Node_Str"").append(""String_Node_Str"");
      queryBuf.append(table).append(""String_Node_Str"");
    }
    tri=DatabaseManager.query(context,queryBuf.toString(),paramsList.toArray());
    TableRow row;
    if (tri.hasNext()) {
      row=tri.next();
      return (int)row.getLongColumn(""String_Node_Str"");
    }
 else {
      return 0;
    }
  }
 catch (  SQLException e) {
    throw new BrowseException(e);
  }
 finally {
    if (tri != null) {
      tri.close();
    }
  }
}","public int doOffsetQuery(String column,String value,boolean isAscending) throws BrowseException {
  TableRowIterator tri=null;
  if (column == null || value == null)   return 0;
  try {
    List paramsList=new ArrayList();
    StringBuffer queryBuf=new StringBuffer();
    queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
    buildSelectStatement(queryBuf,paramsList);
    if (isAscending) {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value);
    }
 else {
      queryBuf.append(""String_Node_Str"").append(column).append(""String_Node_Str"");
      paramsList.add(value + Character.MAX_VALUE);
    }
    if (containerTable != null || (value != null && valueField != null && tableDis != null && tableMap != null)) {
      queryBuf.append(""String_Node_Str"").append(""String_Node_Str"");
      queryBuf.append(table).append(""String_Node_Str"");
    }
    tri=DatabaseManager.query(context,queryBuf.toString(),paramsList.toArray());
    TableRow row;
    if (tri.hasNext()) {
      row=tri.next();
      return (int)row.getLongColumn(""String_Node_Str"");
    }
 else {
      return 0;
    }
  }
 catch (  SQLException e) {
    throw new BrowseException(e);
  }
 finally {
    if (tri != null) {
      tri.close();
    }
  }
}",0.9800391389432486
3406,"/** 
 * The metadata fields of the given item will be added to the given feed.
 * @param context	DSpace context object
 * @param dspaceItem	DSpace Item
 * @return an object representing a feed entry
 */
private com.sun.syndication.feed.rss.Item itemFromDSpaceItem(Context context,Item dspaceItem) throws SQLException {
  com.sun.syndication.feed.rss.Item rssItem=new com.sun.syndication.feed.rss.Item();
  String titleField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleField == null) {
    titleField=""String_Node_Str"";
  }
  String dateField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateField == null) {
    dateField=""String_Node_Str"";
  }
  String itHandle=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? HandleManager.resolveToURL(context,dspaceItem.getHandle()) : HandleManager.getCanonicalForm(dspaceItem.getHandle());
  rssItem.setLink(itHandle);
  String title=null;
  try {
    title=dspaceItem.getMetadata(titleField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    title=labels.getString(clazz + ""String_Node_Str"");
  }
  rssItem.setTitle(title);
  String descriptionFields=ConfigurationManager.getProperty(""String_Node_Str"");
  if (descriptionFields == null) {
    descriptionFields=defaultDescriptionFields;
  }
  StringBuffer descBuf=new StringBuffer();
  StringTokenizer st=new StringTokenizer(descriptionFields,""String_Node_Str"");
  while (st.hasMoreTokens()) {
    String field=st.nextToken().trim();
    boolean isDate=false;
    if (field.indexOf(""String_Node_Str"") > 0) {
      field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
      isDate=true;
    }
    DCValue[] values=dspaceItem.getMetadata(field);
    if (values != null && values.length > 0) {
      if (descBuf.length() > 0) {
        descBuf.append(""String_Node_Str"");
        descBuf.append(""String_Node_Str"");
      }
      String fieldLabel=null;
      try {
        fieldLabel=labels.getString(""String_Node_Str"" + field);
      }
 catch (      java.util.MissingResourceException e) {
      }
      if (fieldLabel != null && fieldLabel.length() > 0)       descBuf.append(fieldLabel + ""String_Node_Str"");
      for (int i=0; i < values.length; i++) {
        String fieldValue=values[i].value;
        if (isDate)         fieldValue=(new DCDate(fieldValue)).toString();
        descBuf.append(fieldValue);
        if (i < values.length - 1) {
          descBuf.append(""String_Node_Str"");
        }
      }
    }
  }
  Description descrip=new Description();
  descrip.setValue(descBuf.toString());
  rssItem.setDescription(descrip);
  String dcDate=null;
  try {
    dcDate=dspaceItem.getMetadata(dateField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
  }
  if (dcDate != null) {
    rssItem.setPubDate((new DCDate(dcDate)).toDate());
  }
  return rssItem;
}","/** 
 * The metadata fields of the given item will be added to the given feed.
 * @param context	DSpace context object
 * @param dspaceItem	DSpace Item
 * @return an object representing a feed entry
 */
private com.sun.syndication.feed.rss.Item itemFromDSpaceItem(Context context,Item dspaceItem) throws SQLException {
  com.sun.syndication.feed.rss.Item rssItem=new com.sun.syndication.feed.rss.Item();
  String titleField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleField == null) {
    titleField=""String_Node_Str"";
  }
  String dateField=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateField == null) {
    dateField=""String_Node_Str"";
  }
  String itHandle=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? HandleManager.resolveToURL(context,dspaceItem.getHandle()) : HandleManager.getCanonicalForm(dspaceItem.getHandle());
  rssItem.setLink(itHandle);
  String title=null;
  try {
    title=dspaceItem.getMetadata(titleField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    title=labels.getString(clazz + ""String_Node_Str"");
  }
  rssItem.setTitle(title);
  String descriptionFields=ConfigurationManager.getProperty(""String_Node_Str"");
  if (descriptionFields == null) {
    descriptionFields=defaultDescriptionFields;
  }
  StringBuffer descBuf=new StringBuffer();
  StringTokenizer st=new StringTokenizer(descriptionFields,""String_Node_Str"");
  while (st.hasMoreTokens()) {
    String field=st.nextToken().trim();
    boolean isDate=false;
    if (field.indexOf(""String_Node_Str"") > 0) {
      field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
      isDate=true;
    }
    DCValue[] values=dspaceItem.getMetadata(field);
    if (values != null && values.length > 0) {
      if (descBuf.length() > 0) {
        descBuf.append(""String_Node_Str"");
        descBuf.append(""String_Node_Str"");
      }
      String fieldLabel=null;
      try {
        fieldLabel=labels.getString(""String_Node_Str"" + field);
      }
 catch (      java.util.MissingResourceException e) {
      }
      if (fieldLabel != null && fieldLabel.length() > 0)       descBuf.append(fieldLabel + ""String_Node_Str"");
      for (int i=0; i < values.length; i++) {
        String fieldValue=values[i].value;
        if (isDate)         fieldValue=(new DCDate(fieldValue)).toString();
        descBuf.append(fieldValue);
        if (i < values.length - 1) {
          descBuf.append(""String_Node_Str"");
        }
      }
    }
  }
  Description descrip=new Description();
  descrip.setValue(descBuf.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
  rssItem.setDescription(descrip);
  String dcDate=null;
  try {
    dcDate=dspaceItem.getMetadata(dateField)[0].value;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
  }
  if (dcDate != null) {
    rssItem.setPubDate((new DCDate(dcDate)).toDate());
  }
  return rssItem;
}",0.9915966386554622
3407,"/** 
 * Generate a syndication feed for a collection or community or community
 * @param context	the DSpace context object
 * @param dso		DSpace object - collection or community
 * @return		an object representing the feed
 */
private Channel generateFeed(Context context,DSpaceObject dso) throws IOException, SQLException {
  try {
    String dspaceUrl=ConfigurationManager.getProperty(""String_Node_Str"");
    String type=null;
    String description=null;
    String title=null;
    Bitstream logo=null;
    String idx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (idx == null) {
      throw new IOException(""String_Node_Str"");
    }
    BrowseIndex bix=BrowseIndex.getItemBrowseIndex();
    if (bix == null) {
      throw new IOException(""String_Node_Str"" + idx);
    }
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bix);
    for (    SortOption so : SortOption.getSortOptions()) {
      if (so.getName().equals(idx))       scope.setSortBy(so.getNumber());
    }
    scope.setOrder(SortOption.DESCENDING);
    Channel channel=new Channel();
    if (dso == null) {
      channel.setTitle(ConfigurationManager.getProperty(""String_Node_Str""));
      channel.setLink(dspaceUrl);
      channel.setDescription(labels.getString(clazz + ""String_Node_Str""));
    }
 else {
      if (dso.getType() == Constants.COLLECTION) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Collection col=(Collection)dso;
        description=col.getMetadata(""String_Node_Str"");
        title=col.getMetadata(""String_Node_Str"");
        logo=col.getLogo();
        scope.setBrowseContainer(col);
      }
 else       if (dso.getType() == Constants.COMMUNITY) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Community comm=(Community)dso;
        description=comm.getMetadata(""String_Node_Str"");
        title=comm.getMetadata(""String_Node_Str"");
        logo=comm.getLogo();
        scope.setBrowseContainer(comm);
      }
      String objectUrl=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? HandleManager.resolveToURL(context,dso.getHandle()) : HandleManager.getCanonicalForm(dso.getHandle());
      channel.setDescription(description);
      channel.setLink(objectUrl);
      String channelTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type,title});
      channel.setTitle(channelTitle);
      if (logo != null) {
        Image image=new Image();
        image.setLink(objectUrl);
        image.setTitle(labels.getString(clazz + ""String_Node_Str""));
        image.setUrl(dspaceUrl + ""String_Node_Str"" + logo.getID());
        channel.setImage(image);
      }
    }
    TextInput input=new TextInput();
    input.setLink(dspaceUrl + ""String_Node_Str"");
    input.setDescription(labels.getString(clazz + ""String_Node_Str""));
    String searchTitle=""String_Node_Str"";
    if (type != null) {
      searchTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type});
    }
 else {
      searchTitle=labels.getString(clazz + ""String_Node_Str"");
    }
    input.setTitle(searchTitle);
    input.setName(labels.getString(clazz + ""String_Node_Str""));
    channel.setTextInput(input);
    scope.setResultsPerPage(itemCount);
    BrowseEngine be=new BrowseEngine(context);
    BrowseInfo bi=be.browseMini(scope);
    Item[] results=bi.getItemResults(context);
    List items=new ArrayList();
    for (int i=0; i < results.length; i++) {
      items.add(itemFromDSpaceItem(context,results[i]));
    }
    channel.setItems(items);
    if (channel.getDescription() == null)     channel.setDescription(""String_Node_Str"");
    return channel;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new IOException(se.getMessage());
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new IOException(e.getMessage());
  }
}","/** 
 * Generate a syndication feed for a collection or community or community
 * @param context	the DSpace context object
 * @param dso		DSpace object - collection or community
 * @return		an object representing the feed
 */
private Channel generateFeed(Context context,DSpaceObject dso) throws IOException, SQLException {
  try {
    String dspaceUrl=ConfigurationManager.getProperty(""String_Node_Str"");
    String type=null;
    String description=null;
    String title=null;
    Bitstream logo=null;
    String idx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (idx == null) {
      throw new IOException(""String_Node_Str"");
    }
    BrowseIndex bix=BrowseIndex.getItemBrowseIndex();
    if (bix == null) {
      throw new IOException(""String_Node_Str"" + idx);
    }
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bix);
    for (    SortOption so : SortOption.getSortOptions()) {
      if (so.getName().equals(idx))       scope.setSortBy(so.getNumber());
    }
    scope.setOrder(SortOption.DESCENDING);
    Channel channel=new Channel();
    if (dso == null) {
      channel.setTitle(ConfigurationManager.getProperty(""String_Node_Str""));
      channel.setLink(dspaceUrl);
      channel.setDescription(labels.getString(clazz + ""String_Node_Str""));
    }
 else {
      if (dso.getType() == Constants.COLLECTION) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Collection col=(Collection)dso;
        description=col.getMetadata(""String_Node_Str"");
        title=col.getMetadata(""String_Node_Str"");
        logo=col.getLogo();
        scope.setBrowseContainer(col);
      }
 else       if (dso.getType() == Constants.COMMUNITY) {
        type=labels.getString(clazz + ""String_Node_Str"");
        Community comm=(Community)dso;
        description=comm.getMetadata(""String_Node_Str"");
        title=comm.getMetadata(""String_Node_Str"");
        logo=comm.getLogo();
        scope.setBrowseContainer(comm);
      }
      String objectUrl=ConfigurationManager.getBooleanProperty(""String_Node_Str"") ? HandleManager.resolveToURL(context,dso.getHandle()) : HandleManager.getCanonicalForm(dso.getHandle());
      channel.setDescription(description.replaceAll(""String_Node_Str"",""String_Node_Str""));
      channel.setLink(objectUrl);
      String channelTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type,title});
      channel.setTitle(channelTitle);
      if (logo != null) {
        Image image=new Image();
        image.setLink(objectUrl);
        image.setTitle(labels.getString(clazz + ""String_Node_Str""));
        image.setUrl(dspaceUrl + ""String_Node_Str"" + logo.getID());
        channel.setImage(image);
      }
    }
    TextInput input=new TextInput();
    input.setLink(dspaceUrl + ""String_Node_Str"");
    input.setDescription(labels.getString(clazz + ""String_Node_Str""));
    String searchTitle=""String_Node_Str"";
    if (type != null) {
      searchTitle=MessageFormat.format(labels.getString(clazz + ""String_Node_Str""),new Object[]{type});
    }
 else {
      searchTitle=labels.getString(clazz + ""String_Node_Str"");
    }
    input.setTitle(searchTitle);
    input.setName(labels.getString(clazz + ""String_Node_Str""));
    channel.setTextInput(input);
    scope.setResultsPerPage(itemCount);
    BrowseEngine be=new BrowseEngine(context);
    BrowseInfo bi=be.browseMini(scope);
    Item[] results=bi.getItemResults(context);
    List items=new ArrayList();
    for (int i=0; i < results.length; i++) {
      items.add(itemFromDSpaceItem(context,results[i]));
    }
    channel.setItems(items);
    if (channel.getDescription() == null)     channel.setDescription(""String_Node_Str"");
    return channel;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new IOException(se.getMessage());
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new IOException(e.getMessage());
  }
}",0.9938853503184714
3408,"/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]);
  }
  Item item=(Item)dso;
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + dso.getID());
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}","/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]);
  }
  Item item=(Item)dso;
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + dso.getID());
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      if (v.value == null) {
        e.setAttribute(""String_Node_Str"",""String_Node_Str"");
      }
 else {
        String reason=Verifier.checkCharacterData(v.value);
        if (reason == null) {
          e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
        }
 else {
          log.warn(""String_Node_Str"" + reason);
          String simpleText=v.value.replaceAll(""String_Node_Str"",""String_Node_Str"");
          if (Verifier.checkCharacterData(simpleText) == null)           e.setAttribute(""String_Node_Str"",simpleText);
        }
      }
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}",0.8879706152433425
3409,"/** 
 * Query DSpace for a list of all items / collections / or communities that match the given search query.
 * @return The associated query results.
 */
protected void performSearch() throws SQLException, IOException {
  if (queryResults != null)   return;
  Context context=ContextUtil.obtainContext(objectModel);
  String query=getQuery();
  DSpaceObject scope=getScope();
  int page=getParameterPage();
  QueryArgs qArgs=new QueryArgs();
  qArgs.setPageSize(getParameterRpp());
  try {
    qArgs.setSortOption(SortOption.getSortOption(getParameterSortBy()));
  }
 catch (  SortException se) {
  }
  qArgs.setSortOrder(getParameterOrder());
  qArgs.setQuery(query);
  if (page > 1)   qArgs.setStart((Integer.valueOf(page) - 1) * qArgs.getPageSize());
 else   qArgs.setStart(0);
  QueryResults qResults=null;
  if (scope instanceof Community) {
    qResults=DSQuery.doQuery(context,qArgs,(Community)scope);
  }
 else   if (scope instanceof Collection) {
    qResults=DSQuery.doQuery(context,qArgs,(Collection)scope);
  }
 else {
    qResults=DSQuery.doQuery(context,qArgs);
  }
  this.queryResults=qResults;
}","/** 
 * Query DSpace for a list of all items / collections / or communities that match the given search query.
 * @return The associated query results.
 */
protected void performSearch() throws SQLException, IOException, UIException {
  if (queryResults != null)   return;
  Context context=ContextUtil.obtainContext(objectModel);
  String query=getQuery();
  DSpaceObject scope=getScope();
  int page=getParameterPage();
  QueryArgs qArgs=new QueryArgs();
  qArgs.setPageSize(getParameterRpp());
  try {
    qArgs.setSortOption(SortOption.getSortOption(getParameterSortBy()));
  }
 catch (  SortException se) {
  }
  qArgs.setSortOrder(getParameterOrder());
  qArgs.setQuery(query);
  if (page > 1)   qArgs.setStart((Integer.valueOf(page) - 1) * qArgs.getPageSize());
 else   qArgs.setStart(0);
  QueryResults qResults=null;
  if (scope instanceof Community) {
    qResults=DSQuery.doQuery(context,qArgs,(Community)scope);
  }
 else   if (scope instanceof Collection) {
    qResults=DSQuery.doQuery(context,qArgs,(Collection)scope);
  }
 else {
    qResults=DSQuery.doQuery(context,qArgs);
  }
  this.queryResults=qResults;
}",0.994193836534167
3410,"/** 
 * Extract the query string. Under most implementations this will be derived from the url parameters.
 * @return The query string.
 */
abstract protected String getQuery();","/** 
 * Extract the query string. Under most implementations this will be derived from the url parameters.
 * @return The query string.
 */
abstract protected String getQuery() throws UIException ;",0.946524064171123
3411,"/** 
 * Build the query field for the given cell.
 * @param row The current row.
 * @param cell The current cell.
 */
private void buildQueryField(int row,Cell cell) throws WingException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String current=request.getParameter(""String_Node_Str"" + row);
  Text text=cell.addText(""String_Node_Str"" + row);
  if (current != null)   text.setValue(current);
}","/** 
 * Build the query field for the given cell.
 * @param row The current row.
 * @param cell The current cell.
 */
private void buildQueryField(int row,Cell cell) throws WingException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String current=URLDecode(request.getParameter(""String_Node_Str"" + row));
  Text text=cell.addText(""String_Node_Str"" + row);
  if (current != null)   text.setValue(current);
}",0.9869203329369798
3412,"/** 
 * Get a list of search fields from the request object and parse them into a linear array of fileds. The field's index is preserved, so if it comes in as index 17 it will  be outputted as field 17.
 * @param request The http request object
 * @return Array of search fields
 */
public ArrayList<SearchField> getSearchFields(Request request){
  if (this.fields != null)   return this.fields;
  int numSearchField;
  try {
    String numSearchFieldStr=request.getParameter(""String_Node_Str"");
    numSearchField=Integer.valueOf(numSearchFieldStr);
  }
 catch (  NumberFormatException nfe) {
    numSearchField=FIELD_MAX_COUNT;
  }
  ArrayList<SearchField> fields=new ArrayList<SearchField>();
  for (int i=1; i <= numSearchField; i++) {
    String field=request.getParameter(""String_Node_Str"" + i);
    String query=request.getParameter(""String_Node_Str"" + i);
    String conjunction=request.getParameter(""String_Node_Str"" + i);
    if (field != null) {
      field=field.trim();
      if (field.length() == 0)       field=null;
    }
    if (query != null) {
      query=query.trim();
      if (query.length() == 0)       query=null;
    }
    if (conjunction != null) {
      conjunction=conjunction.trim();
      if (conjunction.length() == 0)       conjunction=null;
    }
    if (field == null)     field=""String_Node_Str"";
    if (conjunction == null)     conjunction=""String_Node_Str"";
    if (query != null)     fields.add(new SearchField(i,field,query,conjunction));
  }
  this.fields=fields;
  return this.fields;
}","/** 
 * Get a list of search fields from the request object and parse them into a linear array of fileds. The field's index is preserved, so if it comes in as index 17 it will  be outputted as field 17.
 * @param request The http request object
 * @return Array of search fields
 * @throws UIException 
 */
public ArrayList<SearchField> getSearchFields(Request request) throws UIException {
  if (this.fields != null)   return this.fields;
  int numSearchField;
  try {
    String numSearchFieldStr=request.getParameter(""String_Node_Str"");
    numSearchField=Integer.valueOf(numSearchFieldStr);
  }
 catch (  NumberFormatException nfe) {
    numSearchField=FIELD_MAX_COUNT;
  }
  ArrayList<SearchField> fields=new ArrayList<SearchField>();
  for (int i=1; i <= numSearchField; i++) {
    String field=request.getParameter(""String_Node_Str"" + i);
    String query=URLDecode(request.getParameter(""String_Node_Str"" + i));
    String conjunction=request.getParameter(""String_Node_Str"" + i);
    if (field != null) {
      field=field.trim();
      if (field.length() == 0)       field=null;
    }
    if (query != null) {
      query=query.trim();
      if (query.length() == 0)       query=null;
    }
    if (conjunction != null) {
      conjunction=conjunction.trim();
      if (conjunction.length() == 0)       conjunction=null;
    }
    if (field == null)     field=""String_Node_Str"";
    if (conjunction == null)     conjunction=""String_Node_Str"";
    if (query != null)     fields.add(new SearchField(i,field,query,conjunction));
  }
  this.fields=fields;
  return this.fields;
}",0.9823207971713276
3413,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Division search=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  search.setHead(T_head);
  search.addPara(T_para1);
  Para fields=search.addPara();
  fields.addText(""String_Node_Str"");
  fields.addButton(""String_Node_Str"").setValue(T_go);
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Division search=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_GET,""String_Node_Str"");
  search.setHead(T_head);
  search.addPara(T_para1);
  Para fields=search.addPara();
  fields.addText(""String_Node_Str"");
  fields.addButton(""String_Node_Str"").setValue(T_go);
}",0.9943374858437146
3414,"/** 
 * build the DRI page representing the body of the search query. This provides a widget to generate a new query and list of search results if present.
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  String queryString=getQuery();
  Division search=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  search.setHead(T_head);
  Division query=search.addInteractiveDivision(""String_Node_Str"",""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  List queryList=query.addList(""String_Node_Str"",List.TYPE_FORM);
  if (variableScope()) {
    Select scope=queryList.addItem().addSelect(""String_Node_Str"");
    scope.setLabel(T_search_scope);
    buildScopeList(scope);
  }
  Text text=queryList.addItem().addText(""String_Node_Str"");
  text.setLabel(T_full_text_search);
  text.setValue(queryString);
  buildSearchControls(query);
  query.addPara(null,""String_Node_Str"").addButton(""String_Node_Str"").setValue(T_go);
  buildSearchResultsDivision(search);
}","/** 
 * build the DRI page representing the body of the search query. This provides a widget to generate a new query and list of search results if present.
 */
public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  String queryString=getQuery();
  Division search=body.addDivision(""String_Node_Str"",""String_Node_Str"");
  search.setHead(T_head);
  Division query=search.addInteractiveDivision(""String_Node_Str"",""String_Node_Str"",Division.METHOD_GET,""String_Node_Str"");
  List queryList=query.addList(""String_Node_Str"",List.TYPE_FORM);
  if (variableScope()) {
    Select scope=queryList.addItem().addSelect(""String_Node_Str"");
    scope.setLabel(T_search_scope);
    buildScopeList(scope);
  }
  Text text=queryList.addItem().addText(""String_Node_Str"");
  text.setLabel(T_full_text_search);
  text.setValue(queryString);
  buildSearchControls(query);
  query.addPara(null,""String_Node_Str"").addButton(""String_Node_Str"").setValue(T_go);
  buildSearchResultsDivision(search);
}",0.997617913292044
3415,"/** 
 * Get the search query from the URL parameter, if none is found the empty string is returned.
 */
protected String getQuery(){
  Request request=ObjectModelHelper.getRequest(objectModel);
  String query=request.getParameter(""String_Node_Str"");
  if (query == null)   return ""String_Node_Str"";
  return query;
}","/** 
 * Get the search query from the URL parameter, if none is found the empty string is returned.
 */
protected String getQuery() throws UIException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  String query=URLDecode(request.getParameter(""String_Node_Str""));
  if (query == null)   return ""String_Node_Str"";
  return query;
}",0.9532428355957768
3416,"/** 
 * Get the limit clause to perform search result truncation.  Will return something of the form: <code> LIMIT [limit] </code>
 */
private void buildRowLimitAndOffset(StringBuffer queryBuf,List params){
  if (limit > 0 || offset > 0) {
    queryBuf.insert(0,""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
  }
  if (limit > 0) {
    queryBuf.append(""String_Node_Str"");
    if (offset > 0)     params.add(new Integer(limit + offset));
 else     params.add(new Integer(limit));
  }
  if (offset > -1) {
    queryBuf.insert(0,""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
    params.add(new Integer(offset));
  }
}","/** 
 * Get the limit clause to perform search result truncation.  Will return something of the form: <code> LIMIT [limit] </code>
 */
private void buildRowLimitAndOffset(StringBuffer queryBuf,List params){
  if (limit > 0 || offset > 0) {
    queryBuf.insert(0,""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
  }
  if (limit > 0) {
    queryBuf.append(""String_Node_Str"");
    if (offset > 0)     params.add(new Integer(limit + offset));
 else     params.add(new Integer(limit));
  }
  if (offset > 0) {
    queryBuf.insert(0,""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
    params.add(new Integer(offset));
  }
}",0.9976580796252928
3417,"/** 
 * Find the epeople that match the search query across firstname, lastname or email.  This method also allows offsets and limits for pagination purposes. 
 * @param context DSpace context
 * @param query The search string
 * @param offset Inclusive offset 
 * @param limit Maximum number of matches returned
 * @return array of EPerson objects
 */
public static EPerson[] search(Context context,String query,int offset,int limit) throws SQLException {
  String params=""String_Node_Str"" + query.toLowerCase() + ""String_Node_Str"";
  String dbquery=""String_Node_Str"" + ""String_Node_Str"";
  if (offset >= 0 && limit > 0) {
    dbquery+=""String_Node_Str"" + limit + ""String_Node_Str""+ offset;
  }
  Integer int_param;
  try {
    int_param=Integer.valueOf(query);
  }
 catch (  NumberFormatException e) {
    int_param=new Integer(-1);
  }
  TableRowIterator rows=DatabaseManager.query(context,dbquery,new Object[]{int_param,params,params,params});
  List epeopleRows=rows.toList();
  EPerson[] epeople=new EPerson[epeopleRows.size()];
  for (int i=0; i < epeopleRows.size(); i++) {
    TableRow row=(TableRow)epeopleRows.get(i);
    EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      epeople[i]=fromCache;
    }
 else {
      epeople[i]=new EPerson(context,row);
    }
  }
  return epeople;
}","/** 
 * Find the epeople that match the search query across firstname, lastname or email.  This method also allows offsets and limits for pagination purposes. 
 * @param context DSpace context
 * @param query The search string
 * @param offset Inclusive offset 
 * @param limit Maximum number of matches returned
 * @return array of EPerson objects
 */
public static EPerson[] search(Context context,String query,int offset,int limit) throws SQLException {
  String params=""String_Node_Str"" + query.toLowerCase() + ""String_Node_Str"";
  StringBuffer queryBuf=new StringBuffer();
  queryBuf.append(""String_Node_Str"");
  queryBuf.append(""String_Node_Str"");
  if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
    if (limit > 0 || offset > 0) {
      queryBuf.insert(0,""String_Node_Str"");
      queryBuf.append(""String_Node_Str"");
    }
    if (limit > 0) {
      queryBuf.append(""String_Node_Str"");
      if (offset > 0)       limit+=offset;
    }
    if (offset > 0) {
      queryBuf.insert(0,""String_Node_Str"");
      queryBuf.append(""String_Node_Str"");
    }
  }
 else {
    if (limit > 0)     queryBuf.append(""String_Node_Str"");
    if (offset > 0)     queryBuf.append(""String_Node_Str"");
  }
  String dbquery=queryBuf.toString();
  Integer int_param;
  try {
    int_param=Integer.valueOf(query);
  }
 catch (  NumberFormatException e) {
    int_param=new Integer(-1);
  }
  Object[] paramArr=new Object[]{int_param,params,params,params};
  if (limit > 0 && offset > 0)   paramArr=new Object[]{int_param,params,params,params,limit,offset};
 else   if (limit > 0)   paramArr=new Object[]{int_param,params,params,params,limit};
 else   if (offset > 0)   paramArr=new Object[]{int_param,params,params,params,offset};
  TableRowIterator rows=DatabaseManager.query(context,dbquery,paramArr);
  List epeopleRows=rows.toList();
  EPerson[] epeople=new EPerson[epeopleRows.size()];
  for (int i=0; i < epeopleRows.size(); i++) {
    TableRow row=(TableRow)epeopleRows.get(i);
    EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      epeople[i]=fromCache;
    }
 else {
      epeople[i]=new EPerson(context,row);
    }
  }
  return epeople;
}",0.6460519050248481
3418,"/** 
 * Find the groups that match the search query across eperson_group_id or name
 * @param context DSpace context
 * @param query The search string
 * @param offset Inclusive offset 
 * @param limit Maximum number of matches returned
 * @return array of Group objects
 */
public static Group[] search(Context context,String query,int offset,int limit) throws SQLException {
  String params=""String_Node_Str"" + query.toLowerCase() + ""String_Node_Str"";
  String dbquery=""String_Node_Str"";
  if (offset >= 0 && limit > 0) {
    dbquery+=""String_Node_Str"" + limit + ""String_Node_Str""+ offset;
  }
  Integer int_param;
  try {
    int_param=Integer.valueOf(query);
  }
 catch (  NumberFormatException e) {
    int_param=new Integer(-1);
  }
  TableRowIterator rows=DatabaseManager.query(context,dbquery,new Object[]{params,int_param});
  List groupRows=rows.toList();
  Group[] groups=new Group[groupRows.size()];
  for (int i=0; i < groupRows.size(); i++) {
    TableRow row=(TableRow)groupRows.get(i);
    Group fromCache=(Group)context.fromCache(Group.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      groups[i]=fromCache;
    }
 else {
      groups[i]=new Group(context,row);
    }
  }
  return groups;
}","/** 
 * Find the groups that match the search query across eperson_group_id or name
 * @param context DSpace context
 * @param query The search string
 * @param offset Inclusive offset 
 * @param limit Maximum number of matches returned
 * @return array of Group objects
 */
public static Group[] search(Context context,String query,int offset,int limit) throws SQLException {
  String params=""String_Node_Str"" + query.toLowerCase() + ""String_Node_Str"";
  StringBuffer queryBuf=new StringBuffer();
  queryBuf.append(""String_Node_Str"");
  if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
    if (limit > 0 || offset > 0) {
      queryBuf.insert(0,""String_Node_Str"");
      queryBuf.append(""String_Node_Str"");
    }
    if (limit > 0) {
      queryBuf.append(""String_Node_Str"");
      if (offset > 0)       limit+=offset;
    }
    if (offset > 0) {
      queryBuf.insert(0,""String_Node_Str"");
      queryBuf.append(""String_Node_Str"");
    }
  }
 else {
    if (limit > 0)     queryBuf.append(""String_Node_Str"");
    if (offset > 0)     queryBuf.append(""String_Node_Str"");
  }
  String dbquery=queryBuf.toString();
  Integer int_param;
  try {
    int_param=Integer.valueOf(query);
  }
 catch (  NumberFormatException e) {
    int_param=new Integer(-1);
  }
  Object[] paramArr=new Object[]{params,int_param};
  if (limit > 0 && offset > 0)   paramArr=new Object[]{params,int_param,limit,offset};
 else   if (limit > 0)   paramArr=new Object[]{params,int_param,limit};
 else   if (offset > 0)   paramArr=new Object[]{params,int_param,offset};
  TableRowIterator rows=DatabaseManager.query(context,dbquery,paramArr);
  List groupRows=rows.toList();
  Group[] groups=new Group[groupRows.size()];
  for (int i=0; i < groupRows.size(); i++) {
    TableRow row=(TableRow)groupRows.get(i);
    Group fromCache=(Group)context.fromCache(Group.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      groups[i]=fromCache;
    }
 else {
      groups[i]=new Group(context,row);
    }
  }
  return groups;
}",0.6043822276323798
3419,"/** 
 * Get the query parameters supplied to the browse.
 * @return
 * @throws SQLException
 * @throws UIException
 */
private BrowseParams getUserParams() throws SQLException, UIException {
  if (this.userParams != null)   return this.userParams;
  Context context=ContextUtil.obtainContext(objectModel);
  Request request=ObjectModelHelper.getRequest(objectModel);
  BrowseParams params=new BrowseParams();
  params.month=request.getParameter(BrowseParams.MONTH);
  params.year=request.getParameter(BrowseParams.YEAR);
  params.etAl=RequestUtils.getIntParameter(request,BrowseParams.ETAL);
  params.scope=new BrowserScope(context);
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (dso instanceof Community)   params.scope.setCommunity((Community)dso);
  if (dso instanceof Collection)   params.scope.setCollection((Collection)dso);
  try {
    String type=request.getParameter(BrowseParams.TYPE);
    int sortBy=RequestUtils.getIntParameter(request,BrowseParams.SORT_BY);
    BrowseIndex bi=BrowseIndex.getBrowseIndex(type);
    if (bi == null) {
      throw new BrowseException(""String_Node_Str"" + type);
    }
    if (sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi.isItemIndex() && !bi.isInternalIndex()) {
      try {
        SortOption bso=bi.getSortOption();
        SortOption so=SortOption.getSortOption(sortBy);
        if (bso != null && bso != so) {
          BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
          if (newBi != null) {
            bi=newBi;
            type=bi.getName();
          }
        }
      }
 catch (      SortException se) {
        throw new UIException(""String_Node_Str"",se);
      }
    }
    params.scope.setBrowseIndex(bi);
    params.scope.setSortBy(sortBy);
    params.scope.setJumpToItem(RequestUtils.getIntParameter(request,BrowseParams.JUMPTO_ITEM));
    params.scope.setOrder(request.getParameter(BrowseParams.ORDER));
    int offset=RequestUtils.getIntParameter(request,BrowseParams.OFFSET);
    params.scope.setOffset(offset > 0 ? offset : 0);
    params.scope.setResultsPerPage(RequestUtils.getIntParameter(request,BrowseParams.RESULTS_PER_PAGE));
    params.scope.setStartsWith(request.getParameter(BrowseParams.STARTS_WITH));
    params.scope.setFilterValue(request.getParameter(BrowseParams.FILTER_VALUE));
    params.scope.setJumpToValue(request.getParameter(BrowseParams.JUMPTO_VALUE));
    params.scope.setJumpToValueLang(request.getParameter(BrowseParams.JUMPTO_VALUE_LANG));
    params.scope.setFilterValueLang(request.getParameter(BrowseParams.FILTER_VALUE_LANG));
    if (params.scope.getFilterValue() != null)     params.scope.setBrowseLevel(1);
    if (params.year != null && !""String_Node_Str"".equals(params.year) && !""String_Node_Str"".equals(params.year)) {
      String startsWith=params.year;
      if ((params.month != null) && !""String_Node_Str"".equals(params.month) && !""String_Node_Str"".equals(params.month)) {
        if (""String_Node_Str"".equals(params.scope.getOrder())) {
          params.month=Integer.toString((Integer.parseInt(params.month) - 1));
        }
        if (params.month.length() == 1) {
          params.month=""String_Node_Str"" + params.month;
        }
        startsWith=params.year + ""String_Node_Str"" + params.month;
        if (""String_Node_Str"".equals(params.scope.getOrder())) {
          startsWith=startsWith + ""String_Node_Str"";
        }
      }
      params.scope.setStartsWith(startsWith);
    }
  }
 catch (  BrowseException bex) {
    throw new UIException(""String_Node_Str"",bex);
  }
  this.userParams=params;
  return params;
}","/** 
 * Get the query parameters supplied to the browse.
 * @return
 * @throws SQLException
 * @throws UIException
 */
private BrowseParams getUserParams() throws SQLException, UIException {
  if (this.userParams != null)   return this.userParams;
  Context context=ContextUtil.obtainContext(objectModel);
  Request request=ObjectModelHelper.getRequest(objectModel);
  BrowseParams params=new BrowseParams();
  params.month=request.getParameter(BrowseParams.MONTH);
  params.year=request.getParameter(BrowseParams.YEAR);
  params.etAl=RequestUtils.getIntParameter(request,BrowseParams.ETAL);
  params.scope=new BrowserScope(context);
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (dso instanceof Community)   params.scope.setCommunity((Community)dso);
  if (dso instanceof Collection)   params.scope.setCollection((Collection)dso);
  try {
    String type=request.getParameter(BrowseParams.TYPE);
    int sortBy=RequestUtils.getIntParameter(request,BrowseParams.SORT_BY);
    BrowseIndex bi=BrowseIndex.getBrowseIndex(type);
    if (bi == null) {
      throw new BrowseException(""String_Node_Str"" + type);
    }
    if (sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi.isItemIndex() && !bi.isInternalIndex()) {
      try {
        SortOption bso=bi.getSortOption();
        SortOption so=SortOption.getSortOption(sortBy);
        if (bso != null && bso != so) {
          BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
          if (newBi != null) {
            bi=newBi;
            type=bi.getName();
          }
        }
      }
 catch (      SortException se) {
        throw new UIException(""String_Node_Str"",se);
      }
    }
    params.scope.setBrowseIndex(bi);
    params.scope.setSortBy(sortBy);
    params.scope.setJumpToItem(RequestUtils.getIntParameter(request,BrowseParams.JUMPTO_ITEM));
    params.scope.setOrder(request.getParameter(BrowseParams.ORDER));
    int offset=RequestUtils.getIntParameter(request,BrowseParams.OFFSET);
    params.scope.setOffset(offset > 0 ? offset : 0);
    params.scope.setResultsPerPage(RequestUtils.getIntParameter(request,BrowseParams.RESULTS_PER_PAGE));
    params.scope.setStartsWith(URLDecode(request.getParameter(BrowseParams.STARTS_WITH)));
    params.scope.setFilterValue(URLDecode(request.getParameter(BrowseParams.FILTER_VALUE)));
    params.scope.setJumpToValue(URLDecode(request.getParameter(BrowseParams.JUMPTO_VALUE)));
    params.scope.setJumpToValueLang(URLDecode(request.getParameter(BrowseParams.JUMPTO_VALUE_LANG)));
    params.scope.setFilterValueLang(URLDecode(request.getParameter(BrowseParams.FILTER_VALUE_LANG)));
    if (params.scope.getFilterValue() != null)     params.scope.setBrowseLevel(1);
    if (params.year != null && !""String_Node_Str"".equals(params.year) && !""String_Node_Str"".equals(params.year)) {
      String startsWith=params.year;
      if ((params.month != null) && !""String_Node_Str"".equals(params.month) && !""String_Node_Str"".equals(params.month)) {
        if (""String_Node_Str"".equals(params.scope.getOrder())) {
          params.month=Integer.toString((Integer.parseInt(params.month) - 1));
        }
        if (params.month.length() == 1) {
          params.month=""String_Node_Str"" + params.month;
        }
        startsWith=params.year + ""String_Node_Str"" + params.month;
        if (""String_Node_Str"".equals(params.scope.getOrder())) {
          startsWith=startsWith + ""String_Node_Str"";
        }
      }
      params.scope.setStartsWith(startsWith);
    }
  }
 catch (  BrowseException bex) {
    throw new UIException(""String_Node_Str"",bex);
  }
  this.userParams=params;
  return params;
}",0.992526158445441
3420,"/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  try {
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}","/** 
 * Decode the given string from URL transmission.
 * @param encodedString The encoded string.
 * @return The unencoded string
 */
public static String URLDecode(String encodedString) throws UIException {
  if (encodedString == null)   return null;
  try {
    return URLDecoder.decode(encodedString,Constants.DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException uee) {
    throw new UIException(uee);
  }
}",0.9447236180904522
3421,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  addControlButtons(form);
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Item item=submission.getItem();
  Collection collection=submission.getCollection();
  String actionURL=contextPath + ""String_Node_Str"" + collection.getHandle()+ ""String_Node_Str"";
  DCInputSet inputSet=null;
  DCInput[] inputs={};
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
    inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  Division div=body.addInteractiveDivision(""String_Node_Str"",actionURL,Division.METHOD_POST,""String_Node_Str"");
  div.setHead(T_submission_head);
  addSubmissionProgressList(div);
  List form=div.addList(""String_Node_Str"",List.TYPE_FORM);
  form.setHead(T_head);
  for (  DCInput dcInput : inputs) {
    if (!dcInput.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String schema=dcInput.getSchema();
    String element=dcInput.getElement();
    String qualifier=dcInput.getQualifier();
    DCValue[] dcValues=item.getMetadata(schema,element,qualifier,Item.ANY);
    String fieldName=FlowUtils.getFieldName(dcInput);
    String inputType=dcInput.getInputType();
    if (inputType.equals(""String_Node_Str"")) {
      renderNameField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDateField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSeriesField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      DCValue[] unfiltered=item.getMetadata(dcInput.getSchema(),dcInput.getElement(),Item.ANY,Item.ANY);
      ArrayList<DCValue> filtered=new ArrayList<DCValue>();
      for (      DCValue dcValue : unfiltered) {
        String unfilteredFieldName=dcValue.element + ""String_Node_Str"" + dcValue.qualifier;
        if (!inputSet.isFieldPresent(unfilteredFieldName)) {
          filtered.add(dcValue);
        }
      }
      renderQualdropField(form,fieldName,dcInput,filtered.toArray(new DCValue[filtered.size()]));
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderTextArea(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderDropdownField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderSelectFromListField(form,fieldName,dcInput,dcValues);
    }
 else     if (inputType.equals(""String_Node_Str"")) {
      renderOneboxField(form,fieldName,dcInput,dcValues);
    }
 else {
      form.addItem(T_unknown_field);
    }
  }
  div.addHidden(""String_Node_Str"").setValue(knot.getId());
  addControlButtons(form);
}",0.9898717083051992
3422,"/** 
 * Each submission step must define its own information to be reviewed during the final Review/Verify Step in the submission process. <P> The information to review should be tacked onto the passed in  List object. <P> NOTE: To remain consistent across all Steps, you should first add a sub-List object (with this step's name as the heading), by using a call to reviewList.addList().   This sublist is the list you return from this method!
 * @param reviewList The List to which all reviewable information should be added
 * @return The new sub-List object created by this step, which contains all the reviewable information.  If this step has nothing to review, then return null!   
 */
public List addReviewSection(List reviewList) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  List describeSection=reviewList.addList(""String_Node_Str"" + this.stepAndPage,List.TYPE_FORM);
  describeSection.setHead(T_head);
  DCInputSet inputSet=null;
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  DCInput[] inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  for (  DCInput input : inputs) {
    if (!input.isVisible(SCOPE))     continue;
    String inputType=input.getInputType();
    String pairsName=input.getPairsType();
    DCValue[] values=new DCValue[0];
    if (inputType.equals(""String_Node_Str"")) {
      values=submission.getItem().getMetadata(input.getSchema(),input.getElement(),Item.ANY,Item.ANY);
    }
 else {
      values=submission.getItem().getMetadata(input.getSchema(),input.getElement(),input.getQualifier(),Item.ANY);
    }
    if (values.length == 0) {
      describeSection.addLabel(input.getLabel());
      describeSection.addItem().addHighlight(""String_Node_Str"").addContent(ReviewStep.T_no_metadata);
    }
 else {
      for (      DCValue value : values) {
        String displayValue=null;
        if (inputType.equals(""String_Node_Str"")) {
          DCDate date=new DCDate(value.value);
          displayValue=date.toString();
        }
 else         if (inputType.equals(""String_Node_Str"")) {
          displayValue=input.getDisplayString(pairsName,value.value);
        }
 else         if (inputType.equals(""String_Node_Str"")) {
          String qualifier=value.qualifier;
          String displayQual=input.getDisplayString(pairsName,qualifier);
          displayValue=displayQual + ""String_Node_Str"" + value.value;
        }
 else {
          displayValue=value.value;
        }
        describeSection.addLabel(input.getLabel());
        describeSection.addItem(displayValue);
      }
    }
  }
  return describeSection;
}","/** 
 * Each submission step must define its own information to be reviewed during the final Review/Verify Step in the submission process. <P> The information to review should be tacked onto the passed in  List object. <P> NOTE: To remain consistent across all Steps, you should first add a sub-List object (with this step's name as the heading), by using a call to reviewList.addList().   This sublist is the list you return from this method!
 * @param reviewList The List to which all reviewable information should be added
 * @return The new sub-List object created by this step, which contains all the reviewable information.  If this step has nothing to review, then return null!   
 */
public List addReviewSection(List reviewList) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  List describeSection=reviewList.addList(""String_Node_Str"" + this.stepAndPage,List.TYPE_FORM);
  describeSection.setHead(T_head);
  DCInputSet inputSet=null;
  try {
    inputSet=getInputsReader().getInputs(submission.getCollection().getHandle());
  }
 catch (  ServletException se) {
    throw new UIException(se);
  }
  DCInput[] inputs=inputSet.getPageRows(getPage() - 1,submission.hasMultipleTitles(),submission.isPublishedBefore());
  for (  DCInput input : inputs) {
    if (!input.isVisible(submissionInfo.isInWorkflow() ? WORKFLOW_SCOPE : SUBMISSION_SCOPE))     continue;
    String inputType=input.getInputType();
    String pairsName=input.getPairsType();
    DCValue[] values=new DCValue[0];
    if (inputType.equals(""String_Node_Str"")) {
      values=submission.getItem().getMetadata(input.getSchema(),input.getElement(),Item.ANY,Item.ANY);
    }
 else {
      values=submission.getItem().getMetadata(input.getSchema(),input.getElement(),input.getQualifier(),Item.ANY);
    }
    if (values.length == 0) {
      describeSection.addLabel(input.getLabel());
      describeSection.addItem().addHighlight(""String_Node_Str"").addContent(ReviewStep.T_no_metadata);
    }
 else {
      for (      DCValue value : values) {
        String displayValue=null;
        if (inputType.equals(""String_Node_Str"")) {
          DCDate date=new DCDate(value.value);
          displayValue=date.toString();
        }
 else         if (inputType.equals(""String_Node_Str"")) {
          displayValue=input.getDisplayString(pairsName,value.value);
        }
 else         if (inputType.equals(""String_Node_Str"")) {
          String qualifier=value.qualifier;
          String displayQual=input.getDisplayString(pairsName,qualifier);
          displayValue=displayQual + ""String_Node_Str"" + value.value;
        }
 else {
          displayValue=value.value;
        }
        describeSection.addLabel(input.getLabel());
        describeSection.addItem(displayValue);
      }
    }
  }
  return describeSection;
}",0.9893048128342246
3423,"public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  String browseListLine=null;
  String browseWidthLine=null;
  if (browseInfo != null) {
    SortOption so=browseInfo.getSortOption();
    BrowseIndex bix=browseInfo.getBrowseIndex();
    if (bix != null) {
      if (so != null && browseListLine == null) {
        browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
        browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
      }
      if (so == null)       so=bix.getSortOption();
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
  }
  if (browseListLine == null) {
    browseListLine=ConfigurationManager.getProperty(""String_Node_Str"");
    browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (browseListLine != null) {
    if (!showThumbs && browseListLine.contains(""String_Node_Str"")) {
      browseListLine=browseListLine == null ? ""String_Node_Str"" : browseListLine;
      browseWidthLine=browseWidthLine == null ? ""String_Node_Str"" : browseWidthLine;
      StringTokenizer bllt=new StringTokenizer(browseListLine,""String_Node_Str"");
      StringTokenizer bwlt=new StringTokenizer(browseWidthLine,""String_Node_Str"");
      StringBuilder newBLLine=new StringBuilder();
      StringBuilder newBWLine=new StringBuilder();
      while (bllt.hasMoreTokens() && bwlt.hasMoreTokens()) {
        String browseListTok=bllt.hasMoreTokens() ? bllt.nextToken() : null;
        String browseWidthTok=bwlt.hasMoreTokens() ? bwlt.nextToken() : null;
        if (browseListTok == null || !browseListTok.trim().equals(""String_Node_Str"")) {
          if (browseListTok != null) {
            if (newBLLine.length() > 0)             newBLLine.append(""String_Node_Str"");
            newBLLine.append(browseListTok);
          }
          if (browseWidthTok != null) {
            if (newBWLine.length() > 0)             newBWLine.append(""String_Node_Str"");
            newBWLine.append(browseWidthTok);
          }
        }
      }
      browseListLine=newBLLine.toString();
      browseWidthLine=newBWLine.toString();
    }
    listFields=browseListLine;
    listWidths=browseWidthLine;
  }
  String dateLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateLine != null) {
    dateField=dateLine;
  }
  String titleLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleLine != null) {
    titleField=titleLine;
  }
  String authorLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (authorLine != null) {
    authorField=authorLine;
  }
  String[] fieldArr=listFields == null ? new String[0] : listFields.split(""String_Node_Str"");
  String[] widthArr=listWidths == null ? new String[0] : listWidths.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i % 2) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
 else         if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit == -1 ? metadataArray.length : authorLimit);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument=""String_Node_Str"";
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].value);
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].language)+ ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"" + etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  SQLException e) {
    throw new JspException(e);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}","public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  String browseListLine=null;
  String browseWidthLine=null;
  if (browseInfo != null) {
    SortOption so=browseInfo.getSortOption();
    BrowseIndex bix=browseInfo.getBrowseIndex();
    if (bix != null) {
      if (so != null && browseListLine == null) {
        browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
        browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str""+ so.getName()+ ""String_Node_Str"");
      }
      if (so == null)       so=bix.getSortOption();
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
    if (so != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + so.getName() + ""String_Node_Str"");
    }
    if (bix != null && browseListLine == null) {
      browseListLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
      browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"" + bix.getName() + ""String_Node_Str"");
    }
  }
  if (browseListLine == null) {
    browseListLine=ConfigurationManager.getProperty(""String_Node_Str"");
    browseWidthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (browseListLine != null) {
    if (!showThumbs && browseListLine.contains(""String_Node_Str"")) {
      browseListLine=browseListLine == null ? ""String_Node_Str"" : browseListLine;
      browseWidthLine=browseWidthLine == null ? ""String_Node_Str"" : browseWidthLine;
      StringTokenizer bllt=new StringTokenizer(browseListLine,""String_Node_Str"");
      StringTokenizer bwlt=new StringTokenizer(browseWidthLine,""String_Node_Str"");
      StringBuilder newBLLine=new StringBuilder();
      StringBuilder newBWLine=new StringBuilder();
      while (bllt.hasMoreTokens() || bwlt.hasMoreTokens()) {
        String browseListTok=bllt.hasMoreTokens() ? bllt.nextToken() : null;
        String browseWidthTok=bwlt.hasMoreTokens() ? bwlt.nextToken() : null;
        if (browseListTok == null || !browseListTok.trim().equals(""String_Node_Str"")) {
          if (browseListTok != null) {
            if (newBLLine.length() > 0)             newBLLine.append(""String_Node_Str"");
            newBLLine.append(browseListTok);
          }
          if (browseWidthTok != null) {
            if (newBWLine.length() > 0)             newBWLine.append(""String_Node_Str"");
            newBWLine.append(browseWidthTok);
          }
        }
      }
      browseListLine=newBLLine.toString();
      browseWidthLine=newBWLine.toString();
    }
    listFields=browseListLine;
    listWidths=browseWidthLine;
  }
  String dateLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateLine != null) {
    dateField=dateLine;
  }
  String titleLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleLine != null) {
    titleField=titleLine;
  }
  String authorLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (authorLine != null) {
    authorField=authorLine;
  }
  String[] fieldArr=listFields == null ? new String[0] : listFields.split(""String_Node_Str"");
  String[] widthArr=listWidths == null ? new String[0] : listWidths.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i % 2) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
 else         if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit == -1 ? metadataArray.length : authorLimit);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument=""String_Node_Str"";
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].value);
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].language)+ ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"" + etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  SQLException e) {
    throw new JspException(e);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}",0.999837925445705
3424,"public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  String configLine=null;
  String widthLine=null;
  if (sortOption != null) {
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
  }
  if (configLine == null) {
    configLine=ConfigurationManager.getProperty(""String_Node_Str"");
    widthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (configLine != null) {
    if (!showThumbs && configLine.contains(""String_Node_Str"")) {
      configLine=configLine == null ? ""String_Node_Str"" : configLine;
      widthLine=widthLine == null ? ""String_Node_Str"" : widthLine;
      StringTokenizer llt=new StringTokenizer(configLine,""String_Node_Str"");
      StringTokenizer wlt=new StringTokenizer(widthLine,""String_Node_Str"");
      StringBuilder newLLine=new StringBuilder();
      StringBuilder newWLine=new StringBuilder();
      while (llt.hasMoreTokens() && wlt.hasMoreTokens()) {
        String listTok=llt.hasMoreTokens() ? llt.nextToken() : null;
        String widthTok=wlt.hasMoreTokens() ? wlt.nextToken() : null;
        if (listTok == null || !listTok.trim().equals(""String_Node_Str"")) {
          if (listTok != null) {
            if (newLLine.length() > 0)             newLLine.append(""String_Node_Str"");
            newLLine.append(listTok);
          }
          if (widthTok != null) {
            if (newWLine.length() > 0)             newWLine.append(""String_Node_Str"");
            newWLine.append(widthTok);
          }
        }
      }
      configLine=newLLine.toString();
      widthLine=newWLine.toString();
    }
    listFields=configLine;
    listWidths=widthLine;
  }
  String dateLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateLine != null) {
    dateField=dateLine;
  }
  String titleLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleLine != null) {
    titleField=titleLine;
  }
  String authorLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (authorLine != null) {
    authorField=authorLine;
  }
  String[] fieldArr=listFields.split(""String_Node_Str"");
  String[] widthArr=listWidths == null ? new String[0] : listWidths.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
 else       if ((field.equals(dateField) && emphasiseDate) || (field.equals(titleField) && emphasiseTitle)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i % 2) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
        if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit > 0 ? authorLimit : metadataArray.length);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument=""String_Node_Str"";
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].value);
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].language)+ ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"" + etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}","public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  String configLine=null;
  String widthLine=null;
  if (sortOption != null) {
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
    if (configLine == null) {
      configLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
      widthLine=ConfigurationManager.getProperty(""String_Node_Str"" + sortOption.getName() + ""String_Node_Str"");
    }
  }
  if (configLine == null) {
    configLine=ConfigurationManager.getProperty(""String_Node_Str"");
    widthLine=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (configLine != null) {
    if (!showThumbs && configLine.contains(""String_Node_Str"")) {
      configLine=configLine == null ? ""String_Node_Str"" : configLine;
      widthLine=widthLine == null ? ""String_Node_Str"" : widthLine;
      StringTokenizer llt=new StringTokenizer(configLine,""String_Node_Str"");
      StringTokenizer wlt=new StringTokenizer(widthLine,""String_Node_Str"");
      StringBuilder newLLine=new StringBuilder();
      StringBuilder newWLine=new StringBuilder();
      while (llt.hasMoreTokens() || wlt.hasMoreTokens()) {
        String listTok=llt.hasMoreTokens() ? llt.nextToken() : null;
        String widthTok=wlt.hasMoreTokens() ? wlt.nextToken() : null;
        if (listTok == null || !listTok.trim().equals(""String_Node_Str"")) {
          if (listTok != null) {
            if (newLLine.length() > 0)             newLLine.append(""String_Node_Str"");
            newLLine.append(listTok);
          }
          if (widthTok != null) {
            if (newWLine.length() > 0)             newWLine.append(""String_Node_Str"");
            newWLine.append(widthTok);
          }
        }
      }
      configLine=newLLine.toString();
      widthLine=newWLine.toString();
    }
    listFields=configLine;
    listWidths=widthLine;
  }
  String dateLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (dateLine != null) {
    dateField=dateLine;
  }
  String titleLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (titleLine != null) {
    titleField=titleLine;
  }
  String authorLine=ConfigurationManager.getProperty(""String_Node_Str"");
  if (authorLine != null) {
    authorField=authorLine;
  }
  String[] fieldArr=listFields.split(""String_Node_Str"");
  String[] widthArr=listWidths == null ? new String[0] : listWidths.split(""String_Node_Str"");
  boolean isDate[]=new boolean[fieldArr.length];
  boolean emph[]=new boolean[fieldArr.length];
  boolean isAuthor[]=new boolean[fieldArr.length];
  boolean viewFull[]=new boolean[fieldArr.length];
  String[] browseType=new String[fieldArr.length];
  String[] cOddOrEven=new String[fieldArr.length];
  try {
    CrossLinks cl=new CrossLinks();
    String tablewidth=ConfigurationManager.getProperty(""String_Node_Str"");
    if (widthArr.length > 0 && widthArr.length == fieldArr.length && !linkToEdit) {
      if (!StringUtils.isEmpty(tablewidth)) {
        out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      for (int w=0; w < widthArr.length; w++) {
        out.print(""String_Node_Str"");
        if (fieldArr[w].equals(""String_Node_Str"") && widthArr[w].equals(""String_Node_Str"")) {
          out.print(thumbItemListMaxWidth);
        }
 else {
          out.print(StringUtils.isEmpty(widthArr[w]) ? ""String_Node_Str"" : widthArr[w]);
        }
        out.print(""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
 else     if (!StringUtils.isEmpty(tablewidth)) {
      out.println(""String_Node_Str"" + tablewidth + ""String_Node_Str"");
    }
 else {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
      String field=fieldArr[colIdx].toLowerCase().trim();
      cOddOrEven[colIdx]=(((colIdx + 1) % 2) == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
      if (field.indexOf(""String_Node_Str"") > 0) {
        field=field.replaceAll(""String_Node_Str"",""String_Node_Str"");
        isDate[colIdx]=true;
      }
      fieldArr[colIdx]=field;
      if (field.equals(authorField)) {
        isAuthor[colIdx]=true;
      }
      if (cl.hasLink(field)) {
        browseType[colIdx]=cl.getLinkType(field);
        viewFull[colIdx]=BrowseIndex.getBrowseIndex(browseType[colIdx]).isItemIndex();
      }
      if (field.equals(emphColumn)) {
        emph[colIdx]=true;
      }
 else       if ((field.equals(dateField) && emphasiseDate) || (field.equals(titleField) && emphasiseTitle)) {
        emph[colIdx]=true;
      }
      String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
      String css=""String_Node_Str"" + cOddOrEven[colIdx] + ""String_Node_Str"";
      String message=""String_Node_Str"" + field;
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ LocaleSupport.getLocalizedMessage(pageContext,message)+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    if (linkToEdit) {
      String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
      String css=""String_Node_Str"" + cOddOrEven[cOddOrEven.length - 2] + ""String_Node_Str"";
      out.print(""String_Node_Str"" + id + ""String_Node_Str""+ css+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ (emph[emph.length - 2] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    out.print(""String_Node_Str"");
    for (int i=0; i < items.length; i++) {
      String rOddOrEven;
      if (i == highlightRow) {
        rOddOrEven=""String_Node_Str"";
      }
 else {
        rOddOrEven=((i % 2) == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      for (int colIdx=0; colIdx < fieldArr.length; colIdx++) {
        String field=fieldArr[colIdx];
        StringTokenizer eq=new StringTokenizer(field,""String_Node_Str"");
        String[] tokens={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        int k=0;
        while (eq.hasMoreTokens()) {
          tokens[k]=eq.nextToken().toLowerCase().trim();
          k++;
        }
        String schema=tokens[0];
        String element=tokens[1];
        String qualifier=tokens[2];
        DCValue[] metadataArray;
        if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,Item.ANY,Item.ANY);
        }
 else         if (qualifier.equals(""String_Node_Str"")) {
          metadataArray=items[i].getMetadata(schema,element,null,Item.ANY);
        }
 else {
          metadataArray=items[i].getMetadata(schema,element,qualifier,Item.ANY);
        }
        if (metadataArray == null) {
          metadataArray=new DCValue[0];
        }
        String metadata=""String_Node_Str"";
        if (field.equals(""String_Node_Str"")) {
          metadata=getThumbMarkup(hrq,items[i]);
        }
        if (metadataArray.length > 0) {
          if (isDate[colIdx]) {
            DCDate dd=new DCDate(metadataArray[0].value);
            metadata=UIUtil.displayDate(dd,false,false,hrq);
          }
 else           if (field.equals(titleField) && items[i].isWithdrawn()) {
            metadata=Utils.addEntities(metadataArray[0].value);
          }
 else           if (field.equals(titleField)) {
            metadata=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ Utils.addEntities(metadataArray[0].value)+ ""String_Node_Str"";
          }
 else {
            boolean truncated=false;
            int loopLimit=metadataArray.length;
            if (isAuthor[colIdx]) {
              int fieldMax=(authorLimit > 0 ? authorLimit : metadataArray.length);
              loopLimit=(fieldMax > metadataArray.length ? metadataArray.length : fieldMax);
              truncated=(fieldMax < metadataArray.length);
              log.debug(""String_Node_Str"" + field + ""String_Node_Str""+ Integer.toString(loopLimit)+ ""String_Node_Str""+ Integer.toString(metadataArray.length));
            }
            StringBuffer sb=new StringBuffer();
            for (int j=0; j < loopLimit; j++) {
              String startLink=""String_Node_Str"";
              String endLink=""String_Node_Str"";
              if (!StringUtils.isEmpty(browseType[colIdx]) && !disableCrossLinks) {
                String argument=""String_Node_Str"";
                if (viewFull[colIdx]) {
                  argument=""String_Node_Str"";
                }
                startLink=""String_Node_Str"" + hrq.getContextPath() + ""String_Node_Str""+ browseType[colIdx]+ ""String_Node_Str""+ argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].value);
                if (metadataArray[j].language != null) {
                  startLink=startLink + ""String_Node_Str"" + argument+ ""String_Node_Str""+ Utils.addEntities(metadataArray[j].language)+ ""String_Node_Str"";
                }
 else {
                  startLink=startLink + ""String_Node_Str"";
                }
                endLink=""String_Node_Str"";
              }
              sb.append(startLink);
              sb.append(Utils.addEntities(metadataArray[j].value));
              sb.append(endLink);
              if (j < (loopLimit - 1)) {
                sb.append(""String_Node_Str"");
              }
            }
            if (truncated) {
              String etal=LocaleSupport.getLocalizedMessage(pageContext,""String_Node_Str"");
              sb.append(""String_Node_Str"" + etal);
            }
            metadata=""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
          }
        }
        String extras=""String_Node_Str"";
        if (isDate[colIdx]) {
          extras=""String_Node_Str"";
        }
        String id=""String_Node_Str"" + Integer.toString(colIdx + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[colIdx]+ ""String_Node_Str""+ extras+ ""String_Node_Str""+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ metadata+ (emph[colIdx] ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
      }
      if (linkToEdit) {
        String id=""String_Node_Str"" + Integer.toString(cOddOrEven.length + 1);
        out.print(""String_Node_Str"" + id + ""String_Node_Str""+ rOddOrEven+ ""String_Node_Str""+ cOddOrEven[cOddOrEven.length - 2]+ ""String_Node_Str""+ ""String_Node_Str""+ hrq.getContextPath()+ ""String_Node_Str""+ ""String_Node_Str""+ items[i].getHandle()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
catch (  BrowseException e) {
    throw new JspException(e);
  }
  return SKIP_BODY;
}",0.9998237419582268
3425,"/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]);
  }
  Item item=(Item)dso;
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + dso.getID());
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}","/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]);
  }
  Item item=(Item)dso;
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + dso.getID());
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}",0.9900783289817232
3426,"/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    String h=dso.getHandle();
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]+ ""String_Node_Str""+ (h == null ? ""String_Node_Str"" : h));
  }
  Item item=(Item)dso;
  String handle=item.getHandle();
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + (handle == null ? String.valueOf(dso.getID()) : handle) + ""String_Node_Str""+ originalKey);
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}","/** 
 * Return &lt;meta&gt; elements that can be put in the &lt;head&gt; element of an XHTML document.
 */
public List disseminateList(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
  if (dso.getType() != Constants.ITEM) {
    String h=dso.getHandle();
    throw new CrosswalkObjectNotSupported(""String_Node_Str"" + dso.getID() + ""String_Node_Str""+ Constants.typeText[dso.getType()]+ ""String_Node_Str""+ (h == null ? ""String_Node_Str"" : h));
  }
  Item item=(Item)dso;
  String handle=item.getHandle();
  List<Element> metas=new ArrayList<Element>();
  DCValue[] values=item.getMetadata(Item.ANY,Item.ANY,Item.ANY,Item.ANY);
  Iterator<String> schemaIterator=schemaURLs.keySet().iterator();
  while (schemaIterator.hasNext()) {
    String s=schemaIterator.next();
    Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
    e.setAttribute(""String_Node_Str"",s);
    e.setAttribute(""String_Node_Str"",schemaURLs.get(s));
    metas.add(e);
  }
  for (int i=0; i < values.length; i++) {
    DCValue v=values[i];
    String key=v.schema + ""String_Node_Str"" + v.element+ (v.qualifier != null ? ""String_Node_Str"" + v.qualifier : ""String_Node_Str"");
    String originalKey=key;
    String name=names.get(key);
    if (name == null && v.qualifier != null) {
      key=v.schema + ""String_Node_Str"" + v.element;
      name=names.get(key);
    }
    if (name == null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + (handle == null ? String.valueOf(dso.getID()) : handle) + ""String_Node_Str""+ originalKey);
      }
    }
 else {
      Element e=new Element(""String_Node_Str"",XHTML_NAMESPACE);
      e.setAttribute(""String_Node_Str"",name);
      e.setAttribute(""String_Node_Str"",v.value == null ? ""String_Node_Str"" : v.value);
      if (v.language != null && !v.language.equals(""String_Node_Str"")) {
        e.setAttribute(""String_Node_Str"",v.language,Namespace.XML_NAMESPACE);
      }
      String schemeAttr=schemes.get(key);
      if (schemeAttr != null) {
        e.setAttribute(""String_Node_Str"",schemeAttr);
      }
      metas.add(e);
    }
  }
  return metas;
}",0.9910037878787878
3427,"/** 
 * figures out if the date is valid for the policy
 * @return true if policy has begun and hasn't expired yet (or no dates areset)
 */
public boolean isDateValid(){
  Date sd=getStartDate();
  Date ed=getEndDate();
  if ((sd == null) && (ed == null)) {
    return true;
  }
  Date now=new Date();
  if (sd != null) {
    if (now.before(sd)) {
      return false;
    }
  }
  if (ed != null) {
    if (now.after(sd)) {
      return false;
    }
  }
  return true;
}","/** 
 * figures out if the date is valid for the policy
 * @return true if policy has begun and hasn't expired yet (or no dates areset)
 */
public boolean isDateValid(){
  Date sd=getStartDate();
  Date ed=getEndDate();
  if ((sd == null) && (ed == null)) {
    return true;
  }
  Date now=new Date();
  if (sd != null) {
    if (now.before(sd)) {
      return false;
    }
  }
  if (ed != null) {
    if (now.after(ed)) {
      return false;
    }
  }
  return true;
}",0.8869936034115139
3428,"/** 
 * figures out if the date is valid for the policy
 * @return true if policy has begun and hasn't expired yet (or no dates areset)
 */
public boolean isDateValid(){
  Date sd=getStartDate();
  Date ed=getEndDate();
  if ((sd == null) && (ed == null)) {
    return true;
  }
  Date now=new Date();
  if (sd != null) {
    if (now.before(sd)) {
      return false;
    }
  }
  if (ed != null) {
    if (now.after(sd)) {
      return false;
    }
  }
  return true;
}","/** 
 * figures out if the date is valid for the policy
 * @return true if policy has begun and hasn't expired yet (or no dates areset)
 */
public boolean isDateValid(){
  Date sd=getStartDate();
  Date ed=getEndDate();
  if ((sd == null) && (ed == null)) {
    return true;
  }
  Date now=new Date();
  if (sd != null) {
    if (now.before(sd)) {
      return false;
    }
  }
  if (ed != null) {
    if (now.after(ed)) {
      return false;
    }
  }
  return true;
}",0.8869936034115139
3429,"/** 
 */
public static Properties getProperties(){
  return (Properties)properties.clone();
}","/** 
 */
public static Properties getProperties(){
  if (properties == null) {
    loadConfig(null);
  }
  return (Properties)properties.clone();
}",0.775
3430,"public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Division feedback=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  feedback.setHead(T_head);
  feedback.addPara(T_para1);
  List form=feedback.addList(""String_Node_Str"",List.TYPE_FORM);
  Text email=form.addItem().addText(""String_Node_Str"");
  email.setLabel(T_email);
  email.setHelp(T_email_help);
  email.setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
  TextArea comments=form.addItem().addTextArea(""String_Node_Str"");
  comments.setLabel(T_comments);
  comments.setSize(5,60);
  comments.setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
  form.addItem().addButton(""String_Node_Str"").setValue(T_submit);
  feedback.addHidden(""String_Node_Str"").setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
}","public void addBody(Body body) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  Division feedback=body.addInteractiveDivision(""String_Node_Str"",contextPath + ""String_Node_Str"",Division.METHOD_POST,""String_Node_Str"");
  feedback.setHead(T_head);
  feedback.addPara(T_para1);
  List form=feedback.addList(""String_Node_Str"",List.TYPE_FORM);
  Text email=form.addItem().addText(""String_Node_Str"");
  email.setLabel(T_email);
  email.setHelp(T_email_help);
  email.setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
  TextArea comments=form.addItem().addTextArea(""String_Node_Str"");
  comments.setLabel(T_comments);
  comments.setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
  form.addItem().addButton(""String_Node_Str"").setValue(T_submit);
  feedback.addHidden(""String_Node_Str"").setValue(parameters.getParameter(""String_Node_Str"",""String_Node_Str""));
}",0.9864158829676072
3431,"/** 
 * Set the database id of the container object.  This should be the id of a  Community or Collection.  This will constrain the results of the browse to only items or values within items that appear in the given container.
 * @param containerID
 */
public void setContainerID(int containerID);","/** 
 * Set the database id of the container object.  This should be the id of a Community or Collection.  This will constrain the results of the browse to only items or values within items that appear in the given container.
 * @param containerID
 */
public void setContainerID(int containerID);",0.9983136593591906
3432,"/** 
 * get the integer number which is the limit of the results that will be returned by any query.  The default is -1, which means unlimited results.
 * @return	the maximum possible number of results allowed to be returned
 */
public int getLimit();","/** 
 * get the integer number which is the limit of the results that will be returned by any query.  The default is -1, which means unlimited results.
 * @return  the maximum possible number of results allowed to be returned
 */
public int getLimit();",0.9940357852882704
3433,"/** 
 * Get the offset from the first result from which to return results.  This  functionality is present for backwards compatibility, but is ill advised.  All normal browse operations can be completed without it.  The default is -1, which means do not offset.
 * @return		the offset
 */
public int getOffset();","/** 
 * Get the offset from the first result from which to return results.  This functionality is present for backwards compatibility, but is ill advised.  All normal browse operations can be completed without it.  The default is -1, which means do not offset.
 * @return      the offset
 */
public int getOffset();",0.985645933014354
3434,"/** 
 * get the name of the field in which to look for the container id.  This is principally for use internal to the DAO.
 * @return	the name of the container id field.  For example ""collection_id"" or""community_id""
 */
public String getContainerIDField();","/** 
 * get the name of the field in which to look for the container id.  This is principally for use internal to the DAO.
 * @return  the name of the container id field.  For example ""collection_id"" or""community_id""
 */
public String getContainerIDField();",0.9941520467836256
3435,"/** 
 * Set the focus field upon which we will match a value from which to start the browse.  This will either be the ""sort_value"" field or one of the additional sort fields defined by configuration param focusField		the name of the focus field
 */
public void setJumpToField(String focusField);","/** 
 * Set the focus field upon which we will match a value from which to start the browse.  This will either be the ""sort_value"" field or one of the additional sort fields defined by configuration param focusField     the name of the focus field
 */
public void setJumpToField(String focusField);",0.988195615514334
3436,"/** 
 * This executes a query which will count the number of results for the parameters you set.
 * @return		the integer value of the number of results found
 * @throws BrowseException
 */
public int doCountQuery() throws BrowseException ;","/** 
 * This executes a query which will count the number of results for the parameters you set.
 * @return      the integer value of the number of results found
 * @throws BrowseException
 */
public int doCountQuery() throws BrowseException ;",0.983402489626556
3437,"/** 
 * Get the database ID of the container object.  The container object will be a Community or a Collection.
 * @return	the database id of the container, or -1 if none is set
 */
public int getContainerID();","/** 
 * Get the database ID of the container object.  The container object will be a Community or a Collection.
 * @return  the database id of the container, or -1 if none is set
 */
public int getContainerID();",0.992874109263658
3438,"/** 
 * Set whether the query should use an equals comparator when doing less than or  greater than comparisons.  That is, if true then comparisons will be made  using the equivalent of ""<="" and "">="", while if false it will use the  equivalent of ""<"" and "">""
 * @param equalsComparator	true to use, false to not.
 */
public void setEqualsComparator(boolean equalsComparator);","/** 
 * Set whether the query should use an equals comparator when doing less than or greater than comparisons.  That is, if true then comparisons will be made using the equivalent of ""<="" and "">="", while if false it will use the equivalent of ""<"" and "">""
 * @param equalsComparator  true to use, false to not.
 */
public void setEqualsComparator(boolean equalsComparator);",0.9919786096256684
3439,"/** 
 * Get the array of values that we will be selecting on.  The default is to select all of the values from a given table
 * @return	an array of values to select on
 */
public String[] getSelectValues();","/** 
 * Get the array of values that we will be selecting on.  The default is to select all of the values from a given table
 * @return  an array of values to select on
 */
public String[] getSelectValues();",0.9927360774818402
3440,"/** 
 * Get the offset from the first result from which to return results.  This  functionality is present for backwards compatibility, but is ill advised.  All normal browse operations can be completed without it.  The default is -1, which means do not offset.
 * @param offset
 */
public void setOffset(int offset);","/** 
 * Get the offset from the first result from which to return results.  This functionality is present for backwards compatibility, but is ill advised.  All normal browse operations can be completed without it.  The default is -1, which means do not offset.
 * @param offset
 */
public void setOffset(int offset);",0.9984202211690364
3441,"/** 
 * Set the database field which will be used to sort result sets on
 * @param orderField	the field by which results will be sorted
 */
public void setOrderField(String orderField);","/** 
 * Set the database field which will be used to sort result sets on
 * @param orderField    the field by which results will be sorted
 */
public void setOrderField(String orderField);",0.9865951742627346
3442,"/** 
 * Does the query use the equals comparator when doing less than or greater than comparisons.  @see setEqualsComparator Default value is true
 * @return	true if using it, false if not
 */
public boolean useEqualsComparator();","/** 
 * Does the query use the equals comparator when doing less than or greater than comparisons.  @see setEqualsComparator Default value is true
 * @return  true if using it, false if not
 */
public boolean useEqualsComparator();",0.9934924078091106
3443,"/** 
 * Get the name of the field in which the value to constrain results is contained
 * @return	the name of the field
 */
public String getFilterValueField();","/** 
 * Get the name of the field in which the value to constrain results is contained
 * @return  the name of the field
 */
public String getFilterValueField();",0.9906542056074766
3444,"/** 
 * Get the array of fields that we will be counting on.
 * @return	an array of fields to be counted over
 */
public String[] getCountValues();","/** 
 * Get the array of fields that we will be counting on.
 * @return  an array of fields to be counted over
 */
public String[] getCountValues();",0.9898305084745764
3445,"/** 
 * Get the value which we are constraining all our browse results to contain.
 * @return	the value to which to constrain results
 */
public String getFilterValue();","/** 
 * Get the value which we are constraining all our browse results to contain.
 * @return  the value to which to constrain results
 */
public String getFilterValue();",0.991150442477876
3446,"/** 
 * Set the value upon which to start the browse from.  The value supplied here will be the top result on the page of results
 * @param focusValue	the value in the focus field on which to start browsing
 */
public void setJumpToValue(String focusValue);","/** 
 * Set the value upon which to start the browse from.  The value supplied here will be the top result on the page of results
 * @param focusValue    the value in the focus field on which to start browsing
 */
public void setJumpToValue(String focusValue);",0.9903288201160542
3447,"/** 
 * Set whether the results should be sorted in ascending order (on the given sort column) or descending order.
 * @param ascending		true to ascend, false to descend
 */
public void setAscending(boolean ascending);","/** 
 * Set whether the results should be sorted in ascending order (on the given sort column) or descending order.
 * @param ascending     true to ascend, false to descend
 */
public void setAscending(boolean ascending);",0.9840546697038725
3448,"/** 
 * Set he name of the field in which the value to constrain results is  contained
 * @param valueField 	the name of the field
 */
public void setFilterValueField(String valueField);","/** 
 * Set he name of the field in which the value to constrain results is contained
 * @param valueField    the name of the field
 */
public void setFilterValueField(String valueField);",0.9865951742627346
3449,"/** 
 * Set the array of columns that we will be counting over.  In general, the wildcard (*) will suffice
 * @param fields	an array of fields to be counted over
 */
public void setCountValues(String[] fields);","/** 
 * Set the array of columns that we will be counting over.  In general, the wildcard (*) will suffice
 * @param fields    an array of fields to be counted over
 */
public void setCountValues(String[] fields);",0.9881796690307328
3450,"/** 
 * If we have specified a container id and container field, we must also specify a container table.  This is the name of the table that maps the item onto the distinct value.  Since we are in a container, this value will actually be the view which allows us to select only items which are within a given container
 * @param containerTable	the name of the container table mapping
 */
public void setContainerTable(String containerTable);","/** 
 * If we have specified a container id and container field, we must also specify a container table.  This is the name of the table that maps the item onto the distinct value.  Since we are in a container, this value will actually be the view which allows us to select only items which are within a given container
 * @param containerTable    the name of the container table mapping
 */
public void setContainerTable(String containerTable);",0.9943502824858758
3451,"/** 
 * This executes a query which returns a List object containing String values which represent the results of a single value browse (for example, the list of all subject headings).  This is most commonly used with a Distinct browse type.
 * @return	List of Strings representing the single value query results
 * @throws BrowseException
 */
public List doValueQuery() throws BrowseException ;","/** 
 * This executes a query which returns a List object containing String values which represent the results of a single value browse (for example, the list of all subject headings).  This is most commonly used with a Distinct browse type.
 * @return  List of Strings representing the single value query results
 * @throws BrowseException
 */
public List doValueQuery() throws BrowseException ;",0.9962073324905184
3452,"/** 
 * Is this a distinct value browse?
 * @return	true if distinct, false if not
 */
public boolean isDistinct();","/** 
 * Is this a distinct value browse?
 * @return  true if distinct, false if not
 */
public boolean isDistinct();",0.987012987012987
3453,"/** 
 * This executes a query which returns the value of the ""highest"" (max) value in the given table's column for the given item id.
 * @param column	the column to interrogate
 * @param table		the table to query
 * @param itemID	the item id
 * @return			String representing the max value in the given column
 * @throws BrowseException
 */
public String doMaxQuery(String column,String table,int itemID) throws BrowseException ;","/** 
 * This executes a query which returns the value of the ""highest"" (max) value in the given table's column for the given item id.
 * @param column    the column to interrogate
 * @param table     the table to query
 * @param itemID    the item id
 * @return          String representing the max value in the given column
 * @throws BrowseException
 */
public String doMaxQuery(String column,String table,int itemID) throws BrowseException ;",0.9655963302752294
3454,"/** 
 * Get the value at which the browse will start.  The value supplied here will be the top result on the page of results.
 * @return		the value to start browsing on
 */
public String getJumpToValue();","/** 
 * Get the value at which the browse will start.  The value supplied here will be the top result on the page of results.
 * @return      the value to start browsing on
 */
public String getJumpToValue();",0.9805825242718448
3455,"/** 
 * Set the array of values to select on.  This should be a list of the columns available in the target table, or the SQL wildcards.  The default is  single element array with the standard wildcard (*)
 * @param selectValues	the values to select on
 */
public void setSelectValues(String[] selectValues);","/** 
 * Set the array of values to select on.  This should be a list of the columns available in the target table, or the SQL wildcards.  The default is single element array with the standard wildcard (*)
 * @param selectValues  the values to select on
 */
public void setSelectValues(String[] selectValues);",0.9935064935064936
3456,"/** 
 * Get the database field which will be used to do the sorting of result sets on.
 * @return		the field by which results will be sorted
 */
public String getOrderField();","/** 
 * Get the database field which will be used to do the sorting of result sets on.
 * @return      the field by which results will be sorted
 */
public String getOrderField();",0.9774011299435028
3457,"/** 
 * get the name of the table that we are querying
 * @return	the name of the table
 */
public String getTable();","/** 
 * get the name of the table that we are querying
 * @return  the name of the table
 */
public String getTable();",0.9872340425531916
3458,"/** 
 * Set the limit for how many results should be returned.  This is generally for use in paging or limiting the number of items be be displayed.  The default is -1, meaning unlimited results.  Note that if the number of results of the query is less than this number, the size of the result set will be smaller than this limit.
 * @param limit		the maximum number of results to return.
 */
public void setLimit(int limit);","/** 
 * Set the limit for how many results should be returned.  This is generally for use in paging or limiting the number of items be be displayed.  The default is -1, meaning unlimited results.  Note that if the number of results of the query is less than this number, the size of the result set will be smaller than this limit.
 * @param limit     the maximum number of results to return.
 */
public void setLimit(int limit);",0.9917936694021102
3459,"/** 
 * Set the name of the table to query
 * @param table		the name of the table
 */
public void setTable(String table);","/** 
 * Set the name of the table to query
 * @param table     the name of the table
 */
public void setTable(String table);",0.9714285714285714
3460,"/** 
 * Get the name of the container table that is being used to map items to distinct values when in a container constrained browse
 * @return	the name of the table
 */
public String getContainerTable();","/** 
 * Get the name of the container table that is being used to map items to distinct values when in a container constrained browse
 * @return  the name of the table
 */
public String getContainerTable();",0.9927007299270072
3461,"/** 
 * set the name of the field in which to look for the container id.
 * @param containerIDField	the name of the container id field.  For example ""collection_id"" or ""community_id""
 */
public void setContainerIDField(String containerIDField);","/** 
 * set the name of the field in which to look for the container id.
 * @param containerIDField  the name of the container id field.For example ""collection_id"" or ""community_id""
 */
public void setContainerIDField(String containerIDField);",0.9897330595482546
3462,"/** 
 * Set whether this is a distinct value browse or not
 * @param bool	true if distinct value, false if not
 */
public void setDistinct(boolean bool);","/** 
 * Set whether this is a distinct value browse or not
 * @param bool  true if distinct value, false if not
 */
public void setDistinct(boolean bool);",0.990228013029316
3463,"/** 
 * Get the field in which we will match a focus value from which to start the browse.  This will either be the ""sort_value"" field or one of the additional sort fields defined by configuration
 * @return	the name of the focus field
 */
public String getJumpToField();","/** 
 * Get the field in which we will match a focus value from which to start the browse.  This will either be the ""sort_value"" field or one of the additional sort fields defined by configuration
 * @return  the name of the focus field
 */
public String getJumpToField();",0.994475138121547
3464,"/** 
 * Is the sort order ascending or descending? Default value is true
 * @return	true for ascending, false for descending
 */
public boolean isAscending();","/** 
 * Is the sort order ascending or descending? Default value is true
 * @return  true for ascending, false for descending
 */
public boolean isAscending();",0.9905362776025236
3465,"/** 
 * Set the value to which all our browse results should be constrained.  For example, if you are listing all of the publications by a single author your value would be the author name.
 * @param value	the value to which to constrain results
 */
public void setFilterValue(String value);","/** 
 * Set the value to which all our browse results should be constrained.  For example, if you are listing all of the publications by a single author your value would be the author name.
 * @param value the value to which to constrain results
 */
public void setFilterValue(String value);",0.9965635738831616
3466,"/** 
 * assemble a WHERE clause with the given constraints.  This will return something of the form: <code> WHERE [focus clause] [AND] [value clause] [AND] [container constraint] </code> The container constraint is described in one of either getFullConstraint or  getDistinctConstraint, and the form of that section of the query can be found in their documentation. If either of focusClause or valueClause is null, they will be duly omitted from the WHERE clause.
 */
private void buildWhereClauseDistinctConstraints(StringBuffer queryBuf,List params){
  if (containerIDField != null && containerID != -1 && containerTable != null) {
    buildWhereClauseOpInsert(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectTables(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectClauses(queryBuf,params);
    queryBuf.append(""String_Node_Str"" + table + ""String_Node_Str"");
  }
}","/** 
 * assemble a WHERE clause with the given constraints.  This will return something of the form: <code> WHERE [focus clause] [AND] [value clause] [AND] [container constraint] </code> The container constraint is described in one of either getFullConstraint or getDistinctConstraint, and the form of that section of the query can be found in their documentation. If either of focusClause or valueClause is null, they will be duly omitted from the WHERE clause.
 */
private void buildWhereClauseDistinctConstraints(StringBuffer queryBuf,List params){
  if (containerIDField != null && containerID != -1 && containerTable != null) {
    buildWhereClauseOpInsert(queryBuf);
    queryBuf.append(""String_Node_Str"").append(table).append(""String_Node_Str"");
  }
}",0.8918111177525403
3467,"/** 
 * assemble a WHERE clause with the given constraints.  This will return something of the form: <code> WHERE [focus clause] [AND] [value clause] [AND] [container constraint] </code> The container constraint is described in one of either getFullConstraint or  getDistinctConstraint, and the form of that section of the query can be found in their documentation. If either of focusClause or valueClause is null, they will be duly omitted from the WHERE clause.
 */
private void buildWhereClauseFullConstraints(StringBuffer queryBuf,List params){
  if (tableDis == null || tableMap == null) {
    if (containerIDField != null && containerID != -1) {
      buildWhereClauseOpInsert(queryBuf);
      queryBuf.append(""String_Node_Str"").append(table).append(""String_Node_Str"");
    }
  }
}","/** 
 * assemble a WHERE clause with the given constraints.  This will return something of the form: <code> WHERE [focus clause] [AND] [value clause] [AND] [container constraint] </code> The container constraint is described in one of either getFullConstraint or getDistinctConstraint, and the form of that section of the query can be found in their documentation. If either of focusClause or valueClause is null, they will be duly omitted from the WHERE clause.
 */
private void buildWhereClauseFullConstraints(StringBuffer queryBuf,List params){
  if (tableDis == null || tableMap == null) {
    if (containerIDField != null && containerID != -1) {
      buildWhereClauseOpInsert(queryBuf);
      queryBuf.append(""String_Node_Str"").append(table).append(""String_Node_Str"");
    }
  }
}",0.9993642720915448
3468,"/** 
 * Prepare the select clause using the pre-prepared arguments.  This will produce something of the form: <code> SELECT [arguments] FROM [table] </code>
 * @param queryBuf  the string value obtained from distinctClause, countClause or selectValues
 * @return  the SELECT part of the query
 */
private void buildSelectStatementDistinct(StringBuffer queryBuf,List params) throws BrowseException {
  if (queryBuf.length() == 0) {
    throw new BrowseException(""String_Node_Str"");
  }
  if (table == null || ""String_Node_Str"".equals(table)) {
    throw new BrowseException(""String_Node_Str"");
  }
  queryBuf.insert(0,""String_Node_Str"");
  queryBuf.append(""String_Node_Str"");
  queryBuf.append(table);
  queryBuf.append(""String_Node_Str"");
}","/** 
 * Prepare the select clause using the pre-prepared arguments.  This will produce something of the form: <code> SELECT [arguments] FROM [table] </code>
 * @param queryBuf  the string value obtained from distinctClause, countClause or selectValues
 * @return  the SELECT part of the query
 */
private void buildSelectStatementDistinct(StringBuffer queryBuf,List params) throws BrowseException {
  if (queryBuf.length() == 0) {
    throw new BrowseException(""String_Node_Str"");
  }
  if (table == null || ""String_Node_Str"".equals(table)) {
    throw new BrowseException(""String_Node_Str"");
  }
  queryBuf.insert(0,""String_Node_Str"");
  queryBuf.append(""String_Node_Str"");
  queryBuf.append(table);
  if (containerTable != null && tableMap != null) {
    queryBuf.append(""String_Node_Str"").append(tableMap).append(""String_Node_Str"");
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectTables(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectClauses(queryBuf,params);
    queryBuf.append(""String_Node_Str"");
  }
  queryBuf.append(""String_Node_Str"");
}",0.8078817733990148
3469,"/** 
 * Build the query that will be used for a full browse.
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatement(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseFilterValue(queryBuf,params);
  buildWhereClauseFullConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimit(queryBuf,params);
  buildRowOffset(queryBuf,params);
  return queryBuf.toString();
}","/** 
 * Build the query that will be used for a full browse.
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatement(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseFilterValue(queryBuf,params);
  buildWhereClauseFullConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimitAndOffset(queryBuf,params);
  return queryBuf.toString();
}",0.969187675070028
3470,"/** 
 * Build the query that will be used for a distinct select.  This incorporates only the parts of the parameters that are actually useful for this type of browse
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildDistinctQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatementDistinct(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseDistinctConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimit(queryBuf,params);
  return queryBuf.toString();
}","/** 
 * Build the query that will be used for a distinct select.  This incorporates only the parts of the parameters that are actually useful for this type of browse
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildDistinctQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatementDistinct(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseDistinctConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimitAndOffset(queryBuf,params);
  return queryBuf.toString();
}",0.9941822882999354
3471,"/** 
 * Build the query that will be used for a full browse.
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatement(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseFilterValue(queryBuf,params);
  buildWhereClauseFullConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimit(queryBuf,params);
  buildRowOffset(queryBuf,params);
  return queryBuf.toString();
}","/** 
 * Build the query that will be used for a full browse.
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatement(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseFilterValue(queryBuf,params);
  buildWhereClauseFullConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimitAndOffset(queryBuf,params);
  return queryBuf.toString();
}",0.969187675070028
3472,"/** 
 * Required constructor for use by BrowseDAOFactory 
 * @param context   DSpace context
 */
public BrowseDAOPostgres(Context context) throws BrowseException {
  this.context=context;
  utils=BrowseDAOFactory.getUtils(context);
}","/** 
 * Required constructor for use by BrowseDAOFactory
 * @param context   DSpace context
 */
public BrowseDAOPostgres(Context context) throws BrowseException {
  this.context=context;
  utils=BrowseDAOFactory.getUtils(context);
}",0.9978494623655914
3473,"/** 
 * Build the query that will be used for a distinct select.  This incorporates only the parts of the parameters that are actually useful for this type of browse
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildDistinctQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatementDistinct(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseDistinctConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimit(queryBuf,params);
  return queryBuf.toString();
}","/** 
 * Build the query that will be used for a distinct select.  This incorporates only the parts of the parameters that are actually useful for this type of browse
 * @return      the query to be executed
 * @throws BrowseException
 */
private String buildDistinctQuery(List params) throws BrowseException {
  StringBuffer queryBuf=new StringBuffer();
  if (!buildSelectListCount(queryBuf)) {
    if (!buildSelectListValues(queryBuf)) {
      throw new BrowseException(""String_Node_Str"");
    }
  }
  buildSelectStatementDistinct(queryBuf,params);
  buildWhereClauseOpReset();
  buildWhereClauseJumpTo(queryBuf,params);
  buildWhereClauseDistinctConstraints(queryBuf,params);
  buildOrderBy(queryBuf);
  buildRowLimitAndOffset(queryBuf,params);
  return queryBuf.toString();
}",0.9941822882999354
3474,"/** 
 * Return a normalized focus value. If there is no normalization that can be performed, return the focus value that is passed in.
 * @param value a focus value to normalize
 * @return  the normalized focus value
 * @throws BrowseException
 */
private String normalizeJumpToValue(String value) throws BrowseException {
  if (scope.hasJumpToValue()) {
    return OrderFormat.makeSortString(scope.getJumpToValue(),scope.setJumpToValueLang(),scope.getBrowseIndex().getDataType());
  }
 else   if (scope.hasStartsWith()) {
    return OrderFormat.makeSortString(scope.getStartsWith(),null,scope.getBrowseIndex().getDataType());
  }
  return value;
}","/** 
 * Return a normalized focus value. If there is no normalization that can be performed, return the focus value that is passed in.
 * @param value a focus value to normalize
 * @return  the normalized focus value
 * @throws BrowseException
 */
private String normalizeJumpToValue(String value) throws BrowseException {
  if (scope.hasJumpToValue()) {
    return OrderFormat.makeSortString(scope.getJumpToValue(),scope.getJumpToValueLang(),scope.getBrowseIndex().getDataType());
  }
 else   if (scope.hasStartsWith()) {
    return OrderFormat.makeSortString(scope.getStartsWith(),null,scope.getBrowseIndex().getDataType());
  }
  return value;
}",0.9984567901234568
3475,"/** 
 * Get the database id of the item at the top of what will be the previous page of results.  This is so that a ""back"" button can be generated by the User Interface when paging through results.  The callback argument is there so that if the caller wishes the actual results from the previous page can also be returned (this is useful, for example, if you are on the very last page of results, and need some previous results to pad out the full number of results per page).  If the callback is null, then no results are kept
 * @param callback	A List object for holding BrowseItem objects indexed numerically in the correct order
 * @return			the database id of the top of the previous page
 * @throws SQLException
 * @throws BrowseException
 */
private int getPreviousPageID(List callback) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  boolean capture=false;
  if (callback != null) {
    capture=true;
  }
  boolean isAscending=dao.isAscending();
  dao.setAscending(!isAscending);
  boolean useEquals=dao.useEqualsComparator();
  dao.setEqualsComparator(false);
  int resultLimit=dao.getLimit();
  int limit=scope.getResultsPerPage();
  if (capture) {
    limit*=2;
  }
  dao.setLimit(limit);
  List results=dao.doQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setLimit(resultLimit);
  Iterator itr=results.iterator();
  int i=0;
  BrowseItem prev=null;
  while (itr.hasNext()) {
    BrowseItem browseItem=(BrowseItem)itr.next();
    prev=browseItem;
    if (capture && i < scope.getResultsPerPage()) {
      callback.add(0,browseItem);
      i++;
    }
  }
  if (prev != null) {
    return prev.getID();
  }
 else {
    return -1;
  }
}","/** 
 * Get the database id of the item at the top of what will be the previous page of results.  This is so that a ""back"" button can be generated by the User Interface when paging through results.  The callback argument is there so that if the caller wishes the actual results from the previous page can also be returned (this is useful, for example, if you are on the very last page of results, and need some previous results to pad out the full number of results per page).  If the callback is null, then no results are kept
 * @param callback  A List object for holding BrowseItem objects indexed numerically in the correct order
 * @return          the database id of the top of the previous page
 * @throws SQLException
 * @throws BrowseException
 */
private int getPreviousPageID(List callback) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  boolean capture=false;
  if (callback != null) {
    capture=true;
  }
  boolean isAscending=dao.isAscending();
  dao.setAscending(!isAscending);
  boolean useEquals=dao.useEqualsComparator();
  dao.setEqualsComparator(false);
  int resultLimit=dao.getLimit();
  int limit=scope.getResultsPerPage();
  if (capture) {
    limit*=2;
  }
  dao.setLimit(limit);
  List results=dao.doQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setLimit(resultLimit);
  Iterator itr=results.iterator();
  int i=0;
  BrowseItem prev=null;
  while (itr.hasNext()) {
    BrowseItem browseItem=(BrowseItem)itr.next();
    prev=browseItem;
    if (capture && i < scope.getResultsPerPage()) {
      callback.add(0,browseItem);
      i++;
    }
  }
  if (prev != null) {
    return prev.getID();
  }
 else {
    return -1;
  }
}",0.9954545454545456
3476,"/** 
 * Get the value (for single value browses) for the result that appears at the top of the previous page, for when the User Interface is performing result set paging. The callback argument allows for this method to populate the List with the results obtained from the query, which can be useful when, for example, reaching the final browse page and needing additional results to pad up to the number of results per page
 * @param callback		A List object for holding String objects indexed numerically in the correct order
 * @return				the value of the top of the previous page
 * @throws SQLException
 * @throws BrowseException
 */
private String getPreviousPageValue(List callback) throws SQLException, BrowseException {
  boolean capture=false;
  if (callback != null) {
    capture=true;
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + capture));
  boolean isAscending=dao.isAscending();
  dao.setAscending(!isAscending);
  boolean useEquals=dao.useEqualsComparator();
  dao.setEqualsComparator(false);
  int resultLimit=dao.getLimit();
  int limit=scope.getResultsPerPage();
  if (capture) {
    limit*=2;
  }
  dao.setLimit(limit);
  List results=dao.doValueQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setLimit(resultLimit);
  Iterator itr=results.iterator();
  int i=0;
  String prev=null;
  while (itr.hasNext()) {
    String value=(String)itr.next();
    prev=value;
    if (capture && i < scope.getResultsPerPage()) {
      callback.add(0,value);
      i++;
    }
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + prev));
  return prev;
}","/** 
 * Get the value (for single value browses) for the result that appears at the top of the previous page, for when the User Interface is performing result set paging. The callback argument allows for this method to populate the List with the results obtained from the query, which can be useful when, for example, reaching the final browse page and needing additional results to pad up to the number of results per page
 * @param callback      A List object for holding String objects indexed numerically in the correct order
 * @return              the value of the top of the previous page
 * @throws SQLException
 * @throws BrowseException
 */
private String getPreviousPageValue(List callback) throws SQLException, BrowseException {
  boolean capture=false;
  if (callback != null) {
    capture=true;
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + capture));
  boolean isAscending=dao.isAscending();
  dao.setAscending(!isAscending);
  boolean useEquals=dao.useEqualsComparator();
  dao.setEqualsComparator(false);
  int resultLimit=dao.getLimit();
  int limit=scope.getResultsPerPage();
  if (capture) {
    limit*=2;
  }
  dao.setLimit(limit);
  List results=dao.doValueQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setLimit(resultLimit);
  Iterator itr=results.iterator();
  int i=0;
  String prev=null;
  while (itr.hasNext()) {
    String value=(String)itr.next();
    prev=value;
    if (capture && i < scope.getResultsPerPage()) {
      callback.add(0,value);
      i++;
    }
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + prev));
  return prev;
}",0.9922109047333731
3477,"/** 
 * Get the position of the current start point of the browse in the field of total objects relevant to this browse.  This is integrally related to how results are presented in pages to the User Interface.  The argument tells us whether this is a distinct browse or not, as this has an impact on how results are calculated
 * @param distinct		is this a distinct browse
 * @return				the offset of the first result from the start of the set
 * @throws SQLException
 * @throws BrowseException
 */
private int getPosition(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  if (dao.getJumpToValue() == null) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    return 0;
  }
  String tableName=browseIndex.getTableName(distinct,scope.inCommunity(),scope.inCollection());
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  boolean isAscending=dao.isAscending();
  boolean useEquals=dao.useEqualsComparator();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setAscending(!isAscending);
  dao.setEqualsComparator(false);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}","/** 
 * Get the position of the current start point of the browse in the field of total objects relevant to this browse.  This is integrally related to how results are presented in pages to the User Interface.  The argument tells us whether this is a distinct browse or not, as this has an impact on how results are calculated
 * @param distinct      is this a distinct browse
 * @return              the offset of the first result from the start of the set
 * @throws SQLException
 * @throws BrowseException
 */
private int getPosition(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  if (dao.getJumpToValue() == null) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
    return 0;
  }
  String tableName=browseIndex.getTableName(distinct,scope.inCommunity(),scope.inCollection());
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  boolean isAscending=dao.isAscending();
  boolean useEquals=dao.useEqualsComparator();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setAscending(!isAscending);
  dao.setEqualsComparator(false);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setAscending(isAscending);
  dao.setEqualsComparator(useEquals);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}",0.9918392969240428
3478,"/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of  the browse
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getTableName(true,scope.inCommunity(),scope.inCollection()));
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setJumpToField(""String_Node_Str"");
    String focusValue=null;
    String rawFocusValue=null;
    if (scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      dao.setJumpToValue(focusValue);
    }
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getTableName(false,false,false,true));
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setOrderField(""String_Node_Str"");
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doValueQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    String next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(String)results.get(lastIndex);
      results.remove(lastIndex);
    }
    String prev=null;
    if (scope.hasJumpToValue() || scope.hasStartsWith()) {
      if (showLast) {
        prev=getPreviousPageValue(results);
      }
 else {
        prev=getPreviousPageValue(null);
      }
    }
    int offset=0;
    int total=getTotalResults(true);
    int position=getPosition(true);
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextValue(next);
    }
    if (prev != null) {
      browseInfo.setPrevValue(prev);
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    List results=dao.doValueQuery();
    int total=getTotalResults(true);
    if (results.size() == 0) {
      offset=total - scope.getResultsPerPage();
      if (offset < 0)       offset=0;
      dao.setOffset(offset);
      results=dao.doQuery();
      total=getTotalResults();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.6241044419678395
3479,"/** 
 * Create a new instance of the Browse engine, using the given DSpace Context object.  This will automatically assign a Data Access Object for the Browse Engine, based on the dspace.cfg setting for db.name
 * @param context		the DSpace context
 * @throws BrowseException
 */
public BrowseEngine(Context context) throws BrowseException {
  this.context=context;
  dao=BrowseDAOFactory.getInstance(context);
}","/** 
 * Create a new instance of the Browse engine, using the given DSpace Context object.  This will automatically assign a Data Access Object for the Browse Engine, based on the dspace.cfg setting for db.name
 * @param context       the DSpace context
 * @throws BrowseException
 */
public BrowseEngine(Context context) throws BrowseException {
  this.context=context;
  dao=BrowseDAOFactory.getInstance(context);
}",0.9891435464414958
3480,"/** 
 * Get the total number of results.  The argument determines whether this is a distinct browse or not as this has an impact on how results are counted
 * @param distinct	is this a distinct browse or not
 * @return			the total number of results available in this type of browse
 * @throws SQLException
 * @throws BrowseException
 */
private int getTotalResults(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  String tableName=browseIndex.getTableName(distinct,scope.inCommunity(),scope.inCollection());
  dao.setDistinct(distinct);
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  String focusField=dao.getJumpToField();
  String focusValue=dao.getJumpToValue();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setJumpToField(null);
  dao.setJumpToValue(null);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setJumpToField(focusField);
  dao.setJumpToValue(focusValue);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}","/** 
 * Get the total number of results.  The argument determines whether this is a distinct browse or not as this has an impact on how results are counted
 * @param distinct  is this a distinct browse or not
 * @return          the total number of results available in this type of browse
 * @throws SQLException
 * @throws BrowseException
 */
private int getTotalResults(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  dao.setDistinct(distinct);
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  String focusField=dao.getJumpToField();
  String focusValue=dao.getJumpToValue();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setJumpToField(null);
  dao.setJumpToValue(null);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setJumpToField(focusField);
  dao.setJumpToValue(focusValue);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}",0.9554140127388536
3481,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName());
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
      dao.setFilterMappingTables(browseIndex.getTableName(false,false,true,false),browseIndex.getTableName(false,false,false,true));
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName());
    dao.setAscending(scope.isAscending());
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      String value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
      dao.setFilterMappingTables(browseIndex.getDistinctTableName(),browseIndex.getMapTableName());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith())) {
      rawFocusValue=getJumpToValue();
      String focusValue=normalizeJumpToValue(rawFocusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      String focusField=browseIndex.getSortField(scope.isSecondLevel());
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      offset=getOffsetForValue(focusValue);
    }
    dao.setOffset(offset);
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage());
    List results=dao.doQuery();
    int total=getTotalResults();
    if (results.size() == 0) {
      offset=total - scope.getResultsPerPage();
      if (offset < 0)       offset=0;
      dao.setOffset(offset);
      results=dao.doQuery();
      total=getTotalResults();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.4271217712177121
3482,"/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  if (so == null || so.getNumber() == 0) {
    if (browseIndex.getSortOption() != null)     so=browseIndex.getSortOption();
  }
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}","/** 
 * Return the focus value.
 * @return  the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  if (so == null || so.getNumber() == 0) {
    if (browseIndex.getSortOption() != null)     so=browseIndex.getSortOption();
  }
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}",0.9986455981941308
3483,"/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName());
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerTable(""String_Node_Str"");
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerTable(""String_Node_Str"");
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField(scope.isSecondLevel());
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}","/** 
 * Perform a limited browse, which only returns the results requested, without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs    the scope of the browse
 * @return      the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName());
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerTable(""String_Node_Str"");
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerTable(""String_Node_Str"");
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setOffset(scope.getOffset());
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField(scope.isSecondLevel());
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}",0.9874623871614844
3484,"/** 
 * Perform a standard browse, which will return a BrowseInfo object that represents the results for the current page, the total number of results, the range, and information to construct previous and next links on any web page
 * @param bs	the scope of the browse
 * @return		the results of the browse
 * @throws BrowseException
 */
public BrowseInfo browse(BrowserScope bs) throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  if (browseIndex.isMetadataIndex() && !scope.isSecondLevel()) {
    return browseByValue(scope);
  }
 else {
    return browseByItem(scope);
  }
}","/** 
 * Perform a standard browse, which will return a BrowseInfo object that represents the results for the current page, the total number of results, the range, and information to construct previous and next links on any web page
 * @param bs    the scope of the browse
 * @return      the results of the browse
 * @throws BrowseException
 */
public BrowseInfo browse(BrowserScope bs) throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  if (browseIndex.isMetadataIndex() && !scope.isSecondLevel()) {
    return browseByValue(scope);
  }
 else {
    return browseByItem(scope);
  }
}",0.9905865314989138
3485,"/** 
 * Are there results prior to these that haven't been returned here?
 * @return	true if previous page, false if not
 */
public boolean hasPrevPage(){
  if (!""String_Node_Str"".equals(prevValue) && (prevValue != null)) {
    return true;
  }
  if (prevItem != -1) {
    return true;
  }
  return false;
}","/** 
 * Are there results prior to these that haven't been returned here?
 * @return	true if previous page, false if not
 */
public boolean hasPrevPage(){
  if (offset > 0) {
    return true;
  }
  return false;
}",0.7384615384615385
3486,"/** 
 * Does this browse have an item focus (as opposed to one of: no focus,  a value focus)
 * @return	true if item focus, false if not
 */
public boolean hasItemFocus(){
  if (focusItem == -1) {
    return false;
  }
  return true;
}","/** 
 * Does this browse have an item focus (as opposed to one of: no focus, a value focus)
 * @return	true if item focus, false if not
 */
public boolean hasItemFocus(){
  if (focusItem == -1) {
    return false;
  }
  return true;
}",0.997867803837953
3487,"/** 
 * Are there further results for the browse that haven't been returned yet?
 * @return	true if next page, false if not
 */
public boolean hasNextPage(){
  if (!""String_Node_Str"".equals(nextValue) && (nextValue != null)) {
    return true;
  }
  if (nextItem != -1) {
    return true;
  }
  return false;
}","/** 
 * Are there further results for the browse that haven't been returned yet?
 * @return	true if next page, false if not
 */
public boolean hasNextPage(){
  if (nextOffset > -1) {
    return true;
  }
  return false;
}",0.8022598870056498
3488,"/** 
 * Utility method for obtaining a string representation of the browse.  This is useful only for debug
 */
public String toString(){
  try {
    StringBuffer sb=new StringBuffer();
    String from=Integer.toString(overallPosition + 1);
    String to=Integer.toString(overallPosition + results.size());
    String of=Integer.toString(total);
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ of+ ""String_Node_Str"");
    sb.append(""String_Node_Str"" + browseIndex.getName() + ""String_Node_Str""+ browseIndex.getDataType()+ ""String_Node_Str""+ browseIndex.getDisplayType()+ ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    String container=""String_Node_Str"";
    DSpaceObject theContainer=null;
    if (inCollection()) {
      container=""String_Node_Str"";
      theContainer=this.collection;
    }
 else     if (inCommunity()) {
      container=""String_Node_Str"";
      theContainer=this.community;
    }
    String containerID=""String_Node_Str"";
    if (theContainer != null) {
      containerID=Integer.toString(theContainer.getID()) + ""String_Node_Str"" + theContainer.getHandle()+ ""String_Node_Str"";
    }
    sb.append(""String_Node_Str"" + container + ""String_Node_Str""+ containerID);
    sb.append(""String_Node_Str"");
    ItemListConfig config=new ItemListConfig();
    if (browseIndex.isItemIndex()) {
      sb.append(""String_Node_Str"" + Integer.toString(config.numCols()) + ""String_Node_Str"");
      for (int k=1; k <= config.numCols(); k++) {
        if (k > 1) {
          sb.append(""String_Node_Str"");
        }
        String[] meta=config.getMetadata(k);
        sb.append(meta[0] + ""String_Node_Str"" + meta[1]+ ""String_Node_Str""+ meta[2]);
      }
      if (value != null) {
        sb.append(""String_Node_Str"" + value);
      }
      if (isStartsWith()) {
        sb.append(""String_Node_Str"" + focus);
      }
 else       if (hasFocus()) {
        sb.append(""String_Node_Str"" + focus);
      }
    }
 else     if (browseIndex.isMetadataIndex()) {
      sb.append(""String_Node_Str"" + browseIndex.getMetadata());
      if (isStartsWith()) {
        sb.append(""String_Node_Str"" + focus);
      }
 else       if (hasFocus()) {
        sb.append(""String_Node_Str"" + focus);
      }
    }
    sb.append(""String_Node_Str"");
    String direction=(ascending ? ""String_Node_Str"" : ""String_Node_Str"");
    sb.append(""String_Node_Str"" + sortOption.getMetadata() + ""String_Node_Str""+ direction+ ""String_Node_Str""+ Integer.toString(sortOption.getNumber())+ ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (browseIndex.isMetadataIndex() && !isSecondLevel()) {
      sb.append(valueListingString());
    }
 else     if (browseIndex.isItemIndex() || isSecondLevel()) {
      sb.append(fullListingString(config));
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (hasNextPage()) {
      if (browseIndex.isMetadataIndex() && !isSecondLevel()) {
        sb.append(this.nextValue);
      }
 else       if (browseIndex.isItemIndex() || isSecondLevel()) {
        sb.append(""String_Node_Str"" + Integer.toString(this.nextItem));
      }
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (hasPrevPage()) {
      if (browseIndex.isMetadataIndex() && !isSecondLevel()) {
        sb.append(this.prevValue);
      }
 else       if (browseIndex.isItemIndex() || isSecondLevel()) {
        sb.append(""String_Node_Str"" + Integer.toString(this.prevItem));
      }
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
 catch (  SQLException e) {
    return e.getMessage();
  }
catch (  BrowseException e) {
    return e.getMessage();
  }
}","/** 
 * Utility method for obtaining a string representation of the browse.  This is useful only for debug
 */
public String toString(){
  try {
    StringBuffer sb=new StringBuffer();
    String from=Integer.toString(overallPosition + 1);
    String to=Integer.toString(overallPosition + results.size());
    String of=Integer.toString(total);
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ of+ ""String_Node_Str"");
    sb.append(""String_Node_Str"" + browseIndex.getName() + ""String_Node_Str""+ browseIndex.getDataType()+ ""String_Node_Str""+ browseIndex.getDisplayType()+ ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    String container=""String_Node_Str"";
    DSpaceObject theContainer=null;
    if (inCollection()) {
      container=""String_Node_Str"";
      theContainer=this.collection;
    }
 else     if (inCommunity()) {
      container=""String_Node_Str"";
      theContainer=this.community;
    }
    String containerID=""String_Node_Str"";
    if (theContainer != null) {
      containerID=Integer.toString(theContainer.getID()) + ""String_Node_Str"" + theContainer.getHandle()+ ""String_Node_Str"";
    }
    sb.append(""String_Node_Str"" + container + ""String_Node_Str""+ containerID);
    sb.append(""String_Node_Str"");
    ItemListConfig config=new ItemListConfig();
    if (browseIndex.isItemIndex()) {
      sb.append(""String_Node_Str"" + Integer.toString(config.numCols()) + ""String_Node_Str"");
      for (int k=1; k <= config.numCols(); k++) {
        if (k > 1) {
          sb.append(""String_Node_Str"");
        }
        String[] meta=config.getMetadata(k);
        sb.append(meta[0] + ""String_Node_Str"" + meta[1]+ ""String_Node_Str""+ meta[2]);
      }
      if (value != null) {
        sb.append(""String_Node_Str"" + value);
      }
      if (isStartsWith()) {
        sb.append(""String_Node_Str"" + focus);
      }
 else       if (hasFocus()) {
        sb.append(""String_Node_Str"" + focus);
      }
    }
 else     if (browseIndex.isMetadataIndex()) {
      sb.append(""String_Node_Str"" + browseIndex.getMetadata());
      if (isStartsWith()) {
        sb.append(""String_Node_Str"" + focus);
      }
 else       if (hasFocus()) {
        sb.append(""String_Node_Str"" + focus);
      }
    }
    sb.append(""String_Node_Str"");
    String direction=(ascending ? ""String_Node_Str"" : ""String_Node_Str"");
    sb.append(""String_Node_Str"" + sortOption.getMetadata() + ""String_Node_Str""+ direction+ ""String_Node_Str""+ Integer.toString(sortOption.getNumber())+ ""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (browseIndex.isMetadataIndex() && !isSecondLevel()) {
      sb.append(valueListingString());
    }
 else     if (browseIndex.isItemIndex() || isSecondLevel()) {
      sb.append(fullListingString(config));
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (hasNextPage()) {
      sb.append(""String_Node_Str"" + Integer.toString(this.nextOffset));
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    if (hasPrevPage()) {
      sb.append(""String_Node_Str"" + Integer.toString(this.prevOffset));
    }
 else {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
 catch (  SQLException e) {
    return e.getMessage();
  }
catch (  BrowseException e) {
    return e.getMessage();
  }
}",0.9168283892431384
3489,"/** 
 * @return	true if in collection, false if not
 */
public boolean inCollection(){
  if (this.collection != null) {
    return true;
  }
  return false;
}","/** 
 * @return  true if in collection, false if not
 */
public boolean inCollection(){
  if (this.collection != null) {
    return true;
  }
  return false;
}",0.9905362776025236
3490,"/** 
 * @return	true if has item focus, false if not
 */
public boolean hasJumpToItem(){
  if (jumpItemId == -1) {
    return false;
  }
  return true;
}","/** 
 * @return  true if has item focus, false if not
 */
public boolean hasJumpToItem(){
  if (jumpItemId == -1) {
    return false;
  }
  return true;
}",0.990228013029316
3491,"/** 
 * Obtain a DSpaceObject that represents the container object.  This will be a Community or a Collection
 * @return	A DSpaceObject representing a Community or a Collection
 */
public DSpaceObject getBrowseContainer(){
  if (this.collection != null) {
    return this.collection;
  }
  if (this.community != null) {
    return this.community;
  }
  return null;
}","/** 
 * Obtain a DSpaceObject that represents the container object.  This will be a Community or a Collection
 * @return  A DSpaceObject representing a Community or a Collection
 */
public DSpaceObject getBrowseContainer(){
  if (this.collection != null) {
    return this.collection;
  }
  if (this.community != null) {
    return this.community;
  }
  return null;
}",0.9959183673469388
3492,"/** 
 * @return	true if has value focus, false if not
 */
public boolean hasJumpToValue(){
  if (this.jumpValue != null) {
    return true;
  }
  return false;
}","/** 
 * @return  true if has value focus, false if not
 */
public boolean hasJumpToValue(){
  if (this.jumpValue != null) {
    return true;
  }
  return false;
}",0.9907120743034056
3493,"/** 
 * @return	true if has starts with value, false if not
 */
public boolean hasStartsWith(){
  if (this.startsWith != null) {
    return true;
  }
  return false;
}","/** 
 * @return  true if has starts with value, false if not
 */
public boolean hasStartsWith(){
  if (this.startsWith != null) {
    return true;
  }
  return false;
}",0.991044776119403
3494,"/** 
 * Set the DSpaceObject that is the container for this browse.  If this is not of type Collection or Community, this method will throw an exception
 * @param dso		the container object; a Community or Collection
 * @throws BrowseException
 */
public void setBrowseContainer(DSpaceObject dso) throws BrowseException {
  if (dso instanceof Collection) {
    this.collection=(Collection)dso;
  }
 else   if (dso instanceof Community) {
    this.community=(Community)dso;
  }
 else {
    throw new BrowseException(""String_Node_Str"");
  }
}","/** 
 * Set the DSpaceObject that is the container for this browse.  If this is not of type Collection or Community, this method will throw an exception
 * @param dso       the container object; a Community or Collection
 * @throws BrowseException
 */
public void setBrowseContainer(DSpaceObject dso) throws BrowseException {
  if (dso instanceof Collection) {
    this.collection=(Collection)dso;
  }
 else   if (dso instanceof Community) {
    this.community=(Community)dso;
  }
 else {
    throw new BrowseException(""String_Node_Str"");
  }
}",0.9916897506925209
3495,"/** 
 * @return	true if second level browse, false if not
 */
public boolean isSecondLevel(){
  if (this.level == 1) {
    return true;
  }
  return false;
}","/** 
 * @return  true if second level browse, false if not
 */
public boolean isSecondLevel(){
  if (this.level == 1) {
    return true;
  }
  return false;
}",0.9904761904761904
3496,"/** 
 * @return	true if in community, false if not
 */
public boolean inCommunity(){
  if (this.community != null) {
    return true;
  }
  return false;
}","/** 
 * @return  true if in community, false if not
 */
public boolean inCommunity(){
  if (this.community != null) {
    return true;
  }
  return false;
}",0.990353697749196
3497,"/** 
 * Obtain the sort option
 * @return	the sort option
 * @throws BrowseException
 */
public SortOption getSortOption() throws BrowseException {
  try {
    if (sortOption == null) {
      if (browseIndex != null) {
        if (sortBy <= 0 && browseIndex.isMetadataIndex()) {
          String dataType=browseIndex.getDataType();
          String type=(""String_Node_Str"".equals(dataType) ? ""String_Node_Str"" : ""String_Node_Str"");
          sortOption=new SortOption(0,browseIndex.getName(),browseIndex.getMetadata(0),type);
        }
 else {
          if (sortBy <= 0) {
            sortOption=browseIndex.getSortOption();
            if (sortOption == null) {
              for (              SortOption so : SortOption.getSortOptions()) {
                sortOption=so;
                break;
              }
            }
          }
 else {
            for (            SortOption so : SortOption.getSortOptions()) {
              if (so.getNumber() == sortBy)               sortOption=so;
            }
          }
        }
      }
    }
    return sortOption;
  }
 catch (  SortException se) {
    throw new BrowseException(""String_Node_Str"",se);
  }
}","/** 
 * Obtain the sort option
 * @return  the sort option
 * @throws BrowseException
 */
public SortOption getSortOption() throws BrowseException {
  try {
    if (sortOption == null) {
      if (browseIndex != null) {
        if (sortBy <= 0 && browseIndex.isMetadataIndex()) {
          String dataType=browseIndex.getDataType();
          String type=(""String_Node_Str"".equals(dataType) ? ""String_Node_Str"" : ""String_Node_Str"");
          sortOption=new SortOption(0,browseIndex.getName(),browseIndex.getMetadata(0),type);
        }
 else {
          if (sortBy <= 0) {
            sortOption=browseIndex.getSortOption();
            if (sortOption == null) {
              for (              SortOption so : SortOption.getSortOptions()) {
                sortOption=so;
                break;
              }
            }
          }
 else {
            for (            SortOption so : SortOption.getSortOptions()) {
              if (so.getNumber() == sortBy)               sortOption=so;
            }
          }
        }
      }
    }
    return sortOption;
  }
 catch (  SortException se) {
    throw new BrowseException(""String_Node_Str"",se);
  }
}",0.9987085665088248
3498,"/** 
 * Used for second-level item browses, to only display items that match the value 
 * @return Returns the value.
 */
public String getFilterValue(){
  return filterValue;
}","/** 
 * Used for second-level item browses, to only display items that match the value
 * @return Returns the value.
 */
public String getFilterValue(){
  return filterValue;
}",0.9971671388101984
3499,"/** 
 * @param level		the browse level
 */
public void setBrowseLevel(int level){
  this.level=level;
}","/** 
 * @param level     the browse level
 */
public void setBrowseLevel(int level){
  this.level=level;
}",0.9665071770334928
3500,"/** 
 * @param value		the value to focus on
 */
public void setJumpToValue(String value){
  this.jumpValue=value;
}","/** 
 * @param value     the value to focus on
 */
public void setJumpToValue(String value){
  this.jumpValue=value;
}",0.9699570815450644
3501,"/** 
 * @return	the value to focus on
 */
public String getJumpToValue(){
  return jumpValue;
}","/** 
 * @return  the value to focus on
 */
public String getJumpToValue(){
  return jumpValue;
}",0.9842931937172776
3502,"/** 
 * @return	the browse level
 */
public int getBrowseLevel(){
  return this.level;
}","/** 
 * @return  the browse level
 */
public int getBrowseLevel(){
  return this.level;
}",0.9830508474576272
3503,"/** 
 * @return	true if ascending, false if not - or not set
 */
public boolean isAscending(){
  if (SortOption.ASCENDING.equalsIgnoreCase(order)) {
    return true;
  }
  if (SortOption.DESCENDING.equalsIgnoreCase(order)) {
    return false;
  }
  BrowseIndex bi=getBrowseIndex();
  if (bi != null && SortOption.DESCENDING.equalsIgnoreCase(bi.getDefaultOrder()))   return false;
  return true;
}","/** 
 * @return  true if ascending, false if not - or not set
 */
public boolean isAscending(){
  if (SortOption.ASCENDING.equalsIgnoreCase(order)) {
    return true;
  }
  if (SortOption.DESCENDING.equalsIgnoreCase(order)) {
    return false;
  }
  BrowseIndex bi=getBrowseIndex();
  if (bi != null && SortOption.DESCENDING.equalsIgnoreCase(bi.getDefaultOrder()))   return false;
  return true;
}",0.996216897856242
3504,"/** 
 * @return	true if has value, false if not
 */
public boolean hasFilterValue(){
  if (filterValue == null || ""String_Node_Str"".equals(filterValue)) {
    return false;
  }
  return true;
}","/** 
 * @return  true if has value, false if not
 */
public boolean hasFilterValue(){
  if (filterValue == null || ""String_Node_Str"".equals(filterValue)) {
    return false;
  }
  return true;
}",0.992248062015504
3505,"/** 
 * Construct a new BrowserScope using the given Context 
 * @param context	the DSpace Context
 */
public BrowserScope(Context context){
  this.context=context;
}","/** 
 * Construct a new BrowserScope using the given Context
 * @param context   the DSpace Context
 */
public BrowserScope(Context context){
  this.context=context;
}",0.984984984984985
3506,"/** 
 * Used for second-level item browses, to only display items that match the value 
 * @param value The value to set.
 */
public void setFilterValue(String value){
  this.filterValue=value;
}","/** 
 * Used for second-level item browses, to only display items that match the value
 * @param value The value to set.
 */
public void setFilterValue(String value){
  this.filterValue=value;
}",0.9974293059125964
3507,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int offset=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (offset < 0) {
      offset=0;
    }
    if (resultsperpage < 0) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setOffset(offset);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.9532964365472376
3508,"/** 
 * Display the single page.  This is the page which lists just the single values of a  metadata browse, not individual items.  Single values are links through to all the items that match that metadata value
 * @param context
 * @param request
 * @param response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected abstract void showSinglePage(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException ;","/** 
 * Display the single page.  This is the page which lists just the single values of a metadata browse, not individual items.  Single values are links through to all the items that match that metadata value
 * @param context
 * @param request
 * @param response
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected abstract void showSinglePage(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException ;",0.9991063449508488
3509,"/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    int total=getTotalResults();
    List results=null;
    if (total > 0) {
      results=dao.doQuery();
      if (results.size() == 0) {
        offset=total - scope.getResultsPerPage();
        if (offset < 0)         offset=0;
        dao.setOffset(offset);
        results=dao.doQuery();
      }
    }
 else {
      results=new ArrayList();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    int total=getTotalResults(true);
    List results=null;
    if (total > 0) {
      results=dao.doValueQuery();
      if (results.size() == 0) {
        offset=total - scope.getResultsPerPage();
        if (offset < 0)         offset=0;
        dao.setOffset(offset);
        results=dao.doValueQuery();
      }
    }
 else {
      results=new ArrayList();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9977513652425312
3510,"/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    List results=dao.doValueQuery();
    int total=getTotalResults(true);
    if (results.size() == 0) {
      offset=total - scope.getResultsPerPage();
      if (offset < 0)       offset=0;
      dao.setOffset(offset);
      results=dao.doQuery();
      total=getTotalResults();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by single values (such as the name of an author).  This produces a BrowseInfo object that contains Strings as the results of the browse
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByValue(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + bs.getJumpToValue()));
  try {
    dao.setTable(browseIndex.getDistinctTableName());
    dao.setDistinct(true);
    dao.setAscending(scope.isAscending());
    dao.setOrderField(""String_Node_Str"");
    if (scope.inCollection() || scope.inCommunity()) {
      dao.setFilterMappingTables(null,browseIndex.getMapTableName());
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    dao.setJumpToField(""String_Node_Str"");
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && scope.hasJumpToValue() || scope.hasStartsWith()) {
      String focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith() && browseIndex.isDate()) {
        focusValue=focusValue + ""String_Node_Str"";
      }
      offset=getOffsetForDistinctValue(focusValue);
    }
    dao.setOffset(offset);
    dao.setLimit(scope.getResultsPerPage());
    int total=getTotalResults();
    List results=null;
    if (total > 0) {
      results=dao.doQuery();
      if (results.size() == 0) {
        offset=total - scope.getResultsPerPage();
        if (offset < 0)         offset=0;
        dao.setOffset(offset);
        results=dao.doQuery();
      }
    }
 else {
      results=new ArrayList();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setFocus(rawFocusValue);
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9677839245037424
3511,"/** 
 * Get the total number of results.  The argument determines whether this is a distinct browse or not as this has an impact on how results are counted
 * @param distinct  is this a distinct browse or not
 * @return          the total number of results available in this type of browse
 * @throws SQLException
 * @throws BrowseException
 */
private int getTotalResults(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  dao.setDistinct(distinct);
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  String focusField=dao.getJumpToField();
  String focusValue=dao.getJumpToValue();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setJumpToField(null);
  dao.setJumpToValue(null);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setJumpToField(focusField);
  dao.setJumpToValue(focusValue);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}","/** 
 * Get the total number of results.  The argument determines whether this is a distinct browse or not as this has an impact on how results are counted
 * @param distinct  is this a distinct browse or not
 * @return          the total number of results available in this type of browse
 * @throws SQLException
 * @throws BrowseException
 */
private int getTotalResults(boolean distinct) throws SQLException, BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + distinct));
  dao.setDistinct(distinct);
  String[] select={""String_Node_Str""};
  dao.setCountValues(select);
  String focusField=dao.getJumpToField();
  String focusValue=dao.getJumpToValue();
  String orderField=dao.getOrderField();
  int limit=dao.getLimit();
  int offset=dao.getOffset();
  dao.setJumpToField(null);
  dao.setJumpToValue(null);
  dao.setOrderField(null);
  dao.setLimit(-1);
  dao.setOffset(-1);
  int count=dao.doCountQuery();
  dao.setJumpToField(focusField);
  dao.setJumpToValue(focusValue);
  dao.setOrderField(orderField);
  dao.setLimit(limit);
  dao.setOffset(offset);
  dao.setCountValues(null);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + count));
  return count;
}",0.9885807504078304
3512,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName());
    dao.setAscending(scope.isAscending());
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      String value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
      dao.setFilterMappingTables(browseIndex.getDistinctTableName(),browseIndex.getMapTableName());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith())) {
      rawFocusValue=getJumpToValue();
      String focusValue=normalizeJumpToValue(rawFocusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      String focusField=browseIndex.getSortField(scope.isSecondLevel());
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      offset=getOffsetForValue(focusValue);
    }
    dao.setOffset(offset);
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage());
    List results=dao.doQuery();
    int total=getTotalResults();
    if (results.size() == 0) {
      offset=total - scope.getResultsPerPage();
      if (offset < 0)       offset=0;
      dao.setOffset(offset);
      results=dao.doQuery();
      total=getTotalResults();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs        the scope of the browse
 * @return          the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName());
    dao.setAscending(scope.isAscending());
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      String value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
      dao.setFilterMappingTables(browseIndex.getDistinctTableName(),browseIndex.getMapTableName());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerTable(""String_Node_Str"");
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    int offset=scope.getOffset();
    String rawFocusValue=null;
    if (offset < 1 && (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith())) {
      rawFocusValue=getJumpToValue();
      String focusValue=normalizeJumpToValue(rawFocusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      String focusField=browseIndex.getSortField(scope.isSecondLevel());
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      offset=getOffsetForValue(focusValue);
    }
    dao.setOffset(offset);
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage());
    int total=getTotalResults();
    List results=null;
    if (total > 0) {
      results=dao.doQuery();
      if (results.size() == 0) {
        offset=total - scope.getResultsPerPage();
        if (offset < 0)         offset=0;
        dao.setOffset(offset);
        results=dao.doQuery();
      }
    }
 else {
      results=new ArrayList();
    }
    BrowseInfo browseInfo=new BrowseInfo(results,offset,total,offset);
    if (offset + scope.getResultsPerPage() < total) {
      browseInfo.setNextOffset(offset + scope.getResultsPerPage());
    }
    if (offset - scope.getResultsPerPage() > -1) {
      browseInfo.setPrevOffset(offset - scope.getResultsPerPage());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9778667000125046
3513,"/** 
 * using the pre-configuration information passed here, analyse the logs and produce the aggregation file
 * @param context     the DSpace context object this occurs under
 * @param myLogDir    the passed log directory.  Uses default if null
 * @param myFileTemplate  the passed file name regex.  Uses default if null
 * @param myConfigFile    the DStat config file.  Uses default if null
 * @param myOutFile    the file to which to output aggregation data.  Uses default if null
 * @param myStartDate     the desired start of the analysis.  Starts from the beginning otherwise
 * @param myEndDate       the desired end of the analysis.  Goes to the end otherwise
 * @param myLookUp        force a lookup of the database
 */
public static void processLogs(Context context,String myLogDir,String myFileTemplate,String myConfigFile,String myOutFile,Date myStartDate,Date myEndDate,boolean myLookUp) throws IOException, SQLException {
  startTime=new GregorianCalendar();
  actionAggregator=new HashMap();
  searchAggregator=new HashMap();
  userAggregator=new HashMap();
  itemAggregator=new HashMap();
  archiveStats=new HashMap();
  generalSummary=new ArrayList();
  excludeWords=new ArrayList();
  excludeTypes=new ArrayList();
  excludeChars=new ArrayList();
  itemTypes=new ArrayList();
  setParameters(myLogDir,myFileTemplate,myConfigFile,myOutFile,myStartDate,myEndDate,myLookUp);
  FileReader fr=null;
  BufferedReader br=null;
  readConfig(configFile);
  setRegex(fileTemplate);
  File[] logFiles=getLogFiles(logDir);
  int i=0;
  for (i=0; i < logFiles.length; i++) {
    Matcher matchRegex=logRegex.matcher(logFiles[i].getName());
    if (matchRegex.matches()) {
      try {
        fr=new FileReader(logFiles[i].toString());
        br=new BufferedReader(fr);
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"" + logFiles[i].toString());
        System.exit(0);
      }
      String line=null;
      while ((line=br.readLine()) != null) {
        LogLine logLine=getLogLine(line);
        if (logLine != null) {
          if (logLine.beforeDate(startDate)) {
            continue;
          }
          if (logLine.afterDate(endDate)) {
            break;
          }
          lineCount++;
          if (startDate == null) {
            if (logStartDate != null) {
              if (logLine.beforeDate(logStartDate)) {
                logStartDate=logLine.getDate();
              }
            }
 else {
              logStartDate=logLine.getDate();
            }
          }
          if (endDate == null) {
            if (logEndDate != null) {
              if (logLine.afterDate(logEndDate)) {
                logEndDate=logLine.getDate();
              }
            }
 else {
              logEndDate=logLine.getDate();
            }
          }
          if (logLine.isLevel(""String_Node_Str"")) {
            warnCount++;
          }
          if (logLine.isAction(""String_Node_Str"")) {
            String[] words=analyseQuery(logLine.getParams());
            for (int j=0; j < words.length; j++) {
              searchAggregator.put(words[j],increment(searchAggregator,words[j]));
            }
          }
          if (logLine.isAction(""String_Node_Str"") && !userEmail.equals(""String_Node_Str"")) {
            userAggregator.put(logLine.getUser(),increment(userAggregator,logLine.getUser()));
          }
          if (logLine.isAction(""String_Node_Str"")) {
            String handle=logLine.getParams();
            Matcher matchHandle=handleRX.matcher(handle);
            handle=matchHandle.replaceAll(""String_Node_Str"");
            Matcher matchItem=itemRX.matcher(handle);
            handle=matchItem.replaceAll(""String_Node_Str"");
            handle.trim();
            itemAggregator.put(handle,increment(itemAggregator,handle));
          }
          actionAggregator.put(logLine.getAction(),increment(actionAggregator,logLine.getAction()));
        }
      }
      br.close();
      fr.close();
    }
  }
  archiveStats.put(""String_Node_Str"",getNumItems(context));
  for (i=0; i < itemTypes.size(); i++) {
    archiveStats.put(itemTypes.get(i),getNumItems(context,(String)itemTypes.get(i)));
  }
  hostName=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  name=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  url=ConfigurationManager.getProperties(""String_Node_Str"").trim();
  if ((url != null) && (!url.endsWith(""String_Node_Str""))) {
    url=url + ""String_Node_Str"";
  }
  if (((Integer)archiveStats.get(""String_Node_Str"")).intValue() != 0) {
    Double avg=new Double(Math.ceil(((Integer)actionAggregator.get(""String_Node_Str"")).intValue() / ((Integer)archiveStats.get(""String_Node_Str"")).intValue()));
    views=avg.intValue();
  }
  createOutput();
  return;
}","/** 
 * using the pre-configuration information passed here, analyse the logs and produce the aggregation file
 * @param context     the DSpace context object this occurs under
 * @param myLogDir    the passed log directory.  Uses default if null
 * @param myFileTemplate  the passed file name regex.  Uses default if null
 * @param myConfigFile    the DStat config file.  Uses default if null
 * @param myOutFile    the file to which to output aggregation data.  Uses default if null
 * @param myStartDate     the desired start of the analysis.  Starts from the beginning otherwise
 * @param myEndDate       the desired end of the analysis.  Goes to the end otherwise
 * @param myLookUp        force a lookup of the database
 */
public static void processLogs(Context context,String myLogDir,String myFileTemplate,String myConfigFile,String myOutFile,Date myStartDate,Date myEndDate,boolean myLookUp) throws IOException, SQLException {
  startTime=new GregorianCalendar();
  actionAggregator=new HashMap();
  searchAggregator=new HashMap();
  userAggregator=new HashMap();
  itemAggregator=new HashMap();
  archiveStats=new HashMap();
  generalSummary=new ArrayList();
  excludeWords=new ArrayList();
  excludeTypes=new ArrayList();
  excludeChars=new ArrayList();
  itemTypes=new ArrayList();
  setParameters(myLogDir,myFileTemplate,myConfigFile,myOutFile,myStartDate,myEndDate,myLookUp);
  FileReader fr=null;
  BufferedReader br=null;
  readConfig(configFile);
  setRegex(fileTemplate);
  File[] logFiles=getLogFiles(logDir);
  int i=0;
  for (i=0; i < logFiles.length; i++) {
    Matcher matchRegex=logRegex.matcher(logFiles[i].getName());
    if (matchRegex.matches()) {
      try {
        fr=new FileReader(logFiles[i].toString());
        br=new BufferedReader(fr);
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"" + logFiles[i].toString());
        System.exit(0);
      }
      String line=null;
      while ((line=br.readLine()) != null) {
        LogLine logLine=getLogLine(line);
        if (logLine != null) {
          if (logLine.beforeDate(startDate)) {
            continue;
          }
          if (logLine.afterDate(endDate)) {
            break;
          }
          lineCount++;
          if (startDate == null) {
            if (logStartDate != null) {
              if (logLine.beforeDate(logStartDate)) {
                logStartDate=logLine.getDate();
              }
            }
 else {
              logStartDate=logLine.getDate();
            }
          }
          if (endDate == null) {
            if (logEndDate != null) {
              if (logLine.afterDate(logEndDate)) {
                logEndDate=logLine.getDate();
              }
            }
 else {
              logEndDate=logLine.getDate();
            }
          }
          if (logLine.isLevel(""String_Node_Str"")) {
            warnCount++;
          }
          if (logLine.isAction(""String_Node_Str"")) {
            String[] words=analyseQuery(logLine.getParams());
            for (int j=0; j < words.length; j++) {
              searchAggregator.put(words[j],increment(searchAggregator,words[j]));
            }
          }
          if (logLine.isAction(""String_Node_Str"") && !userEmail.equals(""String_Node_Str"")) {
            userAggregator.put(logLine.getUser(),increment(userAggregator,logLine.getUser()));
          }
          if (logLine.isAction(""String_Node_Str"")) {
            String handle=logLine.getParams();
            Matcher matchHandle=handleRX.matcher(handle);
            handle=matchHandle.replaceAll(""String_Node_Str"");
            Matcher matchItem=itemRX.matcher(handle);
            handle=matchItem.replaceAll(""String_Node_Str"");
            handle.trim();
            itemAggregator.put(handle,increment(itemAggregator,handle));
          }
          actionAggregator.put(logLine.getAction(),increment(actionAggregator,logLine.getAction()));
        }
      }
      br.close();
      fr.close();
    }
  }
  archiveStats.put(""String_Node_Str"",getNumItems(context));
  for (i=0; i < itemTypes.size(); i++) {
    archiveStats.put(itemTypes.get(i),getNumItems(context,(String)itemTypes.get(i)));
  }
  hostName=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  name=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  url=ConfigurationManager.getProperty(""String_Node_Str"").trim();
  if ((url != null) && (!url.endsWith(""String_Node_Str""))) {
    url=url + ""String_Node_Str"";
  }
  if (((Integer)archiveStats.get(""String_Node_Str"")).intValue() != 0) {
    Double avg=new Double(Math.ceil(((Integer)actionAggregator.get(""String_Node_Str"")).intValue() / ((Integer)archiveStats.get(""String_Node_Str"")).intValue()));
    views=avg.intValue();
  }
  createOutput();
  return;
}",0.9995800965777872
3514,"/** 
 * Translate the given HTML fragment into a DRI document. The translation is broken up into two steps, 1) recurse through all elements and either translate them into their DRI equivelents or remove them from the document. The second step, 2) is to iterate over all top level elements and ensure that they only consist of paragraphs. Also at this stage if linkBreaks is true then \n are treated as paragraph breaks.
 * @param parent The Element to translate into DRI.
 */
private void translate(Element parent){
  for (int i=0; i < parent.getContentSize(); i++) {
    Content decedent=parent.getContent(i);
    if (decedent instanceof org.jdom.Text) {
    }
 else     if (decedent instanceof Element) {
      Element element=(Element)decedent;
      String name=element.getName();
      if (""String_Node_Str"".equals(name)) {
        if (parent.isRootElement()) {
          moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
          limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
          translate(element);
        }
 else {
          removeContent(element);
        }
      }
 else       if (""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name)|| ""String_Node_Str"".equals(name)|| ""String_Node_Str"".equals(name)) {
        if (parent.isRootElement()) {
          limitAttributes(element);
          element.setName(""String_Node_Str"");
          element.setAttribute(""String_Node_Str"",""String_Node_Str"");
          translate(element);
        }
 else {
          removeContent(element);
        }
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else {
        removeContent(decedent);
      }
    }
 else {
      removeContent(decedent);
    }
  }
  if (parent.isRootElement()) {
    List<Content> removed=new ArrayList<Content>();
    for (int i=0; i < parent.getContentSize(); i++) {
      Content current=parent.getContent(i);
      if ((current instanceof Element) && (""String_Node_Str"".equals(((Element)current).getName()))) {
        if (paragraphWrap(parent,i,removed)) {
          removed.clear();
          i++;
        }
      }
 else {
        if (this.blankLines && current instanceof Text) {
          String rawText=((Text)current).getText();
          @SuppressWarnings(""String_Node_Str"") List<String> parts=new ArrayList(Arrays.asList(rawText.split(""String_Node_Str"")));
          if (parts.size() > 0) {
            Collections.reverse(parts);
            String lastPart=parts.remove(0);
            for (            String part : parts) {
              removed.add(new Text(part));
              if (paragraphWrap(parent,i,removed)) {
                removed.clear();
                i++;
              }
            }
            removed.add(new Text(lastPart));
            parent.removeContent(current);
            i--;
          }
        }
 else {
          removed.add(current);
          parent.removeContent(current);
          i--;
        }
      }
    }
    if (removed.size() > 0) {
      paragraphWrap(parent,-1,removed);
      removed.clear();
    }
  }
}","/** 
 * Translate the given HTML fragment into a DRI document. The translation is broken up into two steps, 1) recurse through all elements and either translate them into their DRI equivelents or remove them from the document. The second step, 2) is to iterate over all top level elements and ensure that they only consist of paragraphs. Also at this stage if linkBreaks is true then \n are treated as paragraph breaks.
 * @param parent The Element to translate into DRI.
 */
private void translate(Element parent){
  for (int i=0; i < parent.getContentSize(); i++) {
    Content decedent=parent.getContent(i);
    if (decedent instanceof org.jdom.Text) {
    }
 else     if (decedent instanceof Element) {
      Element element=(Element)decedent;
      String name=element.getName();
      if (""String_Node_Str"".equals(name)) {
        if (parent.isRootElement()) {
          moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
          limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
          translate(element);
        }
 else {
          removeContent(element);
        }
      }
 else       if (""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name)|| ""String_Node_Str"".equals(name)|| ""String_Node_Str"".equals(name)) {
        if (parent.isRootElement()) {
          limitAttributes(element);
          element.setName(""String_Node_Str"");
          element.setAttribute(""String_Node_Str"",""String_Node_Str"");
          translate(element);
        }
 else {
          removeContent(element);
        }
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element);
        element.setName(""String_Node_Str"");
        element.setAttribute(""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        moveAttribute(element,""String_Node_Str"",""String_Node_Str"");
        limitAttributes(element,""String_Node_Str"");
        element.setName(""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"");
        translate(element);
      }
 else       if (""String_Node_Str"".equals(name)) {
        limitAttributes(element,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        translate(element);
      }
 else {
        removeContent(decedent);
      }
    }
 else {
      removeContent(decedent);
    }
  }
  if (parent.isRootElement()) {
    List<Content> removed=new ArrayList<Content>();
    for (int i=0; i < parent.getContentSize(); i++) {
      Content current=parent.getContent(i);
      if ((current instanceof Element) && (""String_Node_Str"".equals(((Element)current).getName()))) {
        if (paragraphWrap(parent,i,removed)) {
          removed.clear();
          i++;
        }
      }
 else       if ((current instanceof Element) && (""String_Node_Str"".equals(((Element)current).getName()))) {
        i++;
      }
 else {
        if (this.blankLines && current instanceof Text) {
          String rawText=((Text)current).getText();
          @SuppressWarnings(""String_Node_Str"") List<String> parts=new ArrayList(Arrays.asList(rawText.split(""String_Node_Str"")));
          if (parts.size() > 0) {
            Collections.reverse(parts);
            String lastPart=parts.remove(0);
            for (            String part : parts) {
              removed.add(new Text(part));
              if (paragraphWrap(parent,i,removed)) {
                removed.clear();
                i++;
              }
            }
            removed.add(new Text(lastPart));
            parent.removeContent(current);
            i--;
          }
        }
 else {
          removed.add(current);
          parent.removeContent(current);
          i--;
        }
      }
    }
    if (removed.size() > 0) {
      paragraphWrap(parent,-1,removed);
      removed.clear();
    }
  }
}",0.9880367244737086
3515,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal));
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.8676567656765677
3516,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        Set<Integer> distIDSet=new HashSet<Integer>();
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  distIDSet.add(dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal));
                }
              }
            }
          }
        }
        if (distIDSet.isEmpty()) {
          removeIndex(item.getID(),bis[i].getMapTableName());
        }
 else {
          int[] distIDarr=new int[distIDSet.size()];
          int didx=0;
          for (          Integer distID : distIDSet) {
            distIDarr[didx++]=distID;
          }
          dao.updateDistinctMappings(bis[i].getMapTableName(),item.getID(),distIDarr);
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.8676567656765677
3517,"/** 
 * Get a sub-query to obtain the ids for a distinct browse within a given constraint.  This will produce something of the form: <code> id IN (SELECT distinct_id FROM [container table] WHERE [container field] = [container id]) </code> This is for use inside the overall WHERE clause only
 * @return  the sub-query
 */
private void buildWhereClauseDistinctConstraints(StringBuffer queryBuf,List params){
  if (containerIDField != null && containerID != -1 && containerTable != null) {
    buildWhereClauseOpInsert(queryBuf);
    queryBuf.append(""String_Node_Str"");
    queryBuf.append(containerTable);
    queryBuf.append(""String_Node_Str"");
    queryBuf.append(containerIDField);
    queryBuf.append(""String_Node_Str"" + table + ""String_Node_Str"");
    params.add(new Integer(containerID));
  }
}","/** 
 * Get a sub-query to obtain the ids for a distinct browse within a given constraint.  This will produce something of the form: <code> id IN (SELECT distinct_id FROM [container table] WHERE [container field] = [container id]) </code> This is for use inside the overall WHERE clause only
 * @return  the sub-query
 */
private void buildWhereClauseDistinctConstraints(StringBuffer queryBuf,List params){
  if (containerIDField != null && containerID != -1 && containerTable != null) {
    buildWhereClauseOpInsert(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectTables(queryBuf);
    queryBuf.append(""String_Node_Str"");
    buildFocusedSelectClauses(queryBuf,params);
    queryBuf.append(""String_Node_Str"" + table + ""String_Node_Str"");
  }
}",0.8112244897959183
3518,"/** 
 * Get the count of the items in the given container.  If the configuration value webui.strengths.cache is equal to 'true' this will return the cached value if it exists.  If it is equal to 'false' it will count the number of items in the container in real time
 * @param dso
 * @return
 * @throws ItemCountException
 * @throws SQLException 
 */
public int getCount(DSpaceObject dso) throws ItemCountException {
  boolean useCache=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (useCache) {
    return dao.getCount(dso);
  }
  if (dso instanceof Collection) {
    return ((Collection)dso).countItems();
  }
  if (dso instanceof Community) {
    return ((Collection)dso).countItems();
  }
  return 0;
}","/** 
 * Get the count of the items in the given container.  If the configuration value webui.strengths.cache is equal to 'true' this will return the cached value if it exists.  If it is equal to 'false' it will count the number of items in the container in real time
 * @param dso
 * @return
 * @throws ItemCountException
 * @throws SQLException 
 */
public int getCount(DSpaceObject dso) throws ItemCountException {
  boolean useCache=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (useCache) {
    return dao.getCount(dso);
  }
  if (dso instanceof Collection) {
    return ((Collection)dso).countItems();
  }
  if (dso instanceof Community) {
    return ((Community)dso).countItems();
  }
  return 0;
}",0.9896337249481686
3519,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getIdentifier().getCanonicalForm();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getIdentifier().getCanonicalForm();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getIdentifier().getCanonicalForm();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getIdentifier().getCanonicalForm();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.99140625
3520,"/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}","/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  if (so == null || so.getNumber() == 0) {
    if (browseIndex.getSortOption() != null)     so=browseIndex.getSortOption();
  }
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}",0.9108341323106424
3521,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    dao.deleteCommunityMappings(item.getID());
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      dao.insertCommunityMappings(item.getID());
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9617823479005998
3522,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws java.sql.SQLException, javax.servlet.ServletException, java.io.IOException, AuthorizeException {
  ItemDAO itemDAO=ItemDAOFactory.getInstance(context);
  CollectionDAO collectionDAO=CollectionDAOFactory.getInstance(context);
  String jspPage=null;
  int myID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Collection myCollection=collectionDAO.retrieve(myID);
  AuthorizeManager.authorizeAction(context,myCollection,Constants.COLLECTION_ADMIN);
  String action=request.getParameter(""String_Node_Str"");
  if (action == null) {
    action=""String_Node_Str"";
  }
  String cancel=request.getParameter(""String_Node_Str"");
  if (cancel == null) {
    cancel=""String_Node_Str"";
  }
  if (action.equals(""String_Node_Str"") || !cancel.equals(""String_Node_Str"")) {
    int count_native=0;
    int count_import=0;
    Map myItems=new HashMap();
    Map myCollections=new HashMap();
    Map myCounts=new HashMap();
    ItemIterator i=myCollection.getItems();
    while (i.hasNext()) {
      Item myItem=i.next();
      Integer myKey=new Integer(myItem.getID());
      if (myItem.isOwningCollection(myCollection)) {
        count_native++;
      }
 else {
        count_import++;
      }
      Collection owningCollection=myItem.getOwningCollection();
      Integer cKey=new Integer(owningCollection.getID());
      if (myCollections.containsKey(cKey)) {
        Integer x=(Integer)myCounts.get(cKey);
        int myCount=x.intValue() + 1;
        myCounts.put(cKey,new Integer(myCount));
      }
 else {
        myCollections.put(cKey,owningCollection);
        myCounts.put(cKey,new Integer(1));
      }
      myItems.put(myKey,myItem);
    }
    myCollections.remove(new Integer(myCollection.getID()));
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",new Integer(count_native));
    request.setAttribute(""String_Node_Str"",new Integer(count_import));
    request.setAttribute(""String_Node_Str"",myItems);
    request.setAttribute(""String_Node_Str"",myCollections);
    request.setAttribute(""String_Node_Str"",myCounts);
    request.setAttribute(""String_Node_Str"",Collection.findAll(context));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList removedItems=new LinkedList();
    for (int j=0; j < itemIDs.length; j++) {
      int i=Integer.parseInt(itemIDs[j]);
      removedItems.add(itemIDs[j]);
      Item myItem=itemDAO.retrieve(i);
      if (!myItem.isOwningCollection(myCollection)) {
        myCollection.removeItem(myItem);
        try {
          IndexBrowse ib=new IndexBrowse(context);
          ib.itemChanged(myItem);
        }
 catch (        BrowseException e) {
          log.error(""String_Node_Str"",e);
          throw new ServletException(e);
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",removedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList addedItems=new LinkedList();
    if (itemIDs == null) {
      message=""String_Node_Str"";
    }
 else {
      for (int j=0; j < itemIDs.length; j++) {
        int i=Integer.parseInt(itemIDs[j]);
        Item myItem=itemDAO.retrieve(i);
        if (AuthorizeManager.authorizeActionBoolean(context,myItem,Constants.READ)) {
          if (!myItem.isOwningCollection(myCollection)) {
            myCollection.addItem(myItem);
            try {
              IndexBrowse ib=new IndexBrowse(context);
              ib.itemChanged(myItem);
            }
 catch (            BrowseException e) {
              log.error(""String_Node_Str"",e);
              throw new ServletException(e);
            }
            addedItems.add(itemIDs[j]);
          }
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",addedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String name=(String)request.getParameter(""String_Node_Str"");
    String bidx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (bidx == null) {
      throw new ServletException(""String_Node_Str"");
    }
    Map items=new HashMap();
    try {
      BrowserScope bs=new BrowserScope(context);
      BrowseIndex bi=BrowseIndex.getBrowseIndex(bidx);
      bs.setBrowseIndex(bi);
      bs.setOrder(SortOption.ASCENDING);
      bs.setFilterValue(name);
      bs.setFilterValuePartial(true);
      bs.setJumpToValue(null);
      bs.setResultsPerPage(10000);
      bs.setSortBy(0);
      bs.setBrowseLevel(1);
      BrowseEngine be=new BrowseEngine(context);
      BrowseInfo results=be.browse(bs);
      Item[] browseItems=results.getBrowseItemResults(context);
      ItemIterator itr=myCollection.getItems();
      ArrayList idslist=new ArrayList();
      while (itr.hasNext()) {
        idslist.add(new Integer(itr.nextID()));
      }
      for (int i=0; i < browseItems.length; i++) {
        if (!idslist.contains(new Integer(browseItems[i].getID()))) {
          if (AuthorizeManager.authorizeActionBoolean(context,browseItems[i],Constants.READ)) {
            items.put(new Integer(browseItems[i].getID()),browseItems[i]);
          }
        }
      }
    }
 catch (    BrowseException e) {
      log.error(""String_Node_Str"",e);
      throw new ServletException(e);
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",name);
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    int t=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection targetCollection=collectionDAO.retrieve(t);
    ItemIterator i=myCollection.getItems();
    Map items=new HashMap();
    while (i.hasNext()) {
      Item myItem=i.next();
      if (myItem.isOwningCollection(targetCollection)) {
        Integer myKey=new Integer(myItem.getID());
        items.put(myKey,myItem);
      }
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",targetCollection.getMetadata(""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
  context.complete();
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws java.sql.SQLException, javax.servlet.ServletException, java.io.IOException, AuthorizeException {
  ItemDAO itemDAO=ItemDAOFactory.getInstance(context);
  CollectionDAO collectionDAO=CollectionDAOFactory.getInstance(context);
  String jspPage=null;
  int myID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Collection myCollection=collectionDAO.retrieve(myID);
  AuthorizeManager.authorizeAction(context,myCollection,Constants.COLLECTION_ADMIN);
  String action=request.getParameter(""String_Node_Str"");
  if (action == null) {
    action=""String_Node_Str"";
  }
  String cancel=request.getParameter(""String_Node_Str"");
  if (cancel == null) {
    cancel=""String_Node_Str"";
  }
  if (action.equals(""String_Node_Str"") || !cancel.equals(""String_Node_Str"")) {
    int count_native=0;
    int count_import=0;
    Map myItems=new HashMap();
    Map myCollections=new HashMap();
    Map myCounts=new HashMap();
    ItemIterator i=myCollection.getItems();
    while (i.hasNext()) {
      Item myItem=i.next();
      Integer myKey=new Integer(myItem.getID());
      if (myItem.isOwningCollection(myCollection)) {
        count_native++;
      }
 else {
        count_import++;
      }
      Collection owningCollection=myItem.getOwningCollection();
      Integer cKey=new Integer(owningCollection.getID());
      if (myCollections.containsKey(cKey)) {
        Integer x=(Integer)myCounts.get(cKey);
        int myCount=x.intValue() + 1;
        myCounts.put(cKey,new Integer(myCount));
      }
 else {
        myCollections.put(cKey,owningCollection);
        myCounts.put(cKey,new Integer(1));
      }
      myItems.put(myKey,myItem);
    }
    myCollections.remove(new Integer(myCollection.getID()));
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",new Integer(count_native));
    request.setAttribute(""String_Node_Str"",new Integer(count_import));
    request.setAttribute(""String_Node_Str"",myItems);
    request.setAttribute(""String_Node_Str"",myCollections);
    request.setAttribute(""String_Node_Str"",myCounts);
    request.setAttribute(""String_Node_Str"",Collection.findAll(context));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList removedItems=new LinkedList();
    for (int j=0; j < itemIDs.length; j++) {
      int i=Integer.parseInt(itemIDs[j]);
      removedItems.add(itemIDs[j]);
      Item myItem=itemDAO.retrieve(i);
      if (!myItem.isOwningCollection(myCollection)) {
        myCollection.removeItem(myItem);
        try {
          IndexBrowse ib=new IndexBrowse(context);
          ib.itemChanged(myItem);
        }
 catch (        BrowseException e) {
          log.error(""String_Node_Str"",e);
          throw new ServletException(e);
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",removedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList addedItems=new LinkedList();
    if (itemIDs == null) {
      message=""String_Node_Str"";
    }
 else {
      for (int j=0; j < itemIDs.length; j++) {
        int i=Integer.parseInt(itemIDs[j]);
        Item myItem=itemDAO.retrieve(i);
        if (AuthorizeManager.authorizeActionBoolean(context,myItem,Constants.READ)) {
          if (!myItem.isOwningCollection(myCollection)) {
            myCollection.addItem(myItem);
            try {
              IndexBrowse ib=new IndexBrowse(context);
              ib.itemChanged(myItem);
            }
 catch (            BrowseException e) {
              log.error(""String_Node_Str"",e);
              throw new ServletException(e);
            }
            addedItems.add(itemIDs[j]);
          }
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",addedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String name=(String)request.getParameter(""String_Node_Str"");
    String bidx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (bidx == null) {
      throw new ServletException(""String_Node_Str"");
    }
    Map items=new HashMap();
    try {
      BrowserScope bs=new BrowserScope(context);
      BrowseIndex bi=BrowseIndex.getBrowseIndex(bidx);
      bs.setBrowseIndex(bi);
      bs.setOrder(SortOption.ASCENDING);
      bs.setFilterValue(name);
      bs.setFilterValuePartial(true);
      bs.setJumpToValue(null);
      bs.setResultsPerPage(10000);
      bs.setBrowseLevel(1);
      BrowseEngine be=new BrowseEngine(context);
      BrowseInfo results=be.browse(bs);
      Item[] browseItems=results.getBrowseItemResults(context);
      ItemIterator itr=myCollection.getItems();
      ArrayList idslist=new ArrayList();
      while (itr.hasNext()) {
        idslist.add(new Integer(itr.nextID()));
      }
      for (int i=0; i < browseItems.length; i++) {
        if (!idslist.contains(new Integer(browseItems[i].getID()))) {
          if (AuthorizeManager.authorizeActionBoolean(context,browseItems[i],Constants.READ)) {
            items.put(new Integer(browseItems[i].getID()),browseItems[i]);
          }
        }
      }
    }
 catch (    BrowseException e) {
      log.error(""String_Node_Str"",e);
      throw new ServletException(e);
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",name);
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    int t=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection targetCollection=collectionDAO.retrieve(t);
    ItemIterator i=myCollection.getItems();
    Map items=new HashMap();
    while (i.hasNext()) {
      Item myItem=i.next();
      if (myItem.isOwningCollection(targetCollection)) {
        Integer myKey=new Integer(myItem.getID());
        items.put(myKey,myItem);
      }
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",targetCollection.getMetadata(""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
  context.complete();
}",0.9983700659060308
3523,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi != null && bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.9913283405597162
3524,"/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}","/** 
 * Return the focus value.
 * @return	the focus value to use
 * @throws BrowseException
 */
private String getJumpToValue() throws BrowseException {
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  if (scope.hasJumpToValue()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getJumpToValue()));
    return scope.getJumpToValue();
  }
  if (scope.hasStartsWith()) {
    log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + scope.getStartsWith()));
    return scope.getStartsWith();
  }
  int id=scope.getJumpToItem();
  String tableName=browseIndex.getTableName();
  SortOption so=scope.getSortOption();
  if (so == null || so.getNumber() == 0) {
    if (browseIndex.getSortOption() != null)     so=browseIndex.getSortOption();
  }
  String col=""String_Node_Str"";
  if (so.getNumber() > 0) {
    col=""String_Node_Str"" + Integer.toString(so.getNumber());
  }
  String max=dao.doMaxQuery(col,tableName,id);
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + max));
  return max;
}",0.9108341323106424
3525,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    dao.deleteCommunityMappings(item.getID());
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      dao.insertCommunityMappings(item.getID());
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    boolean reqCommunityMappings=false;
    Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
    if (item.isArchived() && !item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      }
      reqCommunityMappings=true;
    }
 else     if (item.isWithdrawn()) {
      if (!dao.updateIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap)) {
        removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
        dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
      }
    }
 else {
      removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
      removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    }
    if (reqCommunityMappings) {
      dao.updateCommunityMappings(item.getID());
    }
 else {
      dao.deleteCommunityMappings(item.getID());
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        boolean itemMapped=false;
        if (item.isArchived() && !item.isWithdrawn()) {
          for (int mdIdx=0; mdIdx < bis[i].getMetadataCount(); mdIdx++) {
            String[] md=bis[i].getMdBits(mdIdx);
            DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
            if (values != null) {
              for (int x=0; x < values.length; x++) {
                if (StringUtils.isEmpty(values[x].value)) {
                  log.error(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ values[x].schema+ ""String_Node_Str""+ values[x].element+ (values[x].qualifier == null ? ""String_Node_Str"" : ""String_Node_Str"" + values[x].qualifier));
                }
 else {
                  String nVal=OrderFormat.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
                  int distinctID=dao.getDistinctID(bis[i].getDistinctTableName(),values[x].value,nVal);
                  if (!dao.updateDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID))                   dao.createDistinctMapping(bis[i].getMapTableName(),item.getID(),distinctID);
                  itemMapped=true;
                }
              }
            }
          }
        }
        if (!itemMapped)         removeIndex(item.getID(),bis[i].getMapTableName());
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9617823479005998
3526,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws java.sql.SQLException, javax.servlet.ServletException, java.io.IOException, AuthorizeException {
  String jspPage=null;
  int myID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Collection myCollection=Collection.find(context,myID);
  AuthorizeManager.authorizeAction(context,myCollection,Constants.COLLECTION_ADMIN);
  String action=request.getParameter(""String_Node_Str"");
  if (action == null) {
    action=""String_Node_Str"";
  }
  String cancel=request.getParameter(""String_Node_Str"");
  if (cancel == null) {
    cancel=""String_Node_Str"";
  }
  if (action.equals(""String_Node_Str"") || !cancel.equals(""String_Node_Str"")) {
    int count_native=0;
    int count_import=0;
    Map myItems=new HashMap();
    Map myCollections=new HashMap();
    Map myCounts=new HashMap();
    ItemIterator i=myCollection.getItems();
    while (i.hasNext()) {
      Item myItem=i.next();
      Integer myKey=new Integer(myItem.getID());
      if (myItem.isOwningCollection(myCollection)) {
        count_native++;
      }
 else {
        count_import++;
      }
      Collection owningCollection=myItem.getOwningCollection();
      Integer cKey=new Integer(owningCollection.getID());
      if (myCollections.containsKey(cKey)) {
        Integer x=(Integer)myCounts.get(cKey);
        int myCount=x.intValue() + 1;
        myCounts.put(cKey,new Integer(myCount));
      }
 else {
        myCollections.put(cKey,owningCollection);
        myCounts.put(cKey,new Integer(1));
      }
      myItems.put(myKey,myItem);
    }
    myCollections.remove(new Integer(myCollection.getID()));
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",new Integer(count_native));
    request.setAttribute(""String_Node_Str"",new Integer(count_import));
    request.setAttribute(""String_Node_Str"",myItems);
    request.setAttribute(""String_Node_Str"",myCollections);
    request.setAttribute(""String_Node_Str"",myCounts);
    request.setAttribute(""String_Node_Str"",Collection.findAll(context));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList removedItems=new LinkedList();
    for (int j=0; j < itemIDs.length; j++) {
      int i=Integer.parseInt(itemIDs[j]);
      removedItems.add(itemIDs[j]);
      Item myItem=Item.find(context,i);
      if (!myItem.isOwningCollection(myCollection)) {
        myCollection.removeItem(myItem);
        try {
          IndexBrowse ib=new IndexBrowse(context);
          ib.itemChanged(myItem);
        }
 catch (        BrowseException e) {
          log.error(""String_Node_Str"",e);
          throw new ServletException(e);
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",removedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList addedItems=new LinkedList();
    if (itemIDs == null) {
      message=""String_Node_Str"";
    }
 else {
      for (int j=0; j < itemIDs.length; j++) {
        int i=Integer.parseInt(itemIDs[j]);
        Item myItem=Item.find(context,i);
        if (AuthorizeManager.authorizeActionBoolean(context,myItem,Constants.READ)) {
          if (!myItem.isOwningCollection(myCollection)) {
            myCollection.addItem(myItem);
            try {
              IndexBrowse ib=new IndexBrowse(context);
              ib.itemChanged(myItem);
            }
 catch (            BrowseException e) {
              log.error(""String_Node_Str"",e);
              throw new ServletException(e);
            }
            addedItems.add(itemIDs[j]);
          }
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",addedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String name=(String)request.getParameter(""String_Node_Str"");
    String bidx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (bidx == null) {
      throw new ServletException(""String_Node_Str"");
    }
    Map items=new HashMap();
    try {
      BrowserScope bs=new BrowserScope(context);
      BrowseIndex bi=BrowseIndex.getBrowseIndex(bidx);
      bs.setBrowseIndex(bi);
      bs.setOrder(SortOption.ASCENDING);
      bs.setFilterValue(name);
      bs.setFilterValuePartial(true);
      bs.setJumpToValue(null);
      bs.setResultsPerPage(10000);
      bs.setSortBy(0);
      bs.setBrowseLevel(1);
      BrowseEngine be=new BrowseEngine(context);
      BrowseInfo results=be.browse(bs);
      Item[] browseItems=results.getItemResults(context);
      ItemIterator itr=myCollection.getItems();
      ArrayList idslist=new ArrayList();
      while (itr.hasNext()) {
        idslist.add(new Integer(itr.nextID()));
      }
      for (int i=0; i < browseItems.length; i++) {
        if (!idslist.contains(new Integer(browseItems[i].getID()))) {
          if (AuthorizeManager.authorizeActionBoolean(context,browseItems[i],Constants.READ)) {
            items.put(new Integer(browseItems[i].getID()),browseItems[i]);
          }
        }
      }
    }
 catch (    BrowseException e) {
      log.error(""String_Node_Str"",e);
      throw new ServletException(e);
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",name);
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    int t=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection targetCollection=Collection.find(context,t);
    ItemIterator i=myCollection.getItems();
    Map items=new HashMap();
    while (i.hasNext()) {
      Item myItem=i.next();
      if (myItem.isOwningCollection(targetCollection)) {
        Integer myKey=new Integer(myItem.getID());
        items.put(myKey,myItem);
      }
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",targetCollection.getMetadata(""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
  context.complete();
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws java.sql.SQLException, javax.servlet.ServletException, java.io.IOException, AuthorizeException {
  String jspPage=null;
  int myID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Collection myCollection=Collection.find(context,myID);
  AuthorizeManager.authorizeAction(context,myCollection,Constants.COLLECTION_ADMIN);
  String action=request.getParameter(""String_Node_Str"");
  if (action == null) {
    action=""String_Node_Str"";
  }
  String cancel=request.getParameter(""String_Node_Str"");
  if (cancel == null) {
    cancel=""String_Node_Str"";
  }
  if (action.equals(""String_Node_Str"") || !cancel.equals(""String_Node_Str"")) {
    int count_native=0;
    int count_import=0;
    Map myItems=new HashMap();
    Map myCollections=new HashMap();
    Map myCounts=new HashMap();
    ItemIterator i=myCollection.getItems();
    while (i.hasNext()) {
      Item myItem=i.next();
      Integer myKey=new Integer(myItem.getID());
      if (myItem.isOwningCollection(myCollection)) {
        count_native++;
      }
 else {
        count_import++;
      }
      Collection owningCollection=myItem.getOwningCollection();
      Integer cKey=new Integer(owningCollection.getID());
      if (myCollections.containsKey(cKey)) {
        Integer x=(Integer)myCounts.get(cKey);
        int myCount=x.intValue() + 1;
        myCounts.put(cKey,new Integer(myCount));
      }
 else {
        myCollections.put(cKey,owningCollection);
        myCounts.put(cKey,new Integer(1));
      }
      myItems.put(myKey,myItem);
    }
    myCollections.remove(new Integer(myCollection.getID()));
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",new Integer(count_native));
    request.setAttribute(""String_Node_Str"",new Integer(count_import));
    request.setAttribute(""String_Node_Str"",myItems);
    request.setAttribute(""String_Node_Str"",myCollections);
    request.setAttribute(""String_Node_Str"",myCounts);
    request.setAttribute(""String_Node_Str"",Collection.findAll(context));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList removedItems=new LinkedList();
    for (int j=0; j < itemIDs.length; j++) {
      int i=Integer.parseInt(itemIDs[j]);
      removedItems.add(itemIDs[j]);
      Item myItem=Item.find(context,i);
      if (!myItem.isOwningCollection(myCollection)) {
        myCollection.removeItem(myItem);
        try {
          IndexBrowse ib=new IndexBrowse(context);
          ib.itemChanged(myItem);
        }
 catch (        BrowseException e) {
          log.error(""String_Node_Str"",e);
          throw new ServletException(e);
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",removedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String[] itemIDs=request.getParameterValues(""String_Node_Str"");
    String message=""String_Node_Str"";
    LinkedList addedItems=new LinkedList();
    if (itemIDs == null) {
      message=""String_Node_Str"";
    }
 else {
      for (int j=0; j < itemIDs.length; j++) {
        int i=Integer.parseInt(itemIDs[j]);
        Item myItem=Item.find(context,i);
        if (AuthorizeManager.authorizeActionBoolean(context,myItem,Constants.READ)) {
          if (!myItem.isOwningCollection(myCollection)) {
            myCollection.addItem(myItem);
            try {
              IndexBrowse ib=new IndexBrowse(context);
              ib.itemChanged(myItem);
            }
 catch (            BrowseException e) {
              log.error(""String_Node_Str"",e);
              throw new ServletException(e);
            }
            addedItems.add(itemIDs[j]);
          }
        }
      }
    }
    request.setAttribute(""String_Node_Str"",message);
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",addedItems);
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    String name=(String)request.getParameter(""String_Node_Str"");
    String bidx=ConfigurationManager.getProperty(""String_Node_Str"");
    if (bidx == null) {
      throw new ServletException(""String_Node_Str"");
    }
    Map items=new HashMap();
    try {
      BrowserScope bs=new BrowserScope(context);
      BrowseIndex bi=BrowseIndex.getBrowseIndex(bidx);
      bs.setBrowseIndex(bi);
      bs.setOrder(SortOption.ASCENDING);
      bs.setFilterValue(name);
      bs.setFilterValuePartial(true);
      bs.setJumpToValue(null);
      bs.setResultsPerPage(10000);
      bs.setBrowseLevel(1);
      BrowseEngine be=new BrowseEngine(context);
      BrowseInfo results=be.browse(bs);
      Item[] browseItems=results.getItemResults(context);
      ItemIterator itr=myCollection.getItems();
      ArrayList idslist=new ArrayList();
      while (itr.hasNext()) {
        idslist.add(new Integer(itr.nextID()));
      }
      for (int i=0; i < browseItems.length; i++) {
        if (!idslist.contains(new Integer(browseItems[i].getID()))) {
          if (AuthorizeManager.authorizeActionBoolean(context,browseItems[i],Constants.READ)) {
            items.put(new Integer(browseItems[i].getID()),browseItems[i]);
          }
        }
      }
    }
 catch (    BrowseException e) {
      log.error(""String_Node_Str"",e);
      throw new ServletException(e);
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",name);
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
 else   if (action.equals(""String_Node_Str"")) {
    int t=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection targetCollection=Collection.find(context,t);
    ItemIterator i=myCollection.getItems();
    Map items=new HashMap();
    while (i.hasNext()) {
      Item myItem=i.next();
      if (myItem.isOwningCollection(targetCollection)) {
        Integer myKey=new Integer(myItem.getID());
        items.put(myKey,myItem);
      }
    }
    request.setAttribute(""String_Node_Str"",myCollection);
    request.setAttribute(""String_Node_Str"",targetCollection.getMetadata(""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",items);
    request.setAttribute(""String_Node_Str"",new String(""String_Node_Str""));
    jspPage=""String_Node_Str"";
    JSPManager.showJSP(request,response,jspPage);
  }
  context.complete();
}",0.9983394700743627
3527,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  ItemDAO itemDAO=ItemDAOFactory.getInstance(context);
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField();
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField();
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    Item next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(Item)results.get(lastIndex);
      results.remove(lastIndex);
    }
    Item prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        prev=itemDAO.retrieve(prevID);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  ItemDAO itemDAO=ItemDAOFactory.getInstance(context);
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    Item next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(Item)results.get(lastIndex);
      results.remove(lastIndex);
    }
    Item prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        prev=itemDAO.retrieve(prevID);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9952065738415888
3528,"/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField();
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}","/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField(scope.isSecondLevel());
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}",0.994492525570417
3529,"/** 
 * Get the field for sorting associated with this index
 * @return
 * @throws BrowseException
 */
public String getSortField() throws BrowseException {
  String focusField;
  if (isMetadataIndex()) {
    focusField=""String_Node_Str"";
  }
 else {
    if (sortOption != null)     focusField=""String_Node_Str"" + sortOption.getNumber();
 else     focusField=""String_Node_Str"";
  }
  return focusField;
}","/** 
 * Get the field for sorting associated with this index
 * @return
 * @throws BrowseException
 */
public String getSortField(boolean isSecondLevel) throws BrowseException {
  String focusField;
  if (isMetadataIndex() && !isSecondLevel) {
    focusField=""String_Node_Str"";
  }
 else {
    if (sortOption != null)     focusField=""String_Node_Str"" + sortOption.getNumber();
 else     focusField=""String_Node_Str"";
  }
  return focusField;
}",0.9539551357733176
3530,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getIdentifier().getCanonicalForm();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getIdentifier().getCanonicalForm();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getIdentifier().getCanonicalForm();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getIdentifier().getCanonicalForm();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.988626248640095
3531,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField();
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField();
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=OrderFormat.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
      dao.setFilterValuePartial(scope.getFilterValuePartial());
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField(scope.isSecondLevel());
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9953302201467644
3532,"/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField();
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}","/** 
 * Perform a limited browse, which only returns the results requested,  without any extraneous information.  To perform a full browse, use BrowseEngine.browse() above.  This supports Item browse only, and does not currently support focus or values.  This method is used, for example, to generate the Recently Submitted Items results.
 * @param bs	the scope of the browse
 * @return		the results of the browse
 */
public BrowseInfo browseMini(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  this.scope=bs;
  browseIndex=scope.getBrowseIndex();
  dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
  dao.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    if (scope.inCollection()) {
      Collection col=(Collection)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(col.getID());
    }
 else     if (scope.inCommunity()) {
      Community com=(Community)scope.getBrowseContainer();
      dao.setContainerIDField(""String_Node_Str"");
      dao.setContainerID(com.getID());
    }
  }
  dao.setLimit(scope.getResultsPerPage());
  String orderBy=browseIndex.getSortField(scope.isSecondLevel());
  if (scope.getSortBy() > 0) {
    orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
  }
  dao.setOrderField(orderBy);
  List results=dao.doQuery();
  BrowseInfo browseInfo=new BrowseInfo(results,0,scope.getResultsPerPage(),0);
  browseInfo.setBrowseIndex(browseIndex);
  browseInfo.setSortOption(scope.getSortOption());
  browseInfo.setAscending(scope.isAscending());
  if (scope.inCollection() || scope.inCommunity()) {
    browseInfo.setBrowseContainer(scope.getBrowseContainer());
  }
  browseInfo.setResultsPerPage(scope.getResultsPerPage());
  browseInfo.setEtAl(scope.getEtAl());
  return browseInfo;
}",0.994492525570417
3533,"/** 
 * Get the field for sorting associated with this index
 * @return
 * @throws BrowseException
 */
public String getSortField() throws BrowseException {
  String focusField;
  if (isMetadataIndex()) {
    focusField=""String_Node_Str"";
  }
 else {
    if (sortOption != null)     focusField=""String_Node_Str"" + sortOption.getNumber();
 else     focusField=""String_Node_Str"";
  }
  return focusField;
}","/** 
 * Get the field for sorting associated with this index
 * @return
 * @throws BrowseException
 */
public String getSortField(boolean isSecondLevel) throws BrowseException {
  String focusField;
  if (isMetadataIndex() && !isSecondLevel) {
    focusField=""String_Node_Str"";
  }
 else {
    if (sortOption != null)     focusField=""String_Node_Str"" + sortOption.getNumber();
 else     focusField=""String_Node_Str"";
  }
  return focusField;
}",0.9539551357733176
3534,"/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}","/** 
 * Create a BrowserScope from the current request
 * @param context The database context
 * @param request The servlet request
 * @param response The servlet response
 * @return A BrowserScope for the current parameters
 * @throws ServletException
 * @throws IOException
 * @throws SQLException
 * @throws AuthorizeException
 */
protected BrowserScope getBrowserScopeForRequest(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  try {
    String type=request.getParameter(""String_Node_Str"");
    String order=request.getParameter(""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"");
    String valueLang=request.getParameter(""String_Node_Str"");
    String month=request.getParameter(""String_Node_Str"");
    String year=request.getParameter(""String_Node_Str"");
    String startsWith=request.getParameter(""String_Node_Str"");
    String valueFocus=request.getParameter(""String_Node_Str"");
    String valueFocusLang=request.getParameter(""String_Node_Str"");
    int focus=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resultsperpage=UIUtil.getIntParameter(request,""String_Node_Str"");
    int sortBy=UIUtil.getIntParameter(request,""String_Node_Str"");
    int etAl=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    collection=UIUtil.getCollectionLocation(request);
    if (collection == null) {
      community=UIUtil.getCommunityLocation(request);
    }
    BrowseIndex bi=null;
    if (type != null && !""String_Node_Str"".equals(type)) {
      bi=BrowseIndex.getBrowseIndex(type);
    }
    if (bi == null) {
      if (sortBy > 0)       bi=BrowseIndex.getBrowseIndex(SortOption.getSortOption(sortBy));
 else       bi=BrowseIndex.getBrowseIndex(SortOption.getDefaultSortOption());
    }
    if (bi != null && sortBy == -1) {
      SortOption so=bi.getSortOption();
      if (so != null) {
        sortBy=so.getNumber();
      }
    }
 else     if (bi != null && bi.isItemIndex() && !bi.isInternalIndex()) {
      SortOption bso=bi.getSortOption();
      SortOption so=SortOption.getSortOption(sortBy);
      if (bso != null && bso != so) {
        BrowseIndex newBi=BrowseIndex.getBrowseIndex(so);
        if (newBi != null) {
          bi=newBi;
          type=bi.getName();
        }
      }
    }
    if (order == null && bi != null) {
      order=bi.getDefaultOrder();
    }
    if (resultsperpage == -1) {
      resultsperpage=20;
    }
    if (year != null && !""String_Node_Str"".equals(year) && !""String_Node_Str"".equals(year)) {
      startsWith=year;
      if ((month != null) && !""String_Node_Str"".equals(month) && !""String_Node_Str"".equals(month)) {
        if (""String_Node_Str"".equals(order)) {
          month=Integer.toString((Integer.parseInt(month) - 1));
        }
        if (month.length() == 1) {
          month=""String_Node_Str"" + month;
        }
        startsWith=year + ""String_Node_Str"" + month;
      }
    }
    int level=0;
    if (value != null) {
      level=1;
    }
    if (sortBy == -1) {
      sortBy=0;
    }
    if (etAl == -1) {
      int limitLine=ConfigurationManager.getIntProperty(""String_Node_Str"");
      if (limitLine != 0) {
        etAl=limitLine;
      }
    }
 else {
      if (etAl == 0) {
        etAl=-1;
      }
    }
    String comHandle=""String_Node_Str"";
    if (community != null) {
      comHandle=community.getHandle();
    }
    String colHandle=""String_Node_Str"";
    if (collection != null) {
      colHandle=collection.getHandle();
    }
    String arguments=""String_Node_Str"" + type + ""String_Node_Str""+ order+ ""String_Node_Str""+ value+ ""String_Node_Str""+ month+ ""String_Node_Str""+ year+ ""String_Node_Str""+ startsWith+ ""String_Node_Str""+ valueFocus+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ resultsperpage+ ""String_Node_Str""+ sortBy+ ""String_Node_Str""+ comHandle+ ""String_Node_Str""+ colHandle+ ""String_Node_Str""+ level+ ""String_Node_Str""+ etAl;
    log.info(LogManager.getHeader(context,""String_Node_Str"",arguments));
    BrowserScope scope=new BrowserScope(context);
    scope.setBrowseIndex(bi);
    scope.setOrder(order);
    scope.setFilterValue(value);
    scope.setFilterValueLang(valueLang);
    scope.setJumpToItem(focus);
    scope.setJumpToValue(valueFocus);
    scope.setJumpToValueLang(valueFocusLang);
    scope.setStartsWith(startsWith);
    scope.setResultsPerPage(resultsperpage);
    scope.setSortBy(sortBy);
    scope.setBrowseLevel(level);
    scope.setEtAl(etAl);
    if (community != null) {
      scope.setBrowseContainer(community);
    }
 else     if (collection != null) {
      scope.setBrowseContainer(collection);
    }
    if (bi.isMetadataIndex() && scope.isSecondLevel() && scope.getSortBy() <= 0) {
      scope.setSortBy(1);
    }
    return scope;
  }
 catch (  SortException se) {
    log.error(""String_Node_Str"",se);
    throw new ServletException(se);
  }
catch (  BrowseException e) {
    log.error(""String_Node_Str"",e);
    throw new ServletException(e);
  }
}",0.988521808563729
3535,"/** 
 * Create Lucene document with all the shared fields initialized.
 * @param type Type of DSpace Object
 * @param id
 * @param handle
 * @param location @return
 */
private static Document buildDocument(int type,int id,String handle,String location){
  Document doc=new Document();
  doc.add(new Field(LAST_INDEXED_FIELD,Long.toString(System.currentTimeMillis()),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(id),Field.Store.YES,Field.Index.NO));
  if (handle != null) {
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.YES,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.YES,Field.Index.UN_TOKENIZED));
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.NO,Field.Index.TOKENIZED));
  }
  if (location != null) {
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
  }
  return doc;
}","/** 
 * Create Lucene document with all the shared fields initialized.
 * @param type Type of DSpace Object
 * @param id
 * @param handle
 * @param location @return
 */
private static Document buildDocument(int type,int id,String handle,String location){
  Document doc=new Document();
  doc.add(new Field(LAST_INDEXED_FIELD,Long.toString(System.currentTimeMillis()),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(id),Field.Store.YES,Field.Index.NO));
  if (handle != null) {
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.YES,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.YES,Field.Index.UN_TOKENIZED));
    doc.add(new Field(""String_Node_Str"",handle,Field.Store.NO,Field.Index.TOKENIZED));
  }
  if (location != null) {
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
  }
  return doc;
}",0.7960526315789473
3536,"/** 
 * Read metadata about a table from the database.
 * @param table The RDBMS table.
 * @return A map of information about the columns. The key is the name ofthe column, a String; the value is a ColumnInfo object.
 * @exception SQLException If there is a problem retrieving information from the RDBMS.
 */
private static Map retrieveColumnInfo(String table) throws SQLException {
  Connection connection=null;
  try {
    connection=getConnection();
    DatabaseMetaData metadata=connection.getMetaData();
    HashMap results=new HashMap();
    int max=metadata.getMaxTableNameLength();
    String tname=(table.length() >= max) ? table.substring(0,max - 1) : table;
    ResultSet pkcolumns=metadata.getPrimaryKeys(null,null,tname);
    Set pks=new HashSet();
    while (pkcolumns.next())     pks.add(pkcolumns.getString(4));
    ResultSet columns=metadata.getColumns(null,null,tname,null);
    while (columns.next()) {
      String column=columns.getString(4);
      ColumnInfo cinfo=new ColumnInfo();
      cinfo.setName(column);
      cinfo.setType((int)columns.getShort(5));
      if (pks.contains(column)) {
        cinfo.setIsPrimaryKey(true);
      }
      results.put(column,cinfo);
    }
    return results;
  }
  finally {
    if (connection != null) {
      connection.close();
    }
  }
}","/** 
 * Read metadata about a table from the database.
 * @param table The RDBMS table.
 * @return A map of information about the columns. The key is the name ofthe column, a String; the value is a ColumnInfo object.
 * @exception SQLException If there is a problem retrieving information from the RDBMS.
 */
private static Map retrieveColumnInfo(String table) throws SQLException {
  Connection connection=null;
  try {
    String schema=ConfigurationManager.getProperty(""String_Node_Str"");
    connection=getConnection();
    DatabaseMetaData metadata=connection.getMetaData();
    HashMap results=new HashMap();
    int max=metadata.getMaxTableNameLength();
    String tname=(table.length() >= max) ? table.substring(0,max - 1) : table;
    ResultSet pkcolumns=metadata.getPrimaryKeys(null,schema,tname);
    Set pks=new HashSet();
    while (pkcolumns.next())     pks.add(pkcolumns.getString(4));
    ResultSet columns=metadata.getColumns(null,schema,tname,null);
    while (columns.next()) {
      String column=columns.getString(4);
      ColumnInfo cinfo=new ColumnInfo();
      cinfo.setName(column);
      cinfo.setType((int)columns.getShort(5));
      if (pks.contains(column)) {
        cinfo.setIsPrimaryKey(true);
      }
      results.put(column,cinfo);
    }
    return results;
  }
  finally {
    if (connection != null) {
      connection.close();
    }
  }
}",0.9660321015304218
3537,"/** 
 * Create Lucene document with all the shared fields initialized.
 * @param type Type of DSpace Object
 * @param id
 * @param uri
 * @param location
 * @return
 */
private static Document buildDocument(int type,int id,String uri,String location){
  Document doc=new Document();
  doc.add(new Field(LAST_INDEXED_FIELD,Long.toString(System.currentTimeMillis()),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(id),Field.Store.YES,Field.Index.NO));
  if (uri != null) {
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.YES,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.YES,Field.Index.UN_TOKENIZED));
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.NO,Field.Index.TOKENIZED));
  }
  if (location != null) {
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
  }
  return doc;
}","/** 
 * Create Lucene document with all the shared fields initialized.
 * @param type Type of DSpace Object
 * @param id
 * @param uri
 * @param location
 * @return
 */
private static Document buildDocument(int type,int id,String uri,String location){
  Document doc=new Document();
  doc.add(new Field(LAST_INDEXED_FIELD,Long.toString(System.currentTimeMillis()),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.NO));
  doc.add(new Field(""String_Node_Str"",Integer.toString(type),Field.Store.YES,Field.Index.UN_TOKENIZED));
  doc.add(new Field(""String_Node_Str"",Integer.toString(id),Field.Store.YES,Field.Index.NO));
  if (uri != null) {
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.YES,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.YES,Field.Index.UN_TOKENIZED));
    doc.add(new Field(""String_Node_Str"",uri,Field.Store.NO,Field.Index.TOKENIZED));
  }
  if (location != null) {
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
    doc.add(new Field(""String_Node_Str"",location,Field.Store.NO,Field.Index.TOKENIZED));
  }
  return doc;
}",0.7960033305578684
3538,"/** 
 * Read metadata about a table from the database.
 * @param table The RDBMS table.
 * @return A map of information about the columns. The key is the name ofthe column, a String; the value is a ColumnInfo object.
 * @exception SQLException If there is a problem retrieving information from the RDBMS.
 */
private static Map retrieveColumnInfo(String table) throws SQLException {
  Connection connection=null;
  try {
    connection=getConnection();
    DatabaseMetaData metadata=connection.getMetaData();
    HashMap results=new HashMap();
    int max=metadata.getMaxTableNameLength();
    String tname=(table.length() >= max) ? table.substring(0,max - 1) : table;
    ResultSet pkcolumns=metadata.getPrimaryKeys(null,null,tname);
    Set pks=new HashSet();
    while (pkcolumns.next())     pks.add(pkcolumns.getString(4));
    ResultSet columns=metadata.getColumns(null,null,tname,null);
    while (columns.next()) {
      String column=columns.getString(4);
      ColumnInfo cinfo=new ColumnInfo();
      cinfo.setName(column);
      cinfo.setType((int)columns.getShort(5));
      if (pks.contains(column)) {
        cinfo.setIsPrimaryKey(true);
      }
      results.put(column,cinfo);
    }
    return results;
  }
  finally {
    if (connection != null) {
      connection.close();
    }
  }
}","/** 
 * Read metadata about a table from the database.
 * @param table The RDBMS table.
 * @return A map of information about the columns. The key is the name ofthe column, a String; the value is a ColumnInfo object.
 * @exception SQLException If there is a problem retrieving information from the RDBMS.
 */
private static Map retrieveColumnInfo(String table) throws SQLException {
  Connection connection=null;
  try {
    String schema=ConfigurationManager.getProperty(""String_Node_Str"");
    connection=getConnection();
    DatabaseMetaData metadata=connection.getMetaData();
    HashMap results=new HashMap();
    int max=metadata.getMaxTableNameLength();
    String tname=(table.length() >= max) ? table.substring(0,max - 1) : table;
    ResultSet pkcolumns=metadata.getPrimaryKeys(null,schema,tname);
    Set pks=new HashSet();
    while (pkcolumns.next())     pks.add(pkcolumns.getString(4));
    ResultSet columns=metadata.getColumns(null,schema,tname,null);
    while (columns.next()) {
      String column=columns.getString(4);
      ColumnInfo cinfo=new ColumnInfo();
      cinfo.setName(column);
      cinfo.setType((int)columns.getShort(5));
      if (pks.contains(column)) {
        cinfo.setIsPrimaryKey(true);
      }
      results.put(column,cinfo);
    }
    return results;
  }
  finally {
    if (connection != null) {
      connection.close();
    }
  }
}",0.9660321015304218
3539,"public static DSpaceIdentifier resolve(Context context,String str){
  DSpaceIdentifier dsi=null;
  if (dsi == null) {
    dsi=IdentifierFactory.resolveAsURLSubstring(context,str);
  }
  if (dsi == null) {
    dsi=IdentifierFactory.resolve(context,str);
  }
  return dsi;
}","public static DSpaceIdentifier resolve(Context context,String str){
  DSpaceIdentifier dsi=null;
  if (dsi == null) {
    dsi=IdentifierFactory.resolveAsURLSubstring(context,str);
  }
  if (dsi == null) {
    dsi=IdentifierFactory.resolveCanonical(context,str);
  }
  return dsi;
}",0.9837251356238698
3540,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  if (buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    return STATUS_COMPLETE;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    if (buttonPressed.equals(CANCEL_EDIT_BUTTON)) {
      subInfo.setBitstream(null);
      return STATUS_EDIT_COMPLETE;
    }
 else {
      Bitstream b=Bitstream.find(context,Integer.parseInt(request.getParameter(""String_Node_Str"")));
      subInfo.setBitstream(b);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    String bitstreamID=buttonPressed.substring(""String_Node_Str"".length());
    Bitstream b=Bitstream.find(context,Integer.parseInt(bitstreamID));
    subInfo.setBitstream(b);
    return STATUS_EDIT_BITSTREAM;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    if (request.getParameter(""String_Node_Str"") != null) {
      String[] removeIDs=request.getParameterValues(""String_Node_Str"");
      for (int i=0; i < removeIDs.length; i++) {
        int id=Integer.parseInt(removeIDs[i]);
        int status=processRemoveFile(context,item,id);
        if (status != STATUS_COMPLETE)         return status;
      }
      subInfo.setBitstream(null);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    int id=Integer.parseInt(buttonPressed.substring(14));
    int status=processRemoveFile(context,item,id);
    if (status != STATUS_COMPLETE)     return status;
    subInfo.setBitstream(null);
  }
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      int status=processUploadFile(context,request,response,subInfo);
      if (status != STATUS_COMPLETE)       return status;
    }
  }
  String fileDescription=request.getParameter(""String_Node_Str"");
  if (fileDescription != null && fileDescription.length() > 0) {
    int status=processSaveFileDescription(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  int formatTypeID=Util.getIntParameter(request,""String_Node_Str"");
  String formatDesc=request.getParameter(""String_Node_Str"");
  if (formatTypeID >= 0 || (formatDesc != null && formatDesc.length() > 0)) {
    int status=processSaveFileFormat(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    bundles[0].setPrimaryBitstreamID(new Integer(request.getParameter(""String_Node_Str"")).intValue());
    bundles[0].update();
  }
  boolean allowEmptyItems=(request.getParameter(""String_Node_Str"") != null);
  if (!allowEmptyItems) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    if (bundles.length == 0) {
      return STATUS_NO_FILES_ERROR;
    }
 else {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      if (bitstreams.length == 0) {
        return STATUS_NO_FILES_ERROR;
      }
    }
  }
  context.commit();
  return STATUS_COMPLETE;
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  if (buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    return STATUS_COMPLETE;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    if (buttonPressed.equals(CANCEL_EDIT_BUTTON)) {
      subInfo.setBitstream(null);
      return STATUS_EDIT_COMPLETE;
    }
 else {
      Bitstream b=Bitstream.find(context,Integer.parseInt(request.getParameter(""String_Node_Str"")));
      subInfo.setBitstream(b);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    String bitstreamID=buttonPressed.substring(""String_Node_Str"".length());
    Bitstream b=Bitstream.find(context,Integer.parseInt(bitstreamID));
    subInfo.setBitstream(b);
    return STATUS_EDIT_BITSTREAM;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    if (request.getParameter(""String_Node_Str"") != null) {
      String[] removeIDs=request.getParameterValues(""String_Node_Str"");
      for (int i=0; i < removeIDs.length; i++) {
        int id=Integer.parseInt(removeIDs[i]);
        int status=processRemoveFile(context,item,id);
        if (status != STATUS_COMPLETE)         return status;
      }
      subInfo.setBitstream(null);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    int id=Integer.parseInt(buttonPressed.substring(14));
    int status=processRemoveFile(context,item,id);
    if (status != STATUS_COMPLETE)     return status;
    subInfo.setBitstream(null);
  }
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      int status=processUploadFile(context,request,response,subInfo);
      if (status != STATUS_COMPLETE)       return status;
    }
  }
  String fileDescription=request.getParameter(""String_Node_Str"");
  if (fileDescription != null && fileDescription.length() > 0) {
    int status=processSaveFileDescription(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  int formatTypeID=Util.getIntParameter(request,""String_Node_Str"");
  String formatDesc=request.getParameter(""String_Node_Str"");
  if (formatTypeID >= 0 || (formatDesc != null && formatDesc.length() > 0)) {
    int status=processSaveFileFormat(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    bundles[0].setPrimaryBitstreamID(new Integer(request.getParameter(""String_Node_Str"")).intValue());
    bundles[0].update();
  }
  boolean allowEmptyItems=(request.getParameter(SUBMIT_SKIP_BUTTON) != null);
  if (!allowEmptyItems) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    if (bundles.length == 0) {
      return STATUS_NO_FILES_ERROR;
    }
 else {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      if (bitstreams.length == 0) {
        return STATUS_NO_FILES_ERROR;
      }
    }
  }
  context.commit();
  return STATUS_COMPLETE;
}",0.9960043588812204
3541,"/** 
 * Forward processing to the specified step.
 * @param context DSpace context
 * @param request the request object
 * @param response the response object
 * @param subInfo SubmissionInfo pertaining to this submission
 * @param stepNumber The number of the step to perform
 */
private void doStep(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int stepNumber) throws ServletException, IOException, SQLException, AuthorizeException {
  if (subInfo.getSubmissionConfig() != null) {
    currentStepConfig=subInfo.getSubmissionConfig().getStep(stepNumber);
  }
 else {
    log.fatal(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + stepNumber + ""String_Node_Str""));
    JSPManager.showInternalError(request,response);
  }
  if (!subInfo.isInWorkflow() && (currentStepConfig.getStepNumber() > getStepReached(subInfo))) {
    userHasReached(subInfo,currentStepConfig.getStepNumber());
    context.commit();
    setBeginningOfStep(request,true);
  }
  saveCurrentStepConfig(request,currentStepConfig);
  log.debug(""String_Node_Str"" + currentStepConfig.getProcessingClassName() + ""String_Node_Str"");
  try {
    JSPStepManager stepManager=JSPStepManager.loadStep(currentStepConfig.getProcessingClassName());
    boolean stepFinished=stepManager.processStep(context,request,response,subInfo);
    if (stepFinished) {
      subInfo=getSubmissionInfo(context,request);
      doNextStep(context,request,response,subInfo);
    }
 else {
      context.complete();
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + currentStepConfig.getProcessingClassName() + ""String_Node_Str"",e);
    JSPManager.showInternalError(request,response);
  }
}","/** 
 * Forward processing to the specified step.
 * @param context DSpace context
 * @param request the request object
 * @param response the response object
 * @param subInfo SubmissionInfo pertaining to this submission
 * @param stepNumber The number of the step to perform
 */
private void doStep(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int stepNumber) throws ServletException, IOException, SQLException, AuthorizeException {
  if (subInfo.getSubmissionConfig() != null) {
    currentStepConfig=subInfo.getSubmissionConfig().getStep(stepNumber);
  }
 else {
    log.fatal(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + stepNumber + ""String_Node_Str""));
    JSPManager.showInternalError(request,response);
  }
  if (!subInfo.isInWorkflow() && (currentStepConfig.getStepNumber() > getStepReached(subInfo))) {
    userHasReached(subInfo,currentStepConfig.getStepNumber());
    context.commit();
    setBeginningOfStep(request,true);
  }
  saveCurrentStepConfig(request,currentStepConfig);
  log.debug(""String_Node_Str"" + currentStepConfig.getProcessingClassName() + ""String_Node_Str"");
  try {
    JSPStepManager stepManager=JSPStepManager.loadStep(currentStepConfig.getProcessingClassName());
    boolean stepFinished=stepManager.processStep(context,request,response,subInfo);
    if (stepFinished) {
      if (request instanceof FileUploadRequest) {
        request=((FileUploadRequest)request).getOriginalRequest();
      }
      subInfo=getSubmissionInfo(context,request);
      doNextStep(context,request,response,subInfo);
    }
 else {
      context.complete();
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + currentStepConfig.getProcessingClassName() + ""String_Node_Str"",e);
    JSPManager.showInternalError(request,response);
  }
}",0.9647986482680936
3542,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  FileUploadRequest wrapper=null;
  String filePath=null;
  InputStream fileInputStream=null;
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      try {
        if (Class.forName(""String_Node_Str"").isInstance(request)) {
          wrapper=(FileUploadRequest)request;
        }
 else {
          wrapper=new FileUploadRequest(request);
        }
        File temp=wrapper.getFile(""String_Node_Str"");
        if (temp != null && temp.length() > 0) {
          fileInputStream=new BufferedInputStream(new FileInputStream(temp));
          filePath=wrapper.getFilesystemName(""String_Node_Str"");
        }
        temp.delete();
        request.setAttribute(""String_Node_Str"",filePath);
        request.setAttribute(""String_Node_Str"",fileInputStream);
        request.setAttribute(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
      }
 catch (      IOException ie) {
        log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ie);
      }
catch (      Exception e) {
        throw new ServletException(e);
      }
    }
  }
  return super.doProcessing(context,request,response,subInfo);
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  FileUploadRequest wrapper=null;
  String filePath=null;
  InputStream fileInputStream=null;
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      try {
        if (Class.forName(""String_Node_Str"").isInstance(request)) {
          wrapper=(FileUploadRequest)request;
        }
 else {
          wrapper=new FileUploadRequest(request);
        }
        File temp=wrapper.getFile(""String_Node_Str"");
        if (temp != null && temp.length() > 0) {
          fileInputStream=new BufferedInputStream(new FileInputStream(temp));
          filePath=wrapper.getFilesystemName(""String_Node_Str"");
          temp.delete();
        }
        request.setAttribute(""String_Node_Str"",filePath);
        request.setAttribute(""String_Node_Str"",fileInputStream);
        request.setAttribute(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
      }
 catch (      IOException ie) {
        log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ie);
      }
catch (      Exception e) {
        throw new ServletException(e);
      }
    }
  }
  return super.doProcessing(context,request,response,subInfo);
}",0.9896640826873384
3543,"/** 
 * Do any post-processing after the step's backend processing occurred (in the doProcessing() method). <P> It is this method's job to determine whether processing completed successfully, or display another JSP informing the users of any potential problems/errors. <P> If this step doesn't require user interaction OR you are solely using Manakin for your user interface, then this method may be left EMPTY, since all step processing should occur in the doProcessing() method.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @param status any status/errors reported by doProcessing() method
 */
public void doPostProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int status) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,NEXT_BUTTON);
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=subInfo.getSubmissionItem().getItem().getBundles(""String_Node_Str"");
    if (bundles.length > 0) {
      showUploadFileList(context,request,response,subInfo,true,false);
    }
    return;
  }
  if (status != STATUS_COMPLETE) {
    if (status == STATUS_INTEGRITY_ERROR) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
 else     if (status == STATUS_UPLOAD_ERROR) {
      if (subInfo != null) {
        Collection c=subInfo.getSubmissionItem().getCollection();
        DCInputsReader inputsReader=new DCInputsReader();
        request.setAttribute(""String_Node_Str"",inputsReader.getInputs(c.getHandle()));
      }
      JSPStepManager.showJSP(request,response,subInfo,UPLOAD_ERROR_JSP);
    }
 else     if (status == STATUS_UNKNOWN_FORMAT) {
      showGetFileFormat(context,request,response,subInfo);
    }
  }
  if (status == STATUS_COMPLETE && buttonPressed.equals(NEXT_BUTTON)) {
    return;
  }
  if (buttonPressed.equals(SUBMIT_MORE_BUTTON)) {
    showChooseFile(context,request,response,subInfo);
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    showUploadFileList(context,request,response,subInfo,false,true);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(16));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showFileDescription(context,request,response,subInfo);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(14));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showGetFileFormat(context,request,response,subInfo);
  }
 else {
    String contentType=request.getContentType();
    boolean fileUpload=false;
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1))     fileUpload=true;
    showUploadPage(context,request,response,subInfo,fileUpload);
  }
}","/** 
 * Do any post-processing after the step's backend processing occurred (in the doProcessing() method). <P> It is this method's job to determine whether processing completed successfully, or display another JSP informing the users of any potential problems/errors. <P> If this step doesn't require user interaction OR you are solely using Manakin for your user interface, then this method may be left EMPTY, since all step processing should occur in the doProcessing() method.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @param status any status/errors reported by doProcessing() method
 */
public void doPostProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int status) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,NEXT_BUTTON);
  if (buttonPressed.equalsIgnoreCase(SUBMIT_SKIP_BUTTON)) {
    Bundle[] bundles=subInfo.getSubmissionItem().getItem().getBundles(""String_Node_Str"");
    if (bundles.length > 0) {
      showUploadFileList(context,request,response,subInfo,true,false);
    }
    return;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    showUploadPage(context,request,response,subInfo,false);
  }
  if (status != STATUS_COMPLETE) {
    if (status == STATUS_INTEGRITY_ERROR) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
 else     if (status == STATUS_UPLOAD_ERROR || status == STATUS_NO_FILES_ERROR) {
      if (buttonPressed.startsWith(""String_Node_Str"")) {
        showUploadPage(context,request,response,subInfo,false);
      }
 else {
        if (subInfo != null) {
          Collection c=subInfo.getSubmissionItem().getCollection();
          DCInputsReader inputsReader=new DCInputsReader();
          request.setAttribute(""String_Node_Str"",inputsReader.getInputs(c.getHandle()));
        }
        JSPStepManager.showJSP(request,response,subInfo,UPLOAD_ERROR_JSP);
      }
    }
 else     if (status == STATUS_UNKNOWN_FORMAT) {
      showGetFileFormat(context,request,response,subInfo);
    }
  }
  if (status == STATUS_COMPLETE && buttonPressed.equals(NEXT_BUTTON)) {
    return;
  }
  if (buttonPressed.equals(SUBMIT_MORE_BUTTON)) {
    showChooseFile(context,request,response,subInfo);
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    showUploadFileList(context,request,response,subInfo,false,true);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(16));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showFileDescription(context,request,response,subInfo);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(14));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showGetFileFormat(context,request,response,subInfo);
  }
 else {
    String contentType=request.getContentType();
    boolean fileUpload=false;
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1))     fileUpload=true;
    showUploadPage(context,request,response,subInfo,fileUpload);
  }
}",0.9187725631768952
3544,"/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  if (buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    return STATUS_COMPLETE;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    if (buttonPressed.equals(CANCEL_EDIT_BUTTON)) {
      subInfo.setBitstream(null);
      return STATUS_EDIT_COMPLETE;
    }
 else {
      Bitstream b=Bitstream.find(context,Integer.parseInt(request.getParameter(""String_Node_Str"")));
      subInfo.setBitstream(b);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    String bitstreamID=buttonPressed.substring(""String_Node_Str"".length());
    Bitstream b=Bitstream.find(context,Integer.parseInt(bitstreamID));
    subInfo.setBitstream(b);
    return STATUS_EDIT_BITSTREAM;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    if (request.getParameter(""String_Node_Str"") != null) {
      String[] removeIDs=request.getParameterValues(""String_Node_Str"");
      for (int i=0; i < removeIDs.length; i++) {
        int id=Integer.parseInt(removeIDs[i]);
        int status=processRemoveFile(context,item,id);
        if (status != STATUS_COMPLETE)         return status;
      }
      subInfo.setBitstream(null);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    int id=Integer.parseInt(buttonPressed.substring(14));
    int status=processRemoveFile(context,item,id);
    if (status != STATUS_COMPLETE)     return status;
    subInfo.setBitstream(null);
  }
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      int status=processUploadFile(context,request,response,subInfo);
      if (status != STATUS_COMPLETE)       return status;
    }
  }
  String fileDescription=request.getParameter(""String_Node_Str"");
  if (fileDescription != null && fileDescription.length() > 0) {
    int status=processSaveFileDescription(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  int formatTypeID=Util.getIntParameter(request,""String_Node_Str"");
  String formatDesc=request.getParameter(""String_Node_Str"");
  if (formatTypeID >= 0 || (formatDesc != null && formatDesc.length() > 0)) {
    int status=processSaveFileFormat(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    bundles[0].setPrimaryBitstreamID(new Integer(request.getParameter(""String_Node_Str"")).intValue());
    bundles[0].update();
  }
  boolean allowEmptyItems=(request.getParameter(SUBMIT_SKIP_BUTTON) != null);
  if (!allowEmptyItems) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    if (bundles.length == 0) {
      return STATUS_NO_FILES_ERROR;
    }
 else {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      if (bitstreams.length == 0) {
        return STATUS_NO_FILES_ERROR;
      }
    }
  }
  context.commit();
  return STATUS_COMPLETE;
}","/** 
 * Do any processing of the information input by the user, and/or perform step processing (if no user interaction required) <P> It is this method's job to save any data to the underlying database, as necessary, and return error messages (if any) which can then be processed by the appropriate user interface (JSP-UI or XML-UI) <P> NOTE: If this step is a non-interactive step (i.e. requires no UI), then it should perform *all* of its processing in this method!
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @return Status or error flag which will be processed bydoPostProcessing() below! (if STATUS_COMPLETE or 0 is returned, no errors occurred!)
 */
public int doProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=Util.getSubmitButton(request,NEXT_BUTTON);
  Item item=subInfo.getSubmissionItem().getItem();
  if (buttonPressed.startsWith(PROGRESS_BAR_PREFIX)) {
    return STATUS_COMPLETE;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    if (buttonPressed.equals(CANCEL_EDIT_BUTTON)) {
      subInfo.setBitstream(null);
      return STATUS_EDIT_COMPLETE;
    }
 else {
      Bitstream b=Bitstream.find(context,Integer.parseInt(request.getParameter(""String_Node_Str"")));
      subInfo.setBitstream(b);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    String bitstreamID=buttonPressed.substring(""String_Node_Str"".length());
    Bitstream b=Bitstream.find(context,Integer.parseInt(bitstreamID));
    subInfo.setBitstream(b);
    return STATUS_EDIT_BITSTREAM;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    if (request.getParameter(""String_Node_Str"") != null) {
      String[] removeIDs=request.getParameterValues(""String_Node_Str"");
      for (int i=0; i < removeIDs.length; i++) {
        int id=Integer.parseInt(removeIDs[i]);
        int status=processRemoveFile(context,item,id);
        if (status != STATUS_COMPLETE)         return status;
      }
      subInfo.setBitstream(null);
    }
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    int id=Integer.parseInt(buttonPressed.substring(14));
    int status=processRemoveFile(context,item,id);
    if (status != STATUS_COMPLETE)     return status;
    subInfo.setBitstream(null);
  }
  String contentType=request.getContentType();
  if (buttonPressed.equalsIgnoreCase(SUBMIT_UPLOAD_BUTTON)) {
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1)) {
      int status=processUploadFile(context,request,response,subInfo);
      if (status != STATUS_COMPLETE)       return status;
    }
  }
  String fileDescription=request.getParameter(""String_Node_Str"");
  if (fileDescription != null && fileDescription.length() > 0) {
    int status=processSaveFileDescription(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  int formatTypeID=Util.getIntParameter(request,""String_Node_Str"");
  String formatDesc=request.getParameter(""String_Node_Str"");
  if (formatTypeID >= 0 || (formatDesc != null && formatDesc.length() > 0)) {
    int status=processSaveFileFormat(context,request,response,subInfo);
    if (status != STATUS_COMPLETE)     return status;
  }
  if (request.getParameter(""String_Node_Str"") != null) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    bundles[0].setPrimaryBitstreamID(new Integer(request.getParameter(""String_Node_Str"")).intValue());
    bundles[0].update();
  }
  boolean fileRequired=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
  if (fileRequired) {
    Bundle[] bundles=item.getBundles(""String_Node_Str"");
    if (bundles.length == 0) {
      return STATUS_NO_FILES_ERROR;
    }
 else {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      if (bitstreams.length == 0) {
        return STATUS_NO_FILES_ERROR;
      }
    }
  }
  context.commit();
  return STATUS_COMPLETE;
}",0.9787079603193806
3545,"/** 
 * Do any post-processing after the step's backend processing occurred (in the doProcessing() method). <P> It is this method's job to determine whether processing completed successfully, or display another JSP informing the users of any potential problems/errors. <P> If this step doesn't require user interaction OR you are solely using Manakin for your user interface, then this method may be left EMPTY, since all step processing should occur in the doProcessing() method.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @param status any status/errors reported by doProcessing() method
 */
public void doPostProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int status) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,UploadStep.NEXT_BUTTON);
  if (buttonPressed.equalsIgnoreCase(UploadStep.SUBMIT_SKIP_BUTTON)) {
    Bundle[] bundles=subInfo.getSubmissionItem().getItem().getBundles(""String_Node_Str"");
    if (bundles.length > 0) {
      showUploadFileList(context,request,response,subInfo,true,false);
    }
    return;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    showUploadPage(context,request,response,subInfo,false);
  }
  if (status != UploadStep.STATUS_COMPLETE) {
    if (status == UploadStep.STATUS_INTEGRITY_ERROR) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
 else     if (status == UploadStep.STATUS_UPLOAD_ERROR || status == UploadStep.STATUS_NO_FILES_ERROR) {
      if (buttonPressed.startsWith(""String_Node_Str"")) {
        showUploadPage(context,request,response,subInfo,false);
      }
 else {
        if (subInfo != null) {
          Collection c=subInfo.getSubmissionItem().getCollection();
          DCInputsReader inputsReader=new DCInputsReader();
          request.setAttribute(""String_Node_Str"",inputsReader.getInputs(c.getHandle()));
        }
        JSPStepManager.showJSP(request,response,subInfo,UPLOAD_ERROR_JSP);
      }
    }
 else     if (status == UploadStep.STATUS_UNKNOWN_FORMAT) {
      showGetFileFormat(context,request,response,subInfo);
    }
  }
  if (status == UploadStep.STATUS_COMPLETE && buttonPressed.equals(UploadStep.NEXT_BUTTON)) {
    return;
  }
  if (buttonPressed.equals(UploadStep.SUBMIT_MORE_BUTTON)) {
    showChooseFile(context,request,response,subInfo);
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    showUploadFileList(context,request,response,subInfo,false,true);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(16));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showFileDescription(context,request,response,subInfo);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(14));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showGetFileFormat(context,request,response,subInfo);
  }
 else {
    String contentType=request.getContentType();
    boolean fileUpload=false;
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1))     fileUpload=true;
    showUploadPage(context,request,response,subInfo,fileUpload);
  }
}","/** 
 * Do any post-processing after the step's backend processing occurred (in the doProcessing() method). <P> It is this method's job to determine whether processing completed successfully, or display another JSP informing the users of any potential problems/errors. <P> If this step doesn't require user interaction OR you are solely using Manakin for your user interface, then this method may be left EMPTY, since all step processing should occur in the doProcessing() method.
 * @param context current DSpace context
 * @param request current servlet request object
 * @param response current servlet response object
 * @param subInfo submission info object
 * @param status any status/errors reported by doProcessing() method
 */
public void doPostProcessing(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo,int status) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,UploadStep.NEXT_BUTTON);
  boolean fileRequired=ConfigurationManager.getBooleanProperty(""String_Node_Str"",true);
  if (buttonPressed.equalsIgnoreCase(UploadStep.SUBMIT_SKIP_BUTTON) || (buttonPressed.equalsIgnoreCase(UploadStep.SUBMIT_UPLOAD_BUTTON) && !fileRequired)) {
    Bundle[] bundles=subInfo.getSubmissionItem().getItem().getBundles(""String_Node_Str"");
    if (bundles.length > 0) {
      showUploadFileList(context,request,response,subInfo,true,false);
    }
    return;
  }
  if (buttonPressed.equalsIgnoreCase(""String_Node_Str"")) {
    showUploadPage(context,request,response,subInfo,false);
  }
  if (status != UploadStep.STATUS_COMPLETE) {
    if (status == UploadStep.STATUS_INTEGRITY_ERROR) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
 else     if (status == UploadStep.STATUS_UPLOAD_ERROR || status == UploadStep.STATUS_NO_FILES_ERROR) {
      if (buttonPressed.startsWith(""String_Node_Str"")) {
        showUploadPage(context,request,response,subInfo,false);
      }
 else {
        if (subInfo != null) {
          Collection c=subInfo.getSubmissionItem().getCollection();
          DCInputsReader inputsReader=new DCInputsReader();
          request.setAttribute(""String_Node_Str"",inputsReader.getInputs(c.getHandle()));
        }
        JSPStepManager.showJSP(request,response,subInfo,UPLOAD_ERROR_JSP);
      }
    }
 else     if (status == UploadStep.STATUS_UNKNOWN_FORMAT) {
      showGetFileFormat(context,request,response,subInfo);
    }
  }
  if (status == UploadStep.STATUS_COMPLETE && buttonPressed.equals(UploadStep.NEXT_BUTTON)) {
    return;
  }
  if (buttonPressed.equals(UploadStep.SUBMIT_MORE_BUTTON)) {
    showChooseFile(context,request,response,subInfo);
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    showUploadFileList(context,request,response,subInfo,false,true);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(16));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showFileDescription(context,request,response,subInfo);
  }
 else   if (buttonPressed.startsWith(""String_Node_Str"")) {
    Bitstream bitstream;
    try {
      int id=Integer.parseInt(buttonPressed.substring(14));
      bitstream=Bitstream.find(context,id);
    }
 catch (    NumberFormatException nfe) {
      bitstream=null;
    }
    if (bitstream == null) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
      JSPManager.showIntegrityError(request,response);
    }
    subInfo.setBitstream(bitstream);
    showGetFileFormat(context,request,response,subInfo);
  }
 else {
    String contentType=request.getContentType();
    boolean fileUpload=false;
    if ((contentType != null) && (contentType.indexOf(""String_Node_Str"") != -1))     fileUpload=true;
    showUploadPage(context,request,response,subInfo,fileUpload);
  }
}",0.9794520547945206
3546,"public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      TableRow row=DatabaseManager.create(context,""String_Node_Str"");
      row.setColumn(""String_Node_Str"",itemID);
      row.setColumn(""String_Node_Str"",commID[i]);
      DatabaseManager.update(context,row);
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      if (isFirstOccurrence(commID,i)) {
        TableRow row=DatabaseManager.create(context,""String_Node_Str"");
        row.setColumn(""String_Node_Str"",itemID);
        row.setColumn(""String_Node_Str"",commID[i]);
        DatabaseManager.update(context,row);
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9453499520613614
3547,"public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      TableRow row=DatabaseManager.create(context,""String_Node_Str"");
      row.setColumn(""String_Node_Str"",itemID);
      row.setColumn(""String_Node_Str"",commID[i]);
      DatabaseManager.update(context,row);
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      if (isFirstOccurrence(commID,i)) {
        TableRow row=DatabaseManager.create(context,""String_Node_Str"");
        row.setColumn(""String_Node_Str"",itemID);
        row.setColumn(""String_Node_Str"",commID[i]);
        DatabaseManager.update(context,row);
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9453499520613614
3548,"/** 
 * @deprecated
 * @return
 * @throws BrowseException
 */
public static String[] tables() throws BrowseException {
  BrowseIndex[] bis=getBrowseIndices();
  String[] returnTables=new String[bis.length + 1];
  for (int i=0; i < bis.length; i++) {
    returnTables[i]=bis[i].getTableName();
  }
  returnTables[bis.length]=""String_Node_Str"";
  return returnTables;
}","/** 
 * @deprecated
 * @return
 * @throws BrowseException
 */
public static String[] tables() throws BrowseException {
  BrowseIndex[] bis=getBrowseIndices();
  String[] returnTables=new String[bis.length];
  for (int i=0; i < bis.length; i++) {
    returnTables[i]=bis[i].getTableName();
  }
  return returnTables;
}",0.9064327485380116
3549,"public boolean itemRemoved(int itemID) throws BrowseException {
  for (int i=0; i < bis.length; i++) {
    log.debug(""String_Node_Str"" + itemID + ""String_Node_Str""+ bis[i].getTableName());
    removeIndex(itemID,bis[i]);
  }
  removeIndex(itemID,BrowseIndex.getItemBrowseIndex().getTableName());
  removeIndex(itemID,BrowseIndex.getWithdrawnBrowseIndex().getTableName());
  pruneIndexes();
  return true;
}","public boolean itemRemoved(int itemID) throws BrowseException {
  for (int i=0; i < bis.length; i++) {
    log.debug(""String_Node_Str"" + itemID + ""String_Node_Str""+ bis[i].getTableName());
    removeIndex(itemID,bis[i]);
  }
  removeIndex(itemID,BrowseIndex.getItemBrowseIndex().getTableName());
  removeIndex(itemID,BrowseIndex.getWithdrawnBrowseIndex().getTableName());
  dao.deleteCommunityMappings(itemID);
  pruneIndexes();
  return true;
}",0.954171562867215
3550,"/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
    removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    if (item.isArchived() && !item.isWithdrawn()) {
      Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
      dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
    }
 else     if (item.isWithdrawn()) {
      Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
      dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        removeIndex(item.getID(),bis[i]);
        if (item.isArchived() && !item.isWithdrawn()) {
          String[] md=bis[i].getMdBits();
          DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
          if (values != null) {
            for (int x=0; x < values.length; x++) {
              String nVal=BrowseOrder.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
              Map sortMap=getSortValues(item,itemMDMap);
              dao.insertIndex(bis[i].getTableName(),item.getID(),values[x].value,nVal,sortMap);
              if (bis[i].isMetadataIndex()) {
                int distinctID=dao.getDistinctID(bis[i].getTableName(true,false,false),values[x].value,nVal);
                dao.createDistinctMapping(bis[i].getMapName(),item.getID(),distinctID);
              }
            }
          }
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Index the given item
 * @param item  the item to index
 * @throws BrowseException
 */
private void indexItem(ItemMetadataProxy item) throws BrowseException {
  Map<String,String> itemMDMap=new HashMap<String,String>();
  try {
    removeIndex(item.getID(),BrowseIndex.getItemBrowseIndex().getTableName());
    removeIndex(item.getID(),BrowseIndex.getWithdrawnBrowseIndex().getTableName());
    dao.deleteCommunityMappings(item.getID());
    if (item.isArchived() && !item.isWithdrawn()) {
      Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
      dao.insertIndex(BrowseIndex.getItemBrowseIndex().getTableName(),item.getID(),sortMap);
      dao.insertCommunityMappings(item.getID());
    }
 else     if (item.isWithdrawn()) {
      Map<Integer,String> sortMap=getSortValues(item,itemMDMap);
      dao.insertIndex(BrowseIndex.getWithdrawnBrowseIndex().getTableName(),item.getID(),sortMap);
    }
    for (int i=0; i < bis.length; i++) {
      log.debug(""String_Node_Str"" + item.getID() + ""String_Node_Str""+ bis[i].getTableName());
      if (bis[i].isMetadataIndex()) {
        removeIndex(item.getID(),bis[i]);
        if (item.isArchived() && !item.isWithdrawn()) {
          String[] md=bis[i].getMdBits();
          DCValue[] values=item.getMetadata(md[0],md[1],md[2],Item.ANY);
          if (values != null) {
            for (int x=0; x < values.length; x++) {
              String nVal=BrowseOrder.makeSortString(values[x].value,values[x].language,bis[i].getDataType());
              Map sortMap=getSortValues(item,itemMDMap);
              dao.insertIndex(bis[i].getTableName(),item.getID(),values[x].value,nVal,sortMap);
              if (bis[i].isMetadataIndex()) {
                int distinctID=dao.getDistinctID(bis[i].getTableName(true,false,false),values[x].value,nVal);
                dao.createDistinctMapping(bis[i].getMapName(),item.getID(),distinctID);
              }
            }
          }
        }
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9762140733399404
3551,"public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      TableRow row=DatabaseManager.create(context,""String_Node_Str"");
      row.setColumn(""String_Node_Str"",itemID);
      row.setColumn(""String_Node_Str"",commID[i]);
      DatabaseManager.update(context,row);
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      if (isFirstOccurrence(commID,i)) {
        TableRow row=DatabaseManager.create(context,""String_Node_Str"");
        row.setColumn(""String_Node_Str"",itemID);
        row.setColumn(""String_Node_Str"",commID[i]);
        DatabaseManager.update(context,row);
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9453499520613614
3552,"public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      TableRow row=DatabaseManager.create(context,""String_Node_Str"");
      row.setColumn(""String_Node_Str"",itemID);
      row.setColumn(""String_Node_Str"",commID[i]);
      DatabaseManager.update(context,row);
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","public void insertCommunityMappings(int itemID) throws BrowseException {
  try {
    int[] commID=getAllCommunityIDs(itemID);
    for (int i=0; i < commID.length; i++) {
      if (isFirstOccurrence(commID,i)) {
        TableRow row=DatabaseManager.create(context,""String_Node_Str"");
        row.setColumn(""String_Node_Str"",itemID);
        row.setColumn(""String_Node_Str"",commID[i]);
        DatabaseManager.update(context,row);
      }
    }
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9453499520613614
3553,"/** 
 * @deprecated
 * @return
 * @throws BrowseException
 */
public static String[] tables() throws BrowseException {
  BrowseIndex[] bis=getBrowseIndices();
  String[] returnTables=new String[bis.length + 1];
  for (int i=0; i < bis.length; i++) {
    returnTables[i]=bis[i].getTableName();
  }
  returnTables[bis.length]=""String_Node_Str"";
  return returnTables;
}","/** 
 * @deprecated
 * @return
 * @throws BrowseException
 */
public static String[] tables() throws BrowseException {
  BrowseIndex[] bis=getBrowseIndices();
  String[] returnTables=new String[bis.length];
  for (int i=0; i < bis.length; i++) {
    returnTables[i]=bis[i].getTableName();
  }
  return returnTables;
}",0.9064327485380116
3554,"/** 
 * Setup the AspectGenerator. 
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  Integer aspectID=(Integer)request.getAttribute(ASPECT_ID);
  if (aspectID == null)   aspectID=0;
  aspectID++;
  request.setAttribute(ASPECT_ID,aspectID);
  String path=request.getServletPath();
  if (path.startsWith(PREFIX)) {
    path=path.substring(PREFIX.length());
  }
  String aspectPath=PROTOCOL + ""String_Node_Str"" + PREFIX+ aspectID+ ""String_Node_Str""+ path;
  getLogger().debug(""String_Node_Str"" + aspectPath);
  super.setup(resolver,objectModel,aspectPath,par);
}","/** 
 * Setup the AspectGenerator. 
 */
public void setup(SourceResolver resolver,Map objectModel,String src,Parameters par) throws ProcessingException, SAXException, IOException {
  Request request=ObjectModelHelper.getRequest(objectModel);
  Integer aspectID=(Integer)request.getAttribute(ASPECT_ID);
  if (aspectID == null)   aspectID=0;
  aspectID++;
  request.setAttribute(ASPECT_ID,aspectID);
  String path=request.getSitemapURI();
  String aspectPath=PROTOCOL + ""String_Node_Str"" + PREFIX+ aspectID+ ""String_Node_Str""+ path;
  getLogger().debug(""String_Node_Str"" + aspectPath);
  super.setup(resolver,objectModel,aspectPath,par);
}",0.9247787610619468
3555,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String extraPathInfo=null;
  DSpaceObject dso=null;
  String path=request.getPathInfo();
  DSpaceIdentifier di=IdentifierFactory.resolve(context,path);
  if (di == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + path));
    JSPManager.showInvalidIDError(request,response,path,-1);
  }
 else {
    String urlForm=di.getURLForm();
    int index=path.indexOf(urlForm);
    int startFrom=index + urlForm.length();
    if (startFrom < path.length()) {
      extraPathInfo=path.substring(startFrom);
    }
    dso=di.getObject(context);
    processDSpaceObject(context,request,response,dso,extraPathInfo);
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String extraPathInfo=null;
  DSpaceObject dso=null;
  String path=request.getPathInfo();
  DSpaceIdentifier di=IdentifierFactory.resolve(context,path);
  if (di != null) {
    dso=di.getObject(context);
  }
  if (dso == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + path));
    JSPManager.showInvalidIDError(request,response,path,-1);
  }
 else {
    String urlForm=di.getURLForm();
    int index=path.indexOf(urlForm);
    int startFrom=index + urlForm.length();
    if (startFrom < path.length()) {
      extraPathInfo=path.substring(startFrom);
    }
    processDSpaceObject(context,request,response,dso,extraPathInfo);
  }
}",0.931804465902233
3556,"public static void main(String[] argv) throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  CommandLineParser parser=new PosixParser();
  int status=0;
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  OptionBuilder.withLongOpt(""String_Node_Str"");
  OptionBuilder.withValueSeparator(',');
  OptionBuilder.withDescription(""String_Node_Str"" + ""String_Node_Str"" + MEDIA_FILTER_PLUGINS_KEY + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Option pluginOption=OptionBuilder.create('p');
  pluginOption.setArgs(Option.UNLIMITED_VALUES);
  options.addOption(pluginOption);
  CommandLine line=null;
  try {
    line=parser.parse(options,argv);
  }
 catch (  MissingArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    HelpFormatter myhelp=new HelpFormatter();
    myhelp.printHelp(""String_Node_Str"",options);
    System.exit(1);
  }
  if (line.hasOption('h')) {
    HelpFormatter myhelp=new HelpFormatter();
    myhelp.printHelp(""String_Node_Str"",options);
    System.exit(0);
  }
  if (line.hasOption('v')) {
    isVerbose=true;
  }
  if (line.hasOption('n')) {
    updateIndex=false;
  }
  if (line.hasOption('f')) {
    isForce=true;
  }
  if (line.hasOption('i')) {
    identifier=line.getOptionValue('i');
  }
  if (line.hasOption('m')) {
    max2Process=Integer.parseInt(line.getOptionValue('m'));
    if (max2Process <= 1) {
      System.out.println(""String_Node_Str"" + line.getOptionValue('m') + ""String_Node_Str"");
      max2Process=Integer.MAX_VALUE;
    }
  }
  String filterNames[]=null;
  if (line.hasOption('p')) {
    filterNames=line.getOptionValues('p');
    if (filterNames == null || filterNames.length == 0) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      HelpFormatter myhelp=new HelpFormatter();
      myhelp.printHelp(""String_Node_Str"",options);
      System.exit(1);
    }
  }
 else {
    String enabledPlugins=ConfigurationManager.getProperty(MEDIA_FILTER_PLUGINS_KEY);
    filterNames=enabledPlugins.split(""String_Node_Str"");
  }
  List filterList=new ArrayList();
  for (int i=0; i < filterNames.length; i++) {
    FormatFilter filter=(FormatFilter)PluginManager.getNamedPlugin(FormatFilter.class,filterNames[i]);
    if (filter == null) {
      System.err.println(""String_Node_Str"" + filterNames[i] + ""String_Node_Str"");
      System.exit(1);
    }
 else {
      filterList.add(filter);
      String filterClassName=filter.getClass().getName();
      String pluginName=null;
      if (SelfNamedPlugin.class.isAssignableFrom(filter.getClass())) {
        pluginName=((SelfNamedPlugin)filter).getPluginInstanceName();
      }
      String formats=ConfigurationManager.getProperty(FILTER_PREFIX + ""String_Node_Str"" + filterClassName+ (pluginName != null ? ""String_Node_Str"" + pluginName : ""String_Node_Str"")+ ""String_Node_Str""+ INPUT_FORMATS_SUFFIX);
      if (formats != null) {
        filterFormats.put(filterClassName + (pluginName != null ? FILTER_PLUGIN_SEPARATOR + pluginName : ""String_Node_Str""),Arrays.asList(formats.split(""String_Node_Str"")));
      }
    }
  }
  if (isVerbose) {
    System.out.println(""String_Node_Str"");
    java.util.Iterator i=filterFormats.keySet().iterator();
    while (i.hasNext()) {
      String filterName=(String)i.next();
      System.out.println(""String_Node_Str"" + filterName);
      String pluginName=null;
      if (filterName.contains(FILTER_PLUGIN_SEPARATOR)) {
        String[] fields=filterName.split(FILTER_PLUGIN_SEPARATOR);
        filterName=fields[0];
        pluginName=fields[1];
      }
      System.out.println(filterName + (pluginName != null ? ""String_Node_Str"" + pluginName + ""String_Node_Str"" : ""String_Node_Str""));
    }
  }
  filterClasses=(MediaFilter[])filterList.toArray(new MediaFilter[filterList.size()]);
  Context c=null;
  try {
    c=new Context();
    c.setIgnoreAuthorization(true);
    if (identifier == null) {
      applyFiltersAllItems(c);
    }
 else {
      DSpaceObject dso=HandleManager.resolveToObject(c,identifier);
      if (dso == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + identifier + ""String_Node_Str"");
      }
switch (dso.getType()) {
case Constants.COMMUNITY:
        applyFiltersCommunity(c,(Community)dso);
      break;
case Constants.COLLECTION:
    applyFiltersCollection(c,(Collection)dso);
  break;
case Constants.ITEM:
applyFiltersItem(c,(Item)dso);
break;
}
}
if (updateIndex) {
System.out.println(""String_Node_Str"");
DSIndexer.updateIndex(c);
}
c.complete();
c=null;
}
 catch (Exception e) {
status=1;
}
 finally {
if (c != null) {
c.abort();
}
}
System.exit(status);
}","public static void main(String[] argv) throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  CommandLineParser parser=new PosixParser();
  int status=0;
  Options options=new Options();
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  options.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  OptionBuilder.withLongOpt(""String_Node_Str"");
  OptionBuilder.withValueSeparator(',');
  OptionBuilder.withDescription(""String_Node_Str"" + ""String_Node_Str"" + MEDIA_FILTER_PLUGINS_KEY + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Option pluginOption=OptionBuilder.create('p');
  pluginOption.setArgs(Option.UNLIMITED_VALUES);
  options.addOption(pluginOption);
  CommandLine line=null;
  try {
    line=parser.parse(options,argv);
  }
 catch (  MissingArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    HelpFormatter myhelp=new HelpFormatter();
    myhelp.printHelp(""String_Node_Str"",options);
    System.exit(1);
  }
  if (line.hasOption('h')) {
    HelpFormatter myhelp=new HelpFormatter();
    myhelp.printHelp(""String_Node_Str"",options);
    System.exit(0);
  }
  if (line.hasOption('v')) {
    isVerbose=true;
  }
  if (line.hasOption('n')) {
    updateIndex=false;
  }
  if (line.hasOption('f')) {
    isForce=true;
  }
  if (line.hasOption('i')) {
    identifier=line.getOptionValue('i');
  }
  if (line.hasOption('m')) {
    max2Process=Integer.parseInt(line.getOptionValue('m'));
    if (max2Process <= 1) {
      System.out.println(""String_Node_Str"" + line.getOptionValue('m') + ""String_Node_Str"");
      max2Process=Integer.MAX_VALUE;
    }
  }
  String filterNames[]=null;
  if (line.hasOption('p')) {
    filterNames=line.getOptionValues('p');
    if (filterNames == null || filterNames.length == 0) {
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
      HelpFormatter myhelp=new HelpFormatter();
      myhelp.printHelp(""String_Node_Str"",options);
      System.exit(1);
    }
  }
 else {
    String enabledPlugins=ConfigurationManager.getProperty(MEDIA_FILTER_PLUGINS_KEY);
    filterNames=enabledPlugins.split(""String_Node_Str"");
  }
  List filterList=new ArrayList();
  for (int i=0; i < filterNames.length; i++) {
    FormatFilter filter=(FormatFilter)PluginManager.getNamedPlugin(FormatFilter.class,filterNames[i]);
    if (filter == null) {
      System.err.println(""String_Node_Str"" + filterNames[i] + ""String_Node_Str"");
      System.exit(1);
    }
 else {
      filterList.add(filter);
      String filterClassName=filter.getClass().getName();
      String pluginName=null;
      if (SelfNamedPlugin.class.isAssignableFrom(filter.getClass())) {
        pluginName=((SelfNamedPlugin)filter).getPluginInstanceName();
      }
      String formats=ConfigurationManager.getProperty(FILTER_PREFIX + ""String_Node_Str"" + filterClassName+ (pluginName != null ? ""String_Node_Str"" + pluginName : ""String_Node_Str"")+ ""String_Node_Str""+ INPUT_FORMATS_SUFFIX);
      if (formats != null) {
        filterFormats.put(filterClassName + (pluginName != null ? FILTER_PLUGIN_SEPARATOR + pluginName : ""String_Node_Str""),Arrays.asList(formats.split(""String_Node_Str"")));
      }
    }
  }
  if (isVerbose) {
    System.out.println(""String_Node_Str"");
    java.util.Iterator i=filterFormats.keySet().iterator();
    while (i.hasNext()) {
      String filterName=(String)i.next();
      System.out.println(""String_Node_Str"" + filterName);
      String pluginName=null;
      if (filterName.contains(FILTER_PLUGIN_SEPARATOR)) {
        String[] fields=filterName.split(FILTER_PLUGIN_SEPARATOR);
        filterName=fields[0];
        pluginName=fields[1];
      }
      System.out.println(filterName + (pluginName != null ? ""String_Node_Str"" + pluginName + ""String_Node_Str"" : ""String_Node_Str""));
    }
  }
  filterClasses=(FormatFilter[])filterList.toArray(new FormatFilter[filterList.size()]);
  Context c=null;
  try {
    c=new Context();
    c.setIgnoreAuthorization(true);
    if (identifier == null) {
      applyFiltersAllItems(c);
    }
 else {
      DSpaceObject dso=HandleManager.resolveToObject(c,identifier);
      if (dso == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + identifier + ""String_Node_Str"");
      }
switch (dso.getType()) {
case Constants.COMMUNITY:
        applyFiltersCommunity(c,(Community)dso);
      break;
case Constants.COLLECTION:
    applyFiltersCollection(c,(Collection)dso);
  break;
case Constants.ITEM:
applyFiltersItem(c,(Item)dso);
break;
}
}
if (updateIndex) {
System.out.println(""String_Node_Str"");
DSIndexer.updateIndex(c);
}
c.complete();
c=null;
}
 catch (Exception e) {
status=1;
}
 finally {
if (c != null) {
c.abort();
}
}
System.exit(status);
}",0.9978388998035363
3557,"/** 
 * processBitstream is a utility class that calls the virtual methods from the current MediaFilter class. It scans the bitstreams in an item, and decides if a bitstream has  already been filtered, and if not or if overWrite is set, invokes the  filter.
 * @param c context
 * @param item item containing bitstream to process
 * @param source source bitstream to process
 * @param mediaFilter MediaFilter to perform filtering
 * @return true if new rendition is created, false if rendition alreadyexists and overWrite is not set
 */
public static boolean processBitstream(Context c,Item item,Bitstream source,FormatFilter formatFilter) throws Exception {
  if (!formatFilter.preProcessBitstream(c,item,source))   return false;
  boolean overWrite=MediaFilterManager.isForce;
  String newName=formatFilter.getFilteredName(source.getName());
  Bitstream existingBitstream=null;
  Bundle targetBundle=null;
  Bundle[] bundles=item.getBundles(formatFilter.getBundleName());
  if (bundles.length > 0) {
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int j=0; j < bitstreams.length; j++) {
        if (bitstreams[j].getName().equals(newName)) {
          targetBundle=bundles[i];
          existingBitstream=bitstreams[j];
        }
      }
    }
  }
  if (!overWrite && (existingBitstream != null)) {
    System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
    return false;
  }
  InputStream destStream=formatFilter.getDestinationStream(source.retrieve());
  if (bundles.length < 1) {
    targetBundle=item.createBundle(formatFilter.getBundleName());
  }
 else {
    targetBundle=bundles[0];
  }
  Bitstream b=targetBundle.createBitstream(destStream);
  b.setName(newName);
  b.setSource(""String_Node_Str"" + formatFilter.getClass().getName() + ""String_Node_Str""+ DCDate.getCurrent()+ ""String_Node_Str"");
  b.setDescription(formatFilter.getDescription());
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(c,formatFilter.getFormatString());
  b.setFormat(bf);
  b.update();
  AuthorizeManager.removeAllPolicies(c,b);
  AuthorizeManager.inheritPolicies(c,source,b);
  if (existingBitstream != null) {
    targetBundle.removeBitstream(existingBitstream);
  }
  System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
  formatFilter.postProcessBitstream(c,item,b);
  return true;
}","/** 
 * processBitstream is a utility class that calls the virtual methods from the current MediaFilter class. It scans the bitstreams in an item, and decides if a bitstream has  already been filtered, and if not or if overWrite is set, invokes the  filter.
 * @param c context
 * @param item item containing bitstream to process
 * @param source source bitstream to process
 * @param formatFilter FormatFilter to perform filtering
 * @return true if new rendition is created, false if rendition alreadyexists and overWrite is not set
 */
public static boolean processBitstream(Context c,Item item,Bitstream source,FormatFilter formatFilter) throws Exception {
  if (!formatFilter.preProcessBitstream(c,item,source))   return false;
  boolean overWrite=MediaFilterManager.isForce;
  String newName=formatFilter.getFilteredName(source.getName());
  Bitstream existingBitstream=null;
  Bundle targetBundle=null;
  Bundle[] bundles=item.getBundles(formatFilter.getBundleName());
  if (bundles.length > 0) {
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int j=0; j < bitstreams.length; j++) {
        if (bitstreams[j].getName().equals(newName)) {
          targetBundle=bundles[i];
          existingBitstream=bitstreams[j];
        }
      }
    }
  }
  if (!overWrite && (existingBitstream != null)) {
    System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
    return false;
  }
  InputStream destStream=formatFilter.getDestinationStream(source.retrieve());
  if (bundles.length < 1) {
    targetBundle=item.createBundle(formatFilter.getBundleName());
  }
 else {
    targetBundle=bundles[0];
  }
  Bitstream b=targetBundle.createBitstream(destStream);
  b.setName(newName);
  b.setSource(""String_Node_Str"" + formatFilter.getClass().getName() + ""String_Node_Str""+ DCDate.getCurrent()+ ""String_Node_Str"");
  b.setDescription(formatFilter.getDescription());
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(c,formatFilter.getFormatString());
  b.setFormat(bf);
  b.update();
  AuthorizeManager.removeAllPolicies(c,b);
  AuthorizeManager.inheritPolicies(c,source,b);
  if (existingBitstream != null) {
    targetBundle.removeBitstream(existingBitstream);
  }
  System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
  formatFilter.postProcessBitstream(c,item,b);
  return true;
}",0.995517522412388
3558,"/** 
 * Get the count of the items in the given container.  If the configuration value webui.strengths.cache is equal to 'true' this will return the cached value if it exists.  If it is equal to 'false' it will count the number of items in the container in real time
 * @param dso
 * @return
 * @throws ItemCountException
 * @throws SQLException 
 */
public int getCount(DSpaceObject dso) throws ItemCountException {
  boolean useCache=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (useCache) {
    return dao.getCount(dso);
  }
  if (dso instanceof Collection) {
    try {
      return ((Collection)dso).countItems();
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
      throw new ItemCountException(e);
    }
  }
  if (dso instanceof Community) {
    try {
      return ((Collection)dso).countItems();
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
      throw new ItemCountException(e);
    }
  }
  return 0;
}","/** 
 * Get the count of the items in the given container.  If the configuration value webui.strengths.cache is equal to 'true' this will return the cached value if it exists.  If it is equal to 'false' it will count the number of items in the container in real time
 * @param dso
 * @return
 * @throws ItemCountException
 * @throws SQLException 
 */
public int getCount(DSpaceObject dso) throws ItemCountException {
  boolean useCache=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (useCache) {
    return dao.getCount(dso);
  }
  if (dso instanceof Collection) {
    try {
      return ((Collection)dso).countItems();
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
      throw new ItemCountException(e);
    }
  }
  if (dso instanceof Community) {
    try {
      return ((Community)dso).countItems();
    }
 catch (    SQLException e) {
      log.error(""String_Node_Str"",e);
      throw new ItemCountException(e);
    }
  }
  return 0;
}",0.9923896499238964
3559,"/** 
 * Get the style using the owning collection handle
 */
public String getStyleForItem(Item item) throws SQLException {
  Collection c=item.getOwningCollection();
  return getFromMap(c.getHandle());
}","/** 
 * Get the style using the owning collection handle
 */
public String getStyleForItem(Item item) throws SQLException {
  Collection c=item.getOwningCollection();
  if (c != null) {
    return getFromMap(c.getHandle());
  }
 else   return ""String_Node_Str"";
}",0.8736616702355461
3560,"public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  final HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
  final HttpServletRequest httpRequest=(HttpServletRequest)objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
  final Iterator authMethods=AuthenticationManager.authenticationMethodIterator();
  final String url=((AuthenticationMethod)authMethods.next()).loginPageURL(ContextUtil.obtainContext(objectModel),httpRequest,httpResponse);
  if (authMethods.hasNext()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (ConfigurationManager.getBooleanProperty(""String_Node_Str"")) {
    if (!httpRequest.isSecure()) {
      StringBuffer location=new StringBuffer(""String_Node_Str"");
      location.append(ConfigurationManager.getProperty(""String_Node_Str"")).append(url).append(httpRequest.getQueryString() == null ? ""String_Node_Str"" : (""String_Node_Str"" + httpRequest.getQueryString()));
      httpResponse.sendRedirect(location.toString());
    }
  }
 else {
    httpResponse.sendRedirect(url);
  }
  return new HashMap();
}","public Map act(Redirector redirector,SourceResolver resolver,Map objectModel,String source,Parameters parameters) throws Exception {
  final HttpServletResponse httpResponse=(HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
  final HttpServletRequest httpRequest=(HttpServletRequest)objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
  final Iterator authMethods=AuthenticationManager.authenticationMethodIterator();
  final String url=((AuthenticationMethod)authMethods.next()).loginPageURL(ContextUtil.obtainContext(objectModel),httpRequest,httpResponse);
  if (authMethods.hasNext()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (ConfigurationManager.getBooleanProperty(""String_Node_Str"")) {
    if (!httpRequest.isSecure()) {
      StringBuffer location=new StringBuffer(""String_Node_Str"");
      location.append(ConfigurationManager.getProperty(""String_Node_Str"")).append(url).append(httpRequest.getQueryString() == null ? ""String_Node_Str"" : (""String_Node_Str"" + httpRequest.getQueryString()));
      httpResponse.sendRedirect(location.toString());
    }
 else {
      httpResponse.sendRedirect(url);
    }
  }
 else {
    httpResponse.sendRedirect(url);
  }
  return new HashMap();
}",0.9786008230452676
3561,"public String createMetadata(Object nativeItem) throws CannotDisseminateFormatException {
  HarvestedItemInfo itemInfo=(HarvestedItemInfo)nativeItem;
  Item item=itemInfo.item;
  DCValue[] allDC=item.getDC(Item.ANY,Item.ANY,Item.ANY);
  StringBuffer metadata=new StringBuffer();
  metadata.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  metadata.append(""String_Node_Str"").append(hostName).append(""String_Node_Str"").append(item.getHandle()).append(""String_Node_Str"");
  for (int i=0; i < allDC.length; i++) {
    if (screened(allDC[i])) {
      String element=allDC[i].element;
      if (allDC[i].element.equals(""String_Node_Str"") && (allDC[i].qualifier != null) && allDC[i].qualifier.equals(""String_Node_Str"")) {
        element=""String_Node_Str"";
      }
      String value=allDC[i].value;
      int c=-1;
      while ((c=value.indexOf(""String_Node_Str"",c + 1)) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      while ((c=value.indexOf(""String_Node_Str"")) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      while ((c=value.indexOf(""String_Node_Str"")) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      metadata.append(""String_Node_Str"").append(element).append(""String_Node_Str"").append(value).append(""String_Node_Str"").append(element).append(""String_Node_Str"");
    }
  }
  Collection[] colls=null;
  Community[] comms=null;
  Bundle[] origBundles=null;
  Bundle[] thumbBundles=null;
  try {
    colls=item.getCollections();
    comms=item.getCommunities();
    origBundles=item.getBundles(""String_Node_Str"");
    thumbBundles=item.getBundles(""String_Node_Str"");
  }
 catch (  SQLException sqlE) {
    ;
  }
  for (int i=0; i < comms.length; i++) {
    metadata.append(""String_Node_Str"").append(comms[i].getMetadata(""String_Node_Str"")).append(""String_Node_Str"");
  }
  for (int j=0; j < colls.length; j++) {
    metadata.append(""String_Node_Str"").append(colls[j].getMetadata(""String_Node_Str"")).append(""String_Node_Str"");
  }
  if (origBundles.length > 0) {
    Bitstream[] bitstreams=origBundles[0].getBitstreams();
    for (int j=0; j < bitstreams.length; j++) {
      String tName=bitstreams[j].getName() + ""String_Node_Str"";
      Bitstream tb=thumbBundles[0].getBitstreamByName(tName);
      if (tb != null) {
        String thumbUrl=null;
        try {
          thumbUrl=baseUrl + ""String_Node_Str"" + tb.getID()+ ""String_Node_Str""+ Util.encodeBitstreamName(tb.getName(),Constants.DEFAULT_ENCODING);
        }
 catch (        Exception e) {
        }
        metadata.append(""String_Node_Str"").append(thumbUrl).append(""String_Node_Str"");
      }
    }
  }
  metadata.append(""String_Node_Str"");
  metadata.append(""String_Node_Str"");
  return metadata.toString();
}","public String createMetadata(Object nativeItem) throws CannotDisseminateFormatException {
  HarvestedItemInfo itemInfo=(HarvestedItemInfo)nativeItem;
  Item item=itemInfo.item;
  DCValue[] allDC=item.getDC(Item.ANY,Item.ANY,Item.ANY);
  StringBuffer metadata=new StringBuffer();
  metadata.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  metadata.append(""String_Node_Str"").append(hostName).append(""String_Node_Str"").append(item.getHandle()).append(""String_Node_Str"");
  for (int i=0; i < allDC.length; i++) {
    if (screened(allDC[i])) {
      String element=allDC[i].element;
      if (allDC[i].element.equals(""String_Node_Str"") && (allDC[i].qualifier != null) && allDC[i].qualifier.equals(""String_Node_Str"")) {
        element=""String_Node_Str"";
      }
      String value=allDC[i].value;
      int c=-1;
      while ((c=value.indexOf(""String_Node_Str"",c + 1)) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      while ((c=value.indexOf(""String_Node_Str"")) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      while ((c=value.indexOf(""String_Node_Str"")) > -1) {
        value=value.substring(0,c) + ""String_Node_Str"" + value.substring(c + 1);
      }
      metadata.append(""String_Node_Str"").append(element).append(""String_Node_Str"").append(value).append(""String_Node_Str"").append(element).append(""String_Node_Str"");
    }
  }
  Collection[] colls=null;
  Community[] comms=null;
  Bundle[] origBundles=null;
  Bundle[] thumbBundles=null;
  try {
    colls=item.getCollections();
    comms=item.getCommunities();
    origBundles=item.getBundles(""String_Node_Str"");
    thumbBundles=item.getBundles(""String_Node_Str"");
  }
 catch (  SQLException sqlE) {
    ;
  }
  for (int i=0; i < comms.length; i++) {
    metadata.append(""String_Node_Str"").append(comms[i].getMetadata(""String_Node_Str"")).append(""String_Node_Str"");
  }
  for (int j=0; j < colls.length; j++) {
    metadata.append(""String_Node_Str"").append(colls[j].getMetadata(""String_Node_Str"")).append(""String_Node_Str"");
  }
  if (origBundles.length > 0) {
    Bitstream[] bitstreams=origBundles[0].getBitstreams();
    for (int j=0; j < bitstreams.length; j++) {
      String tName=bitstreams[j].getName() + ""String_Node_Str"";
      Bitstream tb=null;
      if (thumbBundles.length > 0) {
        tb=thumbBundles[0].getBitstreamByName(tName);
      }
      if (tb != null) {
        String thumbUrl=null;
        try {
          thumbUrl=baseUrl + ""String_Node_Str"" + tb.getID()+ ""String_Node_Str""+ Util.encodeBitstreamName(tb.getName(),Constants.DEFAULT_ENCODING);
        }
 catch (        Exception e) {
        }
        metadata.append(""String_Node_Str"").append(thumbUrl).append(""String_Node_Str"");
      }
    }
  }
  metadata.append(""String_Node_Str"");
  metadata.append(""String_Node_Str"");
  return metadata.toString();
}",0.9894701086956522
3562,"/** 
 * Return a normalized focus value. If there is no normalization that can be performed, return the focus value that is passed in.
 * @param value a focus value to normalize
 * @return  the normalized focus value
 * @throws BrowseException
 */
private String normalizeJumpToValue(String value) throws BrowseException {
  if (scope.hasJumpToValue()) {
    return BrowseOrder.makeSortString(scope.getJumpToValue(),scope.setJumpToValueLang(),scope.getBrowseIndex().getDataType());
  }
  return value;
}","/** 
 * Return a normalized focus value. If there is no normalization that can be performed, return the focus value that is passed in.
 * @param value a focus value to normalize
 * @return  the normalized focus value
 * @throws BrowseException
 */
private String normalizeJumpToValue(String value) throws BrowseException {
  if (scope.hasJumpToValue()) {
    return BrowseOrder.makeSortString(scope.getJumpToValue(),scope.setJumpToValueLang(),scope.getBrowseIndex().getDataType());
  }
 else   if (scope.hasStartsWith()) {
    return BrowseOrder.makeSortString(scope.getStartsWith(),null,scope.getBrowseIndex().getDataType());
  }
  return value;
}",0.8514335360556038
3563,"/** 
 * Load Submission Configuration for a specific user interface(UI). The submission configuration file name is formatted as follows: item-submission-UIName.xml <P> E.g. for a value of ""XMLUI"", uses the config file named item-submission-XMLUI.xml
 * @param UIName the name of the UI to load the Submission configuration for
 */
public SubmissionConfigReader(String UIName) throws ServletException {
  buildInputs(configDir + SUBMIT_DEF_FILE_PREFIX + ""String_Node_Str""+ UIName+ SUBMIT_DEF_FILE_SUFFIX);
}","/** 
 * Load Submission Configuration for a specific user interface(UI). The submission configuration file name is formatted as follows: item-submission-UIName.xml <P> E.g. for a value of ""XMLUI"", uses the config file named item-submission-XMLUI.xml
 * @param UIName the name of the UI to load the Submission configuration for
 */
public SubmissionConfigReader(String UIName) throws ServletException {
  this.UIName=UIName;
  buildInputs(configDir + SUBMIT_DEF_FILE_PREFIX + ""String_Node_Str""+ UIName+ SUBMIT_DEF_FILE_SUFFIX);
}",0.9787234042553192
3564,"/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField();
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=BrowseOrder.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField();
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (showLast) {
      position=total - scope.getResultsPerPage();
    }
 else {
      position=getPosition(false);
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}","/** 
 * Browse the archive by the full item browse mechanism.  This produces a BrowseInfo object which contains full BrowseItem objects as its result set.
 * @param bs		the scope of the browse
 * @return			the results of the browse
 * @throws BrowseException
 */
private BrowseInfo browseByItem(BrowserScope bs) throws BrowseException {
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
  try {
    dao.setTable(browseIndex.getTableName(scope.inCommunity(),scope.inCollection()));
    dao.setAscending(scope.isAscending());
    String focusValue=null;
    String rawFocusValue=null;
    String focusField=browseIndex.getSortField();
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      focusValue=getJumpToValue();
      rawFocusValue=focusValue;
      focusValue=normalizeJumpToValue(focusValue);
      if (scope.hasStartsWith()) {
        if (browseIndex.isDate()) {
          focusValue=focusValue + ""String_Node_Str"";
        }
      }
      log.debug(""String_Node_Str"" + focusValue);
      if (scope.getSortBy() > 0) {
        focusField=""String_Node_Str"" + Integer.toString(scope.getSortBy());
      }
      dao.setJumpToField(focusField);
      dao.setJumpToValue(focusValue);
    }
    String value=null;
    String rawValue=null;
    if (scope.hasFilterValue() && scope.isSecondLevel()) {
      value=scope.getFilterValue();
      rawValue=value;
      value=BrowseOrder.makeSortString(value,scope.getFilterValueLang(),scope.getBrowseIndex().getDataType());
      dao.setFilterValueField(""String_Node_Str"");
      dao.setFilterValue(value);
    }
    if (scope.inCollection() || scope.inCommunity()) {
      if (scope.inCollection()) {
        Collection col=(Collection)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(col.getID());
      }
 else       if (scope.inCommunity()) {
        Community com=(Community)scope.getBrowseContainer();
        dao.setContainerIDField(""String_Node_Str"");
        dao.setContainerID(com.getID());
      }
    }
    String orderBy=browseIndex.getSortField();
    if (scope.getSortBy() > 0) {
      orderBy=""String_Node_Str"" + Integer.toString(scope.getSortBy());
    }
    dao.setOrderField(orderBy);
    dao.setLimit(scope.getResultsPerPage() + 1);
    List results=dao.doQuery();
    boolean showLast=false;
    if (results.size() == 0) {
      showLast=true;
    }
    BrowseItem next=null;
    int lastIndex=results.size() - 1;
    if (lastIndex >= scope.getResultsPerPage()) {
      next=(BrowseItem)results.get(lastIndex);
      results.remove(lastIndex);
    }
    BrowseItem prev=null;
    if (scope.hasJumpToItem() || scope.hasJumpToValue() || scope.hasStartsWith()) {
      int prevID=-1;
      if (showLast) {
        prevID=getPreviousPageID(results);
      }
 else {
        prevID=getPreviousPageID(null);
      }
      if (prevID != -1) {
        if (bs.getBrowseIndex() == BrowseIndex.getWithdrawnBrowseIndex())         prev=new BrowseItem(context,prevID,false,true);
 else         prev=new BrowseItem(context,prevID,true,false);
      }
    }
    int offset=0;
    int total=getTotalResults();
    int position=-1;
    if (total > 0) {
      if (showLast) {
        position=total - scope.getResultsPerPage();
        if (position < 0)         position=0;
      }
 else {
        position=getPosition(false);
      }
    }
    BrowseInfo browseInfo=new BrowseInfo(results,position,total,offset);
    if (next != null) {
      browseInfo.setNextItem(next.getID());
    }
    if (prev != null) {
      browseInfo.setPrevItem(prev.getID());
    }
    browseInfo.setBrowseIndex(browseIndex);
    browseInfo.setSortOption(scope.getSortOption());
    browseInfo.setAscending(scope.isAscending());
    browseInfo.setBrowseLevel(scope.getBrowseLevel());
    browseInfo.setValue(rawValue);
    browseInfo.setFocus(rawFocusValue);
    if (scope.hasJumpToItem()) {
      browseInfo.setFocusItem(scope.getJumpToItem());
    }
    browseInfo.setStartsWith(scope.hasStartsWith());
    if (scope.inCollection() || scope.inCommunity()) {
      browseInfo.setBrowseContainer(scope.getBrowseContainer());
    }
    browseInfo.setResultsPerPage(scope.getResultsPerPage());
    browseInfo.setEtAl(scope.getEtAl());
    return browseInfo;
  }
 catch (  SQLException e) {
    log.error(""String_Node_Str"",e);
    throw new BrowseException(e);
  }
}",0.9905045189337603
3565,"public void addOptions(Options options) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  List context=options.addList(""String_Node_Str"");
  List admin=options.addList(""String_Node_Str"");
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (dso instanceof Item) {
    Item item=(Item)dso;
    if (item.canEdit()) {
      context.setHead(T_context_head);
      context.addItem().addXref(contextPath + ""String_Node_Str"" + item.getID(),T_context_edit_item);
    }
  }
 else   if (dso instanceof Collection) {
    Collection collection=(Collection)dso;
    if (AuthorizeManager.authorizeActionBoolean(this.context,collection,Constants.COLLECTION_ADMIN)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + collection.getID(),T_context_edit_collection);
      context.addItemXref(contextPath + ""String_Node_Str"" + collection.getID(),T_context_item_mapper);
    }
  }
 else   if (dso instanceof Community) {
    Community community=(Community)dso;
    if (community.canEditBoolean()) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_edit_community);
    }
    if (AuthorizeManager.authorizeActionBoolean(this.context,community,Constants.ADD)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_create_collection);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_create_subcommunity);
    }
  }
  if (""String_Node_Str"".equals(this.sitemapURI)) {
    if (AuthorizeManager.isAdmin(this.context)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"",T_context_create_community);
    }
  }
  if (AuthorizeManager.isAdmin(this.context)) {
    admin.setHead(T_administrative_head);
    List epeople=admin.addList(""String_Node_Str"");
    List registries=admin.addList(""String_Node_Str"");
    epeople.setHead(T_administrative_access_control);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_people);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_groups);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_authorizations);
    registries.setHead(T_administrative_registries);
    registries.addItemXref(contextPath + ""String_Node_Str"",T_administrative_metadata);
    registries.addItemXref(contextPath + ""String_Node_Str"",T_administrative_format);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_items);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_control_panel);
  }
}","public void addOptions(Options options) throws SAXException, WingException, UIException, SQLException, IOException, AuthorizeException {
  options.addList(""String_Node_Str"");
  options.addList(""String_Node_Str"");
  List context=options.addList(""String_Node_Str"");
  List admin=options.addList(""String_Node_Str"");
  DSpaceObject dso=HandleUtil.obtainHandle(objectModel);
  if (dso instanceof Item) {
    Item item=(Item)dso;
    if (item.canEdit()) {
      context.setHead(T_context_head);
      context.addItem().addXref(contextPath + ""String_Node_Str"" + item.getID(),T_context_edit_item);
    }
  }
 else   if (dso instanceof Collection) {
    Collection collection=(Collection)dso;
    if (AuthorizeManager.authorizeActionBoolean(this.context,collection,Constants.COLLECTION_ADMIN)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + collection.getID(),T_context_edit_collection);
      context.addItemXref(contextPath + ""String_Node_Str"" + collection.getID(),T_context_item_mapper);
    }
  }
 else   if (dso instanceof Community) {
    Community community=(Community)dso;
    if (community.canEditBoolean()) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_edit_community);
    }
    if (AuthorizeManager.authorizeActionBoolean(this.context,community,Constants.ADD)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_create_collection);
      context.addItemXref(contextPath + ""String_Node_Str"" + community.getID(),T_context_create_subcommunity);
    }
  }
  if (""String_Node_Str"".equals(this.sitemapURI)) {
    if (AuthorizeManager.isAdmin(this.context)) {
      context.setHead(T_context_head);
      context.addItemXref(contextPath + ""String_Node_Str"",T_context_create_community);
    }
  }
  if (AuthorizeManager.isAdmin(this.context)) {
    admin.setHead(T_administrative_head);
    List epeople=admin.addList(""String_Node_Str"");
    List registries=admin.addList(""String_Node_Str"");
    epeople.setHead(T_administrative_access_control);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_people);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_groups);
    epeople.addItemXref(contextPath + ""String_Node_Str"",T_administrative_authorizations);
    registries.setHead(T_administrative_registries);
    registries.addItemXref(contextPath + ""String_Node_Str"",T_administrative_metadata);
    registries.addItemXref(contextPath + ""String_Node_Str"",T_administrative_format);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_items);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_withdrawn);
    admin.addItemXref(contextPath + ""String_Node_Str"",T_administrative_control_panel);
  }
}",0.9854258121158912
3566,"/** 
 * A sanity check that ensures a given element and qualifier are unique within a given schema. The check happens in code as we cannot use a database constraint.
 * @param context dspace context
 * @param schemaID
 * @param element
 * @param qualifier
 * @return true if unique
 * @throws AuthorizeException
 * @throws SQLException
 * @throws IOException
 */
private boolean unique(Context context,int schemaID,String element,String qualifier) throws IOException, SQLException, AuthorizeException {
  Connection con=context.getDBConnection();
  TableRow reg=DatabaseManager.row(""String_Node_Str"");
  String query=""String_Node_Str"" + reg.getTable() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  PreparedStatement statement=con.prepareStatement(query);
  statement.setInt(1,schemaID);
  statement.setInt(2,fieldID);
  statement.setString(3,element);
  statement.setString(4,qualifier);
  ResultSet rs=statement.executeQuery();
  int count=0;
  if (rs.next()) {
    count=rs.getInt(1);
  }
  return (count == 0);
}","/** 
 * A sanity check that ensures a given element and qualifier are unique within a given schema. The check happens in code as we cannot use a database constraint.
 * @param context dspace context
 * @param schemaID
 * @param element
 * @param qualifier
 * @return true if unique
 * @throws AuthorizeException
 * @throws SQLException
 * @throws IOException
 */
private boolean unique(Context context,int schemaID,String element,String qualifier) throws IOException, SQLException, AuthorizeException {
  Connection con=context.getDBConnection();
  TableRow reg=DatabaseManager.row(""String_Node_Str"");
  String qualifierClause=""String_Node_Str"";
  if (qualifier == null) {
    qualifierClause=""String_Node_Str"";
  }
 else {
    qualifierClause=""String_Node_Str"";
  }
  String query=""String_Node_Str"" + reg.getTable() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ qualifierClause;
  PreparedStatement statement=con.prepareStatement(query);
  statement.setInt(1,schemaID);
  statement.setInt(2,fieldID);
  statement.setString(3,element);
  if (qualifier != null) {
    statement.setString(4,qualifier);
  }
  ResultSet rs=statement.executeQuery();
  int count=0;
  if (rs.next()) {
    count=rs.getInt(1);
  }
  return (count == 0);
}",0.9054945054945056
3567,"/** 
 * Return true if there are more rows, false otherwise
 * @return - true if there are more rows, false otherwise
 * @exception SQLException -If a database error occurs while fetching values
 */
public boolean hasNext() throws SQLException {
  if (results == null) {
    return false;
  }
  if (hasAdvanced) {
    return hasNext;
  }
  hasAdvanced=true;
  hasNext=results.next();
  if (!hasNext) {
    close();
  }
  return hasNext;
}","/** 
 * Return true if there are more rows, false otherwise
 * @return - true if there are more rows, false otherwise
 * @exception SQLException -If a database error occurs while fetching values
 */
public boolean hasNext() throws SQLException {
  if (results == null) {
    close();
    return false;
  }
  if (hasAdvanced) {
    return hasNext;
  }
  hasAdvanced=true;
  hasNext=results.next();
  if (!hasNext) {
    close();
  }
  return hasNext;
}",0.9853768278965128
3568,"/** 
 * Close the Iterator and release any associated resources
 */
public void close(){
  try {
    results.close();
    if (results != null)     results.close();
  }
 catch (  SQLException sqle) {
  }
  try {
    if (statemt != null)     statemt.close();
    statemt=null;
  }
 catch (  SQLException sqle) {
  }
}","/** 
 * Close the Iterator and release any associated resources
 */
public void close(){
  try {
    if (results != null) {
      results.close();
      results=null;
    }
  }
 catch (  SQLException sqle) {
  }
  try {
    if (statemt != null) {
      statemt.close();
      statemt=null;
    }
  }
 catch (  SQLException sqle) {
  }
}",0.9032258064516128
3569,"/** 
 * get Set of Integers all of the group memberships for an eperson
 * @param c
 * @param e
 * @return Set of Integer groupIDs
 * @throws SQLException
 */
public static Set allMemberGroupIDs(Context c,EPerson e) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",e.getID());
  Set groupIDs=new HashSet();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    int childID=row.getIntColumn(""String_Node_Str"");
    groupIDs.add(new Integer(childID));
  }
  tri.close();
  String groupQuery=""String_Node_Str"";
  Iterator i=groupIDs.iterator();
  Object[] parameters=new Object[groupIDs.size()];
  int idx=0;
  while (i.hasNext()) {
    int groupID=((Integer)i.next()).intValue();
    parameters[idx++]=new Integer(groupID);
    groupQuery+=""String_Node_Str"";
    if (i.hasNext())     groupQuery+=""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(groupQuery)) {
    return groupIDs;
  }
  tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + groupQuery,parameters);
  while (tri.hasNext()) {
    TableRow row=tri.next();
    int parentID=row.getIntColumn(""String_Node_Str"");
    groupIDs.add(new Integer(parentID));
  }
  tri.close();
  return groupIDs;
}","/** 
 * get Set of Integers all of the group memberships for an eperson
 * @param c
 * @param e
 * @return Set of Integer groupIDs
 * @throws SQLException
 */
public static Set allMemberGroupIDs(Context c,EPerson e) throws SQLException {
  TableRowIterator tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"",e.getID());
  Set groupIDs=new HashSet();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    int childID=row.getIntColumn(""String_Node_Str"");
    groupIDs.add(new Integer(childID));
  }
  tri.close();
  Group[] specialGroups=c.getSpecialGroups();
  for (int j=0; j < specialGroups.length; j++)   groupIDs.add(new Integer(specialGroups[j].getID()));
  String groupQuery=""String_Node_Str"";
  Iterator i=groupIDs.iterator();
  Object[] parameters=new Object[groupIDs.size()];
  int idx=0;
  while (i.hasNext()) {
    int groupID=((Integer)i.next()).intValue();
    parameters[idx++]=new Integer(groupID);
    groupQuery+=""String_Node_Str"";
    if (i.hasNext())     groupQuery+=""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(groupQuery)) {
    return groupIDs;
  }
  tri=DatabaseManager.queryTable(c,""String_Node_Str"",""String_Node_Str"" + groupQuery,parameters);
  while (tri.hasNext()) {
    TableRow row=tri.next();
    int parentID=row.getIntColumn(""String_Node_Str"");
    groupIDs.add(new Integer(parentID));
  }
  tri.close();
  return groupIDs;
}",0.943683409436834
3570,"/** 
 * Retrieve all e-person records from the database, sorted by a particular field. Fields are: <<<<<<< EPerson.java <ul> <li><code>ID</code></li> <li><code>LASTNAME</code></li> <li><code>EMAIL</code></li> <li><code>NETID</code></li> </ul> ======= <UL> <LI><code>ID</code></LI> <LI><code>LASTNAME</code></LI> <LI><code>EMAIL</code></LI> <LI><code>NETID</code></LI> </UL>
 * @return array of EPerson objects >>>>>>> 1.27
 */
public static EPerson[] findAll(Context context,int sortField) throws SQLException {
  String s;
switch (sortField) {
case ID:
    s=""String_Node_Str"";
  break;
case EMAIL:
s=""String_Node_Str"";
break;
case NETID:
s=""String_Node_Str"";
break;
default :
s=""String_Node_Str"";
}
TableRowIterator rows=DatabaseManager.query(context,""String_Node_Str"" + s);
List epeopleRows=rows.toList();
EPerson[] epeople=new EPerson[epeopleRows.size()];
for (int i=0; i < epeopleRows.size(); i++) {
TableRow row=(TableRow)epeopleRows.get(i);
EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
if (fromCache != null) {
epeople[i]=fromCache;
}
 else {
epeople[i]=new EPerson(context,row);
}
}
return epeople;
}","/** 
 * Retrieve all e-person records from the database, sorted by a particular field. Fields are: <ul> <li><code>ID</code></li> <li><code>LASTNAME</code></li> <li><code>EMAIL</code></li> <li><code>NETID</code></li> </ul>
 * @return array of EPerson objects
 */
public static EPerson[] findAll(Context context,int sortField) throws SQLException {
  String s;
switch (sortField) {
case ID:
    s=""String_Node_Str"";
  break;
case EMAIL:
s=""String_Node_Str"";
break;
case NETID:
s=""String_Node_Str"";
break;
default :
s=""String_Node_Str"";
}
TableRowIterator rows=DatabaseManager.query(context,""String_Node_Str"" + s);
List epeopleRows=rows.toList();
EPerson[] epeople=new EPerson[epeopleRows.size()];
for (int i=0; i < epeopleRows.size(); i++) {
TableRow row=(TableRow)epeopleRows.get(i);
EPerson fromCache=(EPerson)context.fromCache(EPerson.class,row.getIntColumn(""String_Node_Str""));
if (fromCache != null) {
epeople[i]=fromCache;
}
 else {
epeople[i]=new EPerson(context,row);
}
}
return epeople;
}",0.9234338747099768
3571,"protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int groupID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Group group=null;
  if (groupID >= 0) {
    group=Group.find(c,groupID);
  }
  if (group != null) {
    AuthorizeManager.authorizeAction(c,group,Constants.ADD);
    boolean submit_edit=(request.getParameter(""String_Node_Str"") != null);
    boolean submit_group_update=(request.getParameter(""String_Node_Str"") != null);
    boolean submit_group_delete=(request.getParameter(""String_Node_Str"") != null);
    if (submit_edit && !submit_group_update && !submit_group_delete) {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else     if (submit_group_update) {
      String newName=request.getParameter(""String_Node_Str"");
      if (!newName.equals(group.getName())) {
        group.setName(newName);
        group.update();
      }
      int[] eperson_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      int[] group_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      EPerson[] members=group.getMembers();
      Group[] membergroups=group.getMemberGroups();
      if (eperson_ids != null) {
        Set memberSet=new HashSet();
        Set epersonIDSet=new HashSet();
        for (int x=0; x < members.length; x++) {
          Integer epersonID=new Integer(members[x].getID());
          memberSet.add(epersonID);
        }
        for (int x=0; x < eperson_ids.length; x++) {
          epersonIDSet.add(new Integer(eperson_ids[x]));
        }
        Iterator i=epersonIDSet.iterator();
        while (i.hasNext()) {
          Integer currentID=(Integer)i.next();
          if (!memberSet.contains(currentID)) {
            group.addMember(EPerson.find(c,currentID.intValue()));
          }
        }
        for (int x=0; x < members.length; x++) {
          EPerson e=members[x];
          if (!epersonIDSet.contains(new Integer(e.getID()))) {
            group.removeMember(e);
          }
        }
      }
 else {
        for (int y=0; y < members.length; y++) {
          group.removeMember(members[y]);
        }
      }
      if (group_ids != null) {
        Set memberSet=new HashSet();
        Set groupIDSet=new HashSet();
        for (int x=0; x < membergroups.length; x++) {
          Integer myID=new Integer(membergroups[x].getID());
          memberSet.add(myID);
        }
        for (int x=0; x < group_ids.length; x++) {
          groupIDSet.add(new Integer(group_ids[x]));
        }
        Iterator i=groupIDSet.iterator();
        while (i.hasNext()) {
          Integer currentID=(Integer)i.next();
          if (!memberSet.contains(currentID)) {
            group.addMember(Group.find(c,currentID.intValue()));
          }
        }
        for (int x=0; x < membergroups.length; x++) {
          Group g=membergroups[x];
          if (!groupIDSet.contains(new Integer(g.getID()))) {
            group.removeMember(g);
          }
        }
      }
 else {
        for (int y=0; y < membergroups.length; y++) {
          group.removeMember(membergroups[y]);
        }
      }
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else     if (submit_group_delete) {
      AuthorizeManager.authorizeAction(c,group,Constants.WRITE);
      group.delete();
      showMainPage(c,request,response);
      c.complete();
    }
 else {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      group=Group.create(c);
      group.setName(""String_Node_Str"" + group.getID());
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else {
      showMainPage(c,request,response);
    }
  }
}","protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int groupID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Group group=null;
  if (groupID >= 0) {
    group=Group.find(c,groupID);
  }
  if (group != null) {
    AuthorizeManager.authorizeAction(c,group,Constants.ADD);
    boolean submit_edit=(request.getParameter(""String_Node_Str"") != null);
    boolean submit_group_update=(request.getParameter(""String_Node_Str"") != null);
    boolean submit_group_delete=(request.getParameter(""String_Node_Str"") != null);
    if (submit_edit && !submit_group_update && !submit_group_delete) {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else     if (submit_group_update) {
      String newName=request.getParameter(""String_Node_Str"");
      if (!newName.equals(group.getName())) {
        group.setName(newName);
        group.update();
      }
      int[] eperson_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      int[] group_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      EPerson[] members=group.getMembers();
      Group[] membergroups=group.getMemberGroups();
      if (eperson_ids != null) {
        Set memberSet=new HashSet();
        Set epersonIDSet=new HashSet();
        for (int x=0; x < members.length; x++) {
          Integer epersonID=new Integer(members[x].getID());
          memberSet.add(epersonID);
        }
        for (int x=0; x < eperson_ids.length; x++) {
          epersonIDSet.add(new Integer(eperson_ids[x]));
        }
        Iterator i=epersonIDSet.iterator();
        while (i.hasNext()) {
          Integer currentID=(Integer)i.next();
          if (!memberSet.contains(currentID)) {
            group.addMember(EPerson.find(c,currentID.intValue()));
          }
        }
        for (int x=0; x < members.length; x++) {
          EPerson e=members[x];
          if (!epersonIDSet.contains(new Integer(e.getID()))) {
            group.removeMember(e);
          }
        }
      }
 else {
        for (int y=0; y < members.length; y++) {
          group.removeMember(members[y]);
        }
      }
      if (group_ids != null) {
        Set memberSet=new HashSet();
        Set groupIDSet=new HashSet();
        for (int x=0; x < membergroups.length; x++) {
          Integer myID=new Integer(membergroups[x].getID());
          memberSet.add(myID);
        }
        for (int x=0; x < group_ids.length; x++) {
          groupIDSet.add(new Integer(group_ids[x]));
        }
        Iterator i=groupIDSet.iterator();
        while (i.hasNext()) {
          Integer currentID=(Integer)i.next();
          if (!memberSet.contains(currentID)) {
            group.addMember(Group.find(c,currentID.intValue()));
          }
        }
        for (int x=0; x < membergroups.length; x++) {
          Group g=membergroups[x];
          if (!groupIDSet.contains(new Integer(g.getID()))) {
            group.removeMember(g);
          }
        }
      }
 else {
        for (int y=0; y < membergroups.length; y++) {
          group.removeMember(membergroups[y]);
        }
      }
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else     if (submit_group_delete) {
      AuthorizeManager.authorizeAction(c,group,Constants.WRITE);
      group.delete();
      showMainPage(c,request,response);
    }
 else {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      group=Group.create(c);
      group.setName(""String_Node_Str"" + group.getID());
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      request.setAttribute(""String_Node_Str"",group.getMemberGroups());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else {
      showMainPage(c,request,response);
    }
  }
}",0.9978614200171086
3572,"private static boolean cacheMe(Class implClass){
  if (cacheMeCache.containsKey(implClass))   return ((Boolean)cacheMeCache.get(implClass)).booleanValue();
 else {
    boolean reusable=true;
    String key=REUSABLE_PREFIX + implClass.getName();
    if (ConfigurationManager.getProperty(key) != null)     reusable=ConfigurationManager.getBooleanProperty(key);
    cacheMeCache.put(implClass,new Boolean(reusable));
    return reusable;
  }
}","private static boolean cacheMe(Class implClass){
  if (cacheMeCache.containsKey(implClass)) {
    return ((Boolean)cacheMeCache.get(implClass)).booleanValue();
  }
 else {
    String key=REUSABLE_PREFIX + implClass.getName();
    boolean reusable=ConfigurationManager.getBooleanProperty(key,true);
    cacheMeCache.put(implClass,new Boolean(reusable));
    return reusable;
  }
}",0.6862026862026862
3573,"private static Object getAnonymousPlugin(String classname) throws PluginInstantiationException {
  try {
    Class pluginClass=Class.forName(classname);
    if (cacheMe(pluginClass)) {
      Object cached=anonymousInstanceCache.get(pluginClass);
      if (cached == null) {
        cached=pluginClass.newInstance();
        anonymousInstanceCache.put(pluginClass,cached);
      }
      return cached;
    }
 else     return pluginClass.newInstance();
  }
 catch (  ClassNotFoundException e) {
    throw new PluginInstantiationException(""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new PluginInstantiationException(e);
  }
catch (  IllegalAccessException e) {
    throw new PluginInstantiationException(e);
  }
}","private static Object getAnonymousPlugin(String classname) throws PluginInstantiationException {
  try {
    Class pluginClass=Class.forName(classname);
    if (cacheMe(pluginClass)) {
      Object cached=anonymousInstanceCache.get(pluginClass);
      if (cached == null) {
        cached=pluginClass.newInstance();
        anonymousInstanceCache.put(pluginClass,cached);
      }
      return cached;
    }
 else     return pluginClass.newInstance();
  }
 catch (  ClassNotFoundException e) {
    throw new PluginInstantiationException(""String_Node_Str"" + e.toString(),e);
  }
catch (  InstantiationException e) {
    throw new PluginInstantiationException(e);
  }
catch (  IllegalAccessException e) {
    throw new PluginInstantiationException(e);
  }
}",0.9899531145344944
3574,"/** 
 * Returns an instance of a plugin that implements the interface intface and is bound to a name matching name.  If there is no matching plugin, it returns null.  The names are matched by String.equals().
 * @param intfc the interface class of the plugin
 * @param name under which the plugin implementation is configured.
 * @return instance of plugin implementation, or null if there is no match or an error.
 */
public static Object getNamedPlugin(Class intfc,String name) throws PluginInstantiationException {
  try {
    String iname=intfc.getName();
    configureNamedPlugin(iname);
    String key=iname + SEP + name;
    String cname=(String)namedPluginClasses.get(key);
    if (cname == null)     log.warn(""String_Node_Str"" + iname + ""String_Node_Str""+ name+ ""String_Node_Str"");
 else {
      Class pluginClass=Class.forName(cname);
      if (cacheMe(pluginClass)) {
        String nkey=pluginClass.getName() + SEP + name;
        Object cached=namedInstanceCache.get(nkey);
        if (cached == null) {
          cached=pluginClass.newInstance();
          if (cached instanceof SelfNamedPlugin)           ((SelfNamedPlugin)cached).setPluginInstanceName(name);
          namedInstanceCache.put(nkey,cached);
        }
        return cached;
      }
 else {
        Object result=pluginClass.newInstance();
        if (result instanceof SelfNamedPlugin)         ((SelfNamedPlugin)result).setPluginInstanceName(name);
      }
    }
  }
 catch (  ClassNotFoundException e) {
    throw new PluginInstantiationException(""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new PluginInstantiationException(e);
  }
catch (  IllegalAccessException e) {
    throw new PluginInstantiationException(e);
  }
  return null;
}","/** 
 * Returns an instance of a plugin that implements the interface intface and is bound to a name matching name.  If there is no matching plugin, it returns null.  The names are matched by String.equals().
 * @param intfc the interface class of the plugin
 * @param name under which the plugin implementation is configured.
 * @return instance of plugin implementation, or null if there is no match or an error.
 */
public static Object getNamedPlugin(Class intfc,String name) throws PluginInstantiationException {
  try {
    String iname=intfc.getName();
    configureNamedPlugin(iname);
    String key=iname + SEP + name;
    String cname=(String)namedPluginClasses.get(key);
    if (cname == null)     log.warn(""String_Node_Str"" + iname + ""String_Node_Str""+ name+ ""String_Node_Str"");
 else {
      Class pluginClass=Class.forName(cname);
      if (cacheMe(pluginClass)) {
        String nkey=pluginClass.getName() + SEP + name;
        Object cached=namedInstanceCache.get(nkey);
        if (cached == null) {
          log.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ iname+ ""String_Node_Str""+ name);
          cached=pluginClass.newInstance();
          if (cached instanceof SelfNamedPlugin)           ((SelfNamedPlugin)cached).setPluginInstanceName(name);
          namedInstanceCache.put(nkey,cached);
        }
        return cached;
      }
 else {
        log.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ iname+ ""String_Node_Str""+ name);
        Object result=pluginClass.newInstance();
        if (result instanceof SelfNamedPlugin)         ((SelfNamedPlugin)result).setPluginInstanceName(name);
        return result;
      }
    }
  }
 catch (  ClassNotFoundException e) {
    throw new PluginInstantiationException(""String_Node_Str"" + e.toString(),e);
  }
catch (  InstantiationException e) {
    throw new PluginInstantiationException(e);
  }
catch (  IllegalAccessException e) {
    throw new PluginInstantiationException(e);
  }
  return null;
}",0.9367292225201072
3575,"private static void configureNamedPlugin(String iname) throws ClassNotFoundException {
  int found=0;
  if (!namedPluginClasses.containsKey(iname)) {
    String namedVal=ConfigurationManager.getProperty(NAMED_PREFIX + iname);
    if (namedVal != null) {
      log.debug(""String_Node_Str"" + iname + ""String_Node_Str""+ namedVal);
      Pattern classnameEqual=Pattern.compile(""String_Node_Str"");
      int prevEnd=-1;
      String prevClassName=null;
      Matcher classMatcher=classnameEqual.matcher(namedVal);
      while (classMatcher.find()) {
        if (prevClassName != null)         found+=installNamedConfigs(iname,prevClassName,namedVal.substring(prevEnd,classMatcher.start()).trim().split(""String_Node_Str""));
        prevClassName=classMatcher.group(1);
        prevEnd=classMatcher.end();
      }
      if (prevClassName != null)       found+=installNamedConfigs(iname,prevClassName,namedVal.substring(prevEnd).trim().split(""String_Node_Str""));
    }
    String selfNamedVal=ConfigurationManager.getProperty(SELFNAMED_PREFIX + iname);
    if (selfNamedVal != null) {
      String classnames[]=selfNamedVal.split(""String_Node_Str"");
      for (int i=0; i < classnames.length; ++i) {
        Class pluginClass=Class.forName(classnames[i]);
        try {
          String names[]=(String[])pluginClass.getMethod(""String_Node_Str"",null).invoke(null,null);
          if (names == null || names.length == 0)           log.error(""String_Node_Str"" + classnames[i] + ""String_Node_Str"");
 else           found+=installNamedConfigs(iname,classnames[i],names);
        }
 catch (        NoSuchMethodException e) {
          log.error(""String_Node_Str"" + classnames[i] + ""String_Node_Str"");
        }
catch (        Exception e) {
          log.error(e.toString());
        }
      }
    }
    namedPluginClasses.put(iname,""String_Node_Str"");
    if (found == 0)     log.error(""String_Node_Str"" + iname);
  }
}","private static void configureNamedPlugin(String iname) throws ClassNotFoundException {
  int found=0;
  if (!namedPluginClasses.containsKey(iname)) {
    String namedVal=ConfigurationManager.getProperty(NAMED_PREFIX + iname);
    if (namedVal != null) {
      log.debug(""String_Node_Str"" + iname + ""String_Node_Str""+ namedVal);
      Pattern classnameEqual=Pattern.compile(""String_Node_Str"");
      int prevEnd=-1;
      String prevClassName=null;
      Matcher classMatcher=classnameEqual.matcher(namedVal);
      while (classMatcher.find()) {
        if (prevClassName != null)         found+=installNamedConfigs(iname,prevClassName,namedVal.substring(prevEnd,classMatcher.start()).trim().split(""String_Node_Str""));
        prevClassName=classMatcher.group(1);
        prevEnd=classMatcher.end();
      }
      if (prevClassName != null)       found+=installNamedConfigs(iname,prevClassName,namedVal.substring(prevEnd).trim().split(""String_Node_Str""));
    }
    String selfNamedVal=ConfigurationManager.getProperty(SELFNAMED_PREFIX + iname);
    if (selfNamedVal != null) {
      String classnames[]=selfNamedVal.split(""String_Node_Str"");
      for (int i=0; i < classnames.length; ++i) {
        try {
          Class pluginClass=Class.forName(classnames[i]);
          String names[]=(String[])pluginClass.getMethod(""String_Node_Str"",null).invoke(null,null);
          if (names == null || names.length == 0)           log.error(""String_Node_Str"" + classnames[i] + ""String_Node_Str"");
 else           found+=installNamedConfigs(iname,classnames[i],names);
        }
 catch (        NoSuchMethodException e) {
          log.error(""String_Node_Str"" + classnames[i] + ""String_Node_Str"");
        }
catch (        Exception e) {
          log.error(""String_Node_Str"" + e.toString());
        }
      }
    }
    namedPluginClasses.put(iname,""String_Node_Str"");
    if (found == 0)     log.error(""String_Node_Str"" + iname);
  }
}",0.98696558915537
3576,"/** 
 * Prune the history records from the database.
 * @param interests set of results and the duration of time before they are removed from the database
 * @return number of bitstreams deleted
 */
public int prune(Map interests){
  Connection conn=null;
  try {
    conn=DatabaseManager.getConnection();
    long now=System.currentTimeMillis();
    int count=0;
    for (Iterator iter=interests.keySet().iterator(); iter.hasNext(); ) {
      String result=(String)iter.next();
      Long dur=(Long)interests.get(result);
      count+=deleteHistoryByDateAndCode(new Date(now - dur.longValue()),result,conn);
    }
    return count;
  }
 catch (  SQLException e) {
    LOG.error(""String_Node_Str"" + e.getMessage(),e);
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    DatabaseManager.freeConnection(conn);
  }
}","/** 
 * Prune the history records from the database.
 * @param interests set of results and the duration of time before they are removed from the database
 * @return number of bitstreams deleted
 */
public int prune(Map interests){
  Connection conn=null;
  try {
    conn=DatabaseManager.getConnection();
    long now=System.currentTimeMillis();
    int count=0;
    for (Iterator iter=interests.keySet().iterator(); iter.hasNext(); ) {
      String result=(String)iter.next();
      Long dur=(Long)interests.get(result);
      count+=deleteHistoryByDateAndCode(new Date(now - dur.longValue()),result,conn);
      conn.commit();
    }
    return count;
  }
 catch (  SQLException e) {
    LOG.error(""String_Node_Str"" + e.getMessage(),e);
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    DatabaseManager.freeConnection(conn);
  }
}",0.9877977919814062
3577,"/** 
 * Export the object (Item, Collection, or Community) to a package file on the indicated OutputStream. Gets an exception of the object cannot be packaged or there is a failure creating the package.
 * @param context - DSpace context.
 * @param dso - DSpace object (item, collection, etc)
 * @param pkg - output stream on which to write package
 * @throws PackageException if package cannot be created or there isa fatal error in creating it.
 */
public void disseminate(Context context,DSpaceObject dso,PackageParameters params,OutputStream pkg) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (dso.getType() == Constants.ITEM) {
    Item item=(Item)dso;
    if (params != null && params.getProperty(""String_Node_Str"") != null) {
      extraFiles=null;
      writeManifest(context,item,params,pkg);
    }
 else {
      extraFiles=new HashMap();
      ZipOutputStream zip=new ZipOutputStream(pkg);
      zip.setComment(""String_Node_Str"");
      ZipEntry me=new ZipEntry(MANIFEST_FILE);
      zip.putNextEntry(me);
      writeManifest(context,item,params,zip);
      zip.closeEntry();
      Iterator fi=extraFiles.keySet().iterator();
      while (fi.hasNext()) {
        String fname=(String)fi.next();
        ZipEntry ze=new ZipEntry(fname);
        zip.putNextEntry(ze);
        Utils.copy((InputStream)extraFiles.get(fname),zip);
        zip.closeEntry();
      }
      Bundle bundles[]=item.getBundles();
      for (int i=0; i < bundles.length; i++) {
        if (!PackageUtils.isMetaInfoBundle(bundles[i])) {
          Bitstream[] bitstreams=bundles[i].getBitstreams();
          for (int k=0; k < bitstreams.length; k++) {
            if (AuthorizeManager.authorizeActionBoolean(context,bitstreams[k],Constants.READ)) {
              ZipEntry ze=new ZipEntry(makeBitstreamName(bitstreams[k]));
              ze.setSize(bitstreams[k].getSize());
              zip.putNextEntry(ze);
              Utils.copy(bitstreams[k].retrieve(),zip);
              zip.closeEntry();
            }
          }
        }
      }
      zip.close();
      extraFiles=null;
    }
  }
 else   throw new PackageValidationException(""String_Node_Str"");
}","/** 
 * Export the object (Item, Collection, or Community) to a package file on the indicated OutputStream. Gets an exception of the object cannot be packaged or there is a failure creating the package.
 * @param context - DSpace context.
 * @param dso - DSpace object (item, collection, etc)
 * @param pkg - output stream on which to write package
 * @throws PackageException if package cannot be created or there isa fatal error in creating it.
 */
public void disseminate(Context context,DSpaceObject dso,PackageParameters params,OutputStream pkg) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  if (dso.getType() == Constants.ITEM) {
    Item item=(Item)dso;
    long lmTime=item.getLastModified().getTime();
    String unauth=(params == null) ? null : params.getProperty(""String_Node_Str"");
    if (params != null && params.getProperty(""String_Node_Str"") != null) {
      extraFiles=null;
      writeManifest(context,item,params,pkg);
    }
 else {
      extraFiles=new HashMap();
      ZipOutputStream zip=new ZipOutputStream(pkg);
      zip.setComment(""String_Node_Str"");
      ZipEntry me=new ZipEntry(MANIFEST_FILE);
      me.setTime(lmTime);
      zip.putNextEntry(me);
      writeManifest(context,item,params,zip);
      zip.closeEntry();
      Iterator fi=extraFiles.keySet().iterator();
      while (fi.hasNext()) {
        String fname=(String)fi.next();
        ZipEntry ze=new ZipEntry(fname);
        ze.setTime(lmTime);
        zip.putNextEntry(ze);
        Utils.copy((InputStream)extraFiles.get(fname),zip);
        zip.closeEntry();
      }
      Bundle bundles[]=item.getBundles();
      for (int i=0; i < bundles.length; i++) {
        if (!PackageUtils.isMetaInfoBundle(bundles[i])) {
          if (!AuthorizeManager.authorizeActionBoolean(context,bundles[i],Constants.READ)) {
            if (unauth != null && (unauth.equalsIgnoreCase(""String_Node_Str""))) {
              log.warn(""String_Node_Str"" + bundles[i].getName() + ""String_Node_Str"");
              continue;
            }
 else             throw new AuthorizeException(""String_Node_Str"" + bundles[i].getName() + ""String_Node_Str"");
          }
          Bitstream[] bitstreams=bundles[i].getBitstreams();
          for (int k=0; k < bitstreams.length; k++) {
            boolean auth=AuthorizeManager.authorizeActionBoolean(context,bitstreams[k],Constants.READ);
            if (auth || (unauth != null && unauth.equalsIgnoreCase(""String_Node_Str""))) {
              ZipEntry ze=new ZipEntry(makeBitstreamName(bitstreams[k]));
              ze.setTime(lmTime);
              ze.setSize(auth ? bitstreams[k].getSize() : 0);
              zip.putNextEntry(ze);
              if (auth)               Utils.copy(bitstreams[k].retrieve(),zip);
 else               log.warn(""String_Node_Str"" + String.valueOf(bitstreams[k].getSequenceID()) + ""String_Node_Str"");
              zip.closeEntry();
            }
 else             if (unauth != null && unauth.equalsIgnoreCase(""String_Node_Str"")) {
              log.warn(""String_Node_Str"" + String.valueOf(bitstreams[k].getSequenceID()) + ""String_Node_Str"");
            }
 else {
              throw new AuthorizeException(""String_Node_Str"" + String.valueOf(bitstreams[k].getSequenceID()));
            }
          }
        }
      }
      zip.close();
      extraFiles=null;
    }
  }
 else   throw new PackageValidationException(""String_Node_Str"");
}",0.740911509132825
3578,"/** 
 * Write out a METS manifest. Mostly lifted from Rob Tansley's METS exporter.
 */
private void writeManifest(Context context,Item item,PackageParameters params,OutputStream out) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  try {
    Mets mets=new Mets();
    mets.setID(gensym(""String_Node_Str""));
    mets.setOBJID(""String_Node_Str"" + item.getHandle());
    mets.setLABEL(""String_Node_Str"");
    mets.setPROFILE(getProfile());
    MetsHdr metsHdr=new MetsHdr();
    metsHdr.setCREATEDATE(new Date());
    Agent agent=new Agent();
    agent.setROLE(Role.CUSTODIAN);
    agent.setTYPE(Type.ORGANIZATION);
    Name name=new Name();
    name.getContent().add(new PCData(ConfigurationManager.getProperty(""String_Node_Str"")));
    agent.getContent().add(name);
    metsHdr.getContent().add(agent);
    mets.getContent().add(metsHdr);
    String dmdTypes[]=getDmdTypes(params);
    String dmdGroup=gensym(""String_Node_Str"");
    String dmdId[]=new String[dmdTypes.length];
    for (int i=0; i < dmdTypes.length; ++i) {
      dmdId[i]=gensym(""String_Node_Str"");
      XmlData xmlData=new XmlData();
      String xwalkName, metsName;
      String parts[]=dmdTypes[i].split(""String_Node_Str"",2);
      if (parts.length > 1) {
        metsName=parts[0];
        xwalkName=parts[1];
      }
 else       xwalkName=metsName=dmdTypes[i];
      DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkName);
      if (xwalk == null)       throw new PackageValidationException(""String_Node_Str"" + dmdTypes[i] + ""String_Node_Str"");
 else       crosswalkToMets(xwalk,item,xmlData);
      DmdSec dmdSec=new DmdSec();
      dmdSec.setID(dmdId[i]);
      dmdSec.setGROUPID(dmdGroup);
      MdWrap mdWrap=new MdWrap();
      setMdType(mdWrap,metsName);
      mdWrap.getContent().add(xmlData);
      dmdSec.getContent().add(mdWrap);
      mets.getContent().add(dmdSec);
    }
    String licenseID=null;
    AmdSec amdSec=new AmdSec();
    addRightsMd(context,item,amdSec);
    if (amdSec.getContent().size() > 0) {
      licenseID=gensym(""String_Node_Str"");
      amdSec.setID(licenseID);
      mets.getContent().add(amdSec);
    }
    FileSec fileSec=new FileSec();
    String techMdType=getTechMdType(params);
    String parts[]=techMdType.split(""String_Node_Str"",2);
    String xwalkName, metsName;
    if (parts.length > 1) {
      metsName=parts[0];
      xwalkName=parts[1];
    }
 else     xwalkName=metsName=techMdType;
    DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkName);
    if (xwalk == null)     throw new PackageValidationException(""String_Node_Str"" + xwalkName + ""String_Node_Str"");
    String primaryBitstreamFileID=null;
    List contentDivs=new ArrayList();
    Bundle[] bundles=item.getBundles();
    for (int i=0; i < bundles.length; i++) {
      if (PackageUtils.isMetaInfoBundle(bundles[i]))       continue;
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      FileGrp fileGrp=new FileGrp();
      String bName=bundles[i].getName();
      if ((bName != null) && !bName.equals(""String_Node_Str""))       fileGrp.setUSE(bundleToFileGrp(bName));
      int primaryBitstreamID=-1;
      boolean isContentBundle=false;
      if ((bName != null) && bName.equals(""String_Node_Str"")) {
        isContentBundle=true;
        primaryBitstreamID=bundles[i].getPrimaryBitstreamID();
      }
      for (int bits=0; bits < bitstreams.length; bits++) {
        String sid=String.valueOf(bitstreams[bits].getSequenceID());
        edu.harvard.hul.ois.mets.File file=new edu.harvard.hul.ois.mets.File();
        String xmlIDstart=""String_Node_Str"";
        String fileID=xmlIDstart + sid;
        file.setID(fileID);
        if (bitstreams[bits].getID() == primaryBitstreamID)         primaryBitstreamFileID=fileID;
        if (isContentBundle) {
          Div div=new Div();
          div.setID(gensym(""String_Node_Str""));
          div.setTYPE(""String_Node_Str"");
          Fptr fptr=new Fptr();
          fptr.setFILEID(fileID);
          div.getContent().add(fptr);
          contentDivs.add(div);
        }
        file.setSEQ(bitstreams[bits].getSequenceID());
        String groupID=""String_Node_Str"" + xmlIDstart + sid;
        if ((bundles[i].getName() != null) && (bundles[i].getName().equals(""String_Node_Str"") || bundles[i].getName().startsWith(""String_Node_Str""))) {
          Bitstream original=findOriginalBitstream(item,bitstreams[bits]);
          if (original != null) {
            groupID=""String_Node_Str"" + xmlIDstart + original.getSequenceID();
          }
        }
        file.setGROUPID(groupID);
        file.setMIMETYPE(bitstreams[bits].getFormat().getMIMEType());
        file.setSIZE(bitstreams[bits].getSize());
        String csType=bitstreams[bits].getChecksumAlgorithm();
        String cs=bitstreams[bits].getChecksum();
        if (cs != null && csType != null) {
          try {
            file.setCHECKSUMTYPE(Checksumtype.parse(csType));
            file.setCHECKSUM(cs);
          }
 catch (          MetsException e) {
            log.warn(""String_Node_Str"" + csType + ""String_Node_Str"");
          }
        }
        FLocat flocat=new FLocat();
        flocat.setLOCTYPE(Loctype.URL);
        flocat.setXlinkHref(makeBitstreamName(bitstreams[bits]));
        String techID=""String_Node_Str"" + bitstreams[bits].getSequenceID();
        AmdSec fAmdSec=new AmdSec();
        fAmdSec.setID(techID);
        TechMD techMd=new TechMD();
        techMd.setID(gensym(""String_Node_Str""));
        MdWrap mdWrap=new MdWrap();
        setMdType(mdWrap,metsName);
        XmlData xmlData=new XmlData();
        mdWrap.getContent().add(xmlData);
        techMd.getContent().add(mdWrap);
        fAmdSec.getContent().add(techMd);
        mets.getContent().add(fAmdSec);
        crosswalkToMets(xwalk,bitstreams[bits],xmlData);
        file.setADMID(techID);
        file.getContent().add(flocat);
        fileGrp.getContent().add(file);
      }
      fileSec.getContent().add(fileGrp);
    }
    mets.getContent().add(fileSec);
    StringBuffer dmdIds=new StringBuffer();
    for (int i=0; i < dmdId.length; ++i)     dmdIds.append(""String_Node_Str"" + dmdId[i]);
    StructMap structMap=new StructMap();
    structMap.setID(gensym(""String_Node_Str""));
    structMap.setTYPE(""String_Node_Str"");
    structMap.setLABEL(""String_Node_Str"");
    Div div0=new Div();
    div0.setID(gensym(""String_Node_Str""));
    div0.setTYPE(""String_Node_Str"");
    div0.setDMDID(dmdIds.substring(1));
    if (licenseID != null)     div0.setADMID(licenseID);
    if (primaryBitstreamFileID != null) {
      Fptr fptr=new Fptr();
      fptr.setFILEID(primaryBitstreamFileID);
      div0.getContent().add(fptr);
    }
    div0.getContent().addAll(contentDivs);
    structMap.getContent().add(div0);
    addStructMap(context,item,params,mets);
    mets.getContent().add(structMap);
    mets.validate(new MetsValidator());
    mets.write(new MetsWriter(out));
  }
 catch (  MetsException e) {
    throw new PackageValidationException(e);
  }
}","/** 
 * Write out a METS manifest. Mostly lifted from Rob Tansley's METS exporter.
 */
private void writeManifest(Context context,Item item,PackageParameters params,OutputStream out) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
  try {
    Mets mets=new Mets();
    mets.setID(gensym(""String_Node_Str""));
    mets.setOBJID(""String_Node_Str"" + item.getHandle());
    mets.setLABEL(""String_Node_Str"");
    mets.setPROFILE(getProfile());
    MetsHdr metsHdr=new MetsHdr();
    metsHdr.setCREATEDATE(new Date());
    Agent agent=new Agent();
    agent.setROLE(Role.CUSTODIAN);
    agent.setTYPE(Type.ORGANIZATION);
    Name name=new Name();
    name.getContent().add(new PCData(ConfigurationManager.getProperty(""String_Node_Str"")));
    agent.getContent().add(name);
    metsHdr.getContent().add(agent);
    mets.getContent().add(metsHdr);
    String dmdTypes[]=getDmdTypes(params);
    String dmdGroup=gensym(""String_Node_Str"");
    String dmdId[]=new String[dmdTypes.length];
    for (int i=0; i < dmdTypes.length; ++i) {
      dmdId[i]=gensym(""String_Node_Str"");
      XmlData xmlData=new XmlData();
      String xwalkName, metsName;
      String parts[]=dmdTypes[i].split(""String_Node_Str"",2);
      if (parts.length > 1) {
        metsName=parts[0];
        xwalkName=parts[1];
      }
 else       xwalkName=metsName=dmdTypes[i];
      DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkName);
      if (xwalk == null)       throw new PackageValidationException(""String_Node_Str"" + dmdTypes[i] + ""String_Node_Str"");
 else       crosswalkToMets(xwalk,item,xmlData);
      DmdSec dmdSec=new DmdSec();
      dmdSec.setID(dmdId[i]);
      dmdSec.setGROUPID(dmdGroup);
      MdWrap mdWrap=new MdWrap();
      setMdType(mdWrap,metsName);
      mdWrap.getContent().add(xmlData);
      dmdSec.getContent().add(mdWrap);
      mets.getContent().add(dmdSec);
    }
    String licenseID=null;
    try {
      AmdSec amdSec=new AmdSec();
      addRightsMd(context,item,amdSec);
      if (amdSec.getContent().size() > 0) {
        licenseID=gensym(""String_Node_Str"");
        amdSec.setID(licenseID);
        mets.getContent().add(amdSec);
      }
    }
 catch (    AuthorizeException e) {
      String unauth=(params == null) ? null : params.getProperty(""String_Node_Str"");
      if (!(unauth != null && unauth.equalsIgnoreCase(""String_Node_Str"")))       throw e;
 else       log.warn(""String_Node_Str"" + e.toString());
    }
    FileSec fileSec=new FileSec();
    String techMdType=getTechMdType(params);
    String parts[]=techMdType.split(""String_Node_Str"",2);
    String xwalkName, metsName;
    if (parts.length > 1) {
      metsName=parts[0];
      xwalkName=parts[1];
    }
 else     xwalkName=metsName=techMdType;
    DisseminationCrosswalk xwalk=(DisseminationCrosswalk)PluginManager.getNamedPlugin(DisseminationCrosswalk.class,xwalkName);
    if (xwalk == null)     throw new PackageValidationException(""String_Node_Str"" + xwalkName + ""String_Node_Str"");
    String primaryBitstreamFileID=null;
    List contentDivs=new ArrayList();
    String unauth=(params == null) ? null : params.getProperty(""String_Node_Str"");
    Bundle[] bundles=item.getBundles();
    for (int i=0; i < bundles.length; i++) {
      if (PackageUtils.isMetaInfoBundle(bundles[i]))       continue;
      if (!AuthorizeManager.authorizeActionBoolean(context,bundles[i],Constants.READ)) {
        if (unauth != null && (unauth.equalsIgnoreCase(""String_Node_Str"")))         continue;
 else         throw new AuthorizeException(""String_Node_Str"" + bundles[i].getName() + ""String_Node_Str"");
      }
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      FileGrp fileGrp=new FileGrp();
      String bName=bundles[i].getName();
      if ((bName != null) && !bName.equals(""String_Node_Str""))       fileGrp.setUSE(bundleToFileGrp(bName));
      int primaryBitstreamID=-1;
      boolean isContentBundle=false;
      if ((bName != null) && bName.equals(""String_Node_Str"")) {
        isContentBundle=true;
        primaryBitstreamID=bundles[i].getPrimaryBitstreamID();
      }
      for (int bits=0; bits < bitstreams.length; bits++) {
        boolean auth=AuthorizeManager.authorizeActionBoolean(context,bitstreams[bits],Constants.READ);
        if (!auth) {
          if (unauth != null && unauth.equalsIgnoreCase(""String_Node_Str""))           continue;
 else           if (!(unauth != null && unauth.equalsIgnoreCase(""String_Node_Str"")))           throw new AuthorizeException(""String_Node_Str"" + String.valueOf(bitstreams[bits].getSequenceID()));
        }
        String sid=String.valueOf(bitstreams[bits].getSequenceID());
        edu.harvard.hul.ois.mets.File file=new edu.harvard.hul.ois.mets.File();
        String xmlIDstart=""String_Node_Str"";
        String fileID=xmlIDstart + sid;
        file.setID(fileID);
        if (bitstreams[bits].getID() == primaryBitstreamID)         primaryBitstreamFileID=fileID;
        if (isContentBundle) {
          Div div=new Div();
          div.setID(gensym(""String_Node_Str""));
          div.setTYPE(""String_Node_Str"");
          Fptr fptr=new Fptr();
          fptr.setFILEID(fileID);
          div.getContent().add(fptr);
          contentDivs.add(div);
        }
        file.setSEQ(bitstreams[bits].getSequenceID());
        String groupID=""String_Node_Str"" + xmlIDstart + sid;
        if ((bundles[i].getName() != null) && (bundles[i].getName().equals(""String_Node_Str"") || bundles[i].getName().startsWith(""String_Node_Str""))) {
          Bitstream original=findOriginalBitstream(item,bitstreams[bits]);
          if (original != null) {
            groupID=""String_Node_Str"" + xmlIDstart + original.getSequenceID();
          }
        }
        file.setGROUPID(groupID);
        file.setMIMETYPE(bitstreams[bits].getFormat().getMIMEType());
        file.setSIZE(auth ? bitstreams[bits].getSize() : 0);
        String csType=bitstreams[bits].getChecksumAlgorithm();
        String cs=bitstreams[bits].getChecksum();
        if (auth && cs != null && csType != null) {
          try {
            file.setCHECKSUMTYPE(Checksumtype.parse(csType));
            file.setCHECKSUM(cs);
          }
 catch (          MetsException e) {
            log.warn(""String_Node_Str"" + csType + ""String_Node_Str"");
          }
        }
        FLocat flocat=new FLocat();
        flocat.setLOCTYPE(Loctype.URL);
        flocat.setXlinkHref(makeBitstreamName(bitstreams[bits]));
        String techID=""String_Node_Str"" + bitstreams[bits].getSequenceID();
        AmdSec fAmdSec=new AmdSec();
        fAmdSec.setID(techID);
        TechMD techMd=new TechMD();
        techMd.setID(gensym(""String_Node_Str""));
        MdWrap mdWrap=new MdWrap();
        setMdType(mdWrap,metsName);
        XmlData xmlData=new XmlData();
        mdWrap.getContent().add(xmlData);
        techMd.getContent().add(mdWrap);
        fAmdSec.getContent().add(techMd);
        mets.getContent().add(fAmdSec);
        crosswalkToMets(xwalk,bitstreams[bits],xmlData);
        file.setADMID(techID);
        file.getContent().add(flocat);
        fileGrp.getContent().add(file);
      }
      fileSec.getContent().add(fileGrp);
    }
    mets.getContent().add(fileSec);
    StringBuffer dmdIds=new StringBuffer();
    for (int i=0; i < dmdId.length; ++i)     dmdIds.append(""String_Node_Str"" + dmdId[i]);
    StructMap structMap=new StructMap();
    structMap.setID(gensym(""String_Node_Str""));
    structMap.setTYPE(""String_Node_Str"");
    structMap.setLABEL(""String_Node_Str"");
    Div div0=new Div();
    div0.setID(gensym(""String_Node_Str""));
    div0.setTYPE(""String_Node_Str"");
    div0.setDMDID(dmdIds.substring(1));
    if (licenseID != null)     div0.setADMID(licenseID);
    if (primaryBitstreamFileID != null) {
      Fptr fptr=new Fptr();
      fptr.setFILEID(primaryBitstreamFileID);
      div0.getContent().add(fptr);
    }
    div0.getContent().addAll(contentDivs);
    structMap.getContent().add(div0);
    addStructMap(context,item,params,mets);
    mets.getContent().add(structMap);
    mets.validate(new MetsValidator());
    mets.write(new MetsWriter(out));
  }
 catch (  MetsException e) {
    throw new PackageValidationException(e);
  }
}",0.9268134294434704
3579,"/** 
 * Create a PreparedStatement to run the correct query for scope.
 * @param scope The Browse scope
 * @param subqueryValue If the focus is an item, this is its value in the browse index (its title, author, date, etc). Otherwise null.
 * @param after If true, create SQL to find the items after the focus. Otherwise create SQL to find the items before the focus.
 * @param isCount If true, create SQL to count the number of matches for the query. Otherwise just the query.
 * @return a prepared statement
 * @throws SQLException
 */
private static PreparedStatement createSql(BrowseScope scope,String subqueryValue,boolean after,boolean isCount) throws SQLException {
  String sqli=createSqlInternal(scope,subqueryValue,isCount);
  String sql=formatSql(scope,sqli,subqueryValue,after);
  PreparedStatement statement=createStatement(scope,sql);
  if (scope.hasFocus()) {
    String value=(subqueryValue != null) ? subqueryValue : (String)scope.getFocus();
    statement.setString(1,value);
    if (subqueryValue != null) {
      statement.setString(2,value);
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + sql + ""String_Node_Str"");
  }
  return statement;
}","/** 
 * Create a PreparedStatement to run the correct query for scope.
 * @param scope The Browse scope
 * @param subqueryValue If the focus is an item, this is its value in the browse index (its title, author, date, etc). Otherwise null.
 * @param after If true, create SQL to find the items after the focus. Otherwise create SQL to find the items before the focus.
 * @param isCount If true, create SQL to count the number of matches for the query. Otherwise just the query.
 * @return a prepared statement
 * @throws SQLException
 */
private static PreparedStatement createSql(BrowseScope scope,String subqueryValue,boolean after,boolean isCount) throws SQLException {
  String sqli=createSqlInternal(scope,subqueryValue,isCount);
  String sql=formatSql(scope,sqli,subqueryValue,after);
  PreparedStatement statement=createStatement(scope,sql);
  if (scope.hasFocus()) {
    String value=subqueryValue;
    if (value == null && scope.getFocus() instanceof String) {
      value=(String)scope.getFocus();
    }
    statement.setString(1,value);
    if (subqueryValue != null) {
      statement.setString(2,value);
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + sql + ""String_Node_Str"");
  }
  return statement;
}",0.8871499176276771
3580,"public void init(){
  String config=getServletContext().getInitParameter(""String_Node_Str"");
  ConfigurationManager.loadConfig(config);
  String log4jConfProp=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  String log4jConfXml=ConfigurationManager.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  File xmlFile=new File(log4jConfXml);
  if (xmlFile.exists()) {
    try {
      DOMConfigurator.configure(xmlFile.toURL());
      log.info(""String_Node_Str"");
    }
 catch (    MalformedURLException e) {
      PropertyConfigurator.configure(log4jConfProp);
      log.error(""String_Node_Str"" + ""String_Node_Str"" + e);
    }
  }
 else {
    PropertyConfigurator.configure(log4jConfProp);
    log.info(""String_Node_Str"");
  }
}","public void init(){
  String config=getServletContext().getInitParameter(""String_Node_Str"");
  ConfigurationManager.loadConfig(config);
}",0.2759315206445116
3581,"/** 
 * Create a list of the found history records.
 * @param history the list of history records to be iterated over.
 * @param osw the output stream writer to write to.
 * @throws IOException if io error occurs
 */
private void printHistoryRecords(List history,OutputStreamWriter osw) throws IOException {
  Iterator iter=history.iterator();
  while (iter.hasNext()) {
    ChecksumHistory historyInfo=(ChecksumHistory)iter.next();
    StringBuilder buf=new StringBuilder(1000);
    buf.append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getBitstreamId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(DATE_FORMAT_MAX.format(historyInfo.getProcessStartDate())).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(DATE_FORMAT_MAX.format(historyInfo.getProcessEndDate())).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getChecksumExpected()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getChecksumCalculated()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getResult()).append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    osw.write(buf.toString());
  }
}","/** 
 * Create a list of the found history records.
 * @param history the list of history records to be iterated over.
 * @param osw the output stream writer to write to.
 * @throws IOException if io error occurs
 */
private void printHistoryRecords(List history,OutputStreamWriter osw) throws IOException {
  Iterator iter=history.iterator();
  while (iter.hasNext()) {
    ChecksumHistory historyInfo=(ChecksumHistory)iter.next();
    StringBuffer buf=new StringBuffer(1000);
    buf.append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getBitstreamId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(DATE_FORMAT_MAX.format(historyInfo.getProcessStartDate())).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(DATE_FORMAT_MAX.format(historyInfo.getProcessEndDate())).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getChecksumExpected()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getChecksumCalculated()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(historyInfo.getResult()).append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    osw.write(buf.toString());
  }
}",0.9964838255977496
3582,"/** 
 * Create a list of the found history records.
 * @param bitstreams the list of history records to be iterated over.
 * @param osw the output stream to write to.
 * @throws IOException if io error occurs
 */
private void printDSpaceInfoRecords(List bitstreams,OutputStreamWriter osw) throws IOException {
  Iterator iter=bitstreams.iterator();
  while (iter.hasNext()) {
    DSpaceBitstreamInfo info=(DSpaceBitstreamInfo)iter.next();
    StringBuilder buf=new StringBuilder(1000);
    buf.append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getBitstreamFormatId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getDeleted()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getBitstreamId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getChecksumAlgorithm()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getInternalId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getName()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getSize()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getSource()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getStoredChecksum()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getStoreNumber()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getUserFormatDescription()).append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    osw.write(buf.toString());
  }
}","/** 
 * Create a list of the found history records.
 * @param bitstreams the list of history records to be iterated over.
 * @param osw the output stream to write to.
 * @throws IOException if io error occurs
 */
private void printDSpaceInfoRecords(List bitstreams,OutputStreamWriter osw) throws IOException {
  Iterator iter=bitstreams.iterator();
  while (iter.hasNext()) {
    DSpaceBitstreamInfo info=(DSpaceBitstreamInfo)iter.next();
    StringBuffer buf=new StringBuffer(1000);
    buf.append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getBitstreamFormatId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getDeleted()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getBitstreamId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getChecksumAlgorithm()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getInternalId()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getName()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getSize()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getSource()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getStoredChecksum()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getStoreNumber()).append(""String_Node_Str"");
    buf.append(msg(""String_Node_Str"")).append(""String_Node_Str"").append(info.getUserFormatDescription()).append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    osw.write(buf.toString());
  }
}",0.9974146845915202
3583,"/** 
 * Slightly convenient method that appends together a msg key and a class name together and retrieves the corresponding message from Messages.properties
 * @param msg final part of message key, omitting fully qualified class name
 * @param classname fully qualified class name.
 * @return Localized message
 */
public String getMessage(String msg,String classname){
  return messages.getString(new StringBuilder(50).append(classname).append(""String_Node_Str"").append(msg).toString());
}","/** 
 * <p> Convenience method to get localized messages in code. Usage will be of the form: - </p> <pre> I18N.message(&quot;my-key&quot;, this); </pre> <p> N.B. That this method uses the runtime type of the object, and hence should only be used in final classes. </p>
 * @param msg Key for the message, omitting the fully qualified class name
 * @param obj the calling object
 * @return Localized message 
 */
public String getMessage(String msg,Object obj){
  return getMessage(msg,obj.getClass());
}",0.3423967774420947
3584,"/** 
 * Return true if an index has changed
 * @param key
 * @return
 * @throws SQLException
 */
public static boolean indexHasChanged(BrowseScope key) throws SQLException {
  Context context=null;
  try {
    context=new Context();
    TableRow results=countAndMax(context,key);
    long count=-1;
    int max=-1;
    if (results != null) {
      count=results.getLongColumn(""String_Node_Str"");
      max=results.getIntColumn(""String_Node_Str"");
    }
    context.complete();
    if ((count == getCount(key)) && (max == getMaximum(key))) {
      return false;
    }
    setMaximum(key,max);
    setCount(key,count);
    return true;
  }
 catch (  SQLException sqle) {
    if (context != null) {
      context.abort();
    }
    throw sqle;
  }
}","/** 
 * Return true if an index has changed
 * @param key
 * @return
 * @throws SQLException
 */
public static boolean indexHasChanged(BrowseScope key) throws SQLException {
  Context context=null;
  try {
    context=new Context();
    TableRow results=countAndMax(context,key);
    long count=-1;
    int max=-1;
    if (results != null) {
      if (""String_Node_Str"".equals(ConfigurationManager.getProperty(""String_Node_Str""))) {
        count=results.getIntColumn(""String_Node_Str"");
      }
 else {
        count=results.getLongColumn(""String_Node_Str"");
      }
      max=results.getIntColumn(""String_Node_Str"");
    }
    context.complete();
    if ((count == getCount(key)) && (max == getMaximum(key))) {
      return false;
    }
    setMaximum(key,max);
    setCount(key,count);
    return true;
  }
 catch (  SQLException sqle) {
    if (context != null) {
      context.abort();
    }
    throw sqle;
  }
}",0.8617788461538461
3585,"/** 
 * counts items in this community
 * @return  total items
 */
public int countItems() throws SQLException {
  int collitems=0;
  int commitems=0;
  Collection[] cols=getCollections();
  if (cols.length > 0) {
    for (int j=0; j < cols.length; j++) {
      collitems=cols[j].countItems();
      commitems+=collitems;
    }
  }
  return commitems;
}","/** 
 * counts items in this community
 * @return  total items
 */
public int countItems() throws SQLException {
  int total=0;
  Collection[] cols=getCollections();
  for (int i=0; i < cols.length; i++) {
    total+=cols[i].countItems();
  }
  Community[] comms=getSubcommunities();
  for (int j=0; j < comms.length; j++) {
    total+=comms[j].countItems();
  }
  return total;
}",0.572987721691678
3586,"/** 
 * Create both the bitstreams and the contents file. Any bitstreams that were originally registered will be marked in the contents file as such. However, the export directory will contain actual copies of the content files being exported.
 * @param c the DSpace context
 * @param i the item being exported
 * @param destDir the item's export directory
 * @throws Exception if there is any problem writing to the export directory
 */
private static void writeBitstreams(Context c,Item i,File destDir) throws Exception {
  File outFile=new File(destDir,""String_Node_Str"");
  if (outFile.createNewFile()) {
    PrintWriter out=new PrintWriter(new FileWriter(outFile));
    Bundle[] bundles=i.getBundles();
    for (int j=0; j < bundles.length; j++) {
      Bitstream[] bitstreams=bundles[j].getBitstreams();
      String bundleName=bundles[j].getName();
      for (int k=0; k < bitstreams.length; k++) {
        Bitstream b=bitstreams[k];
        String myName=b.getName();
        String oldName=myName;
        int myPrefix=1;
        InputStream is=b.retrieve();
        boolean isDone=false;
        while (!isDone) {
          File fout=new File(destDir,myName);
          if (fout.createNewFile()) {
            FileOutputStream fos=new FileOutputStream(fout);
            Utils.bufferedCopy(is,fos);
            if (b.isRegisteredBitstream()) {
              out.println(""String_Node_Str"" + b.getStoreNumber() + ""String_Node_Str""+ myName+ ""String_Node_Str""+ bundleName);
            }
 else {
              out.println(myName + ""String_Node_Str"" + bundleName);
            }
            isDone=true;
          }
 else {
            myName=myPrefix + ""String_Node_Str"" + oldName;
            myPrefix++;
          }
        }
      }
    }
    out.close();
  }
 else {
    throw new Exception(""String_Node_Str"" + destDir);
  }
}","/** 
 * Create both the bitstreams and the contents file. Any bitstreams that were originally registered will be marked in the contents file as such. However, the export directory will contain actual copies of the content files being exported.
 * @param c the DSpace context
 * @param i the item being exported
 * @param destDir the item's export directory
 * @throws Exception if there is any problem writing to the export directory
 */
private static void writeBitstreams(Context c,Item i,File destDir) throws Exception {
  File outFile=new File(destDir,""String_Node_Str"");
  if (outFile.createNewFile()) {
    PrintWriter out=new PrintWriter(new FileWriter(outFile));
    Bundle[] bundles=i.getBundles();
    for (int j=0; j < bundles.length; j++) {
      Bitstream[] bitstreams=bundles[j].getBitstreams();
      String bundleName=bundles[j].getName();
      for (int k=0; k < bitstreams.length; k++) {
        Bitstream b=bitstreams[k];
        String myName=b.getName();
        String oldName=myName;
        int myPrefix=1;
        InputStream is=b.retrieve();
        boolean isDone=false;
        while (!isDone) {
          File fout=new File(destDir,myName);
          if (fout.createNewFile()) {
            FileOutputStream fos=new FileOutputStream(fout);
            Utils.bufferedCopy(is,fos);
            is.close();
            fos.close();
            if (b.isRegisteredBitstream()) {
              out.println(""String_Node_Str"" + b.getStoreNumber() + ""String_Node_Str""+ myName+ ""String_Node_Str""+ bundleName);
            }
 else {
              out.println(myName + ""String_Node_Str"" + bundleName);
            }
            isDone=true;
          }
 else {
            myName=myPrefix + ""String_Node_Str"" + oldName;
            myPrefix++;
          }
        }
      }
    }
    out.close();
  }
 else {
    throw new Exception(""String_Node_Str"" + destDir);
  }
}",0.986831496909433
3587,"/** 
 * Given a contents file and an item, stuffing it with bitstreams from the contents file
 */
private void processContentsFile(Context c,Item i,String path,String filename) throws SQLException, IOException, AuthorizeException {
  String contentspath=path + File.separatorChar + filename;
  String line=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + contentspath);
  BufferedReader is=null;
  try {
    is=new BufferedReader(new FileReader(contentspath));
    while ((line=is.readLine()) != null) {
      if (""String_Node_Str"".equals(line.trim())) {
        continue;
      }
      if (line.trim().startsWith(""String_Node_Str"")) {
        String sRegistrationLine=line.trim();
        int iAssetstore=-1;
        String sFilePath=null;
        String sBundle=null;
        StringTokenizer tokenizer=new StringTokenizer(sRegistrationLine);
        while (tokenizer.hasMoreTokens()) {
          String sToken=tokenizer.nextToken();
          if (sToken.equals(""String_Node_Str"")) {
            continue;
          }
 else           if (sToken.equals(""String_Node_Str"") && tokenizer.hasMoreTokens()) {
            try {
              iAssetstore=Integer.parseInt(tokenizer.nextToken());
            }
 catch (            NumberFormatException e) {
            }
          }
 else           if (sToken.equals(""String_Node_Str"") && tokenizer.hasMoreTokens()) {
            sFilePath=tokenizer.nextToken();
          }
 else           if (sToken.startsWith(""String_Node_Str"")) {
            sBundle=sToken.substring(7);
          }
 else {
          }
        }
        if (iAssetstore == -1 || sFilePath == null) {
          System.out.println(""String_Node_Str"");
          System.out.println(""String_Node_Str"" + sRegistrationLine);
          continue;
        }
        registerBitstream(c,i,iAssetstore,sFilePath,sBundle);
        System.out.println(""String_Node_Str"" + sFilePath + ""String_Node_Str""+ iAssetstore+ ""String_Node_Str""+ sBundle);
        continue;
      }
      String bundleMarker=""String_Node_Str"";
      int markerIndex=line.indexOf(bundleMarker);
      if (markerIndex == -1) {
        processContentFileEntry(c,i,path,line,null);
        System.out.println(""String_Node_Str"" + line);
      }
 else {
        String bundleName=line.substring(markerIndex + bundleMarker.length());
        String bitstreamName=line.substring(0,markerIndex);
        processContentFileEntry(c,i,path,bitstreamName,bundleName);
        System.out.println(""String_Node_Str"" + bitstreamName + ""String_Node_Str""+ bundleName);
      }
    }
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}","/** 
 * Given a contents file and an item, stuffing it with bitstreams from the contents file
 */
private void processContentsFile(Context c,Item i,String path,String filename) throws SQLException, IOException, AuthorizeException {
  String contentspath=path + File.separatorChar + filename;
  String line=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + contentspath);
  BufferedReader is=null;
  try {
    is=new BufferedReader(new FileReader(contentspath));
    while ((line=is.readLine()) != null) {
      if (""String_Node_Str"".equals(line.trim())) {
        continue;
      }
      if (line.trim().startsWith(""String_Node_Str"")) {
        String sRegistrationLine=line.trim();
        int iAssetstore=-1;
        String sFilePath=null;
        String sBundle=null;
        StringTokenizer tokenizer=new StringTokenizer(sRegistrationLine);
        while (tokenizer.hasMoreTokens()) {
          String sToken=tokenizer.nextToken();
          if (sToken.equals(""String_Node_Str"")) {
            continue;
          }
 else           if (sToken.equals(""String_Node_Str"") && tokenizer.hasMoreTokens()) {
            try {
              iAssetstore=Integer.parseInt(tokenizer.nextToken());
            }
 catch (            NumberFormatException e) {
            }
          }
 else           if (sToken.equals(""String_Node_Str"") && tokenizer.hasMoreTokens()) {
            sFilePath=tokenizer.nextToken();
          }
 else           if (sToken.startsWith(""String_Node_Str"")) {
            sBundle=sToken.substring(7);
          }
 else {
          }
        }
        if (iAssetstore == -1 || sFilePath == null) {
          System.out.println(""String_Node_Str"");
          System.out.println(""String_Node_Str"" + sRegistrationLine);
          continue;
        }
        registerBitstream(c,i,iAssetstore,sFilePath,sBundle);
        System.out.println(""String_Node_Str"" + sFilePath + ""String_Node_Str""+ iAssetstore+ ""String_Node_Str""+ sBundle);
        continue;
      }
      String bundleMarker=""String_Node_Str"";
      int markerIndex=line.indexOf(bundleMarker);
      if (markerIndex == -1) {
        processContentFileEntry(c,i,path,line,null);
        System.out.println(""String_Node_Str"" + line);
      }
 else {
        String bundleName=line.substring(markerIndex + bundleMarker.length());
        String bitstreamName=line.substring(0,markerIndex);
        bitstreamName=bitstreamName.trim();
        processContentFileEntry(c,i,path,bitstreamName,bundleName);
        System.out.println(""String_Node_Str"" + bitstreamName + ""String_Node_Str""+ bundleName);
      }
    }
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}",0.9916540212443096
3588,"/** 
 * read the input file and populate all the class globals with the contents The values that come from this file form the basis of the analysis report
 * @param input   the aggregator file
 */
public static void readInput(String input) throws IOException, ParseException {
  FileReader fr=null;
  BufferedReader br=null;
  String record=null;
  try {
    fr=new FileReader(input);
    br=new BufferedReader(fr);
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  while ((record=br.readLine()) != null) {
    Matcher matchReal=real.matcher(record);
    String section=null;
    String key=null;
    String value=null;
    String left=null;
    if (matchReal.matches()) {
      left=matchReal.group(1).trim();
      value=matchReal.group(2).trim();
      StringTokenizer tokens=new StringTokenizer(left,""String_Node_Str"");
      int numTokens=tokens.countTokens();
      if (tokens.hasMoreTokens()) {
        section=tokens.nextToken();
        if (numTokens > 1) {
          key=left.substring(section.length() + 1);
        }
 else {
          key=""String_Node_Str"";
        }
      }
    }
 else {
      continue;
    }
    DateFormat df=DateFormat.getInstance();
    if (section.equals(""String_Node_Str"")) {
      archiveStats.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      actionAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      userAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      searchAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      itemAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      userEmail=value;
    }
    if (section.equals(""String_Node_Str"")) {
      itemFloor=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      searchFloor=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      url=value;
    }
    if (section.equals(""String_Node_Str"")) {
      itemLookup=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      try {
        avgItemViews=Integer.parseInt(value);
      }
 catch (      NumberFormatException e) {
        avgItemViews=0;
      }
    }
    if (section.equals(""String_Node_Str"")) {
      serverName=value;
    }
    if (section.equals(""String_Node_Str"")) {
      name=value;
    }
    if (section.equals(""String_Node_Str"")) {
      startDate=df.parse(value);
    }
    if (section.equals(""String_Node_Str"")) {
      endDate=df.parse(value);
    }
    if (section.equals(""String_Node_Str"")) {
      processTime=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      generalSummary.add(value);
    }
    if (section.equals(""String_Node_Str"")) {
      logLines=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      warnings=Integer.parseInt(value);
    }
  }
  br.close();
  fr.close();
}","/** 
 * read the input file and populate all the class globals with the contents The values that come from this file form the basis of the analysis report
 * @param input   the aggregator file
 */
public static void readInput(String input) throws IOException, ParseException {
  FileReader fr=null;
  BufferedReader br=null;
  String record=null;
  try {
    fr=new FileReader(input);
    br=new BufferedReader(fr);
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  while ((record=br.readLine()) != null) {
    Matcher matchReal=real.matcher(record);
    String section=null;
    String key=null;
    String value=null;
    String left=null;
    if (matchReal.matches()) {
      left=matchReal.group(1).trim();
      value=matchReal.group(2).trim();
      StringTokenizer tokens=new StringTokenizer(left,""String_Node_Str"");
      int numTokens=tokens.countTokens();
      if (tokens.hasMoreTokens()) {
        section=tokens.nextToken();
        if (numTokens > 1) {
          key=left.substring(section.length() + 1);
        }
 else {
          key=""String_Node_Str"";
        }
      }
    }
 else {
      continue;
    }
    SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
    if (section.equals(""String_Node_Str"")) {
      archiveStats.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      actionAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      userAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      searchAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      itemAggregator.put(key,value);
    }
    if (section.equals(""String_Node_Str"")) {
      userEmail=value;
    }
    if (section.equals(""String_Node_Str"")) {
      itemFloor=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      searchFloor=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      url=value;
    }
    if (section.equals(""String_Node_Str"")) {
      itemLookup=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      try {
        avgItemViews=Integer.parseInt(value);
      }
 catch (      NumberFormatException e) {
        avgItemViews=0;
      }
    }
    if (section.equals(""String_Node_Str"")) {
      serverName=value;
    }
    if (section.equals(""String_Node_Str"")) {
      name=value;
    }
    if (section.equals(""String_Node_Str"")) {
      startDate=sdf.parse(value);
    }
    if (section.equals(""String_Node_Str"")) {
      endDate=sdf.parse(value);
    }
    if (section.equals(""String_Node_Str"")) {
      processTime=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      generalSummary.add(value);
    }
    if (section.equals(""String_Node_Str"")) {
      logLines=Integer.parseInt(value);
    }
    if (section.equals(""String_Node_Str"")) {
      warnings=Integer.parseInt(value);
    }
  }
  br.close();
  fr.close();
}",0.9906229068988612
3589,"/** 
 * Set the short description of the bitstream format
 * @param s the new short description
 */
public void setShortDescription(String s) throws SQLException {
  BitstreamFormat unknown=findUnknown(bfContext);
  if (unknown.getID() != getID())   bfRow.setColumn(""String_Node_Str"",s);
}","/** 
 * Set the short description of the bitstream format
 * @param s the new short description
 */
public void setShortDescription(String s) throws SQLException {
  BitstreamFormat unknown=null;
  ;
  try {
    unknown=findUnknown(bfContext);
  }
 catch (  IllegalStateException e) {
  }
  if (unknown == null || unknown.getID() != getID()) {
    bfRow.setColumn(""String_Node_Str"",s);
  }
}",0.8382352941176471
3590,"private void replaceItems(Context c,Collection[] mycollections,String sourceDir,String mapFile) throws Exception {
  File d=new java.io.File(sourceDir);
  if (d == null) {
    System.out.println(""String_Node_Str"" + sourceDir);
    System.exit(1);
  }
  Map myhash=readMapFile(mapFile);
  Iterator i=myhash.keySet().iterator();
  ArrayList itemsToDelete=new ArrayList();
  while (i.hasNext()) {
    String newItemName=(String)i.next();
    String oldHandle=(String)myhash.get(newItemName);
    Item oldItem=null;
    Item newItem=null;
    if (oldHandle.indexOf('/') != -1) {
      System.out.println(""String_Node_Str"" + oldHandle);
      oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    }
 else {
      oldItem=Item.find(c,Integer.parseInt(oldHandle));
    }
    newItem=addItem(c,mycollections,sourceDir,newItemName,null);
    itemsToDelete.add(oldItem);
  }
  i=itemsToDelete.iterator();
  while (i.hasNext()) {
    deleteItem(c,(Item)i.next());
  }
}","private void replaceItems(Context c,Collection[] mycollections,String sourceDir,String mapFile) throws Exception {
  File d=new java.io.File(sourceDir);
  if (d == null) {
    System.out.println(""String_Node_Str"" + sourceDir);
    System.exit(1);
  }
  Map myhash=readMapFile(mapFile);
  Iterator i=myhash.keySet().iterator();
  ArrayList itemsToDelete=new ArrayList();
  while (i.hasNext()) {
    String newItemName=(String)i.next();
    String oldHandle=(String)myhash.get(newItemName);
    Item oldItem=null;
    Item newItem=null;
    if (oldHandle.indexOf('/') != -1) {
      System.out.println(""String_Node_Str"" + oldHandle);
      oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    }
 else {
      oldItem=Item.find(c,Integer.parseInt(oldHandle));
    }
    File handleFile=new File(sourceDir + File.separatorChar + newItemName+ File.separatorChar+ ""String_Node_Str"");
    PrintWriter handleOut=new PrintWriter(new FileWriter(handleFile,true));
    if (handleOut == null) {
      throw new Exception(""String_Node_Str"" + handleFile.getCanonicalPath());
    }
    handleOut.println(oldHandle);
    handleOut.close();
    deleteItem(c,oldItem);
    newItem=addItem(c,mycollections,sourceDir,newItemName,null);
  }
}",0.7513661202185792
3591,"public String buildHTTPQuery(HttpServletRequest request){
  String querystring=""String_Node_Str"";
  HashMap queryHash=buildQueryHash(request);
  Iterator i=queryHash.keySet().iterator();
  while (i.hasNext()) {
    String key=(String)i.next();
    String value=(String)queryHash.get(key);
    querystring=querystring + ""String_Node_Str"" + key+ ""String_Node_Str""+ value;
  }
  return (querystring);
}","public String buildHTTPQuery(HttpServletRequest request) throws UnsupportedEncodingException {
  String querystring=""String_Node_Str"";
  HashMap queryHash=buildQueryHash(request);
  Iterator i=queryHash.keySet().iterator();
  while (i.hasNext()) {
    String key=(String)i.next();
    String value=(String)queryHash.get(key);
    querystring=querystring + ""String_Node_Str"" + key+ ""String_Node_Str""+ URLEncoder.encode(value,Constants.DEFAULT_ENCODING);
  }
  return (querystring);
}",0.905788876276958
3592,"/** 
 * Process the input from the upload logo page
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processUploadLogo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Community community=Community.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  Collection collection=Collection.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  File temp=wrapper.getFile(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(temp));
  Bitstream logoBS;
  if (community != null) {
    logoBS=community.setLogo(is);
  }
 else {
    logoBS=collection.setLogo(is);
  }
  String noPath=wrapper.getFilesystemName(""String_Node_Str"");
  while (noPath.indexOf('/') > -1) {
    noPath=noPath.substring(noPath.indexOf('/') + 1);
  }
  while (noPath.indexOf('\\') > -1) {
    noPath=noPath.substring(noPath.indexOf('\\') + 1);
  }
  logoBS.setName(noPath);
  logoBS.setSource(wrapper.getFilesystemName(""String_Node_Str""));
  BitstreamFormat bf=FormatIdentifier.guessFormat(context,logoBS);
  logoBS.setFormat(bf);
  logoBS.update();
  if (community != null) {
    community.update();
    request.setAttribute(""String_Node_Str"",community);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    collection.update();
    request.setAttribute(""String_Node_Str"",collection);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
  temp.delete();
  context.complete();
}","/** 
 * Process the input from the upload logo page
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processUploadLogo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Community community=Community.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  Collection collection=Collection.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  File temp=wrapper.getFile(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(temp));
  Bitstream logoBS;
  if (collection == null) {
    logoBS=community.setLogo(is);
  }
 else {
    logoBS=collection.setLogo(is);
  }
  String noPath=wrapper.getFilesystemName(""String_Node_Str"");
  while (noPath.indexOf('/') > -1) {
    noPath=noPath.substring(noPath.indexOf('/') + 1);
  }
  while (noPath.indexOf('\\') > -1) {
    noPath=noPath.substring(noPath.indexOf('\\') + 1);
  }
  logoBS.setName(noPath);
  logoBS.setSource(wrapper.getFilesystemName(""String_Node_Str""));
  BitstreamFormat bf=FormatIdentifier.guessFormat(context,logoBS);
  logoBS.setFormat(bf);
  logoBS.update();
  if (collection == null) {
    community.update();
    request.setAttribute(""String_Node_Str"",community);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    collection.update();
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",community);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
  temp.delete();
  context.complete();
}",0.9731601731601732
3593,"/** 
 * Work out which page to show next, and show it
 * @param context
 * @param request
 * @param response
 * @param collection
 * @param stage  the stage the user just finished, or if PERMISSIONS, theparticular permissions page
 * @throws SQLException
 * @throws ServletException
 * @throws IOException
 * @throws AuthorizeException
 */
private void showNextPage(Context context,HttpServletRequest request,HttpServletResponse response,Collection collection,int stage) throws SQLException, ServletException, IOException, AuthorizeException {
  request.setAttribute(""String_Node_Str"",collection);
  if (Group.findByName(context,""String_Node_Str"") != null) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + stage));
switch (stage) {
case BASIC_INFO:
    List anonReadPols=AuthorizeManager.getPoliciesActionFilter(context,collection,Constants.DEFAULT_ITEM_READ);
  if (anonReadPols.size() == 0) {
    request.setAttribute(""String_Node_Str"",new Integer(PERM_READ));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    break;
  }
case PERM_READ:
if (collection.getSubmitters() != null) {
  request.setAttribute(""String_Node_Str"",new Integer(PERM_SUBMIT));
  JSPManager.showJSP(request,response,""String_Node_Str"");
  break;
}
case PERM_SUBMIT:
if (collection.getWorkflowGroup(1) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF1));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF1:
if (collection.getWorkflowGroup(2) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF2));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF2:
if (collection.getWorkflowGroup(3) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF3));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF3:
if (collection.getAdministrators() != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_ADMIN));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_ADMIN:
if (collection.getTemplateItem() != null) {
DCType[] types=DCType.findAll(context);
request.setAttribute(""String_Node_Str"",types);
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case DEFAULT_ITEM:
if (collection != null) {
Community[] communities=collection.getCommunities();
request.setAttribute(""String_Node_Str"",communities[0]);
}
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
}","/** 
 * Work out which page to show next, and show it
 * @param context
 * @param request
 * @param response
 * @param collection
 * @param stage  the stage the user just finished, or if PERMISSIONS, theparticular permissions page
 * @throws SQLException
 * @throws ServletException
 * @throws IOException
 * @throws AuthorizeException
 */
private void showNextPage(Context context,HttpServletRequest request,HttpServletResponse response,Collection collection,int stage) throws SQLException, ServletException, IOException, AuthorizeException {
  request.setAttribute(""String_Node_Str"",collection);
  if (Group.findByName(context,""String_Node_Str"") != null) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  log.debug(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + stage));
switch (stage) {
case BASIC_INFO:
    List anonReadPols=AuthorizeManager.getPoliciesActionFilter(context,collection,Constants.DEFAULT_ITEM_READ);
  if (anonReadPols.size() == 0) {
    request.setAttribute(""String_Node_Str"",new Integer(PERM_READ));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    break;
  }
case PERM_READ:
if (collection.getSubmitters() != null) {
  request.setAttribute(""String_Node_Str"",new Integer(PERM_SUBMIT));
  JSPManager.showJSP(request,response,""String_Node_Str"");
  break;
}
case PERM_SUBMIT:
if (collection.getWorkflowGroup(1) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF1));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF1:
if (collection.getWorkflowGroup(2) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF2));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF2:
if (collection.getWorkflowGroup(3) != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_WF3));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_WF3:
if (collection.getAdministrators() != null) {
request.setAttribute(""String_Node_Str"",new Integer(PERM_ADMIN));
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case PERM_ADMIN:
if (collection.getTemplateItem() != null) {
DCType[] types=DCType.findAll(context);
request.setAttribute(""String_Node_Str"",types);
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
case DEFAULT_ITEM:
if (collection != null) {
Community[] communities=collection.getCommunities();
request.setAttribute(""String_Node_Str"",communities[0]);
if (AuthorizeManager.isAdmin(context)) {
request.setAttribute(""String_Node_Str"",new Boolean(true));
}
}
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
}
}",0.9802248933695232
3594,"private void getThumbSettings(){
  showThumbs=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (showThumbs) {
    thumbItemListMaxHeight=ConfigurationManager.getIntProperty(""String_Node_Str"");
    thumbItemListMaxWidth=ConfigurationManager.getIntProperty(""String_Node_Str"");
    thumbMaxHeight=ConfigurationManager.getIntProperty(""String_Node_Str"");
    thumbMaxWidth=ConfigurationManager.getIntProperty(""String_Node_Str"");
  }
}","private void getThumbSettings(){
  showThumbs=ConfigurationManager.getBooleanProperty(""String_Node_Str"");
  if (showThumbs) {
    thumbItemListMaxHeight=ConfigurationManager.getIntProperty(""String_Node_Str"");
    if (thumbItemListMaxHeight == 0) {
      thumbItemListMaxHeight=ConfigurationManager.getIntProperty(""String_Node_Str"");
    }
    thumbItemListMaxWidth=ConfigurationManager.getIntProperty(""String_Node_Str"");
    if (thumbItemListMaxWidth == 0) {
      thumbItemListMaxWidth=ConfigurationManager.getIntProperty(""String_Node_Str"");
    }
  }
}",0.7307307307307307
3595,"/** 
 * writes an index record - the index record is a set of name/value hashes, which are sent to Lucene.
 */
private static void writeItemIndex(Context c,IndexWriter writer,Item myitem) throws SQLException, IOException {
  String location_text=buildItemLocationString(c,myitem);
  ArrayList indexes=new ArrayList();
  for (int i=1; ConfigurationManager.getProperty(""String_Node_Str"" + i) != null; i++) {
    indexes.add(ConfigurationManager.getProperty(""String_Node_Str"" + i));
  }
  int j, k=0;
  HashMap textvalues=new HashMap();
  if (indexes.size() > 0) {
    ArrayList fields=new ArrayList();
    ArrayList content=new ArrayList();
    DCValue[] mydc;
    for (int i=0; i < indexes.size(); i++) {
      String index=(String)indexes.get(i);
      String dc[]=index.split(""String_Node_Str"");
      String myindex=dc[0];
      String elements[]=dc[1].split(""String_Node_Str"");
      String element=elements[0];
      String qualifier=elements[1];
      if (qualifier.equals(""String_Node_Str"")) {
        mydc=myitem.getDC(element,Item.ANY,Item.ANY);
      }
 else {
        mydc=myitem.getDC(element,qualifier,Item.ANY);
      }
      String content_text=""String_Node_Str"";
      for (j=0; j < mydc.length; j++) {
        content_text=new String(content_text + mydc[j].value + ""String_Node_Str"");
      }
      k=fields.indexOf(myindex);
      if (k < 0) {
        fields.add(myindex);
        content.add(content_text);
      }
 else {
        content_text=new String(content_text + (String)content.get(k) + ""String_Node_Str"");
        content.set(k,content_text);
      }
    }
    for (int i=0; i < fields.size(); i++) {
      textvalues.put((String)fields.get(i),(String)content.get(i));
    }
  }
 else {
    DCValue[] authors=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] creators=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] titles=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] keywords=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] abstracts=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] sors=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] series=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] tocs=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] mimetypes=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] sponsors=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] identifiers=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    String author_text=""String_Node_Str"";
    String title_text=""String_Node_Str"";
    String keyword_text=""String_Node_Str"";
    String abstract_text=""String_Node_Str"";
    String sor_text=""String_Node_Str"";
    String series_text=""String_Node_Str"";
    String mime_text=""String_Node_Str"";
    String sponsor_text=""String_Node_Str"";
    String id_text=""String_Node_Str"";
    for (j=0; j < authors.length; j++) {
      author_text=new String(author_text + authors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < creators.length; j++) {
      author_text=new String(author_text + creators[j].value + ""String_Node_Str"");
    }
    for (j=0; j < sors.length; j++) {
      author_text=new String(author_text + sors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < titles.length; j++) {
      title_text=new String(title_text + titles[j].value + ""String_Node_Str"");
    }
    for (j=0; j < keywords.length; j++) {
      keyword_text=new String(keyword_text + keywords[j].value + ""String_Node_Str"");
    }
    for (j=0; j < abstracts.length; j++) {
      abstract_text=new String(abstract_text + abstracts[j].value + ""String_Node_Str"");
    }
    for (j=0; j < tocs.length; j++) {
      abstract_text=new String(abstract_text + tocs[j].value + ""String_Node_Str"");
    }
    for (j=0; j < series.length; j++) {
      series_text=new String(series_text + series[j].value + ""String_Node_Str"");
    }
    for (j=0; j < mimetypes.length; j++) {
      mime_text=new String(mime_text + mimetypes[j].value + ""String_Node_Str"");
    }
    for (j=0; j < sponsors.length; j++) {
      sponsor_text=new String(sponsor_text + sponsors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < identifiers.length; j++) {
      id_text=new String(id_text + identifiers[j].value + ""String_Node_Str"");
    }
    textvalues.put(""String_Node_Str"",author_text);
    textvalues.put(""String_Node_Str"",title_text);
    textvalues.put(""String_Node_Str"",keyword_text);
    textvalues.put(""String_Node_Str"",location_text);
    textvalues.put(""String_Node_Str"",abstract_text);
    textvalues.put(""String_Node_Str"",series_text);
    textvalues.put(""String_Node_Str"",mime_text);
    textvalues.put(""String_Node_Str"",sponsor_text);
    textvalues.put(""String_Node_Str"",id_text);
  }
  String extractedText=""String_Node_Str"";
  Bundle[] myBundles=myitem.getBundles();
  for (int i=0; i < myBundles.length; i++) {
    if (myBundles[i].getName() != null && myBundles[i].getName().equals(""String_Node_Str"")) {
      Bitstream[] myBitstreams=myBundles[i].getBitstreams();
      for (j=0; j < myBitstreams.length; j++) {
        try {
          InputStreamReader is=new InputStreamReader(myBitstreams[j].retrieve());
          StringBuffer sb=new StringBuffer();
          char[] charBuffer=new char[1024];
          while (true) {
            int bytesIn=is.read(charBuffer);
            if (bytesIn == -1)             break;
            if (bytesIn > 0) {
              sb.append(charBuffer,0,bytesIn);
            }
          }
          extractedText=extractedText.concat(new String(sb));
        }
 catch (        AuthorizeException e) {
        }
      }
    }
  }
  String itemhandle=HandleManager.findHandle(c,myitem);
  textvalues.put(""String_Node_Str"",itemhandle);
  writeIndexRecord(writer,Constants.ITEM,itemhandle,textvalues,extractedText);
}","/** 
 * writes an index record - the index record is a set of name/value hashes, which are sent to Lucene.
 */
private static void writeItemIndex(Context c,IndexWriter writer,Item myitem) throws SQLException, IOException {
  String location_text=buildItemLocationString(c,myitem);
  ArrayList indexes=new ArrayList();
  for (int i=1; ConfigurationManager.getProperty(""String_Node_Str"" + i) != null; i++) {
    indexes.add(ConfigurationManager.getProperty(""String_Node_Str"" + i));
  }
  int j, k=0;
  HashMap textvalues=new HashMap();
  if (indexes.size() > 0) {
    ArrayList fields=new ArrayList();
    ArrayList content=new ArrayList();
    DCValue[] mydc;
    for (int i=0; i < indexes.size(); i++) {
      String index=(String)indexes.get(i);
      String dc[]=index.split(""String_Node_Str"");
      String myindex=dc[0];
      String elements[]=dc[1].split(""String_Node_Str"");
      String element=elements[0];
      String qualifier=elements[1];
      if (qualifier.equals(""String_Node_Str"")) {
        mydc=myitem.getDC(element,Item.ANY,Item.ANY);
      }
 else {
        mydc=myitem.getDC(element,qualifier,Item.ANY);
      }
      String content_text=""String_Node_Str"";
      for (j=0; j < mydc.length; j++) {
        content_text=new String(content_text + mydc[j].value + ""String_Node_Str"");
      }
      k=fields.indexOf(myindex);
      if (k < 0) {
        fields.add(myindex);
        content.add(content_text);
      }
 else {
        content_text=new String(content_text + (String)content.get(k) + ""String_Node_Str"");
        content.set(k,content_text);
      }
    }
    for (int i=0; i < fields.size(); i++) {
      textvalues.put((String)fields.get(i),(String)content.get(i));
    }
    textvalues.put(""String_Node_Str"",location_text);
  }
 else {
    DCValue[] authors=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] creators=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] titles=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] keywords=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    DCValue[] abstracts=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] sors=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] series=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] tocs=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] mimetypes=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] sponsors=myitem.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    DCValue[] identifiers=myitem.getDC(""String_Node_Str"",Item.ANY,Item.ANY);
    String author_text=""String_Node_Str"";
    String title_text=""String_Node_Str"";
    String keyword_text=""String_Node_Str"";
    String abstract_text=""String_Node_Str"";
    String sor_text=""String_Node_Str"";
    String series_text=""String_Node_Str"";
    String mime_text=""String_Node_Str"";
    String sponsor_text=""String_Node_Str"";
    String id_text=""String_Node_Str"";
    for (j=0; j < authors.length; j++) {
      author_text=new String(author_text + authors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < creators.length; j++) {
      author_text=new String(author_text + creators[j].value + ""String_Node_Str"");
    }
    for (j=0; j < sors.length; j++) {
      author_text=new String(author_text + sors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < titles.length; j++) {
      title_text=new String(title_text + titles[j].value + ""String_Node_Str"");
    }
    for (j=0; j < keywords.length; j++) {
      keyword_text=new String(keyword_text + keywords[j].value + ""String_Node_Str"");
    }
    for (j=0; j < abstracts.length; j++) {
      abstract_text=new String(abstract_text + abstracts[j].value + ""String_Node_Str"");
    }
    for (j=0; j < tocs.length; j++) {
      abstract_text=new String(abstract_text + tocs[j].value + ""String_Node_Str"");
    }
    for (j=0; j < series.length; j++) {
      series_text=new String(series_text + series[j].value + ""String_Node_Str"");
    }
    for (j=0; j < mimetypes.length; j++) {
      mime_text=new String(mime_text + mimetypes[j].value + ""String_Node_Str"");
    }
    for (j=0; j < sponsors.length; j++) {
      sponsor_text=new String(sponsor_text + sponsors[j].value + ""String_Node_Str"");
    }
    for (j=0; j < identifiers.length; j++) {
      id_text=new String(id_text + identifiers[j].value + ""String_Node_Str"");
    }
    textvalues.put(""String_Node_Str"",author_text);
    textvalues.put(""String_Node_Str"",title_text);
    textvalues.put(""String_Node_Str"",keyword_text);
    textvalues.put(""String_Node_Str"",location_text);
    textvalues.put(""String_Node_Str"",abstract_text);
    textvalues.put(""String_Node_Str"",series_text);
    textvalues.put(""String_Node_Str"",mime_text);
    textvalues.put(""String_Node_Str"",sponsor_text);
    textvalues.put(""String_Node_Str"",id_text);
  }
  String extractedText=""String_Node_Str"";
  Bundle[] myBundles=myitem.getBundles();
  for (int i=0; i < myBundles.length; i++) {
    if (myBundles[i].getName() != null && myBundles[i].getName().equals(""String_Node_Str"")) {
      Bitstream[] myBitstreams=myBundles[i].getBitstreams();
      for (j=0; j < myBitstreams.length; j++) {
        try {
          InputStreamReader is=new InputStreamReader(myBitstreams[j].retrieve());
          StringBuffer sb=new StringBuffer();
          char[] charBuffer=new char[1024];
          while (true) {
            int bytesIn=is.read(charBuffer);
            if (bytesIn == -1)             break;
            if (bytesIn > 0) {
              sb.append(charBuffer,0,bytesIn);
            }
          }
          extractedText=extractedText.concat(new String(sb));
        }
 catch (        AuthorizeException e) {
        }
      }
    }
  }
  String itemhandle=HandleManager.findHandle(c,myitem);
  textvalues.put(""String_Node_Str"",itemhandle);
  writeIndexRecord(writer,Constants.ITEM,itemhandle,textvalues,extractedText);
}",0.9955262935764329
3596,"/** 
 * Write out the AIP for the given item to the given directory. A new directory will be created with the Handle (URL-encoded) as the directory name, and inside, a mets.xml file written, together with the bitstreams.
 * @param context   DSpace context to use
 * @param item      Item to write
 * @param dest      destination directory
 */
public static void writeAIP(Context context,Item item,String dest) throws SQLException, IOException, AuthorizeException, MetsException {
  System.out.println(""String_Node_Str"" + item.getHandle());
  java.io.File aipDir=new java.io.File(dest + URLEncoder.encode(""String_Node_Str"" + item.getHandle(),""String_Node_Str""));
  if (!aipDir.mkdir()) {
    throw new IOException(""String_Node_Str"" + aipDir.toString());
  }
  FileOutputStream out=new FileOutputStream(aipDir.toString() + java.io.File.separator + ""String_Node_Str"");
  writeMETS(context,item,out);
  out.close();
  Bundle[] bundles=item.getBundles();
  for (int i=0; i < bundles.length; i++) {
    Bitstream[] bitstreams=bundles[i].getBitstreams();
    for (int b=0; b < bitstreams.length; b++) {
      if (bitstreams[b].getFormat().getID() != licenseFormat) {
        out=new FileOutputStream(aipDir.toString() + java.io.File.separator + bitstreams[b].getChecksum());
        InputStream in=bitstreams[b].retrieve();
        Utils.bufferedCopy(in,out);
        out.close();
        in.close();
      }
    }
  }
}","/** 
 * Write out the AIP for the given item to the given directory. A new directory will be created with the Handle (URL-encoded) as the directory name, and inside, a mets.xml file written, together with the bitstreams.
 * @param context   DSpace context to use
 * @param item      Item to write
 * @param dest      destination directory
 */
public static void writeAIP(Context context,Item item,String dest) throws SQLException, IOException, AuthorizeException, MetsException {
  System.out.println(""String_Node_Str"" + item.getHandle());
  java.io.File aipDir=new java.io.File(dest + URLEncoder.encode(""String_Node_Str"" + item.getHandle(),""String_Node_Str""));
  if (!aipDir.mkdir()) {
    throw new IOException(""String_Node_Str"" + aipDir.toString());
  }
  FileOutputStream out=new FileOutputStream(aipDir.toString() + java.io.File.separator + ""String_Node_Str"");
  writeMETS(context,item,out);
  out.close();
  Bundle[] bundles=item.getBundles();
  for (int i=0; i < bundles.length; i++) {
    Bitstream[] bitstreams=bundles[i].getBitstreams();
    for (int b=0; b < bitstreams.length; b++) {
      if (bitstreams[b].getFormat().getID() != licenseFormat && AuthorizeManager.authorizeActionBoolean(context,bitstreams[b],Constants.READ)) {
        out=new FileOutputStream(aipDir.toString() + java.io.File.separator + bitstreams[b].getChecksum());
        InputStream in=bitstreams[b].retrieve();
        Utils.bufferedCopy(in,out);
        out.close();
        in.close();
      }
    }
  }
}",0.9721362229102168
3597,"/** 
 * Attempt to filter a bitstream An exception will be thrown if the media filter class cannot be instantiated, exceptions from filtering will be logged to STDOUT and swallowed.
 */
public static void filterBitstream(Context c,Item myItem,Bitstream myBitstream) throws Exception {
  Integer formatID=new Integer(myBitstream.getFormat().getID());
  if (filterNames.containsKey(formatID)) {
    if (!filterCache.containsKey(formatID)) {
      Class f=Class.forName((String)filterNames.get(formatID));
      MediaFilter myFilter=(MediaFilter)f.newInstance();
      filterCache.put(formatID,myFilter);
    }
    MediaFilter myFilter=(MediaFilter)filterCache.get(formatID);
    try {
      myFilter.processBitstream(c,myItem,myBitstream);
      myItem.update();
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + myBitstream.getID() + ""String_Node_Str""+ e);
      e.printStackTrace();
    }
  }
}","/** 
 * Attempt to filter a bitstream An exception will be thrown if the media filter class cannot be instantiated, exceptions from filtering will be logged to STDOUT and swallowed.
 */
public static void filterBitstream(Context c,Item myItem,Bitstream myBitstream) throws Exception {
  Integer formatID=new Integer(myBitstream.getFormat().getID());
  if (filterNames.containsKey(formatID)) {
    if (!filterCache.containsKey(formatID)) {
      Class f=Class.forName((String)filterNames.get(formatID));
      MediaFilter myFilter=(MediaFilter)f.newInstance();
      filterCache.put(formatID,myFilter);
    }
    MediaFilter myFilter=(MediaFilter)filterCache.get(formatID);
    try {
      if (myFilter.processBitstream(c,myItem,myBitstream)) {
        myItem.update();
      }
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + myBitstream.getID() + ""String_Node_Str""+ e);
      e.printStackTrace();
    }
  }
}",0.9741935483870968
3598,"/** 
 * Given a contents file and an item, stuffing it with bitstreams from the contents file
 */
private void processContentsFile(Context c,Item i,String path,String filename) throws SQLException, IOException, AuthorizeException {
  String contentspath=path + File.separatorChar + filename;
  String line=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + contentspath);
  BufferedReader is=new BufferedReader(new FileReader(contentspath));
  while ((line=is.readLine()) != null) {
    String bundleMarker=""String_Node_Str"";
    int markerIndex=line.indexOf(bundleMarker);
    if (markerIndex == -1) {
      processContentFileEntry(c,i,path,line,null);
      System.out.println(""String_Node_Str"" + line);
    }
 else {
      String bundleName=line.substring(markerIndex + bundleMarker.length());
      String bitstreamName=line.substring(0,markerIndex);
      processContentFileEntry(c,i,path,bitstreamName,bundleName);
      System.out.println(""String_Node_Str"" + bitstreamName + ""String_Node_Str""+ bundleName);
    }
  }
  is.close();
}","/** 
 * Given a contents file and an item, stuffing it with bitstreams from the contents file
 */
private void processContentsFile(Context c,Item i,String path,String filename) throws SQLException, IOException, AuthorizeException {
  String contentspath=path + File.separatorChar + filename;
  String line=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + contentspath);
  BufferedReader is=new BufferedReader(new FileReader(contentspath));
  while ((line=is.readLine()) != null) {
    if (""String_Node_Str"".equals(line.trim()))     continue;
    String bundleMarker=""String_Node_Str"";
    int markerIndex=line.indexOf(bundleMarker);
    if (markerIndex == -1) {
      processContentFileEntry(c,i,path,line,null);
      System.out.println(""String_Node_Str"" + line);
    }
 else {
      String bundleName=line.substring(markerIndex + bundleMarker.length());
      String bitstreamName=line.substring(0,markerIndex);
      processContentFileEntry(c,i,path,bitstreamName,bundleName);
      System.out.println(""String_Node_Str"" + bitstreamName + ""String_Node_Str""+ bundleName);
    }
  }
  is.close();
}",0.9717199814557256
3599,"private void addDCValue(Item i,Node n) throws TransformerException {
  String value=getStringValue(n);
  String element=getAttributeValue(n,""String_Node_Str"");
  String qualifier=getAttributeValue(n,""String_Node_Str"");
  String language=getAttributeValue(n,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + element + ""String_Node_Str""+ qualifier+ ""String_Node_Str""+ value);
  if (qualifier.equals(""String_Node_Str""))   qualifier=null;
  if (language.equals(""String_Node_Str"")) {
    language=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (language == null) {
    language=""String_Node_Str"";
  }
  i.addDC(element,qualifier,language,value);
}","private void addDCValue(Item i,Node n) throws TransformerException {
  String value=getStringValue(n);
  String element=getAttributeValue(n,""String_Node_Str"");
  String qualifier=getAttributeValue(n,""String_Node_Str"");
  String language=getAttributeValue(n,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + element + ""String_Node_Str""+ qualifier+ ""String_Node_Str""+ value);
  if (qualifier.equals(""String_Node_Str"") || ""String_Node_Str"".equals(qualifier))   qualifier=null;
  if (language.equals(""String_Node_Str"")) {
    language=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (language == null) {
    language=""String_Node_Str"";
  }
  i.addDC(element,qualifier,language,value);
}",0.9716363636363636
3600,"/** 
 * Process input from ""verify prune"" step
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processVerifyPrune(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"") != null) {
    doStep(context,request,response,subInfo,INITIAL_QUESTIONS);
    return;
  }
  boolean multipleTitles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean publishedBefore=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean multipleFiles=(isWorkflow(subInfo) || UIUtil.getBoolParameter(request,""String_Node_Str""));
  Item item=subInfo.submission.getItem();
  if (!multipleTitles) {
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  }
  if (publishedBefore == false) {
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    item.clearDC(""String_Node_Str"",null,Item.ANY);
  }
  if (multipleFiles == false) {
    Bundle[] bundles=item.getBundles();
    Bitstream[] bitstreams=bundles[0].getBitstreams();
    for (int i=1; i < bitstreams.length; i++) {
      bundles[0].removeBitstream(bitstreams[i]);
    }
  }
  subInfo.submission.setMultipleTitles(multipleTitles);
  subInfo.submission.setPublishedBefore(publishedBefore);
  if (!isWorkflow(subInfo)) {
    subInfo.submission.setMultipleFiles(multipleFiles);
  }
  subInfo.submission.update();
  if (request.getParameter(""String_Node_Str"") != null) {
    userHasReached(subInfo,EDIT_METADATA_1);
    doStep(context,request,response,subInfo,EDIT_METADATA_1);
    context.complete();
  }
 else {
    doStepJump(context,request,response,subInfo);
    context.complete();
  }
}","/** 
 * Process input from ""verify prune"" step
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processVerifyPrune(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"") != null) {
    doStep(context,request,response,subInfo,INITIAL_QUESTIONS);
    return;
  }
  boolean multipleTitles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean publishedBefore=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean multipleFiles=(isWorkflow(subInfo) || UIUtil.getBoolParameter(request,""String_Node_Str""));
  Item item=subInfo.submission.getItem();
  if (!multipleTitles) {
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  }
  if (publishedBefore == false) {
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    item.clearDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    item.clearDC(""String_Node_Str"",null,Item.ANY);
  }
  if (multipleFiles == false) {
    Bundle[] bundles=item.getBundles();
    if (bundles.length > 0) {
      Bitstream[] bitstreams=bundles[0].getBitstreams();
      for (int i=1; i < bitstreams.length; i++) {
        bundles[0].removeBitstream(bitstreams[i]);
      }
    }
  }
  subInfo.submission.setMultipleTitles(multipleTitles);
  subInfo.submission.setPublishedBefore(publishedBefore);
  if (!isWorkflow(subInfo)) {
    subInfo.submission.setMultipleFiles(multipleFiles);
  }
  subInfo.submission.update();
  if (request.getParameter(""String_Node_Str"") != null) {
    userHasReached(subInfo,EDIT_METADATA_1);
    doStep(context,request,response,subInfo,EDIT_METADATA_1);
    context.complete();
  }
 else {
    doStepJump(context,request,response,subInfo);
    context.complete();
  }
}",0.9887525562372188
3601,"/** 
 * Process input from one of the permissions pages
 * @param context     DSpace context
 * @param request     HTTP request
 * @param response    HTTP response
 * @param collection  Collection we're editing
 */
private void processPermissions(Context context,HttpServletRequest request,HttpServletResponse response,Collection collection) throws SQLException, ServletException, IOException, AuthorizeException {
  int permission=UIUtil.getIntParameter(request,""String_Node_Str"");
  if (UIUtil.getBoolParameter(request,""String_Node_Str"")) {
    Group mitGroup=Group.findByName(context,""String_Node_Str"");
    int action;
    if (permission == PERM_READ) {
      AuthorizeManager.addPolicy(context,collection,Constants.READ,mitGroup);
    }
 else {
      AuthorizeManager.addPolicy(context,collection,Constants.ADD,mitGroup);
    }
  }
  Group g=null;
switch (permission) {
case PERM_READ:
    g=Group.create(context);
  g.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str"");
AuthorizeManager.addPolicy(context,collection,Constants.READ,g);
break;
case PERM_SUBMIT:
g=collection.getSubmitters();
break;
case PERM_WF1:
g=collection.getWorkflowGroup(1);
break;
case PERM_WF2:
g=collection.getWorkflowGroup(2);
break;
case PERM_WF3:
g=collection.getWorkflowGroup(3);
break;
case PERM_EDITOR:
g=collection.getEditors();
break;
}
int[] ids=UIUtil.getIntParameters(request,""String_Node_Str"");
if (ids != null) {
for (int i=0; i < ids.length; i++) {
EPerson eperson=EPerson.find(context,ids[i]);
if (eperson != null) {
g.addMember(eperson);
}
}
}
g.update();
showNextPage(context,request,response,collection,permission);
context.complete();
}","/** 
 * Process input from one of the permissions pages
 * @param context     DSpace context
 * @param request     HTTP request
 * @param response    HTTP response
 * @param collection  Collection we're editing
 */
private void processPermissions(Context context,HttpServletRequest request,HttpServletResponse response,Collection collection) throws SQLException, ServletException, IOException, AuthorizeException {
  int permission=UIUtil.getIntParameter(request,""String_Node_Str"");
  if (UIUtil.getBoolParameter(request,""String_Node_Str"")) {
    Group mitGroup=Group.findByName(context,""String_Node_Str"");
    int action;
    if (permission == PERM_READ) {
      AuthorizeManager.addPolicy(context,collection,Constants.DEFAULT_ITEM_READ,mitGroup);
      AuthorizeManager.addPolicy(context,collection,Constants.DEFAULT_BITSTREAM_READ,mitGroup);
    }
 else {
      AuthorizeManager.addPolicy(context,collection,Constants.ADD,mitGroup);
    }
  }
  Group g=null;
switch (permission) {
case PERM_READ:
    g=Group.create(context);
  g.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str"");
AuthorizeManager.addPolicy(context,collection,Constants.DEFAULT_ITEM_READ,g);
AuthorizeManager.addPolicy(context,collection,Constants.DEFAULT_BITSTREAM_READ,g);
break;
case PERM_SUBMIT:
g=collection.getSubmitters();
break;
case PERM_WF1:
g=collection.getWorkflowGroup(1);
break;
case PERM_WF2:
g=collection.getWorkflowGroup(2);
break;
case PERM_WF3:
g=collection.getWorkflowGroup(3);
break;
case PERM_EDITOR:
g=collection.getEditors();
break;
}
int[] ids=UIUtil.getIntParameters(request,""String_Node_Str"");
if (ids != null) {
for (int i=0; i < ids.length; i++) {
EPerson eperson=EPerson.find(context,ids[i]);
if (eperson != null) {
g.addMember(eperson);
}
}
}
g.update();
showNextPage(context,request,response,collection,permission);
context.complete();
}",0.9415787973781704
3602,"/** 
 * process input from basic info page
 * @param context
 * @param request
 * @param response
 * @param collection
 * @throws SQLException
 * @throws ServletException
 * @throws IOException
 * @throws AuthorizeException
 */
private void processBasicInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws SQLException, ServletException, IOException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Collection collection=Collection.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  if (collection == null) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(wrapper)));
    JSPManager.showIntegrityError(request,response);
    return;
  }
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  String license=wrapper.getParameter(""String_Node_Str"");
  if (license != null) {
    collection.setLicense(null);
  }
  File temp=wrapper.getFile(""String_Node_Str"");
  if (temp != null) {
    InputStream is=new BufferedInputStream(new FileInputStream(temp));
    Bitstream logoBS=collection.setLogo(is);
    String noPath=wrapper.getFilesystemName(""String_Node_Str"");
    while (noPath.indexOf('/') > -1) {
      noPath=noPath.substring(noPath.indexOf('/') + 1);
    }
    while (noPath.indexOf('\\') > -1) {
      noPath=noPath.substring(noPath.indexOf('\\') + 1);
    }
    logoBS.setName(noPath);
    logoBS.setSource(wrapper.getFilesystemName(""String_Node_Str""));
    BitstreamFormat bf=FormatIdentifier.guessFormat(context,logoBS);
    logoBS.setFormat(bf);
    logoBS.update();
    temp.delete();
  }
  collection.update();
  showNextPage(context,request,response,collection,BASIC_INFO);
  context.complete();
}","/** 
 * process input from basic info page
 * @param context
 * @param request
 * @param response
 * @param collection
 * @throws SQLException
 * @throws ServletException
 * @throws IOException
 * @throws AuthorizeException
 */
private void processBasicInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws SQLException, ServletException, IOException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Collection collection=Collection.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  if (collection == null) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(wrapper)));
    JSPManager.showIntegrityError(request,response);
    return;
  }
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",wrapper.getParameter(""String_Node_Str""));
  String license=wrapper.getParameter(""String_Node_Str"");
  if (license != null || license.equals(""String_Node_Str"")) {
    collection.setLicense(license);
  }
  File temp=wrapper.getFile(""String_Node_Str"");
  if (temp != null) {
    InputStream is=new BufferedInputStream(new FileInputStream(temp));
    Bitstream logoBS=collection.setLogo(is);
    String noPath=wrapper.getFilesystemName(""String_Node_Str"");
    while (noPath.indexOf('/') > -1) {
      noPath=noPath.substring(noPath.indexOf('/') + 1);
    }
    while (noPath.indexOf('\\') > -1) {
      noPath=noPath.substring(noPath.indexOf('\\') + 1);
    }
    logoBS.setName(noPath);
    logoBS.setSource(wrapper.getFilesystemName(""String_Node_Str""));
    BitstreamFormat bf=FormatIdentifier.guessFormat(context,logoBS);
    logoBS.setFormat(bf);
    logoBS.update();
    temp.delete();
  }
  collection.update();
  showNextPage(context,request,response,collection,BASIC_INFO);
  context.complete();
}",0.9891255097417307
3603,"protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int groupID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Group group=null;
  if (groupID >= 0) {
    group=Group.find(c,groupID);
  }
  if (group != null) {
    AuthorizeManager.authorizeAction(c,group,Constants.ADD);
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else     if (button.equals(""String_Node_Str"")) {
      String newName=request.getParameter(""String_Node_Str"");
      if (!newName.equals(group.getName())) {
        group.setName(newName);
        group.update();
      }
      int[] eperson_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      if (eperson_ids != null) {
        EPerson[] members=group.getMembers();
        for (int x=0; x < eperson_ids.length; x++) {
          int foundIndex=-1;
          for (int y=0; y < members.length; y++) {
            if ((members[y] != null) && (members[y].getID() == eperson_ids[x])) {
              foundIndex=y;
              break;
            }
          }
          if (foundIndex == -1) {
            EPerson e=EPerson.find(c,eperson_ids[x]);
            group.addMember(e);
          }
 else {
            members[foundIndex]=null;
          }
        }
        for (int y=0; y < members.length; y++) {
          if (members[y] != null) {
            group.removeMember(members[y]);
          }
        }
        group.update();
      }
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else     if (button.equals(""String_Node_Str"")) {
      AuthorizeManager.authorizeAction(c,group,Constants.WRITE);
      group.delete();
      showMainPage(c,request,response);
      c.complete();
    }
 else {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      group=Group.create(c);
      group.setName(""String_Node_Str"" + group.getID());
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else {
      showMainPage(c,request,response);
    }
  }
}","protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int groupID=UIUtil.getIntParameter(request,""String_Node_Str"");
  Group group=null;
  if (groupID >= 0) {
    group=Group.find(c,groupID);
  }
  if (group != null) {
    AuthorizeManager.authorizeAction(c,group,Constants.ADD);
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else     if (button.equals(""String_Node_Str"")) {
      String newName=request.getParameter(""String_Node_Str"");
      if (!newName.equals(group.getName())) {
        group.setName(newName);
        group.update();
      }
      int[] eperson_ids=UIUtil.getIntParameters(request,""String_Node_Str"");
      EPerson[] members=group.getMembers();
      if (eperson_ids != null) {
        for (int x=0; x < eperson_ids.length; x++) {
          int foundIndex=-1;
          for (int y=0; y < members.length; y++) {
            if ((members[y] != null) && (members[y].getID() == eperson_ids[x])) {
              foundIndex=y;
              break;
            }
          }
          if (foundIndex == -1) {
            EPerson e=EPerson.find(c,eperson_ids[x]);
            group.addMember(e);
          }
 else {
            members[foundIndex]=null;
          }
        }
        for (int y=0; y < members.length; y++) {
          if (members[y] != null) {
            group.removeMember(members[y]);
          }
        }
      }
 else {
        for (int y=0; y < members.length; y++) {
          group.removeMember(members[y]);
        }
      }
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else     if (button.equals(""String_Node_Str"")) {
      AuthorizeManager.authorizeAction(c,group,Constants.WRITE);
      group.delete();
      showMainPage(c,request,response);
      c.complete();
    }
 else {
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
    if (button.equals(""String_Node_Str"")) {
      group=Group.create(c);
      group.setName(""String_Node_Str"" + group.getID());
      group.update();
      request.setAttribute(""String_Node_Str"",group);
      request.setAttribute(""String_Node_Str"",group.getMembers());
      JSPManager.showJSP(request,response,""String_Node_Str"");
      c.complete();
    }
 else {
      showMainPage(c,request,response);
    }
  }
}",0.9564018611063244
3604,"/** 
 * Show an item page
 * @param context     Context object
 * @param request     the HTTP request
 * @param response    the HTTP response
 * @param item        the item
 * @param handle      the item's handle
 */
private void displayItem(Context context,HttpServletRequest request,HttpServletResponse response,Item item,String handle) throws ServletException, IOException, SQLException, AuthorizeException {
  if (item.isWithdrawn()) {
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  AuthorizeManager.authorizeAction(context,item,Constants.READ);
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + handle));
  if (item.canEdit()) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  Collection[] collections=item.getCollections();
  request.setAttribute(""String_Node_Str"",collections[0]);
  Community[] comms=collections[0].getCommunities();
  request.setAttribute(""String_Node_Str"",comms[0]);
  request.setAttribute(""String_Node_Str"",getParents(comms[0],true));
  boolean displayAll=false;
  String modeParam=request.getParameter(""String_Node_Str"");
  if (modeParam != null && modeParam.equalsIgnoreCase(""String_Node_Str"")) {
    displayAll=true;
  }
  request.setAttribute(""String_Node_Str"",new Boolean(displayAll));
  request.setAttribute(""String_Node_Str"",item);
  request.setAttribute(""String_Node_Str"",collections);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}","/** 
 * Show an item page
 * @param context     Context object
 * @param request     the HTTP request
 * @param response    the HTTP response
 * @param item        the item
 * @param handle      the item's handle
 */
private void displayItem(Context context,HttpServletRequest request,HttpServletResponse response,Item item,String handle) throws ServletException, IOException, SQLException, AuthorizeException {
  if (item.isWithdrawn()) {
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  AuthorizeManager.authorizeAction(context,item,Constants.READ);
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + handle));
  if (item.canEdit()) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  Collection[] collections=item.getCollections();
  request.setAttribute(""String_Node_Str"",item.getOwningCollection());
  Community[] comms=item.getOwningCollection().getCommunities();
  request.setAttribute(""String_Node_Str"",comms[0]);
  request.setAttribute(""String_Node_Str"",getParents(comms[0],true));
  boolean displayAll=false;
  String modeParam=request.getParameter(""String_Node_Str"");
  if (modeParam != null && modeParam.equalsIgnoreCase(""String_Node_Str"")) {
    displayAll=true;
  }
  request.setAttribute(""String_Node_Str"",new Boolean(displayAll));
  request.setAttribute(""String_Node_Str"",item);
  request.setAttribute(""String_Node_Str"",collections);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}",0.8770380434782609
3605,"/** 
 * This method should be called whenever an item is added.
 * @param context The current DSpace context
 * @param item The item which has been added
 * @exception SQLException If a database error occurs
 */
public static void itemAdded(Context context,Item item) throws SQLException {
  Map table2dc=new HashMap();
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",null,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",Item.ANY,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  for (Iterator iterator=table2dc.keySet().iterator(); iterator.hasNext(); ) {
    String table=(String)iterator.next();
    DCValue[] dc=(DCValue[])table2dc.get(table);
    for (int i=0; i < dc.length; i++) {
      TableRow row=DatabaseManager.create(context,table);
      row.setColumn(""String_Node_Str"",item.getID());
      String value=dc[i].value;
      if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table)) {
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",value.toLowerCase());
      }
 else       if (""String_Node_Str"".equals(table)) {
        String title=NormalizedTitle.normalize(value,dc[i].language);
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",title.toLowerCase());
      }
      DatabaseManager.update(context,row);
    }
  }
}","/** 
 * This method should be called whenever an item is added.
 * @param context The current DSpace context
 * @param item The item which has been added
 * @exception SQLException If a database error occurs
 */
public static void itemAdded(Context context,Item item) throws SQLException {
  Community[] parents=item.getCommunities();
  for (int j=0; j < parents.length; j++) {
    TableRow row=DatabaseManager.create(context,""String_Node_Str"");
    row.setColumn(""String_Node_Str"",item.getID());
    row.setColumn(""String_Node_Str"",parents[j].getID());
    DatabaseManager.update(context,row);
  }
  Map table2dc=new HashMap();
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",null,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",Item.ANY,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  for (Iterator iterator=table2dc.keySet().iterator(); iterator.hasNext(); ) {
    String table=(String)iterator.next();
    DCValue[] dc=(DCValue[])table2dc.get(table);
    for (int i=0; i < dc.length; i++) {
      TableRow row=DatabaseManager.create(context,table);
      row.setColumn(""String_Node_Str"",item.getID());
      String value=dc[i].value;
      if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table)) {
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",value.toLowerCase());
      }
 else       if (""String_Node_Str"".equals(table)) {
        String title=NormalizedTitle.normalize(value,dc[i].language);
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",title.toLowerCase());
      }
      DatabaseManager.update(context,row);
    }
  }
}",0.9150865622423744
3606,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String contentType=request.getContentType();
  if (contentType != null && contentType.indexOf(""String_Node_Str"") != -1) {
    processUploadLogo(context,request,response);
    return;
  }
  int action=UIUtil.getIntParameter(request,""String_Node_Str"");
  Community community=Community.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
  Collection collection=Collection.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
  request.setAttribute(""String_Node_Str"",community);
  request.setAttribute(""String_Node_Str"",collection);
  if (request.getParameter(""String_Node_Str"") != null) {
    showControls(context,request,response);
    return;
  }
switch (action) {
case START_EDIT_COMMUNITY:
    JSPManager.showJSP(request,response,""String_Node_Str"");
  break;
case START_DELETE_COMMUNITY:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_CREATE_COMMUNITY:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_EDIT_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_DELETE_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_CREATE_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case CONFIRM_EDIT_COMMUNITY:
processConfirmEditCommunity(context,request,response,community);
break;
case CONFIRM_DELETE_COMMUNITY:
community.delete();
showControls(context,request,response);
context.complete();
break;
case CONFIRM_EDIT_COLLECTION:
processConfirmEditCollection(context,request,response,community,collection);
break;
case CONFIRM_DELETE_COLLECTION:
community.removeCollection(collection);
showControls(context,request,response);
context.complete();
break;
default :
log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
JSPManager.showIntegrityError(request,response);
}
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String contentType=request.getContentType();
  if (contentType != null && contentType.indexOf(""String_Node_Str"") != -1) {
    processUploadLogo(context,request,response);
    return;
  }
  int action=UIUtil.getIntParameter(request,""String_Node_Str"");
  Community community=Community.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
  Collection collection=Collection.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
  request.setAttribute(""String_Node_Str"",community);
  request.setAttribute(""String_Node_Str"",collection);
  if (request.getParameter(""String_Node_Str"") != null) {
    showControls(context,request,response);
    return;
  }
switch (action) {
case START_EDIT_COMMUNITY:
    JSPManager.showJSP(request,response,""String_Node_Str"");
  break;
case START_DELETE_COMMUNITY:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_CREATE_COMMUNITY:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_EDIT_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_DELETE_COLLECTION:
JSPManager.showJSP(request,response,""String_Node_Str"");
break;
case START_CREATE_COLLECTION:
response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + community.getID()));
break;
case CONFIRM_EDIT_COMMUNITY:
processConfirmEditCommunity(context,request,response,community);
break;
case CONFIRM_DELETE_COMMUNITY:
community.delete();
showControls(context,request,response);
context.complete();
break;
case CONFIRM_EDIT_COLLECTION:
processConfirmEditCollection(context,request,response,community,collection);
break;
case CONFIRM_DELETE_COLLECTION:
community.removeCollection(collection);
showControls(context,request,response);
context.complete();
break;
default :
log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
JSPManager.showIntegrityError(request,response);
}
}",0.9607512641464002
3607,"/** 
 * Give the community a logo.  Passing in <code>null</code> removes any existing logo.  You will need to set the format of the new logo bitstream before it will work, for example to ""JPEG"".  Note that <code>update(/code> will need to be called for the change to take effect.  Setting a logo and not calling <code>update</code> later may result in a previous logo lying around as an ""orphaned"" bitstream.
 * @param is   the stream to use as the new logo
 * @return   the new logo bitstream, or <code>null</code> if there is nologo (<code>null</code> was passed in)
 */
public Bitstream setLogo(InputStream is) throws AuthorizeException, IOException, SQLException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (logo != null) {
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
    communityRow.setColumnNull(""String_Node_Str"");
    logo.delete();
  }
  if (is != null) {
    Bitstream newLogo=Bitstream.create(ourContext,is);
    communityRow.setColumn(""String_Node_Str"",newLogo.getID());
    logo=newLogo;
    List policies=AuthorizeManager.getPoliciesActionFilter(ourContext,this,Constants.READ);
    AuthorizeManager.addPolicies(ourContext,policies,newLogo);
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str""+ newLogo.getID()));
  }
  return logo;
}","/** 
 * Give the community a logo.  Passing in <code>null</code> removes any existing logo.  You will need to set the format of the new logo bitstream before it will work, for example to ""JPEG"".  Note that <code>update(/code> will need to be called for the change to take effect.  Setting a logo and not calling <code>update</code> later may result in a previous logo lying around as an ""orphaned"" bitstream.
 * @param is   the stream to use as the new logo
 * @return   the new logo bitstream, or <code>null</code> if there is nologo (<code>null</code> was passed in)
 */
public Bitstream setLogo(InputStream is) throws AuthorizeException, IOException, SQLException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (logo != null) {
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
    communityRow.setColumnNull(""String_Node_Str"");
    logo.delete();
    logo=null;
  }
  if (is != null) {
    Bitstream newLogo=Bitstream.create(ourContext,is);
    communityRow.setColumn(""String_Node_Str"",newLogo.getID());
    logo=newLogo;
    List policies=AuthorizeManager.getPoliciesActionFilter(ourContext,this,Constants.READ);
    AuthorizeManager.addPolicies(ourContext,policies,newLogo);
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str""+ newLogo.getID()));
  }
  return logo;
}",0.9946332737030412
3608,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.create(context);
    e.setEmail(""String_Node_Str"" + e.getID());
    e.update();
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    String oldEmail=e.getEmail();
    String newEmail=request.getParameter(""String_Node_Str"").trim();
    if (!newEmail.equals(oldEmail)) {
      if (EPerson.findByEmail(context,newEmail) == null) {
        e.setEmail(newEmail);
        e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.update();
        showMain(context,request,response);
        context.complete();
      }
 else {
        request.setAttribute(""String_Node_Str"",e);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        JSPManager.showJSP(request,response,""String_Node_Str"");
        context.complete();
      }
    }
 else {
      e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.update();
      showMain(context,request,response);
      context.complete();
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    e.delete();
    showMain(context,request,response);
    context.complete();
  }
 else {
    showMain(context,request,response);
  }
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.create(context);
    e.setEmail(""String_Node_Str"" + e.getID());
    e.update();
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    String oldEmail=e.getEmail();
    String newEmail=request.getParameter(""String_Node_Str"").trim();
    if (!newEmail.equals(oldEmail)) {
      if (EPerson.findByEmail(context,newEmail) == null) {
        e.setEmail(newEmail);
        e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.update();
        showMain(context,request,response);
        context.complete();
      }
 else {
        request.setAttribute(""String_Node_Str"",e);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        JSPManager.showJSP(request,response,""String_Node_Str"");
        context.complete();
      }
    }
 else {
      e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.update();
      showMain(context,request,response);
      context.complete();
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    try {
      e.delete();
    }
 catch (    EPersonDeletionException ex) {
      request.setAttribute(""String_Node_Str"",e);
      request.setAttribute(""String_Node_Str"",ex.getTables());
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
    showMain(context,request,response);
    context.complete();
  }
 else {
    showMain(context,request,response);
  }
}",0.9643051771117166
3609,"/** 
 * Get the communities this collection appears in
 * @return   array of <code>Community</code> objects
 */
public Community[] getCommunities() throws SQLException {
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str"");
  List communities=new ArrayList();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    Community fromCache=(Community)ourContext.fromCache(Community.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      communities.add(fromCache);
    }
 else {
      communities.add(new Community(ourContext,row));
    }
  }
  Community[] communityArray=new Community[communities.size()];
  communityArray=(Community[])communities.toArray(communityArray);
  return communityArray;
}","/** 
 * Get the communities this collection appears in
 * @return   array of <code>Community</code> objects
 */
public Community[] getCommunities() throws SQLException {
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str"");
  List communities=new ArrayList();
  while (tri.hasNext()) {
    TableRow row=tri.next();
    Community owner=(Community)ourContext.fromCache(Community.class,row.getIntColumn(""String_Node_Str""));
    if (owner == null) {
      owner=new Community(ourContext,row);
    }
    communities.add(owner);
    Community[] parents=owner.getAllParents();
    for (int i=0; i < parents.length; i++) {
      communities.add(parents[i]);
    }
  }
  Community[] communityArray=new Community[communities.size()];
  communityArray=(Community[])communities.toArray(communityArray);
  return communityArray;
}",0.5988636363636364
3610,"/** 
 * Get the communities this item is in.  Returns an unordered array of the communities that house the collections this item is in.
 * @return  the communities this item is in.
 */
public Community[] getCommunities() throws SQLException {
  List communities=new ArrayList();
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow row=tri.next();
    Community fromCache=(Community)ourContext.fromCache(Community.class,row.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      communities.add(fromCache);
    }
 else {
      communities.add(new Community(ourContext,row));
    }
  }
  Community[] communityArray=new Community[communities.size()];
  communityArray=(Community[])communities.toArray(communityArray);
  return communityArray;
}","/** 
 * Get the communities this item is in.  Returns an unordered array of the communities that house the collections this item is in, including parent communities of the owning collections.
 * @return  the communities this item is in.
 */
public Community[] getCommunities() throws SQLException {
  List communities=new ArrayList();
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow row=tri.next();
    Community owner=(Community)ourContext.fromCache(Community.class,row.getIntColumn(""String_Node_Str""));
    if (owner == null) {
      owner=new Community(ourContext,row);
    }
    communities.add(owner);
    Community[] parents=owner.getAllParents();
    for (int i=0; i < parents.length; i++) {
      communities.add(parents[i]);
    }
  }
  Community[] communityArray=new Community[communities.size()];
  communityArray=(Community[])communities.toArray(communityArray);
  return communityArray;
}",0.6258637709772952
3611,"/** 
 * Delete an eperson
 */
public void delete() throws SQLException, AuthorizeException {
  if (!AuthorizeManager.isAdmin(myContext)) {
    throw new AuthorizeException(""String_Node_Str"");
  }
  HistoryManager.saveHistory(myContext,this,HistoryManager.REMOVE,myContext.getCurrentUser(),myContext.getExtraLogInfo());
  myContext.removeCached(this,getID());
  DatabaseManager.updateQuery(myContext,""String_Node_Str"" + getID());
  DatabaseManager.delete(myContext,myRow);
  log.info(LogManager.getHeader(myContext,""String_Node_Str"",""String_Node_Str"" + getID()));
}","/** 
 * Delete an eperson
 */
public void delete() throws SQLException, AuthorizeException, EPersonDeletionException {
  if (!AuthorizeManager.isAdmin(myContext)) {
    throw new AuthorizeException(""String_Node_Str"");
  }
  HistoryManager.saveHistory(myContext,this,HistoryManager.REMOVE,myContext.getCurrentUser(),myContext.getExtraLogInfo());
  Vector constraintList=getDeleteConstraints();
  if (constraintList.size() > 0)   throw new EPersonDeletionException(constraintList);
  myContext.removeCached(this,getID());
  DatabaseManager.updateQuery(myContext,""String_Node_Str"" + getID());
  DatabaseManager.updateQuery(myContext,""String_Node_Str"" + getID());
  DatabaseManager.delete(myContext,myRow);
  log.info(LogManager.getHeader(myContext,""String_Node_Str"",""String_Node_Str"" + getID()));
}",0.8300220750551877
3612,"/** 
 * Delete the community, including the metadata and logo.  Collections and subcommunities that are then orphans are deleted.
 */
public void delete() throws SQLException, AuthorizeException, IOException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.DELETE);
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  DSIndexer.unIndexContent(ourContext,this);
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  ourContext.removeCached(this,getID());
  Collection[] cols=getCollections();
  for (int i=0; i < cols.length; i++) {
    removeCollection(cols[i]);
  }
  Community[] comms=getSubcommunities();
  for (int j=0; j < comms.length; j++) {
    removeSubcommunity(comms[j]);
  }
  setLogo(null);
  AuthorizeManager.removeAllPolicies(ourContext,this);
  DatabaseManager.delete(ourContext,communityRow);
}","/** 
 * Delete the community, including the metadata and logo.  Collections and subcommunities that are then orphans are deleted.
 */
public void delete() throws SQLException, AuthorizeException, IOException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.DELETE);
  Community parent=getParentCommunity();
  if (parent != null) {
    parent.removeSubcommunity(this);
    return;
  }
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  DSIndexer.unIndexContent(ourContext,this);
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  ourContext.removeCached(this,getID());
  Collection[] cols=getCollections();
  for (int i=0; i < cols.length; i++) {
    removeCollection(cols[i]);
  }
  Community[] comms=getSubcommunities();
  for (int j=0; j < comms.length; j++) {
    removeSubcommunity(comms[j]);
  }
  setLogo(null);
  AuthorizeManager.removeAllPolicies(ourContext,this);
  DatabaseManager.delete(ourContext,communityRow);
}",0.941
3613,"/** 
 * Process the input from the upload bitstream page
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processUploadBitstream(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Bitstream b=null;
  Item item=Item.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  File temp=wrapper.getFile(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(temp));
  checkEditAuthorization(context,item);
  Bundle[] bundles=item.getBundles();
  if (bundles.length < 1) {
    b=item.createSingleBitstream(is,""String_Node_Str"");
  }
 else {
    b=bundles[0].createBitstream(is);
  }
  String noPath=wrapper.getFilesystemName(""String_Node_Str"");
  while (noPath.indexOf('/') > -1) {
    noPath=noPath.substring(noPath.indexOf('/') + 1);
  }
  while (noPath.indexOf('\\') > -1) {
    noPath=noPath.substring(noPath.indexOf('\\') + 1);
  }
  b.setName(noPath);
  b.setSource(wrapper.getFilesystemName(""String_Node_Str""));
  BitstreamFormat bf=FormatIdentifier.guessFormat(context,b);
  b.setFormat(bf);
  b.update();
  item.update();
  showEditForm(context,request,response,item);
  temp.delete();
  context.complete();
}","/** 
 * Process the input from the upload bitstream page
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processUploadBitstream(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  FileUploadRequest wrapper=new FileUploadRequest(request);
  Bitstream b=null;
  Item item=Item.find(context,UIUtil.getIntParameter(wrapper,""String_Node_Str""));
  File temp=wrapper.getFile(""String_Node_Str"");
  InputStream is=new BufferedInputStream(new FileInputStream(temp));
  checkEditAuthorization(context,item);
  Bundle[] bundles=item.getBundles(""String_Node_Str"");
  if (bundles.length < 1) {
    b=item.createSingleBitstream(is,""String_Node_Str"");
  }
 else {
    b=bundles[0].createBitstream(is);
  }
  String noPath=wrapper.getFilesystemName(""String_Node_Str"");
  while (noPath.indexOf('/') > -1) {
    noPath=noPath.substring(noPath.indexOf('/') + 1);
  }
  while (noPath.indexOf('\\') > -1) {
    noPath=noPath.substring(noPath.indexOf('\\') + 1);
  }
  b.setName(noPath);
  b.setSource(wrapper.getFilesystemName(""String_Node_Str""));
  BitstreamFormat bf=FormatIdentifier.guessFormat(context,b);
  b.setFormat(bf);
  b.update();
  item.update();
  showEditForm(context,request,response,item);
  temp.delete();
  context.complete();
}",0.9940455341506128
3614,"/** 
 * Create a workflow group for the given step if one does not already exist. Returns either the newly created group or the previously existing one. Note that while the new group is created in the database, the association between the group and the collection is not written until <code>update</code> is called.
 * @param step  the step (1-3) of the workflow to create or get the groupfor
 * @return  the workflow group associated with this collection
 */
public Group createWorkflowGroup(int step) throws SQLException, AuthorizeException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (workflowGroup[step - 1] == null) {
    workflowGroup[step - 1]=Group.create(ourContext);
    workflowGroup[step - 1].setName(""String_Node_Str"" + getID() + ""String_Node_Str""+ step);
    workflowGroup[step - 1].update();
  }
  return workflowGroup[step - 1];
}","/** 
 * Create a workflow group for the given step if one does not already exist. Returns either the newly created group or the previously existing one. Note that while the new group is created in the database, the association between the group and the collection is not written until <code>update</code> is called.
 * @param step  the step (1-3) of the workflow to create or get the groupfor
 * @return  the workflow group associated with this collection
 */
public Group createWorkflowGroup(int step) throws SQLException, AuthorizeException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (workflowGroup[step - 1] == null) {
    Group g=Group.create(ourContext);
    g.setName(""String_Node_Str"" + getID() + ""String_Node_Str""+ step);
    g.update();
    setWorkflowGroup(step,g);
  }
  return workflowGroup[step - 1];
}",0.9432213209733488
3615,"/** 
 * Process input from the edit item form
 * @param context   DSpace context
 * @param request   the HTTP request containing posted info
 * @param response  the HTTP response
 * @param item      the item
 */
private void processUpdateItem(Context context,HttpServletRequest request,HttpServletResponse response,Item item) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  item.clearDC(Item.ANY,Item.ANY,Item.ANY);
  Enumeration unsortedParamNames=request.getParameterNames();
  List sortedParamNames=new LinkedList();
  while (unsortedParamNames.hasMoreElements()) {
    sortedParamNames.add(unsortedParamNames.nextElement());
  }
  Collections.sort(sortedParamNames);
  Iterator iterator=sortedParamNames.iterator();
  while (iterator.hasNext()) {
    String p=(String)iterator.next();
    if (p.startsWith(""String_Node_Str"")) {
      StringTokenizer st=new StringTokenizer(p,""String_Node_Str"");
      st.nextToken();
      String element=st.nextToken();
      String qualifier=null;
      if (st.countTokens() == 2) {
        qualifier=st.nextToken();
      }
      String sequenceNumber=st.nextToken();
      String key=element;
      if (qualifier != null) {
        key=element + ""String_Node_Str"" + qualifier;
      }
      String language=request.getParameter(""String_Node_Str"" + key + ""String_Node_Str""+ sequenceNumber);
      if (language != null && language.equals(""String_Node_Str"")) {
        language=null;
      }
      String value=request.getParameter(p).trim();
      if (value.equals(""String_Node_Str"") || !button.equals(""String_Node_Str"" + key + ""String_Node_Str""+ sequenceNumber)) {
        item.addDC(element,qualifier,language,value);
      }
    }
 else     if (p.startsWith(""String_Node_Str"")) {
      StringTokenizer st=new StringTokenizer(p,""String_Node_Str"");
      st.nextToken();
      st.nextToken();
      int bundleID=Integer.parseInt(st.nextToken());
      int bitstreamID=Integer.parseInt(st.nextToken());
      Bundle bundle=Bundle.find(context,bundleID);
      Bitstream bitstream=Bitstream.find(context,bitstreamID);
      String key=String.valueOf(bundleID) + ""String_Node_Str"" + bitstreamID;
      if (button.equals(""String_Node_Str"" + key)) {
        bundle.removeBitstream(bitstream);
        if (bundle.getBitstreams().length == 0) {
          item.removeBundle(bundle);
        }
      }
 else {
        String name=request.getParameter(p);
        String source=request.getParameter(""String_Node_Str"" + key);
        String desc=request.getParameter(""String_Node_Str"" + key);
        int formatID=UIUtil.getIntParameter(request,""String_Node_Str"" + key);
        String userFormatDesc=request.getParameter(""String_Node_Str"" + key);
        int primaryBitstreamID=UIUtil.getIntParameter(request,bundleID + ""String_Node_Str"");
        if (source.equals(""String_Node_Str""))         source=null;
        if (desc.equals(""String_Node_Str""))         desc=null;
        if (userFormatDesc.equals(""String_Node_Str""))         userFormatDesc=null;
        bitstream.setName(name);
        bitstream.setSource(source);
        bitstream.setDescription(desc);
        bitstream.setFormat(BitstreamFormat.find(context,formatID));
        bundle.setPrimaryBitstreamID(primaryBitstreamID);
        if (userFormatDesc != null) {
          bitstream.setUserFormatDescription(userFormatDesc);
        }
        bitstream.update();
        bundle.update();
      }
    }
  }
  item.update();
  if (button.equals(""String_Node_Str"")) {
    int dcTypeID=UIUtil.getIntParameter(request,""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"").trim();
    String lang=request.getParameter(""String_Node_Str"");
    if (lang.equals(""String_Node_Str""))     lang=null;
    DCType dcType=DCType.find(context,dcTypeID);
    item.addDC(dcType.getElement(),dcType.getQualifier(),lang,value);
    item.update();
  }
  if (button.equals(""String_Node_Str"")) {
    request.setAttribute(""String_Node_Str"",item);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showEditForm(context,request,response,item);
  }
  context.complete();
}","/** 
 * Process input from the edit item form
 * @param context   DSpace context
 * @param request   the HTTP request containing posted info
 * @param response  the HTTP response
 * @param item      the item
 */
private void processUpdateItem(Context context,HttpServletRequest request,HttpServletResponse response,Item item) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  item.clearDC(Item.ANY,Item.ANY,Item.ANY);
  Enumeration unsortedParamNames=request.getParameterNames();
  List sortedParamNames=new LinkedList();
  while (unsortedParamNames.hasMoreElements()) {
    sortedParamNames.add(unsortedParamNames.nextElement());
  }
  Collections.sort(sortedParamNames);
  Iterator iterator=sortedParamNames.iterator();
  while (iterator.hasNext()) {
    String p=(String)iterator.next();
    if (p.startsWith(""String_Node_Str"")) {
      StringTokenizer st=new StringTokenizer(p,""String_Node_Str"");
      st.nextToken();
      String element=st.nextToken();
      String qualifier=null;
      if (st.countTokens() == 2) {
        qualifier=st.nextToken();
      }
      String sequenceNumber=st.nextToken();
      String key=element;
      if (qualifier != null) {
        key=element + ""String_Node_Str"" + qualifier;
      }
      String language=request.getParameter(""String_Node_Str"" + key + ""String_Node_Str""+ sequenceNumber);
      if (language != null && language.equals(""String_Node_Str"")) {
        language=null;
      }
      String value=request.getParameter(p).trim();
      if (value.equals(""String_Node_Str"") || !button.equals(""String_Node_Str"" + key + ""String_Node_Str""+ sequenceNumber)) {
        item.addDC(element,qualifier,language,value);
      }
    }
 else     if (p.startsWith(""String_Node_Str"")) {
      StringTokenizer st=new StringTokenizer(p,""String_Node_Str"");
      st.nextToken();
      st.nextToken();
      int bundleID=Integer.parseInt(st.nextToken());
      int bitstreamID=Integer.parseInt(st.nextToken());
      Bundle bundle=Bundle.find(context,bundleID);
      Bitstream bitstream=Bitstream.find(context,bitstreamID);
      String key=String.valueOf(bundleID) + ""String_Node_Str"" + bitstreamID;
      if (button.equals(""String_Node_Str"" + key)) {
        bundle.removeBitstream(bitstream);
        if (bundle.getBitstreams().length == 0) {
          item.removeBundle(bundle);
        }
      }
 else {
        String name=request.getParameter(p);
        String source=request.getParameter(""String_Node_Str"" + key);
        String desc=request.getParameter(""String_Node_Str"" + key);
        int formatID=UIUtil.getIntParameter(request,""String_Node_Str"" + key);
        String userFormatDesc=request.getParameter(""String_Node_Str"" + key);
        int primaryBitstreamID=UIUtil.getIntParameter(request,bundleID + ""String_Node_Str"");
        if (source.equals(""String_Node_Str""))         source=null;
        if (desc.equals(""String_Node_Str""))         desc=null;
        if (userFormatDesc.equals(""String_Node_Str""))         userFormatDesc=null;
        bitstream.setName(name);
        bitstream.setSource(source);
        bitstream.setDescription(desc);
        bitstream.setFormat(BitstreamFormat.find(context,formatID));
        if (primaryBitstreamID > 0) {
          bundle.setPrimaryBitstreamID(primaryBitstreamID);
        }
        if (userFormatDesc != null) {
          bitstream.setUserFormatDescription(userFormatDesc);
        }
        bitstream.update();
        bundle.update();
      }
    }
  }
  item.update();
  if (button.equals(""String_Node_Str"")) {
    int dcTypeID=UIUtil.getIntParameter(request,""String_Node_Str"");
    String value=request.getParameter(""String_Node_Str"").trim();
    String lang=request.getParameter(""String_Node_Str"");
    if (lang.equals(""String_Node_Str""))     lang=null;
    DCType dcType=DCType.find(context,dcTypeID);
    item.addDC(dcType.getElement(),dcType.getQualifier(),lang,value);
    item.update();
  }
  if (button.equals(""String_Node_Str"")) {
    request.setAttribute(""String_Node_Str"",item);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showEditForm(context,request,response,item);
  }
  context.complete();
}",0.990489776509748
3616,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int sortBy=EPerson.LASTNAME;
  String sbParam=request.getParameter(""String_Node_Str"");
  if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.LASTNAME;
  }
 else   if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.EMAIL;
  }
  int first=UIUtil.getIntParameter(request,""String_Node_Str"");
  if (first == -1)   first=0;
  EPerson[] epeople=EPerson.findAll(context,sortBy);
  request.setAttribute(""String_Node_Str"",new Integer(sortBy));
  request.setAttribute(""String_Node_Str"",new Integer(first));
  request.setAttribute(""String_Node_Str"",epeople);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  int sortBy=EPerson.LASTNAME;
  String sbParam=request.getParameter(""String_Node_Str"");
  if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.LASTNAME;
  }
 else   if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.EMAIL;
  }
 else   if (sbParam != null && sbParam.equals(""String_Node_Str"")) {
    sortBy=EPerson.ID;
  }
  int first=UIUtil.getIntParameter(request,""String_Node_Str"");
  if (first == -1)   first=0;
  EPerson[] epeople=EPerson.findAll(context,sortBy);
  request.setAttribute(""String_Node_Str"",new Integer(sortBy));
  request.setAttribute(""String_Node_Str"",new Integer(first));
  request.setAttribute(""String_Node_Str"",epeople);
  JSPManager.showJSP(request,response,""String_Node_Str"");
}",0.945992040932348
3617,"public static void main(String[] argv) throws Exception {
  Context c=new Context();
  c.setIgnoreAuthorization(true);
  ItemIterator ii=Item.findAll(c);
  while (ii.hasNext()) {
    boolean skipItem=false;
    Item myItem=ii.next();
    int licenseBundleIndex=-1;
    int primaryBundleIndex=-1;
    System.out.println(""String_Node_Str"" + myItem.getID());
    Bundle[] myBundles=myItem.getBundles();
    for (int i=0; i < myBundles.length; i++) {
      Bitstream[] bitstreams=myBundles[i].getBitstreams();
      if (bitstreams.length > 1) {
        System.out.println(""String_Node_Str"");
        skipItem=true;
        break;
      }
      BitstreamFormat bf=bitstreams[0].getFormat();
      if (bf.getShortDescription().equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        if (licenseBundleIndex == -1) {
          licenseBundleIndex=i;
          System.out.println(""String_Node_Str"" + i);
        }
 else {
          System.out.println(""String_Node_Str"");
          skipItem=true;
          break;
        }
      }
 else {
        if (primaryBundleIndex == -1) {
          primaryBundleIndex=i;
          System.out.println(""String_Node_Str"" + i);
        }
      }
    }
    if (!skipItem) {
      if (primaryBundleIndex != -1) {
        myBundles[primaryBundleIndex].setName(""String_Node_Str"");
        myBundles[primaryBundleIndex].update();
      }
      if (licenseBundleIndex != -1) {
        myBundles[licenseBundleIndex].setName(""String_Node_Str"");
        myBundles[licenseBundleIndex].update();
      }
      for (int i=0; i < myBundles.length; i++) {
        Bitstream[] bitstreams=myBundles[i].getBitstreams();
        if (bitstreams.length > 0) {
          if ((i != primaryBundleIndex) && (i != licenseBundleIndex)) {
            myBundles[primaryBundleIndex].addBitstream(bitstreams[0]);
            myItem.removeBundle(myBundles[i]);
            System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
          }
        }
      }
    }
  }
  c.complete();
}","public static void main(String[] argv) throws Exception {
  Context c=new Context();
  c.setIgnoreAuthorization(true);
  ItemIterator ii=null;
  Collection[] collections=Collection.findAll(c);
  System.out.println(""String_Node_Str"");
  for (int q=0; q < collections.length; q++) {
    ii=collections[q].getItems();
    while (ii.hasNext()) {
      Item myItem=ii.next();
      if (myItem.getOwningCollection() == null) {
        myItem.setOwningCollection(collections[q]);
        myItem.update();
        System.out.println(""String_Node_Str"" + myItem.getID() + ""String_Node_Str""+ collections[q].getID());
      }
    }
  }
  c.commit();
  ii=Item.findAll(c);
  while (ii.hasNext()) {
    boolean skipItem=false;
    Item myItem=ii.next();
    int licenseBundleIndex=-1;
    int primaryBundleIndex=-1;
    System.out.println(""String_Node_Str"" + myItem.getID());
    Bundle[] myBundles=myItem.getBundles();
    for (int i=0; i < myBundles.length; i++) {
      if (myBundles[i].getName() != null) {
        System.out.println(""String_Node_Str"");
        skipItem=true;
        break;
      }
      Bitstream[] bitstreams=myBundles[i].getBitstreams();
      if (bitstreams.length > 1) {
        System.out.println(""String_Node_Str"");
        skipItem=true;
        break;
      }
      BitstreamFormat bf=bitstreams[0].getFormat();
      if (bf.getShortDescription().equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        if (licenseBundleIndex == -1) {
          licenseBundleIndex=i;
          System.out.println(""String_Node_Str"" + i);
        }
 else {
          System.out.println(""String_Node_Str"");
          skipItem=true;
          break;
        }
      }
 else {
        if (primaryBundleIndex == -1) {
          primaryBundleIndex=i;
          System.out.println(""String_Node_Str"" + i);
        }
      }
    }
    if (!skipItem) {
      if (primaryBundleIndex != -1) {
        myBundles[primaryBundleIndex].setName(""String_Node_Str"");
        myBundles[primaryBundleIndex].update();
      }
      if (licenseBundleIndex != -1) {
        myBundles[licenseBundleIndex].setName(""String_Node_Str"");
        myBundles[licenseBundleIndex].update();
      }
      for (int i=0; i < myBundles.length; i++) {
        Bitstream[] bitstreams=myBundles[i].getBitstreams();
        if (bitstreams.length > 0) {
          if ((i != primaryBundleIndex) && (i != licenseBundleIndex)) {
            myBundles[primaryBundleIndex].addBitstream(bitstreams[0]);
            myItem.removeBundle(myBundles[i]);
            System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
          }
        }
      }
    }
  }
  c.complete();
}",0.8607486631016042
3618,"public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  try {
    out.println(""String_Node_Str"");
    out.print(""String_Node_Str"" + (emphasiseDate ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (emphasiseDate ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    out.println(""String_Node_Str"" + (emphasiseTitle ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (emphasiseTitle ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    out.println(""String_Node_Str"");
    String row=""String_Node_Str"";
    for (int i=0; i < items.length; i++) {
      DCValue[] titleArray=items[i].getDC(""String_Node_Str"",null,Item.ANY);
      String title=""String_Node_Str"";
      if (titleArray.length > 0) {
        title=titleArray[0].value;
      }
      DCValue[] authors=items[i].getDC(""String_Node_Str"",Item.ANY,Item.ANY);
      DCValue[] dateIssued=items[i].getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
      DCDate dd=null;
      if (dateIssued.length > 0) {
        dd=new DCDate(dateIssued[0].value);
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      if (emphasiseDate) {
        out.print(""String_Node_Str"");
      }
      out.print(UIUtil.displayDate(dd,false,false));
      if (emphasiseDate) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      if (emphasiseTitle) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
      out.print(hrq.getContextPath());
      out.print(""String_Node_Str"");
      out.print(items[i].getHandle());
      out.print(""String_Node_Str"");
      out.print(title);
      out.print(""String_Node_Str"");
      if (emphasiseTitle) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      for (int j=0; j < authors.length; j++) {
        out.print(""String_Node_Str"" + authors[j].value + ""String_Node_Str"");
        if (j < authors.length - 1) {
          out.print(""String_Node_Str"");
        }
      }
      out.println(""String_Node_Str"");
      row=(row.equals(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
  return SKIP_BODY;
}","public int doStartTag() throws JspException {
  JspWriter out=pageContext.getOut();
  boolean emphasiseDate=false;
  boolean emphasiseTitle=false;
  if (emphColumn != null) {
    emphasiseDate=emphColumn.equalsIgnoreCase(""String_Node_Str"");
    emphasiseTitle=emphColumn.equalsIgnoreCase(""String_Node_Str"");
  }
  try {
    out.println(""String_Node_Str"");
    out.print(""String_Node_Str"" + (emphasiseDate ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (emphasiseDate ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    out.println(""String_Node_Str"" + (emphasiseTitle ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ (emphasiseTitle ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    out.println(""String_Node_Str"");
    String row=""String_Node_Str"";
    for (int i=0; i < items.length; i++) {
      DCValue[] titleArray=items[i].getDC(""String_Node_Str"",null,Item.ANY);
      String title=""String_Node_Str"";
      if (titleArray.length > 0) {
        title=titleArray[0].value;
      }
      DCValue[] authors=items[i].getDC(""String_Node_Str"",Item.ANY,Item.ANY);
      DCValue[] dateIssued=items[i].getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
      DCDate dd=null;
      if (dateIssued.length > 0) {
        dd=new DCDate(dateIssued[0].value);
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      if (emphasiseDate) {
        out.print(""String_Node_Str"");
      }
      out.print(UIUtil.displayDate(dd,false,false));
      if (emphasiseDate) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      if (emphasiseTitle) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      HttpServletRequest hrq=(HttpServletRequest)pageContext.getRequest();
      out.print(hrq.getContextPath());
      out.print(""String_Node_Str"");
      out.print(items[i].getHandle());
      out.print(""String_Node_Str"");
      out.print(Utils.addEntities(title));
      out.print(""String_Node_Str"");
      if (emphasiseTitle) {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(i == highlightRow ? ""String_Node_Str"" : row);
      out.print(""String_Node_Str"");
      for (int j=0; j < authors.length; j++) {
        out.print(""String_Node_Str"" + Utils.addEntities(authors[j].value) + ""String_Node_Str"");
        if (j < authors.length - 1) {
          out.print(""String_Node_Str"");
        }
      }
      out.println(""String_Node_Str"");
      row=(row.equals(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
  }
 catch (  IOException ie) {
    throw new JspException(ie);
  }
  return SKIP_BODY;
}",0.9916579770594368
3619,"/** 
 * Render full item record
 */
private void renderFull() throws IOException, java.sql.SQLException {
  JspWriter out=pageContext.getOut();
  DCValue[] values=item.getDC(Item.ANY,Item.ANY,Item.ANY);
  out.println(""String_Node_Str"");
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  for (int i=0; i < values.length; i++) {
    boolean hidden=false;
    if (values[i].element.equals(""String_Node_Str"") && (values[i].qualifier != null && values[i].qualifier.equals(""String_Node_Str""))) {
      hidden=true;
    }
    if (!hidden) {
      out.print(""String_Node_Str"");
      out.print(values[i].element);
      if (values[i].qualifier != null) {
        out.print(""String_Node_Str"" + values[i].qualifier);
      }
      out.print(""String_Node_Str"");
      out.print(values[i].value);
      out.print(""String_Node_Str"");
      if (values[i].language == null) {
        out.print(""String_Node_Str"");
      }
 else {
        out.print(values[i].language);
      }
      out.println(""String_Node_Str"");
    }
  }
  listCollections();
  out.println(""String_Node_Str"");
  listBitstreams();
}","/** 
 * Render full item record
 */
private void renderFull() throws IOException, java.sql.SQLException {
  JspWriter out=pageContext.getOut();
  DCValue[] values=item.getDC(Item.ANY,Item.ANY,Item.ANY);
  out.println(""String_Node_Str"");
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  for (int i=0; i < values.length; i++) {
    boolean hidden=false;
    if (values[i].element.equals(""String_Node_Str"") && (values[i].qualifier != null && values[i].qualifier.equals(""String_Node_Str""))) {
      hidden=true;
    }
    if (!hidden) {
      out.print(""String_Node_Str"");
      out.print(values[i].element);
      if (values[i].qualifier != null) {
        out.print(""String_Node_Str"" + values[i].qualifier);
      }
      out.print(""String_Node_Str"");
      out.print(Utils.addEntities(values[i].value));
      out.print(""String_Node_Str"");
      if (values[i].language == null) {
        out.print(""String_Node_Str"");
      }
 else {
        out.print(values[i].language);
      }
      out.println(""String_Node_Str"");
    }
  }
  listCollections();
  out.println(""String_Node_Str"");
  listBitstreams();
}",0.992020159596808
3620,"/** 
 * Render an item in the default style
 */
private void renderDefault() throws IOException, java.sql.SQLException {
  JspWriter out=pageContext.getOut();
  List fields=new LinkedList();
  DCValue[] titleDC=item.getDC(""String_Node_Str"",null,Item.ANY);
  if (titleDC.length == 0) {
    fields.add(new String[]{""String_Node_Str"",""String_Node_Str""});
  }
 else {
    fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  }
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",Item.ANY});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCDate dd=null;
  if (dateIssued.length > 0) {
    dd=new DCDate(dateIssued[0].value);
  }
  String displayDate=UIUtil.displayDate(dd,false,false);
  fields.add(new String[]{""String_Node_Str"",displayDate});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  DCValue[] abstrDC=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (abstrDC.length > 0) {
    String abstr=abstrDC[0].value;
    if (abstr.length() > 1000) {
      abstr=abstr.substring(0,1000) + ""String_Node_Str"";
    }
    fields.add(new String[]{""String_Node_Str"",abstr});
  }
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.println(""String_Node_Str"");
  Iterator fieldIterator=fields.iterator();
  while (fieldIterator.hasNext()) {
    String[] fieldData=(String[])fieldIterator.next();
    DCValue[] values;
    if (fieldData.length == 2) {
      DCValue v=new DCValue();
      v.value=fieldData[1];
      values=new DCValue[1];
      values[0]=v;
    }
 else {
      values=item.getDC(fieldData[1],fieldData[2],Item.ANY);
    }
    if (values.length > 0) {
      out.print(""String_Node_Str"");
      out.print(fieldData[0]);
      out.print(""String_Node_Str"");
      out.print(values[0].value);
      for (int j=1; j < values.length; j++) {
        out.print(""String_Node_Str"");
        out.print(values[j].value);
      }
      out.println(""String_Node_Str"");
    }
  }
  listCollections();
  out.println(""String_Node_Str"");
  listBitstreams();
}","/** 
 * Render an item in the default style
 */
private void renderDefault() throws IOException, java.sql.SQLException {
  JspWriter out=pageContext.getOut();
  List fields=new LinkedList();
  DCValue[] titleDC=item.getDC(""String_Node_Str"",null,Item.ANY);
  if (titleDC.length == 0) {
    fields.add(new String[]{""String_Node_Str"",""String_Node_Str""});
  }
 else {
    fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  }
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",Item.ANY});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  DCValue[] dateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  DCDate dd=null;
  if (dateIssued.length > 0) {
    dd=new DCDate(dateIssued[0].value);
  }
  String displayDate=UIUtil.displayDate(dd,false,false);
  fields.add(new String[]{""String_Node_Str"",displayDate});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  DCValue[] abstrDC=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (abstrDC.length > 0) {
    String abstr=abstrDC[0].value;
    if (abstr.length() > 1000) {
      abstr=abstr.substring(0,1000) + ""String_Node_Str"";
    }
    fields.add(new String[]{""String_Node_Str"",abstr});
  }
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  fields.add(new String[]{""String_Node_Str"",""String_Node_Str"",null});
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.println(""String_Node_Str"");
  Iterator fieldIterator=fields.iterator();
  while (fieldIterator.hasNext()) {
    String[] fieldData=(String[])fieldIterator.next();
    DCValue[] values;
    if (fieldData.length == 2) {
      DCValue v=new DCValue();
      v.value=fieldData[1];
      values=new DCValue[1];
      values[0]=v;
    }
 else {
      values=item.getDC(fieldData[1],fieldData[2],Item.ANY);
    }
    if (values.length > 0) {
      out.print(""String_Node_Str"");
      out.print(fieldData[0]);
      out.print(""String_Node_Str"");
      out.print(Utils.addEntities(values[0].value));
      for (int j=1; j < values.length; j++) {
        out.print(""String_Node_Str"");
        out.print(Utils.addEntities(values[j].value));
      }
      out.println(""String_Node_Str"");
    }
  }
  listCollections();
  out.println(""String_Node_Str"");
  listBitstreams();
}",0.993598382749326
3621,"/** 
 * Do a query, restricted to a community
 * @param querystring
 * @param community
 * @return HashMap results, same as full doQuery, only hits in a Community
 */
public static QueryResults doQuery(Context c,QueryArgs args,Community comm) throws IOException, ParseException {
  String querystring=args.getQuery();
  querystring=checkEmptyQuery(querystring);
  String location=""String_Node_Str"" + (comm.getID());
  String newquery=new String(""String_Node_Str"" + querystring + ""String_Node_Str""+ location+ ""String_Node_Str"");
  args.setQuery(newquery);
  return doQuery(c,args);
}","/** 
 * Do a query, restricted to a community
 * @param querystring
 * @param community
 * @return HashMap results, same as full doQuery, only hits in a Community
 */
public static QueryResults doQuery(Context c,QueryArgs args,Community comm) throws IOException {
  String querystring=args.getQuery();
  querystring=checkEmptyQuery(querystring);
  String location=""String_Node_Str"" + (comm.getID());
  String newquery=new String(""String_Node_Str"" + querystring + ""String_Node_Str""+ location+ ""String_Node_Str"");
  args.setQuery(newquery);
  return doQuery(c,args);
}",0.9860627177700348
3622,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String query=request.getParameter(""String_Node_Str"");
  int start=UIUtil.getIntParameter(request,""String_Node_Str"");
  String advanced=request.getParameter(""String_Node_Str"");
  String fromAdvanced=request.getParameter(""String_Node_Str"");
  String advancedQuery=""String_Node_Str"";
  HashMap queryHash=new HashMap();
  if (start < 0) {
    start=0;
  }
  List itemHandles=new ArrayList();
  List collectionHandles=new ArrayList();
  List communityHandles=new ArrayList();
  Item[] resultsItems;
  Collection[] resultsCollections;
  Community[] resultsCommunities;
  QueryResults qResults=null;
  QueryArgs qArgs=new QueryArgs();
  if (advanced != null) {
    query=qArgs.buildQuery(request);
    advancedQuery=qArgs.buildHTTPQuery(request);
  }
  if (query == null) {
    query=""String_Node_Str"";
  }
  String location=request.getParameter(""String_Node_Str"");
  String newURL;
  if (location != null && !location.equals(""String_Node_Str"")) {
    String url=""String_Node_Str"";
    if (!location.equals(""String_Node_Str"")) {
      url=""String_Node_Str"" + location;
    }
    query=URLEncoder.encode(query);
    if (advancedQuery.length() > 0) {
      query=query + ""String_Node_Str"" + advancedQuery;
    }
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + url + ""String_Node_Str""+ query));
    return;
  }
  String logInfo=""String_Node_Str"";
  Community community=UIUtil.getCommunityLocation(request);
  Collection collection=UIUtil.getCollectionLocation(request);
  qArgs.setQuery(query);
  qArgs.setStart(start);
  try {
    if (collection != null) {
      logInfo=""String_Node_Str"" + collection.getID() + ""String_Node_Str"";
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",collection);
      qResults=DSQuery.doQuery(context,qArgs,collection);
    }
 else     if (community != null) {
      logInfo=""String_Node_Str"" + community.getID() + ""String_Node_Str"";
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",community.getCollections());
      qResults=DSQuery.doQuery(context,qArgs,community);
    }
 else {
      Community[] communities=Community.findAll(context);
      request.setAttribute(""String_Node_Str"",communities);
      qResults=DSQuery.doQuery(context,qArgs);
    }
    for (int i=0; i < qResults.getHitHandles().size(); i++) {
      String myHandle=(String)qResults.getHitHandles().get(i);
      Integer myType=(Integer)qResults.getHitTypes().get(i);
switch (myType.intValue()) {
case Constants.ITEM:
        itemHandles.add(myHandle);
      break;
case Constants.COLLECTION:
    collectionHandles.add(myHandle);
  break;
case Constants.COMMUNITY:
communityHandles.add(myHandle);
break;
}
}
int numCommunities=communityHandles.size();
int numCollections=collectionHandles.size();
int numItems=itemHandles.size();
resultsCommunities=new Community[numCommunities];
resultsCollections=new Collection[numCollections];
resultsItems=new Item[numItems];
for (int i=0; i < numItems; i++) {
String myhandle=(String)itemHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsItems[i]=(Item)o;
if (resultsItems[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
for (int i=0; i < collectionHandles.size(); i++) {
String myhandle=(String)collectionHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsCollections[i]=(Collection)o;
if (resultsCollections[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
for (int i=0; i < communityHandles.size(); i++) {
String myhandle=(String)communityHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsCommunities[i]=(Community)o;
if (resultsCommunities[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
log.info(LogManager.getHeader(context,""String_Node_Str"",logInfo + ""String_Node_Str"" + query+ ""String_Node_Str""+ resultsCommunities.length+ ""String_Node_Str""+ resultsCollections.length+ ""String_Node_Str""+ resultsItems.length+ ""String_Node_Str""));
}
 catch (ParseException pe) {
log.warn(LogManager.getHeader(context,""String_Node_Str"",logInfo + ""String_Node_Str"" + query+ ""String_Node_Str""),pe);
resultsItems=new Item[0];
resultsCommunities=new Community[0];
resultsCollections=new Collection[0];
}
catch (TokenMgrError tme) {
log.warn(LogManager.getHeader(context,""String_Node_Str"",logInfo + ""String_Node_Str"" + query+ ""String_Node_Str""),tme);
resultsItems=new Item[0];
resultsCommunities=new Community[0];
resultsCollections=new Collection[0];
}
int pageTotal=1 + (qResults.getHitCount() - 1) / qResults.getPageSize();
int pageCurrent=1 + (qResults.getStart() / qResults.getPageSize());
int pageLast=(pageCurrent + 9) > pageTotal ? pageTotal : (pageCurrent + 9);
int pageFirst=(pageCurrent - 9) > 1 ? (pageCurrent - 9) : 1;
request.setAttribute(""String_Node_Str"",resultsItems);
request.setAttribute(""String_Node_Str"",resultsCommunities);
request.setAttribute(""String_Node_Str"",resultsCollections);
request.setAttribute(""String_Node_Str"",new Integer(pageTotal));
request.setAttribute(""String_Node_Str"",new Integer(pageCurrent));
request.setAttribute(""String_Node_Str"",new Integer(pageLast));
request.setAttribute(""String_Node_Str"",new Integer(pageFirst));
request.setAttribute(""String_Node_Str"",qResults);
request.setAttribute(""String_Node_Str"",query);
if ((fromAdvanced != null) && (qResults.getHitCount() == 0)) {
Community[] communities=Community.findAll(context);
request.setAttribute(""String_Node_Str"",communities);
request.setAttribute(""String_Node_Str"",""String_Node_Str"");
queryHash=qArgs.buildQueryHash(request);
Iterator i=queryHash.keySet().iterator();
while (i.hasNext()) {
String key=(String)i.next();
String value=(String)queryHash.get(key);
request.setAttribute(key,value);
}
JSPManager.showJSP(request,response,""String_Node_Str"");
}
 else {
JSPManager.showJSP(request,response,""String_Node_Str"");
}
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String query=request.getParameter(""String_Node_Str"");
  int start=UIUtil.getIntParameter(request,""String_Node_Str"");
  String advanced=request.getParameter(""String_Node_Str"");
  String fromAdvanced=request.getParameter(""String_Node_Str"");
  String advancedQuery=""String_Node_Str"";
  HashMap queryHash=new HashMap();
  if (start < 0) {
    start=0;
  }
  List itemHandles=new ArrayList();
  List collectionHandles=new ArrayList();
  List communityHandles=new ArrayList();
  Item[] resultsItems;
  Collection[] resultsCollections;
  Community[] resultsCommunities;
  QueryResults qResults=null;
  QueryArgs qArgs=new QueryArgs();
  if (advanced != null) {
    query=qArgs.buildQuery(request);
    advancedQuery=qArgs.buildHTTPQuery(request);
  }
  if (query == null) {
    query=""String_Node_Str"";
  }
  String location=request.getParameter(""String_Node_Str"");
  String newURL;
  if (location != null && !location.equals(""String_Node_Str"")) {
    String url=""String_Node_Str"";
    if (!location.equals(""String_Node_Str"")) {
      url=""String_Node_Str"" + location;
    }
    query=URLEncoder.encode(query);
    if (advancedQuery.length() > 0) {
      query=query + ""String_Node_Str"" + advancedQuery;
    }
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + url + ""String_Node_Str""+ query));
    return;
  }
  String logInfo=""String_Node_Str"";
  Community community=UIUtil.getCommunityLocation(request);
  Collection collection=UIUtil.getCollectionLocation(request);
  qArgs.setQuery(query);
  qArgs.setStart(start);
  if (collection != null) {
    logInfo=""String_Node_Str"" + collection.getID() + ""String_Node_Str"";
    request.setAttribute(""String_Node_Str"",community);
    request.setAttribute(""String_Node_Str"",collection);
    qResults=DSQuery.doQuery(context,qArgs,collection);
  }
 else   if (community != null) {
    logInfo=""String_Node_Str"" + community.getID() + ""String_Node_Str"";
    request.setAttribute(""String_Node_Str"",community);
    request.setAttribute(""String_Node_Str"",community.getCollections());
    qResults=DSQuery.doQuery(context,qArgs,community);
  }
 else {
    Community[] communities=Community.findAll(context);
    request.setAttribute(""String_Node_Str"",communities);
    qResults=DSQuery.doQuery(context,qArgs);
  }
  for (int i=0; i < qResults.getHitHandles().size(); i++) {
    String myHandle=(String)qResults.getHitHandles().get(i);
    Integer myType=(Integer)qResults.getHitTypes().get(i);
switch (myType.intValue()) {
case Constants.ITEM:
      itemHandles.add(myHandle);
    break;
case Constants.COLLECTION:
  collectionHandles.add(myHandle);
break;
case Constants.COMMUNITY:
communityHandles.add(myHandle);
break;
}
}
int numCommunities=communityHandles.size();
int numCollections=collectionHandles.size();
int numItems=itemHandles.size();
resultsCommunities=new Community[numCommunities];
resultsCollections=new Collection[numCollections];
resultsItems=new Item[numItems];
for (int i=0; i < numItems; i++) {
String myhandle=(String)itemHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsItems[i]=(Item)o;
if (resultsItems[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
for (int i=0; i < collectionHandles.size(); i++) {
String myhandle=(String)collectionHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsCollections[i]=(Collection)o;
if (resultsCollections[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
for (int i=0; i < communityHandles.size(); i++) {
String myhandle=(String)communityHandles.get(i);
Object o=HandleManager.resolveToObject(context,myhandle);
resultsCommunities[i]=(Community)o;
if (resultsCommunities[i] == null) {
throw new SQLException(""String_Node_Str"" + query + ""String_Node_Str""+ myhandle);
}
}
log.info(LogManager.getHeader(context,""String_Node_Str"",logInfo + ""String_Node_Str"" + query+ ""String_Node_Str""+ resultsCommunities.length+ ""String_Node_Str""+ resultsCollections.length+ ""String_Node_Str""+ resultsItems.length+ ""String_Node_Str""));
int pageTotal=1 + (qResults.getHitCount() - 1) / qResults.getPageSize();
int pageCurrent=1 + (qResults.getStart() / qResults.getPageSize());
int pageLast=(pageCurrent + 9) > pageTotal ? pageTotal : (pageCurrent + 9);
int pageFirst=(pageCurrent - 9) > 1 ? (pageCurrent - 9) : 1;
request.setAttribute(""String_Node_Str"",resultsItems);
request.setAttribute(""String_Node_Str"",resultsCommunities);
request.setAttribute(""String_Node_Str"",resultsCollections);
request.setAttribute(""String_Node_Str"",new Integer(pageTotal));
request.setAttribute(""String_Node_Str"",new Integer(pageCurrent));
request.setAttribute(""String_Node_Str"",new Integer(pageLast));
request.setAttribute(""String_Node_Str"",new Integer(pageFirst));
request.setAttribute(""String_Node_Str"",qResults);
request.setAttribute(""String_Node_Str"",query);
if ((fromAdvanced != null) && (qResults.getHitCount() == 0)) {
Community[] communities=Community.findAll(context);
request.setAttribute(""String_Node_Str"",communities);
request.setAttribute(""String_Node_Str"",""String_Node_Str"");
queryHash=qArgs.buildQueryHash(request);
Iterator i=queryHash.keySet().iterator();
while (i.hasNext()) {
String key=(String)i.next();
String value=(String)queryHash.get(key);
request.setAttribute(key,value);
}
JSPManager.showJSP(request,response,""String_Node_Str"");
}
 else {
JSPManager.showJSP(request,response,""String_Node_Str"");
}
}",0.9492729117348664
3623,"/** 
 * @param c context
 * @param item item containing bitstream to process
 * @param source source bitstream to process
 * @param boolean owerWrite false means do nothing if a matching filter rendition alreads exists
 * @return true if new rendition is created
 */
public boolean processBitstream(Context c,Item item,Bitstream source,boolean overWrite) throws Exception {
  String newName=getFilteredName(source.getName());
  Bitstream existingBitstream=null;
  Bundle targetBundle=null;
  Bundle[] bundles=item.getBundles(getBundleName());
  if (bundles.length > 0) {
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int j=0; j < bitstreams.length; j++) {
        if (bitstreams[j].getName().equals(newName)) {
          targetBundle=bundles[i];
          existingBitstream=bitstreams[j];
        }
      }
    }
  }
  if (!overWrite && (existingBitstream != null)) {
    System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
    return false;
  }
  if (bundles.length < 1) {
    targetBundle=item.createBundle(getBundleName());
  }
 else {
    targetBundle=bundles[0];
  }
  InputStream destStream=getDestinationStream(source.retrieve());
  Bitstream b=targetBundle.createBitstream(destStream);
  b.setName(newName);
  b.setSource(""String_Node_Str"" + this.getClass().getName());
  b.update();
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(c,getFormatString());
  b.setFormat(bf);
  if (existingBitstream != null) {
    targetBundle.removeBitstream(existingBitstream);
  }
  System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
  return true;
}","/** 
 * @param c context
 * @param item item containing bitstream to process
 * @param source source bitstream to process
 * @param boolean owerWrite false means do nothing if a matching filter rendition alreads exists
 * @return true if new rendition is created
 */
public boolean processBitstream(Context c,Item item,Bitstream source,boolean overWrite) throws Exception {
  String newName=getFilteredName(source.getName());
  Bitstream existingBitstream=null;
  Bundle targetBundle=null;
  Bundle[] bundles=item.getBundles(getBundleName());
  if (bundles.length > 0) {
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int j=0; j < bitstreams.length; j++) {
        if (bitstreams[j].getName().equals(newName)) {
          targetBundle=bundles[i];
          existingBitstream=bitstreams[j];
        }
      }
    }
  }
  if (!overWrite && (existingBitstream != null)) {
    System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
    return false;
  }
  if (bundles.length < 1) {
    targetBundle=item.createBundle(getBundleName());
  }
 else {
    targetBundle=bundles[0];
  }
  InputStream destStream=getDestinationStream(source.retrieve());
  Bitstream b=targetBundle.createBitstream(destStream);
  b.setName(newName);
  b.setSource(""String_Node_Str"" + this.getClass().getName());
  BitstreamFormat bf=BitstreamFormat.findByShortDescription(c,getFormatString());
  b.setFormat(bf);
  b.update();
  if (existingBitstream != null) {
    targetBundle.removeBitstream(existingBitstream);
  }
  System.out.println(""String_Node_Str"" + source.getID() + ""String_Node_Str""+ newName+ ""String_Node_Str"");
  return true;
}",0.9918887601390498
3624,"/** 
 * Format SQL according to the browse type.
 */
private static String formatSql(BrowseScope scope,String sql,String subqueryValue,boolean after){
  boolean before=!after;
  int browseType=scope.getBrowseType();
  boolean ascending=scope.getAscending();
  int numberDesired=before ? scope.getNumberBefore() : scope.getTotal();
  String beforeOperator=""String_Node_Str"";
  String afterOperator=""String_Node_Str"";
  if (browseType == ITEMS_BY_AUTHOR_BROWSE)   afterOperator=""String_Node_Str"";
  if (subqueryValue != null) {
    beforeOperator=""String_Node_Str"";
    afterOperator=""String_Node_Str"";
  }
  if (!ascending) {
    beforeOperator=""String_Node_Str"";
    afterOperator=""String_Node_Str"";
  }
  String beforeSubqueryOperator=""String_Node_Str"";
  String afterSubqueryOperator=""String_Node_Str"";
  if (browseType == ITEMS_BY_AUTHOR_BROWSE)   afterSubqueryOperator=""String_Node_Str"";
  if (!ascending) {
    beforeSubqueryOperator=""String_Node_Str"";
    afterSubqueryOperator=""String_Node_Str"";
  }
  String order=before ? ""String_Node_Str"" : ""String_Node_Str"";
  if (!ascending)   order=before ? ""String_Node_Str"" : ""String_Node_Str"";
  List args=new ArrayList();
  args.add(before ? beforeSubqueryOperator : afterSubqueryOperator);
  args.add(before ? beforeOperator : afterOperator);
  args.add(order);
  args.add(new Integer(numberDesired));
  return MessageFormat.format(sql,args.toArray());
}","/** 
 * Format SQL according to the browse type.
 */
private static String formatSql(BrowseScope scope,String sql,String subqueryValue,boolean after){
  boolean before=!after;
  int browseType=scope.getBrowseType();
  boolean ascending=scope.getAscending();
  int numberDesired=before ? scope.getNumberBefore() : scope.getTotal();
  String beforeOperator=""String_Node_Str"";
  String afterOperator=""String_Node_Str"";
  if (browseType == ITEMS_BY_AUTHOR_BROWSE)   afterOperator=""String_Node_Str"";
  if (subqueryValue != null) {
    beforeOperator=""String_Node_Str"";
    afterOperator=""String_Node_Str"";
  }
  if (!ascending) {
    beforeOperator=""String_Node_Str"";
    afterOperator=""String_Node_Str"";
  }
  if (browseType == ITEMS_BY_DATE_BROWSE) {
    if (!ascending) {
      beforeOperator=""String_Node_Str"";
      afterOperator=""String_Node_Str"";
    }
 else {
      beforeOperator=""String_Node_Str"";
      afterOperator=""String_Node_Str"";
    }
  }
  String beforeSubqueryOperator=""String_Node_Str"";
  String afterSubqueryOperator=""String_Node_Str"";
  if (browseType == ITEMS_BY_AUTHOR_BROWSE)   afterSubqueryOperator=""String_Node_Str"";
  if (!ascending) {
    beforeSubqueryOperator=""String_Node_Str"";
    afterSubqueryOperator=""String_Node_Str"";
  }
  String order=before ? ""String_Node_Str"" : ""String_Node_Str"";
  if (!ascending)   order=before ? ""String_Node_Str"" : ""String_Node_Str"";
  List args=new ArrayList();
  args.add(before ? beforeSubqueryOperator : afterSubqueryOperator);
  args.add(before ? beforeOperator : afterOperator);
  args.add(order);
  args.add(new Integer(numberDesired));
  return MessageFormat.format(sql,args.toArray());
}",0.8529411764705882
3625,"/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  int browseType=scope.getBrowseType();
  StringBuffer sqlb=new StringBuffer();
  sqlb.append(""String_Node_Str"");
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  sqlb.append(getTargetColumns(scope));
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  if (browseType == AUTHORS_BROWSE && !isCount) {
    sqlb.append(""String_Node_Str"");
  }
  sqlb.append(""String_Node_Str"");
  sqlb.append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}","/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  int browseType=scope.getBrowseType();
  StringBuffer sqlb=new StringBuffer();
  sqlb.append(""String_Node_Str"");
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  sqlb.append(getTargetColumns(scope));
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  if (browseType == AUTHORS_BROWSE && !isCount) {
    sqlb.append(""String_Node_Str"");
  }
  sqlb.append(""String_Node_Str"");
  sqlb.append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(((scope.focusIsString() && (scope.getBrowseType() != ITEMS_BY_DATE_BROWSE)) || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}",0.9852818661482922
3626,"/** 
 * Command line interface to setPolicies - run to see arguments
 */
public static void main(String[] argv) throws Exception {
  Context c=new Context();
  c.setIgnoreAuthorization(true);
  Collection[] collections=Collection.findAll(c);
  for (int i=0; i < collections.length; i++) {
    Collection t=collections[i];
    System.out.println(""String_Node_Str"" + t + ""String_Node_Str""+ t.getMetadata(""String_Node_Str""));
    if (checkForPolicy(c,t,Constants.READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.READ);
    }
    if (checkForPolicy(c,t,Constants.DEFAULT_ITEM_READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.DEFAULT_ITEM_READ);
    }
    if (checkForPolicy(c,t,Constants.DEFAULT_BITSTREAM_READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.DEFAULT_BITSTREAM_READ);
    }
  }
  Community[] communities=Community.findAll(c);
  for (int i=0; i < collections.length; i++) {
    Community t=communities[i];
    System.out.println(""String_Node_Str"" + t + ""String_Node_Str""+ t.getMetadata(""String_Node_Str""));
    if (checkForPolicy(c,t,Constants.READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.READ);
    }
  }
  c.complete();
}","/** 
 * Command line interface to setPolicies - run to see arguments
 */
public static void main(String[] argv) throws Exception {
  Context c=new Context();
  c.setIgnoreAuthorization(true);
  Collection[] collections=Collection.findAll(c);
  for (int i=0; i < collections.length; i++) {
    Collection t=collections[i];
    System.out.println(""String_Node_Str"" + t + ""String_Node_Str""+ t.getMetadata(""String_Node_Str""));
    if (checkForPolicy(c,t,Constants.READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.READ);
    }
    if (checkForPolicy(c,t,Constants.DEFAULT_ITEM_READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.DEFAULT_ITEM_READ);
    }
    if (checkForPolicy(c,t,Constants.DEFAULT_BITSTREAM_READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.DEFAULT_BITSTREAM_READ);
    }
  }
  Community[] communities=Community.findAll(c);
  for (int i=0; i < communities.length; i++) {
    Community t=communities[i];
    System.out.println(""String_Node_Str"" + t + ""String_Node_Str""+ t.getMetadata(""String_Node_Str""));
    if (checkForPolicy(c,t,Constants.READ)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
      addAnonymousPolicy(c,t,Constants.READ);
    }
  }
  c.complete();
}",0.9948253557567918
3627,"/** 
 * Reinstate a withdrawn item
 */
public void reinstate() throws SQLException, AuthorizeException, IOException {
  String timestamp=DCDate.getCurrent().toString();
  String collectionProv=""String_Node_Str"";
  Collection[] colls=getCollections();
  for (int i=0; i < colls.length; i++) {
    collectionProv=collectionProv + colls[i].getMetadata(""String_Node_Str"") + ""String_Node_Str""+ colls[i].getID()+ ""String_Node_Str"";
    AuthorizeManager.authorizeAction(ourContext,colls[i],Constants.ADD);
  }
  itemRow.setColumn(""String_Node_Str"",false);
  itemRow.setColumn(""String_Node_Str"",true);
  EPerson e=ourContext.getCurrentUser();
  String prov=""String_Node_Str"" + e.getFullName() + ""String_Node_Str""+ e.getEmail()+ ""String_Node_Str""+ timestamp+ ""String_Node_Str""+ ""String_Node_Str""+ collectionProv+ InstallItem.getBitstreamProvenanceMessage(this);
  addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",prov);
  update();
  HistoryManager.saveHistory(ourContext,this,HistoryManager.MODIFY,e,ourContext.getExtraLogInfo());
  Browse.itemAdded(ourContext,this);
  DSIndexer.indexContent(ourContext,this);
  if (colls.length > 0) {
    inheritCollectionDefaultPolicies(colls[0]);
  }
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + e.getEmail() + ""String_Node_Str""+ getID()));
}","/** 
 * Reinstate a withdrawn item
 */
public void reinstate() throws SQLException, AuthorizeException, IOException {
  String timestamp=DCDate.getCurrent().toString();
  String collectionProv=""String_Node_Str"";
  Collection[] colls=getCollections();
  for (int i=0; i < colls.length; i++) {
    collectionProv=collectionProv + colls[i].getMetadata(""String_Node_Str"") + ""String_Node_Str""+ colls[i].getID()+ ""String_Node_Str"";
    AuthorizeManager.authorizeAction(ourContext,colls[i],Constants.ADD);
  }
  itemRow.setColumn(""String_Node_Str"",false);
  itemRow.setColumn(""String_Node_Str"",true);
  EPerson e=ourContext.getCurrentUser();
  String prov=""String_Node_Str"" + e.getFullName() + ""String_Node_Str""+ e.getEmail()+ ""String_Node_Str""+ timestamp+ ""String_Node_Str""+ ""String_Node_Str""+ collectionProv+ InstallItem.getBitstreamProvenanceMessage(this);
  addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",prov);
  update();
  HistoryManager.saveHistory(ourContext,this,HistoryManager.MODIFY,e,ourContext.getExtraLogInfo());
  DSIndexer.indexContent(ourContext,this);
  if (colls.length > 0) {
    inheritCollectionDefaultPolicies(colls[0]);
  }
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + e.getEmail() + ""String_Node_Str""+ getID()));
}",0.9857747020376778
3628,"static String stripAsterisk(String myquery){
  Perl5Util util=new Perl5Util();
  myquery=util.substitute(""String_Node_Str"",myquery);
  myquery=util.substitute(""String_Node_Str"",myquery);
  return myquery;
}","static String stripAsterisk(String myquery){
  Perl5Util util=new Perl5Util();
  myquery=util.substitute(""String_Node_Str"",myquery);
  myquery=util.substitute(""String_Node_Str"",myquery);
  myquery=util.substitute(""String_Node_Str"",myquery);
  myquery=util.substitute(""String_Node_Str"",myquery);
  return myquery;
}",0.7923076923076923
3629,"/** 
 * Construct an item with the given table row
 * @param context  the context this object exists in
 * @param row      the corresponding row in the table
 */
Item(Context context,TableRow row) throws SQLException {
  ourContext=context;
  itemRow=row;
  dublinCoreChanged=false;
  dublinCore=new ArrayList();
  bundles=new ArrayList();
  submitter=null;
  if (!itemRow.isColumnNull(""String_Node_Str"")) {
    submitter=EPerson.find(ourContext,itemRow.getIntColumn(""String_Node_Str""));
  }
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow r=(TableRow)tri.next();
    Bundle fromCache=(Bundle)context.fromCache(Bundle.class,r.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      bundles.add(fromCache);
    }
 else {
      bundles.add(new Bundle(ourContext,r));
    }
  }
  tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow resultRow=(TableRow)tri.next();
    String[] dcType=DCType.quickFind(context,resultRow.getIntColumn(""String_Node_Str""));
    DCValue dcv=new DCValue();
    dcv.element=dcType[0];
    dcv.qualifier=dcType[1];
    dcv.value=resultRow.getStringColumn(""String_Node_Str"");
    dcv.language=resultRow.getStringColumn(""String_Node_Str"");
    dublinCore.add(dcv);
  }
  handle=HandleManager.findHandle(context,this);
  context.cache(this,row.getIntColumn(""String_Node_Str""));
}","/** 
 * Construct an item with the given table row
 * @param context  the context this object exists in
 * @param row      the corresponding row in the table
 */
Item(Context context,TableRow row) throws SQLException {
  ourContext=context;
  itemRow=row;
  dublinCoreChanged=false;
  dublinCore=new ArrayList();
  bundles=new ArrayList();
  submitter=null;
  if (!itemRow.isColumnNull(""String_Node_Str"")) {
    submitter=EPerson.find(ourContext,itemRow.getIntColumn(""String_Node_Str""));
  }
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow r=(TableRow)tri.next();
    Bundle fromCache=(Bundle)context.fromCache(Bundle.class,r.getIntColumn(""String_Node_Str""));
    if (fromCache != null) {
      bundles.add(fromCache);
    }
 else {
      bundles.add(new Bundle(ourContext,r));
    }
  }
  tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow resultRow=(TableRow)tri.next();
    String[] dcType=DCType.quickFind(context,resultRow.getIntColumn(""String_Node_Str""));
    DCValue dcv=new DCValue();
    dcv.element=dcType[0];
    dcv.qualifier=dcType[1];
    dcv.value=resultRow.getStringColumn(""String_Node_Str"");
    dcv.language=resultRow.getStringColumn(""String_Node_Str"");
    dublinCore.add(dcv);
  }
  itemRow.setColumn(""String_Node_Str"",new Date());
  handle=HandleManager.findHandle(context,this);
  context.cache(this,row.getIntColumn(""String_Node_Str""));
}",0.9845220030349012
3630,"protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.create(context);
    e.setEmail(""String_Node_Str"" + e.getID());
    e.update();
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    String oldEmail=e.getEmail();
    String newEmail=request.getParameter(""String_Node_Str"").trim();
    if (!newEmail.equals(oldEmail)) {
      if (EPerson.findByEmail(context,newEmail) == null) {
        e.setEmail(newEmail);
        e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.update();
        showMain(context,request,response);
        context.complete();
      }
 else {
        request.setAttribute(""String_Node_Str"",e);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        JSPManager.showJSP(request,response,""String_Node_Str"");
        context.complete();
      }
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    e.delete();
    showMain(context,request,response);
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    String pageRequest=request.getParameter(""String_Node_Str"");
    int pageIndex=UIUtil.getIntParameter(request,""String_Node_Str"");
    String sortby=request.getParameter(""String_Node_Str"");
    int sortField=EPerson.EMAIL;
    int pageSize=50;
    if (sortby == null) {
    }
 else     if (sortby.equals(""String_Node_Str"")) {
      sortField=EPerson.LASTNAME;
    }
 else     if (sortby.equals(""String_Node_Str"")) {
      sortField=EPerson.ID;
    }
    if (pageIndex == -1) {
      pageIndex=0;
    }
    if (pageRequest != null) {
      if (pageRequest.equals(""String_Node_Str"")) {
        pageIndex++;
      }
 else {
        pageIndex--;
      }
    }
    EPerson[] epeople=EPerson.findAll(context,sortField);
    int pageCount=((epeople.length - 1) / pageSize) + 1;
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",new Integer(pageSize));
    request.setAttribute(""String_Node_Str"",new Integer(pageCount));
    request.setAttribute(""String_Node_Str"",new Integer(pageIndex));
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showMain(context,request,response);
  }
}","protected void doDSPost(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.create(context);
    e.setEmail(""String_Node_Str"" + e.getID());
    e.update();
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    String oldEmail=e.getEmail();
    String newEmail=request.getParameter(""String_Node_Str"").trim();
    if (!newEmail.equals(oldEmail)) {
      if (EPerson.findByEmail(context,newEmail) == null) {
        e.setEmail(newEmail);
        e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
        e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
        e.update();
        showMain(context,request,response);
        context.complete();
      }
 else {
        request.setAttribute(""String_Node_Str"",e);
        request.setAttribute(""String_Node_Str"",""String_Node_Str"");
        JSPManager.showJSP(request,response,""String_Node_Str"");
        context.complete();
      }
    }
 else {
      e.setFirstName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setLastName(request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str"").equals(""String_Node_Str"") ? null : request.getParameter(""String_Node_Str""));
      e.setCanLogIn(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.setRequireCertificate(request.getParameter(""String_Node_Str"") != null && request.getParameter(""String_Node_Str"").equals(""String_Node_Str""));
      e.update();
      showMain(context,request,response);
      context.complete();
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    request.setAttribute(""String_Node_Str"",e);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    EPerson e=EPerson.find(context,UIUtil.getIntParameter(request,""String_Node_Str""));
    e.delete();
    showMain(context,request,response);
    context.complete();
  }
 else   if (button.equals(""String_Node_Str"")) {
    String pageRequest=request.getParameter(""String_Node_Str"");
    int pageIndex=UIUtil.getIntParameter(request,""String_Node_Str"");
    String sortby=request.getParameter(""String_Node_Str"");
    int sortField=EPerson.EMAIL;
    int pageSize=50;
    if (sortby == null) {
    }
 else     if (sortby.equals(""String_Node_Str"")) {
      sortField=EPerson.LASTNAME;
    }
 else     if (sortby.equals(""String_Node_Str"")) {
      sortField=EPerson.ID;
    }
    if (pageIndex == -1) {
      pageIndex=0;
    }
    if (pageRequest != null) {
      if (pageRequest.equals(""String_Node_Str"")) {
        pageIndex++;
      }
 else {
        pageIndex--;
      }
    }
    EPerson[] epeople=EPerson.findAll(context,sortField);
    int pageCount=((epeople.length - 1) / pageSize) + 1;
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",new Integer(pageSize));
    request.setAttribute(""String_Node_Str"",new Integer(pageCount));
    request.setAttribute(""String_Node_Str"",new Integer(pageIndex));
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showMain(context,request,response);
  }
}",0.9044838860345632
3631,"/** 
 * Create a new item, with a new internal ID.  This method is not public, since items need to be created as workspace items.  Authorisation is the responsibility of the caller.
 * @param context  DSpace context object
 * @return  the newly created item
 */
static Item create(Context context) throws SQLException {
  TableRow row=DatabaseManager.create(context,""String_Node_Str"");
  Item i=new Item(context,row);
  HistoryManager.saveHistory(context,i,HistoryManager.CREATE,context.getCurrentUser(),context.getExtraLogInfo());
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + row.getIntColumn(""String_Node_Str"")));
  return i;
}","/** 
 * Create a new item, with a new internal ID.  This method is not public, since items need to be created as workspace items.  Authorisation is the responsibility of the caller.
 * @param context  DSpace context object
 * @return  the newly created item
 */
static Item create(Context context) throws SQLException, AuthorizeException {
  TableRow row=DatabaseManager.create(context,""String_Node_Str"");
  Item i=new Item(context,row);
  i.update();
  HistoryManager.saveHistory(context,i,HistoryManager.CREATE,context.getCurrentUser(),context.getExtraLogInfo());
  log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + row.getIntColumn(""String_Node_Str"")));
  return i;
}",0.974963181148748
3632,"private void replaceItems(Context c,Collection mycollection,String sourceDir,String mapFile) throws Exception {
  HashMap myhash=readMapFile(mapFile);
  Iterator i=myhash.keySet().iterator();
  ArrayList itemsToDelete=new ArrayList();
  while (i.hasNext()) {
    String newItemName=(String)i.next();
    String oldHandle=(String)myhash.get(newItemName);
    System.out.println(""String_Node_Str"" + oldHandle);
    Item oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    Item newItem=addItem(c,mycollection,sourceDir,newItemName,null);
    String newHandle=HandleManager.findHandle(c,newItem);
    String myquery=""String_Node_Str"" + Constants.ITEM + ""String_Node_Str""+ newItem.getID();
    DatabaseManager.updateQuery(c,myquery);
    myquery=""String_Node_Str"" + newItem.getID() + ""String_Node_Str""+ oldHandle+ ""String_Node_Str"";
    DatabaseManager.updateQuery(c,myquery);
    itemsToDelete.add(oldItem);
  }
  i=itemsToDelete.iterator();
  while (i.hasNext()) {
    removeItem(c,(Item)i.next());
  }
}","private void replaceItems(Context c,Collection mycollection,String sourceDir,String mapFile) throws Exception {
  HashMap myhash=readMapFile(mapFile);
  Iterator i=myhash.keySet().iterator();
  ArrayList itemsToDelete=new ArrayList();
  while (i.hasNext()) {
    String newItemName=(String)i.next();
    String oldHandle=(String)myhash.get(newItemName);
    System.out.println(""String_Node_Str"" + oldHandle);
    Item oldItem=(Item)HandleManager.resolveToObject(c,oldHandle);
    Item newItem=addItem(c,mycollection,sourceDir,newItemName,oldHandle,null);
    itemsToDelete.add(oldItem);
  }
  i=itemsToDelete.iterator();
  while (i.hasNext()) {
    removeItem(c,(Item)i.next());
  }
}",0.6584070796460177
3633,"private Item addItem(Context c,Collection mycollection,String path,String itemname,PrintWriter mapOut) throws Exception {
  Item myitem=null;
  System.out.println(""String_Node_Str"" + itemname);
  WorkspaceItem wi=WorkspaceItem.create(c,mycollection,false);
  myitem=wi.getItem();
  loadDublinCore(c,myitem,path + ""String_Node_Str"" + itemname+ ""String_Node_Str""+ ""String_Node_Str"");
  processContentsFile(c,myitem,path + ""String_Node_Str"" + itemname,""String_Node_Str"");
  String myhandle=processHandleFile(c,myitem,path + ""String_Node_Str"" + itemname,""String_Node_Str"");
  InstallItem.installItem(c,wi,myhandle);
  myhandle=HandleManager.findHandle(c,myitem);
  if (mapOut != null) {
    mapOut.println(itemname + ""String_Node_Str"" + myhandle);
  }
  return myitem;
}","/** 
 * item?  try and add it to the archive c mycollection path itemname  handle - non-null means we have a pre-defined handle already mapOut - mapfile we're writing
 */
private Item addItem(Context c,Collection mycollection,String path,String itemname,String handle,PrintWriter mapOut) throws Exception {
  Item myitem=null;
  System.out.println(""String_Node_Str"" + itemname);
  WorkspaceItem wi=WorkspaceItem.create(c,mycollection,false);
  myitem=wi.getItem();
  loadDublinCore(c,myitem,path + ""String_Node_Str"" + itemname+ ""String_Node_Str""+ ""String_Node_Str"");
  processContentsFile(c,myitem,path + ""String_Node_Str"" + itemname,""String_Node_Str"");
  String myhandle=processHandleFile(c,myitem,path + ""String_Node_Str"" + itemname,""String_Node_Str"");
  InstallItem.installItem(c,wi,myhandle);
  myhandle=HandleManager.findHandle(c,myitem);
  if (mapOut != null) {
    mapOut.println(itemname + ""String_Node_Str"" + myhandle);
  }
  return myitem;
}",0.8899242865463017
3634,"private void addDCValue(Item i,Node n) throws TransformerException {
  String value=getStringValue(n);
  String element=getAttributeValue(n,""String_Node_Str"");
  String qualifier=getAttributeValue(n,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + element + ""String_Node_Str""+ qualifier+ ""String_Node_Str""+ value);
  if (qualifier.equals(""String_Node_Str""))   qualifier=null;
  i.addDC(element,qualifier,""String_Node_Str"",value);
}","private void addDCValue(Item i,Node n) throws TransformerException {
  String value=getStringValue(n);
  String element=getAttributeValue(n,""String_Node_Str"");
  String qualifier=getAttributeValue(n,""String_Node_Str"");
  String language=getAttributeValue(n,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + element + ""String_Node_Str""+ qualifier+ ""String_Node_Str""+ value);
  if (qualifier.equals(""String_Node_Str""))   qualifier=null;
  if (language.equals(""String_Node_Str"")) {
    language=ConfigurationManager.getProperty(""String_Node_Str"");
  }
  if (language == null) {
    language=""String_Node_Str"";
  }
  i.addDC(element,qualifier,language,value);
}",0.7668766876687669
3635,"private void addItems(Context c,Collection mycollection,String sourceDir,String mapFile) throws Exception {
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=new File(mapFile);
  PrintWriter mapOut=new PrintWriter(new FileWriter(outFile));
  String[] dircontents=new java.io.File(sourceDir).list();
  for (int i=0; i < dircontents.length; i++) {
    addItem(c,mycollection,sourceDir,dircontents[i],mapOut);
    System.out.println(i + ""String_Node_Str"" + dircontents[i]);
  }
  mapOut.close();
}","private void addItems(Context c,Collection mycollection,String sourceDir,String mapFile) throws Exception {
  System.out.println(""String_Node_Str"" + sourceDir);
  System.out.println(""String_Node_Str"" + mapFile);
  File outFile=new File(mapFile);
  PrintWriter mapOut=new PrintWriter(new FileWriter(outFile));
  String[] dircontents=new java.io.File(sourceDir).list();
  for (int i=0; i < dircontents.length; i++) {
    addItem(c,mycollection,sourceDir,dircontents[i],null,mapOut);
    System.out.println(i + ""String_Node_Str"" + dircontents[i]);
  }
  mapOut.close();
}",0.995579133510168
3636,"/** 
 * Create a new workspace item, with a new ID.  An Item is also created.  The submitter is the current user in the context.
 * @param context   DSpace context object
 * @param coll      Collection being submitted to
 * @param template  if <code>true</code>, the workspace item starts as a copy of the collection's template item
 * @return  the newly created workspace item
 */
public static WorkspaceItem create(Context c,Collection coll,boolean template) throws AuthorizeException, SQLException {
  AuthorizeManager.authorizeAction(c,coll,Constants.ADD);
  Item i=Item.create(c);
  i.setSubmitter(c.getCurrentUser());
  Group step1group=coll.getWorkflowGroup(1);
  Group step2group=coll.getWorkflowGroup(2);
  Group step3group=coll.getWorkflowGroup(3);
  EPerson e=c.getCurrentUser();
  AuthorizeManager.addPolicy(c,i,Constants.READ,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.WRITE,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.ADD,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.REMOVE,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step3group);
  Item templateItem=coll.getTemplateItem();
  if (template && templateItem != null) {
    DCValue[] dc=templateItem.getDC(Item.ANY,Item.ANY,Item.ANY);
    for (int n=0; n < dc.length; n++) {
      i.addDC(dc[n].element,dc[n].qualifier,dc[n].language,dc[n].value);
    }
  }
 else {
    i.addDC(""String_Node_Str"",""String_Node_Str"",null,ConfigurationManager.getProperty(""String_Node_Str""));
  }
  i.update();
  TableRow row=DatabaseManager.create(c,""String_Node_Str"");
  row.setColumn(""String_Node_Str"",i.getID());
  row.setColumn(""String_Node_Str"",coll.getID());
  log.info(LogManager.getHeader(c,""String_Node_Str"",""String_Node_Str"" + row.getIntColumn(""String_Node_Str"") + ""String_Node_Str""+ i.getID()+ ""String_Node_Str""+ coll.getID()));
  DatabaseManager.update(c,row);
  WorkspaceItem wi=new WorkspaceItem(c,row);
  HistoryManager.saveHistory(c,wi,HistoryManager.CREATE,c.getCurrentUser(),c.getExtraLogInfo());
  return wi;
}","/** 
 * Create a new workspace item, with a new ID.  An Item is also created.  The submitter is the current user in the context.
 * @param context   DSpace context object
 * @param coll      Collection being submitted to
 * @param template  if <code>true</code>, the workspace item starts as a copy of the collection's template item
 * @return  the newly created workspace item
 */
public static WorkspaceItem create(Context c,Collection coll,boolean template) throws AuthorizeException, SQLException {
  AuthorizeManager.authorizeAction(c,coll,Constants.ADD);
  Item i=Item.create(c);
  i.setSubmitter(c.getCurrentUser());
  Group step1group=coll.getWorkflowGroup(1);
  Group step2group=coll.getWorkflowGroup(2);
  Group step3group=coll.getWorkflowGroup(3);
  EPerson e=c.getCurrentUser();
  AuthorizeManager.addPolicy(c,i,Constants.READ,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.READ,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.WRITE,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.WRITE,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.ADD,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.ADD,step3group);
  AuthorizeManager.addPolicy(c,i,Constants.REMOVE,e);
  if (step1group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step1group);
  if (step2group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step2group);
  if (step3group != null)   AuthorizeManager.addPolicy(c,i,Constants.REMOVE,step3group);
  Item templateItem=coll.getTemplateItem();
  if (template && templateItem != null) {
    DCValue[] dc=templateItem.getDC(Item.ANY,Item.ANY,Item.ANY);
    for (int n=0; n < dc.length; n++) {
      i.addDC(dc[n].element,dc[n].qualifier,dc[n].language,dc[n].value);
    }
  }
 else {
  }
  i.update();
  TableRow row=DatabaseManager.create(c,""String_Node_Str"");
  row.setColumn(""String_Node_Str"",i.getID());
  row.setColumn(""String_Node_Str"",coll.getID());
  log.info(LogManager.getHeader(c,""String_Node_Str"",""String_Node_Str"" + row.getIntColumn(""String_Node_Str"") + ""String_Node_Str""+ i.getID()+ ""String_Node_Str""+ coll.getID()));
  DatabaseManager.update(c,row);
  WorkspaceItem wi=new WorkspaceItem(c,row);
  HistoryManager.saveHistory(c,wi,HistoryManager.CREATE,c.getCurrentUser(),c.getExtraLogInfo());
  return wi;
}",0.9817000171027878
3637,"private static void recordApproval(Context c,WorkflowItem wi,EPerson e) throws SQLException, AuthorizeException {
  Item item=wi.getItem();
  String usersName=getEPersonName(e);
  String now=DCDate.getCurrent().toString();
  String provDescription=""String_Node_Str"" + usersName + ""String_Node_Str""+ now+ ""String_Node_Str"";
  provDescription+=InstallItem.getBitstreamProvenanceMessage(item);
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,provDescription);
  item.update();
}","private static void recordApproval(Context c,WorkflowItem wi,EPerson e) throws SQLException, AuthorizeException {
  Item item=wi.getItem();
  String usersName=getEPersonName(e);
  String now=DCDate.getCurrent().toString();
  String provDescription=""String_Node_Str"" + usersName + ""String_Node_Str""+ now+ ""String_Node_Str"";
  provDescription+=InstallItem.getBitstreamProvenanceMessage(item);
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  item.update();
}",0.9251282051282051
3638,"/** 
 * rejects an item - rejection means undoing a submit - WorkspaceItem is created, and the WorkflowItem is removed, user is emailed rejection_message.
 * @param c  Context
 * @param wi WorkflowItem to operate on
 * @param e  EPerson doing the operation
 * @param rejection_message message to email to user
 */
public static WorkspaceItem reject(Context c,WorkflowItem wi,EPerson e,String rejection_message) throws SQLException, AuthorizeException, IOException {
  deleteTasks(c,wi);
  Item myitem=wi.getItem();
  String now=DCDate.getCurrent().toString();
  String usersName=getEPersonName(e);
  String provDescription=""String_Node_Str"" + usersName + ""String_Node_Str""+ rejection_message+ ""String_Node_Str""+ now+ ""String_Node_Str"";
  myitem.addDC(""String_Node_Str"",""String_Node_Str"",null,provDescription);
  myitem.update();
  WorkspaceItem wsi=returnToWorkspace(c,wi);
  notifyOfReject(c,wi,e,rejection_message);
  log.info(LogManager.getHeader(c,""String_Node_Str"",""String_Node_Str"" + wi.getID() + ""String_Node_Str""+ wi.getItem().getID()+ ""String_Node_Str""+ wi.getCollection().getID()+ ""String_Node_Str""+ e.getID()));
  return wsi;
}","/** 
 * rejects an item - rejection means undoing a submit - WorkspaceItem is created, and the WorkflowItem is removed, user is emailed rejection_message.
 * @param c  Context
 * @param wi WorkflowItem to operate on
 * @param e  EPerson doing the operation
 * @param rejection_message message to email to user
 */
public static WorkspaceItem reject(Context c,WorkflowItem wi,EPerson e,String rejection_message) throws SQLException, AuthorizeException, IOException {
  deleteTasks(c,wi);
  Item myitem=wi.getItem();
  String now=DCDate.getCurrent().toString();
  String usersName=getEPersonName(e);
  String provDescription=""String_Node_Str"" + usersName + ""String_Node_Str""+ rejection_message+ ""String_Node_Str""+ now+ ""String_Node_Str"";
  myitem.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  myitem.update();
  WorkspaceItem wsi=returnToWorkspace(c,wi);
  notifyOfReject(c,wi,e,rejection_message);
  log.info(LogManager.getHeader(c,""String_Node_Str"",""String_Node_Str"" + wi.getID() + ""String_Node_Str""+ wi.getItem().getID()+ ""String_Node_Str""+ wi.getCollection().getID()+ ""String_Node_Str""+ e.getID()));
  return wsi;
}",0.9908256880733946
3639,"public String buildQuery(HttpServletRequest request){
  String newquery=""String_Node_Str"";
  String query1=request.getParameter(""String_Node_Str"");
  String query2=request.getParameter(""String_Node_Str"");
  String query3=request.getParameter(""String_Node_Str"");
  String field1=request.getParameter(""String_Node_Str"");
  String field2=request.getParameter(""String_Node_Str"");
  String field3=request.getParameter(""String_Node_Str"");
  String conjunction1=request.getParameter(""String_Node_Str"");
  String conjunction2=request.getParameter(""String_Node_Str"");
  if (query1.length() > 0) {
    if (!field1.equals(""String_Node_Str"")) {
      newquery=newquery + field1 + ""String_Node_Str"";
    }
    newquery=newquery + '""' + query1+ '""';
  }
  if (query2.length() > 0) {
    newquery=newquery + ""String_Node_Str"" + conjunction1+ ""String_Node_Str"";
    if (!field2.equals(""String_Node_Str"")) {
      newquery=newquery + field2 + ""String_Node_Str"";
    }
    newquery=newquery + '""' + query2+ '""';
  }
  newquery=newquery + ""String_Node_Str"";
  if (query3.length() > 0) {
    newquery=newquery + ""String_Node_Str"" + conjunction2+ ""String_Node_Str"";
    if (!field3.equals(""String_Node_Str"")) {
      newquery=newquery + field3 + ""String_Node_Str"";
    }
    newquery=newquery + ""String_Node_Str"" + query3+ ""String_Node_Str"";
  }
  return (newquery);
}","public String buildQuery(HttpServletRequest request){
  String newquery=""String_Node_Str"";
  String query1=request.getParameter(""String_Node_Str"");
  String query2=request.getParameter(""String_Node_Str"");
  String query3=request.getParameter(""String_Node_Str"");
  String field1=request.getParameter(""String_Node_Str"");
  String field2=request.getParameter(""String_Node_Str"");
  String field3=request.getParameter(""String_Node_Str"");
  String conjunction1=request.getParameter(""String_Node_Str"");
  String conjunction2=request.getParameter(""String_Node_Str"");
  if (query1.length() > 0) {
    newquery=newquery + buildQueryPart(query1,field1);
  }
  if (query2.length() > 0) {
    newquery=newquery + ""String_Node_Str"" + conjunction1+ ""String_Node_Str"";
    newquery=newquery + buildQueryPart(query2,field2);
  }
  newquery=newquery + ""String_Node_Str"";
  if (query3.length() > 0) {
    newquery=newquery + ""String_Node_Str"" + conjunction2+ ""String_Node_Str"";
    newquery=newquery + buildQueryPart(query3,field3);
  }
  return (newquery);
}",0.611646418098031
3640,"/** 
 * Delete the collection, including the metadata and logo.  Items that are then orphans are deleted. Groups associated with this collection (workflow participants and submitters) are NOT deleted.
 */
void delete() throws SQLException, AuthorizeException, IOException {
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  DSIndexer.unIndexContent(ourContext,this);
  ourContext.removeCached(this,getID());
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  ItemIterator items=getItems();
  while (items.hasNext()) {
    removeItem(items.next());
  }
  setLogo(null);
  DatabaseManager.delete(ourContext,collectionRow);
  AuthorizeManager.removeAllPolicies(ourContext,this);
  Group g=null;
  g=getWorkflowGroup(1);
  if (g != null) {
    g.delete();
  }
  g=getWorkflowGroup(2);
  if (g != null) {
    g.delete();
  }
  g=getWorkflowGroup(3);
  if (g != null) {
    g.delete();
  }
}","/** 
 * Delete the collection, including the metadata and logo.  Items that are then orphans are deleted. Groups associated with this collection (workflow participants and submitters) are NOT deleted.
 */
void delete() throws SQLException, AuthorizeException, IOException {
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  DSIndexer.unIndexContent(ourContext,this);
  ourContext.removeCached(this,getID());
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  ItemIterator items=getItems();
  while (items.hasNext()) {
    removeItem(items.next());
  }
  setLogo(null);
  AuthorizeManager.removeAllPolicies(ourContext,this);
  WorkflowItem[] wfarray=WorkflowItem.findByCollection(ourContext,this);
  for (int x=0; x < wfarray.length; x++) {
    Item myItem=wfarray[x].getItem();
    wfarray[x].deleteWrapper();
    myItem.delete();
  }
  WorkspaceItem[] wsarray=WorkspaceItem.findByCollection(ourContext,this);
  for (int x=0; x < wsarray.length; x++) {
    wsarray[x].deleteAll();
  }
  DatabaseManager.delete(ourContext,collectionRow);
  Group g=null;
  g=getWorkflowGroup(1);
  if (g != null) {
    g.delete();
  }
  g=getWorkflowGroup(2);
  if (g != null) {
    g.delete();
  }
  g=getWorkflowGroup(3);
  if (g != null) {
    g.delete();
  }
}",0.8015170670037927
3641,"/** 
 * delete the WorkflowItem, retaining the Item
 */
public void deleteWrapper() throws SQLException, IOException, AuthorizeException {
  ourContext.removeCached(this,getID());
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  DatabaseManager.delete(ourContext,wfRow);
}","/** 
 * delete the WorkflowItem, retaining the Item
 */
public void deleteWrapper() throws SQLException, IOException, AuthorizeException {
  ourContext.removeCached(this,getID());
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  WorkflowManager.deleteTasks(ourContext,this);
  DatabaseManager.delete(ourContext,wfRow);
}",0.936
3642,"private static void deleteTasks(Context c,WorkflowItem wi) throws SQLException {
  String myrequest=""String_Node_Str"" + wi.getID();
  DatabaseManager.updateQuery(c,myrequest);
}","static void deleteTasks(Context c,WorkflowItem wi) throws SQLException {
  String myrequest=""String_Node_Str"" + wi.getID();
  DatabaseManager.updateQuery(c,myrequest);
}",0.976878612716763
3643,"protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    request.setAttribute(""String_Node_Str"",collections);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community[] communities=Community.findAll(c);
    request.setAttribute(""String_Node_Str"",communities);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    Group[] groups=Group.findAll(c,Group.NAME);
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",groups);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=null;
    int item_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String handle=request.getParameter(""String_Node_Str"");
    if (item_id > 0) {
      item=Item.find(c,item_id);
    }
 else     if (handle != null && !handle.equals(""String_Node_Str"")) {
      DSpaceObject dso=HandleManager.resolveToObject(c,handle);
      if (dso != null && dso.getType() != Constants.ITEM) {
        item=(Item)dso;
      }
    }
    if (item == null) {
      request.setAttribute(""String_Node_Str"",new Boolean(true));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      List item_policies=AuthorizeManager.getPolicies(c,item);
      request.setAttribute(""String_Node_Str"",item);
      request.setAttribute(""String_Node_Str"",item_policies);
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=Item.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(item);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + item.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + item.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=Item.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",item);
    List item_policies=AuthorizeManager.getPolicies(c,item);
    request.setAttribute(""String_Node_Str"",item_policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(collection);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community target=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,target);
    request.setAttribute(""String_Node_Str"",target);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",collection);
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",community);
    List policies=AuthorizeManager.getPolicies(c,community);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.setResource(collection);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.setResource(community);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(collection);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(community);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int item_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    Item item=null;
    Collection collection=null;
    Community community=null;
    String display_page=null;
    ResourcePolicy policy=ResourcePolicy.find(c,policy_id);
    Group group=Group.find(c,group_id);
    if (collection_id != -1) {
      collection=Collection.find(c,collection_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,collection,Constants.READ);
        Bitstream bs=collection.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",collection);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,collection));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      community=Community.find(c,community_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,community,Constants.READ);
        Bitstream bs=community.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,community));
      display_page=""String_Node_Str"";
    }
 else     if (item_id != -1) {
      item=Item.find(c,item_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      request.setAttribute(""String_Node_Str"",item);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,item));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String display_page=null;
    if (collection_id != -1) {
      Collection t=Collection.find(c,collection_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      Community t=Community.find(c,community_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,0,0,false,true);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,0,0,false,true);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,action_id,group_id,false,false);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,action_id,group_id,false,false);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showMainPage(c,request,response);
  }
  c.complete();
}","protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    request.setAttribute(""String_Node_Str"",collections);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community[] communities=Community.findAll(c);
    request.setAttribute(""String_Node_Str"",communities);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    Group[] groups=Group.findAll(c,Group.NAME);
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",groups);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=null;
    int item_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String handle=request.getParameter(""String_Node_Str"");
    if (item_id > 0) {
      item=Item.find(c,item_id);
    }
 else     if (handle != null && !handle.equals(""String_Node_Str"")) {
      DSpaceObject dso=HandleManager.resolveToObject(c,handle);
      if (dso != null && dso.getType() == Constants.ITEM) {
        item=(Item)dso;
      }
    }
    if (item == null) {
      request.setAttribute(""String_Node_Str"",new Boolean(true));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      List item_policies=AuthorizeManager.getPolicies(c,item);
      request.setAttribute(""String_Node_Str"",item);
      request.setAttribute(""String_Node_Str"",item_policies);
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=Item.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(item);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + item.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + item.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item item=Item.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",item);
    List item_policies=AuthorizeManager.getPolicies(c,item);
    request.setAttribute(""String_Node_Str"",item_policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(collection);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community target=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,target);
    request.setAttribute(""String_Node_Str"",target);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",collection);
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",community);
    List policies=AuthorizeManager.getPolicies(c,community);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.setResource(collection);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.setResource(community);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(collection);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.setResource(community);
    policy.update();
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int item_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    Item item=null;
    Collection collection=null;
    Community community=null;
    String display_page=null;
    ResourcePolicy policy=ResourcePolicy.find(c,policy_id);
    Group group=Group.find(c,group_id);
    if (collection_id != -1) {
      collection=Collection.find(c,collection_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,collection,Constants.READ);
        Bitstream bs=collection.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",collection);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,collection));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      community=Community.find(c,community_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,community,Constants.READ);
        Bitstream bs=community.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,community));
      display_page=""String_Node_Str"";
    }
 else     if (item_id != -1) {
      item=Item.find(c,item_id);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      request.setAttribute(""String_Node_Str"",item);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,item));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String display_page=null;
    if (collection_id != -1) {
      Collection t=Collection.find(c,collection_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      Community t=Community.find(c,community_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,0,0,false,true);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,0,0,false,true);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,action_id,group_id,false,false);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,action_id,group_id,false,false);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showMainPage(c,request,response);
  }
  c.complete();
}",0.9999276881914816
3644,"/** 
 * Create an empty template item for this collection.  If one already exists, no action is taken.  Caution:  Make sure you call <code>update</code> on the collection after doing this, or the item will have been created but the collection record will not refer to it.
 */
public void createTemplateItem() throws SQLException, AuthorizeException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (template == null) {
    template=Item.create(ourContext);
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str""+ template.getID()));
  }
}","/** 
 * Create an empty template item for this collection.  If one already exists, no action is taken.  Caution:  Make sure you call <code>update</code> on the collection after doing this, or the item will have been created but the collection record will not refer to it.
 */
public void createTemplateItem() throws SQLException, AuthorizeException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.WRITE);
  if (template == null) {
    template=Item.create(ourContext);
    collectionRow.setColumn(""String_Node_Str"",template.getID());
    log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID() + ""String_Node_Str""+ template.getID()));
  }
}",0.8171384850803366
3645,"/** 
 * Take an InProgressSubmission and turn it into a fully-archived Item.
 * @param Context
 * @param InProgressSubmission
 * @param EPerson (unused, should be removed from API) 
 */
public static Item installItem(Context c,InProgressSubmission is,EPerson e2) throws SQLException, IOException, AuthorizeException {
  Item item=is.getItem();
  DCDate now=DCDate.getCurrent();
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  DCValue[] currentDateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (currentDateIssued.length == 0) {
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  }
  String handle=HandleManager.createHandle(c,item);
  String handleref=HandleManager.getCanonicalForm(handle);
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,handleref);
  Bitstream[] bitstreams=item.getNonInternalBitstreams();
  for (int i=0; i < bitstreams.length; i++) {
    BitstreamFormat bf=bitstreams[i].getFormat();
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,String.valueOf(bitstreams[i].getSize()));
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,bf.getMIMEType());
  }
  String provDescription=""String_Node_Str"" + now + ""String_Node_Str""+ getBitstreamProvenanceMessage(item);
  if (currentDateIssued.length != 0) {
    DCDate d=new DCDate(currentDateIssued[0].value);
    provDescription=provDescription + ""String_Node_Str"" + d.toString();
  }
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  is.getCollection().addItem(item);
  item.setArchived(true);
  item.update();
  DSIndexer.indexContent(c,item);
  is.deleteWrapper();
  List policies=AuthorizeManager.getPoliciesActionFilter(c,is.getCollection(),Constants.READ);
  item.replaceAllPolicies(policies);
  return item;
}","/** 
 * Take an InProgressSubmission and turn it into a fully-archived Item.
 * @param Context
 * @param InProgressSubmission
 * @param EPerson (unused, should be removed from API) 
 */
public static Item installItem(Context c,InProgressSubmission is,EPerson e2) throws SQLException, IOException, AuthorizeException {
  Item item=is.getItem();
  DCDate now=DCDate.getCurrent();
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  DCValue[] currentDateIssued=item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
  if (currentDateIssued.length == 0) {
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,now.toString());
  }
  String handle=HandleManager.createHandle(c,item);
  String handleref=HandleManager.getCanonicalForm(handle);
  item.addDC(""String_Node_Str"",""String_Node_Str"",null,handleref);
  Bitstream[] bitstreams=item.getNonInternalBitstreams();
  for (int i=0; i < bitstreams.length; i++) {
    BitstreamFormat bf=bitstreams[i].getFormat();
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,String.valueOf(bitstreams[i].getSize()) + ""String_Node_Str"");
    item.addDC(""String_Node_Str"",""String_Node_Str"",null,bf.getMIMEType());
  }
  String provDescription=""String_Node_Str"" + now + ""String_Node_Str""+ getBitstreamProvenanceMessage(item);
  if (currentDateIssued.length != 0) {
    DCDate d=new DCDate(currentDateIssued[0].value);
    provDescription=provDescription + ""String_Node_Str"" + d.toString();
  }
  item.addDC(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",provDescription);
  is.getCollection().addItem(item);
  item.setArchived(true);
  item.update();
  DSIndexer.indexContent(c,item);
  is.deleteWrapper();
  List policies=AuthorizeManager.getPoliciesActionFilter(c,is.getCollection(),Constants.READ);
  item.replaceAllPolicies(policies);
  return item;
}",0.9946949602122016
3646,"/** 
 * Return the file corresponding to ID, or null.
 * @param bitstream  the table row for the bitstream
 * @return The file corresponding to ID, or null
 * @exception IOException If a problem occurs while determining the file
 */
private static File getFile(TableRow bitstream) throws IOException {
  int storeNumber=bitstream.getIntColumn(""String_Node_Str"");
  if (storeNumber == -1) {
    storeNumber=0;
  }
  File store=assetStores[storeNumber];
  String id=bitstream.getStringColumn(""String_Node_Str"");
  BigInteger bigint=new BigInteger(id);
  StringBuffer result=new StringBuffer().append(store.getCanonicalPath());
  for (int i=0; i < directoryLevels; i++) {
    int digits=i * digitsPerLevel;
    result.append(File.separator).append(id.substring(digits,digits + digitsPerLevel));
  }
  String theName=result.append(File.separator).append(id).toString();
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + id + ""String_Node_Str""+ theName);
  return new File(theName);
}","/** 
 * Return the file corresponding to a bitstream.  It's safe to pass in <code>null</code>.
 * @param bitstream  the database table row for the bitstream.Can be <code>null</code>
 * @return  The corresponding file in the file system, or <code>null</code>
 * @exception IOException If a problem occurs while determining the file
 */
private static File getFile(TableRow bitstream) throws IOException {
  if (bitstream == null) {
    return null;
  }
  int storeNumber=bitstream.getIntColumn(""String_Node_Str"");
  if (storeNumber == -1) {
    storeNumber=0;
  }
  File store=assetStores[storeNumber];
  String id=bitstream.getStringColumn(""String_Node_Str"");
  BigInteger bigint=new BigInteger(id);
  StringBuffer result=new StringBuffer().append(store.getCanonicalPath());
  for (int i=0; i < directoryLevels; i++) {
    int digits=i * digitsPerLevel;
    result.append(File.separator).append(id.substring(digits,digits + digitsPerLevel));
  }
  String theName=result.append(File.separator).append(id).toString();
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + id + ""String_Node_Str""+ theName);
  return new File(theName);
}",0.893796992481203
3647,"/** 
 * Return the index of the first non-whitespace character in the character array, starting at position STARTAT.
 */
private static int firstWhitespace(char[] title,int startAt){
  int first=0;
  for (int j=startAt; j < title.length; j++) {
    if (Character.isWhitespace(title[j])) {
      first=j + 1;
      continue;
    }
    break;
  }
  return first;
}","/** 
 * Return the index of the first letter or number in the character array, starting at position STARTAT.
 */
private static int firstWhitespace(char[] title,int startAt){
  int first=0;
  for (int j=startAt; j < title.length; j++) {
    if (!Character.isLetterOrDigit(title[j])) {
      first=j + 1;
      continue;
    }
    break;
  }
  return first;
}",0.9166666666666666
3648,"/** 
 * Create/update collection metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community the collection is in
 * @param collection  the collection to update (or null for creation)
 */
private void processConfirmEditCollection(Context context,HttpServletRequest request,HttpServletResponse response,Community community,Collection collection) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    collection=community.createCollection();
    request.setAttribute(""String_Node_Str"",collection);
  }
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  String license=request.getParameter(""String_Node_Str"");
  if (license.equals(""String_Node_Str"")) {
    license=null;
  }
  String provenance=request.getParameter(""String_Node_Str"");
  if (provenance.equals(""String_Node_Str"")) {
    provenance=null;
  }
  collection.setMetadata(""String_Node_Str"",intro);
  collection.setMetadata(""String_Node_Str"",copy);
  collection.setMetadata(""String_Node_Str"",side);
  collection.setMetadata(""String_Node_Str"",license);
  collection.setMetadata(""String_Node_Str"",provenance);
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group newGroup=Group.create(context);
    newGroup.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str""+ step);
    newGroup.update();
    collection.setWorkflowGroup(step,newGroup);
    collection.update();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + newGroup.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(15));
    Group g=collection.getWorkflowGroup(step);
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + g.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group g=collection.getWorkflowGroup(step);
    collection.setWorkflowGroup(step,null);
    collection.update();
    g.delete();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.createTemplateItem();
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.removeTemplateItem();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  collection.update();
  context.complete();
}","/** 
 * Create/update collection metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community the collection is in
 * @param collection  the collection to update (or null for creation)
 */
private void processConfirmEditCollection(Context context,HttpServletRequest request,HttpServletResponse response,Community community,Collection collection) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    collection=community.createCollection();
    request.setAttribute(""String_Node_Str"",collection);
  }
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  String license=request.getParameter(""String_Node_Str"");
  if (license.equals(""String_Node_Str"")) {
    license=null;
  }
  String provenance=request.getParameter(""String_Node_Str"");
  if (provenance.equals(""String_Node_Str"")) {
    provenance=null;
  }
  collection.setMetadata(""String_Node_Str"",intro);
  collection.setMetadata(""String_Node_Str"",copy);
  collection.setMetadata(""String_Node_Str"",side);
  collection.setMetadata(""String_Node_Str"",license);
  collection.setMetadata(""String_Node_Str"",provenance);
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group newGroup=Group.create(context);
    newGroup.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str""+ step);
    newGroup.update();
    collection.setWorkflowGroup(step,newGroup);
    collection.update();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + newGroup.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(15));
    Group g=collection.getWorkflowGroup(step);
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + g.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group g=collection.getWorkflowGroup(step);
    collection.setWorkflowGroup(step,null);
    collection.update();
    g.delete();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.createTemplateItem();
    Item i=collection.getTemplateItem();
    collection.update();
    context.complete();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
    return;
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.removeTemplateItem();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  collection.update();
  context.complete();
}",0.992121916569805
3649,"/** 
 * List bitstreams in the item
 */
private void listBitstreams() throws IOException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.print(""String_Node_Str"");
  out.println(""String_Node_Str"");
  Bundle[] bundles=item.getBundles();
  if (bundles.length == 0) {
    out.println(""String_Node_Str"");
  }
 else {
    out.println(""String_Node_Str"");
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int k=0; k < bitstreams.length; k++) {
        if (!bitstreams[k].getFormat().isInternal()) {
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getName());
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getSize() / 1024);
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getFormatDescription());
          out.print(""String_Node_Str"");
          out.print(request.getContextPath());
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getID() + ""String_Node_Str"");
          out.print(URLEncoder.encode(bitstreams[k].getName()));
          out.print(""String_Node_Str"");
        }
      }
    }
    out.println(""String_Node_Str"");
  }
  out.println(""String_Node_Str"");
}","/** 
 * List bitstreams in the item
 */
private void listBitstreams() throws IOException {
  JspWriter out=pageContext.getOut();
  HttpServletRequest request=(HttpServletRequest)pageContext.getRequest();
  out.print(""String_Node_Str"");
  out.println(""String_Node_Str"");
  Bundle[] bundles=item.getBundles();
  if (bundles.length == 0) {
    out.println(""String_Node_Str"");
  }
 else {
    boolean multiFile=(bundles.length > 2);
    out.println(""String_Node_Str"");
    if (multiFile) {
      out.println(""String_Node_Str"");
    }
    out.println(""String_Node_Str"");
    for (int i=0; i < bundles.length; i++) {
      Bitstream[] bitstreams=bundles[i].getBitstreams();
      for (int k=0; k < bitstreams.length; k++) {
        if (!bitstreams[k].getFormat().isInternal()) {
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getName());
          if (multiFile) {
            out.print(""String_Node_Str"");
            String desc=bitstreams[k].getDescription();
            out.print(desc != null ? desc : ""String_Node_Str"");
          }
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getSize() / 1024);
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getFormatDescription());
          out.print(""String_Node_Str"");
          out.print(request.getContextPath());
          out.print(""String_Node_Str"");
          out.print(bitstreams[k].getID() + ""String_Node_Str"");
          out.print(URLEncoder.encode(bitstreams[k].getName()));
          out.print(""String_Node_Str"");
        }
      }
    }
    out.println(""String_Node_Str"");
  }
  out.println(""String_Node_Str"");
}",0.8826322930800543
3650,"/** 
 * Create/update collection metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community the collection is in
 * @param collection  the collection to update (or null for creation)
 */
private void processConfirmEditCollection(Context context,HttpServletRequest request,HttpServletResponse response,Community community,Collection collection) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    collection=community.createCollection();
    request.setAttribute(""String_Node_Str"",collection);
  }
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  String license=request.getParameter(""String_Node_Str"");
  if (license.equals(""String_Node_Str"")) {
    license=null;
  }
  String provenance=request.getParameter(""String_Node_Str"");
  if (provenance.equals(""String_Node_Str"")) {
    provenance=null;
  }
  collection.setMetadata(""String_Node_Str"",intro);
  collection.setMetadata(""String_Node_Str"",copy);
  collection.setMetadata(""String_Node_Str"",side);
  collection.setMetadata(""String_Node_Str"",license);
  collection.setMetadata(""String_Node_Str"",license);
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group newGroup=Group.create(context);
    newGroup.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str""+ step);
    newGroup.update();
    collection.setWorkflowGroup(step,newGroup);
    collection.update();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + newGroup.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(15));
    Group g=collection.getWorkflowGroup(step);
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + g.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group g=collection.getWorkflowGroup(step);
    collection.setWorkflowGroup(step,null);
    collection.update();
    g.delete();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.createTemplateItem();
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.removeTemplateItem();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  collection.update();
  context.complete();
}","/** 
 * Create/update collection metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community the collection is in
 * @param collection  the collection to update (or null for creation)
 */
private void processConfirmEditCollection(Context context,HttpServletRequest request,HttpServletResponse response,Community community,Collection collection) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    collection=community.createCollection();
    request.setAttribute(""String_Node_Str"",collection);
  }
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  collection.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  String license=request.getParameter(""String_Node_Str"");
  if (license.equals(""String_Node_Str"")) {
    license=null;
  }
  String provenance=request.getParameter(""String_Node_Str"");
  if (provenance.equals(""String_Node_Str"")) {
    provenance=null;
  }
  collection.setMetadata(""String_Node_Str"",intro);
  collection.setMetadata(""String_Node_Str"",copy);
  collection.setMetadata(""String_Node_Str"",side);
  collection.setMetadata(""String_Node_Str"",license);
  collection.setMetadata(""String_Node_Str"",provenance);
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.setLogo(null);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group newGroup=Group.create(context);
    newGroup.setName(""String_Node_Str"" + collection.getID() + ""String_Node_Str""+ step);
    newGroup.update();
    collection.setWorkflowGroup(step,newGroup);
    collection.update();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + newGroup.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(15));
    Group g=collection.getWorkflowGroup(step);
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + g.getID()));
  }
 else   if (button.startsWith(""String_Node_Str"")) {
    int step=Integer.parseInt(button.substring(17));
    Group g=collection.getWorkflowGroup(step);
    collection.setWorkflowGroup(step,null);
    collection.update();
    g.delete();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.createTemplateItem();
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    Item i=collection.getTemplateItem();
    response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + ""String_Node_Str"" + i.getID()));
  }
 else   if (button.equals(""String_Node_Str"")) {
    collection.removeTemplateItem();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  collection.update();
  context.complete();
}",0.998046620653731
3651,"/** 
 * Process information from ""Personal information page""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processPersonalInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String token=request.getParameter(""String_Node_Str"");
  String email=AccountManager.getEmail(context,token);
  if (email == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + token));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  EPerson eperson=EPerson.findByEmail(context,email);
  if (eperson == null) {
    context.setIgnoreAuthorization(true);
    eperson=EPerson.create(context);
    eperson.setEmail(email);
    eperson.update();
    context.setIgnoreAuthorization(false);
  }
  context.setCurrentUser(eperson);
  boolean infoOK=EditProfileServlet.updateUserProfile(eperson,request);
  eperson.setCanLogIn(true);
  eperson.setSelfRegistered(true);
  Authenticate.getSiteAuth().initEPerson(context,request,eperson);
  boolean passwordOK=true;
  if (eperson.getRequireCertificate() == false && Authenticate.getSiteAuth().allowSetPassword(context,request,eperson.getEmail())) {
    passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  }
  if (infoOK && passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,token);
    eperson.update();
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",token);
    request.setAttribute(""String_Node_Str"",eperson);
    request.setAttribute(""String_Node_Str"",new Boolean(!infoOK));
    request.setAttribute(""String_Node_Str"",new Boolean(!infoOK));
    boolean setPassword=Authenticate.getSiteAuth().allowSetPassword(context,request,email);
    request.setAttribute(""String_Node_Str"",new Boolean(setPassword));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.abort();
  }
}","/** 
 * Process information from ""Personal information page""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processPersonalInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String token=request.getParameter(""String_Node_Str"");
  String email=AccountManager.getEmail(context,token);
  if (email == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + token));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  EPerson eperson=EPerson.findByEmail(context,email);
  if (eperson == null) {
    context.setIgnoreAuthorization(true);
    eperson=EPerson.create(context);
    eperson.setEmail(email);
    eperson.update();
    context.setIgnoreAuthorization(false);
  }
  context.setCurrentUser(eperson);
  boolean infoOK=EditProfileServlet.updateUserProfile(eperson,request);
  eperson.setCanLogIn(true);
  eperson.setSelfRegistered(true);
  Authenticate.getSiteAuth().initEPerson(context,request,eperson);
  boolean passwordOK=true;
  if (eperson.getRequireCertificate() == false && Authenticate.getSiteAuth().allowSetPassword(context,request,eperson.getEmail())) {
    passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  }
  if (infoOK && passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,token);
    eperson.update();
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",token);
    request.setAttribute(""String_Node_Str"",eperson);
    request.setAttribute(""String_Node_Str"",new Boolean(!infoOK));
    request.setAttribute(""String_Node_Str"",new Boolean(!passwordOK));
    boolean setPassword=Authenticate.getSiteAuth().allowSetPassword(context,request,email);
    request.setAttribute(""String_Node_Str"",new Boolean(setPassword));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.abort();
  }
}",0.997341603898981
3652,"protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    request.setAttribute(""String_Node_Str"",collections);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community[] communities=Community.findAll(c);
    request.setAttribute(""String_Node_Str"",communities);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    Group[] groups=Group.findAll(c,Group.NAME);
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",groups);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community target=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,target);
    request.setAttribute(""String_Node_Str"",target);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",collection);
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",community);
    List policies=AuthorizeManager.getPolicies(c,community);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.update();
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.update();
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    String display_page=null;
    ResourcePolicy policy=ResourcePolicy.find(c,policy_id);
    Group group=Group.find(c,group_id);
    if (collection_id != -1) {
      collection=Collection.find(c,collection_id);
      policy.setResource(collection);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,collection,Constants.READ);
        Bitstream bs=collection.getLogo();
        AuthorizeManager.removeAllPolicies(c,bs);
        AuthorizeManager.addPolicies(c,rps,bs);
      }
      request.setAttribute(""String_Node_Str"",collection);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,collection));
      display_page=""String_Node_Str"";
    }
    if (community_id != -1) {
      community=Community.find(c,community_id);
      policy.setResource(community);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,community,Constants.READ);
        Bitstream bs=community.getLogo();
        AuthorizeManager.removeAllPolicies(c,bs);
        AuthorizeManager.addPolicies(c,rps,bs);
      }
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,community));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String display_page=null;
    if (collection_id != -1) {
      Collection t=Collection.find(c,collection_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      Community t=Community.find(c,community_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,0,0,false,true);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,0,0,false,true);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,action_id,group_id,false,false);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,action_id,group_id,false,false);
    }
    showMainPage(c,request,response);
  }
 else {
    showMainPage(c,request,response);
  }
  c.complete();
}","protected void doDSPost(Context c,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    request.setAttribute(""String_Node_Str"",collections);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community[] communities=Community.findAll(c);
    request.setAttribute(""String_Node_Str"",communities);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection[] collections=Collection.findAll(c);
    Group[] groups=Group.findAll(c,Group.NAME);
    request.setAttribute(""String_Node_Str"",collections);
    request.setAttribute(""String_Node_Str"",groups);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community target=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    List policies=AuthorizeManager.getPolicies(c,target);
    request.setAttribute(""String_Node_Str"",target);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",collection);
    List policies=AuthorizeManager.getPolicies(c,collection);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    ResourcePolicy policy=ResourcePolicy.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    policy.delete();
    request.setAttribute(""String_Node_Str"",community);
    List policies=AuthorizeManager.getPolicies(c,community);
    request.setAttribute(""String_Node_Str"",policies);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    ResourcePolicy policy=null;
    if (policy_id == -1) {
      policy=ResourcePolicy.create(c);
      policy.update();
    }
 else {
      policy=ResourcePolicy.find(c,policy_id);
    }
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.update();
    Collection collection=Collection.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + collection.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    ResourcePolicy policy=ResourcePolicy.create(c);
    policy.update();
    Community community=Community.find(c,UIUtil.getIntParameter(request,""String_Node_Str""));
    Group[] groups=Group.findAll(c,Group.NAME);
    EPerson[] epeople=EPerson.findAll(c,EPerson.EMAIL);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    request.setAttribute(""String_Node_Str"",policy);
    request.setAttribute(""String_Node_Str"",groups);
    request.setAttribute(""String_Node_Str"",epeople);
    request.setAttribute(""String_Node_Str"",""String_Node_Str"");
    request.setAttribute(""String_Node_Str"",""String_Node_Str"" + community.getID());
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    int policy_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    Collection collection=null;
    Community community=null;
    String display_page=null;
    ResourcePolicy policy=ResourcePolicy.find(c,policy_id);
    Group group=Group.find(c,group_id);
    if (collection_id != -1) {
      collection=Collection.find(c,collection_id);
      policy.setResource(collection);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,collection,Constants.READ);
        Bitstream bs=collection.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",collection);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,collection));
      display_page=""String_Node_Str"";
    }
    if (community_id != -1) {
      community=Community.find(c,community_id);
      policy.setResource(community);
      policy.setAction(action_id);
      policy.setGroup(group);
      policy.update();
      if (action_id == Constants.READ) {
        List rps=AuthorizeManager.getPoliciesActionFilter(c,community,Constants.READ);
        Bitstream bs=community.getLogo();
        if (bs != null) {
          AuthorizeManager.removeAllPolicies(c,bs);
          AuthorizeManager.addPolicies(c,rps,bs);
        }
      }
      request.setAttribute(""String_Node_Str"",community);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,community));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int community_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    String display_page=null;
    if (collection_id != -1) {
      Collection t=Collection.find(c,collection_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
 else     if (community_id != -1) {
      Community t=Community.find(c,community_id);
      request.setAttribute(""String_Node_Str"",t);
      request.setAttribute(""String_Node_Str"",AuthorizeManager.getPolicies(c,t));
      display_page=""String_Node_Str"";
    }
    JSPManager.showJSP(request,response,display_page);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,0,0,false,true);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,0,0,false,true);
    }
    showMainPage(c,request,response);
  }
 else   if (button.equals(""String_Node_Str"")) {
    int collection_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int resource_type=UIUtil.getIntParameter(request,""String_Node_Str"");
    int action_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    int group_id=UIUtil.getIntParameter(request,""String_Node_Str"");
    PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,resource_type,action_id,group_id,false,false);
    if (resource_type == Constants.BITSTREAM) {
      PolicySet.setPolicies(c,Constants.COLLECTION,collection_id,Constants.BUNDLE,action_id,group_id,false,false);
    }
    showMainPage(c,request,response);
  }
 else {
    showMainPage(c,request,response);
  }
  c.complete();
}",0.99608533959679
3653,"/** 
 * process input from edit-metadata-1.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processEditMetadataOne(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,EDIT_METADATA_1,EDIT_METADATA_1);
    return;
  }
  Item item=subInfo.submission.getItem();
  readNames(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  if (subInfo.submission.hasMultipleTitles()) {
    readText(request,item,""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  }
  readSeriesNumbers(request,item,""String_Node_Str"",""String_Node_Str"",true);
  item.clearDC(""String_Node_Str"",null,Item.ANY);
  String[] types=request.getParameterValues(""String_Node_Str"");
  for (int i=0; i < types.length; i++) {
    item.addDC(""String_Node_Str"",null,""String_Node_Str"",types[i]);
  }
  readText(request,item,""String_Node_Str"",""String_Node_Str"",false,null);
  subInfo.submission.getItem().clearDC(""String_Node_Str"",Item.ANY,Item.ANY);
  List quals=getRepeatedParameter(request,""String_Node_Str"");
  List vals=getRepeatedParameter(request,""String_Node_Str"");
  for (int i=0; i < vals.size(); i++) {
    String thisQual=(String)quals.get(i);
    String thisVal=(String)vals.get(i);
    if (!buttonPressed.equals(""String_Node_Str"" + i) && !thisVal.equals(""String_Node_Str"")) {
      item.addDC(""String_Node_Str"",thisQual,null,thisVal);
    }
  }
  if (subInfo.submission.isPublishedBefore()) {
    readDate(request,item,""String_Node_Str"",""String_Node_Str"");
    readText(request,item,""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  }
  int nextStep=-1;
  if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (subInfo.submission.hasMultipleTitles() && buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    nextStep=INITIAL_QUESTIONS;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    userHasReached(subInfo,EDIT_METADATA_2);
    nextStep=EDIT_METADATA_2;
  }
 else   if (buttonPressed.indexOf(""String_Node_Str"") > -1) {
    nextStep=EDIT_METADATA_1;
  }
  subInfo.submission.update();
  if (nextStep != -1) {
    doStep(context,request,response,subInfo,nextStep);
  }
 else {
    doStepJump(context,request,response,subInfo);
  }
  context.complete();
}","/** 
 * process input from edit-metadata-1.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processEditMetadataOne(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,EDIT_METADATA_1,EDIT_METADATA_1);
    return;
  }
  Item item=subInfo.submission.getItem();
  readNames(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  if (subInfo.submission.hasMultipleTitles()) {
    readText(request,item,""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  }
  readSeriesNumbers(request,item,""String_Node_Str"",""String_Node_Str"",true);
  item.clearDC(""String_Node_Str"",null,Item.ANY);
  String[] types=request.getParameterValues(""String_Node_Str"");
  if (types != null) {
    for (int i=0; i < types.length; i++) {
      item.addDC(""String_Node_Str"",null,""String_Node_Str"",types[i]);
    }
  }
  readText(request,item,""String_Node_Str"",""String_Node_Str"",false,null);
  subInfo.submission.getItem().clearDC(""String_Node_Str"",Item.ANY,Item.ANY);
  List quals=getRepeatedParameter(request,""String_Node_Str"");
  List vals=getRepeatedParameter(request,""String_Node_Str"");
  for (int i=0; i < vals.size(); i++) {
    String thisQual=(String)quals.get(i);
    String thisVal=(String)vals.get(i);
    if (!buttonPressed.equals(""String_Node_Str"" + i) && !thisVal.equals(""String_Node_Str"")) {
      item.addDC(""String_Node_Str"",thisQual,null,thisVal);
    }
  }
  if (subInfo.submission.isPublishedBefore()) {
    readDate(request,item,""String_Node_Str"",""String_Node_Str"");
    readText(request,item,""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
    readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  }
  int nextStep=-1;
  if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (subInfo.submission.hasMultipleTitles() && buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    nextStep=INITIAL_QUESTIONS;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    userHasReached(subInfo,EDIT_METADATA_2);
    nextStep=EDIT_METADATA_2;
  }
 else   if (buttonPressed.indexOf(""String_Node_Str"") > -1) {
    nextStep=EDIT_METADATA_1;
  }
  subInfo.submission.update();
  if (nextStep != -1) {
    doStep(context,request,response,subInfo,nextStep);
  }
 else {
    doStepJump(context,request,response,subInfo);
  }
  context.complete();
}",0.995170496121762
3654,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  X509Certificate[] certs=(X509Certificate[])request.getAttribute(""String_Node_Str"");
  if (certs == null || certs.length == 0) {
    if (request.getParameter(""String_Node_Str"") != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    try {
      if (X509Manager.isValid(certs[0])) {
        EPerson eperson=X509Manager.getUser(context,certs[0]);
        if (eperson == null) {
          if (ConfigurationManager.getBooleanProperty(""String_Node_Str"")) {
            String email=X509Manager.getEmail(certs[0]);
            eperson=EPerson.create(context);
            eperson.setEmail(email);
            eperson.setCanLogIn(true);
            Authenticate.getSiteAuth().initEPerson(context,request,eperson);
            eperson.update();
            context.commit();
          }
 else {
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
            JSPManager.showJSP(request,response,""String_Node_Str"");
            return;
          }
        }
        if (eperson != null && eperson.canLogIn()) {
          Authenticate.loggedIn(context,request,eperson);
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          Authenticate.resumeInterruptedRequest(request,response);
          return;
        }
      }
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 catch (    CertificateException ce) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ce);
      JSPManager.showInternalError(request,response);
    }
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  X509Certificate[] certs=(X509Certificate[])request.getAttribute(""String_Node_Str"");
  if (certs == null || certs.length == 0) {
    if (request.getParameter(""String_Node_Str"") != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    try {
      if (X509Manager.isValid(certs[0])) {
        EPerson eperson=X509Manager.getUser(context,certs[0]);
        if (eperson == null) {
          if (ConfigurationManager.getBooleanProperty(""String_Node_Str"")) {
            String email=X509Manager.getEmail(certs[0]);
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + email));
            context.setIgnoreAuthorization(true);
            eperson=EPerson.create(context);
            eperson.setEmail(email);
            eperson.setCanLogIn(true);
            Authenticate.getSiteAuth().initEPerson(context,request,eperson);
            eperson.update();
            context.commit();
            context.setIgnoreAuthorization(false);
          }
 else {
            log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
            JSPManager.showJSP(request,response,""String_Node_Str"");
            return;
          }
        }
        if (eperson != null && eperson.canLogIn()) {
          Authenticate.loggedIn(context,request,eperson);
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          Authenticate.resumeInterruptedRequest(request,response);
          return;
        }
      }
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 catch (    CertificateException ce) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ce);
      JSPManager.showInternalError(request,response);
    }
  }
}",0.952744630071599
3655,"/** 
 * Get the e-person's full name, combining first and last name in a displayable string.
 * @return  their full name
 */
public String getFullName(){
  String t=myRow.getStringColumn(""String_Node_Str"") + ""String_Node_Str"" + myRow.getStringColumn(""String_Node_Str"");
  return t;
}","/** 
 * Get the e-person's full name, combining first and last name in a displayable string.
 * @return  their full name
 */
public String getFullName(){
  String f=myRow.getStringColumn(""String_Node_Str"");
  String l=myRow.getStringColumn(""String_Node_Str"");
  if (l == null && f == null) {
    return getEmail();
  }
 else   if (f == null) {
    return l;
  }
 else {
    return (f + ""String_Node_Str"" + l);
  }
}",0.7191977077363897
3656,"/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  StringBuffer sqlb=new StringBuffer().append(""String_Node_Str"").append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(getTargetColumns(scope)).append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}","/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  int browseType=scope.getBrowseType();
  StringBuffer sqlb=new StringBuffer();
  sqlb.append(""String_Node_Str"");
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  sqlb.append(getTargetColumns(scope));
  sqlb.append(isCount ? ""String_Node_Str"" : ""String_Node_Str"");
  if (browseType == AUTHORS_BROWSE && !isCount) {
    sqlb.append(""String_Node_Str"");
  }
  sqlb.append(""String_Node_Str"");
  sqlb.append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}",0.3548961424332344
3657,"/** 
 * This method should be called whenever an item is added.
 * @param context The current DSpace context
 * @param item The item which has been added
 * @exception SQLException If a database error occurs
 */
public static void itemAdded(Context context,Item item) throws SQLException {
  Map table2dc=new HashMap();
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",null,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",Item.ANY,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  for (Iterator iterator=table2dc.keySet().iterator(); iterator.hasNext(); ) {
    String table=(String)iterator.next();
    DCValue[] dc=(DCValue[])table2dc.get(table);
    for (int i=0; i < dc.length; i++) {
      TableRow row=DatabaseManager.create(context,table);
      row.setColumn(""String_Node_Str"",item.getID());
      String value=dc[i].value;
      if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table)) {
        String title=NormalizedTitle.normalize(value,dc[i].language);
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",title);
      }
      DatabaseManager.update(context,row);
    }
  }
}","/** 
 * This method should be called whenever an item is added.
 * @param context The current DSpace context
 * @param item The item which has been added
 * @exception SQLException If a database error occurs
 */
public static void itemAdded(Context context,Item item) throws SQLException {
  Map table2dc=new HashMap();
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",null,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",Item.ANY,Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  table2dc.put(""String_Node_Str"",item.getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY));
  for (Iterator iterator=table2dc.keySet().iterator(); iterator.hasNext(); ) {
    String table=(String)iterator.next();
    DCValue[] dc=(DCValue[])table2dc.get(table);
    for (int i=0; i < dc.length; i++) {
      TableRow row=DatabaseManager.create(context,table);
      row.setColumn(""String_Node_Str"",item.getID());
      String value=dc[i].value;
      if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table))       row.setColumn(""String_Node_Str"",value);
 else       if (""String_Node_Str"".equals(table)) {
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",value.toLowerCase());
      }
 else       if (""String_Node_Str"".equals(table)) {
        String title=NormalizedTitle.normalize(value,dc[i].language);
        row.setColumn(""String_Node_Str"",value);
        row.setColumn(""String_Node_Str"",title.toLowerCase());
      }
      DatabaseManager.update(context,row);
    }
  }
}",0.972856261566934
3658,"protected static int countTotalInIndex(BrowseScope scope,int numberOfResults) throws SQLException {
  int browseType=scope.getBrowseType();
  if ((browseType == ITEMS_BY_AUTHOR_BROWSE) && (scope.hasNoLimit() || ((scope.getTotal() > numberOfResults))))   return numberOfResults;
  PreparedStatement statement=null;
  Object obj=scope.getScope();
  try {
    String table=BrowseTables.getTable(scope);
    StringBuffer buffer=new StringBuffer().append(""String_Node_Str"").append(getTargetColumns(scope)).append(""String_Node_Str"").append(table);
    boolean hasWhere=false;
    if (browseType == ITEMS_BY_AUTHOR_BROWSE) {
      hasWhere=true;
      buffer.append(""String_Node_Str"");
    }
    String connector=hasWhere ? ""String_Node_Str"" : ""String_Node_Str"";
    String sql=buffer.append(getScopeClause(scope,connector)).toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + sql + ""String_Node_Str"");
    statement=createStatement(scope,sql);
    if (browseType == ITEMS_BY_AUTHOR_BROWSE)     statement.setString(1,(String)scope.getFocus());
    return getIntValue(statement);
  }
  finally {
    if (statement != null)     statement.close();
  }
}","protected static int countTotalInIndex(BrowseScope scope,int numberOfResults) throws SQLException {
  int browseType=scope.getBrowseType();
  if ((browseType == ITEMS_BY_AUTHOR_BROWSE) && (scope.hasNoLimit() || ((scope.getTotal() > numberOfResults))))   return numberOfResults;
  PreparedStatement statement=null;
  Object obj=scope.getScope();
  try {
    String table=BrowseTables.getTable(scope);
    StringBuffer buffer=new StringBuffer().append(""String_Node_Str"").append((getTargetColumns(scope) == ""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(table);
    boolean hasWhere=false;
    if (browseType == ITEMS_BY_AUTHOR_BROWSE) {
      hasWhere=true;
      buffer.append(""String_Node_Str"");
    }
    String connector=hasWhere ? ""String_Node_Str"" : ""String_Node_Str"";
    String sql=buffer.append(getScopeClause(scope,connector)).toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + sql + ""String_Node_Str"");
    statement=createStatement(scope,sql);
    if (browseType == ITEMS_BY_AUTHOR_BROWSE)     statement.setString(1,(String)scope.getFocus());
    return getIntValue(statement);
  }
  finally {
    if (statement != null)     statement.close();
  }
}",0.9737171464330412
3659,"/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  StringBuffer sqlb=new StringBuffer().append(""String_Node_Str"").append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(getTargetColumns(scope)).append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}","/** 
 * Create a SQL string to run the correct query.
 */
private static String createSqlInternal(BrowseScope scope,String itemValue,boolean isCount) throws SQLException {
  String tablename=BrowseTables.getTable(scope);
  String column=BrowseTables.getValueColumn(scope);
  StringBuffer sqlb=new StringBuffer().append(""String_Node_Str"").append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append((getTargetColumns(scope) == ""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(isCount ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(tablename);
  boolean addedWhereClause=false;
  if (scope.hasFocus()) {
    String subquery=null;
    if (scope.focusIsItem())     subquery=new StringBuffer().append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(scope.getFocusItemId()).append(""String_Node_Str"").toString();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + subquery + ""String_Node_Str"");
    sqlb.append(""String_Node_Str"").append(""String_Node_Str"").append(column).append(""String_Node_Str"").append(""String_Node_Str"").append(scope.focusIsItem() ? subquery : ""String_Node_Str"").append(""String_Node_Str"");
    addedWhereClause=true;
  }
  String connector=addedWhereClause ? ""String_Node_Str"" : ""String_Node_Str"";
  sqlb.append(getScopeClause(scope,connector));
  if (isCount)   return sqlb.toString();
  sqlb.append(""String_Node_Str"").append(column).append(""String_Node_Str"").append((scope.focusIsString() || (scope.getBrowseType() == AUTHORS_BROWSE)) ? ""String_Node_Str"" : ""String_Node_Str"");
  if (!scope.hasNoLimit())   sqlb.append(""String_Node_Str"");
  return sqlb.toString();
}",0.9806451612903224
3660,"/** 
 * Returns a normalized String corresponding to TITLE. The normalization is effected by: + first removing leading spaces, if any + then removing the first leading occurences of ""a"", ""an"" and ""the"" (in any case). + removing any whitespace following an occurence of a stop word This simple strategy is only expected to be used for English words.
 */
public static String normalizeEnglish(String title){
  if (title == null)   return null;
  if (title.length() == 0)   return title;
  int startAt=firstWhitespace(title);
  boolean modified=(startAt != 0);
  boolean usedStopWord=false;
  String stop=null;
  for (int i=0; i < STOP_WORDS.length; i++) {
    stop=STOP_WORDS[i];
    int stoplen=stop.length();
    boolean found=title.toLowerCase().startsWith(stop.toLowerCase(),startAt) && title.length() >= (startAt + stoplen + 1) && Character.isWhitespace(title.charAt(startAt + stoplen));
    if (found) {
      modified=true;
      usedStopWord=true;
      startAt+=stoplen;
      int firstw=firstWhitespace(title,startAt);
      if (firstw != 0)       startAt=firstw;
      break;
    }
  }
  if (!modified)   return title;
  if (!usedStopWord)   return title.substring(startAt);
  return new StringBuffer(title.substring(startAt)).append(""String_Node_Str"").append(stop).toString();
}","/** 
 * Returns a normalized String corresponding to TITLE. The normalization is effected by: + first removing leading spaces, if any + then removing the first leading occurences of ""a"", ""an"" and ""the"" (in any case). + removing any whitespace following an occurence of a stop word This simple strategy is only expected to be used for English words.
 */
public static String normalizeEnglish(String oldtitle){
  if (oldtitle == null)   return null;
  if (oldtitle.length() == 0)   return oldtitle;
  String title=oldtitle.toLowerCase();
  int startAt=firstWhitespace(title);
  boolean modified=(startAt != 0);
  boolean usedStopWord=false;
  String stop=null;
  for (int i=0; i < STOP_WORDS.length; i++) {
    stop=STOP_WORDS[i];
    int stoplen=stop.length();
    boolean found=title.toLowerCase().startsWith(stop.toLowerCase(),startAt) && title.length() >= (startAt + stoplen + 1) && Character.isWhitespace(title.charAt(startAt + stoplen));
    if (found) {
      modified=true;
      usedStopWord=true;
      startAt+=stoplen;
      int firstw=firstWhitespace(title,startAt);
      if (firstw != 0)       startAt=firstw;
      break;
    }
  }
  if (!modified)   return title;
  if (!usedStopWord)   return title.substring(startAt);
  return new StringBuffer(title.substring(startAt)).append(""String_Node_Str"").append(stop).toString();
}",0.949371907118386
3661,"/** 
 * Process input from remove item page
 * @param context   current context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processRemoveItem(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  WorkspaceItem workspaceItem;
  try {
    int wsID=Integer.parseInt(request.getParameter(""String_Node_Str""));
    workspaceItem=WorkspaceItem.find(context,wsID);
  }
 catch (  NumberFormatException nfe) {
    workspaceItem=null;
  }
  if (workspaceItem == null) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
    JSPManager.showIntegrityError(request,response);
    return;
  }
  if (buttonPressed.equals(""String_Node_Str"")) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceItem.getID() + ""String_Node_Str""+ workspaceItem.getItem().getID()));
    workspaceItem.deleteWrapper();
    showMainPage(context,request,response);
    context.complete();
  }
 else {
    showMainPage(context,request,response);
  }
}","/** 
 * Process input from remove item page
 * @param context   current context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processRemoveItem(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  WorkspaceItem workspaceItem;
  try {
    int wsID=Integer.parseInt(request.getParameter(""String_Node_Str""));
    workspaceItem=WorkspaceItem.find(context,wsID);
  }
 catch (  NumberFormatException nfe) {
    workspaceItem=null;
  }
  if (workspaceItem == null) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
    JSPManager.showIntegrityError(request,response);
    return;
  }
  if (buttonPressed.equals(""String_Node_Str"")) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + workspaceItem.getID() + ""String_Node_Str""+ workspaceItem.getItem().getID()));
    workspaceItem.deleteAll();
    showMainPage(context,request,response);
    context.complete();
  }
 else {
    showMainPage(context,request,response);
  }
}",0.9959612277867528
3662,"/** 
 * Delete the item.  Bundles and bitstreams are also deleted if they are not also included in another item.  The Dublin Core metadata is deleted.
 */
void delete() throws SQLException, AuthorizeException, IOException {
  AuthorizeManager.authorizeAction(ourContext,this,Constants.DELETE);
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  ourContext.removeCached(this,getID());
  if (isArchived()) {
    Browse.itemRemoved(ourContext,getID());
  }
  removeDCFromDatabase();
  Bundle[] bundles=getBundles();
  for (int i=0; i < bundles.length; i++) {
    removeBundle(bundles[i]);
  }
  AuthorizeManager.removeAllPolicies(ourContext,this);
  DatabaseManager.updateQuery(ourContext,""String_Node_Str"" + Constants.ITEM + ""String_Node_Str""+ getID());
  DatabaseManager.delete(ourContext,itemRow);
}","/** 
 * Delete the item.  Bundles and bitstreams are also deleted if they are not also included in another item.  The Dublin Core metadata is deleted.
 */
void delete() throws SQLException, AuthorizeException, IOException {
  HistoryManager.saveHistory(ourContext,this,HistoryManager.REMOVE,ourContext.getCurrentUser(),ourContext.getExtraLogInfo());
  log.info(LogManager.getHeader(ourContext,""String_Node_Str"",""String_Node_Str"" + getID()));
  ourContext.removeCached(this,getID());
  if (isArchived()) {
    Browse.itemRemoved(ourContext,getID());
  }
  removeDCFromDatabase();
  Bundle[] bundles=getBundles();
  for (int i=0; i < bundles.length; i++) {
    removeBundle(bundles[i]);
  }
  AuthorizeManager.removeAllPolicies(ourContext,this);
  DatabaseManager.updateQuery(ourContext,""String_Node_Str"" + Constants.ITEM + ""String_Node_Str""+ getID());
  DatabaseManager.delete(ourContext,itemRow);
}",0.962486602357985
3663,"/** 
 * Process information from ""Personal information page""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processPersonalInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  boolean infoOK=EditProfileServlet.updateUserProfile(eperson,request);
  boolean passwordOK=true;
  if (eperson.getRequireCertificate() == false) {
    passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  }
  if (!infoOK) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  if (!passwordOK) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  request.setAttribute(""String_Node_Str"",eperson);
  if (infoOK && passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    eperson.setActive(true);
    eperson.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}","/** 
 * Process information from ""Personal information page""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processPersonalInfo(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  context.setCurrentUser(eperson);
  boolean infoOK=EditProfileServlet.updateUserProfile(eperson,request);
  boolean passwordOK=true;
  if (eperson.getRequireCertificate() == false) {
    passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  }
  if (!infoOK) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  if (!passwordOK) {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
  }
  request.setAttribute(""String_Node_Str"",eperson);
  if (infoOK && passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    eperson.setActive(true);
    eperson.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}",0.9890316515198996
3664,"/** 
 * Process information from ""enter new password""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processNewPassword(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  boolean passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  if (passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
    request.setAttribute(""String_Node_Str"",key);
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}","/** 
 * Process information from ""enter new password""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processNewPassword(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  context.setCurrentUser(eperson);
  boolean passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  if (passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
    request.setAttribute(""String_Node_Str"",key);
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}",0.986247544204322
3665,"/** 
 * Get all the items in this collection.  The order is indeterminate.
 * @return  an iterator over the items in the collection.
 */
public ItemIterator getItems() throws SQLException {
  TableRowIterator rows=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str"");
  return new ItemIterator(ourContext,rows);
}","/** 
 * Get all the items in this collection.  The order is indeterminate.
 * @return  an iterator over the items in the collection.
 */
public ItemIterator getItems() throws SQLException {
  TableRowIterator rows=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + getID() + ""String_Node_Str"");
  return new ItemIterator(ourContext,rows);
}",0.9743589743589745
3666,"/** 
 * Fill out an item's DC values from a plain standard text field. If the field isn't repeatable, the input field name is called: element_qualifier or for an unqualified element: element Repeated elements are appended with an underscore then an integer. e.g.: title_alternative_0 title_alternative_1 The values will be put in separate DCValues, ordered as they appear in the list.  These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 * @param lang       language to set (ISO code)
 */
private void readText(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated,String lang){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List vals=new LinkedList();
  if (repeated) {
    vals=getRepeatedParameter(request,dcname);
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      vals.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname);
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < vals.size(); i++) {
    String s=(String)vals.get(i);
    if (s != null && !s.trim().equals(""String_Node_Str"")) {
      item.addDC(element,qualifier,lang,s);
    }
  }
}","/** 
 * Fill out an item's DC values from a plain standard text field. If the field isn't repeatable, the input field name is called: element_qualifier or for an unqualified element: element Repeated elements are appended with an underscore then an integer. e.g.: title_alternative_0 title_alternative_1 The values will be put in separate DCValues, ordered as they appear in the list.  These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 * @param lang       language to set (ISO code)
 */
private void readText(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated,String lang){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List vals=new LinkedList();
  if (repeated) {
    vals=getRepeatedParameter(request,dcname);
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      vals.remove(valToRemove);
    }
  }
 else {
    vals.add(request.getParameter(dcname).trim());
    ;
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < vals.size(); i++) {
    String s=(String)vals.get(i);
    if (s != null && !s.equals(""String_Node_Str"")) {
      item.addDC(element,qualifier,lang,s);
    }
  }
}",0.988340807174888
3667,"/** 
 * Get repeated values from a form.  If ""foo"" is passed in, values in the form of parameters ""foo_0"", ""foo_1"", etc. are returned.
 * @param request   the HTTP request containing the form information
 * @param param     the repeated parameter
 * @return a List of Strings
 */
private List getRepeatedParameter(HttpServletRequest request,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  while (!foundLast) {
    String s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      vals.add(s);
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}","/** 
 * Get repeated values from a form.  If ""foo"" is passed in, values in the form of parameters ""foo_0"", ""foo_1"", etc. are returned.
 * @param request   the HTTP request containing the form information
 * @param param     the repeated parameter
 * @return a List of Strings
 */
private List getRepeatedParameter(HttpServletRequest request,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  while (!foundLast) {
    String s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      vals.add(s.trim());
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}",0.994422310756972
3668,"/** 
 * Fill out an item's DC values from a plain standard text field. If the field isn't repeatable, the input field name is called: element_qualifier or for an unqualified element: element Repeated elements are appended with an underscore then an integer. e.g.: title_alternative_0 title_alternative_1 The values will be put in separate DCValues, ordered as they appear in the list.  These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 * @param lang       language to set (ISO code)
 */
private void readText(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated,String lang){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List vals=new LinkedList();
  if (repeated) {
    vals=getRepeatedParameter(request,dcname);
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      vals.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname);
    if (s != null && !s.equals(""String_Node_Str"")) {
      vals.add(s);
    }
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < vals.size(); i++) {
    item.addDC(element,qualifier,lang,(String)vals.get(i));
  }
}","/** 
 * Fill out an item's DC values from a plain standard text field. If the field isn't repeatable, the input field name is called: element_qualifier or for an unqualified element: element Repeated elements are appended with an underscore then an integer. e.g.: title_alternative_0 title_alternative_1 The values will be put in separate DCValues, ordered as they appear in the list.  These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 * @param lang       language to set (ISO code)
 */
private void readText(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated,String lang){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List vals=new LinkedList();
  if (repeated) {
    vals=getRepeatedParameter(request,dcname);
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      vals.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname);
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < vals.size(); i++) {
    String s=(String)vals.get(i);
    if (s != null && !s.trim().equals(""String_Node_Str"")) {
      item.addDC(element,qualifier,lang,s);
    }
  }
}",0.9399759903961584
3669,"/** 
 * process input from edit-metadata-1.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processEditMetadataOne(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,EDIT_METADATA_1,EDIT_METADATA_1);
    return;
  }
  Item item=subInfo.submission.getItem();
  readNames(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  if (subInfo.submission.hasMultipleTitles()) {
    readText(request,item,""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  }
  if (subInfo.submission.isPublishedBefore()) {
    readDate(request,item,""String_Node_Str"",""String_Node_Str"");
  }
  readSeriesNumbers(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",""String_Node_Str"",false,null);
  subInfo.submission.getItem().clearDC(""String_Node_Str"",Item.ANY,Item.ANY);
  List quals=getRepeatedParameter(request,""String_Node_Str"");
  List vals=getRepeatedParameter(request,""String_Node_Str"");
  for (int i=0; i < vals.size(); i++) {
    String thisQual=(String)quals.get(i);
    String thisVal=(String)vals.get(i);
    if (!buttonPressed.equals(""String_Node_Str"" + i)) {
      item.addDC(""String_Node_Str"",thisQual,null,thisVal);
    }
  }
  int nextStep=-1;
  if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (subInfo.submission.hasMultipleTitles() && buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    nextStep=INITIAL_QUESTIONS;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    userHasReached(subInfo,EDIT_METADATA_2);
    nextStep=EDIT_METADATA_2;
  }
 else   if (buttonPressed.indexOf(""String_Node_Str"") > -1) {
    nextStep=EDIT_METADATA_1;
  }
  subInfo.submission.update();
  if (nextStep != -1) {
    doStep(context,request,response,subInfo,nextStep);
  }
 else {
    doStepJump(context,request,response,subInfo);
  }
  context.complete();
}","/** 
 * process input from edit-metadata-1.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processEditMetadataOne(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,EDIT_METADATA_1,EDIT_METADATA_1);
    return;
  }
  Item item=subInfo.submission.getItem();
  readNames(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",null,false,""String_Node_Str"");
  if (subInfo.submission.hasMultipleTitles()) {
    readText(request,item,""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  }
  if (subInfo.submission.isPublishedBefore()) {
    readDate(request,item,""String_Node_Str"",""String_Node_Str"");
  }
  readSeriesNumbers(request,item,""String_Node_Str"",""String_Node_Str"",true);
  readText(request,item,""String_Node_Str"",""String_Node_Str"",false,null);
  subInfo.submission.getItem().clearDC(""String_Node_Str"",Item.ANY,Item.ANY);
  List quals=getRepeatedParameter(request,""String_Node_Str"");
  List vals=getRepeatedParameter(request,""String_Node_Str"");
  for (int i=0; i < vals.size(); i++) {
    String thisQual=(String)quals.get(i);
    String thisVal=(String)vals.get(i);
    if (!buttonPressed.equals(""String_Node_Str"" + i) && !thisVal.equals(""String_Node_Str"")) {
      item.addDC(""String_Node_Str"",thisQual,null,thisVal);
    }
  }
  int nextStep=-1;
  if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (subInfo.submission.hasMultipleTitles() && buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    subInfo.moreBoxesFor=""String_Node_Str"";
    subInfo.jumpToField=""String_Node_Str"";
    nextStep=EDIT_METADATA_1;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    nextStep=INITIAL_QUESTIONS;
  }
 else   if (buttonPressed.equals(""String_Node_Str"")) {
    userHasReached(subInfo,EDIT_METADATA_2);
    nextStep=EDIT_METADATA_2;
  }
 else   if (buttonPressed.indexOf(""String_Node_Str"") > -1) {
    nextStep=EDIT_METADATA_1;
  }
  subInfo.submission.update();
  if (nextStep != -1) {
    doStep(context,request,response,subInfo,nextStep);
  }
 else {
    doStepJump(context,request,response,subInfo);
  }
  context.complete();
}",0.9936518543267624
3670,"/** 
 * Set relevant DC fields in an item from name values in the form. Some fields are repeatable in the form.  If this is the case, and the field is ""contributor.author"", the names in the request will be from the fields as follows: contributor_author_last_0       -> last name of first author contributor_author_first_0      -> first name(s) of first author contributor_author_last_1       -> last name of second author contributor_author_first_1      -> first name(s) of second author and so on.  If the field is unqualified: contributor_last_0        -> last name of first contributor contributor_first_0       -> first name(s) of first contributor If the parameter ""submit_contributor_author_remove_n"" is set, that value is removed. Otherwise the parameters are of the form: contributor_author_last contributor_author_first The values will be put in separate DCValues, in the form ""last name, first name(s)"", ordered as they appear in the list. These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 */
private void readNames(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List firsts=new LinkedList();
  List lasts=new LinkedList();
  if (repeated) {
    firsts=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    lasts=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      firsts.remove(valToRemove);
      lasts.remove(valToRemove);
    }
  }
 else {
    String lastName=request.getParameter(dcname + ""String_Node_Str"");
    String firstNames=request.getParameter(dcname + ""String_Node_Str"");
    if (lastName != null && !lastName.equals(""String_Node_Str"")) {
      lasts.add(lastName);
      firsts.add(firstNames);
    }
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < lasts.size(); i++) {
    String f=((String)firsts.get(i)).trim();
    String l=((String)lasts.get(i)).trim();
    int comma=l.indexOf(',');
    if (comma >= 0) {
      f=f + l.substring(comma + 1);
      l=l.substring(0,comma);
      while (f.startsWith(""String_Node_Str"")) {
        f=f.substring(1);
      }
    }
    item.addDC(element,qualifier,null,new DCPersonName(l,f).toString());
  }
}","/** 
 * Set relevant DC fields in an item from name values in the form. Some fields are repeatable in the form.  If this is the case, and the field is ""contributor.author"", the names in the request will be from the fields as follows: contributor_author_last_0       -> last name of first author contributor_author_first_0      -> first name(s) of first author contributor_author_last_1       -> last name of second author contributor_author_first_1      -> first name(s) of second author and so on.  If the field is unqualified: contributor_last_0        -> last name of first contributor contributor_first_0       -> first name(s) of first contributor If the parameter ""submit_contributor_author_remove_n"" is set, that value is removed. Otherwise the parameters are of the form: contributor_author_last contributor_author_first The values will be put in separate DCValues, in the form ""last name, first name(s)"", ordered as they appear in the list. These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 */
private void readNames(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List firsts=new LinkedList();
  List lasts=new LinkedList();
  if (repeated) {
    firsts=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    lasts=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      firsts.remove(valToRemove);
      lasts.remove(valToRemove);
    }
  }
 else {
    String lastName=request.getParameter(dcname + ""String_Node_Str"");
    String firstNames=request.getParameter(dcname + ""String_Node_Str"");
    lasts.add(lastName);
    firsts.add(firstNames);
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < lasts.size(); i++) {
    String f=(String)firsts.get(i);
    String l=(String)lasts.get(i);
    if (l != null && !((l.trim()).equals(""String_Node_Str""))) {
      if (f == null) {
        f=""String_Node_Str"";
      }
      int comma=l.indexOf(',');
      if (comma >= 0) {
        f=f + l.substring(comma + 1);
        l=l.substring(0,comma);
        while (f.startsWith(""String_Node_Str"")) {
          f=f.substring(1);
        }
      }
      item.addDC(element,qualifier,null,new DCPersonName(l,f).toString());
    }
  }
}",0.9326222222222222
3671,"/** 
 * Set relevant DC fields in an item from series/number values in the form. Some fields are repeatable in the form.  If this is the case, and the field is ""relation.ispartof"", the names in the request will be from the fields as follows: relation_ispartof_series_0 relation_ispartof_number_0 relation_ispartof_series_1 relation_ispartof_number_1 and so on.  If the field is unqualified: relation_series_0 relation_number_0 Otherwise the parameters are of the form: relation_ispartof_series relation_ispartof_number The values will be put in separate DCValues, in the form ""last name, first name(s)"", ordered as they appear in the list. These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 */
private void readSeriesNumbers(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List series=new LinkedList();
  List numbers=new LinkedList();
  if (repeated) {
    series=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    numbers=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      series.remove(valToRemove);
      numbers.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname + ""String_Node_Str"");
    String n=request.getParameter(dcname + ""String_Node_Str"");
    if (s != null && !s.equals(""String_Node_Str"")) {
      series.add(s);
      numbers.add(n);
    }
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < series.size(); i++) {
    String s=((String)series.get(i)).trim();
    String n=((String)numbers.get(i)).trim();
    item.addDC(element,qualifier,null,new DCSeriesNumber(s,n).toString());
  }
}","/** 
 * Set relevant DC fields in an item from series/number values in the form. Some fields are repeatable in the form.  If this is the case, and the field is ""relation.ispartof"", the names in the request will be from the fields as follows: relation_ispartof_series_0 relation_ispartof_number_0 relation_ispartof_series_1 relation_ispartof_number_1 and so on.  If the field is unqualified: relation_series_0 relation_number_0 Otherwise the parameters are of the form: relation_ispartof_series relation_ispartof_number The values will be put in separate DCValues, in the form ""last name, first name(s)"", ordered as they appear in the list. These will replace any existing values.
 * @param request    the request object
 * @param item       the item to update
 * @param element    the DC element
 * @param qualifier  the DC qualifier, or null if unqualified
 * @param repeated   set to true if the field is repeatable on the form
 */
private void readSeriesNumbers(HttpServletRequest request,Item item,String element,String qualifier,boolean repeated){
  String dcname=element;
  if (qualifier != null) {
    dcname=element + ""String_Node_Str"" + qualifier;
  }
  List series=new LinkedList();
  List numbers=new LinkedList();
  if (repeated) {
    series=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    numbers=getRepeatedParameter(request,dcname + ""String_Node_Str"");
    String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
    String removeButton=""String_Node_Str"" + dcname + ""String_Node_Str"";
    if (buttonPressed.startsWith(removeButton)) {
      int valToRemove=Integer.parseInt(buttonPressed.substring(removeButton.length()));
      series.remove(valToRemove);
      numbers.remove(valToRemove);
    }
  }
 else {
    String s=request.getParameter(dcname + ""String_Node_Str"");
    String n=request.getParameter(dcname + ""String_Node_Str"");
    if (s != null && !s.equals(""String_Node_Str"")) {
      series.add(s);
      numbers.add(n);
    }
  }
  item.clearDC(element,qualifier,Item.ANY);
  for (int i=0; i < series.size(); i++) {
    String s=((String)series.get(i)).trim();
    String n=((String)numbers.get(i)).trim();
    if (!s.equals(""String_Node_Str"") || !n.equals(""String_Node_Str"")) {
      item.addDC(element,qualifier,null,new DCSeriesNumber(s,n).toString());
    }
  }
}",0.9824945295404814
3672,"/** 
 * Get repeated values from a form.  If ""foo"" is passed in, values in the form of parameters ""foo_0"", ""foo_1"", etc. are returned.
 * @param request   the HTTP request containing the form information
 * @param param     the repeated parameter
 * @return a List of Strings
 */
private List getRepeatedParameter(HttpServletRequest request,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  while (!foundLast) {
    String s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null && !s.equals(""String_Node_Str"")) {
      vals.add(s);
    }
    foundLast=(s == null);
    i++;
  }
  return vals;
}","/** 
 * Get repeated values from a form.  If ""foo"" is passed in, values in the form of parameters ""foo_0"", ""foo_1"", etc. are returned.
 * @param request   the HTTP request containing the form information
 * @param param     the repeated parameter
 * @return a List of Strings
 */
private List getRepeatedParameter(HttpServletRequest request,String param){
  List vals=new LinkedList();
  int i=0;
  boolean foundLast=false;
  while (!foundLast) {
    String s=request.getParameter(param + ""String_Node_Str"" + i);
    if (s != null) {
      vals.add(s);
    }
 else {
      foundLast=true;
    }
    i++;
  }
  return vals;
}",0.912667191188041
3673,"/** 
 * process input from initial-questions.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processInitialQuestions(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,INITIAL_QUESTIONS,INITIAL_QUESTIONS);
    return;
  }
  boolean multipleTitles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean publishedBefore=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean multipleFiles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean isThesis=UIUtil.getBoolParameter(request,""String_Node_Str"");
  if (isWorkflow(subInfo)) {
    isThesis=false;
  }
  if (isThesis) {
    WorkspaceItem wi=(WorkspaceItem)subInfo.submission;
    wi.deleteAll();
    request.getSession().setAttribute(""String_Node_Str"",new Boolean(true));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
    return;
  }
  boolean willRemoveTitles=false;
  boolean willRemoveDate=false;
  boolean willRemoveFiles=false;
  if (multipleTitles == false) {
    DCValue[] altTitles=subInfo.submission.getItem().getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    willRemoveTitles=altTitles.length > 0;
  }
  if (publishedBefore == false) {
    DCValue[] dateIssued=subInfo.submission.getItem().getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    willRemoveDate=dateIssued.length > 0;
  }
  if (multipleFiles == false) {
    Bundle[] bundles=subInfo.submission.getItem().getBundles();
    willRemoveFiles=bundles.length > 1;
  }
  if (willRemoveTitles || willRemoveDate || willRemoveFiles) {
    request.setAttribute(""String_Node_Str"",subInfo);
    request.setAttribute(""String_Node_Str"",new Boolean(multipleTitles));
    request.setAttribute(""String_Node_Str"",new Boolean(publishedBefore));
    request.setAttribute(""String_Node_Str"",new Boolean(multipleFiles));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveTitles));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveDate));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveFiles));
    request.setAttribute(""String_Node_Str"",UIUtil.getSubmitButton(request,""String_Node_Str""));
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    subInfo.submission.setMultipleTitles(multipleTitles);
    subInfo.submission.setPublishedBefore(publishedBefore);
    if (!isWorkflow(subInfo)) {
      subInfo.submission.setMultipleFiles(multipleFiles);
    }
    subInfo.submission.update();
    if (buttonPressed.equals(""String_Node_Str"")) {
      userHasReached(subInfo,EDIT_METADATA_1);
      doStep(context,request,response,subInfo,EDIT_METADATA_1);
    }
 else {
      doStepJump(context,request,response,subInfo);
    }
    context.complete();
  }
}","/** 
 * process input from initial-questions.jsp
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 * @param subInfo   submission info object
 */
private void processInitialQuestions(Context context,HttpServletRequest request,HttpServletResponse response,SubmissionInfo subInfo) throws ServletException, IOException, SQLException, AuthorizeException {
  String buttonPressed=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (buttonPressed.equals(""String_Node_Str"")) {
    doCancellation(request,response,subInfo,INITIAL_QUESTIONS,INITIAL_QUESTIONS);
    return;
  }
  boolean multipleTitles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean publishedBefore=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean multipleFiles=UIUtil.getBoolParameter(request,""String_Node_Str"");
  boolean isThesis=UIUtil.getBoolParameter(request,""String_Node_Str"");
  if (isWorkflow(subInfo)) {
    isThesis=false;
    multipleFiles=true;
  }
  if (isThesis) {
    WorkspaceItem wi=(WorkspaceItem)subInfo.submission;
    wi.deleteAll();
    request.getSession().setAttribute(""String_Node_Str"",new Boolean(true));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
    return;
  }
  boolean willRemoveTitles=false;
  boolean willRemoveDate=false;
  boolean willRemoveFiles=false;
  if (multipleTitles == false) {
    DCValue[] altTitles=subInfo.submission.getItem().getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    willRemoveTitles=altTitles.length > 0;
  }
  if (publishedBefore == false) {
    DCValue[] dateIssued=subInfo.submission.getItem().getDC(""String_Node_Str"",""String_Node_Str"",Item.ANY);
    willRemoveDate=dateIssued.length > 0;
  }
  if (multipleFiles == false) {
    Bundle[] bundles=subInfo.submission.getItem().getBundles();
    willRemoveFiles=bundles.length > 1;
  }
  if (willRemoveTitles || willRemoveDate || willRemoveFiles) {
    request.setAttribute(""String_Node_Str"",subInfo);
    request.setAttribute(""String_Node_Str"",new Boolean(multipleTitles));
    request.setAttribute(""String_Node_Str"",new Boolean(publishedBefore));
    request.setAttribute(""String_Node_Str"",new Boolean(multipleFiles));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveTitles));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveDate));
    request.setAttribute(""String_Node_Str"",new Boolean(willRemoveFiles));
    request.setAttribute(""String_Node_Str"",UIUtil.getSubmitButton(request,""String_Node_Str""));
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    subInfo.submission.setMultipleTitles(multipleTitles);
    subInfo.submission.setPublishedBefore(publishedBefore);
    if (!isWorkflow(subInfo)) {
      subInfo.submission.setMultipleFiles(multipleFiles);
    }
    subInfo.submission.update();
    if (buttonPressed.equals(""String_Node_Str"")) {
      userHasReached(subInfo,EDIT_METADATA_1);
      doStep(context,request,response,subInfo,EDIT_METADATA_1);
    }
 else {
      doStepJump(context,request,response,subInfo);
    }
    context.complete();
  }
}",0.9961928934010152
3674,"/** 
 * Create/update community metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community to update (or null for creation)
 */
private void processConfirmEditCommunity(Context context,HttpServletRequest request,HttpServletResponse response,Community community) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    community=Community.create(context);
  }
  community.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  community.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  community.setMetadata(""String_Node_Str"",intro);
  community.setMetadata(""String_Node_Str"",copy);
  community.setMetadata(""String_Node_Str"",side);
  community.update();
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    community.setLogo(null);
    community.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    community.setLogo(null);
    community.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  context.complete();
}","/** 
 * Create/update community metadata from a posted form
 * @param context     DSpace context
 * @param request     the HTTP request containing posted info
 * @param response    the HTTP response
 * @param community   the community to update (or null for creation)
 */
private void processConfirmEditCommunity(Context context,HttpServletRequest request,HttpServletResponse response,Community community) throws ServletException, IOException, SQLException, AuthorizeException {
  if (request.getParameter(""String_Node_Str"").equals(""String_Node_Str"")) {
    community=Community.create(context);
    request.setAttribute(""String_Node_Str"",community);
  }
  community.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  community.setMetadata(""String_Node_Str"",request.getParameter(""String_Node_Str""));
  String intro=request.getParameter(""String_Node_Str"");
  if (intro.equals(""String_Node_Str"")) {
    intro=null;
  }
  String copy=request.getParameter(""String_Node_Str"");
  if (copy.equals(""String_Node_Str"")) {
    copy=null;
  }
  String side=request.getParameter(""String_Node_Str"");
  if (side.equals(""String_Node_Str"")) {
    side=null;
  }
  community.setMetadata(""String_Node_Str"",intro);
  community.setMetadata(""String_Node_Str"",copy);
  community.setMetadata(""String_Node_Str"",side);
  community.update();
  String button=UIUtil.getSubmitButton(request,""String_Node_Str"");
  if (button.equals(""String_Node_Str"")) {
    community.setLogo(null);
    community.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else   if (button.equals(""String_Node_Str"")) {
    community.setLogo(null);
    community.update();
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
 else {
    showControls(context,request,response);
  }
  context.complete();
}",0.9845462208485528
3675,"/** 
 * Process information from ""enter new password""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processNewPassword(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  boolean passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  if (passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
    request.setAttribute(""String_Node_Str"",key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}","/** 
 * Process information from ""enter new password""
 * @param context   current DSpace context
 * @param request   current servlet request object
 * @param response  current servlet response object
 */
private void processNewPassword(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  String key=request.getParameter(""String_Node_Str"");
  EPerson eperson=AccountManager.getEPerson(context,key);
  if (eperson == null) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + key));
    JSPManager.showJSP(request,response,""String_Node_Str"");
    return;
  }
  boolean passwordOK=EditProfileServlet.confirmAndSetPassword(eperson,request);
  if (passwordOK) {
    log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str"" + eperson.getEmail()));
    AccountManager.deleteToken(context,key);
    JSPManager.showJSP(request,response,""String_Node_Str"");
    context.complete();
  }
 else {
    request.setAttribute(""String_Node_Str"",new Boolean(true));
    request.setAttribute(""String_Node_Str"",key);
    request.setAttribute(""String_Node_Str"",eperson);
    JSPManager.showJSP(request,response,""String_Node_Str"");
  }
}",0.9784289784289784
3676,"/** 
 * Update the ResourcePolicy
 */
public void update() throws SQLException, AuthorizeException {
  DatabaseManager.update(myContext,myRow);
}","/** 
 * Update the ResourcePolicy
 */
public void update() throws SQLException {
  DatabaseManager.update(myContext,myRow);
}",0.925925925925926
3677,"/** 
 * Return the request that the system should be dealing with, given the request that the browse just sent.  If the incoming request is from a redirect resulting from successful authentication, a request object corresponding to the original request that prompted authentication is returned.  Otherwise, the request passed in is returned.
 * @param request   the incoming HTTP request
 * @return   the HTTP request the DSpace system should deal with
 */
public static HttpServletRequest getRealRequest(HttpServletRequest request){
  HttpSession session=request.getSession();
  if (session.getAttribute(""String_Node_Str"") != null) {
    log.info(""String_Node_Str"");
    RequestInfo requestInfo=(RequestInfo)session.getAttribute(""String_Node_Str"");
    HttpServletRequest actualRequest=requestInfo.wrapRequest(request);
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    return actualRequest;
  }
 else {
    return request;
  }
}","/** 
 * Return the request that the system should be dealing with, given the request that the browse just sent.  If the incoming request is from a redirect resulting from successful authentication, a request object corresponding to the original request that prompted authentication is returned.  Otherwise, the request passed in is returned.
 * @param request   the incoming HTTP request
 * @return   the HTTP request the DSpace system should deal with
 */
public static HttpServletRequest getRealRequest(HttpServletRequest request){
  HttpSession session=request.getSession();
  if (session.getAttribute(""String_Node_Str"") != null) {
    RequestInfo requestInfo=(RequestInfo)session.getAttribute(""String_Node_Str"");
    HttpServletRequest actualRequest;
    if (requestInfo == null) {
      actualRequest=request;
    }
 else {
      actualRequest=requestInfo.wrapRequest(request);
    }
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    session.removeAttribute(""String_Node_Str"");
    return actualRequest;
  }
 else {
    return request;
  }
}",0.7947269303201506
3678,"private static void doState(Context c,WorkflowItem wi,int newstate,EPerson newowner) throws SQLException, IOException, AuthorizeException {
  Collection mycollection=wi.getCollection();
  Group mygroup=null;
  wi.setState(newstate);
switch (newstate) {
case WFSTATE_REVIEWPOOL:
    wi.setOwner(null);
  mygroup=mycollection.getWorkflowGroup(1);
if (mygroup != null) {
  createTasks(c,wi,mygroup);
  wi.update();
  notifyGroupOfTask(c,mygroup,wi);
}
 else {
  doState(c,wi,WFSTATE_ADMINPOOL,null);
}
break;
case WFSTATE_REVIEW:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_ADMINPOOL:
wi.setOwner(null);
mygroup=mycollection.getWorkflowGroup(2);
if (mygroup != null) {
createTasks(c,wi,mygroup);
notifyGroupOfTask(c,mygroup,wi);
}
 else {
doState(c,wi,WFSTATE_EDITPOOL,null);
}
break;
case WFSTATE_ADMIN:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_EDITPOOL:
wi.setOwner(null);
mygroup=mycollection.getWorkflowGroup(3);
if (mygroup != null) {
createTasks(c,wi,mygroup);
notifyGroupOfTask(c,mygroup,wi);
}
 else {
doState(c,wi,WFSTATE_ARCHIVE,newowner);
}
break;
case WFSTATE_EDIT:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_ARCHIVE:
try {
deleteTasks(c,wi);
mycollection=wi.getCollection();
Item myitem=archive(c,wi);
notifyOfArchive(c,myitem,mycollection);
DSIndexer.indexItem(c,myitem);
}
 catch (IOException e) {
throw e;
}
catch (SQLException e) {
throw e;
}
break;
}
if (wi != null) wi.update();
}","private static void doState(Context c,WorkflowItem wi,int newstate,EPerson newowner) throws SQLException, IOException, AuthorizeException {
  Collection mycollection=wi.getCollection();
  Group mygroup=null;
  wi.setState(newstate);
switch (newstate) {
case WFSTATE_REVIEWPOOL:
    wi.setOwner(null);
  mygroup=mycollection.getWorkflowGroup(1);
if (mygroup != null) {
  createTasks(c,wi,mygroup);
  wi.update();
  notifyGroupOfTask(c,mygroup,wi);
}
 else {
  doState(c,wi,WFSTATE_ADMINPOOL,null);
}
break;
case WFSTATE_REVIEW:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_ADMINPOOL:
wi.setOwner(null);
mygroup=mycollection.getWorkflowGroup(2);
if (mygroup != null) {
createTasks(c,wi,mygroup);
notifyGroupOfTask(c,mygroup,wi);
}
 else {
doState(c,wi,WFSTATE_EDITPOOL,null);
}
break;
case WFSTATE_ADMIN:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_EDITPOOL:
wi.setOwner(null);
mygroup=mycollection.getWorkflowGroup(3);
if (mygroup != null) {
createTasks(c,wi,mygroup);
notifyGroupOfTask(c,mygroup,wi);
}
 else {
doState(c,wi,WFSTATE_ARCHIVE,newowner);
}
break;
case WFSTATE_EDIT:
deleteTasks(c,wi);
wi.setOwner(newowner);
break;
case WFSTATE_ARCHIVE:
try {
deleteTasks(c,wi);
mycollection=wi.getCollection();
Item myitem=archive(c,wi);
notifyOfArchive(c,myitem,mycollection);
}
 catch (IOException e) {
throw e;
}
catch (SQLException e) {
throw e;
}
break;
}
if (wi != null) wi.update();
}",0.989224887035106
3679,"/** 
 * Set the e-person that originally submitted this item.  This is a public method since it is handled by the WorkspaceItem class in the ingest package. <code>update</code> must be called to write the change to the database.
 * @param sub  the submitter
 */
public void setSubmitter(EPerson sub){
  submitter=sub;
}","/** 
 * Set the e-person that originally submitted this item.  This is a public method since it is handled by the WorkspaceItem class in the ingest package. <code>update</code> must be called to write the change to the database.
 * @param sub  the submitter
 */
public void setSubmitter(EPerson sub){
  submitter=sub;
  if (submitter != null) {
    itemRow.setColumn(""String_Node_Str"",submitter.getID());
  }
 else {
    itemRow.setColumnNull(""String_Node_Str"");
  }
}",0.8106734434561627
3680,"protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  processRequest(request,response,true);
}","protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  processRequest(request,response);
}",0.984126984126984
3681,"protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  processRequest(request,response,false);
}","protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  processRequest(request,response);
}",0.9808917197452228
3682,"/** 
 * Process an incoming request
 * @param request    the request object
 * @param response   the response object
 * @param isPost     if true, this is a POST
 */
private void processRequest(HttpServletRequest request,HttpServletResponse response,boolean isPost) throws ServletException, IOException {
  Context context=null;
  UIUtil.storeOriginalURL(request);
  try {
    context=UIUtil.obtainContext(request);
    request=Authenticate.getRealRequest(request);
    if (isPost) {
      doDSPost(context,request,response);
    }
 else {
      doDSGet(context,request,response);
    }
  }
 catch (  SQLException se) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",se.toString()),se);
    UIUtil.sendAlert(request,se);
    JSPManager.showInternalError(request,response);
  }
catch (  AuthorizeException ae) {
    if (context.getCurrentUser() == null) {
      Authenticate.startAuthentication(context,request,response);
    }
 else {
      log.info(LogManager.getHeader(context,""String_Node_Str"",ae.toString()));
      JSPManager.showAuthorizeError(request,response,ae);
    }
  }
  if (context != null && context.isValid()) {
    context.abort();
  }
}","/** 
 * Process an incoming request
 * @param request    the request object
 * @param response   the response object
 */
private void processRequest(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  Context context=null;
  UIUtil.storeOriginalURL(request);
  try {
    context=UIUtil.obtainContext(request);
    request=Authenticate.getRealRequest(request);
    if (log.isDebugEnabled()) {
      log.debug(LogManager.getHeader(context,""String_Node_Str"",UIUtil.getRequestLogInfo(request)));
    }
    if (request.getMethod().equals(""String_Node_Str"")) {
      doDSPost(context,request,response);
    }
 else {
      doDSGet(context,request,response);
    }
  }
 catch (  SQLException se) {
    log.warn(LogManager.getHeader(context,""String_Node_Str"",se.toString()),se);
    UIUtil.sendAlert(request,se);
    JSPManager.showInternalError(request,response);
  }
catch (  AuthorizeException ae) {
    if (context.getCurrentUser() == null) {
      Authenticate.startAuthentication(context,request,response);
    }
 else {
      log.info(LogManager.getHeader(context,""String_Node_Str"",ae.toString()));
      JSPManager.showAuthorizeError(request,response,ae);
    }
  }
  if (context != null && context.isValid()) {
    context.abort();
  }
}",0.8984088127294981
3683,"protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  X509Certificate[] certs=(X509Certificate[])request.getAttribute(""String_Node_Str"");
  if (certs.length == 0) {
    if (request.getParameter(""String_Node_Str"") != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    try {
      if (X509Manager.isValid(certs[0])) {
        EPerson eperson=X509Manager.getUser(context,certs[0]);
        if (eperson != null && eperson.getActive()) {
          Authenticate.loggedIn(context,request,eperson);
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          Authenticate.resumeInterruptedRequest(request,response);
          return;
        }
 else {
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          JSPManager.showJSP(request,response,""String_Node_Str"");
        }
      }
 else {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        JSPManager.showJSP(request,response,""String_Node_Str"");
      }
    }
 catch (    CertificateException ce) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ce);
      JSPManager.showInternalError(request,response);
    }
  }
}","protected void doDSGet(Context context,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException, SQLException, AuthorizeException {
  X509Certificate[] certs=(X509Certificate[])request.getAttribute(""String_Node_Str"");
  if (certs == null || certs.length == 0) {
    if (request.getParameter(""String_Node_Str"") != null) {
      log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
 else {
      JSPManager.showJSP(request,response,""String_Node_Str"");
    }
  }
 else {
    try {
      if (X509Manager.isValid(certs[0])) {
        EPerson eperson=X509Manager.getUser(context,certs[0]);
        if (eperson != null && eperson.getActive()) {
          Authenticate.loggedIn(context,request,eperson);
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          Authenticate.resumeInterruptedRequest(request,response);
          return;
        }
 else {
          log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
          JSPManager.showJSP(request,response,""String_Node_Str"");
        }
      }
 else {
        log.info(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""));
        JSPManager.showJSP(request,response,""String_Node_Str"");
      }
    }
 catch (    CertificateException ce) {
      log.warn(LogManager.getHeader(context,""String_Node_Str"",""String_Node_Str""),ce);
      JSPManager.showInternalError(request,response);
    }
  }
}",0.994475138121547
3684,"/** 
 * Set the EPerson's password
 * @param s   the new email
 */
public void setPassword(String s){
  String encoded=encodePassword(s);
  myRow.setColumn(""String_Node_Str"",encoded);
}","/** 
 * Set the EPerson's password
 * @param s   the new email
 */
public void setPassword(String s){
  String encoded=Utils.getMD5(s);
  myRow.setColumn(""String_Node_Str"",encoded);
}",0.9347826086956522
3685,"/** 
 * Check EPerson's password
 * @param attempt the password attempt
 * @return boolean successful/unsuccessful
 */
public boolean checkPassword(String attempt){
  String encoded=encodePassword(attempt);
  if (attempt.equals(myRow.getStringColumn(""String_Node_Str"")))   return true;
  return false;
}","/** 
 * Check EPerson's password
 * @param attempt the password attempt
 * @return boolean successful/unsuccessful
 */
public boolean checkPassword(String attempt){
  String encoded=Utils.getMD5(attempt);
  return (encoded.equals(myRow.getStringColumn(""String_Node_Str"")));
}",0.8581314878892734
3686,"/** 
 * Construct an item with the given table row
 * @param context  the context this object exists in
 * @param row      the corresponding row in the table
 */
Item(Context context,TableRow row) throws SQLException {
  ourContext=context;
  itemRow=row;
  dublinCoreChanged=false;
  dublinCore=new ArrayList();
  bundlesChanged=false;
  bundles=new ArrayList();
  submitter=null;
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow r=(TableRow)tri.next();
    bundles.add(new Bundle(ourContext,r));
  }
  tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str""));
  while (tri.hasNext()) {
    TableRow resultRow=(TableRow)tri.next();
    TableRow typeRow=DatabaseManager.find(ourContext,""String_Node_Str"",resultRow.getIntColumn(""String_Node_Str""));
    DCValue dcv=new DCValue();
    dcv.element=typeRow.getStringColumn(""String_Node_Str"");
    dcv.qualifier=typeRow.getStringColumn(""String_Node_Str"");
    dcv.value=resultRow.getStringColumn(""String_Node_Str"");
    dcv.language=resultRow.getStringColumn(""String_Node_Str"");
    dublinCore.add(dcv);
  }
}","/** 
 * Construct an item with the given table row
 * @param context  the context this object exists in
 * @param row      the corresponding row in the table
 */
Item(Context context,TableRow row) throws SQLException {
  ourContext=context;
  itemRow=row;
  dublinCoreChanged=false;
  dublinCore=new ArrayList();
  bundlesChanged=false;
  bundles=new ArrayList();
  submitter=null;
  TableRowIterator tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow r=(TableRow)tri.next();
    bundles.add(new Bundle(ourContext,r));
  }
  tri=DatabaseManager.query(ourContext,""String_Node_Str"",""String_Node_Str"" + itemRow.getIntColumn(""String_Node_Str"") + ""String_Node_Str"");
  while (tri.hasNext()) {
    TableRow resultRow=(TableRow)tri.next();
    TableRow typeRow=DatabaseManager.find(ourContext,""String_Node_Str"",resultRow.getIntColumn(""String_Node_Str""));
    DCValue dcv=new DCValue();
    dcv.element=typeRow.getStringColumn(""String_Node_Str"");
    dcv.qualifier=typeRow.getStringColumn(""String_Node_Str"");
    dcv.value=resultRow.getStringColumn(""String_Node_Str"");
    dcv.language=resultRow.getStringColumn(""String_Node_Str"");
    dublinCore.add(dcv);
  }
}",0.9923605805958748
3687,"/** 
 * Clear Dublin Core metadata values.  As with <code>addDC</code> above, passing in <code>null</code> only matches fields where the qualifier or language is actually <code>null</code>.  <code>Item.ANY</code> will match any element, qualifier or language, including <code>null</code>. Thus, <code>item.clearDC(Item.ANY, Item.ANY, Item.ANY)</code> will remove all Dublin Core metadata associated with an item.
 * @param element     the Dublin Core element to remove, or<code>Item.ANY</code>
 * @param qualifier   the qualifier.  <code>null</code> means unqualified,and <code>Item.ANY</code> means any qualifier (including unqualified.)
 * @param lang       the ISO639 language code, optionally followed byan underscore and the ISO3166 country code. <code>null</code> means only values with no language are removed, and <code>Item.ANY</code> means values with any country code or no country code are removed.
 */
public void clearDC(String element,String qualifier,String lang) throws AuthorizeException {
  List values=new ArrayList();
  Iterator i=dublinCore.iterator();
  while (i.hasNext()) {
    DCValue dcv=(DCValue)i.next();
    if (!match(element,qualifier,lang,dcv)) {
      values.add(dcv.value);
    }
  }
  dublinCore=values;
}","/** 
 * Clear Dublin Core metadata values.  As with <code>addDC</code> above, passing in <code>null</code> only matches fields where the qualifier or language is actually <code>null</code>.  <code>Item.ANY</code> will match any element, qualifier or language, including <code>null</code>. Thus, <code>item.clearDC(Item.ANY, Item.ANY, Item.ANY)</code> will remove all Dublin Core metadata associated with an item.
 * @param element     the Dublin Core element to remove, or<code>Item.ANY</code>
 * @param qualifier   the qualifier.  <code>null</code> means unqualified,and <code>Item.ANY</code> means any qualifier (including unqualified.)
 * @param lang       the ISO639 language code, optionally followed byan underscore and the ISO3166 country code. <code>null</code> means only values with no language are removed, and <code>Item.ANY</code> means values with any country code or no country code are removed.
 */
public void clearDC(String element,String qualifier,String lang) throws AuthorizeException {
  List values=new ArrayList();
  Iterator i=dublinCore.iterator();
  while (i.hasNext()) {
    DCValue dcv=(DCValue)i.next();
    if (!match(element,qualifier,lang,dcv)) {
      values.add(dcv);
    }
  }
  dublinCore=values;
}",0.9975767366720516
3688,"/** 
 * Assign an ID to row
 */
private static synchronized void assignId(TableRow row) throws SQLException {
  String table=canonicalize(row.getTable());
  String pk=getPrimaryKeyColumn(table);
  Integer id=(Integer)ids.get(table);
  int nid=id == null ? -1 : id.intValue() + 1;
  if (id == null) {
    String sql=MessageFormat.format(""String_Node_Str"",new Object[]{pk,table});
    Statement statement=null;
    try {
      statement=getConnection().createStatement();
      ResultSet results=statement.executeQuery(sql);
      nid=results.next() ? results.getInt(1) : -1;
    }
  finally {
      if (statement != null) {
        try {
          statement.close();
        }
 catch (        SQLException sqle) {
        }
      }
    }
  }
  row.setColumn(pk,nid);
  ids.put(table,new Integer(nid));
}","/** 
 * Assign an ID to row
 */
private static synchronized void assignId(TableRow row) throws SQLException {
  String table=canonicalize(row.getTable());
  String pk=getPrimaryKeyColumn(table);
  Integer id=(Integer)ids.get(table);
  int current_id=id == null ? -1 : id.intValue();
  if (id == null) {
    String sql=MessageFormat.format(""String_Node_Str"",new Object[]{pk,table});
    Statement statement=null;
    try {
      statement=getConnection().createStatement();
      ResultSet results=statement.executeQuery(sql);
      current_id=results.next() ? results.getInt(1) : -1;
    }
  finally {
      if (statement != null) {
        try {
          statement.close();
        }
 catch (        SQLException sqle) {
        }
      }
    }
  }
  int new_id=current_id + 1;
  row.setColumn(pk,new_id);
  ids.put(table,new Integer(new_id));
}",0.96543359611886
3689,"@Test public void testPerson() throws java.security.NoSuchAlgorithmException, java.io.UnsupportedEncodingException {
  Person p=new Person();
  p.setEntityAccessStatus(""String_Node_Str"");
  p.setEntityId(EntityBase.generateNewID());
  p.setTypeId(0);
  p.setEmail(""String_Node_Str"");
  p.setFirstName(""String_Node_Str"");
  p.setLastName(""String_Node_Str"");
  p.setPhone(""String_Node_Str"");
  p.save();
  User personOwner=new User();
  personOwner.setFirstName(""String_Node_Str"");
  personOwner.setLastName(""String_Node_Str"");
  personOwner.setPhone(""String_Node_Str"");
  personOwner.setEntityId(EntityBase.generateNewID());
  personOwner.setPassword(EntityBase.generateNewID());
  personOwner.save();
  Person person=(Person)Person.selectByPersonEmail(""String_Node_Str"");
  Person p1=new Person();
  p1.setEntityAccessStatus(""String_Node_Str"");
  p1.setEntityId(EntityBase.generateNewID());
  p1.setTypeId(0);
  p1.setPhone(""String_Node_Str"");
  p1.setFirstName(""String_Node_Str"");
  assert(person != null);
  p1.setLastName(""String_Node_Str"");
  p1.setEmail(""String_Node_Str"");
  p1.setOwner(personOwner);
  p1.save();
  p.delete(true);
  p1.delete(true);
  Person p6=Person.selectByPersonEmail(""String_Node_Str"");
  assert(p6 == null);
  Person p7=Person.selectByPersonEmail(""String_Node_Str"");
  assert(p7 == null);
}","@Test public void testPerson() throws java.security.NoSuchAlgorithmException, java.io.UnsupportedEncodingException {
  String Id1=EntityBase.generateNewID();
  String Id2=EntityBase.generateNewID();
  String Id3=EntityBase.generateNewID();
  Person p=new Person();
  p.setEntityAccessStatus(""String_Node_Str"");
  p.setEntityId(Id1);
  p.setTypeId(0);
  p.setEmail(""String_Node_Str"");
  p.setFirstName(""String_Node_Str"");
  p.setLastName(""String_Node_Str"");
  p.setPhone(""String_Node_Str"");
  p.save();
  User personOwner=new User();
  personOwner.setFirstName(""String_Node_Str"");
  personOwner.setLastName(""String_Node_Str"");
  personOwner.setEmail(Id2);
  personOwner.setPhone(""String_Node_Str"");
  personOwner.setEntityId(Id2);
  personOwner.setPassword(EntityBase.generateNewID());
  personOwner.save();
  Person person=(Person)Person.selectByID(Id1);
  assert(person != null);
  Person p1=new Person();
  p1.setEntityAccessStatus(""String_Node_Str"");
  p1.setEntityId(Id3);
  p1.setTypeId(0);
  p1.setPhone(""String_Node_Str"");
  p1.setFirstName(""String_Node_Str"");
  p1.setLastName(""String_Node_Str"");
  p1.setEmail(""String_Node_Str"");
  p1.setOwner(personOwner);
  p1.save();
  Person p4=(Person)Person.selectByID(Id3);
  User u1=(User)User.selectByUsername(Id2);
  assert(p4 != null);
  assert(u1 != null);
  p4.delete(true);
  Person p5=(Person)Person.selectByID(Id3);
  assert(p5 == null);
  User u2=(User)User.selectByUsername(Id2);
  assert(u2 != null);
  u2.delete(true);
  p.delete(true);
  Person p6=(Person)Person.selectByID(Id1);
  User u6=(User)User.selectByUsername(Id2);
  assert(p6 == null);
  assert(u6 == null);
}",0.6142905519810362
3690,"@Test public void testPerson() throws java.security.NoSuchAlgorithmException, java.io.UnsupportedEncodingException {
  Person p=new Person();
  p.setEntityAccessStatus(""String_Node_Str"");
  p.setEntityId(EntityBase.generateNewID());
  p.setTypeId(0);
  p.setEmail(""String_Node_Str"");
  p.setFirstName(""String_Node_Str"");
  p.setLastName(""String_Node_Str"");
  p.setPhone(""String_Node_Str"");
  p.save();
  User personOwner=new User();
  personOwner.setFirstName(""String_Node_Str"");
  personOwner.setLastName(""String_Node_Str"");
  personOwner.setPhone(""String_Node_Str"");
  personOwner.setEntityId(EntityBase.generateNewID());
  personOwner.setPassword(EntityBase.generateNewID());
  personOwner.save();
  Person person=(Person)Person.selectByPersonEmail(""String_Node_Str"");
  Person p1=new Person();
  p1.setEntityAccessStatus(""String_Node_Str"");
  p1.setEntityId(EntityBase.generateNewID());
  p1.setTypeId(0);
  p1.setPhone(""String_Node_Str"");
  p1.setFirstName(""String_Node_Str"");
  assert(person != null);
  p1.setLastName(""String_Node_Str"");
  p1.setEmail(""String_Node_Str"");
  p1.setOwner(personOwner);
  p1.save();
  p.delete(true);
  p1.delete(true);
  Person p6=Person.selectByPersonEmail(""String_Node_Str"");
  assert(p6 == null);
  Person p7=Person.selectByPersonEmail(""String_Node_Str"");
  assert(p7 == null);
}","@Test public void testPerson() throws java.security.NoSuchAlgorithmException, java.io.UnsupportedEncodingException {
  String Id1=EntityBase.generateNewID();
  String Id2=EntityBase.generateNewID();
  String Id3=EntityBase.generateNewID();
  Person p=new Person();
  p.setEntityAccessStatus(""String_Node_Str"");
  p.setEntityId(Id1);
  p.setTypeId(0);
  p.setEmail(""String_Node_Str"");
  p.setFirstName(""String_Node_Str"");
  p.setLastName(""String_Node_Str"");
  p.setPhone(""String_Node_Str"");
  p.save();
  User personOwner=new User();
  personOwner.setFirstName(""String_Node_Str"");
  personOwner.setLastName(""String_Node_Str"");
  personOwner.setEmail(Id2);
  personOwner.setPhone(""String_Node_Str"");
  personOwner.setEntityId(Id2);
  personOwner.setPassword(EntityBase.generateNewID());
  personOwner.save();
  Person person=(Person)Person.selectByID(Id1);
  assert(person != null);
  Person p1=new Person();
  p1.setEntityAccessStatus(""String_Node_Str"");
  p1.setEntityId(Id3);
  p1.setTypeId(0);
  p1.setPhone(""String_Node_Str"");
  p1.setFirstName(""String_Node_Str"");
  p1.setLastName(""String_Node_Str"");
  p1.setEmail(""String_Node_Str"");
  p1.setOwner(personOwner);
  p1.save();
  Person p4=(Person)Person.selectByID(Id3);
  User u1=(User)User.selectByUsername(Id2);
  assert(p4 != null);
  assert(u1 != null);
  p4.delete(true);
  Person p5=(Person)Person.selectByID(Id3);
  assert(p5 == null);
  User u2=(User)User.selectByUsername(Id2);
  assert(u2 != null);
  u2.delete(true);
  p.delete(true);
  Person p6=(Person)Person.selectByID(Id1);
  User u6=(User)User.selectByUsername(Id2);
  assert(p6 == null);
  assert(u6 == null);
  ;
}",0.6073723368278661
3691,"@Test public void testPerson() throws java.security.NoSuchAlgorithmException, java.io.UnsupportedEncodingException {
  String Id1=EntityBase.generateNewID();
  String Id2=EntityBase.generateNewID();
  String Id3=EntityBase.generateNewID();
  Person p=new Person();
  p.setEntityAccessStatus(""String_Node_Str"");
  p.setEntityId(Id1);
  p.setTypeId(0);
  p.setEmail(""String_Node_Str"");
  p.setFirstName(""String_Node_Str"");
  p.setLastName(""String_Node_Str"");
  p.setPhone(""String_Node_Str"");
  p.save();
  User personOwner=new User();
  personOwner.setFirstName(""String_Node_Str"");
  personOwner.setLastName(""String_Node_Str"");
  personOwner.setEmail(Id2);
  personOwner.setPhone(""String_Node_Str"");
  personOwner.setEntityId(Id2);
  personOwner.setPassword(EntityBase.generateNewID());
  personOwner.save();
  Person person=(Person)Person.selectByID(Id1);
  assert(person != null);
  Person p1=new Person();
  p1.setEntityAccessStatus(""String_Node_Str"");
  p1.setEntityId(Id3);
  p1.setTypeId(0);
  p1.setPhone(""String_Node_Str"");
  p1.setFirstName(""String_Node_Str"");
  p1.setLastName(""String_Node_Str"");
  p1.setEmail(""String_Node_Str"");
  p1.setOwner(personOwner);
  p1.save();
  Person p4=(Person)Person.selectByID(Id3);
  User u1=(User)User.selectByUsername(Id2);
  assert(p4 != null);
  assert(u1 != null);
  p4.delete(true);
  Person p5=(Person)Person.selectByID(Id3);
  assert(p5 == null);
  User u2=(User)User.selectByUsername(Id2);
  assert(u2 != null);
  u2.delete(true);
  p.delete(true);
  Person p6=(Person)Person.selectByID(Id1);
  User u6=(User)User.selectByUsername(Id2);
  assert(p6 == null);
  assert(u6 == null);
  ;
}","@Test public void testPerson() throws java.security.NoSuchAlgorithmException, java.io.UnsupportedEncodingException {
  String Id1=EntityBase.generateNewID();
  String Id2=EntityBase.generateNewID();
  String Id3=EntityBase.generateNewID();
  Person p=new Person();
  p.setEntityAccessStatus(""String_Node_Str"");
  p.setEntityId(Id1);
  p.setTypeId(0);
  p.setEmail(""String_Node_Str"");
  p.setFirstName(""String_Node_Str"");
  p.setLastName(""String_Node_Str"");
  p.setPhone(""String_Node_Str"");
  p.save();
  User personOwner=new User();
  personOwner.setFirstName(""String_Node_Str"");
  personOwner.setLastName(""String_Node_Str"");
  personOwner.setEmail(Id2);
  personOwner.setPhone(""String_Node_Str"");
  personOwner.setEntityId(Id2);
  personOwner.setPassword(EntityBase.generateNewID());
  personOwner.save();
  Person person=(Person)Person.selectByID(Id1);
  assert(person != null);
  Person p1=new Person();
  p1.setEntityAccessStatus(""String_Node_Str"");
  p1.setEntityId(Id3);
  p1.setTypeId(0);
  p1.setPhone(""String_Node_Str"");
  p1.setFirstName(""String_Node_Str"");
  p1.setLastName(""String_Node_Str"");
  p1.setEmail(""String_Node_Str"");
  p1.setOwner(personOwner);
  p1.save();
  Person p4=(Person)Person.selectByID(Id3);
  User u1=(User)User.selectByUsername(Id2);
  assert(p4 != null);
  assert(u1 != null);
  p4.delete(true);
  Person p5=(Person)Person.selectByID(Id3);
  assert(p5 == null);
  User u2=(User)User.selectByUsername(Id2);
  assert(u2 != null);
  u2.delete(true);
  p.delete(true);
  Person p6=(Person)Person.selectByID(Id1);
  User u6=(User)User.selectByUsername(Id2);
  assert(p6 == null);
  assert(u6 == null);
}",0.998776758409786
3692,"@Path(""String_Node_Str"") @PUT @Consumes(""String_Node_Str"") public String addUser(String json){
  String strName=null;
  try {
    JSONObject content=new JSONObject(json);
    User u=new User();
    u.createNewID();
    if (content.getString(""String_Node_Str"") != null) {
      u.setFirstName(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setLastName(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setPhone(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setPhone(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setPassword(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setEmail(content.getString(""String_Node_Str""));
    }
 else {
      return ""String_Node_Str"";
    }
    u.save();
    strName=(String)content.get(""String_Node_Str"");
  }
 catch (  Exception ex) {
    return ex.toString();
  }
  return ""String_Node_Str"" + strName;
}","@Path(""String_Node_Str"") @PUT @Consumes(""String_Node_Str"") public String addUser(String json){
  String strName=null;
  try {
    JSONObject content=new JSONObject(json);
    User u=new User();
    u.createNewID();
    if (content.getString(""String_Node_Str"") != null) {
      u.setFirstName(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setLastName(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setPhone(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setEmail(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setPassword(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setUserName(content.getString(""String_Node_Str""));
    }
 else {
      return ""String_Node_Str"";
    }
    u.save();
    strName=(String)content.get(""String_Node_Str"");
  }
 catch (  Exception ex) {
    return ex.toString();
  }
  return ""String_Node_Str"" + strName;
}",0.9908336970755128
3693,"/** 
 * Post method for updating an instance of UserResource
 * @param content representation for the resource
 * @return an HTTP response with content of the  created resource.
 */
@Path(""String_Node_Str"") @POST @Consumes(""String_Node_Str"") public String updateUser(@PathParam(""String_Node_Str"") String astrEmail,String json){
  String strName=null;
  try {
    JSONObject content=new JSONObject(json);
    User u=User.selectByUsername(astrEmail);
    if (content.getString(""String_Node_Str"") != null) {
      u.setFirstName(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setLastName(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setPhone(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setPassword(content.getString(""String_Node_Str""));
    }
    u.save();
    User uUpdated=User.selectByUsername(content.getString(""String_Node_Str""));
    strName=uUpdated.getFirstName();
  }
 catch (  Exception ex) {
    return ex.toString();
  }
  return ""String_Node_Str"" + strName;
}","/** 
 * Post method for updating an instance of UserResource
 * @param content representation for the resource
 * @return an HTTP response with content of the  created resource.
 */
@Path(""String_Node_Str"") @POST @Consumes(""String_Node_Str"") public String updateUser(@PathParam(""String_Node_Str"") String astrEmail,String json){
  String strName=null;
  try {
    JSONObject content=new JSONObject(json);
    User u=User.selectByUsername(astrEmail);
    if (content.getString(""String_Node_Str"") != null) {
      u.setFirstName(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setLastName(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setPhone(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setPassword(content.getString(""String_Node_Str""));
    }
    if (content.getString(""String_Node_Str"") != null) {
      u.setEmail(content.getString(""String_Node_Str""));
    }
    u.save();
    User uUpdated=User.selectByUsername(content.getString(""String_Node_Str""));
    strName=uUpdated.getFirstName();
  }
 catch (  Exception ex) {
    return ex.toString();
  }
  return ""String_Node_Str"" + strName;
}",0.951599671862182
3694,"@Path(""String_Node_Str"") @DELETE public String deletePerson(@QueryParam(""String_Node_Str"") String PersonEmail){
{
    String EML=null;
    try {
      JSONObject content=new JSONObject(PersonEmail);
      EML=content.toString();
      System.out.println(""String_Node_Str"" + content.getString(""String_Node_Str""));
      Person person=Person.selectByPersonEmail(content.getString(""String_Node_Str""));
      person.delete(true);
      return (""String_Node_Str"");
    }
 catch (    Exception E) {
      return (EML);
    }
  }
}","@Path(""String_Node_Str"") @DELETE public String deletePerson(@PathParam(""String_Node_Str"") String id){
{
    try {
      System.out.println(""String_Node_Str"" + id);
      Person person=(Person)EntityBase.selectByID(id);
      if (person instanceof User) {
        return ""String_Node_Str"";
      }
      if (person == null) {
        return ""String_Node_Str"";
      }
      person.delete(true);
      return (""String_Node_Str"");
    }
 catch (    Exception E) {
      return (E.getMessage());
    }
  }
}",0.5666991236611489
3695,"/** 
 * Update the clock time fields.
 * @param hourOfDay 24-hr clock time hour field
 * @param minutes   clock time minutes field
 */
public void updateTime(int hourOfDay,int minutes){
  this.hourOfDay=hourOfDay;
  this.minutes=minutes;
}","/** 
 * Update the clock time fields.
 * @param hourOfDay 24-hr clock time hour field
 * @param minutes   clock time minutes field
 */
public void updateTime(int hourOfDay,int minutes){
  this.mHourOfDay=hourOfDay;
  this.mMinutes=minutes;
}",0.9916666666666668
3696,"public int getHourOfDay(){
  return hourOfDay;
}","public int getHourOfDay(){
  return mHourOfDay;
}",0.9690721649484536
3697,"@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(hourOfDay);
  dest.writeInt(minutes);
}","@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(mHourOfDay);
  dest.writeInt(mMinutes);
}",0.9827586206896552
3698,"public int getMinutes(){
  return minutes;
}","public int getMinutes(){
  return mMinutes;
}",0.9887640449438202
3699,"private void enableAlarm(){
  Intent innerIntent=new Intent(Intent.ACTION_VIEW,songUri);
  innerIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  lastAlarmIntent=PendingIntent.getActivity(this,0,innerIntent,PendingIntent.FLAG_CANCEL_CURRENT);
  getAlarmManager().setRepeating(AlarmManager.RTC_WAKEUP,alarmTimestamp,AlarmManager.INTERVAL_DAY,lastAlarmIntent);
  showToast(R.string.info_alarm_enabled);
}","private void enableAlarm(){
  Intent innerIntent=new Intent(Intent.ACTION_VIEW,songUri);
  innerIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  lastAlarmIntent=PendingIntent.getActivity(this,0,innerIntent,PendingIntent.FLAG_CANCEL_CURRENT);
  getAlarmManager().setRepeating(AlarmManager.RTC_WAKEUP,alarmTime.toTimestamp(),AlarmManager.INTERVAL_DAY,lastAlarmIntent);
  showToast(R.string.info_alarm_enabled);
}",0.988929889298893
3700,"public SongAlarmActivity(){
  alarmTimestamp=NO_ALARM_TIME_SET;
  alarmTime=null;
  lastAlarmIntent=null;
  songUri=null;
}","public SongAlarmActivity(){
  alarmTime=null;
  lastAlarmIntent=null;
  songUri=null;
}",0.8285714285714286
3701,"@Override public boolean onPreferenceChange(Preference pref,Object newValue){
  boolean allowChange=false;
  if (mAlarmEnabledPref == pref) {
    boolean enableAlarm=((Boolean)newValue).booleanValue();
    if (enableAlarm) {
      if (NO_ALARM_TIME_SET == alarmTimestamp) {
        showToast(R.string.error_no_time_set);
      }
 else       if (null == songUri) {
        showToast(R.string.error_no_song_set);
      }
 else {
        enableAlarm();
        allowChange=true;
      }
    }
 else {
      getAlarmManager().cancel(lastAlarmIntent);
      showToast(R.string.info_alarm_disabled);
      allowChange=true;
      lastAlarmIntent=null;
    }
  }
  return allowChange;
}","@Override public boolean onPreferenceChange(Preference pref,Object newValue){
  boolean allowChange=false;
  if (mAlarmEnabledPref == pref) {
    boolean enableAlarm=((Boolean)newValue).booleanValue();
    if (enableAlarm) {
      if (null == alarmTime) {
        showToast(R.string.error_no_time_set);
      }
 else       if (null == songUri) {
        showToast(R.string.error_no_song_set);
      }
 else {
        enableAlarm();
        allowChange=true;
      }
    }
 else {
      getAlarmManager().cancel(lastAlarmIntent);
      showToast(R.string.info_alarm_disabled);
      allowChange=true;
      lastAlarmIntent=null;
    }
  }
  return allowChange;
}",0.3925373134328358
3702,"private void updateTimeSummary(){
  if (null == alarmTime) {
    return;
  }
  Calendar cal=Calendar.getInstance();
  cal.setTimeInMillis(System.currentTimeMillis());
  int currentHourOfDay=cal.get(Calendar.HOUR_OF_DAY), currentMinutes=cal.get(Calendar.MINUTE);
  int hourOfDay=alarmTime.getHourOfDay(), minutes=alarmTime.getMinutes();
  if (currentHourOfDay > hourOfDay || (currentHourOfDay == hourOfDay && currentMinutes > minutes)) {
    cal.add(Calendar.DAY_OF_YEAR,1);
  }
  cal.set(Calendar.MILLISECOND,0);
  cal.set(Calendar.SECOND,0);
  cal.set(Calendar.HOUR_OF_DAY,hourOfDay);
  cal.set(Calendar.MINUTE,minutes);
  alarmTimestamp=cal.getTimeInMillis();
  mAlarmTimePref.setSummary(DateFormat.format(getResources().getString(R.string.date_format_alarm_time),cal));
}","private void updateTimeSummary(){
  if (null == alarmTime) {
    return;
  }
  Calendar cal=Calendar.getInstance();
  cal.setTimeInMillis(alarmTime.toTimestamp());
  mAlarmTimePref.setSummary(DateFormat.format(getResources().getString(R.string.date_format_alarm_time),cal));
}",0.2819047619047619
3703,"@Override public boolean onPreferenceChange(Preference pref,Object newValue){
  boolean allowChange=false;
  if (mAlarmEnabledPref == pref) {
    boolean enableAlarm=((Boolean)newValue).booleanValue();
    if (enableAlarm) {
      if (NO_ALARM_TIME_SET == alarmTimestamp) {
        showToast(R.string.error_no_time_set);
      }
 else       if (null == songUri) {
        showToast(R.string.error_no_song_set);
      }
 else {
        enableAlarm();
        allowChange=true;
      }
    }
 else {
      getAlarmManager().cancel(lastAlarmIntent);
      showToast(R.string.info_alarm_disabled);
      allowChange=true;
      alarmTimestamp=NO_ALARM_TIME_SET;
      lastAlarmIntent=null;
    }
  }
  return allowChange;
}","@Override public boolean onPreferenceChange(Preference pref,Object newValue){
  boolean allowChange=false;
  if (mAlarmEnabledPref == pref) {
    boolean enableAlarm=((Boolean)newValue).booleanValue();
    if (enableAlarm) {
      if (NO_ALARM_TIME_SET == alarmTimestamp) {
        showToast(R.string.error_no_time_set);
      }
 else       if (null == songUri) {
        showToast(R.string.error_no_song_set);
      }
 else {
        enableAlarm();
        allowChange=true;
      }
    }
 else {
      getAlarmManager().cancel(lastAlarmIntent);
      showToast(R.string.info_alarm_disabled);
      allowChange=true;
      lastAlarmIntent=null;
    }
  }
  return allowChange;
}",0.9585121602288984
3704,"@Override protected void configure(){
  binder().install(new LimeWireCommonModule());
  binder().install(new LimeWireCoreSettingsModule());
  binder().install(new LimeWireSettingsModule());
  binder().install(new LimeWireNetModule(SettingsBackedProxySettings.class,SettingsBackedSocketBindingSettings.class));
  binder().install(new LimeWireDownloadModule());
  binder().install(new LimeWireHashTreeModule());
  binder().install(new LimeWireDHTModule());
  binder().install(new LimeWireActivationModule());
  binder().install(new LimeWireHttpModule());
  binder().install(new LimeWireSearchModule());
  binder().install(new LimeWireStatisticsModule());
  binder().install(new LimeWireGnutellaStatisticsModule());
  binder().install(new LimeWireGnutellaRudpModule());
  binder().install(new LimeWireIOModule());
  binder().install(new LimeWireMojitoModule());
  binder().install(new LimeWireSecurityCertificateModule());
  binder().install(new LimewireGeocodeModule());
  binder().install(new LimeWirePromotionModule(PromotionBinderRequestorImpl.class,PromotionServicesImpl.class));
  binder().install(new LimeWireSecurityModule());
  binder().install(new LimeWireSimppModule());
  binder().install(new LimeWireUpdateModule());
  binder().install(new LimeWireBittorrentModule());
  binder().install(new LimeWireLibraryModule());
  binder().install(new LimeWireUploaderModule());
  binder().install(new LimeWireContentAuthModule());
  binder().install(new LimeWireFiltersModule());
  binder().install(new LimeWireSpamModule());
  binder().install(new LimeWireCoreConnectionModule());
  binder().install(new LimeWireBootstrapModule());
  binder().install(new LimeWireMalwareModule());
  binder().install(new LimeWireXmlModule());
  binder().install(new LimeWireLWSModule());
  if (activityCallbackClass != null) {
    bind(ActivityCallback.class).to(activityCallbackClass);
  }
  bind(HttpClientInstanceUtils.class).to(LimeWireInfo.class);
  bind(ActivationSettingsController.class).to(ActivationSettingsImpl.class);
  bind(DownloadCallback.class).to(ActivityCallback.class);
  bind(NetworkManager.class).to(NetworkManagerImpl.class);
  bind(TLSManager.class).to(NetworkManagerImpl.class);
  bind(new TypeLiteral<ListenerSupport<AddressEvent>>(){
  }
).to(NetworkManagerImpl.class);
  bind(DHTManager.class).to(DHTManagerImpl.class);
  bind(DHTControllerFactory.class).to(DHTControllerFactoryImpl.class);
  bind(PingReplyFactory.class).to(PingReplyFactoryImpl.class);
  bind(PushProxiesValueFactory.class).to(PushProxiesValueFactoryImpl.class);
  bind(HandshakeResponderFactory.class).to(HandshakeResponderFactoryImpl.class);
  bind(HeadersFactory.class).to(HeadersFactoryImpl.class);
  bind(PushEndpointFactory.class).to(PushEndpointFactoryImpl.class);
  bind(HeadPongFactory.class).to(HeadPongFactoryImpl.class);
  bind(UploadManager.class).to(HTTPUploadManager.class);
  bind(HTTPUploadSessionManager.class).to(HTTPUploadManager.class);
  bind(QueryHandlerFactory.class).to(QueryHandlerFactoryImpl.class);
  bind(QueryRequestFactory.class).to(QueryRequestFactoryImpl.class);
  bind(AltLocValueFactory.class).to(AltLocValueFactoryImpl.class);
  bind(AlternateLocationFactory.class).to(AlternateLocationFactoryImpl.class);
  bind(HttpExecutor.class).to(DefaultHttpExecutor.class);
  bind(HttpRequestHandlerFactory.class).to(HttpRequestHandlerFactoryImpl.class);
  bind(ResponseFactory.class).to(ResponseFactoryImpl.class);
  bind(QueryReplyFactory.class).to(QueryReplyFactoryImpl.class);
  bind(MessageDispatcherFactory.class).to(LimeMessageDispatcherFactoryImpl.class);
  bind(CapabilitiesVMFactory.class).to(CapabilitiesVMFactoryImpl.class);
  bind(LifecycleManager.class).to(LifecycleManagerImpl.class);
  bind(LocalPongInfo.class).to(LocalPongInfoImpl.class);
  bind(ConnectionServices.class).to(ConnectionServicesImpl.class);
  bind(SearchServices.class).to(SearchServicesImpl.class);
  bind(DownloadServices.class).to(DownloadServicesImpl.class);
  bind(UploadServices.class).to(UploadServicesImpl.class);
  bind(ApplicationServices.class).to(ApplicationServicesImpl.class);
  bind(SpamServices.class).to(SpamServicesImpl.class);
  bind(DHTControllerFacade.class).to(DHTControllerFacadeImpl.class);
  bind(DHTBootstrapperFactory.class).to(DHTBootstrapperFactoryImpl.class);
  bind(DHTNodeFetcherFactory.class).to(DHTNodeFetcherFactoryImpl.class);
  bind(UDPReplyHandlerFactory.class).to(UDPReplyHandlerFactoryImpl.class);
  bind(UDPReplyHandlerCache.class).to(UDPReplyHandlerCacheImpl.class);
  bind(SocketProcessor.class).to(Acceptor.class);
  bind(DownloadManager.class).to(DownloadManagerImpl.class).asEagerSingleton();
  bind(BrowseHostHandlerManagerImpl.class).asEagerSingleton();
  bind(ReplyNumberVendorMessageFactory.class).to(ReplyNumberVendorMessageFactoryImpl.class);
  bind(GuidMapManager.class).to(GuidMapManagerImpl.class);
  bind(BrowseHostHandlerManager.class).to(BrowseHostHandlerManagerImpl.class);
  bind(PushEndpointCache.class).to(PushEndpointCacheImpl.class);
  bind(PushEndpointService.class).annotatedWith(Names.named(""String_Node_Str"")).to(PushEndpointCacheImpl.class);
  bind(FileResponseEntityFactory.class).to(FileResponseEntityFactoryImpl.class);
  bind(MessageFactory.class).to(MessageFactoryImpl.class);
  bind(MessageParserBinder.class).to(MessageParserBinderImpl.class);
  bind(VendorMessageFactory.class).to(VendorMessageFactoryImpl.class);
  bind(VendorMessageParserBinder.class).to(VendorMessageParserBinderImpl.class);
  bind(UDPCrawlerPongFactory.class).to(UDPCrawlerPongFactoryImpl.class);
  bind(LicenseFactory.class).to(LicenseFactoryImpl.class);
  bind(MetaDataFactory.class).to(MetaDataFactoryImpl.class);
  bind(SaveLocationManager.class).to(DownloadManager.class);
  bind(BTUploaderFactory.class).to(TorrentUploadManager.class);
  bind(PingRequestFactory.class).to(PingRequestFactoryImpl.class);
  bind(IpPortContentAuthorityFactory.class).to(IpPortContentAuthorityFactoryImpl.class);
  bind(UpdateCollectionFactory.class).to(UpdateCollectionFactoryImpl.class);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(UDPPinger.class).to(UDPPingerImpl.class);
  bind(Inspector.class).to(InspectorImpl.class);
  bind(LWSManager.class).to(LWSManagerImpl.class);
  bind(LWSIntegrationServicesDelegate.class).to(DownloadManager.class);
  bind(LocalSocketAddressProvider.class).to(LocalSocketAddressProviderImpl.class);
  bind(SettingsProvider.class).to(MacCalculatorSettingsProviderImpl.class);
  bind(ReplyHandler.class).annotatedWith(Names.named(""String_Node_Str"")).to(ForMeReplyHandler.class);
  bind(MessageRouter.class).to(StandardMessageRouter.class);
  bind(UploadSlotManager.class).to(UploadSlotManagerImpl.class);
  bind(BandwidthManager.class).to(BandwidthManagerImpl.class);
  bind(PongCacher.class).to(PongCacherImpl.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(UploadManager.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(DownloadManager.class);
  bind(ResponseVerifier.class).to(ResponseVerifierImpl.class);
  bind(HandshakeServices.class).to(HandshakeServicesImpl.class);
  bind(ConnectionManager.class).to(ConnectionManagerImpl.class);
  bind(MessageHandlerBinder.class).to(MessageHandlerBinderImpl.class);
  bind(QueryDispatcher.class).to(QueryDispatcherImpl.class);
  bind(Acceptor.class).to(AcceptorImpl.class);
  bind(UpdateHandler.class).to(UpdateHandlerImpl.class);
  bind(SecurityToken.TokenProvider.class).to(SecurityToken.AddressSecurityTokenProvider.class);
  bind(UpdateMessageVerifier.class).to(UpdateMessageVerifierImpl.class);
  bind(InspectionResponseFactory.class).to(InspectionResponseFactoryImpl.class);
  bind(FECUtils.class).to(FECUtilsImpl.class);
  bind(BandwidthCollector.class).to(BandwidthCollectorImpl.class);
  bind(BandwidthCollectorDriver.class).to(BandwidthCollectorImpl.class);
  bind(NodeAssigner.class).to(NodeAssignerImpl.class);
  bind(OutgoingQueryReplyFactory.class).to(OutgoingQueryReplyFactoryImpl.class);
  bind(UPnPManagerConfiguration.class).to(UPnPManagerConfigurationImpl.class);
  bind(Bootstrapper.Listener.class).to(HostCatcher.class);
  bind(RareFileStrategy.class).to(RareFileStrategyImpl.class);
  bind(MulticastService.class).to(MulticastServiceImpl.class);
  bind(CategoryManager.class).to(CategoryManagerImpl.class);
  bind(TorrentScrapeScheduler.class).to(TorrentScrapeSchedulerImpl.class);
  bind(TorrentTrackerScraper.class).to(TorrentTrackerScraperImpl.class);
  Executor fwtEventExecutor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  AsynchronousCachingEventMulticasterImpl<FirewallTransferStatusEvent> asyncTransferMulticaster=new AsynchronousCachingEventMulticasterImpl<FirewallTransferStatusEvent>(fwtEventExecutor,BroadcastPolicy.IF_NOT_EQUALS);
  bind(new TypeLiteral<EventBean<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  bind(new TypeLiteral<AsynchronousEventBroadcaster<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  bind(new TypeLiteral<ListenerSupport<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  AsynchronousCachingEventMulticasterImpl<FirewallStatusEvent> asyncStatusMulticaster=new AsynchronousCachingEventMulticasterImpl<FirewallStatusEvent>(fwtEventExecutor,BroadcastPolicy.IF_NOT_EQUALS);
  bind(new TypeLiteral<EventBean<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(new TypeLiteral<AsynchronousEventBroadcaster<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(new TypeLiteral<ListenerSupport<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(Statistics.class);
  bind(CoreRandomGlue.class);
  bind(ConnectionAcceptorGlue.class);
  bind(DownloadUpgradeTaskService.class);
  bind(LocalAcceptor.class);
  bind(Pinger.class);
  bind(ConnectionWatchdog.class);
  bind(OutOfBandThroughputMeasurer.class);
  bind(HostCatcher.class);
  bind(LimeCoreGlue.class);
  bind(QRPUpdater.class);
  bind(DaapManager.class);
  bind(FirewalledAddressSerializer.class).asEagerSingleton();
  bind(SameNATAddressResolver.class).asEagerSingleton();
  bind(ConnectableConnector.class).asEagerSingleton();
  bind(PushEndpointSerializer.class).asEagerSingleton();
  bind(SecureIdStore.class).to(SecureIdDatabaseStore.class);
}","@Override protected void configure(){
  binder().install(new LimeWireCommonModule());
  binder().install(new LimeWireCoreSettingsModule());
  binder().install(new LimeWireSettingsModule());
  binder().install(new LimeWireNetModule(SettingsBackedProxySettings.class,SettingsBackedSocketBindingSettings.class));
  binder().install(new LimeWireDownloadModule());
  binder().install(new LimeWireHashTreeModule());
  binder().install(new LimeWireDHTModule());
  binder().install(new LimeWireActivationModule());
  binder().install(new LimeWireHttpModule());
  binder().install(new LimeWireSearchModule());
  binder().install(new LimeWireStatisticsModule());
  binder().install(new LimeWireGnutellaStatisticsModule());
  binder().install(new LimeWireGnutellaRudpModule());
  binder().install(new LimeWireIOModule());
  binder().install(new LimeWireMojitoModule());
  binder().install(new LimeWireSecurityCertificateModule());
  binder().install(new LimewireGeocodeModule());
  binder().install(new LimeWirePromotionModule(PromotionBinderRequestorImpl.class,PromotionServicesImpl.class));
  binder().install(new LimeWireSecurityModule());
  binder().install(new LimeWireSimppModule());
  binder().install(new LimeWireUpdateModule());
  binder().install(new LimeWireBittorrentModule());
  binder().install(new LimeWireLibraryModule());
  binder().install(new LimeWireUploaderModule());
  binder().install(new LimeWireContentAuthModule());
  binder().install(new LimeWireFiltersModule());
  binder().install(new LimeWireSpamModule());
  binder().install(new LimeWireCoreConnectionModule());
  binder().install(new LimeWireBootstrapModule());
  binder().install(new LimeWireMalwareModule());
  binder().install(new LimeWireXmlModule());
  binder().install(new LimeWireLWSModule());
  if (activityCallbackClass != null) {
    bind(ActivityCallback.class).to(activityCallbackClass);
  }
  bind(HttpClientInstanceUtils.class).to(LimeWireInfo.class);
  bind(LWSNetworkAdapter.class).to(LWSNetworkAdapterImpl.class);
  bind(ActivationSettingsController.class).to(ActivationSettingsImpl.class);
  bind(DownloadCallback.class).to(ActivityCallback.class);
  bind(NetworkManager.class).to(NetworkManagerImpl.class);
  bind(TLSManager.class).to(NetworkManagerImpl.class);
  bind(new TypeLiteral<ListenerSupport<AddressEvent>>(){
  }
).to(NetworkManagerImpl.class);
  bind(DHTManager.class).to(DHTManagerImpl.class);
  bind(DHTControllerFactory.class).to(DHTControllerFactoryImpl.class);
  bind(PingReplyFactory.class).to(PingReplyFactoryImpl.class);
  bind(PushProxiesValueFactory.class).to(PushProxiesValueFactoryImpl.class);
  bind(HandshakeResponderFactory.class).to(HandshakeResponderFactoryImpl.class);
  bind(HeadersFactory.class).to(HeadersFactoryImpl.class);
  bind(PushEndpointFactory.class).to(PushEndpointFactoryImpl.class);
  bind(HeadPongFactory.class).to(HeadPongFactoryImpl.class);
  bind(UploadManager.class).to(HTTPUploadManager.class);
  bind(HTTPUploadSessionManager.class).to(HTTPUploadManager.class);
  bind(QueryHandlerFactory.class).to(QueryHandlerFactoryImpl.class);
  bind(QueryRequestFactory.class).to(QueryRequestFactoryImpl.class);
  bind(AltLocValueFactory.class).to(AltLocValueFactoryImpl.class);
  bind(AlternateLocationFactory.class).to(AlternateLocationFactoryImpl.class);
  bind(HttpExecutor.class).to(DefaultHttpExecutor.class);
  bind(HttpRequestHandlerFactory.class).to(HttpRequestHandlerFactoryImpl.class);
  bind(ResponseFactory.class).to(ResponseFactoryImpl.class);
  bind(QueryReplyFactory.class).to(QueryReplyFactoryImpl.class);
  bind(MessageDispatcherFactory.class).to(LimeMessageDispatcherFactoryImpl.class);
  bind(CapabilitiesVMFactory.class).to(CapabilitiesVMFactoryImpl.class);
  bind(LifecycleManager.class).to(LifecycleManagerImpl.class);
  bind(LocalPongInfo.class).to(LocalPongInfoImpl.class);
  bind(ConnectionServices.class).to(ConnectionServicesImpl.class);
  bind(SearchServices.class).to(SearchServicesImpl.class);
  bind(DownloadServices.class).to(DownloadServicesImpl.class);
  bind(UploadServices.class).to(UploadServicesImpl.class);
  bind(ApplicationServices.class).to(ApplicationServicesImpl.class);
  bind(SpamServices.class).to(SpamServicesImpl.class);
  bind(DHTControllerFacade.class).to(DHTControllerFacadeImpl.class);
  bind(DHTBootstrapperFactory.class).to(DHTBootstrapperFactoryImpl.class);
  bind(DHTNodeFetcherFactory.class).to(DHTNodeFetcherFactoryImpl.class);
  bind(UDPReplyHandlerFactory.class).to(UDPReplyHandlerFactoryImpl.class);
  bind(UDPReplyHandlerCache.class).to(UDPReplyHandlerCacheImpl.class);
  bind(SocketProcessor.class).to(Acceptor.class);
  bind(DownloadManager.class).to(DownloadManagerImpl.class).asEagerSingleton();
  bind(BrowseHostHandlerManagerImpl.class).asEagerSingleton();
  bind(ReplyNumberVendorMessageFactory.class).to(ReplyNumberVendorMessageFactoryImpl.class);
  bind(GuidMapManager.class).to(GuidMapManagerImpl.class);
  bind(BrowseHostHandlerManager.class).to(BrowseHostHandlerManagerImpl.class);
  bind(PushEndpointCache.class).to(PushEndpointCacheImpl.class);
  bind(PushEndpointService.class).annotatedWith(Names.named(""String_Node_Str"")).to(PushEndpointCacheImpl.class);
  bind(FileResponseEntityFactory.class).to(FileResponseEntityFactoryImpl.class);
  bind(MessageFactory.class).to(MessageFactoryImpl.class);
  bind(MessageParserBinder.class).to(MessageParserBinderImpl.class);
  bind(VendorMessageFactory.class).to(VendorMessageFactoryImpl.class);
  bind(VendorMessageParserBinder.class).to(VendorMessageParserBinderImpl.class);
  bind(UDPCrawlerPongFactory.class).to(UDPCrawlerPongFactoryImpl.class);
  bind(LicenseFactory.class).to(LicenseFactoryImpl.class);
  bind(MetaDataFactory.class).to(MetaDataFactoryImpl.class);
  bind(SaveLocationManager.class).to(DownloadManager.class);
  bind(BTUploaderFactory.class).to(TorrentUploadManager.class);
  bind(PingRequestFactory.class).to(PingRequestFactoryImpl.class);
  bind(IpPortContentAuthorityFactory.class).to(IpPortContentAuthorityFactoryImpl.class);
  bind(UpdateCollectionFactory.class).to(UpdateCollectionFactoryImpl.class);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(UDPPinger.class).to(UDPPingerImpl.class);
  bind(Inspector.class).to(InspectorImpl.class);
  bind(LWSManager.class).to(LWSManagerImpl.class);
  bind(LWSIntegrationServicesDelegate.class).to(DownloadManager.class);
  bind(LocalSocketAddressProvider.class).to(LocalSocketAddressProviderImpl.class);
  bind(SettingsProvider.class).to(MacCalculatorSettingsProviderImpl.class);
  bind(ReplyHandler.class).annotatedWith(Names.named(""String_Node_Str"")).to(ForMeReplyHandler.class);
  bind(MessageRouter.class).to(StandardMessageRouter.class);
  bind(UploadSlotManager.class).to(UploadSlotManagerImpl.class);
  bind(BandwidthManager.class).to(BandwidthManagerImpl.class);
  bind(PongCacher.class).to(PongCacherImpl.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(UploadManager.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(DownloadManager.class);
  bind(ResponseVerifier.class).to(ResponseVerifierImpl.class);
  bind(HandshakeServices.class).to(HandshakeServicesImpl.class);
  bind(ConnectionManager.class).to(ConnectionManagerImpl.class);
  bind(MessageHandlerBinder.class).to(MessageHandlerBinderImpl.class);
  bind(QueryDispatcher.class).to(QueryDispatcherImpl.class);
  bind(Acceptor.class).to(AcceptorImpl.class);
  bind(UpdateHandler.class).to(UpdateHandlerImpl.class);
  bind(SecurityToken.TokenProvider.class).to(SecurityToken.AddressSecurityTokenProvider.class);
  bind(UpdateMessageVerifier.class).to(UpdateMessageVerifierImpl.class);
  bind(InspectionResponseFactory.class).to(InspectionResponseFactoryImpl.class);
  bind(FECUtils.class).to(FECUtilsImpl.class);
  bind(BandwidthCollector.class).to(BandwidthCollectorImpl.class);
  bind(BandwidthCollectorDriver.class).to(BandwidthCollectorImpl.class);
  bind(NodeAssigner.class).to(NodeAssignerImpl.class);
  bind(OutgoingQueryReplyFactory.class).to(OutgoingQueryReplyFactoryImpl.class);
  bind(UPnPManagerConfiguration.class).to(UPnPManagerConfigurationImpl.class);
  bind(Bootstrapper.Listener.class).to(HostCatcher.class);
  bind(RareFileStrategy.class).to(RareFileStrategyImpl.class);
  bind(MulticastService.class).to(MulticastServiceImpl.class);
  bind(CategoryManager.class).to(CategoryManagerImpl.class);
  bind(TorrentScrapeScheduler.class).to(TorrentScrapeSchedulerImpl.class);
  bind(TorrentTrackerScraper.class).to(TorrentTrackerScraperImpl.class);
  Executor fwtEventExecutor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  AsynchronousCachingEventMulticasterImpl<FirewallTransferStatusEvent> asyncTransferMulticaster=new AsynchronousCachingEventMulticasterImpl<FirewallTransferStatusEvent>(fwtEventExecutor,BroadcastPolicy.IF_NOT_EQUALS);
  bind(new TypeLiteral<EventBean<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  bind(new TypeLiteral<AsynchronousEventBroadcaster<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  bind(new TypeLiteral<ListenerSupport<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  AsynchronousCachingEventMulticasterImpl<FirewallStatusEvent> asyncStatusMulticaster=new AsynchronousCachingEventMulticasterImpl<FirewallStatusEvent>(fwtEventExecutor,BroadcastPolicy.IF_NOT_EQUALS);
  bind(new TypeLiteral<EventBean<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(new TypeLiteral<AsynchronousEventBroadcaster<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(new TypeLiteral<ListenerSupport<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(Statistics.class);
  bind(CoreRandomGlue.class);
  bind(ConnectionAcceptorGlue.class);
  bind(DownloadUpgradeTaskService.class);
  bind(LocalAcceptor.class);
  bind(Pinger.class);
  bind(ConnectionWatchdog.class);
  bind(OutOfBandThroughputMeasurer.class);
  bind(HostCatcher.class);
  bind(LimeCoreGlue.class);
  bind(QRPUpdater.class);
  bind(DaapManager.class);
  bind(FirewalledAddressSerializer.class).asEagerSingleton();
  bind(SameNATAddressResolver.class).asEagerSingleton();
  bind(ConnectableConnector.class).asEagerSingleton();
  bind(PushEndpointSerializer.class).asEagerSingleton();
  bind(SecureIdStore.class).to(SecureIdDatabaseStore.class);
}",0.9969248237687468
3705,"@Override public void applySettings(){
  SwingUiSettings.HANDLE_MAGNETS.setValue(associationFileTypeCheckBox.isSelected());
  LimeAssociationOption magnetAssociationOption=LimeAssociations.getMagnetAssociation();
  if (magnetAssociationOption != null) {
    magnetAssociationOption.setEnabled(associationFileTypeCheckBox.isSelected());
  }
  SwingUiSettings.HANDLE_TORRENTS.setValue(associationFileTypeCheckBox.isSelected());
  LimeAssociationOption torrentAssociationOption=LimeAssociations.getTorrentAssociation();
  if (torrentAssociationOption != null) {
    torrentAssociationOption.setEnabled(associationFileTypeCheckBox.isSelected());
  }
  InstallSettings.ASSOCIATION_OPTION.setValue(2);
  if (shouldShowStartOnStartupWindow()) {
    if (OSUtils.isMacOSX())     MacOSXUtils.setLoginStatus(launchAtStartupCheckBox.isSelected());
 else     if (WindowsUtils.isLoginStatusAvailable())     BackgroundExecutorService.execute(new Runnable(){
      @Override public void run(){
        WindowsUtils.setLoginStatus(launchAtStartupCheckBox.isSelected());
      }
    }
);
    StartupSettings.RUN_ON_STARTUP.setValue(launchAtStartupCheckBox.isSelected());
  }
 else   StartupSettings.RUN_ON_STARTUP.setValue(false);
  InstallSettings.START_STARTUP.setValue(true);
  ApplicationSettings.ALLOW_ANONYMOUS_STATISTICS_GATHERING.setValue(shareUsageDataCheckBox.isSelected());
  InstallSettings.ANONYMOUS_DATA_COLLECTION.setValue(true);
  ContentSettings.USER_WANTS_MANAGEMENTS.setValue(contentFilterCheckBox.isSelected());
  InstallSettings.FILTER_OPTION.setValue(true);
}","@Override public void applySettings(){
  SwingUiSettings.HANDLE_MAGNETS.setValue(associationFileTypeCheckBox.isSelected());
  LimeAssociationOption magnetAssociationOption=LimeAssociations.getMagnetAssociation();
  if (magnetAssociationOption != null) {
    magnetAssociationOption.setEnabled(associationFileTypeCheckBox.isSelected());
  }
  SwingUiSettings.HANDLE_TORRENTS.setValue(associationFileTypeCheckBox.isSelected());
  LimeAssociationOption torrentAssociationOption=LimeAssociations.getTorrentAssociation();
  if (torrentAssociationOption != null) {
    torrentAssociationOption.setEnabled(associationFileTypeCheckBox.isSelected());
  }
  InstallSettings.ASSOCIATION_OPTION.setValue(2);
  if (shouldShowStartOnStartupWindow()) {
    if (OSUtils.isMacOSX())     MacOSXUtils.setLoginStatus(launchAtStartupCheckBox.isSelected());
 else     if (WindowsUtils.isLoginStatusAvailable())     BackgroundExecutorService.execute(new Runnable(){
      @Override public void run(){
        WindowsUtils.setLoginStatus(launchAtStartupCheckBox.isSelected());
      }
    }
);
    StartupSettings.RUN_ON_STARTUP.setValue(launchAtStartupCheckBox.isSelected());
  }
 else   StartupSettings.RUN_ON_STARTUP.setValue(false);
  InstallSettings.START_STARTUP.setValue(true);
  ApplicationSettings.ALLOW_ANONYMOUS_STATISTICS_GATHERING.setValue(shareUsageDataCheckBox.isSelected());
  InstallSettings.ANONYMOUS_DATA_COLLECTION.setValue(true);
  ContentSettings.USER_WANTS_MANAGEMENTS.setValue(contentFilterCheckBox.isSelected());
  InstallSettings.CONTENT_FILTER_OPTION.setValue(true);
}",0.9974473516273132
3706,"private static boolean shouldShowPage1(){
  if (!InstallSettings.AUTO_SHARING_OPTION.getValue()) {
    return true;
  }
  if (!InstallSettings.ANONYMOUS_DATA_COLLECTION.getValue()) {
    return true;
  }
  if (!InstallSettings.FILTER_OPTION.getValue()) {
    return true;
  }
  if (!InstallSettings.START_STARTUP.getValue()) {
    return GuiUtils.shouldShowStartOnStartupWindow();
  }
  return false;
}","private static boolean shouldShowPage1(){
  if (!InstallSettings.AUTO_SHARING_OPTION.getValue()) {
    return true;
  }
  if (!InstallSettings.ANONYMOUS_DATA_COLLECTION.getValue()) {
    return true;
  }
  if (!InstallSettings.CONTENT_FILTER_OPTION.getValue()) {
    return true;
  }
  if (!InstallSettings.START_STARTUP.getValue()) {
    return GuiUtils.shouldShowStartOnStartupWindow();
  }
  return false;
}",0.9901477832512317
3707,"@Override public Time getMediaTime(){
  if ((audioProperties != null) && audioProperties.containsKey(AUDIO_LENGTH_BYTES) && audioProperties.containsKey(""String_Node_Str"")) {
    float byteslength=((Integer)audioProperties.get(AUDIO_LENGTH_BYTES)).floatValue();
    float progress=bytesRead / byteslength;
    long currentTime=(long)((((Long)audioProperties.get(""String_Node_Str"")) / 1000) * progress);
    return new Time(currentTime);
  }
  return new Time(0);
}","@Override public Time getMediaTime(){
  if ((audioProperties != null) && audioProperties.containsKey(AUDIO_LENGTH_BYTES) && audioProperties.containsKey(""String_Node_Str"")) {
    return new Time(bytesRead);
  }
  return new Time(0);
}",0.5488505747126436
3708,"@Override public void start(){
  state=Started;
  audioPlayer.playSong();
}","@Override public void start(){
  state=Started;
  PlayerState status=getPlayer().getStatus();
  if (status != PlayerState.PAUSED) {
    audioPlayer.stop();
    audioPlayer.playSong();
  }
 else {
    audioPlayer.unpause();
  }
}",0.495049504950495
3709,"@Override public void stateChange(AudioPlayerEvent event){
  if (event.getState() == PlayerState.EOM) {
    state=Unrealized;
    for (    ControllerListener listener : listenerList) {
      listener.controllerUpdate(new EndOfMediaEvent(JavaSoundPlayer.this,0,0,0,null));
    }
  }
 else   if (event.getState() == PlayerState.STOPPED || event.getState() == PlayerState.PAUSED) {
    state=Realized;
    for (    ControllerListener listener : listenerList) {
      listener.controllerUpdate(new StopEvent(JavaSoundPlayer.this,0,0,0,null));
    }
  }
 else   if (event.getState() == PlayerState.PLAYING) {
    state=Started;
  }
 else {
    state=Realized;
  }
}","@Override public void stateChange(AudioPlayerEvent event){
  if (event.getState() == PlayerState.EOM) {
    state=Unrealized;
    for (    ControllerListener listener : listenerList) {
      listener.controllerUpdate(new EndOfMediaEvent(JavaSoundPlayer.this,0,0,0,null));
    }
  }
 else   if (event.getState() == PlayerState.STOPPED || event.getState() == PlayerState.PAUSED) {
    state=Realized;
    for (    ControllerListener listener : listenerList) {
      listener.controllerUpdate(new StopEvent(JavaSoundPlayer.this,0,0,0,null));
    }
  }
 else   if (event.getState() == PlayerState.PLAYING) {
    state=Started;
    for (    ControllerListener listener : listenerList) {
      listener.controllerUpdate(new StartEvent(JavaSoundPlayer.this,0,0,0,null,null));
    }
  }
 else {
    state=Realized;
  }
}",0.8967391304347826
3710,"@Override public void songOpened(Map<String,Object> properties){
  audioProperties=properties;
  if (audioProperties != null && audioProperties.containsKey(""String_Node_Str"")) {
    duration=new Time(((Long)audioProperties.get(""String_Node_Str"")) / 1000);
  }
 else {
    duration=Time.TIME_UNKNOWN;
  }
  for (  ControllerListener listener : listenerList) {
    listener.controllerUpdate(new StartEvent(JavaSoundPlayer.this,0,0,0,null,null));
  }
}","@Override public void songOpened(Map<String,Object> properties){
  audioProperties=properties;
  if (audioProperties != null && audioProperties.containsKey(AUDIO_LENGTH_BYTES)) {
    duration=new Time((Integer)audioProperties.get(AUDIO_LENGTH_BYTES));
  }
 else {
    duration=Time.TIME_UNKNOWN;
  }
  for (  ControllerListener listener : listenerList) {
    listener.controllerUpdate(new StartEvent(JavaSoundPlayer.this,0,0,0,null,null));
  }
}",0.8411633109619687
3711,"@Override public void pause(){
  player.stop();
}","@Override public void pause(){
  if (player instanceof JavaSoundPlayer)   ((JavaSoundPlayer)player).pause();
 else   player.stop();
}",0.5384615384615384
3712,"private void createTabs(PropertiableFile propertiableFile,final FileInfoType type){
  List<Tabs> tabs=new ArrayList<Tabs>();
  tabs.add(Tabs.GENERAL);
  Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
  if (torrent != null) {
    if (torrent.isEditable()) {
      tabs.add(Tabs.LIMITS);
    }
    if (torrent.hasMetaData()) {
      tabs.add(Tabs.BITTORENT);
      tabs.add(Tabs.TRACKERS);
    }
    if (torrent.isEditable()) {
      tabs.add(Tabs.TRANSFERS);
      tabs.add(Tabs.PIECES);
    }
  }
 else {
    if (type == FileInfoType.LOCAL_FILE) {
      tabs.add(Tabs.SHARING);
    }
    if (type != FileInfoType.REMOTE_FILE) {
      tabs.add(Tabs.TRANSFERS);
    }
    if (type == FileInfoType.DOWNLOADING_FILE) {
      tabs.add(Tabs.PIECES);
    }
  }
  tabPanel.setTabs(tabs);
}","private void createTabs(PropertiableFile propertiableFile,final FileInfoType type){
  List<Tabs> tabs=new ArrayList<Tabs>();
  tabs.add(Tabs.GENERAL);
  Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
  if (torrent != null) {
    if (torrent.isEditable()) {
      tabs.add(Tabs.LIMITS);
    }
    if (torrent.hasMetaData()) {
      tabs.add(Tabs.BITTORENT);
      tabs.add(Tabs.TRACKERS);
    }
    if (torrent.isEditable()) {
      tabs.add(Tabs.TRANSFERS);
      if (type == FileInfoType.DOWNLOADING_FILE) {
        tabs.add(Tabs.PIECES);
      }
    }
  }
 else {
    if (type == FileInfoType.LOCAL_FILE) {
      tabs.add(Tabs.SHARING);
    }
    if (type != FileInfoType.REMOTE_FILE) {
      tabs.add(Tabs.TRANSFERS);
    }
    if (type == FileInfoType.DOWNLOADING_FILE) {
      tabs.add(Tabs.PIECES);
    }
  }
  tabPanel.setTabs(tabs);
}",0.9638839550029604
3713,"@Inject public FileInfoDialog(@Assisted PropertiableFile propertiable,@Assisted final FileInfoType type,FileInfoTabPanel fileInfoTabPanel,final FileInfoPanelFactory fileInfoFactory,LibraryManager libraryManager){
  super(GuiUtils.getMainFrame());
  this.libraryManager=libraryManager;
  tabPanel=fileInfoTabPanel;
  cardPanel=new JPanel(new BorderLayout());
  cardPanel.setPreferredSize(new Dimension(400,600));
  cards=new HashMap<Tabs,FileInfoPanel>();
  this.propertiableFile=propertiable;
  GuiUtils.assignResources(this);
  cardPanel.setOpaque(false);
  createTabs(propertiableFile,type);
  cards.put(Tabs.GENERAL,fileInfoFactory.createGeneralPanel(type,propertiableFile));
  cardPanel.add(cards.get(Tabs.GENERAL).getComponent());
  updateTitle(propertiableFile.getFileName());
  setLayout(new MigLayout(""String_Node_Str""));
  getContentPane().setBackground(backgroundColor);
  overviewPanel=(FileInfoOverviewPanel)fileInfoFactory.createOverviewPanel(type,propertiableFile);
  add(overviewPanel.getComponent(),""String_Node_Str"");
  add(tabPanel.getComponent(),""String_Node_Str"");
  add(cardPanel,""String_Node_Str"");
  createFooter();
  setPreferredSize(new Dimension(500,565));
  setDefaultCloseOperation(FileInfoDialog.DISPOSE_ON_CLOSE);
  if (type == FileInfoType.LOCAL_FILE) {
    setModalityType(ModalityType.APPLICATION_MODAL);
  }
  pack();
  setLocationRelativeTo(GuiUtils.getMainFrame());
  addComponentListener(new ComponentListener(){
    @Override public void componentHidden(    ComponentEvent e){
      dispose();
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentResized(    ComponentEvent e){
    }
    @Override public void componentShown(    ComponentEvent e){
      if (okButton != null)       okButton.requestFocusInWindow();
    }
  }
);
  renameListener=new RenameListener(libraryManager);
  libraryManager.getLibraryManagedList().addPropertyChangeListener(renameListener);
  tabPanel.addSearchTabListener(new FileInfoTabListener(){
    @Override public void tabSelected(    Tabs tab){
      if (!cards.containsKey(tab)) {
        if (tab == Tabs.GENERAL) {
          cards.put(tab,fileInfoFactory.createGeneralPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.SHARING) {
          cards.put(tab,fileInfoFactory.createSharingPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.LIMITS) {
          Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
          if (torrent != null && torrent.isEditable()) {
            cards.put(tab,fileInfoFactory.createLimitsPanel(type,propertiableFile));
          }
        }
 else         if (tab == Tabs.TRACKERS) {
          cards.put(tab,fileInfoFactory.createTrackersPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.TRANSFERS) {
          cards.put(tab,fileInfoFactory.createTransferPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.BITTORENT) {
          Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
          if (torrent != null && torrent.hasMetaData()) {
            cards.put(tab,fileInfoFactory.createBittorentPanel(torrent));
          }
        }
 else         if (tab == Tabs.PIECES) {
          if (propertiableFile instanceof DownloadItem) {
            cards.put(tab,fileInfoFactory.createPiecesPanel(type,(DownloadItem)propertiableFile));
          }
 else {
            throw new IllegalStateException(""String_Node_Str"");
          }
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + tab);
        }
      }
      cardPanel.removeAll();
      cardPanel.add(cards.get(tab).getComponent());
      FileInfoDialog.this.validate();
      FileInfoDialog.this.repaint();
    }
  }
);
}","@Inject public FileInfoDialog(@Assisted PropertiableFile propertiable,@Assisted final FileInfoType type,FileInfoTabPanel fileInfoTabPanel,final FileInfoPanelFactory fileInfoFactory,LibraryManager libraryManager){
  super(GuiUtils.getMainFrame());
  this.libraryManager=libraryManager;
  tabPanel=fileInfoTabPanel;
  cardPanel=new JPanel(new BorderLayout());
  cardPanel.setPreferredSize(new Dimension(400,600));
  cards=new HashMap<Tabs,FileInfoPanel>();
  this.propertiableFile=propertiable;
  GuiUtils.assignResources(this);
  cardPanel.setOpaque(false);
  createTabs(propertiableFile,type);
  cards.put(Tabs.GENERAL,fileInfoFactory.createGeneralPanel(type,propertiableFile));
  cardPanel.add(cards.get(Tabs.GENERAL).getComponent());
  updateTitle(propertiableFile.getFileName());
  setLayout(new MigLayout(""String_Node_Str""));
  getContentPane().setBackground(backgroundColor);
  overviewPanel=(FileInfoOverviewPanel)fileInfoFactory.createOverviewPanel(type,propertiableFile);
  add(overviewPanel.getComponent(),""String_Node_Str"");
  add(tabPanel.getComponent(),""String_Node_Str"");
  add(cardPanel,""String_Node_Str"");
  createFooter();
  setPreferredSize(new Dimension(500,565));
  setDefaultCloseOperation(FileInfoDialog.DISPOSE_ON_CLOSE);
  if (type == FileInfoType.LOCAL_FILE) {
    setModalityType(ModalityType.APPLICATION_MODAL);
  }
  pack();
  setLocationRelativeTo(GuiUtils.getMainFrame());
  addComponentListener(new ComponentListener(){
    @Override public void componentHidden(    ComponentEvent e){
      dispose();
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentResized(    ComponentEvent e){
    }
    @Override public void componentShown(    ComponentEvent e){
      if (okButton != null)       okButton.requestFocusInWindow();
    }
  }
);
  renameListener=new RenameListener(libraryManager);
  libraryManager.getLibraryManagedList().addPropertyChangeListener(renameListener);
  tabPanel.addSearchTabListener(new FileInfoTabListener(){
    @Override public void tabSelected(    Tabs tab){
      if (!cards.containsKey(tab)) {
        if (tab == Tabs.GENERAL) {
          cards.put(tab,fileInfoFactory.createGeneralPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.SHARING) {
          cards.put(tab,fileInfoFactory.createSharingPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.LIMITS) {
          Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
          if (torrent != null && torrent.isEditable()) {
            cards.put(tab,fileInfoFactory.createLimitsPanel(type,propertiableFile));
          }
        }
 else         if (tab == Tabs.TRACKERS) {
          cards.put(tab,fileInfoFactory.createTrackersPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.TRANSFERS) {
          cards.put(tab,fileInfoFactory.createTransferPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.BITTORENT) {
          Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
          if (torrent != null && torrent.hasMetaData()) {
            cards.put(tab,fileInfoFactory.createBittorentPanel(torrent));
          }
        }
 else         if (tab == Tabs.PIECES) {
          if (propertiableFile instanceof DownloadItem) {
            cards.put(tab,fileInfoFactory.createPiecesPanel(type,(DownloadItem)propertiableFile));
          }
 else {
          }
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + tab);
        }
      }
      cardPanel.removeAll();
      cardPanel.add(cards.get(tab).getComponent());
      FileInfoDialog.this.validate();
      FileInfoDialog.this.repaint();
    }
  }
);
}",0.9407702523240372
3714,"@Override public void tabSelected(Tabs tab){
  if (!cards.containsKey(tab)) {
    if (tab == Tabs.GENERAL) {
      cards.put(tab,fileInfoFactory.createGeneralPanel(type,propertiableFile));
    }
 else     if (tab == Tabs.SHARING) {
      cards.put(tab,fileInfoFactory.createSharingPanel(type,propertiableFile));
    }
 else     if (tab == Tabs.LIMITS) {
      Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
      if (torrent != null && torrent.isEditable()) {
        cards.put(tab,fileInfoFactory.createLimitsPanel(type,propertiableFile));
      }
    }
 else     if (tab == Tabs.TRACKERS) {
      cards.put(tab,fileInfoFactory.createTrackersPanel(type,propertiableFile));
    }
 else     if (tab == Tabs.TRANSFERS) {
      cards.put(tab,fileInfoFactory.createTransferPanel(type,propertiableFile));
    }
 else     if (tab == Tabs.BITTORENT) {
      Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
      if (torrent != null && torrent.hasMetaData()) {
        cards.put(tab,fileInfoFactory.createBittorentPanel(torrent));
      }
    }
 else     if (tab == Tabs.PIECES) {
      if (propertiableFile instanceof DownloadItem) {
        cards.put(tab,fileInfoFactory.createPiecesPanel(type,(DownloadItem)propertiableFile));
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + tab);
    }
  }
  cardPanel.removeAll();
  cardPanel.add(cards.get(tab).getComponent());
  FileInfoDialog.this.validate();
  FileInfoDialog.this.repaint();
}","@Override public void tabSelected(Tabs tab){
  if (!cards.containsKey(tab)) {
    if (tab == Tabs.GENERAL) {
      cards.put(tab,fileInfoFactory.createGeneralPanel(type,propertiableFile));
    }
 else     if (tab == Tabs.SHARING) {
      cards.put(tab,fileInfoFactory.createSharingPanel(type,propertiableFile));
    }
 else     if (tab == Tabs.LIMITS) {
      Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
      if (torrent != null && torrent.isEditable()) {
        cards.put(tab,fileInfoFactory.createLimitsPanel(type,propertiableFile));
      }
    }
 else     if (tab == Tabs.TRACKERS) {
      cards.put(tab,fileInfoFactory.createTrackersPanel(type,propertiableFile));
    }
 else     if (tab == Tabs.TRANSFERS) {
      cards.put(tab,fileInfoFactory.createTransferPanel(type,propertiableFile));
    }
 else     if (tab == Tabs.BITTORENT) {
      Torrent torrent=(Torrent)propertiableFile.getProperty(FilePropertyKey.TORRENT);
      if (torrent != null && torrent.hasMetaData()) {
        cards.put(tab,fileInfoFactory.createBittorentPanel(torrent));
      }
    }
 else     if (tab == Tabs.PIECES) {
      if (propertiableFile instanceof DownloadItem) {
        cards.put(tab,fileInfoFactory.createPiecesPanel(type,(DownloadItem)propertiableFile));
      }
 else {
      }
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + tab);
    }
  }
  cardPanel.removeAll();
  cardPanel.add(cards.get(tab).getComponent());
  FileInfoDialog.this.validate();
  FileInfoDialog.this.repaint();
}",0.8796178343949045
3715,"/** 
 * Displays an Info dialog for the specified download item.
 */
private void showInfoDialog(DownloadItem item){
switch (item.getDownloadItemType()) {
case ANTIVIRUS:
    avInfoPanelFactory.get().showVendorMessage();
  break;
case BITTORRENT:
switch (item.getState()) {
case DANGEROUS:
  avInfoPanelFactory.get().showDangerMessage(item,false);
break;
case SCANNING:
case SCANNING_FRAGMENT:
avInfoPanelFactory.get().showVendorMessage();
break;
case THREAT_FOUND:
avInfoPanelFactory.get().showThreatMessage(item,false);
break;
case SCAN_FAILED:
avInfoPanelFactory.get().showFailureMessage(item,false);
break;
default :
createFileInfoDialog(item);
break;
}
case GNUTELLA:
switch (item.getState()) {
case DANGEROUS:
avInfoPanelFactory.get().showDangerMessage(item,false);
break;
case SCANNING:
case SCANNING_FRAGMENT:
avInfoPanelFactory.get().showVendorMessage();
break;
case THREAT_FOUND:
avInfoPanelFactory.get().showThreatMessage(item,false);
break;
case SCAN_FAILED:
avInfoPanelFactory.get().showFailureMessage(item,false);
break;
}
break;
}
}","/** 
 * Displays an Info dialog for the specified download item.
 */
private void showInfoDialog(DownloadItem item){
switch (item.getDownloadItemType()) {
case ANTIVIRUS:
    avInfoPanelFactory.get().showVendorMessage();
  return;
case BITTORRENT:
switch (item.getState()) {
case DANGEROUS:
  avInfoPanelFactory.get().showDangerMessage(item,false);
return;
case SCANNING:
case SCANNING_FRAGMENT:
avInfoPanelFactory.get().showVendorMessage();
return;
case THREAT_FOUND:
avInfoPanelFactory.get().showThreatMessage(item,false);
return;
case SCAN_FAILED:
avInfoPanelFactory.get().showFailureMessage(item,false);
return;
default :
createFileInfoDialog(item);
return;
}
case GNUTELLA:
switch (item.getState()) {
case DANGEROUS:
avInfoPanelFactory.get().showDangerMessage(item,false);
return;
case SCANNING:
case SCANNING_FRAGMENT:
avInfoPanelFactory.get().showVendorMessage();
return;
case THREAT_FOUND:
avInfoPanelFactory.get().showThreatMessage(item,false);
return;
case SCAN_FAILED:
avInfoPanelFactory.get().showFailureMessage(item,false);
return;
}
break;
}
}",0.943916349809886
3716,"public void load(String url){
  loadedOnce=true;
  url=application.addClientInfoToUrl(url);
  if (firstRequest) {
    if (isLastRequestSuccessful()) {
      firstRequest=false;
    }
 else {
      url+=""String_Node_Str"";
      if (application.isNewInstall()) {
        url+=""String_Node_Str"" + true;
        url+=""String_Node_Str"" + EncodingUtils.encode(application.getAskValue());
      }
      if (initialLoadTime == -1) {
        initialLoadTime=System.currentTimeMillis();
      }
    }
  }
  if (MozillaInitialization.isInitialized()) {
    browser.load(url);
  }
 else {
    url+=""String_Node_Str"";
    URL bgImage=HomePanel.class.getResource(""String_Node_Str"");
    URL topImage=HomePanel.class.getResource(""String_Node_Str"");
    String offlinePage=""String_Node_Str"" + bgImage.toExternalForm() + ""String_Node_Str""+ topImage.toExternalForm()+ ""String_Node_Str"";
    fallbackBrowser.setPageAsynchronous(url,offlinePage).addFutureListener(new EventListener<FutureEvent<LoadResult>>(){
      @SwingEDTEvent public void handleEvent(      FutureEvent<LoadResult> event){
        pageLoadFinished(event.getResult() == LoadResult.SERVER_PAGE);
      }
    }
);
  }
}","public void load(String url){
  loadedOnce=true;
  url=application.addClientInfoToUrl(url);
  if (firstRequest) {
    if (isLastRequestSuccessful()) {
      firstRequest=false;
    }
 else {
      url+=""String_Node_Str"";
      if (application.isNewInstall()) {
        url+=""String_Node_Str"" + true;
        if (OSUtils.isWindows()) {
          url+=""String_Node_Str"" + EncodingUtils.encode(application.getAskValue());
        }
      }
      if (initialLoadTime == -1) {
        initialLoadTime=System.currentTimeMillis();
      }
    }
  }
  if (MozillaInitialization.isInitialized()) {
    browser.load(url);
  }
 else {
    url+=""String_Node_Str"";
    URL bgImage=HomePanel.class.getResource(""String_Node_Str"");
    URL topImage=HomePanel.class.getResource(""String_Node_Str"");
    String offlinePage=""String_Node_Str"" + bgImage.toExternalForm() + ""String_Node_Str""+ topImage.toExternalForm()+ ""String_Node_Str"";
    fallbackBrowser.setPageAsynchronous(url,offlinePage).addFutureListener(new EventListener<FutureEvent<LoadResult>>(){
      @SwingEDTEvent public void handleEvent(      FutureEvent<LoadResult> event){
        pageLoadFinished(event.getResult() == LoadResult.SERVER_PAGE);
      }
    }
);
  }
}",0.980243799915931
3717,"private void initValues(){
  if (torrent == null || !torrent.isEditable()) {
    defaultRadioButton.setSelected(true);
    limitDownloadBandWidthCheckBox.setSelected(false);
    limitUploadBandwidthCheckBox.setSelected(false);
  }
 else {
    float ratio=torrent.getProperty(LimeWireTorrentProperties.MAX_SEED_RATIO_LIMIT,-1f);
    int uploadRate=torrent.getMaxUploadBandwidth() / 1024;
    int downloadRate=torrent.getMaxDownloadBandwidth() / 1024;
    int time=torrent.getProperty(LimeWireTorrentProperties.MAX_SEED_TIME_RATIO_LIMIT,-1);
    if (ratio == Float.MAX_VALUE && time == Integer.MAX_VALUE) {
      uploadForeverRadioButton.setSelected(true);
      initTimeSpinners(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.get());
    }
 else     if ((ratio >= 0 && ratio != torrentSettings.getSeedRatioLimit()) || (time >= 0 && time != torrentSettings.getSeedTimeLimit())) {
      uploadControlRadioButton.setSelected(true);
      seedRatioSpinner.setValue(ratio);
      initTimeSpinners(getTime(torrent));
    }
 else {
      defaultRadioButton.setSelected(true);
      initTimeSpinners(getTime(torrent));
    }
    limitUploadBandwidthCheckBox.setSelected(uploadRate >= (Integer)((SpinnerNumberModel)maxUploadSpeedSpinner.getModel()).getMinimum() && uploadRate != torrentSettings.getMaxUploadBandwidth());
    if (limitDownloadBandWidthCheckBox.isSelected() && uploadRate >= (Integer)((SpinnerNumberModel)maxUploadSpeedSpinner.getModel()).getMinimum())     maxUploadSpeedSpinner.setValue(uploadRate);
    limitDownloadBandWidthCheckBox.setSelected(downloadRate >= 0 && downloadRate != torrentSettings.getMaxDownloadBandwidth());
    if (limitDownloadBandWidthCheckBox.isSelected() && downloadRate > (Integer)((SpinnerNumberModel)maxDownloadSpeedSpinner.getModel()).getMinimum())     maxDownloadSpeedSpinner.setValue(downloadRate);
  }
}","private void initValues(){
  if (torrent == null || !torrent.isEditable()) {
    defaultRadioButton.setSelected(true);
    limitDownloadBandWidthCheckBox.setSelected(false);
    limitUploadBandwidthCheckBox.setSelected(false);
  }
 else {
    float ratio=torrent.getProperty(LimeWireTorrentProperties.MAX_SEED_RATIO_LIMIT,-1f);
    int uploadRate=torrent.getMaxUploadBandwidth() / 1024;
    int downloadRate=torrent.getMaxDownloadBandwidth() / 1024;
    int time=torrent.getProperty(LimeWireTorrentProperties.MAX_SEED_TIME_RATIO_LIMIT,-1);
    if (ratio == Float.MAX_VALUE && time == Integer.MAX_VALUE) {
      uploadForeverRadioButton.setSelected(true);
      initTimeSpinners(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.get());
    }
 else     if ((ratio >= 0 && ratio != torrentSettings.getSeedRatioLimit()) || (time >= 0 && time != torrentSettings.getSeedTimeLimit())) {
      uploadControlRadioButton.setSelected(true);
      seedRatioSpinner.setValue(ratio);
      initTimeSpinners(getTime(torrent));
    }
 else {
      defaultRadioButton.setSelected(true);
      initTimeSpinners(getTime(torrent));
    }
    limitUploadBandwidthCheckBox.setSelected(uploadRate >= (Integer)((SpinnerNumberModel)maxUploadSpeedSpinner.getModel()).getMinimum() && uploadRate != torrentSettings.getMaxUploadBandwidth() / 1024);
    if (limitUploadBandwidthCheckBox.isSelected())     maxUploadSpeedSpinner.setValue(uploadRate);
    limitDownloadBandWidthCheckBox.setSelected(downloadRate >= (Integer)((SpinnerNumberModel)maxDownloadSpeedSpinner.getModel()).getMinimum() && downloadRate != torrentSettings.getMaxDownloadBandwidth() / 1024);
    if (limitDownloadBandWidthCheckBox.isSelected()) {
      maxDownloadSpeedSpinner.setValue(downloadRate);
    }
  }
}",0.903010033444816
3718,"/** 
 * Creates a Spinner to set the Max Download Bandwidth for a Torrent.
 */
private JSpinner createDownloadSpinner(){
  SpinnerNumberModel maxSpinnerModel=new SpinnerNumberModel(DownloadSettings.MAX_DOWNLOAD_SPEED.getValue() / 1024,DownloadSettings.MAX_DOWNLOAD_SPEED.getMinValue().intValue() / 1024,DownloadSettings.MAX_DOWNLOAD_SPEED.getMaxValue().intValue() / 1024,1);
  return createSpinner(maxSpinnerModel);
}","/** 
 * Creates a Spinner to set the Max Download Bandwidth for a Torrent.
 */
private JSpinner createDownloadSpinner(){
  SpinnerNumberModel maxSpinnerModel=new SpinnerNumberModel(DownloadSettings.MAX_DOWNLOAD_SPEED.getValue() / 1024,DownloadSettings.MAX_DOWNLOAD_SPEED.getMinValue().intValue() / 1024,DownloadSettings.LIMIT_MAX_DOWNLOAD_SPEED.get() ? (DownloadSettings.MAX_DOWNLOAD_SPEED.getValue() / 1024) : (DownloadSettings.MAX_DOWNLOAD_SPEED.getMaxValue().intValue() / 1024),1);
  return createSpinner(maxSpinnerModel);
}",0.8559322033898306
3719,"/** 
 * Creates a Spinner to set the Max Upload Bandwidth for a Torrent. 
 */
private JSpinner createUploadSpinner(){
  SpinnerNumberModel maxUploadSpinnerModel=new SpinnerNumberModel(UploadSettings.MAX_UPLOAD_SPEED.getValue() / 1024,UploadSettings.MAX_UPLOAD_SPEED.getMinValue().intValue() / 1024,UploadSettings.MAX_UPLOAD_SPEED.getMaxValue().intValue() / 1024,1);
  return createSpinner(maxUploadSpinnerModel);
}","/** 
 * Creates a Spinner to set the Max Upload Bandwidth for a Torrent. 
 */
private JSpinner createUploadSpinner(){
  SpinnerNumberModel maxUploadSpinnerModel=new SpinnerNumberModel(UploadSettings.MAX_UPLOAD_SPEED.getValue() / 1024,UploadSettings.MAX_UPLOAD_SPEED.getMinValue().intValue() / 1024,UploadSettings.LIMIT_MAX_UPLOAD_SPEED.get() ? (UploadSettings.MAX_UPLOAD_SPEED.getValue() / 1024) : (UploadSettings.MAX_UPLOAD_SPEED.getMaxValue().intValue() / 1024),1);
  return createSpinner(maxUploadSpinnerModel);
}",0.8623655913978494
3720,"/** 
 * Asks the user whether to continue with a torrent download that contains files with banned extensions.
 * @return true if the download should continue.
 */
@Override public boolean promptAboutTorrentWithBannedExtensions(Torrent torrent,Set<String> bannedExtensions){
  String extensions=StringUtils.explode(bannedExtensions,""String_Node_Str"");
  String warning=I18n.tr(""String_Node_Str"",extensions);
  String prompt=I18n.tr(""String_Node_Str"");
  MultiLineLabel label=new MultiLineLabel(warning + ""String_Node_Str"" + prompt,400);
  int ok=FocusJOptionPane.showConfirmDialog(GuiUtils.getMainFrame(),label,torrent.getName(),JOptionPane.YES_NO_OPTION);
  return ok == JOptionPane.YES_OPTION;
}","/** 
 * Asks the user whether to continue with a torrent download that contains files with banned extensions.
 * @return true if the download should continue.
 */
@Override public boolean promptAboutTorrentWithBannedExtensions(Torrent torrent,Set<String> bannedExtensions){
  String extensions=StringUtils.explode(bannedExtensions,""String_Node_Str"");
  String warning=I18n.tr(""String_Node_Str"",extensions);
  String prompt=I18n.tr(""String_Node_Str"");
  final MultiLineLabel label=new MultiLineLabel(warning + ""String_Node_Str"" + prompt,400);
  final String title=I18n.tr(""String_Node_Str"",torrent.getName());
  final AtomicInteger result=new AtomicInteger(JOptionPane.YES_OPTION);
  SwingUtils.invokeNowOrWait(new Runnable(){
    @Override public void run(){
      result.set(FocusJOptionPane.showConfirmDialog(GuiUtils.getMainFrame(),label,title,JOptionPane.YES_NO_OPTION));
    }
  }
);
  return result.get() == JOptionPane.YES_OPTION;
}",0.72782874617737
3721,"@Override public boolean promptUserQuestion(String marktr){
  return yesNoQuestion(I18n.tr(marktr));
}","@Override public boolean promptUserQuestion(final String marktr){
  final MultiLineLabel label=new MultiLineLabel(I18n.tr(marktr),400);
  final String title=I18n.tr(""String_Node_Str"");
  final AtomicInteger result=new AtomicInteger(JOptionPane.YES_OPTION);
  SwingUtils.invokeNowOrWait(new Runnable(){
    @Override public void run(){
      result.set(FocusJOptionPane.showConfirmDialog(GuiUtils.getMainFrame(),label,title,JOptionPane.YES_NO_OPTION));
    }
  }
);
  return result.get() == JOptionPane.YES_OPTION;
}",0.2658022690437601
3722,"@Override public void run(){
  result.set(TorrentDownloadSelector.showBittorrentSelector(torrent,fileInfoPanelFactory.get()));
}","@Override public void run(){
  result.set(FocusJOptionPane.showConfirmDialog(GuiUtils.getMainFrame(),label,title,JOptionPane.YES_NO_OPTION));
}",0.4870848708487085
3723,"public void testKeyMismatchServerUnsuccessfullyDecrypts() throws Exception {
  settingsStub.serverPublicKey=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String json=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  serverController.setReturnJsonTemplate(json);
  serverController.startServer();
  ActivationCommunicator comm=injector.getInstance(ActivationCommunicator.class);
  try {
    comm.activate(""String_Node_Str"",RequestType.USER_ACTIVATE);
    fail(""String_Node_Str"");
  }
 catch (  InvalidTokenException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
}","public void testKeyMismatchServerUnsuccessfullyDecrypts() throws Exception {
  settingsStub.serverPublicKey=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String json=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  serverController.setReturnJsonTemplate(json);
  serverController.startServer();
  ActivationCommunicator comm=injector.getInstance(ActivationCommunicator.class);
  ActivationResponse resp=comm.activate(""String_Node_Str"",RequestType.USER_ACTIVATE);
  assertEquals(ActivationResponse.Type.ERROR,resp.getResponseType());
}",0.8732970027247956
3724,"public ActivationResponse activate(final String licenseId,RequestType type) throws IOException, InvalidDataException, InvalidTokenException {
  String randomNumber=getRandomToken();
  String lidToken=getEncryptedToken(licenseId,randomNumber);
  String postContent=activationSettings.getQueryString() + ""String_Node_Str"" + licenseId+ ""String_Node_Str""+ lidToken;
  String jsonResult=sendToServer(postContent,licenseId,type);
  ActivationResponse activationResponse=activationFactory.createFromJson(jsonResult);
  boolean responseHasSameRandomNumber=randomNumber.equals(activationResponse.getToken());
  if (!responseHasSameRandomNumber) {
    throw new InvalidTokenException(""String_Node_Str"");
  }
  return activationResponse;
}","public ActivationResponse activate(final String licenseId,RequestType type) throws IOException, InvalidDataException, InvalidTokenException {
  String randomNumber=getRandomToken();
  String lidToken=getEncryptedToken(licenseId,randomNumber);
  String postContent=activationSettings.getQueryString() + ""String_Node_Str"" + licenseId+ ""String_Node_Str""+ lidToken;
  String jsonResult=sendToServer(postContent,licenseId,type);
  ActivationResponse activationResponse=activationFactory.createFromJson(jsonResult);
  boolean responseHasSameRandomNumber=randomNumber.equals(activationResponse.getToken());
  if ((activationResponse.getResponseType() == ActivationResponse.Type.VALID) && !responseHasSameRandomNumber) {
    throw new InvalidTokenException(""String_Node_Str"");
  }
  return activationResponse;
}",0.9510124101894188
3725,"private void checkLicenseForCompleteness(){
  if (getLength() == 14 || getLength() == 0) {
    if (!licenseIsCorrectLength) {
      firePropertyChange(LICENSE_IS_CORRECT_LENGTH,licenseIsCorrectLength,true);
      licenseIsCorrectLength=true;
    }
  }
 else {
    if (licenseIsCorrectLength) {
      firePropertyChange(LICENSE_IS_CORRECT_LENGTH,licenseIsCorrectLength,false);
      licenseIsCorrectLength=false;
    }
  }
}","private void checkLicenseForCompleteness(){
  boolean isCorrectLength=getLength() == 14 || getLength() == 0;
  firePropertyChange(LICENSE_IS_CORRECT_LENGTH,!isCorrectLength,isCorrectLength);
}",0.5430894308943089
3726,"@Inject public ActivationManagerImpl(@Named(""String_Node_Str"") ScheduledExecutorService scheduler,ActivationCommunicator activationCommunicator,ActivationModel activationModel,ActivationSerializer activationSerializer,ActivationResponseFactory activationReponseFactory,ActivationSettingsController activationSettings,ApplicationServices applicationServices){
  this.activationModel=activationModel;
  this.scheduler=scheduler;
  this.activationCommunicator=activationCommunicator;
  this.activationSerializer=activationSerializer;
  this.activationResponseFactory=activationReponseFactory;
  this.activationSettings=activationSettings;
  this.applicationServices=applicationServices;
}","@Inject public ActivationManagerImpl(@Named(""String_Node_Str"") ScheduledExecutorService scheduler,ActivationCommunicator activationCommunicator,ActivationModel activationModel,ActivationSerializer activationSerializer,ActivationResponseFactory activationReponseFactory,ActivationSettingsController activationSettings){
  this.activationModel=activationModel;
  this.scheduler=scheduler;
  this.activationCommunicator=activationCommunicator;
  this.activationSerializer=activationSerializer;
  this.activationResponseFactory=activationReponseFactory;
  this.activationSettings=activationSettings;
}",0.9313572542901716
3727,"private void deleteBuyProLinks(boolean lastStartPro){
  if (OSUtils.isWindows() && (!lastStartPro || applicationServices.isNewInstall())) {
    File pathToLimeWireStartMenuLink=new File(System.getProperty(""String_Node_Str"") + PATH_TO_BUY_PRO_LINK);
    if (pathToLimeWireStartMenuLink.exists()) {
      pathToLimeWireStartMenuLink.delete();
    }
    File pathToLimeWireAllUsersStartMenuLink=new File(System.getProperty(""String_Node_Str"") + ""String_Node_Str"" + PATH_TO_BUY_PRO_LINK);
    if (pathToLimeWireAllUsersStartMenuLink.exists()) {
      pathToLimeWireAllUsersStartMenuLink.delete();
    }
  }
}","private void deleteBuyProLinks(boolean lastStartPro){
  if (OSUtils.isWindows() && (!lastStartPro || activationSettings.isNewInstall())) {
    File pathToLimeWireStartMenuLink=new File(System.getProperty(""String_Node_Str"") + PATH_TO_BUY_PRO_LINK);
    if (pathToLimeWireStartMenuLink.exists()) {
      pathToLimeWireStartMenuLink.delete();
    }
    File pathToLimeWireAllUsersStartMenuLink=new File(System.getProperty(""String_Node_Str"") + ""String_Node_Str"" + PATH_TO_BUY_PRO_LINK);
    if (pathToLimeWireAllUsersStartMenuLink.exists()) {
      pathToLimeWireAllUsersStartMenuLink.delete();
    }
  }
}",0.9759336099585062
3728,"/** 
 * @param comm ActivationCommunicator
 * @return an {@link ActivationManager} object with astub/mocked  {@link ActivationCommunicator}
 */
private ActivationManagerImpl getActivationManager(ActivationCommunicator comm){
  ActivationModel model=injector.getInstance(ActivationModel.class);
  ActivationSerializer serializer=injector.getInstance(ActivationSerializer.class);
  ScheduledExecutorService scheduler=injector.getInstance(Key.get(ScheduledExecutorService.class,Names.named(""String_Node_Str"")));
  ActivationResponseFactory factory=injector.getInstance(ActivationResponseFactory.class);
  return new ActivationManagerImpl(scheduler,comm,model,serializer,factory,activationSettings,null);
}","/** 
 * @param comm ActivationCommunicator
 * @return an {@link ActivationManager} object with astub/mocked  {@link ActivationCommunicator}
 */
private ActivationManagerImpl getActivationManager(ActivationCommunicator comm){
  ActivationModel model=injector.getInstance(ActivationModel.class);
  ActivationSerializer serializer=injector.getInstance(ActivationSerializer.class);
  ScheduledExecutorService scheduler=injector.getInstance(Key.get(ScheduledExecutorService.class,Names.named(""String_Node_Str"")));
  ActivationResponseFactory factory=injector.getInstance(ActivationResponseFactory.class);
  return new ActivationManagerImpl(scheduler,comm,model,serializer,factory,activationSettings);
}",0.9964260185847034
3729,"public void update(){
  boolean isEditMode=editingLicense || state == ActivationState.NOT_AUTHORIZED || (state == ActivationState.AUTHORIZING);
  licenseKeyPanel.setEditable(isEditMode);
  Mode warningPanelMode=Mode.EMPTY;
  if (state == ActivationState.AUTHORIZING) {
    warningPanelMode=Mode.SPINNER;
  }
 else   if (state == ActivationState.NOT_AUTHORIZED) {
    if (error == ActivationError.INVALID_KEY || error == ActivationError.BLOCKED_KEY) {
      warningPanelMode=Mode.WARNING;
    }
  }
  warningPanel.setActivationMode(warningPanelMode);
  editButton.setVisible(!isEditMode);
  licenseErrorLabel.setText(getLicenseErrorMessage(error));
  if (state == ActivationState.REFRESHING) {
    editButton.setEnabled(false);
    tableOverlayBusyLabel.setBusy(true);
    tableJXLayer.getGlassPane().setVisible(true);
  }
 else {
    editButton.setEnabled(true);
    tableOverlayBusyLabel.setBusy(false);
    tableJXLayer.getGlassPane().setVisible(false);
  }
  if (error == ActivationError.BLOCKED_KEY) {
    underneathModuleTableMessagePanel.setState(MessageState.BLOCKED);
  }
 else   if (areThereExpiredModules()) {
    underneathModuleTableMessagePanel.setState(MessageState.EXPIRED);
  }
 else   if (areThereNonFunctionalModules()) {
    underneathModuleTableMessagePanel.setState(MessageState.UNSUPPORTED);
  }
 else {
    underneathModuleTableMessagePanel.setState(MessageState.NO_ERROR);
  }
  String cardName=NO_LICENSE_BUTTON_PANEL;
  if (state == ActivationState.AUTHORIZED) {
    if (isEditMode) {
      cardName=EDIT_LICENSE_BUTTON_PANEL;
    }
 else {
      cardName=OK_LICENSE_BUTTON_PANEL;
    }
  }
 else   if (state == ActivationState.REFRESHING) {
    cardName=OK_LICENSE_BUTTON_PANEL;
  }
  selectCard(cardName);
  if (state == ActivationState.REFRESHING) {
    ((ActivatedButtonPanel)cardMap.get(OK_LICENSE_BUTTON_PANEL)).setRefreshEnabled(false);
  }
 else   if (state == ActivationState.AUTHORIZED) {
    ((ActivatedButtonPanel)cardMap.get(OK_LICENSE_BUTTON_PANEL)).setRefreshEnabled(true);
  }
  activationPanel.revalidate();
}","public void update(){
  boolean isEditMode=editingLicense || state == ActivationState.NOT_AUTHORIZED || (state == ActivationState.AUTHORIZING);
  licenseKeyPanel.setEditable(isEditMode);
  Mode warningPanelMode=Mode.EMPTY;
  if (state == ActivationState.AUTHORIZING) {
    warningPanelMode=Mode.SPINNER;
  }
 else   if (state == ActivationState.NOT_AUTHORIZED) {
    if (error == ActivationError.INVALID_KEY || error == ActivationError.BLOCKED_KEY) {
      warningPanelMode=Mode.WARNING;
    }
  }
  warningPanel.setActivationMode(warningPanelMode);
  editButton.setVisible(!isEditMode);
  licenseErrorLabel.setText(getLicenseErrorMessage(error));
  if (state == ActivationState.REFRESHING) {
    editButton.setEnabled(false);
    tableOverlayBusyLabel.setBusy(true);
    tableJXLayer.getGlassPane().setVisible(true);
  }
 else {
    editButton.setEnabled(true);
    tableOverlayBusyLabel.setBusy(false);
    tableJXLayer.getGlassPane().setVisible(false);
  }
  if (error == ActivationError.BLOCKED_KEY) {
    underneathModuleTableMessagePanel.setState(MessageState.BLOCKED);
  }
 else   if (areThereExpiredModules()) {
    underneathModuleTableMessagePanel.setState(MessageState.EXPIRED);
  }
 else   if (areThereNonFunctionalModules()) {
    underneathModuleTableMessagePanel.setState(MessageState.UNSUPPORTED);
  }
 else {
    underneathModuleTableMessagePanel.setState(MessageState.NO_ERROR);
  }
  String cardName=NO_LICENSE_BUTTON_PANEL;
  if (state == ActivationState.AUTHORIZED) {
    if (isEditMode) {
      cardName=EDIT_LICENSE_BUTTON_PANEL;
    }
 else {
      cardName=OK_LICENSE_BUTTON_PANEL;
    }
  }
 else   if (state == ActivationState.REFRESHING) {
    cardName=OK_LICENSE_BUTTON_PANEL;
  }
  selectCard(cardName);
  cardMap.get(cardName).setIsActivating(state == ActivationState.REFRESHING || state == ActivationState.AUTHORIZING);
  activationPanel.revalidate();
}",0.905765811531623
3730,"public UnderneathActivationTableMessagePanel(){
  setLayout(new BorderLayout());
  setOpaque(false);
  iconLabel=new JLabel(unsupportedIcon);
  textLabel=new LabelWithLinkSupport();
  add(iconLabel,BorderLayout.WEST);
  add(textLabel,BorderLayout.CENTER);
}","public UnderneathActivationTableMessagePanel(){
  setLayout(new BorderLayout());
  setOpaque(false);
  iconLabel=new JLabel(unsupportedIcon);
  iconLabel.setBorder(BorderFactory.createEmptyBorder(0,0,0,6));
  textLabel=new LabelWithLinkSupport();
  textLabel.setBorder(BorderFactory.createEmptyBorder());
  add(iconLabel,BorderLayout.WEST);
  add(textLabel,BorderLayout.CENTER);
}",0.8069073783359497
3731,"public ActivationTable(EventList<ActivationItem> eventList,CalendarRenderer calendarRenderer,Application application){
  GuiUtils.assignResources(this);
  model=new DefaultEventTableModel<ActivationItem>(new SortedList<ActivationItem>(eventList,new ActivationItemComparator()),new ActivationTableFormat());
  setModel(model);
  this.application=application;
  initTable();
  getColumnExt(ActivationTableFormat.DATE_REGISTERED_INDEX).setMinWidth(90);
  getColumnExt(ActivationTableFormat.DATE_REGISTERED_INDEX).setMaxWidth(90);
  getColumnExt(ActivationTableFormat.DATE_EXPIRE_INDEX).setMinWidth(90);
  getColumnExt(ActivationTableFormat.DATE_EXPIRE_INDEX).setMaxWidth(90);
  getColumn(ActivationTableFormat.MODULE_TYPE_INDEX).setCellRenderer(new LicenseTypeEditorRenderer());
  getColumn(ActivationTableFormat.MODULE_TYPE_INDEX).setCellEditor(new LicenseTypeEditorRenderer());
  getColumn(ActivationTableFormat.DATE_REGISTERED_INDEX).setCellRenderer(calendarRenderer);
  getColumn(ActivationTableFormat.DATE_EXPIRE_INDEX).setCellRenderer(new ExpiredRendererEditor());
  ExpiredRendererEditor expiredRenderer=new ExpiredRendererEditor();
  expiredRenderer.addActionListener(new ActivationInfoAction(expiredRenderer,this,application));
  getColumn(ActivationTableFormat.DATE_EXPIRE_INDEX).setCellEditor(expiredRenderer);
  setupHighlighters();
}","public ActivationTable(EventList<ActivationItem> eventList,CalendarRenderer calendarRenderer,Application application){
  GuiUtils.assignResources(this);
  model=new DefaultEventTableModel<ActivationItem>(new SortedList<ActivationItem>(eventList,new ActivationItemComparator()),new ActivationTableFormat());
  setModel(model);
  this.application=application;
  initTable();
  getColumnExt(ActivationTableFormat.DATE_REGISTERED_INDEX).setMinWidth(100);
  getColumnExt(ActivationTableFormat.DATE_REGISTERED_INDEX).setMaxWidth(100);
  getColumnExt(ActivationTableFormat.DATE_EXPIRE_INDEX).setMinWidth(100);
  getColumnExt(ActivationTableFormat.DATE_EXPIRE_INDEX).setMaxWidth(100);
  getColumn(ActivationTableFormat.MODULE_TYPE_INDEX).setCellRenderer(new LicenseTypeEditorRenderer());
  getColumn(ActivationTableFormat.MODULE_TYPE_INDEX).setCellEditor(new LicenseTypeEditorRenderer());
  getColumn(ActivationTableFormat.DATE_REGISTERED_INDEX).setCellRenderer(calendarRenderer);
  getColumn(ActivationTableFormat.DATE_EXPIRE_INDEX).setCellRenderer(new ExpiredRendererEditor());
  ExpiredRendererEditor expiredRenderer=new ExpiredRendererEditor();
  expiredRenderer.addActionListener(new ActivationInfoAction(expiredRenderer,this,application));
  getColumn(ActivationTableFormat.DATE_EXPIRE_INDEX).setCellEditor(expiredRenderer);
  setupHighlighters();
}",0.995539033457249
3732,"public void update(){
  boolean isEditMode=editingLicense || state == ActivationState.NOT_AUTHORIZED || (state == ActivationState.AUTHORIZING);
  licenseKeyPanel.setEditable(isEditMode);
  Mode warningPanelMode=Mode.EMPTY;
  if (state == ActivationState.AUTHORIZING) {
    warningPanelMode=Mode.SPINNER;
  }
 else   if (state == ActivationState.NOT_AUTHORIZED) {
    if (error == ActivationError.INVALID_KEY || error == ActivationError.BLOCKED_KEY) {
      warningPanelMode=Mode.WARNING;
    }
  }
  warningPanel.setActivationMode(warningPanelMode);
  editButton.setVisible(!isEditMode);
  licenseErrorLabel.setText(getLicenseErrorMessage(error));
  if (state == ActivationState.REFRESHING) {
    tableOverlayBusyLabel.setBusy(true);
    tableJXLayer.getGlassPane().setVisible(true);
  }
 else {
    tableOverlayBusyLabel.setBusy(false);
    tableJXLayer.getGlassPane().setVisible(false);
  }
  if (error == ActivationError.BLOCKED_KEY) {
    underneathModuleTableMessagePanel.setState(MessageState.BLOCKED);
  }
 else   if (areThereExpiredModules()) {
    underneathModuleTableMessagePanel.setState(MessageState.EXPIRED);
  }
 else   if (areThereNonFunctionalModules()) {
    underneathModuleTableMessagePanel.setState(MessageState.UNSUPPORTED);
  }
 else {
    underneathModuleTableMessagePanel.setState(MessageState.NO_ERROR);
  }
  String cardName=NO_LICENSE_BUTTON_PANEL;
  if (state == ActivationState.AUTHORIZED) {
    if (isEditMode) {
      cardName=EDIT_LICENSE_BUTTON_PANEL;
    }
 else {
      cardName=OK_LICENSE_BUTTON_PANEL;
    }
  }
 else   if (state == ActivationState.REFRESHING) {
    cardName=OK_LICENSE_BUTTON_PANEL;
  }
  selectCard(cardName);
  if (state == ActivationState.REFRESHING) {
    ((ActivatedButtonPanel)cardMap.get(OK_LICENSE_BUTTON_PANEL)).setRefreshEnabled(false);
  }
 else   if (state == ActivationState.AUTHORIZED) {
    ((ActivatedButtonPanel)cardMap.get(OK_LICENSE_BUTTON_PANEL)).setRefreshEnabled(true);
  }
  activationPanel.revalidate();
}","public void update(){
  boolean isEditMode=editingLicense || state == ActivationState.NOT_AUTHORIZED || (state == ActivationState.AUTHORIZING);
  licenseKeyPanel.setEditable(isEditMode);
  Mode warningPanelMode=Mode.EMPTY;
  if (state == ActivationState.AUTHORIZING) {
    warningPanelMode=Mode.SPINNER;
  }
 else   if (state == ActivationState.NOT_AUTHORIZED) {
    if (error == ActivationError.INVALID_KEY || error == ActivationError.BLOCKED_KEY) {
      warningPanelMode=Mode.WARNING;
    }
  }
  warningPanel.setActivationMode(warningPanelMode);
  editButton.setVisible(!isEditMode);
  licenseErrorLabel.setText(getLicenseErrorMessage(error));
  if (state == ActivationState.REFRESHING) {
    editButton.setEnabled(false);
    tableOverlayBusyLabel.setBusy(true);
    tableJXLayer.getGlassPane().setVisible(true);
  }
 else {
    editButton.setEnabled(true);
    tableOverlayBusyLabel.setBusy(false);
    tableJXLayer.getGlassPane().setVisible(false);
  }
  if (error == ActivationError.BLOCKED_KEY) {
    underneathModuleTableMessagePanel.setState(MessageState.BLOCKED);
  }
 else   if (areThereExpiredModules()) {
    underneathModuleTableMessagePanel.setState(MessageState.EXPIRED);
  }
 else   if (areThereNonFunctionalModules()) {
    underneathModuleTableMessagePanel.setState(MessageState.UNSUPPORTED);
  }
 else {
    underneathModuleTableMessagePanel.setState(MessageState.NO_ERROR);
  }
  String cardName=NO_LICENSE_BUTTON_PANEL;
  if (state == ActivationState.AUTHORIZED) {
    if (isEditMode) {
      cardName=EDIT_LICENSE_BUTTON_PANEL;
    }
 else {
      cardName=OK_LICENSE_BUTTON_PANEL;
    }
  }
 else   if (state == ActivationState.REFRESHING) {
    cardName=OK_LICENSE_BUTTON_PANEL;
  }
  selectCard(cardName);
  if (state == ActivationState.REFRESHING) {
    ((ActivatedButtonPanel)cardMap.get(OK_LICENSE_BUTTON_PANEL)).setRefreshEnabled(false);
  }
 else   if (state == ActivationState.AUTHORIZED) {
    ((ActivatedButtonPanel)cardMap.get(OK_LICENSE_BUTTON_PANEL)).setRefreshEnabled(true);
  }
  activationPanel.revalidate();
}",0.983403517463463
3733,"@Inject public ActivationCommunicatorImpl(ActSettings activationSettings,ActivationResponseFactory activationFactory,Provider<LimeHttpClient> httpClientProvider){
  this.activationSettings=activationSettings;
  this.httpClientProvider=httpClientProvider;
  this.activationFactory=activationFactory;
}","@Inject public ActivationCommunicatorImpl(ActivationSettingsController activationSettings,ActivationResponseFactory activationFactory,Provider<LimeHttpClient> httpClientProvider){
  this.activationSettings=activationSettings;
  this.httpClientProvider=httpClientProvider;
  this.activationFactory=activationFactory;
}",0.9724473257698542
3734,"@Inject public ActivationItemFactoryImpl(ActSettings activationSettings){
  this.activationSettings=activationSettings;
}","@Inject public ActivationItemFactoryImpl(ActivationSettingsController activationSettings){
  this.activationSettings=activationSettings;
}",0.9343629343629344
3735,"public ActivationItemImpl(ActSettings activationSettings,int intID,String licenseName,Date datePurchased,Date dateExpired,Status currentStatus,boolean isLoadedFromDisk){
  this.activationSettings=activationSettings;
  this.intID=intID;
  this.moduleID=ActivationID.getActivationID(intID);
  this.licenseName=licenseName;
  this.datePurchased=datePurchased;
  this.dateExpired=dateExpired;
  this.currentStatus=updateActivationStatus(currentStatus,isLoadedFromDisk);
}","public ActivationItemImpl(ActivationSettingsController activationSettings,int intID,String licenseName,Date datePurchased,Date dateExpired,Status currentStatus,boolean isLoadedFromDisk){
  this.activationSettings=activationSettings;
  this.intID=intID;
  this.moduleID=ActivationID.getActivationID(intID);
  this.licenseName=licenseName;
  this.datePurchased=datePurchased;
  this.dateExpired=dateExpired;
  this.currentStatus=updateActivationStatus(currentStatus,isLoadedFromDisk);
}",0.9652996845425869
3736,"@Inject public ActivationManagerImpl(@Named(""String_Node_Str"") ScheduledExecutorService scheduler,ActivationCommunicator activationCommunicator,ActivationModel activationModel,ActivationSerializer activationSerializer,ActivationResponseFactory activationReponseFactory,ActSettings activationSettings){
  this.activationModel=activationModel;
  this.scheduler=scheduler;
  this.activationCommunicator=activationCommunicator;
  this.activationSerializer=activationSerializer;
  this.activationResponseFactory=activationReponseFactory;
  this.activationSettings=activationSettings;
}","@Inject public ActivationManagerImpl(@Named(""String_Node_Str"") ScheduledExecutorService scheduler,ActivationCommunicator activationCommunicator,ActivationModel activationModel,ActivationSerializer activationSerializer,ActivationResponseFactory activationReponseFactory,ActivationSettingsController activationSettings){
  this.activationModel=activationModel;
  this.scheduler=scheduler;
  this.activationCommunicator=activationCommunicator;
  this.activationSerializer=activationSerializer;
  this.activationResponseFactory=activationReponseFactory;
  this.activationSettings=activationSettings;
}",0.9855564995751912
3737,"@Inject public ActivationSerializerImpl(ActivationSerializerSettings settings,CipherProvider cipherProvider,ActSettings activationSettings){
  this.settings=settings;
  this.cipherProvider=cipherProvider;
  this.activationSettings=activationSettings;
}","@Inject public ActivationSerializerImpl(ActivationSerializerSettings settings,CipherProvider cipherProvider,ActivationSettingsController activationSettings){
  this.settings=settings;
  this.cipherProvider=cipherProvider;
  this.activationSettings=activationSettings;
}",0.9366602687140116
3738,"private Module[] getModules(){
  List<Module> modules=new ArrayList<Module>();
  modules.add(new AbstractModule(){
    @Override public void configure(){
      bind(ActSettings.class).toInstance(new ActivationSettingStub());
      bind(ActivationCommunicator.class).to(ActivationCommunicatorImpl.class);
      bind(ActivationResponseFactory.class).to(ActivationResponseFactoryImpl.class);
      bind(ActivationItemFactory.class).to(ActivationItemFactoryImpl.class);
      bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(new SimpleTimer(true));
    }
  }
);
  modules.add(new LimeWireHttpModule());
  modules.add(new LimeWireCommonModule());
  modules.add(new LimeWireNetTestModule());
  return modules.toArray(new Module[modules.size()]);
}","private Module[] getModules(){
  List<Module> modules=new ArrayList<Module>();
  modules.add(new AbstractModule(){
    @Override public void configure(){
      bind(ActivationSettingsController.class).toInstance(new ActivationSettingStub());
      bind(ActivationCommunicator.class).to(ActivationCommunicatorImpl.class);
      bind(ActivationResponseFactory.class).to(ActivationResponseFactoryImpl.class);
      bind(ActivationItemFactory.class).to(ActivationItemFactoryImpl.class);
      bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(new SimpleTimer(true));
    }
  }
);
  modules.add(new LimeWireHttpModule());
  modules.add(new LimeWireCommonModule());
  modules.add(new LimeWireNetTestModule());
  return modules.toArray(new Module[modules.size()]);
}",0.9893014474512272
3739,"@Override public void configure(){
  bind(ActSettings.class).toInstance(new ActivationSettingStub());
  bind(ActivationCommunicator.class).to(ActivationCommunicatorImpl.class);
  bind(ActivationResponseFactory.class).to(ActivationResponseFactoryImpl.class);
  bind(ActivationItemFactory.class).to(ActivationItemFactoryImpl.class);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(new SimpleTimer(true));
}","@Override public void configure(){
  bind(ActivationSettingsController.class).toInstance(new ActivationSettingStub());
  bind(ActivationCommunicator.class).to(ActivationCommunicatorImpl.class);
  bind(ActivationResponseFactory.class).to(ActivationResponseFactoryImpl.class);
  bind(ActivationItemFactory.class).to(ActivationItemFactoryImpl.class);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(new SimpleTimer(true));
}",0.981541802388708
3740,"@Override protected void setUp() throws Exception {
  injector=createInjector(getModules());
  serverController=new ServerController();
  comm=injector.getInstance(ActivationCommunicator.class);
  settingsStub=(ActivationSettingStub)injector.getInstance(ActSettings.class);
  settingsStub.setActivationHost(""String_Node_Str"");
}","@Override protected void setUp() throws Exception {
  injector=createInjector(getModules());
  serverController=new ServerController();
  comm=injector.getInstance(ActivationCommunicator.class);
  settingsStub=(ActivationSettingStub)injector.getInstance(ActivationSettingsController.class);
  settingsStub.setActivationHost(""String_Node_Str"");
}",0.950965824665676
3741,"private Module[] getModules(){
  List<Module> modules=new ArrayList<Module>();
  modules.add(new AbstractModule(){
    @Override public void configure(){
      bind(CipherProvider.class).to(CipherProviderImpl.class);
      bind(ActSettings.class).to(ActivationSettingStub.class);
      bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(new SimpleTimer(true));
      LimeScheduledThreadPoolExecutor scheduledThreadExecutor=new LimeScheduledThreadPoolExecutor(1,ExecutorsHelper.daemonThreadFactory(""String_Node_Str""));
      bind(Executor.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(scheduledThreadExecutor);
      bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(scheduledThreadExecutor);
      bind(ActivationResponseFactory.class).to(ActivationResponseFactoryImpl.class);
      bind(ActivationModel.class).to(ActivationModelImpl.class);
      bind(ActivationItemFactory.class).to(ActivationItemFactoryImpl.class);
    }
  }
);
  modules.add(new ActivationSerializerModule());
  modules.add(new LimeWireHttpModule());
  modules.add(new LimeWireCommonModule());
  modules.add(new LimeWireNetTestModule());
  return modules.toArray(new Module[modules.size()]);
}","private Module[] getModules(){
  List<Module> modules=new ArrayList<Module>();
  modules.add(new AbstractModule(){
    @Override public void configure(){
      bind(CipherProvider.class).to(CipherProviderImpl.class);
      bind(ActivationSettingsController.class).to(ActivationSettingStub.class);
      bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(new SimpleTimer(true));
      LimeScheduledThreadPoolExecutor scheduledThreadExecutor=new LimeScheduledThreadPoolExecutor(1,ExecutorsHelper.daemonThreadFactory(""String_Node_Str""));
      bind(Executor.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(scheduledThreadExecutor);
      bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(scheduledThreadExecutor);
      bind(ActivationResponseFactory.class).to(ActivationResponseFactoryImpl.class);
      bind(ActivationModel.class).to(ActivationModelImpl.class);
      bind(ActivationItemFactory.class).to(ActivationItemFactoryImpl.class);
    }
  }
);
  modules.add(new ActivationSerializerModule());
  modules.add(new LimeWireHttpModule());
  modules.add(new LimeWireCommonModule());
  modules.add(new LimeWireNetTestModule());
  return modules.toArray(new Module[modules.size()]);
}",0.9933463796477496
3742,"@Override public void configure(){
  bind(CipherProvider.class).to(CipherProviderImpl.class);
  bind(ActSettings.class).to(ActivationSettingStub.class);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(new SimpleTimer(true));
  LimeScheduledThreadPoolExecutor scheduledThreadExecutor=new LimeScheduledThreadPoolExecutor(1,ExecutorsHelper.daemonThreadFactory(""String_Node_Str""));
  bind(Executor.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(scheduledThreadExecutor);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(scheduledThreadExecutor);
  bind(ActivationResponseFactory.class).to(ActivationResponseFactoryImpl.class);
  bind(ActivationModel.class).to(ActivationModelImpl.class);
  bind(ActivationItemFactory.class).to(ActivationItemFactoryImpl.class);
}","@Override public void configure(){
  bind(CipherProvider.class).to(CipherProviderImpl.class);
  bind(ActivationSettingsController.class).to(ActivationSettingStub.class);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(new SimpleTimer(true));
  LimeScheduledThreadPoolExecutor scheduledThreadExecutor=new LimeScheduledThreadPoolExecutor(1,ExecutorsHelper.daemonThreadFactory(""String_Node_Str""));
  bind(Executor.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(scheduledThreadExecutor);
  bind(ScheduledExecutorService.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(scheduledThreadExecutor);
  bind(ActivationResponseFactory.class).to(ActivationResponseFactoryImpl.class);
  bind(ActivationModel.class).to(ActivationModelImpl.class);
  bind(ActivationItemFactory.class).to(ActivationItemFactoryImpl.class);
}",0.9903244166192372
3743,"@Override protected void setUp() throws Exception {
  injector=Guice.createInjector(Stage.DEVELOPMENT,getModules());
  responseFactory=injector.getInstance(ActivationResponseFactory.class);
  activationSettings=injector.getInstance(ActSettings.class);
}","@Override protected void setUp() throws Exception {
  injector=Guice.createInjector(Stage.DEVELOPMENT,getModules());
  responseFactory=injector.getInstance(ActivationResponseFactory.class);
  activationSettings=injector.getInstance(ActivationSettingsController.class);
}",0.9674952198852772
3744,"@Override protected void configure(){
  bind(ActivationTest.class).to(ActivationTestImpl.class);
  bind(ActivityCallback.class).to(GlueActivityCallback.class);
  bind(GuiCallbackService.class).to(GlueActivityCallback.class);
  bind(QueryReplyListenerList.class).to(GlueActivityCallback.class);
  bind(DownloadListenerList.class).to(GlueActivityCallback.class);
  bind(UploadListenerList.class).to(GlueActivityCallback.class);
  bind(IncomingSearchListenerList.class).to(GlueActivityCallback.class);
  bind(Application.class).to(ApplicationImpl.class);
  bind(HttpClientInstanceUtils.class).to(ApplicationImpl.class);
  bind(LifeCycleManager.class).to(LifeCycleManagerImpl.class);
  bind(MagnetFactory.class).to(MagnetFactoryImpl.class);
  bind(ItunesMediator.class).to(ItunesMediatorImpl.class);
  bind(InspectionsCommunicator.class).to(InspectionsCommunicatorImpl.class);
  install(new CoreGlueSpamModule());
  install(new CoreGlueActivationModule());
  install(new CoreGlueConnectionModule());
  install(new CoreGlueDaapModule());
  install(new CoreGlueSearchModule());
  install(new CoreGlueBrowseSearchModule());
  install(new CoreGlueNetworkModule());
  install(new CoreGlueFriendModule());
  install(new CoreGlueDownloadModule());
  install(new CoreGlueLibraryModule());
  install(new CoreGlueMojitoModule());
  install(new CoreGlueMonitorModule());
  install(new CoreGlueBrowseModule());
  install(new CoreGlueXMPPModule());
  install(new CoreGluePlayerModule());
  install(new CoreGluePropertiesModule());
  install(new CoreGlueMozillaModule());
  install(new CoreGlueSupportModule());
  install(new CoreGlueUploadModule());
  install(new CoreGlueUpdatesModule());
}","@Override protected void configure(){
  bind(ActivationTest.class).to(ActivationTestImpl.class);
  bind(ActivityCallback.class).to(GlueActivityCallback.class);
  bind(GuiCallbackService.class).to(GlueActivityCallback.class);
  bind(QueryReplyListenerList.class).to(GlueActivityCallback.class);
  bind(DownloadListenerList.class).to(GlueActivityCallback.class);
  bind(UploadListenerList.class).to(GlueActivityCallback.class);
  bind(IncomingSearchListenerList.class).to(GlueActivityCallback.class);
  bind(Application.class).to(ApplicationImpl.class);
  bind(HttpClientInstanceUtils.class).to(ApplicationImpl.class);
  bind(LifeCycleManager.class).to(LifeCycleManagerImpl.class);
  bind(MagnetFactory.class).to(MagnetFactoryImpl.class);
  bind(ItunesMediator.class).to(ItunesMediatorImpl.class);
  bind(InspectionsCommunicator.class).to(InspectionsCommunicatorImpl.class);
  install(new CoreGlueSpamModule());
  install(new CoreGlueConnectionModule());
  install(new CoreGlueDaapModule());
  install(new CoreGlueSearchModule());
  install(new CoreGlueBrowseSearchModule());
  install(new CoreGlueNetworkModule());
  install(new CoreGlueFriendModule());
  install(new CoreGlueDownloadModule());
  install(new CoreGlueLibraryModule());
  install(new CoreGlueMojitoModule());
  install(new CoreGlueMonitorModule());
  install(new CoreGlueBrowseModule());
  install(new CoreGlueXMPPModule());
  install(new CoreGluePlayerModule());
  install(new CoreGluePropertiesModule());
  install(new CoreGlueMozillaModule());
  install(new CoreGlueSupportModule());
  install(new CoreGlueUploadModule());
  install(new CoreGlueUpdatesModule());
}",0.9869894099848714
3745,"@Override protected void configure(){
  binder().install(new LimeWireCommonModule());
  binder().install(new LimeWireCoreSettingsModule());
  binder().install(new LimeWireSettingsModule());
  binder().install(new LimeWireNetModule(SettingsBackedProxySettings.class,SettingsBackedSocketBindingSettings.class));
  binder().install(new LimeWireDownloadModule());
  binder().install(new LimeWireHashTreeModule());
  binder().install(new LimeWireDHTModule());
  binder().install(new LimeWireHttpModule());
  binder().install(new LimeWireSearchModule());
  binder().install(new LimeWireStatisticsModule());
  binder().install(new LimeWireGnutellaStatisticsModule());
  binder().install(new LimeWireGnutellaRudpModule());
  binder().install(new LimeWireIOModule());
  binder().install(new LimeWireMojitoModule());
  binder().install(new LimeWireSecurityCertificateModule());
  binder().install(new LimewireGeocodeModule());
  binder().install(new LimeWirePromotionModule(PromotionBinderRequestorImpl.class,PromotionServicesImpl.class));
  binder().install(new LimeWireSimppModule());
  binder().install(new LimeWireBittorrentModule());
  binder().install(new LimeWireLibraryModule());
  binder().install(new LimeWireUploaderModule());
  binder().install(new LimeWireContentAuthModule());
  binder().install(new LimeWireFiltersModule());
  binder().install(new LimeWireSpamModule());
  binder().install(new LimeWireCoreConnectionModule());
  binder().install(new LimeWireBootstrapModule());
  binder().install(new LimeWireMalwareModule());
  binder().install(new LimeWireXmlModule());
  if (activityCallbackClass != null) {
    bind(ActivityCallback.class).to(activityCallbackClass);
  }
  bind(DownloadCallback.class).to(ActivityCallback.class);
  bind(NetworkManager.class).to(NetworkManagerImpl.class);
  bind(TLSManager.class).to(NetworkManagerImpl.class);
  bind(new TypeLiteral<ListenerSupport<AddressEvent>>(){
  }
).to(NetworkManagerImpl.class);
  bind(DHTManager.class).to(DHTManagerImpl.class);
  bind(DHTControllerFactory.class).to(DHTControllerFactoryImpl.class);
  bind(PingReplyFactory.class).to(PingReplyFactoryImpl.class);
  bind(PushProxiesValueFactory.class).to(PushProxiesValueFactoryImpl.class);
  bind(HandshakeResponderFactory.class).to(HandshakeResponderFactoryImpl.class);
  bind(HeadersFactory.class).to(HeadersFactoryImpl.class);
  bind(PushEndpointFactory.class).to(PushEndpointFactoryImpl.class);
  bind(HeadPongFactory.class).to(HeadPongFactoryImpl.class);
  bind(UploadManager.class).to(HTTPUploadManager.class);
  bind(HTTPUploadSessionManager.class).to(HTTPUploadManager.class);
  bind(QueryHandlerFactory.class).to(QueryHandlerFactoryImpl.class);
  bind(QueryRequestFactory.class).to(QueryRequestFactoryImpl.class);
  bind(AltLocValueFactory.class).to(AltLocValueFactoryImpl.class);
  bind(AlternateLocationFactory.class).to(AlternateLocationFactoryImpl.class);
  bind(HttpExecutor.class).to(DefaultHttpExecutor.class);
  bind(HttpRequestHandlerFactory.class).to(HttpRequestHandlerFactoryImpl.class);
  bind(ResponseFactory.class).to(ResponseFactoryImpl.class);
  bind(QueryReplyFactory.class).to(QueryReplyFactoryImpl.class);
  bind(MessageDispatcherFactory.class).to(LimeMessageDispatcherFactoryImpl.class);
  bind(CapabilitiesVMFactory.class).to(CapabilitiesVMFactoryImpl.class);
  bind(LifecycleManager.class).to(LifecycleManagerImpl.class);
  bind(LocalPongInfo.class).to(LocalPongInfoImpl.class);
  bind(ConnectionServices.class).to(ConnectionServicesImpl.class);
  bind(SearchServices.class).to(SearchServicesImpl.class);
  bind(DownloadServices.class).to(DownloadServicesImpl.class);
  bind(UploadServices.class).to(UploadServicesImpl.class);
  bind(ApplicationServices.class).to(ApplicationServicesImpl.class);
  bind(SpamServices.class).to(SpamServicesImpl.class);
  bind(DHTControllerFacade.class).to(DHTControllerFacadeImpl.class);
  bind(DHTBootstrapperFactory.class).to(DHTBootstrapperFactoryImpl.class);
  bind(DHTNodeFetcherFactory.class).to(DHTNodeFetcherFactoryImpl.class);
  bind(UDPReplyHandlerFactory.class).to(UDPReplyHandlerFactoryImpl.class);
  bind(UDPReplyHandlerCache.class).to(UDPReplyHandlerCacheImpl.class);
  bind(SocketProcessor.class).to(Acceptor.class);
  bind(DownloadManager.class).to(DownloadManagerImpl.class).asEagerSingleton();
  bind(BrowseHostHandlerManagerImpl.class).asEagerSingleton();
  bind(ReplyNumberVendorMessageFactory.class).to(ReplyNumberVendorMessageFactoryImpl.class);
  bind(GuidMapManager.class).to(GuidMapManagerImpl.class);
  bind(BrowseHostHandlerManager.class).to(BrowseHostHandlerManagerImpl.class);
  bind(PushEndpointCache.class).to(PushEndpointCacheImpl.class);
  bind(PushEndpointService.class).annotatedWith(Names.named(""String_Node_Str"")).to(PushEndpointCacheImpl.class);
  bind(FileResponseEntityFactory.class).to(FileResponseEntityFactoryImpl.class);
  bind(MessageFactory.class).to(MessageFactoryImpl.class);
  bind(MessageParserBinder.class).to(MessageParserBinderImpl.class);
  bind(VendorMessageFactory.class).to(VendorMessageFactoryImpl.class);
  bind(VendorMessageParserBinder.class).to(VendorMessageParserBinderImpl.class);
  bind(UDPCrawlerPongFactory.class).to(UDPCrawlerPongFactoryImpl.class);
  bind(LicenseFactory.class).to(LicenseFactoryImpl.class);
  bind(MetaDataFactory.class).to(MetaDataFactoryImpl.class);
  bind(SaveLocationManager.class).to(DownloadManager.class);
  bind(BTUploaderFactory.class).to(TorrentUploadManager.class);
  bind(PingRequestFactory.class).to(PingRequestFactoryImpl.class);
  bind(IpPortContentAuthorityFactory.class).to(IpPortContentAuthorityFactoryImpl.class);
  bind(UpdateCollectionFactory.class).to(UpdateCollectionFactoryImpl.class);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(UDPPinger.class).to(UDPPingerImpl.class);
  bind(Inspector.class).to(InspectorImpl.class);
  bind(LWSManager.class).to(LWSManagerImpl.class);
  bind(LWSIntegrationServicesDelegate.class).to(DownloadManager.class);
  bind(LocalSocketAddressProvider.class).to(LocalSocketAddressProviderImpl.class);
  bind(SettingsProvider.class).to(MacCalculatorSettingsProviderImpl.class);
  bind(ReplyHandler.class).annotatedWith(Names.named(""String_Node_Str"")).to(ForMeReplyHandler.class);
  bind(MessageRouter.class).to(StandardMessageRouter.class);
  bind(UploadSlotManager.class).to(UploadSlotManagerImpl.class);
  bind(BandwidthManager.class).to(BandwidthManagerImpl.class);
  bind(PongCacher.class).to(PongCacherImpl.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(UploadManager.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(DownloadManager.class);
  bind(ResponseVerifier.class).to(ResponseVerifierImpl.class);
  bind(HandshakeServices.class).to(HandshakeServicesImpl.class);
  bind(ConnectionManager.class).to(ConnectionManagerImpl.class);
  bind(MessageHandlerBinder.class).to(MessageHandlerBinderImpl.class);
  bind(QueryDispatcher.class).to(QueryDispatcherImpl.class);
  bind(Acceptor.class).to(AcceptorImpl.class);
  bind(UpdateHandler.class).to(UpdateHandlerImpl.class);
  bind(SecurityToken.TokenProvider.class).to(SecurityToken.AddressSecurityTokenProvider.class);
  bind(UpdateMessageVerifier.class).to(UpdateMessageVerifierImpl.class);
  bind(InspectionResponseFactory.class).to(InspectionResponseFactoryImpl.class);
  bind(FECUtils.class).to(FECUtilsImpl.class);
  bind(BandwidthCollector.class).to(BandwidthCollectorImpl.class);
  bind(BandwidthCollectorDriver.class).to(BandwidthCollectorImpl.class);
  bind(NodeAssigner.class).to(NodeAssignerImpl.class);
  bind(OutgoingQueryReplyFactory.class).to(OutgoingQueryReplyFactoryImpl.class);
  bind(UPnPManagerConfiguration.class).to(UPnPManagerConfigurationImpl.class);
  bind(Bootstrapper.Listener.class).to(HostCatcher.class);
  bind(RareFileStrategy.class).to(RareFileStrategyImpl.class);
  bind(MulticastService.class).to(MulticastServiceImpl.class);
  bind(NetworkUpdateSanityChecker.class).to(NetworkUpdateSanityCheckerImpl.class);
  bind(CategoryManager.class).to(CategoryManagerImpl.class);
  Executor fwtEventExecutor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  AsynchronousCachingEventMulticasterImpl<FirewallTransferStatusEvent> asyncTransferMulticaster=new AsynchronousCachingEventMulticasterImpl<FirewallTransferStatusEvent>(fwtEventExecutor,BroadcastPolicy.IF_NOT_EQUALS);
  bind(new TypeLiteral<EventBean<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  bind(new TypeLiteral<AsynchronousEventBroadcaster<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  bind(new TypeLiteral<ListenerSupport<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  AsynchronousCachingEventMulticasterImpl<FirewallStatusEvent> asyncStatusMulticaster=new AsynchronousCachingEventMulticasterImpl<FirewallStatusEvent>(fwtEventExecutor,BroadcastPolicy.IF_NOT_EQUALS);
  bind(new TypeLiteral<EventBean<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(new TypeLiteral<AsynchronousEventBroadcaster<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(new TypeLiteral<ListenerSupport<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(Statistics.class);
  bind(CoreRandomGlue.class);
  bind(ConnectionAcceptorGlue.class);
  bind(DownloadUpgradeTaskService.class);
  bind(LocalAcceptor.class);
  bind(Pinger.class);
  bind(ConnectionWatchdog.class);
  bind(OutOfBandThroughputMeasurer.class);
  bind(HostCatcher.class);
  bind(LimeCoreGlue.class);
  bind(QRPUpdater.class);
  bind(DaapManager.class);
  bind(FirewalledAddressSerializer.class).asEagerSingleton();
  bind(SameNATAddressResolver.class).asEagerSingleton();
  bind(ConnectableConnector.class).asEagerSingleton();
  bind(PushEndpointSerializer.class).asEagerSingleton();
}","@Override protected void configure(){
  binder().install(new LimeWireCommonModule());
  binder().install(new LimeWireCoreSettingsModule());
  binder().install(new LimeWireSettingsModule());
  binder().install(new LimeWireNetModule(SettingsBackedProxySettings.class,SettingsBackedSocketBindingSettings.class));
  binder().install(new LimeWireDownloadModule());
  binder().install(new LimeWireHashTreeModule());
  binder().install(new LimeWireDHTModule());
  binder().install(new LimeWireActivationModule());
  binder().install(new LimeWireHttpModule());
  binder().install(new LimeWireSearchModule());
  binder().install(new LimeWireStatisticsModule());
  binder().install(new LimeWireGnutellaStatisticsModule());
  binder().install(new LimeWireGnutellaRudpModule());
  binder().install(new LimeWireIOModule());
  binder().install(new LimeWireMojitoModule());
  binder().install(new LimeWireSecurityCertificateModule());
  binder().install(new LimewireGeocodeModule());
  binder().install(new LimeWirePromotionModule(PromotionBinderRequestorImpl.class,PromotionServicesImpl.class));
  binder().install(new LimeWireSimppModule());
  binder().install(new LimeWireBittorrentModule());
  binder().install(new LimeWireLibraryModule());
  binder().install(new LimeWireUploaderModule());
  binder().install(new LimeWireContentAuthModule());
  binder().install(new LimeWireFiltersModule());
  binder().install(new LimeWireSpamModule());
  binder().install(new LimeWireCoreConnectionModule());
  binder().install(new LimeWireBootstrapModule());
  binder().install(new LimeWireMalwareModule());
  binder().install(new LimeWireXmlModule());
  if (activityCallbackClass != null) {
    bind(ActivityCallback.class).to(activityCallbackClass);
  }
  bind(ActivationSettingsController.class).to(ActivationSettingsImpl.class);
  bind(DownloadCallback.class).to(ActivityCallback.class);
  bind(NetworkManager.class).to(NetworkManagerImpl.class);
  bind(TLSManager.class).to(NetworkManagerImpl.class);
  bind(new TypeLiteral<ListenerSupport<AddressEvent>>(){
  }
).to(NetworkManagerImpl.class);
  bind(DHTManager.class).to(DHTManagerImpl.class);
  bind(DHTControllerFactory.class).to(DHTControllerFactoryImpl.class);
  bind(PingReplyFactory.class).to(PingReplyFactoryImpl.class);
  bind(PushProxiesValueFactory.class).to(PushProxiesValueFactoryImpl.class);
  bind(HandshakeResponderFactory.class).to(HandshakeResponderFactoryImpl.class);
  bind(HeadersFactory.class).to(HeadersFactoryImpl.class);
  bind(PushEndpointFactory.class).to(PushEndpointFactoryImpl.class);
  bind(HeadPongFactory.class).to(HeadPongFactoryImpl.class);
  bind(UploadManager.class).to(HTTPUploadManager.class);
  bind(HTTPUploadSessionManager.class).to(HTTPUploadManager.class);
  bind(QueryHandlerFactory.class).to(QueryHandlerFactoryImpl.class);
  bind(QueryRequestFactory.class).to(QueryRequestFactoryImpl.class);
  bind(AltLocValueFactory.class).to(AltLocValueFactoryImpl.class);
  bind(AlternateLocationFactory.class).to(AlternateLocationFactoryImpl.class);
  bind(HttpExecutor.class).to(DefaultHttpExecutor.class);
  bind(HttpRequestHandlerFactory.class).to(HttpRequestHandlerFactoryImpl.class);
  bind(ResponseFactory.class).to(ResponseFactoryImpl.class);
  bind(QueryReplyFactory.class).to(QueryReplyFactoryImpl.class);
  bind(MessageDispatcherFactory.class).to(LimeMessageDispatcherFactoryImpl.class);
  bind(CapabilitiesVMFactory.class).to(CapabilitiesVMFactoryImpl.class);
  bind(LifecycleManager.class).to(LifecycleManagerImpl.class);
  bind(LocalPongInfo.class).to(LocalPongInfoImpl.class);
  bind(ConnectionServices.class).to(ConnectionServicesImpl.class);
  bind(SearchServices.class).to(SearchServicesImpl.class);
  bind(DownloadServices.class).to(DownloadServicesImpl.class);
  bind(UploadServices.class).to(UploadServicesImpl.class);
  bind(ApplicationServices.class).to(ApplicationServicesImpl.class);
  bind(SpamServices.class).to(SpamServicesImpl.class);
  bind(DHTControllerFacade.class).to(DHTControllerFacadeImpl.class);
  bind(DHTBootstrapperFactory.class).to(DHTBootstrapperFactoryImpl.class);
  bind(DHTNodeFetcherFactory.class).to(DHTNodeFetcherFactoryImpl.class);
  bind(UDPReplyHandlerFactory.class).to(UDPReplyHandlerFactoryImpl.class);
  bind(UDPReplyHandlerCache.class).to(UDPReplyHandlerCacheImpl.class);
  bind(SocketProcessor.class).to(Acceptor.class);
  bind(DownloadManager.class).to(DownloadManagerImpl.class).asEagerSingleton();
  bind(BrowseHostHandlerManagerImpl.class).asEagerSingleton();
  bind(ReplyNumberVendorMessageFactory.class).to(ReplyNumberVendorMessageFactoryImpl.class);
  bind(GuidMapManager.class).to(GuidMapManagerImpl.class);
  bind(BrowseHostHandlerManager.class).to(BrowseHostHandlerManagerImpl.class);
  bind(PushEndpointCache.class).to(PushEndpointCacheImpl.class);
  bind(PushEndpointService.class).annotatedWith(Names.named(""String_Node_Str"")).to(PushEndpointCacheImpl.class);
  bind(FileResponseEntityFactory.class).to(FileResponseEntityFactoryImpl.class);
  bind(MessageFactory.class).to(MessageFactoryImpl.class);
  bind(MessageParserBinder.class).to(MessageParserBinderImpl.class);
  bind(VendorMessageFactory.class).to(VendorMessageFactoryImpl.class);
  bind(VendorMessageParserBinder.class).to(VendorMessageParserBinderImpl.class);
  bind(UDPCrawlerPongFactory.class).to(UDPCrawlerPongFactoryImpl.class);
  bind(LicenseFactory.class).to(LicenseFactoryImpl.class);
  bind(MetaDataFactory.class).to(MetaDataFactoryImpl.class);
  bind(SaveLocationManager.class).to(DownloadManager.class);
  bind(BTUploaderFactory.class).to(TorrentUploadManager.class);
  bind(PingRequestFactory.class).to(PingRequestFactoryImpl.class);
  bind(IpPortContentAuthorityFactory.class).to(IpPortContentAuthorityFactoryImpl.class);
  bind(UpdateCollectionFactory.class).to(UpdateCollectionFactoryImpl.class);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(UDPPinger.class).to(UDPPingerImpl.class);
  bind(Inspector.class).to(InspectorImpl.class);
  bind(LWSManager.class).to(LWSManagerImpl.class);
  bind(LWSIntegrationServicesDelegate.class).to(DownloadManager.class);
  bind(LocalSocketAddressProvider.class).to(LocalSocketAddressProviderImpl.class);
  bind(SettingsProvider.class).to(MacCalculatorSettingsProviderImpl.class);
  bind(ReplyHandler.class).annotatedWith(Names.named(""String_Node_Str"")).to(ForMeReplyHandler.class);
  bind(MessageRouter.class).to(StandardMessageRouter.class);
  bind(UploadSlotManager.class).to(UploadSlotManagerImpl.class);
  bind(BandwidthManager.class).to(BandwidthManagerImpl.class);
  bind(PongCacher.class).to(PongCacherImpl.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(UploadManager.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(DownloadManager.class);
  bind(ResponseVerifier.class).to(ResponseVerifierImpl.class);
  bind(HandshakeServices.class).to(HandshakeServicesImpl.class);
  bind(ConnectionManager.class).to(ConnectionManagerImpl.class);
  bind(MessageHandlerBinder.class).to(MessageHandlerBinderImpl.class);
  bind(QueryDispatcher.class).to(QueryDispatcherImpl.class);
  bind(Acceptor.class).to(AcceptorImpl.class);
  bind(UpdateHandler.class).to(UpdateHandlerImpl.class);
  bind(SecurityToken.TokenProvider.class).to(SecurityToken.AddressSecurityTokenProvider.class);
  bind(UpdateMessageVerifier.class).to(UpdateMessageVerifierImpl.class);
  bind(InspectionResponseFactory.class).to(InspectionResponseFactoryImpl.class);
  bind(FECUtils.class).to(FECUtilsImpl.class);
  bind(BandwidthCollector.class).to(BandwidthCollectorImpl.class);
  bind(BandwidthCollectorDriver.class).to(BandwidthCollectorImpl.class);
  bind(NodeAssigner.class).to(NodeAssignerImpl.class);
  bind(OutgoingQueryReplyFactory.class).to(OutgoingQueryReplyFactoryImpl.class);
  bind(UPnPManagerConfiguration.class).to(UPnPManagerConfigurationImpl.class);
  bind(Bootstrapper.Listener.class).to(HostCatcher.class);
  bind(RareFileStrategy.class).to(RareFileStrategyImpl.class);
  bind(MulticastService.class).to(MulticastServiceImpl.class);
  bind(NetworkUpdateSanityChecker.class).to(NetworkUpdateSanityCheckerImpl.class);
  bind(CategoryManager.class).to(CategoryManagerImpl.class);
  Executor fwtEventExecutor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  AsynchronousCachingEventMulticasterImpl<FirewallTransferStatusEvent> asyncTransferMulticaster=new AsynchronousCachingEventMulticasterImpl<FirewallTransferStatusEvent>(fwtEventExecutor,BroadcastPolicy.IF_NOT_EQUALS);
  bind(new TypeLiteral<EventBean<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  bind(new TypeLiteral<AsynchronousEventBroadcaster<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  bind(new TypeLiteral<ListenerSupport<FirewallTransferStatusEvent>>(){
  }
).toInstance(asyncTransferMulticaster);
  AsynchronousCachingEventMulticasterImpl<FirewallStatusEvent> asyncStatusMulticaster=new AsynchronousCachingEventMulticasterImpl<FirewallStatusEvent>(fwtEventExecutor,BroadcastPolicy.IF_NOT_EQUALS);
  bind(new TypeLiteral<EventBean<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(new TypeLiteral<AsynchronousEventBroadcaster<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(new TypeLiteral<ListenerSupport<FirewallStatusEvent>>(){
  }
).toInstance(asyncStatusMulticaster);
  bind(Statistics.class);
  bind(CoreRandomGlue.class);
  bind(ConnectionAcceptorGlue.class);
  bind(DownloadUpgradeTaskService.class);
  bind(LocalAcceptor.class);
  bind(Pinger.class);
  bind(ConnectionWatchdog.class);
  bind(OutOfBandThroughputMeasurer.class);
  bind(HostCatcher.class);
  bind(LimeCoreGlue.class);
  bind(QRPUpdater.class);
  bind(DaapManager.class);
  bind(FirewalledAddressSerializer.class).asEagerSingleton();
  bind(SameNATAddressResolver.class).asEagerSingleton();
  bind(ConnectableConnector.class).asEagerSingleton();
  bind(PushEndpointSerializer.class).asEagerSingleton();
}",0.9936393668951236
3746,"public void run(){
  boolean enabled=SwingUiSettings.PLAYER_ENABLED.getValue();
  if (!enabled) {
    getPlayerMediator().stop();
    if (getPlayerMediator().hasScrollingTitle()) {
      titleLabel.stop();
    }
  }
  PlayerControlPanel.this.innerPanel.setVisible(enabled);
}","public void run(){
  boolean enabled=SwingUiSettings.PLAYER_ENABLED.getValue();
  if (!enabled) {
    getPlayerMediator().stop();
    resetPlayer();
  }
  PlayerControlPanel.this.innerPanel.setVisible(enabled);
}",0.5913757700205339
3747,"@Override public void settingChanged(final SettingEvent evt){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      boolean enabled=SwingUiSettings.PLAYER_ENABLED.getValue();
      if (!enabled) {
        getPlayerMediator().stop();
        if (getPlayerMediator().hasScrollingTitle()) {
          titleLabel.stop();
        }
      }
      PlayerControlPanel.this.innerPanel.setVisible(enabled);
    }
  }
);
}","@Override public void settingChanged(final SettingEvent evt){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      boolean enabled=SwingUiSettings.PLAYER_ENABLED.getValue();
      if (!enabled) {
        getPlayerMediator().stop();
        resetPlayer();
      }
      PlayerControlPanel.this.innerPanel.setVisible(enabled);
    }
  }
);
}",0.7104930467762326
3748,"/** 
 * Registers listeners for player events.
 */
private void register(){
  getPlayerMediator().addMediatorListener(this);
  settingListener=new SettingListener(){
    @Override public void settingChanged(    final SettingEvent evt){
      SwingUtilities.invokeLater(new Runnable(){
        public void run(){
          boolean enabled=SwingUiSettings.PLAYER_ENABLED.getValue();
          if (!enabled) {
            getPlayerMediator().stop();
            if (getPlayerMediator().hasScrollingTitle()) {
              titleLabel.stop();
            }
          }
          PlayerControlPanel.this.innerPanel.setVisible(enabled);
        }
      }
);
    }
  }
;
  SwingUiSettings.PLAYER_ENABLED.addSettingListener(settingListener);
}","/** 
 * Registers listeners for player events.
 */
private void register(){
  getPlayerMediator().addMediatorListener(this);
  settingListener=new SettingListener(){
    @Override public void settingChanged(    final SettingEvent evt){
      SwingUtilities.invokeLater(new Runnable(){
        public void run(){
          boolean enabled=SwingUiSettings.PLAYER_ENABLED.getValue();
          if (!enabled) {
            getPlayerMediator().stop();
            resetPlayer();
          }
          PlayerControlPanel.this.innerPanel.setVisible(enabled);
        }
      }
);
    }
  }
;
  SwingUiSettings.PLAYER_ENABLED.addSettingListener(settingListener);
}",0.9345794392523364
3749,"private void updateDownloadDetails(){
  long currentSize=download.getCurrentSize();
  long verifiedSize=download.getAmountVerified();
  String downloadString=GuiUtils.formatUnitFromBytes(currentSize);
  if (currentSize - verifiedSize > 1000) {
    downloadString+=""String_Node_Str"" + I18n.tr(""String_Node_Str"",GuiUtils.formatUnitFromBytes(verifiedSize));
  }
  downloadedLabel.setText(downloadString);
  if (numPieces > 0) {
    numPiecesLabel.setText(""String_Node_Str"" + numPieces);
  }
  if (piecesInfo != null) {
    int completed=piecesInfo.getNumPiecesCompleted();
    String completedText;
    if (finishedSuccessfully) {
      completedText=""String_Node_Str"" + numPieces;
    }
 else     if (completed == -1) {
      completedText=""String_Node_Str"";
    }
 else {
      completedText=""String_Node_Str"" + completed;
    }
    piecesCompletedLabel.setText(completedText);
    piecesSizeLabel.setText(GuiUtils.formatUnitFromBytes(piecesInfo.getPieceSize()));
  }
  failedDownloadLabel.setText(GuiUtils.formatUnitFromBytes(download.getAmountLost()));
  if (torrent != null) {
    uploadedLabel.setText(GuiUtils.formatUnitFromBytes(torrent.getTotalUploaded()));
    ratioLabel.setText(formatter.format(torrent.getSeedRatio()));
  }
}","private void updateDownloadDetails(){
  long currentSize=download.getCurrentSize();
  long verifiedSize=download.getAmountVerified();
  String downloadString=GuiUtils.formatUnitFromBytes(currentSize);
  if (currentSize - verifiedSize > 1000) {
    downloadString+=""String_Node_Str"" + I18n.tr(""String_Node_Str"",GuiUtils.formatUnitFromBytes(verifiedSize));
  }
  downloadedLabel.setText(downloadString);
  if (numPieces > 0) {
    numPiecesLabel.setText(""String_Node_Str"" + numPieces);
  }
  if (piecesInfo != null) {
    int completed=piecesInfo.getNumPiecesCompleted();
    String completedText;
    if (finishedSuccessfully) {
      completedText=""String_Node_Str"" + numPieces;
    }
 else     if (completed < 0) {
      completedText=""String_Node_Str"";
    }
 else {
      completedText=""String_Node_Str"" + completed;
    }
    piecesCompletedLabel.setText(completedText);
    piecesSizeLabel.setText(GuiUtils.formatUnitFromBytes(piecesInfo.getPieceSize()));
  }
  failedDownloadLabel.setText(GuiUtils.formatUnitFromBytes(download.getAmountLost()));
  if (torrent != null) {
    uploadedLabel.setText(GuiUtils.formatUnitFromBytes(torrent.getTotalUploaded()));
    ratioLabel.setText(formatter.format(torrent.getSeedRatio()));
  }
}",0.9967585089141004
3750,"private int calculatePieceData(){
  piecesInfo=download.getPiecesInfo();
  int newNum=piecesInfo.getNumPieces();
  if (newNum != numPieces && newNum != 0) {
    statusLabel.setVisible(false);
    numPieces=newNum;
    setupGrid();
  }
  return newNum;
}","private int calculatePieceData(){
  piecesInfo=download.getPiecesInfo();
  if (piecesInfo == null) {
    return -1;
  }
  int newNum=piecesInfo.getNumPieces();
  if (newNum != numPieces && newNum != 0) {
    statusLabel.setVisible(false);
    numPieces=newNum;
    setupGrid();
  }
  return newNum;
}",0.91500904159132
3751,"@Override public Torrent addTorrent(TorrentParams params) throws IOException {
  if (!isValid()) {
    return null;
  }
  params.fill();
  shareTorrent(params.getTorrentFile());
  File torrentFile=params.getTorrentFile();
  File torrentParent=torrentFile.getParentFile();
  File torrentDownloadFolder=SharingSettings.INCOMPLETE_DIRECTORY.get();
  File torrentUploadFolder=BittorrentSettings.TORRENT_UPLOADS_FOLDER.get();
  if (!torrentParent.equals(torrentDownloadFolder) && !torrentParent.equals(torrentUploadFolder)) {
    torrentDownloadFolder.mkdirs();
    File newTorrentFile=new File(torrentDownloadFolder,params.getName() + ""String_Node_Str"");
    FileUtils.copy(torrentFile,newTorrentFile);
    params.setTorrentFile(newTorrentFile);
  }
  return torrentManager.get().addTorrent(params);
}","/** 
 * Shares the torrent with gnutella, then registers the specified torrent with the TorrentManager. Delegates an add torrent call to the underlying torrentManager implementation.
 * @return the torrent if it was successfully added, null otherwise.
 */
@Override public Torrent addTorrent(TorrentParams params) throws IOException {
  if (!isValid()) {
    return null;
  }
  params.fill();
  shareTorrent(params.getTorrentFile());
  return addTorrentInternal(params);
}",0.2899921197793538
3752,"@Inject public TorrentUploadManager(Provider<TorrentManager> torrentManager,Provider<ActivityCallback> activityCallback){
  this.torrentManager=torrentManager;
  this.activityCallback=activityCallback;
}","@Inject public TorrentUploadManager(Provider<LimeWireTorrentManager> torrentManager,Provider<ActivityCallback> activityCallback){
  this.torrentManager=torrentManager;
  this.activityCallback=activityCallback;
}",0.9806763285024156
3753,"/** 
 * Iterates through the uploads folder finding saved torrent mementos and starting off the uploads.
 */
public void loadSavedUploads(){
  File uploadsDirectory=BittorrentSettings.TORRENT_UPLOADS_FOLDER.get();
  if (uploadsDirectory.exists()) {
    File[] uploadMementos=uploadsDirectory.listFiles(new FileFilter(){
      @Override public boolean accept(      File file){
        return ""String_Node_Str"".equals(FileUtils.getFileExtension(file));
      }
    }
);
    if (uploadMementos != null) {
      for (      File mementoFile : uploadMementos) {
        Map<String,Object> memento=null;
        try {
          memento=readMemento(mementoFile);
        }
 catch (        IllegalArgumentException e) {
          LOG.error(""String_Node_Str"" + mementoFile,e);
        }
catch (        IOException e) {
          LOG.error(""String_Node_Str"" + mementoFile,e);
        }
catch (        ClassNotFoundException e) {
          LOG.error(""String_Node_Str"" + mementoFile,e);
        }
        if (memento != null) {
          long mementoModifiedTime=mementoFile.lastModified();
          File torrentFile=(File)memento.get(""String_Node_Str"");
          File fastResumeFile=(File)memento.get(""String_Node_Str"");
          File torrentDataFile=(File)memento.get(""String_Node_Str"");
          String sha1=(String)memento.get(""String_Node_Str"");
          String trackerURL=(String)memento.get(""String_Node_Str"");
          String name=(String)memento.get(""String_Node_Str"");
          boolean torrentAdded=false;
          boolean torrentLoaded=false;
          Torrent torrent=null;
          if (torrentDataFile.exists() && fastResumeFile != null && fastResumeFile.exists()) {
            if (torrentManager.get().isValid() && !torrentManager.get().isDownloadingTorrent(mementoFile)) {
              try {
                TorrentParams params=new LibTorrentParams(torrentDataFile.getParentFile(),name,sha1);
                params.setTrackerURL(trackerURL);
                params.setFastResumeFile(fastResumeFile);
                params.setTorrentFile(torrentFile);
                params.setTorrentDataFile(torrentDataFile);
                torrent=torrentManager.get().addTorrent(params);
                if (torrent != null) {
                  torrentAdded=true;
                  if (torrent.hasMetaData()) {
                    TorrentInfo torrentInfo=torrent.getTorrentInfo();
                    boolean filesOk=true;
                    for (                    TorrentFileEntry entry : torrentInfo.getTorrentFileEntries()) {
                      int priority=entry.getPriority();
                      if (priority > 0) {
                        File torrentFileEntry=torrent.getTorrentDataFile(entry);
                        boolean exists=torrentFileEntry.exists();
                        long fileModifiedTime=torrentFileEntry.lastModified();
                        if (!exists || fileModifiedTime > mementoModifiedTime) {
                          filesOk=false;
                          break;
                        }
                      }
                    }
                    if (filesOk) {
                      createBTUploader(torrent);
                      torrent.setAutoManaged(true);
                      torrent.start();
                      torrentLoaded=true;
                    }
                  }
                }
              }
 catch (              IOException e) {
                LOG.error(""String_Node_Str"" + mementoFile,e);
              }
            }
          }
          if (!torrentLoaded) {
            cleanup(mementoFile,torrentFile,fastResumeFile);
            if (torrent != null && torrentAdded) {
              torrentManager.get().removeTorrent(torrent);
            }
          }
        }
      }
    }
  }
}","/** 
 * Iterates through the uploads folder finding saved torrent mementos and starting off the uploads.
 */
public void loadSavedUploads(){
  File uploadsDirectory=BittorrentSettings.TORRENT_UPLOADS_FOLDER.get();
  if (uploadsDirectory.exists()) {
    File[] uploadMementos=uploadsDirectory.listFiles(new FileFilter(){
      @Override public boolean accept(      File file){
        return ""String_Node_Str"".equals(FileUtils.getFileExtension(file));
      }
    }
);
    if (uploadMementos != null) {
      for (      File mementoFile : uploadMementos) {
        Map<String,Object> memento=null;
        try {
          memento=readMemento(mementoFile);
        }
 catch (        IllegalArgumentException e) {
          LOG.error(""String_Node_Str"" + mementoFile,e);
        }
catch (        IOException e) {
          LOG.error(""String_Node_Str"" + mementoFile,e);
        }
catch (        ClassNotFoundException e) {
          LOG.error(""String_Node_Str"" + mementoFile,e);
        }
        if (memento != null) {
          long mementoModifiedTime=mementoFile.lastModified();
          File torrentFile=(File)memento.get(""String_Node_Str"");
          File fastResumeFile=(File)memento.get(""String_Node_Str"");
          File torrentDataFile=(File)memento.get(""String_Node_Str"");
          String sha1=(String)memento.get(""String_Node_Str"");
          String trackerURL=(String)memento.get(""String_Node_Str"");
          String name=(String)memento.get(""String_Node_Str"");
          boolean torrentAdded=false;
          boolean torrentLoaded=false;
          Torrent torrent=null;
          if (torrentDataFile.exists() && fastResumeFile != null && fastResumeFile.exists()) {
            if (torrentManager.get().isValid() && !torrentManager.get().isDownloadingTorrent(mementoFile)) {
              try {
                TorrentParams params=new LibTorrentParams(torrentDataFile.getParentFile(),name,sha1);
                params.setTrackerURL(trackerURL);
                params.setFastResumeFile(fastResumeFile);
                params.setTorrentFile(torrentFile);
                params.setTorrentDataFile(torrentDataFile);
                torrent=torrentManager.get().seedTorrent(params);
                if (torrent != null) {
                  torrentAdded=true;
                  if (torrent.hasMetaData()) {
                    TorrentInfo torrentInfo=torrent.getTorrentInfo();
                    boolean filesOk=true;
                    for (                    TorrentFileEntry entry : torrentInfo.getTorrentFileEntries()) {
                      int priority=entry.getPriority();
                      if (priority > 0) {
                        File torrentFileEntry=torrent.getTorrentDataFile(entry);
                        boolean exists=torrentFileEntry.exists();
                        long fileModifiedTime=torrentFileEntry.lastModified();
                        if (!exists || fileModifiedTime > mementoModifiedTime) {
                          filesOk=false;
                          break;
                        }
                      }
                    }
                    if (filesOk) {
                      createBTUploader(torrent);
                      torrent.setAutoManaged(true);
                      torrent.start();
                      torrentLoaded=true;
                    }
                  }
                }
              }
 catch (              IOException e) {
                LOG.error(""String_Node_Str"" + mementoFile,e);
              }
            }
          }
          if (!torrentLoaded) {
            cleanup(mementoFile,torrentFile,fastResumeFile);
            if (torrent != null && torrentAdded) {
              torrentManager.get().removeTorrent(torrent);
            }
          }
        }
      }
    }
  }
}",0.9993388866851778
3754,"private void handleBTTorrentFileDownloader(){
  File torrentFile=null;
  final BTTorrentFileDownloader btTorrentFileDownloader=(BTTorrentFileDownloader)downloader;
  try {
    torrentFile=btTorrentFileDownloader.getTorrentFile();
    downloadManager.downloadTorrent(torrentFile,null,false);
    downloadItems.remove(getDownloadItem(downloader));
  }
 catch (  DownloadException e) {
    final File torrentFileFinal=torrentFile;
    activityCallback.handleDownloadException(new DownloadAction(){
      @Override public void download(      File saveDirectory,      boolean overwrite) throws DownloadException {
        downloadManager.downloadTorrent(torrentFileFinal,saveDirectory,overwrite);
        downloadItems.remove(getDownloadItem(downloader));
      }
      @Override public void downloadCanceled(      DownloadException ex){
        if (!torrentManager.isDownloadingTorrent(torrentFileFinal)) {
          FileUtils.forceDelete(torrentFileFinal);
        }
      }
    }
,e,false);
  }
}","private void handleBTTorrentFileDownloader(){
  File torrentCopy=null;
  File torrentFile=null;
  final BTTorrentFileDownloader btTorrentFileDownloader=(BTTorrentFileDownloader)downloader;
  try {
    torrentFile=btTorrentFileDownloader.getTorrentFile();
    torrentCopy=new File(SharingSettings.INCOMPLETE_DIRECTORY.get(),UUID.randomUUID().toString() + ""String_Node_Str"");
    FileUtils.copy(torrentFile,torrentCopy);
    downloadManager.downloadTorrent(torrentFile,null,false);
    downloadItems.remove(getDownloadItem(downloader));
  }
 catch (  DownloadException e) {
    final File torrentFileFinal=torrentFile;
    final File torrentCopyFinal=torrentCopy;
    activityCallback.handleDownloadException(new DownloadAction(){
      @Override public void download(      File saveDirectory,      boolean overwrite) throws DownloadException {
        FileUtils.copy(torrentCopyFinal,torrentFileFinal);
        downloadManager.downloadTorrent(torrentFileFinal,saveDirectory,overwrite);
        downloadItems.remove(getDownloadItem(downloader));
        FileUtils.forceDelete(torrentCopyFinal);
      }
      @Override public void downloadCanceled(      DownloadException ex){
        if (!torrentManager.isDownloadingTorrent(torrentFileFinal)) {
          FileUtils.forceDelete(torrentFileFinal);
        }
        FileUtils.forceDelete(torrentCopyFinal);
      }
    }
,e,false);
  }
}",0.835645229087852
3755,"@Override public void downloadCanceled(DownloadException ex){
  if (!torrentManager.isDownloadingTorrent(torrentFileFinal)) {
    FileUtils.forceDelete(torrentFileFinal);
  }
}","@Override public void downloadCanceled(DownloadException ex){
  if (!torrentManager.isDownloadingTorrent(torrentFileFinal)) {
    FileUtils.forceDelete(torrentFileFinal);
  }
  FileUtils.forceDelete(torrentCopyFinal);
}",0.8911392405063291
3756,"@Override public void download(File saveDirectory,boolean overwrite) throws DownloadException {
  downloadManager.downloadTorrent(torrentFileFinal,saveDirectory,overwrite);
  downloadItems.remove(getDownloadItem(downloader));
}","@Override public void download(File saveDirectory,boolean overwrite) throws DownloadException {
  FileUtils.copy(torrentCopyFinal,torrentFileFinal);
  downloadManager.downloadTorrent(torrentFileFinal,saveDirectory,overwrite);
  downloadItems.remove(getDownloadItem(downloader));
  FileUtils.forceDelete(torrentCopyFinal);
}",0.8254545454545454
3757,"/** 
 * The implementation that the other methods delegate to. This provides the caller with all available options for customizing the <tt>JFileChooser</tt> instance. If a <tt>FileDialog</tt> is displayed instead of a <tt>JFileChooser</tt> (on OS X, for example), most or all of these options have no effect.
 * @param parent the <tt>Component</tt> that should be the dialog's parent
 * @param titleKey the key for the locale-specific string to use for thefile dialog title
 * @param approveKey the key for the locale-specific string to use for theapprove button text
 * @param directory the directory to open the dialog to
 * @param mode the ""mode"" to open the <tt>JFileChooser</tt> in from the<tt>JFileChooser</tt> class, such as <tt>JFileChooser.DIRECTORIES_ONLY</tt>
 * @param option the option to look for in the return code, such as<tt>JFileChooser.APPROVE_OPTION</tt>
 * @param allowMultiSelect true if the chooser allows multiple files to bechosen
 * @param filter the <tt>FileFilter</tt> instance for customizing thefiles that are displayed -- if this is null, no filter is used
 * @return the selected <tt>File</tt> instance, or <tt>null</tt> if afile was not selected correctly
 */
public static List<File> getInput(Component parent,String titleKey,String approveKey,File directory,int mode,int option,boolean allowMultiSelect,final FileFilter filter){
  if (!OSUtils.isMacOSX()) {
    if (OSUtils.isWindows() && mode == JFileChooser.DIRECTORIES_ONLY && !allowMultiSelect) {
      try {
        WindowsFolderChooser folder=new WindowsFolderChooser(parent,titleKey,false,true,directory.getAbsolutePath());
        String path=folder.showWidget();
        if (path != null && path.length() > 0) {
          File file=new File(path);
          setLastInputDirectory(file);
          return Collections.singletonList(file);
        }
 else {
          return null;
        }
      }
 catch (      UnsatisfiedLinkError ule) {
        return getFileChooser(parent,titleKey,approveKey,directory,mode,option,allowMultiSelect,filter);
      }
    }
 else {
      return getFileChooser(parent,titleKey,approveKey,directory,mode,option,allowMultiSelect,filter);
    }
  }
 else {
    boolean canChooseFiles=(mode == JFileChooser.FILES_ONLY || mode == JFileChooser.FILES_AND_DIRECTORIES);
    boolean canChooseDirectories=(mode == JFileChooser.DIRECTORIES_ONLY || mode == JFileChooser.FILES_AND_DIRECTORIES);
    List<File> selectedFiles=MacOSXUtils.openNativeFileDialog(I18n.tr(titleKey),directory,canChooseFiles,canChooseDirectories,allowMultiSelect,filter);
    if (selectedFiles == null) {
      return null;
    }
 else {
      if (selectedFiles.size() > 0) {
        if (selectedFiles.get(0).isFile()) {
          setLastInputDirectory(selectedFiles.get(0));
        }
 else {
          if (selectedFiles.get(0).getParent() != null)           setLastInputDirectory(new File(selectedFiles.get(0).getParent()));
 else           setLastInputDirectory(selectedFiles.get(0));
        }
      }
      return selectedFiles;
    }
  }
}","/** 
 * The implementation that the other methods delegate to. This provides the caller with all available options for customizing the <tt>JFileChooser</tt> instance. If a <tt>FileDialog</tt> is displayed instead of a <tt>JFileChooser</tt> (on OS X, for example), most or all of these options have no effect.
 * @param parent the <tt>Component</tt> that should be the dialog's parent
 * @param titleKey the key for the locale-specific string to use for thefile dialog title
 * @param approveKey the key for the locale-specific string to use for theapprove button text
 * @param directory the directory to open the dialog to
 * @param mode the ""mode"" to open the <tt>JFileChooser</tt> in from the<tt>JFileChooser</tt> class, such as <tt>JFileChooser.DIRECTORIES_ONLY</tt>
 * @param option the option to look for in the return code, such as<tt>JFileChooser.APPROVE_OPTION</tt>
 * @param allowMultiSelect true if the chooser allows multiple files to bechosen
 * @param filter the <tt>FileFilter</tt> instance for customizing thefiles that are displayed -- if this is null, no filter is used
 * @return the selected <tt>File</tt> instance, or <tt>null</tt> if afile was not selected correctly
 */
public static List<File> getInput(Component parent,String titleKey,String approveKey,File directory,int mode,int option,boolean allowMultiSelect,final FileFilter filter){
  if (!OSUtils.isMacOSX()) {
    if (OSUtils.isWindows() && mode == JFileChooser.DIRECTORIES_ONLY && !allowMultiSelect) {
      try {
        String oldPath=directory == null ? null : directory.getAbsolutePath();
        WindowsFolderChooser folder=new WindowsFolderChooser(parent,titleKey,false,true,oldPath);
        String path=folder.showWidget();
        if (path != null && path.length() > 0) {
          File file=new File(path);
          setLastInputDirectory(file);
          return Collections.singletonList(file);
        }
 else {
          return null;
        }
      }
 catch (      UnsatisfiedLinkError ule) {
        return getFileChooser(parent,titleKey,approveKey,directory,mode,option,allowMultiSelect,filter);
      }
    }
 else {
      return getFileChooser(parent,titleKey,approveKey,directory,mode,option,allowMultiSelect,filter);
    }
  }
 else {
    boolean canChooseFiles=(mode == JFileChooser.FILES_ONLY || mode == JFileChooser.FILES_AND_DIRECTORIES);
    boolean canChooseDirectories=(mode == JFileChooser.DIRECTORIES_ONLY || mode == JFileChooser.FILES_AND_DIRECTORIES);
    List<File> selectedFiles=MacOSXUtils.openNativeFileDialog(I18n.tr(titleKey),directory,canChooseFiles,canChooseDirectories,allowMultiSelect,filter);
    if (selectedFiles == null) {
      return null;
    }
 else {
      if (selectedFiles.size() > 0) {
        if (selectedFiles.get(0).isFile()) {
          setLastInputDirectory(selectedFiles.get(0));
        }
 else {
          if (selectedFiles.get(0).getParent() != null)           setLastInputDirectory(new File(selectedFiles.get(0).getParent()));
 else           setLastInputDirectory(selectedFiles.get(0));
        }
      }
      return selectedFiles;
    }
  }
}",0.9648979591836736
3758,"/** 
 * Shows the chooser & sets the save directory setting, adding the save directory as shared, also.
 * @return the selected <tt>File</tt>, or <tt>null</tt> if there wereany problems
 */
private static File showChooser(){
  File dir=FileChooser.getInputDirectory(null);
  if (dir != null) {
    try {
      SharingSettings.setSaveDirectory(dir);
      return dir;
    }
 catch (    IOException ignored) {
    }
  }
  return null;
}","/** 
 * Shows the chooser & sets the save directory setting, adding the save directory as shared, also.
 * @return the selected <tt>File</tt>, or <tt>null</tt> if there wereany problems
 */
private static File showChooser(){
  File dir=FileChooser.getInputDirectory(GuiUtils.getMainFrame());
  if (dir != null) {
    try {
      SharingSettings.setSaveDirectory(dir);
      return dir;
    }
 catch (    IOException ignored) {
    }
  }
  return null;
}",0.9695603156708004
3759,"@Override public void actionPerformed(ActionEvent e){
  List<LocalFileItem> selectedItems=new ArrayList<LocalFileItem>(selectedLocalFileItems.get());
  String title=null;
  String message=null;
  String yesText=null;
  String noText=I18n.tr(""String_Node_Str"");
  if (OSUtils.isWindows() && OSUtils.supportsTrash()) {
    title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    yesText=I18n.tr(""String_Node_Str"");
  }
 else   if (OSUtils.isMacOSX() && OSUtils.supportsTrash()) {
    title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    yesText=I18n.tr(""String_Node_Str"");
  }
 else {
    title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    yesText=I18n.tr(""String_Node_Str"");
  }
  Object[] options=new Object[]{yesText,noText};
  int confirmation=FocusJOptionPane.showOptionDialog(null,message,title,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,noText);
  if (confirmation > -1 && options[confirmation] == yesText) {
    deleteSelectedItems(libraryManager,selectedItems);
  }
}","@Override public void actionPerformed(ActionEvent e){
  List<LocalFileItem> selectedItems=new ArrayList<LocalFileItem>(selectedLocalFileItems.get());
  String title=null;
  String message=null;
  String yesText=null;
  String noText=I18n.tr(""String_Node_Str"");
  if (OSUtils.isWindows() && OSUtils.supportsTrash()) {
    title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    yesText=I18n.tr(""String_Node_Str"");
  }
 else   if (OSUtils.isMacOSX() && OSUtils.supportsTrash()) {
    title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    yesText=I18n.tr(""String_Node_Str"");
  }
 else {
    title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
    yesText=I18n.tr(""String_Node_Str"");
  }
  Object[] options=new Object[]{yesText,noText};
  int confirmation=FocusJOptionPane.showOptionDialog(null,message,title,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,noText);
  if (confirmation > -1 && options[confirmation] == yesText) {
    deleteSelectedItems(libraryManager,downloadListManager,selectedItems);
  }
}",0.9924585218702866
3760,"static void deleteSelectedItems(final LibraryManager libraryManager,final List<LocalFileItem> selectedItems){
  BackgroundExecutorService.execute(new Runnable(){
    public void run(){
      File currentSong=PlayerUtils.getCurrentSongFile();
      for (      LocalFileItem item : selectedItems) {
        if (item.getFile().equals(currentSong)) {
          stopAudio();
        }
        if (!item.isIncomplete()) {
          FileUtils.unlockFile(item.getFile());
          libraryManager.getLibraryManagedList().removeFile(item.getFile());
          FileUtils.delete(item.getFile(),OSUtils.supportsTrash());
        }
      }
    }
  }
);
}","static void deleteSelectedItems(final LibraryManager libraryManager,final DownloadListManager downloadListManager,final List<LocalFileItem> selectedItems){
  BackgroundExecutorService.execute(new Runnable(){
    public void run(){
      File currentSong=PlayerUtils.getCurrentSongFile();
      for (      LocalFileItem item : selectedItems) {
        if (item.getFile().equals(currentSong)) {
          stopAudio();
        }
        if (!item.isIncomplete()) {
          FileUtils.unlockFile(item.getFile());
          removeDownloadItem(item.getUrn(),downloadListManager);
          libraryManager.getLibraryManagedList().removeFile(item.getFile());
          FileUtils.delete(item.getFile(),OSUtils.supportsTrash());
        }
      }
    }
  }
);
}",0.9203158650394831
3761,"@Inject public DeleteAction(@LibrarySelected Provider<List<LocalFileItem>> selectedLocalFileItems,LibraryManager libraryManager){
  this.selectedLocalFileItems=selectedLocalFileItems;
  this.libraryManager=libraryManager;
  putValue(Action.NAME,I18n.tr(""String_Node_Str""));
}","@Inject public DeleteAction(@LibrarySelected Provider<List<LocalFileItem>> selectedLocalFileItems,DownloadListManager downloadListManager,LibraryManager libraryManager){
  this.selectedLocalFileItems=selectedLocalFileItems;
  this.downloadListManager=downloadListManager;
  this.libraryManager=libraryManager;
  putValue(Action.NAME,I18n.tr(""String_Node_Str""));
}",0.8620689655172413
3762,"@Override public void keyPressed(KeyEvent e){
  if (e.getKeyCode() == KeyEvent.VK_DELETE) {
    List<LocalFileItem> selectedItems=new ArrayList<LocalFileItem>(selectedLocalFileItems.get());
    String title=null;
    String message=null;
    String deleteText=null;
    String removeText=I18n.tr(""String_Node_Str"");
    String cancelText=I18n.tr(""String_Node_Str"");
    if (OSUtils.isWindows() && OSUtils.supportsTrash()) {
      title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      deleteText=I18n.tr(""String_Node_Str"");
    }
 else     if (OSUtils.isMacOSX() && OSUtils.supportsTrash()) {
      title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      deleteText=I18n.tr(""String_Node_Str"");
    }
 else {
      title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      deleteText=I18n.tr(""String_Node_Str"");
    }
    Object[] options=new Object[]{removeText,deleteText,cancelText};
    int confirmation=FocusJOptionPane.showOptionDialog(null,message,title,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,cancelText);
    if (confirmation < 0 || options[confirmation] == cancelText) {
      return;
    }
    if (options[confirmation] == deleteText) {
      DeleteAction.deleteSelectedItems(libraryManager,selectedItems);
    }
 else     if (options[confirmation] == removeText) {
      RemoveFromLibraryAction.removeFromLibrary(libraryManager,selectedItems);
    }
  }
}","@Override public void keyPressed(KeyEvent e){
  if (e.getKeyCode() == KeyEvent.VK_DELETE) {
    List<LocalFileItem> selectedItems=new ArrayList<LocalFileItem>(selectedLocalFileItems.get());
    String title=null;
    String message=null;
    String deleteText=null;
    String removeText=I18n.tr(""String_Node_Str"");
    String cancelText=I18n.tr(""String_Node_Str"");
    if (OSUtils.isWindows() && OSUtils.supportsTrash()) {
      title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      deleteText=I18n.tr(""String_Node_Str"");
    }
 else     if (OSUtils.isMacOSX() && OSUtils.supportsTrash()) {
      title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      deleteText=I18n.tr(""String_Node_Str"");
    }
 else {
      title=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      message=I18n.trn(""String_Node_Str"",""String_Node_Str"",selectedItems.size());
      deleteText=I18n.tr(""String_Node_Str"");
    }
    Object[] options=new Object[]{removeText,deleteText,cancelText};
    int confirmation=FocusJOptionPane.showOptionDialog(null,message,title,JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,cancelText);
    if (confirmation < 0 || options[confirmation] == cancelText) {
      return;
    }
    if (options[confirmation] == deleteText) {
      DeleteAction.deleteSelectedItems(libraryManager,downloadListManager,selectedItems);
    }
 else     if (options[confirmation] == removeText) {
      RemoveFromLibraryAction.removeFromLibrary(libraryManager,selectedItems);
    }
  }
}",0.994199535962877
3763,"@Inject public DeletionKeyListener(LibraryManager libraryManager,@LibrarySelected Provider<List<LocalFileItem>> selectedLocalFileItems){
  this.libraryManager=libraryManager;
  this.selectedLocalFileItems=selectedLocalFileItems;
}","@Inject public DeletionKeyListener(LibraryManager libraryManager,DownloadListManager downloadListManager,@LibrarySelected Provider<List<LocalFileItem>> selectedLocalFileItems){
  this.libraryManager=libraryManager;
  this.downloadListManager=downloadListManager;
  this.selectedLocalFileItems=selectedLocalFileItems;
}",0.8394160583941606
3764,"/** 
 * Attempts to match a newly added uploader with one that already exists in the list. If an uploader already exists that matches this Uploader, it returns the pre-existing CoreUploadItem, otherwise returns null.
 */
private CoreUploadItem findMatchingUploader(Uploader uploader){
  CoreUploadItem matchingItem=null;
  threadSafeUploadItems.getReadWriteLock().readLock().lock();
  try {
    for (    UploadItem item : threadSafeUploadItems) {
      CoreUploadItem coreUploadItem=(CoreUploadItem)item;
      if (coreUploadItem.getUploader().getHost().equals(uploader.getHost()) && coreUploadItem.getUploader().isInactive()) {
        if (uploader.getState() == UploadStatus.BROWSE_HOST && uploader.getUploadType() == coreUploadItem.getUploader().getUploadType()) {
          matchingItem=coreUploadItem;
          break;
        }
 else         if (uploader.getFile() != null && uploader.getFile().equals(coreUploadItem.getFile())) {
          matchingItem=coreUploadItem;
          break;
        }
      }
    }
  }
  finally {
    threadSafeUploadItems.getReadWriteLock().readLock().unlock();
  }
  return matchingItem;
}","/** 
 * Attempts to match a newly added uploader with one that already exists in the list. If an uploader already exists that matches this Uploader, it returns the pre-existing CoreUploadItem, otherwise returns null.
 */
private CoreUploadItem findMatchingUploader(Uploader uploader){
  CoreUploadItem matchingItem=null;
  threadSafeUploadItems.getReadWriteLock().readLock().lock();
  try {
    for (    UploadItem item : threadSafeUploadItems) {
      CoreUploadItem coreUploadItem=(CoreUploadItem)item;
      if (coreUploadItem.getUploader().getHost().equals(uploader.getHost())) {
        if (uploader.getState() == UploadStatus.BROWSE_HOST && uploader.getUploadType() == coreUploadItem.getUploader().getUploadType()) {
          matchingItem=coreUploadItem;
          break;
        }
 else         if (uploader.getFile() != null && uploader.getFile().equals(coreUploadItem.getFile())) {
          matchingItem=coreUploadItem;
          break;
        }
      }
    }
  }
  finally {
    threadSafeUploadItems.getReadWriteLock().readLock().unlock();
  }
  return matchingItem;
}",0.9796287913082844
3765,"@Override protected void updateProgress(Object value,int columnWidth){
  if (value instanceof UploadItem) {
    UploadItem item=(UploadItem)value;
    if (UploadItemType.GNUTELLA == item.getUploadItemType()) {
      progressBar.setValue((int)(100 * item.getTotalAmountUploaded() / item.getFileSize()));
      progressBar.setVisible((item.getState() == UploadState.UPLOADING) && (columnWidth > resources.getProgressBarCutoffWidth()));
    }
 else {
      progressBar.setVisible(false);
    }
  }
 else {
    progressBar.setVisible(false);
  }
  progressBar.setEnabled(true);
}","@Override protected void updateProgress(Object value,int columnWidth){
  if (value instanceof UploadItem) {
    UploadItem item=(UploadItem)value;
    if (UploadItemType.GNUTELLA == item.getUploadItemType()) {
      progressBar.setVisible((item.getState() == UploadState.UPLOADING) && (columnWidth > resources.getProgressBarCutoffWidth()));
      if (progressBar.isVisible()) {
        long size=item.getFileSize();
        progressBar.setValue((size > 0) ? (int)(100 * item.getTotalAmountUploaded() / size) : 0);
      }
    }
 else {
      progressBar.setVisible(false);
    }
  }
 else {
    progressBar.setVisible(false);
  }
  progressBar.setEnabled(true);
}",0.778675282714055
3766,"private void handleUncaughtException(String name,Throwable throwable){
  if (LimeWireUtils.isTestingVersion()) {
    StackTraceElement[] stackTraceElements=throwable.getStackTrace();
    for (    StackTraceElement stackTraceElement : stackTraceElements) {
      if (matches(stackTraceElement)) {
        throwable.printStackTrace();
        return;
      }
    }
    ErrorService.error(throwable,""String_Node_Str"" + name);
  }
}","private void handleUncaughtException(String name,Throwable throwable){
  StackTraceElement[] stackTraceElements=throwable.getStackTrace();
  for (  StackTraceElement stackTraceElement : stackTraceElements) {
    if (matchesUnreported(stackTraceElement)) {
      throwable.printStackTrace();
      return;
    }
  }
  ErrorService.error(throwable,""String_Node_Str"" + name);
}",0.9077306733167082
3767,"public UncaughtExceptionHandlerImpl(){
  filters=new ArrayList<StackTraceElement>();
  filters.add(new StackTraceElement(""String_Node_Str"",""String_Node_Str"",null,-1));
}","public UncaughtExceptionHandlerImpl(){
  notReported=new ArrayList<StackTraceElement>();
  notReported.add(new StackTraceElement(""String_Node_Str"",""String_Node_Str"",null,-1));
}",0.9190751445086706
3768,"@Inject public FilteringOptionPanel(SpamManager spamManager){
  super();
  this.spamManager=spamManager;
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  setOpaque(false);
  add(getBlockHostsPanel(),""String_Node_Str"");
  add(getAllowHostsPanel(),""String_Node_Str"");
}","@Inject public FilteringOptionPanel(SpamManager spamManager){
  super();
  this.spamManager=spamManager;
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  add(getBlockHostsPanel(),""String_Node_Str"");
  add(getAllowHostsPanel(),""String_Node_Str"");
}",0.936842105263158
3769,"@Inject public ListeningPortsOptionPanel(NetworkManager networkManager,Provider<TorrentManager> torrentManager,@TorrentSettingsAnnotation TorrentManagerSettings torrentSettings){
  super(null);
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  this.networkManager=networkManager;
  this.torrentManager=torrentManager;
  this.torrentSettings=torrentSettings;
  gnutellaListeningPorts=new GnutellaListeningPortsOptionPanel();
  torrentListeningPorts=new TorrentListeningPortsOptionPanel();
  add(new MultiLineLabel(I18n.tr(""String_Node_Str""),AdvancedOptionPanel.MULTI_LINE_LABEL_WIDTH),""String_Node_Str"");
  add(gnutellaListeningPorts,""String_Node_Str"");
  add(torrentListeningPorts,""String_Node_Str"");
}","@Inject public ListeningPortsOptionPanel(NetworkManager networkManager,Provider<TorrentManager> torrentManager,@TorrentSettingsAnnotation TorrentManagerSettings torrentSettings){
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  this.networkManager=networkManager;
  this.torrentManager=torrentManager;
  this.torrentSettings=torrentSettings;
  gnutellaListeningPorts=new GnutellaListeningPortsOptionPanel();
  torrentListeningPorts=new TorrentListeningPortsOptionPanel();
  JPanel p=new JPanel();
  p.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  p.setLayout(new MigLayout(""String_Node_Str""));
  p.setOpaque(false);
  p.add(new MultiLineLabel(I18n.tr(""String_Node_Str""),AdvancedOptionPanel.MULTI_LINE_LABEL_WIDTH),""String_Node_Str"");
  p.add(gnutellaListeningPorts,""String_Node_Str"");
  p.add(torrentListeningPorts,""String_Node_Str"");
  add(p,""String_Node_Str"");
}",0.8689230769230769
3770,"@Inject public NetworkInterfaceOptionPanel(){
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  setOpaque(false);
  add(getNetworkPanel(),""String_Node_Str"");
}","@Inject public NetworkInterfaceOptionPanel(){
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  add(getNetworkPanel(),""String_Node_Str"");
}",0.8977272727272727
3771,"@Inject public SystemOptionPanel(TrayNotifier trayNotifier){
  this.trayNotifier=trayNotifier;
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  setOpaque(false);
  fileAssociationPanel=new FileAssociationPanel();
  startupShutdownPanel=new StartupShutdownPanel();
  bugsAndUpdatesPanel=new BugsAndUpdatesPanel();
  add(fileAssociationPanel,""String_Node_Str"");
  add(startupShutdownPanel,""String_Node_Str"");
  add(bugsAndUpdatesPanel,""String_Node_Str"");
}","@Inject public SystemOptionPanel(TrayNotifier trayNotifier){
  this.trayNotifier=trayNotifier;
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  fileAssociationPanel=new FileAssociationPanel();
  startupShutdownPanel=new StartupShutdownPanel();
  bugsAndUpdatesPanel=new BugsAndUpdatesPanel();
  add(fileAssociationPanel,""String_Node_Str"");
  add(startupShutdownPanel,""String_Node_Str"");
  add(bugsAndUpdatesPanel,""String_Node_Str"");
}",0.4576271186440678
3772,"@Inject public LibraryImageTable(final ImageList imageList,final ImageCellEditor imageEditor,final LibraryNavigatorPanel navigatorPanel){
  super(new MigLayout(""String_Node_Str""));
  this.imageEditor=imageEditor;
  GuiUtils.assignResources(this);
  setBackground(backgroundColor);
  this.imageList=imageList;
  imageList.setDragEnabled(true);
  imageList.setDropMode(DropMode.ON);
  imageList.setBorder(BorderFactory.createEmptyBorder(0,7,0,7));
  JScrollPane imageScrollPane=new JScrollPane(imageList);
  imageScrollPane.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  layer=new JXLayer<JComponent>(imageScrollPane,new AbstractLayerUI<JComponent>());
  layer.getGlassPane().setLayout(null);
  new MouseReaction(imageList,imageEditor,imageScrollPane);
  layer.getGlassPane().add(imageEditor);
  imageEditor.getRemoveButton().addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      Point p2=SwingUtilities.convertPoint((Component)e.getSource(),e.getPoint(),imageList);
      int popupRow=imageList.locationToIndex(p2);
      if (popupRow < 0)       return;
      imageList.setSelectedIndex(popupRow);
      List<LocalFileItem> items=imageList.getSelectedItems();
      if (items.size() > 0) {
        LibraryNavItem item=navigatorPanel.getSelectedNavItem();
        item.getLocalFileList().removeFile(items.get(0).getFile());
      }
      imageEditor.setVisible(false);
    }
  }
);
  add(layer,""String_Node_Str"");
}","@Inject public LibraryImageTable(final ImageList imageList,final ImageCellEditor imageEditor,final LibraryNavigatorPanel navigatorPanel){
  super(new MigLayout(""String_Node_Str""));
  this.imageEditor=imageEditor;
  imageEditor.setVisible(false);
  GuiUtils.assignResources(this);
  setBackground(backgroundColor);
  this.imageList=imageList;
  imageList.setDragEnabled(true);
  imageList.setDropMode(DropMode.ON);
  imageList.setBorder(BorderFactory.createEmptyBorder(0,7,0,7));
  JScrollPane imageScrollPane=new JScrollPane(imageList);
  imageScrollPane.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
  layer=new JXLayer<JComponent>(imageScrollPane,new AbstractLayerUI<JComponent>());
  layer.getGlassPane().setLayout(null);
  new MouseReaction(imageList,imageEditor,imageScrollPane);
  layer.getGlassPane().add(imageEditor);
  imageEditor.getRemoveButton().addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      Point p2=SwingUtilities.convertPoint((Component)e.getSource(),e.getPoint(),imageList);
      int popupRow=imageList.locationToIndex(p2);
      if (popupRow < 0)       return;
      imageList.setSelectedIndex(popupRow);
      List<LocalFileItem> items=imageList.getSelectedItems();
      if (items.size() > 0) {
        LibraryNavItem item=navigatorPanel.getSelectedNavItem();
        item.getLocalFileList().removeFile(items.get(0).getFile());
      }
      imageEditor.setVisible(false);
    }
  }
);
  add(layer,""String_Node_Str"");
}",0.9888851465139776
3773,"private void showInClient(){
  limeWireLayeredPane.add(videoPanel,JLayeredPane.DEFAULT_LAYER);
  limeWireLayeredPane.moveToFront(videoPanel);
  resizeVideoContainer();
  GuiUtils.getMainFrame().toFront();
}","private void showInClient(){
  limeWireLayeredPane.add(videoPanel,videoLayer);
  resizeVideoContainer();
  GuiUtils.getMainFrame().toFront();
}",0.7908309455587392
3774,"private void closeInClient(){
  limeWireLayeredPane.moveToBack(videoPanel);
  limeWireLayeredPane.remove(videoPanel);
}","private void closeInClient(){
  limeWireLayeredPane.remove(videoPanel);
}",0.7604166666666666
3775,"/** 
 * Updates the state of the components based on whether the user has opted to control the bittorrent settings manually, or let limewire control them.
 */
private void updateState(boolean uploadForever){
  seedController.setVisible(!uploadForever);
}","/** 
 * Updates the state of the components based on whether the user has opted to control the bittorrent settings manually, or let limewire control them.
 */
private void updateState(boolean uploadForever){
  seedRatioLabel.setEnabled(!uploadForever);
  seedRatioSpinner.setEnabled(!uploadForever);
  seedTimeLabel.setEnabled(!uploadForever);
  seedTimeSpinner.setEnabled(!uploadForever);
}",0.7224806201550388
3776,"@Override public void itemStateChanged(ItemEvent e){
  updateState(uploadForever.isSelected());
}","@Override public void itemStateChanged(ItemEvent e){
  updateState(uploadTorrentsForeverButton.isSelected());
}",0.9326923076923076
3777,"@Override boolean hasChanged(){
  return BittorrentSettings.UPLOAD_TORRENTS_FOREVER.getValue() != uploadForever.isSelected() || ((Float)seedRatio.getValue()).floatValue() != BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.getValue() || ((Double)Math.ceil(((Double)seedTime.getValue()).doubleValue() * 60 * 60* 24)).intValue() != BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.getValue() || prioritizeTorrentPopup.isSelected() != BittorrentSettings.TORRENT_SHOW_POPUP_BEFORE_DOWNLOADING.getValue();
}","@Override boolean hasChanged(){
  return BittorrentSettings.UPLOAD_TORRENTS_FOREVER.getValue() != uploadTorrentsForeverButton.isSelected() || ((Float)seedRatioSpinner.getValue()).floatValue() != BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.getValue() || ((Double)Math.ceil(((Double)seedTimeSpinner.getValue()).doubleValue() * 60 * 60* 24)).intValue() != BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.getValue() || chooseTorrentsCheckBox.isSelected() != BittorrentSettings.TORRENT_SHOW_POPUP_BEFORE_DOWNLOADING.getValue();
}",0.929549902152642
3778,"@Override public void initOptions(){
  boolean auto=BittorrentSettings.UPLOAD_TORRENTS_FOREVER.getValue();
  if (auto) {
    uploadForever.setSelected(true);
  }
 else {
    myControl.setSelected(true);
  }
  seedRatio.setValue(BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.get().doubleValue());
  seedTime.setValue(getDays(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.get()));
  prioritizeTorrentPopup.setSelected(BittorrentSettings.TORRENT_SHOW_POPUP_BEFORE_DOWNLOADING.getValue());
  updateState(auto);
}","@Override public void initOptions(){
  boolean auto=BittorrentSettings.UPLOAD_TORRENTS_FOREVER.getValue();
  if (auto) {
    uploadTorrentsForeverButton.setSelected(true);
  }
 else {
    uploadTorrentsControlButton.setSelected(true);
  }
  seedRatioSpinner.setValue(BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.get().doubleValue());
  seedTimeSpinner.setValue(getDays(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.get()));
  chooseTorrentsCheckBox.setSelected(BittorrentSettings.TORRENT_SHOW_POPUP_BEFORE_DOWNLOADING.getValue());
}",0.5043144774688398
3779,"@Override boolean applyOptions(){
  BittorrentSettings.UPLOAD_TORRENTS_FOREVER.setValue(uploadForever.isSelected());
  if (!uploadForever.isSelected()) {
    BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.setValue(seedRatioModel.getNumber().floatValue());
    BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.setValue(((Double)Math.ceil(((Double)seedTime.getValue()).doubleValue() * 60 * 60* 24)).intValue());
  }
  BittorrentSettings.TORRENT_SHOW_POPUP_BEFORE_DOWNLOADING.setValue(prioritizeTorrentPopup.isSelected());
  if (torrentManager.get().isValid()) {
    torrentManager.get().setTorrentManagerSettings(torrentSettings);
  }
  return false;
}","@Override boolean applyOptions(){
  BittorrentSettings.UPLOAD_TORRENTS_FOREVER.setValue(uploadTorrentsForeverButton.isSelected());
  if (!uploadTorrentsForeverButton.isSelected()) {
    BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.setValue(seedRatioModel.getNumber().floatValue());
    BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.setValue(((Double)Math.ceil(((Double)seedTimeSpinner.getValue()).doubleValue() * 60 * 60* 24)).intValue());
  }
  BittorrentSettings.TORRENT_SHOW_POPUP_BEFORE_DOWNLOADING.setValue(chooseTorrentsCheckBox.isSelected());
  if (torrentManager.get().isValid()) {
    torrentManager.get().setTorrentManagerSettings(torrentSettings);
  }
  return false;
}",0.9300225733634312
3780,"@Inject public BitTorrentOptionPanel(Provider<TorrentManager> torrentManager,@TorrentSettingsAnnotation TorrentManagerSettings torrentSettings){
  this.torrentManager=torrentManager;
  this.torrentSettings=torrentSettings;
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  uploadForever=new JRadioButton(""String_Node_Str"" + I18n.tr(""String_Node_Str"") + ""String_Node_Str"");
  uploadForever.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      updateState(uploadForever.isSelected());
    }
  }
);
  myControl=new JRadioButton(I18n.tr(""String_Node_Str""));
  myControl.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      updateState(uploadForever.isSelected());
    }
  }
);
  uploadForever.setOpaque(false);
  myControl.setOpaque(false);
  buttonGroup=new ButtonGroup();
  buttonGroup.add(uploadForever);
  buttonGroup.add(myControl);
  seedRatioModel=new SpinnerNumberModel(BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.get().doubleValue(),BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.getMinValue().doubleValue(),BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.getMaxValue().doubleValue(),.05);
  seedRatio=new JSpinner(seedRatioModel);
  seedRatio.setPreferredSize(new Dimension(50,20));
  seedRatio.setMaximumSize(new Dimension(60,20));
  seedTimeModel=new SpinnerNumberModel(getDays(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.get()),getDays(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.getMinValue()),getDays(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.getMaxValue()),.05);
  seedTime=new JSpinner(seedTimeModel);
  seedTime.setPreferredSize(new Dimension(50,20));
  seedTime.setMaximumSize(new Dimension(60,20));
  seedController=new JPanel(new MigLayout(""String_Node_Str""));
  seedController.setOpaque(false);
  seedController.add(new JLabel(I18n.tr(""String_Node_Str"")));
  seedController.add(seedRatio,""String_Node_Str"");
  seedController.add(new JLabel(I18n.tr(""String_Node_Str"")));
  seedController.add(seedTime,""String_Node_Str"");
  prioritizeTorrentPopup=new JCheckBox(I18n.tr(""String_Node_Str""));
  prioritizeTorrentPopup.setOpaque(false);
  if (torrentManager.get().isValid()) {
    add(prioritizeTorrentPopup,""String_Node_Str"");
    add(uploadForever,""String_Node_Str"");
    add(myControl,""String_Node_Str"");
    add(seedController,""String_Node_Str"");
  }
 else {
    add(new MultiLineLabel(I18n.tr(""String_Node_Str""),500),""String_Node_Str"");
  }
  add(new JButton(new OKDialogAction()),""String_Node_Str"");
  add(new JButton(new CancelDialogAction()),""String_Node_Str"");
}","@Inject public BitTorrentOptionPanel(Provider<TorrentManager> torrentManager,@TorrentSettingsAnnotation TorrentManagerSettings torrentSettings){
  this.torrentManager=torrentManager;
  this.torrentSettings=torrentSettings;
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  uploadTorrentsForeverButton=new JRadioButton(I18n.tr(""String_Node_Str""));
  uploadTorrentsForeverButton.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      updateState(uploadTorrentsForeverButton.isSelected());
    }
  }
);
  uploadTorrentsControlButton=new JRadioButton(I18n.tr(""String_Node_Str""));
  uploadTorrentsControlButton.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      updateState(uploadTorrentsForeverButton.isSelected());
    }
  }
);
  uploadTorrentsForeverButton.setOpaque(false);
  uploadTorrentsControlButton.setOpaque(false);
  ButtonGroup buttonGroup=new ButtonGroup();
  buttonGroup.add(uploadTorrentsForeverButton);
  buttonGroup.add(uploadTorrentsControlButton);
  seedRatioModel=new SpinnerNumberModel(BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.get().doubleValue(),BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.getMinValue().doubleValue(),BittorrentSettings.LIBTORRENT_SEED_RATIO_LIMIT.getMaxValue().doubleValue(),.05);
  seedRatioSpinner=new JSpinner(seedRatioModel);
  seedRatioSpinner.setPreferredSize(new Dimension(50,20));
  seedRatioSpinner.setMaximumSize(new Dimension(60,20));
  seedTimeModel=new SpinnerNumberModel(getDays(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.get()),getDays(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.getMinValue()),getDays(BittorrentSettings.LIBTORRENT_SEED_TIME_LIMIT.getMaxValue()),.05);
  seedTimeSpinner=new JSpinner(seedTimeModel);
  seedTimeSpinner.setPreferredSize(new Dimension(50,20));
  seedTimeSpinner.setMaximumSize(new Dimension(60,20));
  seedRatioLabel=new JLabel(I18n.tr(""String_Node_Str""));
  seedTimeLabel=new JLabel(I18n.tr(""String_Node_Str""));
  chooseTorrentsCheckBox=new JCheckBox(I18n.tr(""String_Node_Str""));
  chooseTorrentsCheckBox.setOpaque(false);
  if (torrentManager.get().isValid()) {
    add(uploadTorrentsForeverButton,""String_Node_Str"");
    add(uploadTorrentsControlButton,""String_Node_Str"");
    add(seedRatioLabel,""String_Node_Str"");
    add(seedRatioSpinner,""String_Node_Str"");
    add(seedTimeLabel,""String_Node_Str"");
    add(seedTimeSpinner,""String_Node_Str"");
    add(chooseTorrentsCheckBox,""String_Node_Str"");
  }
 else {
    add(new MultiLineLabel(I18n.tr(""String_Node_Str""),500),""String_Node_Str"");
  }
  add(new JButton(new OKDialogAction()),""String_Node_Str"");
  add(new JButton(new CancelDialogAction()),""String_Node_Str"");
}",0.81877688423415
3781,"@Inject public OptionsDialog(Provider<LibraryOptionPanel> libraryOptionPanel,Provider<SearchOptionPanel> searchOptionPanel,Provider<TransferOptionPanel> transferOptionPanel,Provider<MiscOptionPanel> miscOptionPanel,Provider<AdvancedOptionPanel> advancedOptionPanel,BarPainterFactory barPainterFactory,UnsafeTypeOptionPanelStateManager unsafeTypeOptionPanelStateManager,Application application){
  super(GuiUtils.getMainFrame(),(OSUtils.isMacOSX()) ? I18n.tr(""String_Node_Str"") : I18n.tr(""String_Node_Str""),true);
  GuiUtils.assignResources(this);
  this.application=application;
  this.libraryOptionPanel=libraryOptionPanel;
  this.searchOptionPanel=searchOptionPanel;
  this.transferOptionPanel=transferOptionPanel;
  this.miscOptionPanel=miscOptionPanel;
  this.advancedOptionPanel=advancedOptionPanel;
  this.unsafeTypeOptionPanelStateManager=unsafeTypeOptionPanelStateManager;
  if (!OSUtils.isMacOSX()) {
    setSize(700,656);
    setPreferredSize(getSize());
  }
 else {
    setSize(743,707);
    setPreferredSize(getSize());
  }
  setResizable(true);
  setDefaultCloseOperation(DISPOSE_ON_CLOSE);
  createComponents(barPainterFactory);
  pack();
}","@Inject public OptionsDialog(Provider<LibraryOptionPanel> libraryOptionPanel,Provider<SearchOptionPanel> searchOptionPanel,Provider<TransferOptionPanel> transferOptionPanel,Provider<MiscOptionPanel> miscOptionPanel,Provider<AdvancedOptionPanel> advancedOptionPanel,BarPainterFactory barPainterFactory,UnsafeTypeOptionPanelStateManager unsafeTypeOptionPanelStateManager,Application application){
  super(GuiUtils.getMainFrame(),(OSUtils.isMacOSX()) ? I18n.tr(""String_Node_Str"") : I18n.tr(""String_Node_Str""),true);
  GuiUtils.assignResources(this);
  this.application=application;
  this.libraryOptionPanel=libraryOptionPanel;
  this.searchOptionPanel=searchOptionPanel;
  this.transferOptionPanel=transferOptionPanel;
  this.miscOptionPanel=miscOptionPanel;
  this.advancedOptionPanel=advancedOptionPanel;
  this.unsafeTypeOptionPanelStateManager=unsafeTypeOptionPanelStateManager;
  if (!OSUtils.isMacOSX()) {
    setSize(660,556);
    setPreferredSize(getSize());
  }
 else {
    setSize(703,607);
    setPreferredSize(getSize());
  }
  setResizable(false);
  setDefaultCloseOperation(DISPOSE_ON_CLOSE);
  createComponents(barPainterFactory);
  pack();
}",0.938068427890862
3782,"public FilteringPanel(){
  super(I18n.tr(""String_Node_Str""));
  configureButton=new JButton(new DialogDisplayAction(SearchOptionPanel.this,unsafeOptionPanel,I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str"")));
  filterKeywordPanel=filterKeywordOptionPanelProvider.get();
  filterKeywordPanel.setPreferredSize(new Dimension(300,400));
  filterFileExtensionPanel=filterFileExtensionsOptionPanelProvider.get();
  filterFileExtensionPanel.setPreferredSize(new Dimension(300,400));
  copyrightContentCheckBox=new JCheckBox(""String_Node_Str"" + I18n.tr(""String_Node_Str"") + ""String_Node_Str"");
  copyrightContentCheckBox.setContentAreaFilled(false);
  adultContentCheckBox=new JCheckBox(""String_Node_Str"" + I18n.tr(""String_Node_Str"") + ""String_Node_Str"");
  adultContentCheckBox.setContentAreaFilled(false);
  filterKeywordsButton=new JButton(new DialogDisplayAction(SearchOptionPanel.this,filterKeywordPanel,I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str"")));
  filterFileExtensionsButton=new JButton(new DialogDisplayAction(SearchOptionPanel.this,filterFileExtensionPanel,I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str"")));
  clearSpamButton=new JButton(new DialogDisplayAction(SearchOptionPanel.this,new SpamOptionPanel(),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str"")));
  programSharingLabel=new JLabel(I18n.tr(""String_Node_Str""));
  add(programSharingLabel);
  add(configureButton,""String_Node_Str"");
  add(copyrightContentCheckBox);
  add(new LearnMoreButton(""String_Node_Str"",application),""String_Node_Str"");
  add(adultContentCheckBox,""String_Node_Str"");
  add(filterKeywordsButton,""String_Node_Str"");
  add(filterFileExtensionsButton,""String_Node_Str"");
  add(clearSpamButton,""String_Node_Str"");
}","public FilteringPanel(){
  super(I18n.tr(""String_Node_Str""));
  configureButton=new JButton(new DialogDisplayAction(SearchOptionPanel.this,unsafeOptionPanel,I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str"")));
  filterKeywordPanel=filterKeywordOptionPanelProvider.get();
  filterKeywordPanel.setPreferredSize(new Dimension(300,400));
  filterFileExtensionPanel=filterFileExtensionsOptionPanelProvider.get();
  filterFileExtensionPanel.setPreferredSize(new Dimension(300,400));
  copyrightContentCheckBox=new JCheckBox(""String_Node_Str"" + I18n.tr(""String_Node_Str"") + ""String_Node_Str"");
  copyrightContentCheckBox.setContentAreaFilled(false);
  adultContentCheckBox=new JCheckBox(""String_Node_Str"" + I18n.tr(""String_Node_Str"") + ""String_Node_Str"");
  adultContentCheckBox.setContentAreaFilled(false);
  filterKeywordsButton=new JButton(new DialogDisplayAction(SearchOptionPanel.this,filterKeywordPanel,I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str"")));
  filterFileExtensionsButton=new JButton(new DialogDisplayAction(SearchOptionPanel.this,filterFileExtensionPanel,I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str"")));
  clearSpamButton=new JButton(new DialogDisplayAction(SearchOptionPanel.this,new SpamOptionPanel(),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str"")));
  JLabel programSharingLabel=new JLabel(I18n.tr(""String_Node_Str""));
  add(programSharingLabel,""String_Node_Str"");
  add(configureButton,""String_Node_Str"");
  add(copyrightContentCheckBox);
  add(new LearnMoreButton(""String_Node_Str"",application),""String_Node_Str"");
  add(adultContentCheckBox,""String_Node_Str"");
  add(filterKeywordsButton,""String_Node_Str"");
  add(filterFileExtensionsButton,""String_Node_Str"");
  add(clearSpamButton,""String_Node_Str"");
}",0.993212055389628
3783,"public BugsPanel(){
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  showBugsBeforeSending=new JRadioButton(I18n.tr(""String_Node_Str""));
  showBugsBeforeSending.setContentAreaFilled(false);
  alwaysSendBugs=new JRadioButton(I18n.tr(""String_Node_Str""));
  alwaysSendBugs.setContentAreaFilled(false);
  neverSendBugs=new JRadioButton(I18n.tr(""String_Node_Str""));
  neverSendBugs.setContentAreaFilled(false);
  ButtonGroup bugsButtonGroup=new ButtonGroup();
  bugsButtonGroup.add(showBugsBeforeSending);
  bugsButtonGroup.add(alwaysSendBugs);
  bugsButtonGroup.add(neverSendBugs);
  add(showBugsBeforeSending,""String_Node_Str"");
  add(alwaysSendBugs,""String_Node_Str"");
  add(neverSendBugs,""String_Node_Str"");
  add(new JButton(new OKDialogAction()),""String_Node_Str"");
  add(new JButton(new CancelDialogAction()),""String_Node_Str"");
}","public BugsPanel(){
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  showBugsBeforeSendingButton=new JRadioButton(I18n.tr(""String_Node_Str""));
  showBugsBeforeSendingButton.setContentAreaFilled(false);
  alwaysSendBugsButton=new JRadioButton(I18n.tr(""String_Node_Str""));
  alwaysSendBugsButton.setContentAreaFilled(false);
  neverSendBugsButton=new JRadioButton(I18n.tr(""String_Node_Str""));
  neverSendBugsButton.setContentAreaFilled(false);
  ButtonGroup bugsButtonGroup=new ButtonGroup();
  bugsButtonGroup.add(showBugsBeforeSendingButton);
  bugsButtonGroup.add(alwaysSendBugsButton);
  bugsButtonGroup.add(neverSendBugsButton);
  add(showBugsBeforeSendingButton,""String_Node_Str"");
  add(alwaysSendBugsButton,""String_Node_Str"");
  add(neverSendBugsButton,""String_Node_Str"");
  add(new JButton(new OKDialogAction()),""String_Node_Str"");
  add(new JButton(new CancelDialogAction()),""String_Node_Str"");
}",0.9594594594594594
3784,"public StartupShutdownPanel(){
  super(I18n.tr(""String_Node_Str""));
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  runAtStartupCheckBox=new JCheckBox(I18n.tr(""String_Node_Str""));
  runAtStartupCheckBox.setContentAreaFilled(false);
  minimizeButton=new JRadioButton(I18n.tr(""String_Node_Str""));
  minimizeButton.setContentAreaFilled(false);
  exitButton=new JRadioButton(I18n.tr(""String_Node_Str""));
  exitButton.setContentAreaFilled(false);
  ButtonGroup buttonGroup=new ButtonGroup();
  buttonGroup.add(minimizeButton);
  buttonGroup.add(exitButton);
  if (OSUtils.isWindows() || OSUtils.isMacOSX()) {
    add(runAtStartupCheckBox,""String_Node_Str"");
  }
  if (trayNotifier.supportsSystemTray()) {
    add(new JLabel(I18n.tr(""String_Node_Str"")),""String_Node_Str"");
    add(minimizeButton,""String_Node_Str"");
    add(exitButton);
  }
}","public StartupShutdownPanel(){
  super(I18n.tr(""String_Node_Str""));
  runAtStartupCheckBox=new JCheckBox(I18n.tr(""String_Node_Str""));
  runAtStartupCheckBox.setContentAreaFilled(false);
  minimizeButton=new JRadioButton(I18n.tr(""String_Node_Str""));
  minimizeButton.setContentAreaFilled(false);
  exitButton=new JRadioButton(I18n.tr(""String_Node_Str""));
  exitButton.setContentAreaFilled(false);
  ButtonGroup buttonGroup=new ButtonGroup();
  buttonGroup.add(minimizeButton);
  buttonGroup.add(exitButton);
  if (OSUtils.isWindows() || OSUtils.isMacOSX()) {
    add(runAtStartupCheckBox,""String_Node_Str"");
  }
  if (trayNotifier.supportsSystemTray()) {
    add(new JLabel(I18n.tr(""String_Node_Str"")),""String_Node_Str"");
    add(minimizeButton,""String_Node_Str"");
    add(exitButton);
  }
}",0.9593199757134184
3785,"@Override public void initOptions(){
  if (BugSettings.SHOW_BUGS.getValue()) {
    showBugsBeforeSending.setSelected(true);
  }
 else   if (BugSettings.REPORT_BUGS.getValue()) {
    alwaysSendBugs.setSelected(true);
  }
 else {
    neverSendBugs.setSelected(true);
  }
}","@Override public void initOptions(){
  if (BugSettings.SHOW_BUGS.getValue()) {
    showBugsBeforeSendingButton.setSelected(true);
  }
 else   if (BugSettings.REPORT_BUGS.getValue()) {
    alwaysSendBugsButton.setSelected(true);
  }
 else {
    neverSendBugsButton.setSelected(true);
  }
}",0.967741935483871
3786,"@Override boolean applyOptions(){
  if (showBugsBeforeSending.isSelected()) {
    BugSettings.SHOW_BUGS.setValue(true);
    BugSettings.REPORT_BUGS.setValue(true);
  }
 else   if (alwaysSendBugs.isSelected()) {
    BugSettings.SHOW_BUGS.setValue(false);
    BugSettings.REPORT_BUGS.setValue(true);
  }
 else {
    BugSettings.SHOW_BUGS.setValue(false);
    BugSettings.REPORT_BUGS.setValue(false);
  }
  return false;
}","@Override boolean applyOptions(){
  if (showBugsBeforeSendingButton.isSelected()) {
    BugSettings.SHOW_BUGS.setValue(true);
    BugSettings.REPORT_BUGS.setValue(true);
  }
 else   if (alwaysSendBugsButton.isSelected()) {
    BugSettings.SHOW_BUGS.setValue(false);
    BugSettings.REPORT_BUGS.setValue(true);
  }
 else {
    BugSettings.SHOW_BUGS.setValue(false);
    BugSettings.REPORT_BUGS.setValue(false);
  }
  return false;
}",0.9858823529411764
3787,"@Override public List<TorrentFileEntry> getTorrentFileEntries(){
  if (cancelled.get()) {
    TorrentInfo torrentInfo=this.torrentInfo.get();
    if (torrentInfo == null) {
      return Collections.emptyList();
    }
    return torrentInfo.getTorrentFileEntries();
  }
  return torrentManager.getTorrentFileEntries(this);
}","@Override public List<TorrentFileEntry> getTorrentFileEntries(){
  lock.readLock().lock();
  try {
    if (cancelled.get()) {
      TorrentInfo torrentInfo=this.torrentInfo.get();
      if (torrentInfo == null) {
        return Collections.emptyList();
      }
      return torrentInfo.getTorrentFileEntries();
    }
    return torrentManager.getTorrentFileEntries(this);
  }
  finally {
    lock.readLock().unlock();
  }
}",0.8150134048257373
3788,"/** 
 * Constructs a PlaylistManager using the specified managed file list.
 */
@Inject public PlaylistManagerImpl(Library managedList,CategoryManager categoryManager){
  this.managedList=managedList;
  this.defaultPlaylist=new PlaylistImpl(""String_Node_Str"",categoryManager.getFilterForCategory(Category.AUDIO));
  this.playlistList=Arrays.asList(new Playlist[]{defaultPlaylist});
}","/** 
 * Constructs a PlaylistManager using the specified managed file list.
 */
@Inject public PlaylistManagerImpl(Library managedList,CategoryManager categoryManager){
  this.managedList=managedList;
  this.defaultPlaylist=new PlaylistImpl(""String_Node_Str"",categoryManager.getExtensionFilterForCategory(Category.AUDIO));
  this.playlistList=Arrays.asList(new Playlist[]{defaultPlaylist});
}",0.9883870967741936
3789,"@Override public Object getProperty(FilePropertyKey property){
  FileDesc fd=uploader.getFileDesc();
  if (fd != null) {
switch (property) {
case NAME:
      return FileUtils.getFilenameNoExtension(fd.getFileName());
case DATE_CREATED:
    long ct=fd.lastModified();
  return ct == -1 ? null : ct;
case FILE_SIZE:
return fd.getFileSize();
default :
Category category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(fd.getFileName()));
return FilePropertyKeyPopulator.get(category,property,fd.getXMLDocument());
}
}
 else {
return null;
}
}","@Override public Object getProperty(FilePropertyKey property){
  FileDesc fd=uploader.getFileDesc();
  if (fd != null) {
switch (property) {
case NAME:
      return FileUtils.getFilenameNoExtension(fd.getFileName());
case DATE_CREATED:
    long ct=fd.lastModified();
  return ct == -1 ? null : ct;
case FILE_SIZE:
return fd.getFileSize();
default :
Category category=categoryManager.getCategoryForFilename(fd.getFileName());
return FilePropertyKeyPopulator.get(category,property,fd.getXMLDocument());
}
}
 else {
return null;
}
}",0.9586016559337628
3790,"@Override public Category getCategory(){
  return categoryManager.getCategoryForExtension(FileUtils.getFileExtension(getFileName()));
}","@Override public Category getCategory(){
  return categoryManager.getCategoryForFilename(getFileName());
}",0.8547717842323651
3791,"/** 
 * Returns a Predicate<String> to use for your query. 
 */
public Predicate<String> getPredicateForQuery(QueryRequest query){
  if (query.desiresAll()) {
    return Predicates.alwaysTrue();
  }
  List<Predicate<String>> predicates=new ArrayList<Predicate<String>>();
  if (query.desiresLinuxOSXPrograms()) {
    predicates.add(categoryManager.getOsxAndLinuxProgramsFilter());
  }
  if (query.desiresWindowsPrograms()) {
    predicates.add(categoryManager.getWindowsProgramsFilter());
  }
  if (query.desiresDocuments()) {
    predicates.add(categoryManager.getFilterForCategory(Category.DOCUMENT));
  }
  if (query.desiresAudio()) {
    predicates.add(categoryManager.getFilterForCategory(Category.AUDIO));
  }
  if (query.desiresVideo()) {
    predicates.add(categoryManager.getFilterForCategory(Category.VIDEO));
  }
  if (query.desiresImages()) {
    predicates.add(categoryManager.getFilterForCategory(Category.IMAGE));
  }
  return Predicates.or(predicates);
}","/** 
 * Returns a Predicate<String> to use for your query. 
 */
public Predicate<String> getPredicateForQuery(QueryRequest query){
  if (query.desiresAll()) {
    return Predicates.alwaysTrue();
  }
  List<Predicate<String>> predicates=new ArrayList<Predicate<String>>();
  if (query.desiresLinuxOSXPrograms()) {
    predicates.add(categoryManager.getOsxAndLinuxProgramsFilter());
  }
  if (query.desiresWindowsPrograms()) {
    predicates.add(categoryManager.getWindowsProgramsFilter());
  }
  if (query.desiresDocuments()) {
    predicates.add(categoryManager.getExtensionFilterForCategory(Category.DOCUMENT));
  }
  if (query.desiresAudio()) {
    predicates.add(categoryManager.getExtensionFilterForCategory(Category.AUDIO));
  }
  if (query.desiresVideo()) {
    predicates.add(categoryManager.getExtensionFilterForCategory(Category.VIDEO));
  }
  if (query.desiresImages()) {
    predicates.add(categoryManager.getExtensionFilterForCategory(Category.IMAGE));
  }
  return Predicates.or(predicates);
}",0.9817813765182186
3792,"/** 
 * Returns true if response has the same media type as the corresponding query request the given GUID.  In the rare case that guid is not known (because this' buffers overflowed), conservatively returns true.
 */
public boolean matchesType(byte[] guid,Response response){
  RequestData request=mapper.get(new GUID(guid));
  if (request == null || request.type == null)   return true;
  String reply=response.getName();
  Category category=request.type.getCategory();
  if (category != null) {
    String extension=FileUtils.getFileExtension(reply);
    return categoryManager.getFilterForCategory(category).apply(extension);
  }
 else {
    return true;
  }
}","/** 
 * Returns true if response has the same media type as the corresponding query request the given GUID.  In the rare case that guid is not known (because this' buffers overflowed), conservatively returns true.
 */
public boolean matchesType(byte[] guid,Response response){
  RequestData request=mapper.get(new GUID(guid));
  if (request == null || request.type == null)   return true;
  String reply=response.getName();
  Category category=request.type.getCategory();
  if (category != null) {
    return categoryManager.getCategoryForFilename(reply) == category;
  }
 else {
    return true;
  }
}",0.8183254344391785
3793,"public void setSaveFile(File saveDirectory,String fileName,boolean overwrite) throws DownloadException {
  if (fileName == null) {
    fileName=getDefaultFileName();
  }
  Category category=null;
  if (fileName != null) {
    category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(fileName));
  }
  if (saveDirectory == null) {
    saveDirectory=SharingSettings.getSaveDirectory(category);
  }
  if (!saveDirectory.exists()) {
    saveDirectory.mkdirs();
  }
  try {
    fileName=CommonUtils.convertFileName(saveDirectory,fileName);
  }
 catch (  IOException ie) {
    if (saveDirectory.isDirectory()) {
      throw new DownloadException(ErrorCode.PATH_NAME_TOO_LONG,saveDirectory);
    }
  }
  if (!saveDirectory.isDirectory()) {
    if (saveDirectory.exists()) {
      throw new DownloadException(ErrorCode.NOT_A_DIRECTORY,saveDirectory);
    }
    throw new DownloadException(ErrorCode.DIRECTORY_DOES_NOT_EXIST,saveDirectory);
  }
  File candidateFile=new File(saveDirectory,fileName);
  try {
    if (!FileUtils.isReallyParent(saveDirectory,candidateFile))     throw new DownloadException(ErrorCode.SECURITY_VIOLATION,candidateFile);
  }
 catch (  IOException e) {
    throw new DownloadException(ErrorCode.FILESYSTEM_ERROR,candidateFile);
  }
  if (!FileUtils.setWriteable(saveDirectory))   throw new DownloadException(ErrorCode.DIRECTORY_NOT_WRITEABLE,saveDirectory);
  if (candidateFile.exists()) {
    if (!candidateFile.isFile() && !(this instanceof BTDownloader))     throw new DownloadException(ErrorCode.FILE_NOT_REGULAR,candidateFile);
    if (!overwrite)     throw new DownloadException(ErrorCode.FILE_ALREADY_EXISTS,candidateFile);
  }
  if (saveLocationManager.isSaveLocationTaken(candidateFile)) {
    throw new DownloadException(ErrorCode.FILE_IS_ALREADY_DOWNLOADED_TO,candidateFile);
  }
synchronized (this) {
    if (!isRelocatable())     throw new DownloadException(ErrorCode.FILE_ALREADY_SAVED,candidateFile);
    this.saveFile=candidateFile;
  }
}","public void setSaveFile(File saveDirectory,String fileName,boolean overwrite) throws DownloadException {
  if (fileName == null) {
    fileName=getDefaultFileName();
  }
  Category category=null;
  if (fileName != null) {
    category=categoryManager.getCategoryForFilename(fileName);
  }
  if (saveDirectory == null) {
    saveDirectory=SharingSettings.getSaveDirectory(category);
  }
  if (!saveDirectory.exists()) {
    saveDirectory.mkdirs();
  }
  try {
    fileName=CommonUtils.convertFileName(saveDirectory,fileName);
  }
 catch (  IOException ie) {
    if (saveDirectory.isDirectory()) {
      throw new DownloadException(ErrorCode.PATH_NAME_TOO_LONG,saveDirectory);
    }
  }
  if (!saveDirectory.isDirectory()) {
    if (saveDirectory.exists()) {
      throw new DownloadException(ErrorCode.NOT_A_DIRECTORY,saveDirectory);
    }
    throw new DownloadException(ErrorCode.DIRECTORY_DOES_NOT_EXIST,saveDirectory);
  }
  File candidateFile=new File(saveDirectory,fileName);
  try {
    if (!FileUtils.isReallyParent(saveDirectory,candidateFile))     throw new DownloadException(ErrorCode.SECURITY_VIOLATION,candidateFile);
  }
 catch (  IOException e) {
    throw new DownloadException(ErrorCode.FILESYSTEM_ERROR,candidateFile);
  }
  if (!FileUtils.setWriteable(saveDirectory))   throw new DownloadException(ErrorCode.DIRECTORY_NOT_WRITEABLE,saveDirectory);
  if (candidateFile.exists()) {
    if (!candidateFile.isFile() && !(this instanceof BTDownloader))     throw new DownloadException(ErrorCode.FILE_NOT_REGULAR,candidateFile);
    if (!overwrite)     throw new DownloadException(ErrorCode.FILE_ALREADY_EXISTS,candidateFile);
  }
  if (saveLocationManager.isSaveLocationTaken(candidateFile)) {
    throw new DownloadException(ErrorCode.FILE_IS_ALREADY_DOWNLOADED_TO,candidateFile);
  }
synchronized (this) {
    if (!isRelocatable())     throw new DownloadException(ErrorCode.FILE_ALREADY_SAVED,candidateFile);
    this.saveFile=candidateFile;
  }
}",0.9886162408297496
3794,"/** 
 * Returns the save file from the default save directory.
 */
@Override protected File getDefaultSaveFile(){
  String fileName=getDefaultFileName();
  Category category=null;
  if (fileName != null) {
    category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(fileName));
  }
  return new File(SharingSettings.getSaveDirectory(category),fileName);
}","/** 
 * Returns the save file from the default save directory.
 */
@Override protected File getDefaultSaveFile(){
  String fileName=getDefaultFileName();
  Category category=null;
  if (fileName != null) {
    category=categoryManager.getCategoryForFilename(fileName);
  }
  return new File(SharingSettings.getSaveDirectory(category),fileName);
}",0.7156726768377254
3795,"private File getIncompleteFile(SerialManagedDownloader download,SerialIncompleteFileManager sifm){
  URN sha1=getSha1(download);
  File incompleteFile=null;
  if (download instanceof SerialResumeDownloader)   incompleteFile=((SerialResumeDownloader)download).getIncompleteFile();
  if (sha1 != null)   incompleteFile=sifm.getHashes().get(sha1);
  if (incompleteFile == null) {
    File saveFile=(File)download.getProperties().get(""String_Node_Str"");
    if (saveFile != null) {
      String defaultName=(String)download.getProperties().get(""String_Node_Str"");
      if (defaultName != null) {
        Category category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(defaultName));
        saveFile=new File(SharingSettings.getSaveDirectory(category),defaultName);
      }
    }
    Number size=(Number)download.getProperties().get(""String_Node_Str"");
    if (download instanceof SerialResumeDownloader)     size=((SerialResumeDownloader)download).getSize();
    if (saveFile != null && size != null) {
      String name=CommonUtils.convertFileName(saveFile.getName());
      incompleteFile=new File(SharingSettings.INCOMPLETE_DIRECTORY.get(),""String_Node_Str"" + size.longValue() + ""String_Node_Str""+ name);
    }
  }
  return incompleteFile;
}","private File getIncompleteFile(SerialManagedDownloader download,SerialIncompleteFileManager sifm){
  URN sha1=getSha1(download);
  File incompleteFile=null;
  if (download instanceof SerialResumeDownloader)   incompleteFile=((SerialResumeDownloader)download).getIncompleteFile();
  if (sha1 != null)   incompleteFile=sifm.getHashes().get(sha1);
  if (incompleteFile == null) {
    File saveFile=(File)download.getProperties().get(""String_Node_Str"");
    if (saveFile != null) {
      String defaultName=(String)download.getProperties().get(""String_Node_Str"");
      if (defaultName != null) {
        Category category=categoryManager.getCategoryForFilename(defaultName);
        saveFile=new File(SharingSettings.getSaveDirectory(category),defaultName);
      }
    }
    Number size=(Number)download.getProperties().get(""String_Node_Str"");
    if (download instanceof SerialResumeDownloader)     size=((SerialResumeDownloader)download).getSize();
    if (saveFile != null && size != null) {
      String name=CommonUtils.convertFileName(saveFile.getName());
      incompleteFile=new File(SharingSettings.INCOMPLETE_DIRECTORY.get(),""String_Node_Str"" + size.longValue() + ""String_Node_Str""+ name);
    }
  }
  return incompleteFile;
}",0.97236684020825
3796,"@Override public boolean allow(QueryReply qr,Response response){
  String extension=FileUtils.getFileExtension(response.getName());
  if (categoryManager.getFilterForCategory(Category.PROGRAM).apply(extension)) {
    return LibrarySettings.ALLOW_PROGRAMS.getValue();
  }
 else {
    return true;
  }
}","@Override public boolean allow(QueryReply qr,Response response){
  if (categoryManager.getCategoryForFilename(response.getName()) == Category.PROGRAM) {
    return LibrarySettings.ALLOW_PROGRAMS.getValue();
  }
 else {
    return true;
  }
}",0.6494464944649446
3797,"/** 
 * Checks to make sure that the file is not a document before adding file to managed file list. Returns true if the files was not a document, false otherwise. 
 */
private boolean addManagedFile(LibraryFileData newData,File file){
  Category category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(file));
  if (category != Category.DOCUMENT && category != Category.PROGRAM) {
    newData.addManagedFile(file);
    return true;
  }
  return false;
}","/** 
 * Checks to make sure that the file is not a document before adding file to managed file list. Returns true if the files was not a document, false otherwise. 
 */
private boolean addManagedFile(LibraryFileData newData,File file){
  Category category=categoryManager.getCategoryForFile(file);
  if (category != Category.DOCUMENT && category != Category.PROGRAM) {
    newData.addManagedFile(file);
    return true;
  }
  return false;
}",0.946448087431694
3798,"@Override public boolean isFileAddable(File file){
  if (file == null) {
    return false;
  }
  if (file.isDirectory()) {
    return isDirectoryAllowed(file);
  }
  Category category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(file));
  if (category == Category.PROGRAM && !LibrarySettings.ALLOW_PROGRAMS.getValue()) {
    return false;
  }
  return true;
}","@Override public boolean isFileAddable(File file){
  if (file == null) {
    return false;
  }
  if (file.isDirectory()) {
    return isDirectoryAllowed(file);
  }
  Category category=categoryManager.getCategoryForFile(file);
  if (category == Category.PROGRAM && !LibrarySettings.ALLOW_PROGRAMS.getValue()) {
    return false;
  }
  return true;
}",0.9410150891632372
3799,"@Override public boolean isFileAddable(File file){
  if (!library.isFileAddable(file)) {
    return false;
  }
  if (isPublic()) {
    Category category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(file));
    if (category == Category.DOCUMENT && !LibrarySettings.ALLOW_DOCUMENT_GNUTELLA_SHARING.getValue()) {
      return false;
    }
  }
  return true;
}","@Override public boolean isFileAddable(File file){
  if (!library.isFileAddable(file)) {
    return false;
  }
  if (isPublic()) {
    Category category=categoryManager.getCategoryForFile(file);
    if (category == Category.DOCUMENT && !LibrarySettings.ALLOW_DOCUMENT_GNUTELLA_SHARING.getValue()) {
      return false;
    }
  }
  return true;
}",0.9294605809128632
3800,"private Set<Response> queryFileNames(QueryRequest request){
  String str=request.getQuery();
  boolean includeXML=request.shouldIncludeXMLInResponse();
  str=keywordTrie.canonicalCase(str);
  IntSet matches=search(str,null,request.desiresPartialResults());
  if (request.getQueryUrns().size() > 0)   matches=urnSearch(request.getQueryUrns(),matches);
  if (matches == null)   return Collections.emptySet();
  Set<Response> responses=new HashSet<Response>();
  Predicate<String> filter=mediaTypeAggregator.getPredicateForQuery(request);
  LimeXMLDocument doc=request.getRichQuery();
  for (IntSet.IntSetIterator iter=matches.iterator(); iter.hasNext(); ) {
    int i=iter.next();
    FileDesc desc=gnutellaFileView.getFileDescForIndex(i);
    if (desc == null) {
      desc=incompleteFileView.getFileDescForIndex(i);
    }
    if (desc != null) {
      if (!filter.apply(desc.getFileName()))       continue;
      activityCallback.handleSharedFileUpdate(desc.getFile());
      Response resp=responseFactory.get().createResponse(desc);
      if (includeXML) {
        if (doc != null && resp.getDocument() != null && !isValidXMLMatch(resp,doc))         continue;
      }
 else {
        resp.setDocument(null);
      }
      responses.add(resp);
    }
  }
  if (responses.size() == 0)   return Collections.emptySet();
  return responses;
}","private Set<Response> queryFileNames(QueryRequest request){
  String str=request.getQuery();
  boolean includeXML=request.shouldIncludeXMLInResponse();
  str=keywordTrie.canonicalCase(str);
  IntSet matches=search(str,null,request.desiresPartialResults());
  if (request.getQueryUrns().size() > 0)   matches=urnSearch(request.getQueryUrns(),matches);
  if (matches == null)   return Collections.emptySet();
  Set<Response> responses=new HashSet<Response>();
  Predicate<String> filter=mediaTypeAggregator.getPredicateForQuery(request);
  LimeXMLDocument doc=request.getRichQuery();
  for (IntSet.IntSetIterator iter=matches.iterator(); iter.hasNext(); ) {
    int i=iter.next();
    FileDesc desc=gnutellaFileView.getFileDescForIndex(i);
    if (desc == null) {
      desc=incompleteFileView.getFileDescForIndex(i);
    }
    if (desc != null) {
      if (!filter.apply(FileUtils.getFileExtension(desc.getFileName()))) {
        continue;
      }
      activityCallback.handleSharedFileUpdate(desc.getFile());
      Response resp=responseFactory.get().createResponse(desc);
      if (includeXML) {
        if (doc != null && resp.getDocument() != null && !isValidXMLMatch(resp,doc))         continue;
      }
 else {
        resp.setDocument(null);
      }
      responses.add(resp);
    }
  }
  if (responses.size() == 0)   return Collections.emptySet();
  return responses;
}",0.9734708916728076
3801,"@Override public File getSaveFile(){
  String fileName=getIncompleteFile().getName();
  Category category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(fileName));
  File saveFile=new File(SharingSettings.getSaveDirectory(category),fileName);
  return saveFile;
}","@Override public File getSaveFile(){
  String fileName=getIncompleteFile().getName();
  Category category=categoryManager.getCategoryForFilename(fileName);
  File saveFile=new File(SharingSettings.getSaveDirectory(category),fileName);
  return saveFile;
}",0.7309833024118738
3802,"private BTTorrentFileDownloader createDownloader(URI uri){
  BTTorrentFileDownloader torrentFileDownloaderImpl=new BTTorrentFileDownloaderImpl(new DownloadManager(){
    @Override public boolean acceptPushedSocket(    String file,    int index,    byte[] clientGUID,    Socket socket){
      return false;
    }
    @Override public void addNewDownloader(    CoreDownloader downloader){
    }
    @Override public void bumpPriority(    Downloader downl,    boolean up,    int amt){
    }
    @Override public boolean conflicts(    URN urn,    long fileSize,    File... fileName){
      return false;
    }
    @Override public Downloader download(    RemoteFileDesc[] files,    List<? extends RemoteFileDesc> alts,    GUID queryGUID,    boolean overwrite,    File saveDir,    String fileName) throws DownloadException {
      return null;
    }
    @Override public Downloader download(    MagnetOptions magnet,    boolean overwrite,    File saveDir,    String fileName) throws IllegalArgumentException, DownloadException {
      return null;
    }
    @Override public Downloader download(    File incompleteFile) throws CantResumeException, DownloadException {
      return null;
    }
    @Override public Downloader download(    DownloadInformation info,    long now) throws DownloadException {
      return null;
    }
    @Override public Downloader downloadFromMozilla(    MozillaDownload listener){
      return null;
    }
    @Override public Downloader downloadFromStore(    RemoteFileDesc rfd,    boolean overwrite,    File saveDir,    String fileName) throws IllegalArgumentException, DownloadException {
      return null;
    }
    @Override public Downloader downloadTorrent(    URI torrentURI,    boolean overwrite) throws DownloadException {
      return null;
    }
    @Override public Downloader downloadTorrent(    File torrentFile,    File saveDirectory,    boolean overwrite) throws DownloadException {
      return null;
    }
    @Override public int downloadsInProgress(){
      return 0;
    }
    @Override public Iterable<CoreDownloader> getAllDownloaders(){
      return null;
    }
    @Override public float getAverageBandwidth(){
      return 0;
    }
    @Override public Downloader getDownloaderForIncompleteFile(    File file){
      return null;
    }
    @Override public Downloader getDownloaderForURN(    URN sha1){
      return null;
    }
    @Override public IncompleteFileManager getIncompleteFileManager(){
      return null;
    }
    @Override public float getLastMeasuredBandwidth(){
      return 0;
    }
    @Override public float getMeasuredBandwidth(){
      return 0;
    }
    @Override public int getNumActiveDownloads(){
      return 0;
    }
    @Override public int getNumIndividualDownloaders(){
      return 0;
    }
    @Override public int getNumWaitingDownloads(){
      return 0;
    }
    @Override public boolean hasInNetworkDownload(){
      return false;
    }
    @Override public boolean isActivelyDownloading(    URN urn){
      return false;
    }
    @Override public boolean isGuidForQueryDownloading(    GUID guid){
      return false;
    }
    @Override public boolean isIncomplete(    URN urn){
      return false;
    }
    @Override public boolean isSaveLocationTaken(    File candidateFile){
      return false;
    }
    @Override public boolean isSavedDownloadsLoaded(){
      return false;
    }
    @Override public void killDownloadersNotListed(    Collection<? extends DownloadInformation> updates){
    }
    @Override public void loadSavedDownloadsAndScheduleWriting(){
    }
    @Override public void measureBandwidth(){
    }
    @Override public void remove(    CoreDownloader downloader,    boolean completed){
    }
    @Override public void sendQuery(    QueryRequest query){
    }
    @Override public void start(){
    }
    @Override public void writeSnapshot(){
    }
    @Override public void visitDownloads(    Visitor<CoreDownloader> d){
    }
    @Override public void addListener(    EventListener<DownloadManagerEvent> listener){
    }
    @Override public boolean removeListener(    EventListener<DownloadManagerEvent> listener){
      return false;
    }
    @Override public void handleQueryReply(    QueryReply qr,    Address address){
    }
    @Override public boolean contains(    Downloader downloader){
      return false;
    }
  }
,new NoOpSaveLocationManager(),new DefaultHttpExecutor(new Provider<LimeHttpClient>(){
    @Override public LimeHttpClient get(){
      return new SimpleLimeHttpClient();
    }
  }
,new BasicHttpParams()),new ActivityCallback(){
    @Override public void addUpload(    Uploader u){
    }
    @Override public void handleMagnets(    MagnetOptions[] magnets){
    }
    @Override public void handleQuery(    QueryRequest query,    String address,    int port){
    }
    public void handleSharedFileUpdate(    File file){
    }
    @Override public void handleTorrent(    File torrentFile){
    }
    @Override public void installationCorrupted(){
    }
    @Override public boolean isQueryAlive(    GUID guid){
      return false;
    }
    @Override public void removeUpload(    Uploader u){
    }
    @Override public void restoreApplication(){
    }
    @Override public String translate(    String s){
      return null;
    }
    @Override public void uploadsComplete(){
    }
    @Override public void addDownload(    Downloader d){
    }
    @Override public void downloadsComplete(){
    }
    @Override public void promptAboutCorruptDownload(    Downloader dloader){
      dloader.discardCorruptDownload(false);
    }
    @Override public void warnUser(    String filename,    String message){
    }
    @Override public void removeDownload(    Downloader d){
    }
    @Override public void handleDownloadException(    DownloadAction downLoadAction,    DownloadException e,    boolean supportsNewSaveDir){
    }
    @Override public boolean promptTorrentUploadCancel(    Torrent torrent){
      return true;
    }
    @Override public void handleQueryResult(    RemoteFileDesc rfd,    QueryReply queryReply,    Set<? extends IpPort> locs){
    }
    @Override public boolean promptTorrentFilePriorities(    Torrent torrent){
      return true;
    }
  }
,new CategoryManager(){
    @Override public Category getCategoryForExtension(    String extension){
      return null;
    }
    @Override public Predicate<String> getFilterForCategory(    Category category){
      return null;
    }
    @Override public Predicate<String> getOsxAndLinuxProgramsFilter(){
      return null;
    }
    @Override public Predicate<String> getWindowsProgramsFilter(){
      return null;
    }
    @Override public Collection<String> getExtensionsForCategory(    Category category){
      return null;
    }
    @Override public Category getCategoryForFile(    File file){
      return null;
    }
  }
);
  torrentFileDownloaderImpl.initDownloadInformation(uri,true);
  return torrentFileDownloaderImpl;
}","private BTTorrentFileDownloader createDownloader(URI uri){
  BTTorrentFileDownloader torrentFileDownloaderImpl=new BTTorrentFileDownloaderImpl(new DownloadManager(){
    @Override public boolean acceptPushedSocket(    String file,    int index,    byte[] clientGUID,    Socket socket){
      return false;
    }
    @Override public void addNewDownloader(    CoreDownloader downloader){
    }
    @Override public void bumpPriority(    Downloader downl,    boolean up,    int amt){
    }
    @Override public boolean conflicts(    URN urn,    long fileSize,    File... fileName){
      return false;
    }
    @Override public Downloader download(    RemoteFileDesc[] files,    List<? extends RemoteFileDesc> alts,    GUID queryGUID,    boolean overwrite,    File saveDir,    String fileName) throws DownloadException {
      return null;
    }
    @Override public Downloader download(    MagnetOptions magnet,    boolean overwrite,    File saveDir,    String fileName) throws IllegalArgumentException, DownloadException {
      return null;
    }
    @Override public Downloader download(    File incompleteFile) throws CantResumeException, DownloadException {
      return null;
    }
    @Override public Downloader download(    DownloadInformation info,    long now) throws DownloadException {
      return null;
    }
    @Override public Downloader downloadFromMozilla(    MozillaDownload listener){
      return null;
    }
    @Override public Downloader downloadFromStore(    RemoteFileDesc rfd,    boolean overwrite,    File saveDir,    String fileName) throws IllegalArgumentException, DownloadException {
      return null;
    }
    @Override public Downloader downloadTorrent(    URI torrentURI,    boolean overwrite) throws DownloadException {
      return null;
    }
    @Override public Downloader downloadTorrent(    File torrentFile,    File saveDirectory,    boolean overwrite) throws DownloadException {
      return null;
    }
    @Override public int downloadsInProgress(){
      return 0;
    }
    @Override public Iterable<CoreDownloader> getAllDownloaders(){
      return null;
    }
    @Override public float getAverageBandwidth(){
      return 0;
    }
    @Override public Downloader getDownloaderForIncompleteFile(    File file){
      return null;
    }
    @Override public Downloader getDownloaderForURN(    URN sha1){
      return null;
    }
    @Override public IncompleteFileManager getIncompleteFileManager(){
      return null;
    }
    @Override public float getLastMeasuredBandwidth(){
      return 0;
    }
    @Override public float getMeasuredBandwidth(){
      return 0;
    }
    @Override public int getNumActiveDownloads(){
      return 0;
    }
    @Override public int getNumIndividualDownloaders(){
      return 0;
    }
    @Override public int getNumWaitingDownloads(){
      return 0;
    }
    @Override public boolean hasInNetworkDownload(){
      return false;
    }
    @Override public boolean isActivelyDownloading(    URN urn){
      return false;
    }
    @Override public boolean isGuidForQueryDownloading(    GUID guid){
      return false;
    }
    @Override public boolean isIncomplete(    URN urn){
      return false;
    }
    @Override public boolean isSaveLocationTaken(    File candidateFile){
      return false;
    }
    @Override public boolean isSavedDownloadsLoaded(){
      return false;
    }
    @Override public void killDownloadersNotListed(    Collection<? extends DownloadInformation> updates){
    }
    @Override public void loadSavedDownloadsAndScheduleWriting(){
    }
    @Override public void measureBandwidth(){
    }
    @Override public void remove(    CoreDownloader downloader,    boolean completed){
    }
    @Override public void sendQuery(    QueryRequest query){
    }
    @Override public void start(){
    }
    @Override public void writeSnapshot(){
    }
    @Override public void visitDownloads(    Visitor<CoreDownloader> d){
    }
    @Override public void addListener(    EventListener<DownloadManagerEvent> listener){
    }
    @Override public boolean removeListener(    EventListener<DownloadManagerEvent> listener){
      return false;
    }
    @Override public void handleQueryReply(    QueryReply qr,    Address address){
    }
    @Override public boolean contains(    Downloader downloader){
      return false;
    }
  }
,new NoOpSaveLocationManager(),new DefaultHttpExecutor(new Provider<LimeHttpClient>(){
    @Override public LimeHttpClient get(){
      return new SimpleLimeHttpClient();
    }
  }
,new BasicHttpParams()),new ActivityCallback(){
    @Override public void addUpload(    Uploader u){
    }
    @Override public void handleMagnets(    MagnetOptions[] magnets){
    }
    @Override public void handleQuery(    QueryRequest query,    String address,    int port){
    }
    public void handleSharedFileUpdate(    File file){
    }
    @Override public void handleTorrent(    File torrentFile){
    }
    @Override public void installationCorrupted(){
    }
    @Override public boolean isQueryAlive(    GUID guid){
      return false;
    }
    @Override public void removeUpload(    Uploader u){
    }
    @Override public void restoreApplication(){
    }
    @Override public String translate(    String s){
      return null;
    }
    @Override public void uploadsComplete(){
    }
    @Override public void addDownload(    Downloader d){
    }
    @Override public void downloadsComplete(){
    }
    @Override public void promptAboutCorruptDownload(    Downloader dloader){
      dloader.discardCorruptDownload(false);
    }
    @Override public void warnUser(    String filename,    String message){
    }
    @Override public void removeDownload(    Downloader d){
    }
    @Override public void handleDownloadException(    DownloadAction downLoadAction,    DownloadException e,    boolean supportsNewSaveDir){
    }
    @Override public boolean promptTorrentUploadCancel(    Torrent torrent){
      return true;
    }
    @Override public void handleQueryResult(    RemoteFileDesc rfd,    QueryReply queryReply,    Set<? extends IpPort> locs){
    }
    @Override public boolean promptTorrentFilePriorities(    Torrent torrent){
      return true;
    }
  }
,new CategoryManager(){
    @Override public Category getCategoryForExtension(    String extension){
      return null;
    }
    @Override public Predicate<String> getExtensionFilterForCategory(    Category category){
      return null;
    }
    @Override public Predicate<String> getOsxAndLinuxProgramsFilter(){
      return null;
    }
    @Override public Predicate<String> getWindowsProgramsFilter(){
      return null;
    }
    @Override public Collection<String> getExtensionsForCategory(    Category category){
      return null;
    }
    @Override public Category getCategoryForFile(    File file){
      return null;
    }
    @Override public Category getCategoryForFilename(    String filename){
      return null;
    }
  }
);
  torrentFileDownloaderImpl.initDownloadInformation(uri,true);
  return torrentFileDownloaderImpl;
}",0.9922137295521108
3803,"@Override public void actionPerformed(ActionEvent e){
  Category category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(file));
switch (category) {
case AUDIO:
    PlayerUtils.playOrLaunch(file,categoryManager);
  break;
case DOCUMENT:
case IMAGE:
case VIDEO:
NativeLaunchUtils.safeLaunchFile(file,categoryManager);
break;
case PROGRAM:
case OTHER:
NativeLaunchUtils.launchExplorer(file);
break;
default :
break;
}
}","@Override public void actionPerformed(ActionEvent e){
  Category category=categoryManager.getCategoryForFile(file);
switch (category) {
case AUDIO:
    PlayerUtils.playOrLaunch(file,categoryManager);
  break;
case DOCUMENT:
case IMAGE:
case VIDEO:
NativeLaunchUtils.safeLaunchFile(file,categoryManager);
break;
case PROGRAM:
case OTHER:
NativeLaunchUtils.launchExplorer(file);
break;
default :
break;
}
}",0.948870392390012
3804,"private void addRecentDownloadAction(final File file){
  add(new AbstractAction(file.getName()){
    @Override public void actionPerformed(    ActionEvent e){
      Category category=categoryManager.getCategoryForExtension(FileUtils.getFileExtension(file));
switch (category) {
case AUDIO:
        PlayerUtils.playOrLaunch(file,categoryManager);
      break;
case DOCUMENT:
case IMAGE:
case VIDEO:
    NativeLaunchUtils.safeLaunchFile(file,categoryManager);
  break;
case PROGRAM:
case OTHER:
NativeLaunchUtils.launchExplorer(file);
break;
default :
break;
}
}
}
);
}","private void addRecentDownloadAction(final File file){
  add(new AbstractAction(file.getName()){
    @Override public void actionPerformed(    ActionEvent e){
      Category category=categoryManager.getCategoryForFile(file);
switch (category) {
case AUDIO:
        PlayerUtils.playOrLaunch(file,categoryManager);
      break;
case DOCUMENT:
case IMAGE:
case VIDEO:
    NativeLaunchUtils.safeLaunchFile(file,categoryManager);
  break;
case PROGRAM:
case OTHER:
NativeLaunchUtils.launchExplorer(file);
break;
default :
break;
}
}
}
);
}",0.96094459582198
3805,"@Inject public FirewallOptionPanel(NetworkManager networkManager){
  super();
  this.networkManager=networkManager;
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  setOpaque(false);
  add(getListeningPortPanel(),""String_Node_Str"");
  add(getRouterConfigPanel(),""String_Node_Str"");
}","@Inject public FirewallOptionPanel(NetworkManager networkManager){
  super();
  this.networkManager=networkManager;
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  add(getListeningPortPanel(),""String_Node_Str"");
  add(getRouterConfigPanel(),""String_Node_Str"");
}",0.6611295681063123
3806,"private JPanel getPerformancePanel(){
  JPanel p=new JPanel();
  p.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  p.setLayout(new MigLayout());
  p.setOpaque(false);
  disableUltraPeerCheckBox=new JCheckBox(I18n.tr(""String_Node_Str""));
  disableMojitoCheckBox=new JCheckBox(I18n.tr(""String_Node_Str""));
  disableTLS=new JCheckBox(I18n.tr(""String_Node_Str""));
  disableOutOfBandSearchCheckBox=new JCheckBox(I18n.tr(""String_Node_Str""));
  disableUltraPeerCheckBox.setOpaque(false);
  disableMojitoCheckBox.setOpaque(false);
  disableTLS.setOpaque(false);
  disableOutOfBandSearchCheckBox.setOpaque(false);
  p.add(new MultiLineLabel(firstMultiLineLabel,ReallyAdvancedOptionPanel.MULTI_LINE_LABEL_WIDTH),""String_Node_Str"");
  p.add(disableUltraPeerCheckBox,""String_Node_Str"");
  p.add(disableMojitoCheckBox,""String_Node_Str"");
  p.add(new MultiLineLabel(secondMultiLineLabel,ReallyAdvancedOptionPanel.MULTI_LINE_LABEL_WIDTH),""String_Node_Str"");
  p.add(disableTLS,""String_Node_Str"");
  p.add(new MultiLineLabel(thirdMultiLineLabel,ReallyAdvancedOptionPanel.MULTI_LINE_LABEL_WIDTH),""String_Node_Str"");
  p.add(disableOutOfBandSearchCheckBox,""String_Node_Str"");
  return p;
}","private JPanel getPerformancePanel(){
  JPanel p=new JPanel();
  p.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  p.setLayout(new MigLayout(""String_Node_Str""));
  p.setOpaque(false);
  disableUltraPeerCheckBox=new JCheckBox(I18n.tr(""String_Node_Str""));
  disableMojitoCheckBox=new JCheckBox(I18n.tr(""String_Node_Str""));
  disableTLS=new JCheckBox(I18n.tr(""String_Node_Str""));
  disableOutOfBandSearchCheckBox=new JCheckBox(I18n.tr(""String_Node_Str""));
  disableUltraPeerCheckBox.setOpaque(false);
  disableMojitoCheckBox.setOpaque(false);
  disableTLS.setOpaque(false);
  disableOutOfBandSearchCheckBox.setOpaque(false);
  p.add(new MultiLineLabel(firstMultiLineLabel,ReallyAdvancedOptionPanel.MULTI_LINE_LABEL_WIDTH),""String_Node_Str"");
  p.add(disableUltraPeerCheckBox,""String_Node_Str"");
  p.add(disableMojitoCheckBox,""String_Node_Str"");
  p.add(new MultiLineLabel(secondMultiLineLabel,ReallyAdvancedOptionPanel.MULTI_LINE_LABEL_WIDTH),""String_Node_Str"");
  p.add(disableTLS,""String_Node_Str"");
  p.add(new MultiLineLabel(thirdMultiLineLabel,ReallyAdvancedOptionPanel.MULTI_LINE_LABEL_WIDTH),""String_Node_Str"");
  p.add(disableOutOfBandSearchCheckBox,""String_Node_Str"");
  return p;
}",0.992901878914405
3807,"@Inject public SpamOptionPanel(SpamManager spamManager){
  this.spamManager=spamManager;
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  setOpaque(false);
  add(getClearPanel(),""String_Node_Str"");
}","@Inject public SpamOptionPanel(SpamManager spamManager){
  this.spamManager=spamManager;
  setLayout(new MigLayout(""String_Node_Str""));
  setOpaque(false);
  add(getClearPanel(),""String_Node_Str"");
}",0.9170506912442395
3808,"public void setupCellRenderers(Category category,AbstractLibraryFormat format){
  for (int i=0; i < format.getColumnCount(); i++) {
    Class clazz=format.getColumnClass(i);
    if (clazz == String.class) {
      setCellRenderer(i,defaultCellRenderer.get());
    }
  }
  if (category != null) {
switch (category) {
case AUDIO:
      setCellRenderer(AudioTableFormat.PLAY_INDEX,isPlayingRenderer.get());
    setUnsortable(AudioTableFormat.PLAY_INDEX);
  setCellRenderer(AudioTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(AudioTableFormat.LENGTH_INDEX,timeRenderer.get());
setCellRenderer(AudioTableFormat.TITLE_INDEX,nameRenderer.get());
setCellRenderer(AudioTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(AudioTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(AudioTableFormat.ACTION_INDEX);
break;
case VIDEO:
setCellRenderer(VideoTableFormat.LENGTH_INDEX,timeRenderer.get());
setCellRenderer(VideoTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(VideoTableFormat.NAME_INDEX,nameRenderer.get());
setCellRenderer(VideoTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(VideoTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(VideoTableFormat.ACTION_INDEX);
break;
case IMAGE:
setCellRenderer(ImageTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(ImageTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(ImageTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(ImageTableFormat.ACTION_INDEX);
break;
case DOCUMENT:
setCellRenderer(DocumentTableFormat.NAME_INDEX,iconLabelRenderer);
setCellRenderer(DocumentTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(DocumentTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(DocumentTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(DocumentTableFormat.ACTION_INDEX);
break;
case PROGRAM:
setCellRenderer(ProgramTableFormat.NAME_INDEX,iconLabelRenderer);
setCellRenderer(ProgramTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(ProgramTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(ProgramTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(ProgramTableFormat.ACTION_INDEX);
break;
case OTHER:
setCellRenderer(OtherTableFormat.NAME_INDEX,iconLabelRenderer);
setCellRenderer(OtherTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(OtherTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(OtherTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(OtherTableFormat.ACTION_INDEX);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + category);
}
}
 else {
setCellRenderer(AllTableFormat.PLAY_INDEX,isPlayingRenderer.get());
setUnsortable(AllTableFormat.PLAY_INDEX);
setCellRenderer(AllTableFormat.NAME_INDEX,nameCategoryRenderer.get());
setCellRenderer(AllTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(AllTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(AllTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(AllTableFormat.ACTION_INDEX);
}
}","public void setupCellRenderers(Category category,AbstractLibraryFormat format){
  for (int i=0; i < format.getColumnCount(); i++) {
    Class clazz=format.getColumnClass(i);
    if (clazz == String.class) {
      setCellRenderer(i,defaultCellRenderer.get());
    }
  }
  if (category != null) {
switch (category) {
case AUDIO:
      setHeaderRenderer(AudioTableFormat.LENGTH_INDEX,new TableCellHeaderRenderer(JLabel.TRAILING));
    setCellRenderer(AudioTableFormat.PLAY_INDEX,isPlayingRenderer.get());
  setUnsortable(AudioTableFormat.PLAY_INDEX);
setCellRenderer(AudioTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(AudioTableFormat.LENGTH_INDEX,timeRenderer.get());
setCellRenderer(AudioTableFormat.TITLE_INDEX,nameRenderer.get());
setCellRenderer(AudioTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(AudioTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(AudioTableFormat.ACTION_INDEX);
break;
case VIDEO:
setHeaderRenderer(VideoTableFormat.LENGTH_INDEX,new TableCellHeaderRenderer(JLabel.TRAILING));
setCellRenderer(VideoTableFormat.LENGTH_INDEX,timeRenderer.get());
setCellRenderer(VideoTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(VideoTableFormat.NAME_INDEX,nameRenderer.get());
setCellRenderer(VideoTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(VideoTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(VideoTableFormat.ACTION_INDEX);
break;
case IMAGE:
setCellRenderer(ImageTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(ImageTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(ImageTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(ImageTableFormat.ACTION_INDEX);
break;
case DOCUMENT:
setCellRenderer(DocumentTableFormat.NAME_INDEX,iconLabelRenderer);
setCellRenderer(DocumentTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(DocumentTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(DocumentTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(DocumentTableFormat.ACTION_INDEX);
break;
case PROGRAM:
setCellRenderer(ProgramTableFormat.NAME_INDEX,iconLabelRenderer);
setCellRenderer(ProgramTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(ProgramTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(ProgramTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(ProgramTableFormat.ACTION_INDEX);
break;
case OTHER:
setCellRenderer(OtherTableFormat.NAME_INDEX,iconLabelRenderer);
setCellRenderer(OtherTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(OtherTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(OtherTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(OtherTableFormat.ACTION_INDEX);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + category);
}
}
 else {
setCellRenderer(AllTableFormat.PLAY_INDEX,isPlayingRenderer.get());
setUnsortable(AllTableFormat.PLAY_INDEX);
setCellRenderer(AllTableFormat.NAME_INDEX,nameCategoryRenderer.get());
setCellRenderer(AllTableFormat.SIZE_INDEX,fileSizeRenderer.get());
setCellRenderer(AllTableFormat.ACTION_INDEX,removeRenderer.get());
setCellEditor(AllTableFormat.ACTION_INDEX,removeEditor);
setUnsortable(AllTableFormat.ACTION_INDEX);
}
}",0.9680851063829788
3809,"/** 
 * Constructs a BaseResultPanel with the specified components.
 */
@Inject public BaseResultPanel(@Assisted SearchResultsModel searchResultsModel,ResultsTableFormatFactory tableFormatFactory,ListViewTableEditorRendererFactory listViewTableEditorRendererFactory,ListViewRowHeightRule rowHeightRule,RemoteHostWidgetFactory fromWidgetFactory,SearchResultMenuFactory menuFactory,Provider<IconLabelRendererFactory> iconLabelRendererFactory,Provider<TimeRenderer> timeRenderer,Provider<FileSizeRenderer> fileSizeRenderer,Provider<CalendarRenderer> calendarRenderer,LibraryMediator libraryMediator,Provider<QualityRenderer> qualityRenderer,DefaultTableCellRenderer defaultTableCellRenderer,MainDownloadPanel mainDownloadPanel){
  this.searchResultsModel=searchResultsModel;
  this.tableFormatFactory=tableFormatFactory;
  this.listViewTableEditorRendererFactory=listViewTableEditorRendererFactory;
  this.rowHeightRule=rowHeightRule;
  this.fromWidgetfactory=fromWidgetFactory;
  this.iconLabelRendererFactory=iconLabelRendererFactory;
  this.downloadHandler=new DownloadHandlerImpl(searchResultsModel,libraryMediator,mainDownloadPanel);
  this.timeRenderer=timeRenderer;
  this.fileSizeRenderer=fileSizeRenderer;
  this.calendarRenderer=calendarRenderer;
  this.qualityRenderer=qualityRenderer;
  this.defaultTableCellRenderer=defaultTableCellRenderer;
  this.menuFactory=menuFactory;
  rowHeightRule.initializeWithSearch(searchResultsModel.getSearchQuery());
  this.resultsList=createList();
  this.resultsTable=createTable();
  searchResultsModel.addDisposalListener(new ResultModelDisposalListener());
  setLayout(new BorderLayout());
}","/** 
 * Constructs a BaseResultPanel with the specified components.
 */
@Inject public BaseResultPanel(@Assisted SearchResultsModel searchResultsModel,ResultsTableFormatFactory tableFormatFactory,ListViewTableEditorRendererFactory listViewTableEditorRendererFactory,ListViewRowHeightRule rowHeightRule,RemoteHostWidgetFactory fromWidgetFactory,SearchResultMenuFactory menuFactory,Provider<IconLabelRendererFactory> iconLabelRendererFactory,Provider<TimeRenderer> timeRenderer,Provider<FileSizeRenderer> fileSizeRenderer,Provider<CalendarRenderer> calendarRenderer,LibraryMediator libraryMediator,Provider<QualityRenderer> qualityRenderer,DefaultLimeTableCellRenderer defaultTableCellRenderer,MainDownloadPanel mainDownloadPanel){
  this.searchResultsModel=searchResultsModel;
  this.tableFormatFactory=tableFormatFactory;
  this.listViewTableEditorRendererFactory=listViewTableEditorRendererFactory;
  this.rowHeightRule=rowHeightRule;
  this.fromWidgetfactory=fromWidgetFactory;
  this.iconLabelRendererFactory=iconLabelRendererFactory;
  this.downloadHandler=new DownloadHandlerImpl(searchResultsModel,libraryMediator,mainDownloadPanel);
  this.timeRenderer=timeRenderer;
  this.fileSizeRenderer=fileSizeRenderer;
  this.calendarRenderer=calendarRenderer;
  this.qualityRenderer=qualityRenderer;
  this.defaultTableCellRenderer=defaultTableCellRenderer;
  this.menuFactory=menuFactory;
  rowHeightRule.initializeWithSearch(searchResultsModel.getSearchQuery());
  this.resultsList=createList();
  this.resultsTable=createTable();
  searchResultsModel.addDisposalListener(new ResultModelDisposalListener());
  setLayout(new BorderLayout());
}",0.998780487804878
3810,"private void handleTorrentEvent(TorrentEvent event){
  if (event == TorrentEvent.COMPLETED) {
    lock.writeLock().lock();
    try {
      int seedingTorrents=0;
      int maxSeedingTorrents=torrentSettings.get().getMaxSeedingLimit();
      if (maxSeedingTorrents == Integer.MAX_VALUE) {
        return;
      }
      for (      Torrent torrent : torrents.values()) {
        if (torrent.isFinished()) {
          seedingTorrents++;
        }
      }
      if (seedingTorrents <= maxSeedingTorrents) {
        return;
      }
      List<Torrent> ratioSortedTorrents=new SortedList<Torrent>(torrents.values(),new Comparator<Torrent>(){
        @Override public int compare(        Torrent o1,        Torrent o2){
          int compare=Double.compare(o2.getSeedRatio(),o1.getSeedRatio());
          if (compare == 0) {
            TorrentStatus status1=o1.getStatus();
            TorrentStatus status2=o2.getStatus();
            if (status1 != null && status2 != null) {
              int time1=status1.getSeedingTime();
              int time2=status2.getSeedingTime();
              if (time1 > time2) {
                return -1;
              }
 else               if (time2 > time1) {
                return 1;
              }
 else {
                return 0;
              }
            }
          }
          return compare;
        }
      }
);
      for (int i=0; i < seedingTorrents - maxSeedingTorrents && ratioSortedTorrents.size() > 0; ) {
        Torrent torrent=ratioSortedTorrents.remove(0);
        if (torrent.isFinished()) {
          torrent.stop();
          torrent.removeListener(torrentListener);
          i++;
        }
      }
    }
  finally {
      lock.writeLock().unlock();
    }
  }
}","private void handleTorrentEvent(TorrentEvent event){
  if (event == TorrentEvent.COMPLETED) {
    lock.writeLock().lock();
    try {
      int seedingTorrents=0;
      int maxSeedingTorrents=torrentSettings.get().getMaxSeedingLimit();
      if (maxSeedingTorrents == Integer.MAX_VALUE) {
        return;
      }
      for (      Torrent torrent : torrents.values()) {
        if (torrent.isFinished()) {
          seedingTorrents++;
        }
      }
      if (seedingTorrents <= maxSeedingTorrents) {
        return;
      }
      List<Torrent> ratioSortedTorrents=new ArrayList<Torrent>(torrents.values());
      Collections.sort(ratioSortedTorrents,new Comparator<Torrent>(){
        @Override public int compare(        Torrent o1,        Torrent o2){
          int compare=Double.compare(o2.getSeedRatio(),o1.getSeedRatio());
          if (compare == 0) {
            TorrentStatus status1=o1.getStatus();
            TorrentStatus status2=o2.getStatus();
            if (status1 != null && status2 != null) {
              int time1=status1.getSeedingTime();
              int time2=status2.getSeedingTime();
              if (time1 > time2) {
                return -1;
              }
 else               if (time2 > time1) {
                return 1;
              }
 else {
                return 0;
              }
            }
          }
          return compare;
        }
      }
);
      for (int i=0; i < seedingTorrents - maxSeedingTorrents && ratioSortedTorrents.size() > 0; ) {
        Torrent torrent=ratioSortedTorrents.remove(0);
        if (torrent.isFinished()) {
          torrent.stop();
          torrent.removeListener(torrentListener);
          i++;
        }
      }
    }
  finally {
      lock.writeLock().unlock();
    }
  }
}",0.9695402298850576
3811,"@Inject public FileInfoDialog(@Assisted PropertiableFile propertiable,@Assisted final FileInfoType type,FileInfoTabPanel fileInfoTabPanel,final FileInfoPanelFactory fileInfoFactory,final LibraryManager libraryManager){
  super(GuiUtils.getMainFrame());
  tabPanel=fileInfoTabPanel;
  cardPanel=new JPanel(new BorderLayout());
  cardPanel.setPreferredSize(new Dimension(400,600));
  cards=new HashMap<Tabs,FileInfoPanel>();
  this.propertiableFile=propertiable;
  GuiUtils.assignResources(this);
  cardPanel.setOpaque(false);
  createTabs(propertiableFile,type);
  cards.put(Tabs.GENERAL,fileInfoFactory.createGeneralPanel(type,propertiableFile));
  cardPanel.add(cards.get(Tabs.GENERAL).getComponent());
  setTitle(I18n.tr(""String_Node_Str"",propertiableFile.getFileName()));
  setLayout(new MigLayout(""String_Node_Str""));
  getContentPane().setBackground(backgroundColor);
  overviewPanel=(FileInfoOverviewPanel)fileInfoFactory.createOverviewPanel(type,propertiableFile);
  add(overviewPanel.getComponent(),""String_Node_Str"");
  add(tabPanel.getComponent(),""String_Node_Str"");
  add(cardPanel,""String_Node_Str"");
  createFooter();
  setPreferredSize(new Dimension(500,565));
  setModalityType(ModalityType.APPLICATION_MODAL);
  setDefaultCloseOperation(FileInfoDialog.DISPOSE_ON_CLOSE);
  pack();
  setLocationRelativeTo(GuiUtils.getMainFrame());
  addComponentListener(new ComponentListener(){
    @Override public void componentHidden(    ComponentEvent e){
      for (      FileInfoPanel panel : cards.values()) {
        panel.unregisterListeners();
      }
      libraryManager.getLibraryManagedList().removePropertyChangeListener(renameListener);
      FileInfoDialog.this.dispose();
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentResized(    ComponentEvent e){
    }
    @Override public void componentShown(    ComponentEvent e){
      if (okButton != null)       okButton.requestFocusInWindow();
    }
  }
);
  renameListener=new RenameListener(libraryManager);
  libraryManager.getLibraryManagedList().addPropertyChangeListener(renameListener);
  tabPanel.addSearchTabListener(new FileInfoTabListener(){
    @Override public void tabSelected(    Tabs tab){
      if (!cards.containsKey(tab)) {
        if (tab == Tabs.GENERAL) {
          cards.put(tab,fileInfoFactory.createGeneralPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.SHARING) {
          cards.put(tab,fileInfoFactory.createSharingPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.TRANSFERS) {
          cards.put(tab,fileInfoFactory.createTransferPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.BITTORENT) {
          if (propertiableFile instanceof DownloadItem && ((DownloadItem)propertiableFile).getDownloadProperty(DownloadPropertyKey.TORRENT) != null) {
            Torrent torrent=(Torrent)((DownloadItem)propertiableFile).getDownloadProperty(DownloadPropertyKey.TORRENT);
            if (torrent.hasMetaData()) {
              cards.put(tab,fileInfoFactory.createBittorentPanel(torrent));
            }
          }
 else {
            throw new IllegalStateException(""String_Node_Str"");
          }
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + tab);
        }
      }
      cardPanel.removeAll();
      cardPanel.add(cards.get(tab).getComponent());
      FileInfoDialog.this.validate();
      FileInfoDialog.this.repaint();
    }
  }
);
}","@Inject public FileInfoDialog(@Assisted PropertiableFile propertiable,@Assisted final FileInfoType type,FileInfoTabPanel fileInfoTabPanel,final FileInfoPanelFactory fileInfoFactory,final LibraryManager libraryManager){
  super(GuiUtils.getMainFrame());
  tabPanel=fileInfoTabPanel;
  cardPanel=new JPanel(new BorderLayout());
  cardPanel.setPreferredSize(new Dimension(400,600));
  cards=new HashMap<Tabs,FileInfoPanel>();
  this.propertiableFile=propertiable;
  GuiUtils.assignResources(this);
  cardPanel.setOpaque(false);
  createTabs(propertiableFile,type);
  cards.put(Tabs.GENERAL,fileInfoFactory.createGeneralPanel(type,propertiableFile));
  cardPanel.add(cards.get(Tabs.GENERAL).getComponent());
  updateTitle(propertiableFile.getFileName());
  setLayout(new MigLayout(""String_Node_Str""));
  getContentPane().setBackground(backgroundColor);
  overviewPanel=(FileInfoOverviewPanel)fileInfoFactory.createOverviewPanel(type,propertiableFile);
  add(overviewPanel.getComponent(),""String_Node_Str"");
  add(tabPanel.getComponent(),""String_Node_Str"");
  add(cardPanel,""String_Node_Str"");
  createFooter();
  setPreferredSize(new Dimension(500,565));
  setModalityType(ModalityType.APPLICATION_MODAL);
  setDefaultCloseOperation(FileInfoDialog.DISPOSE_ON_CLOSE);
  pack();
  setLocationRelativeTo(GuiUtils.getMainFrame());
  addComponentListener(new ComponentListener(){
    @Override public void componentHidden(    ComponentEvent e){
      for (      FileInfoPanel panel : cards.values()) {
        panel.unregisterListeners();
      }
      libraryManager.getLibraryManagedList().removePropertyChangeListener(renameListener);
      FileInfoDialog.this.dispose();
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentResized(    ComponentEvent e){
    }
    @Override public void componentShown(    ComponentEvent e){
      if (okButton != null)       okButton.requestFocusInWindow();
    }
  }
);
  renameListener=new RenameListener(libraryManager);
  libraryManager.getLibraryManagedList().addPropertyChangeListener(renameListener);
  tabPanel.addSearchTabListener(new FileInfoTabListener(){
    @Override public void tabSelected(    Tabs tab){
      if (!cards.containsKey(tab)) {
        if (tab == Tabs.GENERAL) {
          cards.put(tab,fileInfoFactory.createGeneralPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.SHARING) {
          cards.put(tab,fileInfoFactory.createSharingPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.TRANSFERS) {
          cards.put(tab,fileInfoFactory.createTransferPanel(type,propertiableFile));
        }
 else         if (tab == Tabs.BITTORENT) {
          if (propertiableFile instanceof DownloadItem && ((DownloadItem)propertiableFile).getDownloadProperty(DownloadPropertyKey.TORRENT) != null) {
            Torrent torrent=(Torrent)((DownloadItem)propertiableFile).getDownloadProperty(DownloadPropertyKey.TORRENT);
            if (torrent.hasMetaData()) {
              cards.put(tab,fileInfoFactory.createBittorentPanel(torrent));
            }
          }
 else {
            throw new IllegalStateException(""String_Node_Str"");
          }
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + tab);
        }
      }
      cardPanel.removeAll();
      cardPanel.add(cards.get(tab).getComponent());
      FileInfoDialog.this.validate();
      FileInfoDialog.this.repaint();
    }
  }
);
}",0.987906708897207
3812,"@Override public void propertyChange(PropertyChangeEvent evt){
  if (evt.getPropertyName().equals(""String_Node_Str"")) {
    if (propertiableFile instanceof LocalFileItem && ((LocalFileItem)propertiableFile).getFile().equals(evt.getOldValue())) {
      propertiableFile=libraryManager.getLibraryManagedList().getFileItem((File)evt.getNewValue());
      for (      FileInfoPanel panel : cards.values()) {
        panel.updatePropertiableFile(propertiableFile);
      }
      overviewPanel.updatePropertiableFile(propertiableFile);
    }
  }
}","@Override public void propertyChange(PropertyChangeEvent evt){
  if (evt.getPropertyName().equals(""String_Node_Str"")) {
    if (propertiableFile instanceof LocalFileItem && ((LocalFileItem)propertiableFile).getFile().equals(evt.getOldValue())) {
      propertiableFile=libraryManager.getLibraryManagedList().getFileItem((File)evt.getNewValue());
      for (      FileInfoPanel panel : cards.values()) {
        panel.updatePropertiableFile(propertiableFile);
      }
      overviewPanel.updatePropertiableFile(propertiableFile);
      updateTitle(propertiableFile.getFileName());
    }
  }
}",0.9549071618037136
3813,"@Override public void setSaveFile(File saveFile,boolean overwrite) throws DownloadException {
  File saveDir=null;
  String fileName=null;
  if (saveFile != null) {
    if (saveFile.isDirectory()) {
      saveDir=saveFile;
    }
 else {
      saveDir=saveFile.getParentFile();
      fileName=saveFile.getName();
    }
  }
  downloader.setSaveFile(saveDir,fileName,overwrite);
}","@Override public void setSaveFile(File saveFile,boolean overwrite) throws DownloadException {
  File saveDir=null;
  String fileName=null;
  if (saveFile != null) {
    if (saveFile.isDirectory()) {
      saveDir=saveFile;
      fileName=getFileName();
    }
 else {
      saveDir=saveFile.getParentFile();
      fileName=saveFile.getName();
    }
  }
  downloader.setSaveFile(saveDir,fileName,overwrite);
}",0.9617346938775512
3814,"private void createOverwriteDialogue(final File saveFile,final DownloadAction downLoadAction,final DownloadException ex,final boolean supportNewSaveFileName){
  final JDialog dialog=new LimeJDialog(GuiUtils.getMainFrame());
  dialog.setModalityType(ModalityType.APPLICATION_MODAL);
  final MultiLineLabel message=new MultiLineLabel(I18n.tr(""String_Node_Str""),400);
  final JTextField filePathField=new JTextField(25);
  filePathField.setEnabled(false);
  filePathField.setText(saveFile.getAbsolutePath());
  JToggleButton overwriteButton=null;
  overwriteButton=new JToggleButton(I18n.tr(""String_Node_Str""));
  overwriteButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      dialog.dispose();
      download(downLoadAction,supportNewSaveFileName,saveFile,true);
    }
  }
);
  JButton cancelButton=new JButton(I18n.tr(""String_Node_Str""));
  cancelButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      dialog.dispose();
      File saveFile=ex.getFile();
      File oldSaveFile=saveFile;
      File oldSaveFileParent=saveFile != null && saveFile.getParentFile() != null ? saveFile.getParentFile() : saveFile;
      saveFile=FileChooser.getInputDirectory(GuiUtils.getMainFrame(),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),oldSaveFileParent);
      File newSaveParent=saveFile;
      if (newSaveParent != null && new File(newSaveParent,oldSaveFile.getName()).exists()) {
        createOverwriteDialogue(newSaveParent,downLoadAction,ex,supportNewSaveFileName);
        return;
      }
 else       if (saveFile != null) {
        download(downLoadAction,supportNewSaveFileName,saveFile,false);
      }
    }
  }
);
  JPanel panel=new JPanel();
  panel.setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  panel.add(message,""String_Node_Str"");
  panel.add(filePathField,""String_Node_Str"");
  panel.add(overwriteButton,""String_Node_Str"");
  panel.add(cancelButton);
  dialog.setContentPane(panel);
  dialog.pack();
  dialog.setLocationRelativeTo(GuiUtils.getMainFrame());
  dialog.setVisible(true);
}","private void createOverwriteDialogue(final File overwriteFile,final DownloadAction downLoadAction,final DownloadException ex,final boolean supportNewSaveFileName){
  final JDialog dialog=new LimeJDialog(GuiUtils.getMainFrame());
  dialog.setModalityType(ModalityType.APPLICATION_MODAL);
  final MultiLineLabel message=new MultiLineLabel(I18n.tr(""String_Node_Str""),400);
  final JTextField filePathField=new JTextField(25);
  filePathField.setEnabled(false);
  filePathField.setText(overwriteFile.getAbsolutePath());
  JToggleButton overwriteButton=null;
  overwriteButton=new JToggleButton(I18n.tr(""String_Node_Str""));
  overwriteButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      dialog.dispose();
      download(downLoadAction,supportNewSaveFileName,overwriteFile,true);
    }
  }
);
  JButton cancelButton=new JButton(I18n.tr(""String_Node_Str""));
  cancelButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      dialog.dispose();
      File oldSaveFile=overwriteFile;
      File oldSaveFileParent=overwriteFile.getParentFile() != null ? overwriteFile.getParentFile() : overwriteFile;
      File newSaveParent=FileChooser.getInputDirectory(GuiUtils.getMainFrame(),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),oldSaveFileParent);
      if (newSaveParent != null && new File(newSaveParent,oldSaveFile.getName()).exists()) {
        File saveFile=new File(newSaveParent,oldSaveFile.getName());
        createOverwriteDialogue(saveFile,downLoadAction,ex,supportNewSaveFileName);
        return;
      }
 else       if (newSaveParent != null) {
        File saveFile=new File(newSaveParent,oldSaveFile.getName());
        download(downLoadAction,supportNewSaveFileName,saveFile,false);
      }
    }
  }
);
  JPanel panel=new JPanel();
  panel.setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  panel.add(message,""String_Node_Str"");
  panel.add(filePathField,""String_Node_Str"");
  panel.add(overwriteButton,""String_Node_Str"");
  panel.add(cancelButton);
  dialog.setContentPane(panel);
  dialog.pack();
  dialog.setLocationRelativeTo(GuiUtils.getMainFrame());
  dialog.setVisible(true);
}",0.8539682539682539
3815,"@Override public void actionPerformed(ActionEvent e){
  dialog.dispose();
  File saveFile=ex.getFile();
  File oldSaveFile=saveFile;
  File oldSaveFileParent=saveFile != null && saveFile.getParentFile() != null ? saveFile.getParentFile() : saveFile;
  saveFile=FileChooser.getInputDirectory(GuiUtils.getMainFrame(),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),oldSaveFileParent);
  File newSaveParent=saveFile;
  if (newSaveParent != null && new File(newSaveParent,oldSaveFile.getName()).exists()) {
    createOverwriteDialogue(newSaveParent,downLoadAction,ex,supportNewSaveFileName);
    return;
  }
 else   if (saveFile != null) {
    download(downLoadAction,supportNewSaveFileName,saveFile,false);
  }
}","@Override public void actionPerformed(ActionEvent e){
  dialog.dispose();
  File oldSaveFile=overwriteFile;
  File oldSaveFileParent=overwriteFile.getParentFile() != null ? overwriteFile.getParentFile() : overwriteFile;
  File newSaveParent=FileChooser.getInputDirectory(GuiUtils.getMainFrame(),I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),oldSaveFileParent);
  if (newSaveParent != null && new File(newSaveParent,oldSaveFile.getName()).exists()) {
    File saveFile=new File(newSaveParent,oldSaveFile.getName());
    createOverwriteDialogue(saveFile,downLoadAction,ex,supportNewSaveFileName);
    return;
  }
 else   if (newSaveParent != null) {
    File saveFile=new File(newSaveParent,oldSaveFile.getName());
    download(downLoadAction,supportNewSaveFileName,saveFile,false);
  }
}",0.6998011928429424
3816,"/** 
 * Downloads the given file using the supplied download action and handles any possible DownloadExceptions.
 */
private void download(final DownloadAction downLoadAction,final boolean supportNewSaveFileName,File saveFile,boolean overwrite){
  try {
    downLoadAction.download(saveFile,overwrite);
  }
 catch (  DownloadException e1) {
    handleDownloadException(downLoadAction,e1,supportNewSaveFileName);
  }
}","/** 
 * Downloads the given file using the supplied download action and handles any possible DownloadExceptions.
 */
private void download(final DownloadAction downLoadAction,final boolean supportNewSaveFileName,File saveFile,boolean overwrite){
  File newSaveFile=supportNewSaveFileName ? saveFile : saveFile.getParentFile();
  try {
    downLoadAction.download(newSaveFile,overwrite);
  }
 catch (  DownloadException e1) {
    handleDownloadException(downLoadAction,e1,supportNewSaveFileName);
  }
}",0.7995642701525054
3817,"/** 
 * Handles the specified DownloadException. The method may prompt the user for input, and should be executed from the UI thread.
 */
private void handleException(final DownloadAction downLoadAction,final DownloadException e,final boolean supportNewSaveFileName){
  if (e.getErrorCode() == DownloadException.ErrorCode.FILE_ALREADY_DOWNLOADING) {
    downLoadAction.downloadCanceled(e);
    showErrorMessage(e);
    return;
  }
  if ((e.getErrorCode() != DownloadException.ErrorCode.FILE_ALREADY_EXISTS) && (e.getErrorCode() != DownloadException.ErrorCode.FILE_IS_ALREADY_DOWNLOADED_TO)) {
    downLoadAction.downloadCanceled(e);
    showErrorMessage(e);
    return;
  }
  File saveFile=null;
  if (supportNewSaveFileName && SwingUiSettings.AUTO_RENAME_DUPLICATE_FILES.getValue()) {
    saveFile=getAutoSaveFile(e);
  }
 else {
    if (supportNewSaveFileName) {
      saveFile=FileChooser.getSaveAsFile(GuiUtils.getMainFrame(),I18n.tr(""String_Node_Str""),e.getFile());
    }
 else {
      saveFile=e.getFile();
      if (saveFile != null && saveFile.exists()) {
        createOverwriteDialogue(saveFile,downLoadAction,e,supportNewSaveFileName);
        return;
      }
    }
    if (saveFile == null) {
      downLoadAction.downloadCanceled(e);
      return;
    }
  }
  download(downLoadAction,supportNewSaveFileName,saveFile,saveFile.exists());
}","/** 
 * Handles the specified DownloadException. The method may prompt the user for input, and should be executed from the UI thread.
 */
private void handleException(final DownloadAction downLoadAction,final DownloadException e,final boolean supportNewSaveFileName){
  if (e.getErrorCode() == DownloadException.ErrorCode.FILE_ALREADY_DOWNLOADING) {
    downLoadAction.downloadCanceled(e);
    showErrorMessage(e);
    return;
  }
  if ((e.getErrorCode() != DownloadException.ErrorCode.FILE_ALREADY_EXISTS) && (e.getErrorCode() != DownloadException.ErrorCode.FILE_IS_ALREADY_DOWNLOADED_TO)) {
    downLoadAction.downloadCanceled(e);
    showErrorMessage(e);
    return;
  }
 else   if (e.getErrorCode() == DownloadException.ErrorCode.FILE_IS_ALREADY_DOWNLOADED_TO && !supportNewSaveFileName) {
    downLoadAction.downloadCanceled(e);
    showErrorMessage(e);
    return;
  }
  File saveFile=null;
  if (supportNewSaveFileName && SwingUiSettings.AUTO_RENAME_DUPLICATE_FILES.getValue()) {
    saveFile=getAutoSaveFile(e);
  }
 else {
    if (supportNewSaveFileName) {
      saveFile=FileChooser.getSaveAsFile(GuiUtils.getMainFrame(),I18n.tr(""String_Node_Str""),e.getFile());
    }
 else {
      saveFile=e.getFile();
      if (saveFile != null && saveFile.exists()) {
        createOverwriteDialogue(saveFile,downLoadAction,e,supportNewSaveFileName);
        return;
      }
    }
    if (saveFile == null) {
      downLoadAction.downloadCanceled(e);
      return;
    }
  }
  download(downLoadAction,supportNewSaveFileName,saveFile,saveFile.exists());
}",0.9307135470527405
3818,"private void selectTable(AbstractLibraryFormat<LocalFileItem> libraryTableFormat,Category category){
  selectedCategory=category;
  if (category != Category.IMAGE) {
    tableListLayout.show(tableListPanel,TABLE);
    setEventListOnTable(eventList);
    libraryTable.setupCellRenderers(category,libraryTableFormat);
    libraryTable.applySavedColumnSettings();
    TableColumnExt column=libraryTable.getColumnExt(libraryTableFormat.getColumnName(libraryTableFormat.getActionColumn()));
    if (column != null) {
      column.setVisible(libraryNavigatorPanel.getSelectedNavItem().getType() != NavType.LIBRARY);
    }
  }
 else {
    if (libraryImagePanel == null) {
      createImageList();
    }
    tableListLayout.show(tableListPanel,LIST);
    setEventListOnImages(eventList);
    libraryImagePanel.setShowButtons(libraryNavigatorPanel.getSelectedNavItem().getType() != NavType.LIBRARY);
  }
}","private void selectTable(AbstractLibraryFormat<LocalFileItem> libraryTableFormat,Category category){
  selectedCategory=category;
  if (category != Category.IMAGE) {
    setEventListOnTable(eventList);
    libraryTable.setupCellRenderers(category,libraryTableFormat);
    libraryTable.applySavedColumnSettings();
    TableColumnExt column=libraryTable.getColumnExt(libraryTableFormat.getColumnName(libraryTableFormat.getActionColumn()));
    if (column != null) {
      column.setVisible(libraryNavigatorPanel.getSelectedNavItem().getType() != NavType.LIBRARY);
    }
    tableListLayout.show(tableListPanel,TABLE);
  }
 else {
    if (libraryImagePanel == null) {
      createImageList();
    }
    setEventListOnImages(eventList);
    libraryImagePanel.setShowButtons(libraryNavigatorPanel.getSelectedNavItem().getType() != NavType.LIBRARY);
    tableListLayout.show(tableListPanel,LIST);
  }
}",0.8939732142857143
3819,"public void setEventList(EventList<LocalFileItem> eventList,AbstractLibraryFormat<LocalFileItem> tableFormat,boolean playable){
  uninstallListeners();
  fileItemFormat=tableFormat;
  SortedList<LocalFileItem> newSortedList=GlazedListsFactory.sortedList(eventList,null);
  LibraryTableModel newLibraryTableModel=new LibraryTableModel(newSortedList,tableFormat);
  DefaultEventSelectionModel<LocalFileItem> newEventSelectionModel=new DefaultEventSelectionModel<LocalFileItem>(newSortedList);
  FilterList<LocalFileItem> newPlayableList=playable ? createPlayableList(newSortedList) : null;
  if (cachedTableSorting != null) {
    cachedTableSorting.uninstall();
  }
  setModel(newLibraryTableModel);
  setSelectionModel(newEventSelectionModel);
  newEventSelectionModel.setSelectionMode(ListSelection.MULTIPLE_INTERVAL_SELECTION_DEFENSIVE);
  if (cachedPlayableList != null) {
    cachedPlayableList.dispose();
  }
  if (cachedLibraryTableModel != null) {
    cachedEventSelectionModel.dispose();
    cachedLibraryTableModel.dispose();
    cachedSortedList.dispose();
  }
  EventListJXTableSorting newTableSorting=EventListJXTableSorting.install(this,newSortedList,tableFormat);
  cachedSortedList=newSortedList;
  cachedLibraryTableModel=newLibraryTableModel;
  cachedEventSelectionModel=newEventSelectionModel;
  cachedTableSorting=newTableSorting;
  cachedPlayableList=newPlayableList;
  installListeners();
}","public void setEventList(EventList<LocalFileItem> eventList,AbstractLibraryFormat<LocalFileItem> tableFormat,boolean playable){
  uninstallListeners();
  fileItemFormat=tableFormat;
  SortedList<LocalFileItem> newSortedList=GlazedListsFactory.sortedList(eventList,null);
  LibraryTableModel newLibraryTableModel=new LibraryTableModel(newSortedList,tableFormat);
  DefaultEventSelectionModel<LocalFileItem> newEventSelectionModel=new DefaultEventSelectionModel<LocalFileItem>(newSortedList);
  FilterList<LocalFileItem> newPlayableList=playable ? createPlayableList(newSortedList) : null;
  if (cachedTableSorting != null) {
    cachedTableSorting.uninstall();
  }
  setSelectionModel(newEventSelectionModel);
  setModel(newLibraryTableModel);
  newEventSelectionModel.setSelectionMode(ListSelection.MULTIPLE_INTERVAL_SELECTION_DEFENSIVE);
  if (cachedPlayableList != null) {
    cachedPlayableList.dispose();
  }
  if (cachedLibraryTableModel != null) {
    cachedEventSelectionModel.dispose();
    cachedLibraryTableModel.dispose();
    cachedSortedList.dispose();
  }
  EventListJXTableSorting newTableSorting=EventListJXTableSorting.install(this,newSortedList,tableFormat);
  cachedSortedList=newSortedList;
  cachedLibraryTableModel=newLibraryTableModel;
  cachedEventSelectionModel=newEventSelectionModel;
  cachedTableSorting=newTableSorting;
  cachedPlayableList=newPlayableList;
  installListeners();
}",0.975886524822695
3820,"@Override public void actionPerformed(ActionEvent e){
  File currentSong=PlayerUtils.getCurrentSongFile();
  List<LocalFileItem> selected=selectedLocalFileItems.get();
  int confirmation=FocusJOptionPane.showConfirmDialog(null,getMessage(selected),I18n.trn(""String_Node_Str"",""String_Node_Str"",selected.size()),JOptionPane.OK_CANCEL_OPTION);
  if (confirmation == JOptionPane.OK_OPTION) {
    final List<File> toRemove=new ArrayList<File>(selected.size());
    for (    LocalFileItem item : selected) {
      if (item.getFile().equals(currentSong)) {
        PlayerUtils.stop();
      }
      if (!item.isIncomplete()) {
        toRemove.add(item.getFile());
      }
    }
    if (libraryPanel.getSelectedCategory() == Category.IMAGE) {
      libraryImageTable.get().getImageList().setSelectionInterval(-1,-1);
    }
 else {
      libraryTable.getSelectionModel().setSelectionInterval(-1,-1);
    }
    if (!toRemove.isEmpty()) {
      BackgroundExecutorService.execute(new Runnable(){
        @Override public void run(){
          for (          File file : toRemove) {
            libraryManager.getLibraryManagedList().removeFile(file);
          }
        }
      }
);
    }
  }
}","@Override public void actionPerformed(ActionEvent e){
  File currentSong=PlayerUtils.getCurrentSongFile();
  List<LocalFileItem> selected=selectedLocalFileItems.get();
  int confirmation=FocusJOptionPane.showConfirmDialog(null,getMessage(selected),I18n.trn(""String_Node_Str"",""String_Node_Str"",selected.size()),JOptionPane.OK_CANCEL_OPTION);
  if (confirmation == JOptionPane.OK_OPTION) {
    final List<File> toRemove=new ArrayList<File>(selected.size());
    for (    LocalFileItem item : selected) {
      if (item.getFile().equals(currentSong)) {
        PlayerUtils.stop();
      }
      if (!item.isIncomplete()) {
        toRemove.add(item.getFile());
      }
    }
    if (!toRemove.isEmpty()) {
      BackgroundExecutorService.execute(new Runnable(){
        @Override public void run(){
          for (          File file : toRemove) {
            libraryManager.getLibraryManagedList().removeFile(file);
          }
        }
      }
);
    }
  }
}",0.8944911297852475
3821,"@Inject public RemoveFromLibraryAction(@LibrarySelected Provider<List<LocalFileItem>> selectedLocalFileItems,LibraryManager libraryManager,SharedFileListManager sharedFileListManager,LibraryTable libraryTable,Provider<LibraryImageTable> libraryImageTable,LibraryPanel libraryPanel){
  super(I18n.tr(""String_Node_Str""));
  this.selectedLocalFileItems=selectedLocalFileItems;
  this.libraryManager=libraryManager;
  this.sharedFileListManager=sharedFileListManager;
  this.libraryTable=libraryTable;
  this.libraryImageTable=libraryImageTable;
  this.libraryPanel=libraryPanel;
}","@Inject public RemoveFromLibraryAction(@LibrarySelected Provider<List<LocalFileItem>> selectedLocalFileItems,LibraryManager libraryManager,SharedFileListManager sharedFileListManager){
  super(I18n.tr(""String_Node_Str""));
  this.selectedLocalFileItems=selectedLocalFileItems;
  this.libraryManager=libraryManager;
  this.sharedFileListManager=sharedFileListManager;
}",0.777542372881356
3822,"/** 
 * Sets the gain(volume) for the outputline.
 * @param gain [0.0 <-> 1.0]
 * @throws IOException thrown when the soundcard does not support thisoperation
 */
public void setVolume(double fGain){
synchronized (volumeLock) {
    volume=fGain;
    setVolume=true;
  }
}","/** 
 * Sets the gain(volume) for the outputline.
 * @param fGain [0.0 <-> 1.0]
 * @throws IOException thrown when the soundcard does not support thisoperation
 */
public void setVolume(double fGain){
synchronized (volumeLock) {
    volume=fGain;
    setVolume=true;
  }
}",0.994475138121547
3823,"/** 
 * Paints fake rows to fill the viewport.
 */
protected void paintEmptyRows(Graphics g){
  int rowCount=getRowCount();
  Rectangle clip=g.getClipBounds();
  int clipHeight=clip.y + clip.height;
  int tableHeight=getHeight();
  int clipViewableRows=clipHeight / rowHeight;
  int tableViewableRows=tableHeight / rowHeight;
  int startDrawingAt=rowCount * rowHeight;
  if (startDrawingAt < tableHeight) {
    if (clipViewableRows < tableViewableRows) {
      repaint(clip.x,startDrawingAt,clip.width,tableHeight - startDrawingAt);
    }
 else {
      for (int i=rowCount; i <= clipViewableRows; ++i) {
        g.setColor(getColorForRow(i));
        g.fillRect(clip.x,i * rowHeight,clip.width,rowHeight);
        if (getShowHorizontalLines() && i > rowCount) {
          g.setColor(gridColor);
          g.drawLine(clip.x,i * rowHeight,clip.width,i * rowHeight);
        }
      }
      if (getShowVerticalLines()) {
        g.setColor(gridColor);
        TableColumnModel columnModel=getColumnModel();
        int x=0;
        for (int i=0; i < columnModel.getColumnCount(); ++i) {
          TableColumn column=columnModel.getColumn(i);
          x+=column.getWidth();
          g.drawLine(x - 1,rowCount * rowHeight,x - 1,clipHeight);
        }
      }
    }
  }
}","/** 
 * Paints fake rows to fill the viewport.
 */
protected void paintEmptyRows(Graphics g){
  int rowCount=getRowCount();
  Rectangle clip=g.getClipBounds();
  int clipHeight=clip.y + clip.height;
  int tableHeight=getVisibleRect().height;
  int clipViewableRows=clipHeight / rowHeight;
  int tableViewableRows=tableHeight / rowHeight;
  int startDrawingAt=rowCount * rowHeight;
  if (startDrawingAt < tableHeight) {
    if (clipViewableRows < tableViewableRows) {
      repaint(clip.x,startDrawingAt,clip.width,tableHeight - startDrawingAt);
    }
 else {
      for (int i=rowCount; i <= clipViewableRows; ++i) {
        g.setColor(getColorForRow(i));
        g.fillRect(clip.x,i * rowHeight,clip.width,rowHeight);
        if (getShowHorizontalLines() && i > rowCount) {
          g.setColor(gridColor);
          g.drawLine(clip.x,i * rowHeight,clip.width,i * rowHeight);
        }
      }
      if (getShowVerticalLines()) {
        g.setColor(gridColor);
        TableColumnModel columnModel=getColumnModel();
        int x=0;
        for (int i=0; i < columnModel.getColumnCount(); ++i) {
          TableColumn column=columnModel.getColumn(i);
          x+=column.getWidth();
          g.drawLine(x - 1,rowCount * rowHeight,x - 1,clipHeight);
        }
      }
    }
  }
}",0.9890023566378632
3824,"@Override public void setVisible(boolean visible){
  if (frame == null && visible) {
    initContent();
    start();
    resize();
    repaint();
    validate();
  }
 else   if (visible && !isVisible()) {
    restart();
  }
 else   if (contentPanel != null) {
    contentPanel.removeAll();
  }
  super.setVisible(visible);
}","@Override public void setVisible(boolean visible){
  if (frame == null && visible) {
    initContent();
    start();
    resize();
    repaint();
    validate();
  }
 else   if (visible && !isVisible()) {
    restart();
  }
 else   if (!visible && contentPanel != null) {
    contentPanel.removeAll();
  }
  super.setVisible(visible);
}",0.9818181818181818
3825,"@Override public void removeFile(File file){
  if (contains(file)) {
    getCoreCollection().remove(file);
  }
}","@Override public void removeFile(File file){
  getCoreCollection().remove(file);
}",0.845360824742268
3826,"/** 
 * Removes the FD for this file, returning the FD that was removed. This does NOT dispatch a remove event.  It will update the libraryData to signify the file should not be shared, though. The file should be canonicalized already.
 */
private FileDesc removeInternal(File file){
  FileDesc fd;
  rwLock.writeLock().lock();
  try {
    fd=fileToFileDescMap.get(file);
    if (fd != null) {
      removeFileDesc(file,fd);
    }
    Future future=fileToFutures.remove(file);
    if (future != null) {
      future.cancel(true);
    }
  }
  finally {
    rwLock.writeLock().unlock();
  }
  if (fd != null) {
    getLibraryData().removeManagedFile(file);
  }
  return fd;
}","/** 
 * Removes the FD for this file, returning the FD that was removed. This does NOT dispatch a remove event.  It will update the libraryData to signify the file should not be shared, though. The file should be canonicalized already.
 */
private FileDesc removeInternal(File file){
  FileDesc fd;
  boolean cancelled=false;
  rwLock.writeLock().lock();
  try {
    fd=fileToFileDescMap.get(file);
    if (fd != null) {
      removeFileDesc(file,fd);
    }
    Future future=fileToFutures.remove(file);
    if (future != null) {
      cancelled=future.cancel(true);
    }
  }
  finally {
    rwLock.writeLock().unlock();
  }
  if (fd != null) {
    getLibraryData().removeManagedFile(file);
  }
  if (cancelled) {
    broadcastFinished(file);
  }
  return fd;
}",0.9226480836236932
3827,"/** 
 * Actually performs the clear & dispatches an event. Does not save the clear to LibraryFileData. 
 */
private void clearImpl(){
  List<Future> fileFutures;
  rwLock.writeLock().lock();
  try {
    fileFutures=new ArrayList<Future>(fileToFutures.values());
    fileToFutures.clear();
    files.clear();
    urnMap.clear();
    fileToFileDescMap.clear();
  }
  finally {
    rwLock.writeLock().unlock();
  }
  for (  Future future : fileFutures) {
    future.cancel(true);
  }
  dispatch(new FileViewChangeEvent(LibraryImpl.this,FileViewChangeEvent.Type.FILES_CLEARED,true));
}","/** 
 * Actually performs the clear & dispatches an event. Does not save the clear to LibraryFileData. 
 */
private void clearImpl(){
  Map<File,Future> fileFutures;
  rwLock.writeLock().lock();
  try {
    fileFutures=new HashMap<File,Future>(fileToFutures);
    fileToFutures.clear();
    files.clear();
    urnMap.clear();
    fileToFileDescMap.clear();
  }
  finally {
    rwLock.writeLock().unlock();
  }
  for (  Map.Entry<File,Future> entry : fileFutures.entrySet()) {
    if (entry.getValue().cancel(true)) {
      broadcastFinished(entry.getKey());
    }
  }
  dispatch(new FileViewChangeEvent(LibraryImpl.this,FileViewChangeEvent.Type.FILES_CLEARED,true));
}",0.8422738190552442
3828,"/** 
 * Create the FD with or without URNs or XML. Step 1 of loading a filedesc. Then proceed to either step 2 (calculate URNs if none exist) or step 3 (check if dangerous & load XML)
 */
private void startLoadingFileDesc(final File file,Set<URN> urns,final List<? extends LimeXMLDocument> metadata,final FileDesc oldFileDesc,final PendingFuture task){
  final FileDesc fd=createAndAddFileDesc(file,metadata,urns,oldFileDesc,task);
  if (fd != null) {
    if (urns.isEmpty()) {
      ListeningFuture<Set<URN>> urnFuture=urnCache.calculateAndCacheUrns(file);
      setFutureForFile(file,urnFuture);
      LOG.debugf(""String_Node_Str"",file);
      broadcastQueued(file);
      urnFuture.addFutureListener(new EventListener<FutureEvent<Set<URN>>>(){
        @Override public void handleEvent(        FutureEvent<Set<URN>> event){
          LOG.debugf(""String_Node_Str"",file);
          removeFutureForFile(file);
          if (contains(fd)) {
            addUrnsToFileDesc(fd,metadata,event,task,oldFileDesc);
          }
          broadcastFinished(file);
        }
      }
);
    }
 else {
      boolean safe=getLibraryData().isFileSafe(fd.getSHA1Urn().toString());
      boolean loadedXML=!fd.getLimeXMLDocuments().isEmpty();
      boolean allowsXML=xmlController.canConstructXml(fd);
      if (safe && (loadedXML || !allowsXML)) {
        LOG.debugf(""String_Node_Str"",file);
        removeFutureForFile(file);
        task.set(fd);
      }
 else {
        LOG.debugf(""String_Node_Str"",file);
        broadcastQueued(file);
        rwLock.writeLock().lock();
        try {
          LOG.debugf(""String_Node_Str"",fd.getFile());
          setFutureForFile(fd.getFile(),diskIoService.submit(new Runnable(){
            @Override public void run(){
              broadcastProcessing(fd.getFile());
              LOG.debugf(""String_Node_Str"",fd.getFile());
              removeFutureForFile(fd.getFile());
              if (contains(fd)) {
                finishLoadingFileDesc(fd,metadata,task,false,oldFileDesc);
              }
              broadcastFinished(file);
            }
          }
));
        }
  finally {
          rwLock.writeLock().unlock();
        }
      }
    }
  }
 else {
    LOG.debugf(""String_Node_Str"",file);
  }
}","/** 
 * Create the FD with or without URNs or XML. Step 1 of loading a filedesc. Then proceed to either step 2 (calculate URNs if none exist) or step 3 (check if dangerous & load XML)
 */
private void startLoadingFileDesc(final File file,Set<URN> urns,final List<? extends LimeXMLDocument> metadata,final FileDesc oldFileDesc,final PendingFuture task){
  final FileDesc fd=createAndAddFileDesc(file,metadata,urns,oldFileDesc,task);
  if (fd != null) {
    if (urns.isEmpty()) {
      ListeningFuture<Set<URN>> urnFuture=urnCache.calculateAndCacheUrns(file);
      setFutureForFile(file,urnFuture);
      LOG.debugf(""String_Node_Str"",file);
      broadcastQueued(file);
      urnFuture.addFutureListener(new EventListener<FutureEvent<Set<URN>>>(){
        @Override public void handleEvent(        FutureEvent<Set<URN>> event){
          LOG.debugf(""String_Node_Str"",file);
          removeFutureForFile(file);
          if (contains(fd)) {
            addUrnsToFileDesc(fd,metadata,event,task,oldFileDesc);
          }
          if (event.getType() != FutureEvent.Type.CANCELLED) {
            broadcastFinished(file);
          }
        }
      }
);
    }
 else {
      boolean safe=getLibraryData().isFileSafe(fd.getSHA1Urn().toString());
      boolean loadedXML=!fd.getLimeXMLDocuments().isEmpty();
      boolean allowsXML=xmlController.canConstructXml(fd);
      if (safe && (loadedXML || !allowsXML)) {
        LOG.debugf(""String_Node_Str"",file);
        removeFutureForFile(file);
        task.set(fd);
      }
 else {
        LOG.debugf(""String_Node_Str"",file);
        broadcastQueued(file);
        rwLock.writeLock().lock();
        try {
          LOG.debugf(""String_Node_Str"",fd.getFile());
          setFutureForFile(fd.getFile(),diskIoService.submit(new Runnable(){
            @Override public void run(){
              broadcastProcessing(fd.getFile());
              LOG.debugf(""String_Node_Str"",fd.getFile());
              removeFutureForFile(fd.getFile());
              if (contains(fd)) {
                finishLoadingFileDesc(fd,metadata,task,false,oldFileDesc);
              }
              broadcastFinished(file);
            }
          }
));
        }
  finally {
          rwLock.writeLock().unlock();
        }
      }
    }
  }
 else {
    LOG.debugf(""String_Node_Str"",file);
  }
}",0.983080641617227
3829,"/** 
 * Creates a LimeXMLDocument for the given FileDesc if no XML already exists for it.
 */
public LimeXMLDocument createIfNecessary(FileDesc fd){
  LimeXMLDocument doc=null;
synchronized (LOCK) {
    if (!mainMap.containsKey(new FileAndUrn(fd))) {
      File file=fd.getFile();
      if (fd.getLimeXMLDocuments().size() == 0) {
        doc=constructDocument(file);
        if (doc != null) {
          if (LOG.isDebugEnabled())           LOG.debug(""String_Node_Str"" + file + ""String_Node_Str""+ doc);
          addReply(fd,doc);
        }
      }
    }
  }
  return doc;
}","/** 
 * Creates a LimeXMLDocument for the given FileDesc if no XML already exists for it.
 */
public LimeXMLDocument createIfNecessary(FileDesc fd){
  LimeXMLDocument doc=null;
  boolean needsXml=false;
  File file=fd.getFile();
  FileAndUrn fileAndUrn=new FileAndUrn(fd);
synchronized (LOCK) {
    if (!mainMap.containsKey(fileAndUrn)) {
      if (fd.getLimeXMLDocuments().size() == 0) {
        needsXml=true;
      }
    }
  }
  if (needsXml) {
    doc=constructDocument(file);
    if (doc != null) {
synchronized (LOCK) {
        if (!mainMap.containsKey(fileAndUrn)) {
          if (fd.getLimeXMLDocuments().size() == 0) {
            if (LOG.isDebugEnabled())             LOG.debug(""String_Node_Str"" + file + ""String_Node_Str""+ doc);
            addReply(fd,doc);
          }
        }
      }
    }
  }
  return doc;
}",0.7591136526090064
3830,"/** 
 * Adds the SchemaURI to a HashMap with the replyCollection. <p> Warning/Note:If the schemaURI already corresponds to a ReplyCollection this method will replace the old reply collection with the new one.  The old collection will be lost!
 */
public synchronized void add(String schemaURI,LimeXMLReplyCollection replyCollection){
  mapper.put(schemaURI,replyCollection);
}","/** 
 * Adds the SchemaURI to a HashMap with the replyCollection. <p> Warning/Note:If the schemaURI already corresponds to a ReplyCollection this method will replace the old reply collection with the new one.  The old collection will be lost!
 */
public void add(String schemaURI,LimeXMLReplyCollection replyCollection){
  mapper.put(schemaURI,replyCollection);
}",0.9824086603518268
3831,"/** 
 * Loads the map with the LimeXMLDocument for a given FileDesc. If no LimeXMLDocument exists for the FileDesc, one is created for it.
 */
@Override public synchronized boolean loadXml(FileDesc fd){
  Collection<LimeXMLReplyCollection> replies=getCollections();
  boolean loaded=false;
  for (  LimeXMLReplyCollection col : replies) {
    LimeXMLDocument doc=col.createIfNecessary(fd);
    if (doc != null) {
      loaded=true;
    }
  }
  return loaded;
}","/** 
 * Loads the map with the LimeXMLDocument for a given FileDesc. If no LimeXMLDocument exists for the FileDesc, one is created for it.
 */
@Override public boolean loadXml(FileDesc fd){
  Collection<LimeXMLReplyCollection> replies=getCollections();
  boolean loaded=false;
  for (  LimeXMLReplyCollection col : replies) {
    LimeXMLDocument doc=col.createIfNecessary(fd);
    if (doc != null) {
      loaded=true;
    }
  }
  return loaded;
}",0.9856670341786108
3832,"private synchronized void removeFileDesc(FileDesc fd){
  List<LimeXMLDocument> xmlDocs=fd.getLimeXMLDocuments();
  List<String> schemas=new LinkedList<String>();
  for (  LimeXMLDocument doc : xmlDocs)   schemas.add(doc.getSchemaURI());
  for (  String uri : schemas) {
    LimeXMLReplyCollection col=getReplyCollection(uri);
    if (col != null)     col.removeDoc(fd);
  }
}","private void removeFileDesc(FileDesc fd){
  List<LimeXMLDocument> xmlDocs=fd.getLimeXMLDocuments();
  List<String> schemas=new LinkedList<String>();
  for (  LimeXMLDocument doc : xmlDocs)   schemas.add(doc.getSchemaURI());
  for (  String uri : schemas) {
    LimeXMLReplyCollection col=getReplyCollection(uri);
    if (col != null)     col.removeDoc(fd);
  }
}",0.98236092265943
3833,"/** 
 * Serializes the current LimeXMLReplyCollection to disk.
 */
private void save(LibraryStatusEvent event){
  if (event.getLibrary().isLoadFinished()) {
synchronized (this) {
      Collection<LimeXMLReplyCollection> replies=getCollections();
      for (      LimeXMLReplyCollection col : replies)       col.writeMapToDisk();
    }
  }
}","/** 
 * Serializes the current LimeXMLReplyCollection to disk.
 */
private void save(LibraryStatusEvent event){
  if (event.getLibrary().isLoadFinished()) {
    Collection<LimeXMLReplyCollection> replies=getCollections();
    for (    LimeXMLReplyCollection col : replies)     col.writeMapToDisk();
  }
}",0.9440993788819876
3834,"/** 
 * Returns a collection of all available LimeXMLReplyCollections. YOU MUST SYNCHRONIZE ITERATION OVER THE COLLECTION IF IT CAN BE MODIFIED.
 */
public synchronized Collection<LimeXMLReplyCollection> getCollections(){
  return mapper.values();
}","/** 
 * Returns a collection of all available LimeXMLReplyCollections.
 */
public Collection<LimeXMLReplyCollection> getCollections(){
  return mapper.values();
}",0.7883211678832117
3835,"/** 
 * Looks up and returns the <tt>LimeXMLReplyCollection</tt> value for the supplied schemaURI key.
 * @ return the <tt>LimeXMLReplyCollection</tt> for the given schema URI,or <tt>null</tt> if we the requested mapping does not exist
 */
public synchronized LimeXMLReplyCollection getReplyCollection(String schemaURI){
  return mapper.get(schemaURI);
}","/** 
 * Looks up and returns the <tt>LimeXMLReplyCollection</tt> value for the supplied schemaURI key.
 * @ return the <tt>LimeXMLReplyCollection</tt> for the given schema URI,or <tt>null</tt> if we the requested mapping does not exist
 */
public LimeXMLReplyCollection getReplyCollection(String schemaURI){
  return mapper.get(schemaURI);
}",0.981294964028777
3836,"@Override public synchronized boolean loadCachedXml(FileDesc fd,Collection<? extends LimeXMLDocument> prebuilt){
  Collection<LimeXMLReplyCollection> replies=getCollections();
  boolean loaded=false;
  for (  LimeXMLReplyCollection col : replies) {
    LimeXMLDocument doc=col.initialize(fd,prebuilt);
    if (doc != null) {
      loaded=true;
    }
  }
  return loaded;
}","@Override public boolean loadCachedXml(FileDesc fd,Collection<? extends LimeXMLDocument> prebuilt){
  Collection<LimeXMLReplyCollection> replies=getCollections();
  boolean loaded=false;
  for (  LimeXMLReplyCollection col : replies) {
    LimeXMLDocument doc=col.initialize(fd,prebuilt);
    if (doc != null) {
      loaded=true;
    }
  }
  return loaded;
}",0.9822161422708618
3837,"@Inject SchemaReplyCollectionMapper(LimeXMLReplyCollectionFactory limeXMLReplyCollectionFactory,Provider<LimeXMLSchemaRepository> limeXMLSchemaRepository){
  this.limeXMLReplyCollectionFactory=limeXMLReplyCollectionFactory;
  this.limeXMLSchemaRepository=limeXMLSchemaRepository;
  mapper=new HashMap<String,LimeXMLReplyCollection>();
}","@Inject SchemaReplyCollectionMapper(LimeXMLReplyCollectionFactory limeXMLReplyCollectionFactory,Provider<LimeXMLSchemaRepository> limeXMLSchemaRepository){
  this.limeXMLReplyCollectionFactory=limeXMLReplyCollectionFactory;
  this.limeXMLSchemaRepository=limeXMLSchemaRepository;
  mapper=new ConcurrentHashMap<String,LimeXMLReplyCollection>();
}",0.9853372434017597
3838,"/** 
 * Notifies all the LimeXMLReplyCollections that the initial loading has completed.
 */
private synchronized void finishLoading(){
  Collection<LimeXMLReplyCollection> replies=getCollections();
  for (  LimeXMLReplyCollection col : replies)   col.loadFinished();
}","/** 
 * Notifies all the LimeXMLReplyCollections that the initial loading has completed.
 */
private void finishLoading(){
  Collection<LimeXMLReplyCollection> replies=getCollections();
  for (  LimeXMLReplyCollection col : replies)   col.loadFinished();
}",0.9752380952380952
3839,"@Override public void actionPerformed(ActionEvent e){
  File currentSong=PlayerUtils.getCurrentSongFile();
  List<LocalFileItem> items=new ArrayList<LocalFileItem>(selectedLocalFileItems.get());
  for (  LocalFileItem item : items) {
    if (item.getFile().equals(currentSong)) {
      PlayerUtils.stop();
    }
    if (!item.isIncomplete()) {
      libraryManager.getLibraryManagedList().removeFile(item.getFile());
    }
  }
}","@Override public void actionPerformed(ActionEvent e){
  File currentSong=PlayerUtils.getCurrentSongFile();
  List<LocalFileItem> selected=selectedLocalFileItems.get();
  final List<File> toRemove=new ArrayList<File>(selected.size());
  for (  LocalFileItem item : selected) {
    if (item.getFile().equals(currentSong)) {
      PlayerUtils.stop();
    }
    if (!item.isIncomplete()) {
      toRemove.add(item.getFile());
    }
  }
  if (!toRemove.isEmpty()) {
    BackgroundExecutorService.execute(new Runnable(){
      @Override public void run(){
        for (        File file : toRemove) {
          libraryManager.getLibraryManagedList().removeFile(file);
        }
      }
    }
);
  }
}",0.4117647058823529
3840,"/** 
 * Constructs a FilterPanel with the specified filterable data source and UI decorators.
 */
public AdvancedFilterPanel(FilterableSource<E> filterableSource,TextFieldDecorator textFieldDecorator,FriendActions friendManager,Provider<IconManager> iconManager){
  this.filterableSource=filterableSource;
  this.editorList=new BasicEventList<MatcherEditor<E>>();
  this.filterManager=new FilterManager<E>(filterableSource,iconManager);
  if (filterableSource.getFilterDebugger() != null) {
    filterableSource.getFilterDebugger().initialize(filterManager);
  }
  GuiUtils.assignResources(this);
  setBackground(backgroundColor);
  setBorder(new SideLineBorder(borderColor,Side.RIGHT));
  setLayout(new MigLayout(""String_Node_Str""));
  int textFieldWidth=filterWidth - LEFT_INSET - RIGHT_INSET;
  textFieldDecorator.decorateClearablePromptField(filterTextField,AccentType.NONE);
  filterTextField.setMinimumSize(new Dimension(textFieldWidth,filterTextField.getMinimumSize().height));
  filterTextField.setPreferredSize(new Dimension(textFieldWidth,filterTextField.getPreferredSize().height));
  filterDisplayPanel=new FilterDisplayPanel();
  filterPanel.setBackground(backgroundColor);
  filterPanel.setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  upperDividerLine=Line.createHorizontalLine(dividerForegroundColor);
  lowerDividerLine=Line.createHorizontalLine(dividerBackgroundColor);
  filterScrollPane.setBorder(BorderFactory.createEmptyBorder());
  filterScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  filterScrollPane.setViewportView(filterPanel);
  filterScrollPane.getVerticalScrollBar().setUnitIncrement(5);
  filterScrollPane.getVerticalScrollBar().addComponentListener(new ComponentAdapter(){
    @Override public void componentHidden(    ComponentEvent e){
      if (!layoutAdjusting)       doFilterLayout();
    }
    @Override public void componentShown(    ComponentEvent e){
      if (!layoutAdjusting)       doFilterLayout();
    }
  }
);
  propertyPanel=new PropertyFilterPanel();
  categoryFilter=filterManager.getCategoryFilter();
  JComponent categoryComp=categoryFilter.getComponent();
  categoryComp.setVisible(filterableSource.getFilterCategory() == SearchCategory.ALL);
  sourceFilter=filterManager.getSourceFilter();
  JComponent sourceComp=sourceFilter.getComponent();
  sourceComp.setVisible(friendManager.isSignedIn());
  add(filterTextField,""String_Node_Str"");
  add(filterDisplayPanel,""String_Node_Str"");
  add(upperDividerLine,""String_Node_Str"");
  add(lowerDividerLine,""String_Node_Str"");
  add(filterScrollPane,""String_Node_Str"");
  doFilterLayout();
  configureFilters();
}","/** 
 * Constructs a FilterPanel with the specified filterable data source and UI decorators.
 */
public AdvancedFilterPanel(FilterableSource<E> filterableSource,TextFieldDecorator textFieldDecorator,FriendActions friendManager,Provider<IconManager> iconManager){
  this.filterableSource=filterableSource;
  this.editorList=new BasicEventList<MatcherEditor<E>>();
  this.filterManager=new FilterManager<E>(filterableSource,iconManager);
  if (filterableSource.getFilterDebugger() != null) {
    filterableSource.getFilterDebugger().initialize(filterManager);
  }
  GuiUtils.assignResources(this);
  setBackground(background);
  setBorder(new SideLineBorder(borderColor,Side.RIGHT));
  setLayout(new MigLayout(""String_Node_Str""));
  int textFieldWidth=filterWidth - LEFT_INSET - RIGHT_INSET;
  textFieldDecorator.decorateClearablePromptField(filterTextField,AccentType.NONE);
  filterTextField.setMinimumSize(new Dimension(textFieldWidth,filterTextField.getMinimumSize().height));
  filterTextField.setPreferredSize(new Dimension(textFieldWidth,filterTextField.getPreferredSize().height));
  filterDisplayPanel=new FilterDisplayPanel();
  filterPanel.setBackground(background);
  filterPanel.setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  upperDividerLine=Line.createHorizontalLine(dividerForeground);
  lowerDividerLine=Line.createHorizontalLine(dividerBackground);
  filterScrollPane.setBorder(BorderFactory.createEmptyBorder());
  filterScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  filterScrollPane.setViewportView(filterPanel);
  filterScrollPane.getVerticalScrollBar().setUnitIncrement(5);
  filterScrollPane.getVerticalScrollBar().addComponentListener(new ComponentAdapter(){
    @Override public void componentHidden(    ComponentEvent e){
      if (!layoutAdjusting)       doFilterLayout();
    }
    @Override public void componentShown(    ComponentEvent e){
      if (!layoutAdjusting)       doFilterLayout();
    }
  }
);
  propertyPanel=new PropertyFilterPanel();
  categoryFilter=filterManager.getCategoryFilter();
  JComponent categoryComp=categoryFilter.getComponent();
  categoryComp.setVisible(filterableSource.getFilterCategory() == SearchCategory.ALL);
  sourceFilter=filterManager.getSourceFilter();
  JComponent sourceComp=sourceFilter.getComponent();
  sourceComp.setVisible(friendManager.isSignedIn());
  add(filterTextField,""String_Node_Str"");
  add(filterDisplayPanel,""String_Node_Str"");
  add(upperDividerLine,""String_Node_Str"");
  add(lowerDividerLine,""String_Node_Str"");
  add(filterScrollPane,""String_Node_Str"");
  doFilterLayout();
  configureFilters();
}",0.9962532783814164
3841,"@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  Component renderer=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  if (renderer instanceof JLabel) {
    int count=uniqueList.getCount((Category)value);
    StringBuilder buf=new StringBuilder();
    buf.append(value.toString()).append(""String_Node_Str"").append(count).append(""String_Node_Str"");
    ((JLabel)renderer).setText(buf.toString());
    ((JLabel)renderer).setBorder(border);
    ((JLabel)renderer).setOpaque(false);
  }
  return renderer;
}","@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  Component renderer=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  if (renderer instanceof JLabel) {
    int count=uniqueList.getCount((Category)value);
    StringBuilder buf=new StringBuilder();
    buf.append(value.toString()).append(""String_Node_Str"").append(count).append(""String_Node_Str"");
    ((JLabel)renderer).setText(buf.toString());
    ((JLabel)renderer).setBackground(background);
    ((JLabel)renderer).setBorder(border);
  }
  return renderer;
}",0.9541432019308126
3842,"@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  Component renderer=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  if ((renderer instanceof JLabel) && (value != null)) {
    int count=uniqueList.getCount(value);
    StringBuilder buf=new StringBuilder();
    buf.append(value.toString()).append(""String_Node_Str"").append(count).append(""String_Node_Str"");
    ((JLabel)renderer).setText(buf.toString());
    ((JLabel)renderer).setBorder(border);
    ((JLabel)renderer).setOpaque(false);
  }
  return renderer;
}","@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  Component renderer=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  if ((renderer instanceof JLabel) && (value != null)) {
    int count=uniqueList.getCount(value);
    StringBuilder buf=new StringBuilder();
    buf.append(value.toString()).append(""String_Node_Str"").append(count).append(""String_Node_Str"");
    ((JLabel)renderer).setText(buf.toString());
    ((JLabel)renderer).setBackground(background);
    ((JLabel)renderer).setBorder(border);
  }
  return renderer;
}",0.9549407114624506
3843,"public MorePopupPanel(){
  FilterResources resources=getResources();
  setBorder(BorderFactory.createLineBorder(resources.getPopupBorderColor(),2));
  setLayout(new BorderLayout());
  titlePanel.setBackground(resources.getPopupHeaderBackground());
  titlePanel.setBorder(BorderFactory.createEmptyBorder(1,3,1,1));
  titlePanel.setLayout(new BorderLayout());
  titleLabel.setForeground(resources.getPopupHeaderForeground());
  titleLabel.setFont(resources.getPopupHeaderFont());
  titleLabel.setText(I18n.tr(""String_Node_Str"",getPropertyText()));
  closeButton.setBorder(BorderFactory.createEmptyBorder(0,3,3,3));
  closeButton.setContentAreaFilled(false);
  closeButton.setForeground(resources.getPopupHeaderForeground());
  closeButton.setIcon(resources.getPopupCloseIcon());
  closeButton.addMouseListener(new RolloverCursorListener());
  closeButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      hidePopup();
    }
  }
);
  moreList.setCellRenderer(new PropertyCellRenderer(BorderFactory.createEmptyBorder(1,4,0,1)));
  moreList.setFont(resources.getRowFont());
  moreList.setForeground(resources.getRowColor());
  moreList.setOpaque(false);
  moreList.setRolloverEnabled(true);
  moreList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  moreList.setHighlighters(new ColorHighlighter(HighlightPredicate.ROLLOVER_ROW,resources.getHighlightBackground(),resources.getHighlightForeground()));
  moreList.addMouseListener(new RolloverCursorListener());
  EventListModel<Object> listModel=new EventListModel<Object>(uniqueList);
  popupSelectionModel=new EventSelectionModel<Object>(uniqueList);
  moreList.setModel(listModel);
  moreList.setSelectionModel(popupSelectionModel);
  popupSelectionModel.addListSelectionListener(new SelectionListener(popupSelectionModel));
  scrollPane.setBorder(BorderFactory.createEmptyBorder());
  scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  scrollPane.setViewportView(moreList);
  popupMenu.setBorder(BorderFactory.createEmptyBorder());
  popupMenu.setFocusable(false);
  popupMenu.addPopupMenuListener(new PopupMenuListener(){
    @Override public void popupMenuCanceled(    PopupMenuEvent e){
    }
    @Override public void popupMenuWillBecomeInvisible(    PopupMenuEvent e){
      if (popupTriggered) {
        popupReady=false;
      }
 else {
        popupReady=true;
      }
    }
    @Override public void popupMenuWillBecomeVisible(    PopupMenuEvent e){
      popupTriggered=true;
    }
  }
);
  add(titlePanel,BorderLayout.NORTH);
  add(scrollPane,BorderLayout.CENTER);
  titlePanel.add(titleLabel,BorderLayout.CENTER);
  titlePanel.add(closeButton,BorderLayout.EAST);
  popupMenu.add(this);
}","public MorePopupPanel(){
  FilterResources resources=getResources();
  setBorder(BorderFactory.createLineBorder(resources.getPopupBorderColor(),2));
  setLayout(new BorderLayout());
  titlePanel.setBackground(resources.getPopupHeaderBackground());
  titlePanel.setBorder(BorderFactory.createEmptyBorder(1,3,1,1));
  titlePanel.setLayout(new BorderLayout());
  titleLabel.setForeground(resources.getPopupHeaderForeground());
  titleLabel.setFont(resources.getPopupHeaderFont());
  titleLabel.setText(I18n.tr(""String_Node_Str"",getPropertyText()));
  closeButton.setBorder(BorderFactory.createEmptyBorder(0,3,3,3));
  closeButton.setContentAreaFilled(false);
  closeButton.setForeground(resources.getPopupHeaderForeground());
  closeButton.setIcon(resources.getPopupCloseIcon());
  closeButton.addMouseListener(new RolloverCursorListener());
  closeButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      hidePopup();
    }
  }
);
  moreList.setCellRenderer(new PropertyCellRenderer(getBackground(),BorderFactory.createEmptyBorder(1,4,0,1)));
  moreList.setFont(resources.getRowFont());
  moreList.setForeground(resources.getRowColor());
  moreList.setOpaque(false);
  moreList.setRolloverEnabled(true);
  moreList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  moreList.setHighlighters(new ColorHighlighter(HighlightPredicate.ROLLOVER_ROW,resources.getHighlightBackground(),resources.getHighlightForeground()));
  moreList.addMouseListener(new RolloverCursorListener());
  EventListModel<Object> listModel=new EventListModel<Object>(uniqueList);
  popupSelectionModel=new EventSelectionModel<Object>(uniqueList);
  moreList.setModel(listModel);
  moreList.setSelectionModel(popupSelectionModel);
  popupSelectionModel.addListSelectionListener(new SelectionListener(popupSelectionModel));
  scrollPane.setBorder(BorderFactory.createEmptyBorder());
  scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  scrollPane.setViewportView(moreList);
  popupMenu.setBorder(BorderFactory.createEmptyBorder());
  popupMenu.setFocusable(false);
  popupMenu.addPopupMenuListener(new PopupMenuListener(){
    @Override public void popupMenuCanceled(    PopupMenuEvent e){
    }
    @Override public void popupMenuWillBecomeInvisible(    PopupMenuEvent e){
      if (popupTriggered) {
        popupReady=false;
      }
 else {
        popupReady=true;
      }
    }
    @Override public void popupMenuWillBecomeVisible(    PopupMenuEvent e){
      popupTriggered=true;
    }
  }
);
  add(titlePanel,BorderLayout.NORTH);
  add(scrollPane,BorderLayout.CENTER);
  titlePanel.add(titleLabel,BorderLayout.CENTER);
  titlePanel.add(closeButton,BorderLayout.EAST);
  popupMenu.add(this);
}",0.9970951343500364
3844,"public PropertyCellRenderer(Border border){
  this.border=border;
}","public PropertyCellRenderer(Color background,Border border){
  this.background=background;
  this.border=border;
}",0.7403314917127072
3845,"/** 
 * Constructs a PropertyFilter using the specified results list, filter type, property key, and icon manager.
 */
public PropertyFilter(EventList<E> resultsList,FilterType filterType,FilePropertyKey propertyKey,Provider<IconManager> iconManager){
  if ((filterType == FilterType.PROPERTY) && (propertyKey == null)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.filterType=filterType;
  this.propertyKey=propertyKey;
  this.iconManager=iconManager;
  FilterResources resources=getResources();
  panel.setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  panel.setOpaque(false);
  propertyLabel.setFont(resources.getHeaderFont());
  propertyLabel.setForeground(resources.getHeaderColor());
  propertyLabel.setText(getPropertyText());
  list.setCellRenderer(new PropertyCellRenderer(BorderFactory.createEmptyBorder(1,7,0,7)));
  list.setFont(resources.getRowFont());
  list.setForeground(resources.getRowColor());
  list.setOpaque(false);
  list.setRolloverEnabled(true);
  list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  list.setHighlighters(new ColorHighlighter(HighlightPredicate.ROLLOVER_ROW,resources.getHighlightBackground(),resources.getHighlightForeground()));
  list.addMouseListener(new RolloverCursorListener());
  moreButton.setAction(new MoreAction());
  moreButton.setBorder(BorderFactory.createEmptyBorder(0,1,1,1));
  moreButton.setContentAreaFilled(false);
  moreButton.setFocusPainted(false);
  moreButton.setFont(resources.getRowFont());
  moreButton.setHorizontalTextPosition(JButton.LEADING);
  moreButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseEntered(    MouseEvent e){
      if (morePopupPanel != null) {
        morePopupPanel.setPopupTriggered(true);
      }
    }
    @Override public void mouseExited(    MouseEvent e){
      if (morePopupPanel != null) {
        morePopupPanel.setPopupTriggered(false);
      }
    }
  }
);
  initialize(resultsList);
  list.setPrototypeCellValue(""String_Node_Str"");
  int listHeight=3 * list.getFixedCellHeight();
  panel.add(propertyLabel,""String_Node_Str"");
  panel.add(list,""String_Node_Str"" + listHeight + ""String_Node_Str"");
  panel.add(moreButton,""String_Node_Str"");
}","/** 
 * Constructs a PropertyFilter using the specified results list, filter type, property key, and icon manager.
 */
public PropertyFilter(EventList<E> resultsList,FilterType filterType,FilePropertyKey propertyKey,Provider<IconManager> iconManager){
  if ((filterType == FilterType.PROPERTY) && (propertyKey == null)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.filterType=filterType;
  this.propertyKey=propertyKey;
  this.iconManager=iconManager;
  FilterResources resources=getResources();
  panel.setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  panel.setOpaque(false);
  propertyLabel.setFont(resources.getHeaderFont());
  propertyLabel.setForeground(resources.getHeaderColor());
  propertyLabel.setText(getPropertyText());
  list.setCellRenderer(new PropertyCellRenderer(resources.getBackground(),BorderFactory.createEmptyBorder(1,7,0,7)));
  list.setFont(resources.getRowFont());
  list.setForeground(resources.getRowColor());
  list.setOpaque(false);
  list.setRolloverEnabled(true);
  list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  list.setHighlighters(new ColorHighlighter(HighlightPredicate.ROLLOVER_ROW,resources.getHighlightBackground(),resources.getHighlightForeground()));
  list.addMouseListener(new RolloverCursorListener());
  moreButton.setAction(new MoreAction());
  moreButton.setBorder(BorderFactory.createEmptyBorder(0,1,1,1));
  moreButton.setContentAreaFilled(false);
  moreButton.setFocusPainted(false);
  moreButton.setFont(resources.getRowFont());
  moreButton.setHorizontalTextPosition(JButton.LEADING);
  moreButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseEntered(    MouseEvent e){
      if (morePopupPanel != null) {
        morePopupPanel.setPopupTriggered(true);
      }
    }
    @Override public void mouseExited(    MouseEvent e){
      if (morePopupPanel != null) {
        morePopupPanel.setPopupTriggered(false);
      }
    }
  }
);
  initialize(resultsList);
  list.setPrototypeCellValue(""String_Node_Str"");
  int listHeight=3 * list.getFixedCellHeight();
  panel.add(propertyLabel,""String_Node_Str"");
  panel.add(list,""String_Node_Str"" + listHeight + ""String_Node_Str"");
  panel.add(moreButton,""String_Node_Str"");
}",0.994227353463588
3846,"@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  Component renderer=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  if (renderer instanceof JLabel) {
    ((JLabel)renderer).setBorder(border);
    ((JLabel)renderer).setOpaque(false);
  }
  return renderer;
}","@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  Component renderer=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
  if (renderer instanceof JLabel) {
    ((JLabel)renderer).setBackground(background);
    ((JLabel)renderer).setBorder(border);
  }
  return renderer;
}",0.9247027741083224
3847,"@Override public boolean allow(Message m){
  if (m instanceof QueryRequest) {
    QueryRequest q=(QueryRequest)m;
    boolean shouldDrop=false;
    byte[] guid=q.getGUID();
    for (int i=0; i < 4; i++) {
      int slice=ByteUtils.leb2int(guid,i);
      Long key=Long.valueOf((i << 32) + slice);
      Integer count=sliceCounts.get(key);
      if (count == null)       count=0;
      count++;
      sliceTotals[i]++;
      sliceCounts.put(key,count);
      if (sliceTotals[i] >= GUIDS_TO_COUNT && count > sliceTotals[i] * MAX_FRACTION_PER_SLICE && !q.desiresOutOfBandReplies() && q.getMinSpeed() == 0) {
        shouldDrop=true;
      }
    }
    if (shouldDrop) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + q);
      return false;
    }
  }
  return true;
}","@Override public boolean allow(Message m){
  if (m instanceof QueryRequest) {
    QueryRequest q=(QueryRequest)m;
    boolean shouldDrop=false;
    byte[] guid=q.getGUID();
    for (int i=0; i < 4; i++) {
      int slice=ByteUtils.leb2int(guid,i * 4);
      Long key=((long)i << 32) | (slice & 0xFFFFFFFFL);
      Integer count=sliceCounts.get(key);
      if (count == null)       count=0;
      count++;
      sliceTotals[i]++;
      sliceCounts.put(key,count);
      if (sliceTotals[i] >= GUIDS_TO_COUNT && count > sliceTotals[i] * MAX_FRACTION_PER_SLICE && !q.desiresOutOfBandReplies() && q.getMinSpeed() == 0) {
        shouldDrop=true;
      }
    }
    if (shouldDrop) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + q);
      return false;
    }
  }
  return true;
}",0.9657794676806084
3848,"private void shareTorrentFile(BTData btData,File torrentFile){
  if (SharingSettings.SHARE_DOWNLOADED_FILES_IN_NON_SHARED_DIRECTORIES.getValue() && !btData.isPrivate()) {
    final File tFile=getSharedTorrentMetaDataFile(btData);
    fileManager.getGnutellaFileList().remove(tFile);
    File backup=null;
    if (tFile.exists()) {
      backup=new File(tFile.getParent(),tFile.getName().concat(""String_Node_Str""));
      FileUtils.forceRename(tFile,backup);
    }
    if (FileUtils.forceRename(torrentFile,tFile)) {
      fileManager.getGnutellaFileList().add(tFile);
    }
 else {
      if (backup != null) {
        if (FileUtils.forceRename(backup,tFile)) {
          fileManager.getGnutellaFileList().add(tFile);
        }
      }
    }
  }
}","private void shareTorrentFile(BTData btData,File torrentFile){
  if (SharingSettings.SHARE_DOWNLOADED_FILES_IN_NON_SHARED_DIRECTORIES.getValue() && !btData.isPrivate()) {
    final File tFile=getSharedTorrentMetaDataFile(btData);
    fileManager.getGnutellaFileList().remove(tFile);
    File backup=null;
    if (tFile.exists()) {
      backup=new File(tFile.getParent(),tFile.getName().concat(""String_Node_Str""));
      FileUtils.forceRename(tFile,backup);
    }
    if (FileUtils.copy(torrentFile,tFile)) {
      fileManager.getGnutellaFileList().add(tFile);
    }
 else {
      if (backup != null) {
        if (FileUtils.forceRename(backup,tFile)) {
          fileManager.getGnutellaFileList().add(tFile);
        }
      }
    }
  }
}",0.98989898989899
3849,"@Override public boolean requestComplete(HttpUriRequest method,HttpResponse response){
  aborter=null;
  if (downloadStatus == DownloadState.ABORTED) {
    return false;
  }
  InputStream torrentDownloadStream=null;
  FileOutputStream torrentOutputStream=null;
  FileInputStream torrentInputStream=null;
  try {
    if (response.getStatusLine().getStatusCode() < 200 || response.getStatusLine().getStatusCode() >= 300) {
      throw new IOException(""String_Node_Str"" + response.getStatusLine().getStatusCode());
    }
    if (response.getEntity() != null) {
      torrentDownloadStream=response.getEntity().getContent();
      torrentOutputStream=new FileOutputStream(incompleteTorrentFile);
      FileUtils.write(torrentDownloadStream,torrentOutputStream);
      torrentInputStream=new FileInputStream(incompleteTorrentFile);
      torrentOutputStream.close();
      Map<?,?> torrentFileMap=(Map<?,?>)Token.parse(torrentInputStream.getChannel());
      BTData btData=new BTDataImpl(torrentFileMap);
      shareTorrentFile(btData,incompleteTorrentFile);
      downloadStatus=DownloadState.COMPLETE;
      torrentFile=new File(SharingSettings.INCOMPLETE_DIRECTORY.get(),btData.getName() + ""String_Node_Str"");
      if (incompleteTorrentFile.equals(torrentFile)) {
      }
 else       if (torrentFile.exists()) {
        throw new IOException(""String_Node_Str"" + torrentFile.getAbsolutePath());
      }
 else {
        FileUtils.forceRename(incompleteTorrentFile,torrentFile);
      }
    }
 else {
      throw new IOException(""String_Node_Str"");
    }
  }
 catch (  IOException iox) {
    downloadStatus=DownloadState.INVALID;
    if (LOG.isErrorEnabled()) {
      LOG.error(""String_Node_Str"" + torrentURI,iox);
    }
  }
 finally {
    FileUtils.delete(incompleteTorrentFile,false);
    IOUtils.close(torrentInputStream);
    IOUtils.close(torrentDownloadStream);
    IOUtils.close(torrentOutputStream);
    httpExecutor.releaseResources(response);
  }
  eventListenerList.broadcast(new DownloadStateEvent(this,DownloadState.COMPLETE));
  return false;
}","@Override public boolean requestComplete(HttpUriRequest method,HttpResponse response){
  aborter=null;
  if (downloadStatus == DownloadState.ABORTED) {
    return false;
  }
  InputStream torrentDownloadStream=null;
  FileOutputStream torrentOutputStream=null;
  FileInputStream torrentInputStream=null;
  try {
    if (response.getStatusLine().getStatusCode() < 200 || response.getStatusLine().getStatusCode() >= 300) {
      throw new IOException(""String_Node_Str"" + response.getStatusLine().getStatusCode());
    }
    if (response.getEntity() != null) {
      torrentDownloadStream=response.getEntity().getContent();
      torrentOutputStream=new FileOutputStream(incompleteTorrentFile);
      FileUtils.write(torrentDownloadStream,torrentOutputStream);
      torrentInputStream=new FileInputStream(incompleteTorrentFile);
      torrentOutputStream.close();
      Map<?,?> torrentFileMap=(Map<?,?>)Token.parse(torrentInputStream.getChannel());
      BTData btData=new BTDataImpl(torrentFileMap);
      shareTorrentFile(btData,incompleteTorrentFile);
      downloadStatus=DownloadState.COMPLETE;
      torrentFile=new File(SharingSettings.INCOMPLETE_DIRECTORY.get(),btData.getName() + ""String_Node_Str"");
      if (incompleteTorrentFile.equals(torrentFile)) {
      }
 else       if (torrentFile.exists()) {
        throw new IOException(""String_Node_Str"" + torrentFile.getAbsolutePath());
      }
 else {
        FileUtils.forceRename(incompleteTorrentFile,torrentFile);
      }
    }
 else {
      throw new IOException(""String_Node_Str"");
    }
  }
 catch (  IOException iox) {
    downloadStatus=DownloadState.INVALID;
    if (LOG.isErrorEnabled()) {
      LOG.error(""String_Node_Str"" + torrentURI,iox);
    }
  }
 finally {
    FileUtils.delete(incompleteTorrentFile,false);
    IOUtils.close(torrentInputStream);
    IOUtils.close(torrentDownloadStream);
    IOUtils.close(torrentOutputStream);
    httpExecutor.releaseResources(response);
  }
  eventListenerList.broadcast(new DownloadStateEvent(this,downloadStatus));
  return false;
}",0.991219512195122
3850,"/** 
 * Returns true if the specified item matches any of the property values.
 */
@Override public boolean matches(E item){
  if (item == null)   return false;
  if (values.isEmpty())   return true;
switch (filterType) {
case EXTENSION:
    return values.contains(item.getFileExtension().toLowerCase());
case PROPERTY:
  return values.contains(item.getProperty(propertyKey));
case FILE_TYPE:
String type=iconManager.getMIMEDescription(item.getFileExtension());
return values.contains(type);
default :
return false;
}
}","/** 
 * Returns true if the specified item matches any of the property values.
 */
@Override public boolean matches(E item){
  if (item == null)   return false;
  if (values.isEmpty())   return true;
switch (filterType) {
case EXTENSION:
    return values.contains(item.getFileExtension().toLowerCase());
case PROPERTY:
  Object property=item.getProperty(propertyKey);
if (FilePropertyKey.isLong(propertyKey)) {
  return values.contains(property);
}
 else {
  for (  Object value : values) {
    if (Objects.compareToNullIgnoreCase((String)value,(String)property,false) == 0) {
      return true;
    }
  }
  return false;
}
case FILE_TYPE:
String type=iconManager.getMIMEDescription(item.getFileExtension());
return values.contains(type);
default :
return false;
}
}",0.7682737169517885
3851,"Collection<Friend> getKnownFriends(){
  return Collections.unmodifiableCollection(knownFriends.values());
}","public Collection<Friend> getKnownFriends(){
  return Collections.unmodifiableCollection(knownFriends.values());
}",0.9683257918552036
3852,"@Override protected void configure(){
  bind(GuiCallbackImpl.class);
  install(new LimeWireUiUtilModule());
  install(new LimeWireUiSearchModule());
  install(new LimeWireUiNavModule());
  install(new LimeWireUiMainframeModule());
  install(new LimeWireUiTrayModule());
  install(new LimeWireUiFriendsModule());
  install(new LimeWireUiPlayerModule());
  install(new LimeWireUiImagesModule());
  install(new LimeWireUiLibraryModule());
  install(new LimeWireUiLibrarySharingModule());
  install(new LimeWireUiDownloadsModule());
  install(new LimeWireUiOptionsModule());
  install(new LimeWireUiStatusbarModule());
  install(new LimeWireUiPainterModule(isPro));
  install(new LimeWireUiComponentsModule());
  install(new LimeWireUiUploadModule());
  install(new LimeWireUiDockModule());
  install(new LimeWireUiWizardModule());
  install(new LimeWireUiPropertiesModule());
  install(new LimeWireUiBrowserModule());
}","@Override protected void configure(){
  bind(GuiCallbackImpl.class);
  install(new LimeWireUiUtilModule());
  install(new LimeWireUiSearchModule());
  install(new LimeWireUiNavModule());
  install(new LimeWireUiMainframeModule());
  install(new LimeWireUiTrayModule());
  install(new LimeWireUiFriendsModule());
  install(new LimeWireUiPlayerModule());
  install(new LimeWireUiImagesModule());
  install(new LimeWireUiLibraryModule());
  install(new LimeWireUiLibrarySharingModule());
  install(new LimeWireUiDownloadsModule());
  install(new LimeWireUiOptionsModule());
  install(new LimeWireUiStatusbarModule());
  install(new LimeWireUiPainterModule(isPro));
  install(new LimeWireUiComponentsModule());
  install(new LimeWireUiDockModule());
  install(new LimeWireUiWizardModule());
  install(new LimeWireUiPropertiesModule());
  install(new LimeWireUiBrowserModule());
}",0.977107761027359
3853,"public void performAction(final String actionCommmand,final DownloadItem item){
  if (actionCommmand == CANCEL_COMMAND) {
    item.cancel();
  }
 else   if (actionCommmand == PAUSE_COMMAND) {
    item.pause();
  }
 else   if (actionCommmand == RESUME_COMMAND) {
    item.resume();
  }
 else   if (actionCommmand == TRY_AGAIN_COMMAND) {
    item.resume();
  }
 else   if (actionCommmand == LINK_COMMAND) {
  }
 else   if (actionCommmand == PREVIEW_COMMAND || actionCommmand == LAUNCH_COMMAND || actionCommmand == PLAY_COMMAND) {
    if (item.isLaunchable()) {
      DownloadItemUtils.launch(item);
    }
  }
 else   if (actionCommmand == LOCATE_COMMAND) {
    NativeLaunchUtils.launchExplorer(item.getDownloadingFile());
  }
 else   if (actionCommmand == PROPERTIES_COMMAND) {
    if (item.getState() != DownloadState.DONE) {
      propertiesFactory.newProperties().showProperties(item);
    }
 else {
      LocalFileItem localItem=libraryManager.getLibraryManagedList().getFileItem(item.getLaunchableFile());
      if (localItem != null)       localItemFactory.newProperties().showProperties(localItem);
 else       propertiesFactory.newProperties().showProperties(item);
    }
  }
 else   if (actionCommmand == REMOVE_COMMAND) {
    downloadListManager.remove(item);
  }
 else   if (actionCommmand == SHARE_COMMAND) {
    shareWidget.setShareable(item.getDownloadingFile());
    shareWidget.show(null);
  }
 else   if (actionCommmand == LIBRARY_COMMAND) {
    File file=item.getState() == DownloadState.DONE ? item.getLaunchableFile() : item.getDownloadingFile();
    URN urn=item.getUrn();
    Category category=item.getCategory();
    if (file != null) {
      libraryNavigator.selectInLibrary(file,category);
    }
 else     if (urn != null) {
      libraryNavigator.selectInLibrary(urn,category);
    }
  }
}","public void performAction(final String actionCommmand,final DownloadItem item){
  if (actionCommmand == CANCEL_COMMAND) {
    item.cancel();
  }
 else   if (actionCommmand == PAUSE_COMMAND) {
    item.pause();
  }
 else   if (actionCommmand == RESUME_COMMAND) {
    item.resume();
  }
 else   if (actionCommmand == TRY_AGAIN_COMMAND) {
    item.resume();
  }
 else   if (actionCommmand == LINK_COMMAND) {
  }
 else   if (actionCommmand == PREVIEW_COMMAND || actionCommmand == LAUNCH_COMMAND || actionCommmand == PLAY_COMMAND) {
    if (item.isLaunchable()) {
      DownloadItemUtils.launch(item);
    }
  }
 else   if (actionCommmand == LOCATE_COMMAND) {
    NativeLaunchUtils.launchExplorer(item.getDownloadingFile());
  }
 else   if (actionCommmand == PROPERTIES_COMMAND) {
    if (item.getState() != DownloadState.DONE) {
      fileInfoFactory.createFileInfoDialog(item,FileInfoType.DOWNLOADING_FILE);
    }
 else {
      LocalFileItem localItem=libraryManager.getLibraryManagedList().getFileItem(item.getLaunchableFile());
      if (localItem != null)       fileInfoFactory.createFileInfoDialog(localItem,FileInfoType.LOCAL_FILE);
 else       fileInfoFactory.createFileInfoDialog(item,FileInfoType.DOWNLOADING_FILE);
    }
  }
 else   if (actionCommmand == REMOVE_COMMAND) {
    downloadListManager.remove(item);
  }
 else   if (actionCommmand == SHARE_COMMAND) {
    shareWidget.setShareable(item.getDownloadingFile());
    shareWidget.show(null);
  }
 else   if (actionCommmand == LIBRARY_COMMAND) {
    File file=item.getState() == DownloadState.DONE ? item.getLaunchableFile() : item.getDownloadingFile();
    URN urn=item.getUrn();
    Category category=item.getCategory();
    if (file != null) {
      libraryNavigator.selectInLibrary(file,category);
    }
 else     if (urn != null) {
      libraryNavigator.selectInLibrary(urn,category);
    }
  }
}",0.809795918367347
3854,"@Inject public DownloadActionHandler(PropertiesFactory<DownloadItem> propertiesFactory,ShareWidgetFactory shareFactory,DownloadListManager downloadListManager,LibraryNavigator libraryNavigator,PropertiesFactory<LocalFileItem> localItemFactory,LibraryManager libraryManager){
  this.downloadListManager=downloadListManager;
  this.propertiesFactory=propertiesFactory;
  this.shareWidget=shareFactory.createFileShareWidget();
  this.libraryNavigator=libraryNavigator;
  this.localItemFactory=localItemFactory;
  this.libraryManager=libraryManager;
}","@Inject public DownloadActionHandler(ShareWidgetFactory shareFactory,DownloadListManager downloadListManager,LibraryNavigator libraryNavigator,LibraryManager libraryManager,FileInfoDialogFactory fileInfoFactory){
  this.downloadListManager=downloadListManager;
  this.shareWidget=shareFactory.createFileShareWidget();
  this.libraryNavigator=libraryNavigator;
  this.libraryManager=libraryManager;
  this.fileInfoFactory=fileInfoFactory;
}",0.6632860040567952
3855,"@Override protected void configure(){
  bind(DownloadTableFactory.class).toProvider(FactoryProvider.newFactory(DownloadTableFactory.class,DownloadTable.class));
  bind(DownloadActionHandler.class);
  bind(new TypeLiteral<PropertiesFactory<DownloadItem>>(){
  }
).to(DownloadItemPropertiesFactory.class);
}","@Override protected void configure(){
  bind(DownloadTableFactory.class).toProvider(FactoryProvider.newFactory(DownloadTableFactory.class,DownloadTable.class));
  bind(DownloadActionHandler.class);
}",0.7896825396825397
3856,"@Override protected void configure(){
  install(new LimeWireUiLibraryNavModule());
  bind(LibraryTableFactory.class).to(LibraryTableFactoryImpl.class);
  bind(SharingActionFactory.class).to(SharingActionFactoryImpl.class);
  bind(LibraryImageSubPanelFactory.class).to(LibraryImageSubPanelFactoryImpl.class);
  bind(new TypeLiteral<PropertiesFactory<LocalFileItem>>(){
  }
).to(LocalFileItemPropertiesFactory.class);
  bind(new TypeLiteral<PropertiesFactory<RemoteFileItem>>(){
  }
).to(RemoteFileItemPropertiesFactory.class);
  bind(ShareTableRendererEditorFactory.class).toProvider(FactoryProvider.newFactory(ShareTableRendererEditorFactory.class,ShareTableRendererEditor.class));
}","@Override protected void configure(){
  install(new LimeWireUiLibraryNavModule());
  bind(LibraryTableFactory.class).to(LibraryTableFactoryImpl.class);
  bind(SharingActionFactory.class).to(SharingActionFactoryImpl.class);
  bind(LibraryImageSubPanelFactory.class).to(LibraryImageSubPanelFactoryImpl.class);
  bind(ShareTableRendererEditorFactory.class).toProvider(FactoryProvider.newFactory(ShareTableRendererEditorFactory.class,ShareTableRendererEditor.class));
  bind(MyLibraryPopupMenuFactory.class).toProvider(FactoryProvider.newFactory(MyLibraryPopupMenuFactory.class,MyLibraryPopupMenu.class));
}",0.7231726283048211
3857,"/** 
 * Attempts to generate an advanced search based on   {@link SearchInfo} from a  {@link SearchCategory} and encoded composite query string. 
 * @return null if the query could not be parsed otherwise the corresponding {@link SearchInfo}.
 */
public SearchInfo attemptToCreateAdvancedSearch(String query,SearchCategory searchCategory){
  String translatedKeySeparator=getTranslatedKeySeprator();
  String lowerCaseUntranslatedQuery=translator.toLowerCaseEnglish(query);
  String lowerCaseTranslatedQuery=translator.toLowerCaseCurrentLocale(query);
  if (query.indexOf(translatedKeySeparator) > -1) {
    Map<FilePropertyKey,String> map=new HashMap<FilePropertyKey,String>();
    List<KeyPacket> foundKeys=new SortedList<KeyPacket>();
    for (    FilePropertyKey candidateKey : FilePropertyKey.values()) {
      String untranslatedKeyName=FilePropertyKeyUtils.getUntraslatedDisplayName(candidateKey,searchCategory);
      KeyPacket keyPacket=attemptToFindKey(candidateKey,translator.toLowerCaseEnglish(untranslatedKeyName),UNTRANSLATED_SEPARATOR,lowerCaseUntranslatedQuery);
      if (keyPacket != null) {
        foundKeys.add(keyPacket);
        continue;
      }
      if (translator.isCurrentLanguageEnglish()) {
        continue;
      }
      keyPacket=attemptToFindKey(candidateKey,translator.toLowerCaseCurrentLocale(translator.translate(untranslatedKeyName)),translatedKeySeparator,lowerCaseTranslatedQuery);
      if (keyPacket != null) {
        foundKeys.add(keyPacket);
      }
    }
    if (foundKeys.size() == 0) {
      return null;
    }
    if (CHECK_FORMAT) {
      if (query.substring(0,foundKeys.get(0).getStartIndex()).trim().length() > 0) {
        return null;
      }
    }
    for (int i=0; i < foundKeys.size() - 1; i++) {
      attemptToParseValue(query,map,foundKeys.get(i),foundKeys.get(i + 1).startIndex);
    }
    KeyPacket currentPacket=foundKeys.get(foundKeys.size() - 1);
    if (currentPacket.getEndIndex() != query.length()) {
      attemptToParseValue(query,map,currentPacket,query.length());
    }
 else {
      KeyPacket secondLastPacket=foundKeys.get(foundKeys.size() - 2);
      map.remove(secondLastPacket);
      attemptToParseValue(query,map,secondLastPacket,query.length());
    }
    if (map.size() == 0) {
      return null;
    }
    return createAdvancedSearch(map,searchCategory);
  }
  return null;
}","/** 
 * Attempts to generate an advanced search based on   {@link SearchInfo} from a  {@link SearchCategory} and encoded composite query string. 
 * @return null if the query could not be parsed otherwise the corresponding {@link SearchInfo}.
 */
public SearchInfo attemptToCreateAdvancedSearch(String query,SearchCategory searchCategory){
  if (searchCategory == SearchCategory.ALL) {
    return null;
  }
  String translatedKeySeparator=getTranslatedKeySeprator();
  String untranslatedKeySeparator=UNTRANSLATED_SEPARATOR;
  String lowerCaseUntranslatedQuery=translator.toLowerCaseEnglish(query);
  String lowerCaseTranslatedQuery=translator.toLowerCaseCurrentLocale(query);
  if (query.indexOf(translatedKeySeparator) > -1 || query.indexOf(untranslatedKeySeparator) > -1) {
    Map<FilePropertyKey,String> map=new HashMap<FilePropertyKey,String>();
    List<KeyPacket> foundKeys=new SortedList<KeyPacket>();
    for (    FilePropertyKey candidateKey : FilePropertyKey.values()) {
      String untranslatedKeyName=FilePropertyKeyUtils.getUntraslatedDisplayName(candidateKey,searchCategory);
      KeyPacket keyPacket=attemptToFindKey(candidateKey,translator.toLowerCaseEnglish(untranslatedKeyName),untranslatedKeySeparator,lowerCaseUntranslatedQuery);
      if (keyPacket != null) {
        foundKeys.add(keyPacket);
        continue;
      }
      if (translator.isCurrentLanguageEnglish()) {
        continue;
      }
      keyPacket=attemptToFindKey(candidateKey,translator.toLowerCaseCurrentLocale(translator.translate(untranslatedKeyName)),translatedKeySeparator,lowerCaseTranslatedQuery);
      if (keyPacket != null) {
        foundKeys.add(keyPacket);
      }
    }
    if (foundKeys.size() == 0) {
      return null;
    }
    if (CHECK_FORMAT) {
      if (query.substring(0,foundKeys.get(0).getStartIndex()).trim().length() > 0) {
        return null;
      }
    }
    for (int i=0; i < foundKeys.size() - 1; i++) {
      attemptToParseValue(query,map,foundKeys.get(i),foundKeys.get(i + 1).startIndex);
    }
    KeyPacket currentPacket=foundKeys.get(foundKeys.size() - 1);
    if (currentPacket.getEndIndex() != query.length()) {
      attemptToParseValue(query,map,currentPacket,query.length());
    }
 else {
      KeyPacket secondLastPacket=foundKeys.get(foundKeys.size() - 2);
      map.remove(secondLastPacket);
      attemptToParseValue(query,map,secondLastPacket,query.length());
    }
    if (map.size() == 0) {
      return null;
    }
    return createAdvancedSearch(map,searchCategory);
  }
  return null;
}",0.6909388422990387
3858,"public LibrarySharePanel(ThreadSafeList<SharingTarget> allFriends,ShapeDialog dialog,FriendActions xmppService,boolean canShowP2P,boolean shareVisible){
  this.dialog=dialog;
  this.friendActions=xmppService;
  this.canShowP2P=canShowP2P;
  this.shareVisible=shareVisible;
  setFocusPainted(false);
  initialize(allFriends);
}","public LibrarySharePanel(ThreadSafeList<SharingTarget> allFriends,ShapeDialog dialog,FriendActions xmppService,boolean canShowP2P,boolean shareVisible){
  this.dialog=dialog;
  this.friendActions=xmppService;
  this.canShowP2P=canShowP2P;
  this.shareVisible=shareVisible;
  setFocusPainted(false);
  setBorderPainted(false);
  initialize(allFriends);
}",0.9602356406480118
3859,"public String getPath(){
  return path;
}","/** 
 * Returns the path to the file relative to the root  directory of the torrent in unix form. This form work for appending the path to urls. path/to/file instead of path\to\file
 */
public String getPath(){
  return path;
}",0.3059701492537313
3860,"/** 
 * Parses a list of paths into a single string, adding the intermediate folders into the Set of folders.  The paths are parsed either as UTF or ASCII.
 */
private String parseFileList(List<?> paths,Set<String> folders,boolean utf8) throws ValueException {
  if (paths.isEmpty())   throw new ValueException(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  for (Iterator<?> i=paths.iterator(); i.hasNext(); ) {
    Object o=i.next();
    if (!(o instanceof byte[]))     throw new ValueException(""String_Node_Str"");
    String current;
    if (utf8)     current=StringUtils.getUTF8String((byte[])o);
 else     current=StringUtils.getASCIIString((byte[])o);
    if (current.length() == 0)     throw new ValueException(""String_Node_Str"");
    sb.append(File.separator);
    sb.append(CommonUtils.convertFileName(current));
    if (i.hasNext())     folders.add(sb.toString());
  }
  return sb.toString();
}","/** 
 * Parses a list of paths into a single string, adding the intermediate folders into the Set of folders.  The paths are parsed either as UTF or ASCII.
 */
private String parseFileList(List<?> paths,Set<String> folders,boolean utf8) throws ValueException {
  if (paths.isEmpty())   throw new ValueException(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  for (Iterator<?> i=paths.iterator(); i.hasNext(); ) {
    Object o=i.next();
    if (!(o instanceof byte[]))     throw new ValueException(""String_Node_Str"");
    String current;
    if (utf8)     current=StringUtils.getUTF8String((byte[])o);
 else     current=StringUtils.getASCIIString((byte[])o);
    if (current.length() == 0)     throw new ValueException(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(CommonUtils.convertFileName(current));
    if (i.hasNext())     folders.add(sb.toString());
  }
  return sb.toString();
}",0.9831430125067973
3861,"/** 
 * Tests the edge functionality of the can resolve case.  First resolve but with a  non connectable address.  Next force fire an IOE event to the then non relevant resolve handler and make sure things are handled accordingly. <p> Tests tryToResolveAndBrowse() and handleFailedResolution().
 */
public void testBrowseWhenCanResolveButCantConnectPlusIOE(){
  final Mockery context=new Mockery(){
{
      setImposteriser(ClassImposteriser.INSTANCE);
    }
  }
;
  final SocketsManager socketsManager=context.mock(SocketsManager.class);
  final PresenceLibrary presenceLibrary=context.mock(PresenceLibrary.class);
  final Address resolvedAddress=context.mock(Address.class);
  final PresenceLibraryBrowser presenceLibraryBrowser=new PresenceLibraryBrowser(null,null,socketsManager,null);
  final MatchAndCopy<AddressResolutionObserver> observerCollector=new MatchAndCopy<AddressResolutionObserver>(AddressResolutionObserver.class);
  context.checking(new Expectations(){
{
      FriendPresence presence=context.mock(FriendPresence.class);
      allowing(presenceLibrary).getPresence();
      will(returnValue(presence));
      allowing(presence).hasFeatures(AddressFeature.ID);
      will(returnValue(false));
      AddressFeature addressFeature=context.mock(AddressFeature.class);
      allowing(presence).getFeature(AddressFeature.ID);
      will(returnValue(addressFeature));
      Address address=context.mock(Address.class);
      allowing(addressFeature).getFeature();
      will(returnValue(address));
      allowing(socketsManager).canResolve(address);
      will(returnValue(true));
      allowing(socketsManager).canConnect(resolvedAddress);
      will(returnValue(false));
      allowing(presenceLibrary);
      allowing(presence);
      exactly(1).of(socketsManager).resolve(with(same(address)),with(observerCollector));
    }
  }
);
  presenceLibraryBrowser.tryToResolveAndBrowse(presenceLibrary,0);
  observerCollector.getLastMatch().resolved(resolvedAddress);
  assertContains(presenceLibraryBrowser.librariesToBrowse,presenceLibrary);
  observerCollector.getLastMatch().handleIOException(new IOException(""String_Node_Str""));
  assertContains(presenceLibraryBrowser.librariesToBrowse,presenceLibrary);
  observerCollector.getLastMatch().shutdown();
  context.assertIsSatisfied();
}","/** 
 * Tests the edge functionality of the can resolve case.  First resolve but with a  non connectable address.  Next force fire an IOE event to the then non relevant resolve handler and make sure things are handled accordingly. <p> Tests tryToResolveAndBrowse() and handleFailedResolution().
 */
public void testBrowseWhenCanResolveButCantConnectPlusIOE(){
  final Mockery context=new Mockery(){
{
      setImposteriser(ClassImposteriser.INSTANCE);
    }
  }
;
  final SocketsManager socketsManager=context.mock(SocketsManager.class);
  final PresenceLibrary presenceLibrary=context.mock(PresenceLibrary.class);
  final Address resolvedAddress=context.mock(Address.class);
  final PresenceLibraryBrowser presenceLibraryBrowser=new PresenceLibraryBrowser(null,null,socketsManager,null);
  final MatchAndCopy<AddressResolutionObserver> observerCollector=new MatchAndCopy<AddressResolutionObserver>(AddressResolutionObserver.class);
  context.checking(new Expectations(){
{
      FriendPresence presence=context.mock(FriendPresence.class);
      allowing(presenceLibrary).getPresence();
      will(returnValue(presence));
      allowing(presence).hasFeatures(AddressFeature.ID);
      will(returnValue(false));
      AddressFeature addressFeature=context.mock(AddressFeature.class);
      allowing(presence).getFeature(AddressFeature.ID);
      will(returnValue(addressFeature));
      Address address=context.mock(Address.class);
      allowing(addressFeature).getFeature();
      will(returnValue(address));
      allowing(socketsManager).canResolve(address);
      will(returnValue(true));
      allowing(socketsManager).canConnect(resolvedAddress);
      will(returnValue(false));
      allowing(presenceLibrary);
      allowing(presence);
      exactly(1).of(socketsManager).resolve(with(same(address)),with(observerCollector));
    }
  }
);
  presenceLibraryBrowser.tryToResolveAndBrowse(presenceLibrary,0);
  observerCollector.getLastMatch().resolved(resolvedAddress);
  assertContains(presenceLibraryBrowser.librariesToBrowse,presenceLibrary);
  presenceLibraryBrowser.librariesToBrowse.remove(presenceLibrary);
  observerCollector.getLastMatch().handleIOException(new IOException(""String_Node_Str""));
  assertContains(presenceLibraryBrowser.librariesToBrowse,presenceLibrary);
  observerCollector.getLastMatch().shutdown();
  context.assertIsSatisfied();
}",0.9854139854139854
3862,"/** 
 * Determines whether or not we need more hosts.
 */
private boolean needsHosts(long now){
  if (!listener.needsHosts()) {
    LOG.trace(""String_Node_Str"");
    return true;
  }
  long delay=now - firstBootstrapCheck;
  if (!connectionServices.isConnected() && delay > ConnectionSettings.BOOTSTRAP_DELAY.getValue()) {
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + delay + ""String_Node_Str"");
    return true;
  }
  LOG.trace(""String_Node_Str"");
  return false;
}","/** 
 * Determines whether or not we need more hosts.
 */
private boolean needsHosts(long now){
  if (listener.needsHosts()) {
    LOG.trace(""String_Node_Str"");
    return true;
  }
  long delay=now - firstBootstrapCheck;
  if (!connectionServices.isConnected() && delay > ConnectionSettings.BOOTSTRAP_DELAY.getValue()) {
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + delay + ""String_Node_Str"");
    return true;
  }
  LOG.trace(""String_Node_Str"");
  return false;
}",0.998968008255934
3863,"/** 
 * Attempts to fetch via multicast, returning true if it was able to.
 */
private boolean multicastFetch(long now){
  if (nextAllowedMulticastTime < now && !ConnectionSettings.DO_NOT_MULTICAST_BOOTSTRAP.getValue()) {
    LOG.trace(""String_Node_Str"");
    PingRequest pr=pingRequestFactory.createMulticastPing();
    multicastService.get().send(pr);
    nextAllowedMulticastTime=now + MULTICAST_INTERVAL;
    if (nextAllowedUdpTime == Long.MAX_VALUE)     nextAllowedUdpTime=now + UDP_FALLBACK_DELAY;
    return true;
  }
  if (nextAllowedUdpTime == Long.MAX_VALUE && ConnectionSettings.DO_NOT_MULTICAST_BOOTSTRAP.getValue())   nextAllowedUdpTime=now + UDP_FALLBACK_DELAY;
  LOG.trace(""String_Node_Str"");
  return false;
}","/** 
 * Attempts to fetch via multicast, returning true if it was able to.
 */
private boolean multicastFetch(long now){
  if (nextAllowedMulticastTime < now && !ConnectionSettings.DO_NOT_MULTICAST_BOOTSTRAP.getValue()) {
    LOG.trace(""String_Node_Str"");
    PingRequest pr=pingRequestFactory.createMulticastPing();
    multicastService.get().send(pr);
    nextAllowedMulticastTime=now + MULTICAST_INTERVAL;
    if (nextAllowedUdpTime == Long.MAX_VALUE)     nextAllowedUdpTime=now + UDP_FALLBACK_DELAY;
    return true;
  }
  if (nextAllowedUdpTime == Long.MAX_VALUE && ConnectionSettings.DO_NOT_MULTICAST_BOOTSTRAP.getValue())   nextAllowedUdpTime=0;
  LOG.trace(""String_Node_Str"");
  return false;
}",0.9824807288016818
3864,"private void initializePainters(){
  setBackgroundPainter(new Painter(){
    @Override public void paint(    Graphics2D g,    Object object,    int width,    int height){
      Shape mainPanelShape=getShape();
      Area panelArea=new Area(mainPanelShape);
      Point bottomLocation=SwingUtilities.convertPoint(mainPanel,bottomPanel.getLocation(),LibrarySharePanel.this);
      Area bottomArea=new Area(new Rectangle2D.Float(0,bottomLocation.y,getWidth(),1000));
      bottomArea.intersect(panelArea);
      Graphics2D g2=(Graphics2D)g.create();
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
      g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_SPEED);
      g2.setColor(Color.WHITE);
      g2.fill(panelArea);
      if (bottomPanel.isVisible()) {
        bottomGradient=new GradientPaint(0,bottomLocation.y,bottomPanelTopGradient,0,bottomLocation.y + bottomPanel.getHeight(),bottomPanelBottomGradient);
        g2.setPaint(bottomGradient);
        g2.fill(bottomArea);
        g2.setColor(dividerColor);
        Rectangle panelBounds=mainPanelShape.getBounds();
        g2.drawLine(panelBounds.x,bottomLocation.y,panelBounds.x + panelBounds.width,bottomLocation.y);
      }
      if (signInPanel.isVisible()) {
        g2.setColor(dividerColor);
        Rectangle panelBounds=mainPanelShape.getBounds();
        Point signInLocation=SwingUtilities.convertPoint(mainPanel,signInPanel.getLocation(),LibrarySharePanel.this);
        g2.drawLine(panelBounds.x,signInLocation.y,panelBounds.x + panelBounds.width,signInLocation.y);
      }
      g2.setColor(borderColor);
      g2.setStroke(new BasicStroke(2));
      g2.draw(mainPanelShape);
      g2.setStroke(new BasicStroke(1));
      g2.draw(mainPanelShape);
      g2.translate(1,1);
      g2.draw(mainPanelShape);
      g2.dispose();
    }
  }
);
}","private void initializePainters(){
  setBackgroundPainter(new Painter(){
    @Override public void paint(    Graphics2D g,    Object object,    int width,    int height){
      Shape mainPanelShape=getShape();
      Area panelArea=new Area(mainPanelShape);
      Point bottomLocation=SwingUtilities.convertPoint(mainPanel,bottomPanel.getLocation(),LibrarySharePanel.this);
      Area bottomArea=new Area(new Rectangle2D.Float(0,bottomLocation.y,getWidth(),1000));
      bottomArea.intersect(panelArea);
      Graphics2D g2=(Graphics2D)g.create();
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
      g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_SPEED);
      g2.setColor(Color.WHITE);
      g2.fill(panelArea);
      if (bottomPanel.isVisible()) {
        bottomGradient=new GradientPaint(0,bottomLocation.y,bottomPanelTopGradient,0,bottomLocation.y + bottomPanel.getHeight(),bottomPanelBottomGradient);
        g2.setPaint(bottomGradient);
        g2.fill(bottomArea);
        g2.setColor(dividerColor);
        Rectangle panelBounds=mainPanelShape.getBounds();
        g2.drawLine(panelBounds.x,bottomLocation.y,panelBounds.x + panelBounds.width,bottomLocation.y);
      }
      if (signInPanel.isVisible()) {
        g2.setColor(dividerColor);
        Rectangle panelBounds=mainPanelShape.getBounds();
        Point signInLocation=SwingUtilities.convertPoint(mainPanel,signInPanel.getLocation(),LibrarySharePanel.this);
        g2.drawLine(panelBounds.x,signInLocation.y,panelBounds.x + panelBounds.width,signInLocation.y);
      }
      g2.setColor(borderColor);
      g2.setStroke(new BasicStroke(2));
      Shape originalClip=g2.getClip();
      g2.setClip(originalClip.getBounds().x,originalClip.getBounds().y,10,10);
      g2.draw(mainPanelShape);
      g2.setClip(originalClip);
      g2.setStroke(new BasicStroke(1));
      g2.draw(mainPanelShape);
      g2.translate(1,1);
      g2.draw(mainPanelShape);
      g2.dispose();
    }
  }
);
}",0.9615975422427036
3865,"@Override public void paint(Graphics2D g,Object object,int width,int height){
  Shape mainPanelShape=getShape();
  Area panelArea=new Area(mainPanelShape);
  Point bottomLocation=SwingUtilities.convertPoint(mainPanel,bottomPanel.getLocation(),LibrarySharePanel.this);
  Area bottomArea=new Area(new Rectangle2D.Float(0,bottomLocation.y,getWidth(),1000));
  bottomArea.intersect(panelArea);
  Graphics2D g2=(Graphics2D)g.create();
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_SPEED);
  g2.setColor(Color.WHITE);
  g2.fill(panelArea);
  if (bottomPanel.isVisible()) {
    bottomGradient=new GradientPaint(0,bottomLocation.y,bottomPanelTopGradient,0,bottomLocation.y + bottomPanel.getHeight(),bottomPanelBottomGradient);
    g2.setPaint(bottomGradient);
    g2.fill(bottomArea);
    g2.setColor(dividerColor);
    Rectangle panelBounds=mainPanelShape.getBounds();
    g2.drawLine(panelBounds.x,bottomLocation.y,panelBounds.x + panelBounds.width,bottomLocation.y);
  }
  if (signInPanel.isVisible()) {
    g2.setColor(dividerColor);
    Rectangle panelBounds=mainPanelShape.getBounds();
    Point signInLocation=SwingUtilities.convertPoint(mainPanel,signInPanel.getLocation(),LibrarySharePanel.this);
    g2.drawLine(panelBounds.x,signInLocation.y,panelBounds.x + panelBounds.width,signInLocation.y);
  }
  g2.setColor(borderColor);
  g2.setStroke(new BasicStroke(2));
  g2.draw(mainPanelShape);
  g2.setStroke(new BasicStroke(1));
  g2.draw(mainPanelShape);
  g2.translate(1,1);
  g2.draw(mainPanelShape);
  g2.dispose();
}","@Override public void paint(Graphics2D g,Object object,int width,int height){
  Shape mainPanelShape=getShape();
  Area panelArea=new Area(mainPanelShape);
  Point bottomLocation=SwingUtilities.convertPoint(mainPanel,bottomPanel.getLocation(),LibrarySharePanel.this);
  Area bottomArea=new Area(new Rectangle2D.Float(0,bottomLocation.y,getWidth(),1000));
  bottomArea.intersect(panelArea);
  Graphics2D g2=(Graphics2D)g.create();
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_SPEED);
  g2.setColor(Color.WHITE);
  g2.fill(panelArea);
  if (bottomPanel.isVisible()) {
    bottomGradient=new GradientPaint(0,bottomLocation.y,bottomPanelTopGradient,0,bottomLocation.y + bottomPanel.getHeight(),bottomPanelBottomGradient);
    g2.setPaint(bottomGradient);
    g2.fill(bottomArea);
    g2.setColor(dividerColor);
    Rectangle panelBounds=mainPanelShape.getBounds();
    g2.drawLine(panelBounds.x,bottomLocation.y,panelBounds.x + panelBounds.width,bottomLocation.y);
  }
  if (signInPanel.isVisible()) {
    g2.setColor(dividerColor);
    Rectangle panelBounds=mainPanelShape.getBounds();
    Point signInLocation=SwingUtilities.convertPoint(mainPanel,signInPanel.getLocation(),LibrarySharePanel.this);
    g2.drawLine(panelBounds.x,signInLocation.y,panelBounds.x + panelBounds.width,signInLocation.y);
  }
  g2.setColor(borderColor);
  g2.setStroke(new BasicStroke(2));
  Shape originalClip=g2.getClip();
  g2.setClip(originalClip.getBounds().x,originalClip.getBounds().y,10,10);
  g2.draw(mainPanelShape);
  g2.setClip(originalClip);
  g2.setStroke(new BasicStroke(1));
  g2.draw(mainPanelShape);
  g2.translate(1,1);
  g2.draw(mainPanelShape);
  g2.dispose();
}",0.9597197898423818
3866,"/** 
 * Increments the   {@link PresenceLibraryBrowser#latestConnectivityEventRevision}copies and empties   {@link PresenceLibraryBrowser#librariesToBrowse} andtries calls  {@link PresenceLibraryBrowser#tryToResolveAndBrowse(PresenceLibrary,int)}for each with the new revision.
 */
@Override public void handleEvent(ConnectivityChangeEvent event){
  LOG.debug(""String_Node_Str"");
  List<PresenceLibrary> copy;
  int currentRevision;
synchronized (librariesToBrowse) {
    currentRevision=++latestConnectivityEventRevision;
    copy=new ArrayList<PresenceLibrary>(librariesToBrowse);
    librariesToBrowse.clear();
  }
  for (  PresenceLibrary library : copy) {
    tryToResolveAndBrowse(library,currentRevision);
  }
}","/** 
 * Increments the   {@link PresenceLibraryBrowser#latestConnectivityEventRevision}copies and empties   {@link PresenceLibraryBrowser#librariesToBrowse} andtries calls  {@link PresenceLibraryBrowser#tryToResolveAndBrowse(PresenceLibrary,int)}for each with the new revision.
 */
@Override public void handleEvent(ConnectivityChangeEvent event){
  LOG.debug(""String_Node_Str"");
  List<PresenceLibrary> copy;
  int currentRevision;
synchronized (librariesToBrowse) {
    currentRevision=++latestConnectivityEventRevision;
    copy=new ArrayList<PresenceLibrary>(librariesToBrowse);
    LOG.debugf(""String_Node_Str"",currentRevision,copy);
    librariesToBrowse.clear();
  }
  for (  PresenceLibrary library : copy) {
    tryToResolveAndBrowse(library,currentRevision);
  }
}",0.9624664879356568
3867,"/** 
 * Called when resolution failed. If   {@link #latestConnectivityEventRevision} is greater then <code>startRevision</code>,a new attempt at resolving the presence address is started, otherwise <code>presenceLibrary</code> is queued up in libraries to browse.
 * @param presenceLibrary the library that could not be browsed
 * @param startRevision the revision under which the address resolution attemptwas started
 */
private void handleFailedResolution(PresenceLibrary presenceLibrary,int startRevision){
  LOG.debugf(""String_Node_Str"",presenceLibrary.getPresence().getPresenceId(),startRevision);
  presenceLibrary.setState(LibraryState.FAILED_TO_LOAD);
  boolean retry;
synchronized (librariesToBrowse) {
    retry=latestConnectivityEventRevision > startRevision;
    if (!retry) {
      assert(librariesToBrowse.add(presenceLibrary));
    }
 else {
      startRevision=latestConnectivityEventRevision;
    }
  }
  if (retry) {
    tryToResolveAndBrowse(presenceLibrary,startRevision);
  }
}","/** 
 * Called when resolution failed. If   {@link #latestConnectivityEventRevision} is greater then <code>startRevision</code>,a new attempt at resolving the presence address is started, otherwise <code>presenceLibrary</code> is queued up in libraries to browse.
 * @param presenceLibrary the library that could not be browsed
 * @param startRevision the revision under which the address resolution attemptwas started
 */
private void handleFailedResolution(PresenceLibrary presenceLibrary,int startRevision){
  LOG.debugf(""String_Node_Str"",presenceLibrary.getPresence().getPresenceId(),startRevision);
  presenceLibrary.setState(LibraryState.FAILED_TO_LOAD);
  boolean retry;
synchronized (librariesToBrowse) {
    retry=latestConnectivityEventRevision > startRevision;
    if (!retry) {
      LOG.debugf(""String_Node_Str"",presenceLibrary);
      boolean wasAdded=librariesToBrowse.add(presenceLibrary);
      assert(wasAdded);
    }
 else {
      startRevision=latestConnectivityEventRevision;
      LOG.debugf(""String_Node_Str"",startRevision);
    }
    LOG.debugf(""String_Node_Str"",librariesToBrowse,librariesToBrowse.size());
  }
  if (retry) {
    tryToResolveAndBrowse(presenceLibrary,startRevision);
  }
}",0.8956168097605061
3868,"@Inject public PresenceLibraryBrowser(BrowseFactory browseFactory,RemoteLibraryManagerImpl remoteLibraryManager,SocketsManager socketsManager,XMPPRemoteFileDescDeserializer remoteFileDescDeserializer){
  this.browseFactory=browseFactory;
  this.remoteLibraryManager=remoteLibraryManager;
  this.socketsManager=socketsManager;
  this.remoteFileDescDeserializer=remoteFileDescDeserializer;
  socketsManager.addListener(new ConnectivityChangeListener());
}","@Inject public PresenceLibraryBrowser(BrowseFactory browseFactory,RemoteLibraryManager remoteLibraryManager,SocketsManager socketsManager,XMPPRemoteFileDescDeserializer remoteFileDescDeserializer){
  this.browseFactory=browseFactory;
  this.remoteLibraryManager=remoteLibraryManager;
  this.socketsManager=socketsManager;
  this.remoteFileDescDeserializer=remoteFileDescDeserializer;
}",0.918854415274463
3869,"@Inject void register(ListenerSupport<LibraryChangedEvent> listenerSupport){
  listenerSupport.addListener(this);
}","@Inject void register(ListenerSupport<LibraryChangedEvent> listenerSupport){
  registerSecondaryListeners();
  listenerSupport.addListener(this);
}",0.8778625954198473
3870,"/** 
 * Displays the error to the user with a specific message. 
 */
public void error(Throwable problem,String msg){
  if (problem instanceof ThreadDeath)   throw (ThreadDeath)problem;
 else {
    Runnable doWorkRunnable=new Error(problem,msg);
    SwingUtils.invokeLater(doWorkRunnable);
  }
}","/** 
 * Displays the error to the user with a specific message. 
 */
public void error(Throwable problem,String msg){
  if (problem instanceof ThreadDeath)   throw (ThreadDeath)problem;
 else {
    SwingUtilities.invokeLater(new Error(problem,msg));
  }
}",0.8290909090909091
3871,"/** 
 * Constructs a new downloader that's gonna work off the network.
 * @param pushListProvider TODO
 */
@Inject InNetworkDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,@Named(""String_Node_Str"") EventMulticaster<DownloadStateEvent> downloadStateMulticaster) throws SaveLocationException {
  super(saveLocationManager,downloadManager,fileManager,incompleteFileManager,downloadCallback,networkManager,alternateLocationFactory,requeryManagerFactory,queryRequestFactory,onDemandUnicaster,downloadWorkerFactory,altLocManager,contentManager,sourceRankerFactory,urnCache,verifyingFileFactory,diskController,ipFilter,backgroundExecutor,messageRouter,tigerTreeCache,applicationServices,remoteFileDescFactory,pushListProvider,socketsManager,downloadStateMulticaster);
}","/** 
 * Constructs a new downloader that's gonna work off the network.
 * @param pushListProvider TODO
 */
@Inject InNetworkDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,@Named(""String_Node_Str"") ListeningExecutorService downloadStateProcessingQueue) throws SaveLocationException {
  super(saveLocationManager,downloadManager,fileManager,incompleteFileManager,downloadCallback,networkManager,alternateLocationFactory,requeryManagerFactory,queryRequestFactory,onDemandUnicaster,downloadWorkerFactory,altLocManager,contentManager,sourceRankerFactory,urnCache,verifyingFileFactory,diskController,ipFilter,backgroundExecutor,messageRouter,tigerTreeCache,applicationServices,remoteFileDescFactory,pushListProvider,socketsManager,downloadStateProcessingQueue);
}",0.9453883495145632
3872,"/** 
 * Creates a new MAGNET downloader.  Immediately tries to download from <tt>defaultURLs</tt>, if specified. If that fails, or if defaultURLs does not provide alternate locations, issues a requery with <tt>textQuery</tt> and </tt>urn</tt>, as provided.  (Note that at least one must be non-null.)  If <tt>filename</tt> is specified, it will be used as the name of the complete file; otherwise it will be taken from any search results or guessed from <tt>defaultURLs</tt>.
 * @param saveLocationManager 
 * @param pushListProvider TODO
 * @param magnet contains all the information for the download, must be{@link MagnetOptions#isDownloadable() downloadable}.
 * @param overwrite whether file at download location should be overwritten
 * @param saveDir can be null, then the default save directory is used
 * @param fileName the final file name, can be <code>null</code>
 * @throws SaveLocationException if there was an error setting the downloadsfinal file location 
 */
@Inject MagnetDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,@Named(""String_Node_Str"") EventMulticaster<DownloadStateEvent> downloadStateMulticaster){
  super(saveLocationManager,downloadManager,fileManager,incompleteFileManager,downloadCallback,networkManager,alternateLocationFactory,requeryManagerFactory,queryRequestFactory,onDemandUnicaster,downloadWorkerFactory,altLocManager,contentManager,sourceRankerFactory,urnCache,verifyingFileFactory,diskController,ipFilter,backgroundExecutor,messageRouter,tigerTreeCache,applicationServices,remoteFileDescFactory,pushListProvider,socketsManager,downloadStateMulticaster);
}","/** 
 * Creates a new MAGNET downloader.  Immediately tries to download from <tt>defaultURLs</tt>, if specified. If that fails, or if defaultURLs does not provide alternate locations, issues a requery with <tt>textQuery</tt> and </tt>urn</tt>, as provided.  (Note that at least one must be non-null.)  If <tt>filename</tt> is specified, it will be used as the name of the complete file; otherwise it will be taken from any search results or guessed from <tt>defaultURLs</tt>.
 * @param saveLocationManager 
 * @param pushListProvider TODO
 * @param magnet contains all the information for the download, must be{@link MagnetOptions#isDownloadable() downloadable}.
 * @param overwrite whether file at download location should be overwritten
 * @param saveDir can be null, then the default save directory is used
 * @param fileName the final file name, can be <code>null</code>
 * @throws SaveLocationException if there was an error setting the downloadsfinal file location 
 */
@Inject MagnetDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,@Named(""String_Node_Str"") ListeningExecutorService downloadStateProcessingQueue){
  super(saveLocationManager,downloadManager,fileManager,incompleteFileManager,downloadCallback,networkManager,alternateLocationFactory,requeryManagerFactory,queryRequestFactory,onDemandUnicaster,downloadWorkerFactory,altLocManager,contentManager,sourceRankerFactory,urnCache,verifyingFileFactory,diskController,ipFilter,backgroundExecutor,messageRouter,tigerTreeCache,applicationServices,remoteFileDescFactory,pushListProvider,socketsManager,downloadStateProcessingQueue);
}",0.9774557165861514
3873,"/** 
 * Creates a new ManagedDownload to download the given files. You must set initial source via   {@link #addInitialSources}, set the save file via   {@link #setSaveFile(File,String,boolean)}, and call   {@link #initialize} prior to starting this download.
 * @param downloadStateMulticaster TODO
 */
@Inject protected ManagedDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,@Named(""String_Node_Str"") EventMulticaster<DownloadStateEvent> downloadStateMulticaster){
  super(saveLocationManager);
  this.listeners=downloadStateMulticaster;
  this.downloadManager=downloadManager;
  this.fileManager=fileManager;
  this.incompleteFileManager=incompleteFileManager;
  this.downloadCallback=downloadCallback;
  this.networkManager=networkManager;
  this.alternateLocationFactory=alternateLocationFactory;
  this.socketsManager=socketsManager;
  this.requeryManager=requeryManagerFactory.createRequeryManager(new RequeryListenerImpl());
  this.queryRequestFactory=queryRequestFactory;
  this.onDemandUnicaster=onDemandUnicaster;
  this.downloadWorkerFactory=downloadWorkerFactory;
  this.altLocManager=altLocManager;
  this.contentManager=contentManager;
  this.sourceRankerFactory=sourceRankerFactory;
  this.urnCache=urnCache;
  this.verifyingFileFactory=verifyingFileFactory;
  this.diskController=diskController;
  this.ipFilter=ipFilter;
  this.backgroundExecutor=backgroundExecutor;
  this.messageRouter=messageRouter;
  this.tigerTreeCache=tigerTreeCache;
  this.applicationServices=applicationServices;
  this.remoteFileDescFactory=remoteFileDescFactory;
  this.cachedRFDs=new HashSet<RemoteFileDesc>();
  this.pushListProvider=pushListProvider;
}","/** 
 * Creates a new ManagedDownload to download the given files. You must set initial source via   {@link #addInitialSources}, set the save file via   {@link #setSaveFile(File,String,boolean)}, and call   {@link #initialize} prior to starting this download.
 * @param downloadStateMulticaster TODO
 */
@Inject protected ManagedDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,@Named(""String_Node_Str"") ListeningExecutorService downloadStateProcessingQueue){
  super(saveLocationManager);
  this.listeners=new AsynchronousMulticaster<DownloadStateEvent>(downloadStateProcessingQueue);
  this.downloadManager=downloadManager;
  this.fileManager=fileManager;
  this.incompleteFileManager=incompleteFileManager;
  this.downloadCallback=downloadCallback;
  this.networkManager=networkManager;
  this.alternateLocationFactory=alternateLocationFactory;
  this.socketsManager=socketsManager;
  this.requeryManager=requeryManagerFactory.createRequeryManager(new RequeryListenerImpl());
  this.queryRequestFactory=queryRequestFactory;
  this.onDemandUnicaster=onDemandUnicaster;
  this.downloadWorkerFactory=downloadWorkerFactory;
  this.altLocManager=altLocManager;
  this.contentManager=contentManager;
  this.sourceRankerFactory=sourceRankerFactory;
  this.urnCache=urnCache;
  this.verifyingFileFactory=verifyingFileFactory;
  this.diskController=diskController;
  this.ipFilter=ipFilter;
  this.backgroundExecutor=backgroundExecutor;
  this.messageRouter=messageRouter;
  this.tigerTreeCache=tigerTreeCache;
  this.applicationServices=applicationServices;
  this.remoteFileDescFactory=remoteFileDescFactory;
  this.cachedRFDs=new HashSet<RemoteFileDesc>();
  this.pushListProvider=pushListProvider;
}",0.9455397228186608
3874,"/** 
 * Creates a RequeryDownloader to finish downloading incompleteFile.  This constructor has preconditions on several parameters; putting the burden on the caller makes the method easier to implement, since the superclass constructor immediately starts a download thread.
 * @param pushListProvider TODO
 * @param incompleteFile the incomplete file to resume to, whichMUST be the result of IncompleteFileManager.getFile.
 * @param name the name of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedName(incompleteFile)
 * @param size the size of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedSize(incompleteFile) 
 */
@Inject ResumeDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,@Named(""String_Node_Str"") EventMulticaster<DownloadStateEvent> downloadStateMulticaster){
  super(saveLocationManager,downloadManager,fileManager,incompleteFileManager,downloadCallback,networkManager,alternateLocationFactory,requeryManagerFactory,queryRequestFactory,onDemandUnicaster,downloadWorkerFactory,altLocManager,contentManager,sourceRankerFactory,urnCache,verifyingFileFactory,diskController,ipFilter,backgroundExecutor,messageRouter,tigerTreeCache,applicationServices,remoteFileDescFactory,pushListProvider,socketsManager,downloadStateMulticaster);
}","/** 
 * Creates a RequeryDownloader to finish downloading incompleteFile.  This constructor has preconditions on several parameters; putting the burden on the caller makes the method easier to implement, since the superclass constructor immediately starts a download thread.
 * @param pushListProvider TODO
 * @param incompleteFile the incomplete file to resume to, whichMUST be the result of IncompleteFileManager.getFile.
 * @param name the name of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedName(incompleteFile)
 * @param size the size of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedSize(incompleteFile) 
 */
@Inject ResumeDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,@Named(""String_Node_Str"") ListeningExecutorService downloadStateProcessingQueue){
  super(saveLocationManager,downloadManager,fileManager,incompleteFileManager,downloadCallback,networkManager,alternateLocationFactory,requeryManagerFactory,queryRequestFactory,onDemandUnicaster,downloadWorkerFactory,altLocManager,contentManager,sourceRankerFactory,urnCache,verifyingFileFactory,diskController,ipFilter,backgroundExecutor,messageRouter,tigerTreeCache,applicationServices,remoteFileDescFactory,pushListProvider,socketsManager,downloadStateProcessingQueue);
}",0.974487471526196
3875,"@Inject public StoreDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,MetaDataFactory metaDataFactory,@Named(""String_Node_Str"") EventMulticaster<DownloadStateEvent> downloadStateMulticaster){
  super(saveLocationManager,downloadManager,fileManager,incompleteFileManager,downloadCallback,networkManager,alternateLocationFactory,requeryManagerFactory,queryRequestFactory,onDemandUnicaster,downloadWorkerFactory,altLocManager,contentManager,sourceRankerFactory,urnCache,verifyingFileFactory,diskController,ipFilter,backgroundExecutor,messageRouter,tigerTreeCache,applicationServices,remoteFileDescFactory,pushListProvider,socketsManager,downloadStateMulticaster);
  this.metaDataFactory=metaDataFactory;
}","@Inject public StoreDownloaderImpl(SaveLocationManager saveLocationManager,DownloadManager downloadManager,FileManager fileManager,IncompleteFileManager incompleteFileManager,DownloadCallback downloadCallback,NetworkManager networkManager,AlternateLocationFactory alternateLocationFactory,RequeryManagerFactory requeryManagerFactory,QueryRequestFactory queryRequestFactory,OnDemandUnicaster onDemandUnicaster,DownloadWorkerFactory downloadWorkerFactory,AltLocManager altLocManager,ContentManager contentManager,SourceRankerFactory sourceRankerFactory,UrnCache urnCache,VerifyingFileFactory verifyingFileFactory,DiskController diskController,IPFilter ipFilter,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,Provider<MessageRouter> messageRouter,Provider<HashTreeCache> tigerTreeCache,ApplicationServices applicationServices,RemoteFileDescFactory remoteFileDescFactory,Provider<PushList> pushListProvider,SocketsManager socketsManager,MetaDataFactory metaDataFactory,@Named(""String_Node_Str"") ListeningExecutorService downloadStateProcessingQueue){
  super(saveLocationManager,downloadManager,fileManager,incompleteFileManager,downloadCallback,networkManager,alternateLocationFactory,requeryManagerFactory,queryRequestFactory,onDemandUnicaster,downloadWorkerFactory,altLocManager,contentManager,sourceRankerFactory,urnCache,verifyingFileFactory,diskController,ipFilter,backgroundExecutor,messageRouter,tigerTreeCache,applicationServices,remoteFileDescFactory,pushListProvider,socketsManager,downloadStateProcessingQueue);
  this.metaDataFactory=metaDataFactory;
}",0.9646910466582598
3876,"/** 
 * The base constructor. Nothing should ever be initialized in the constructor. This is because of the way JUnit sets up tests -- It first builds a new instance of the class for every possible test, then it runs through those instances, calling the appropriate test. All pre & post initializations that are necessary for every test should be in the new 'preSetUp' and 'postTearDown' methods.
 */
public BaseTestCase(String name){
  super(name);
  _testClass=getClass();
}","/** 
 * The base constructor. Nothing should ever be initialized in the constructor. This is because of the way JUnit sets up tests -- It first builds a new instance of the class for every possible test, then it runs through those instances, calling the appropriate test. All pre & post initializations that are necessary for every test should be in the new 'preSetUp' and 'postTearDown' methods.
 */
public BaseTestCase(String name){
  super(name);
  _testClass=getClass();
  ErrorUtils.setCallback(this);
  Thread.setDefaultUncaughtExceptionHandler(this);
  Thread.currentThread().setUncaughtExceptionHandler(this);
}",0.869406392694064
3877,"public static boolean isURL(String input){
  Matcher matcher=getRegex().matcher(input);
  return matcher.matches();
}","public static boolean isURL(String input){
  Matcher matcher=getRegex().matcher(input.toLowerCase());
  return matcher.matches();
}",0.9435483870967742
3878,"@Override public void download(File saveFile,boolean overwrite) throws SaveLocationException {
  downloadManager.downloadTorrent(saveFile,overwrite);
}","@Override public void download(File saveFile,boolean overwrite) throws SaveLocationException {
  downloadManager.downloadTorrent(torrentFile,overwrite);
}",0.9704918032786886
3879,"@Override public void handleTorrent(File torrentFile){
  if (torrentFile != null && torrentFile.exists() && torrentFile.length() > 0) {
    try {
      downloadManager.downloadTorrent(torrentFile,false);
    }
 catch (    SaveLocationException e) {
      handleSaveLocationException(new DownloadAction(){
        @Override public void download(        File saveFile,        boolean overwrite) throws SaveLocationException {
          downloadManager.downloadTorrent(saveFile,overwrite);
        }
      }
,e,false);
    }
  }
}","@Override public void handleTorrent(final File torrentFile){
  if (torrentFile != null && torrentFile.exists() && torrentFile.length() > 0) {
    try {
      downloadManager.downloadTorrent(torrentFile,false);
    }
 catch (    SaveLocationException e) {
      handleSaveLocationException(new DownloadAction(){
        @Override public void download(        File saveFile,        boolean overwrite) throws SaveLocationException {
          downloadManager.downloadTorrent(torrentFile,overwrite);
        }
      }
,e,false);
    }
  }
}",0.9840075258701788
3880,"@Override public void handleEvent(DownloadStatusEvent event){
  DownloadStatus downloadStatus=event.getType();
  if (DownloadStatus.COMPLETE == downloadStatus) {
    try {
      if (downloader instanceof BTTorrentFileDownloader) {
        BTTorrentFileDownloader btTorrentFileDownloader=(BTTorrentFileDownloader)downloader;
        BTMetaInfo btMetaInfo=btTorrentFileDownloader.getBtMetaInfo();
        list.remove(getDownloadItem(downloader));
        downloadManager.downloadTorrent(btMetaInfo,true);
      }
 else {
        File possibleTorrentFile=downloader.getSaveFile();
        String fileExtension=FileUtils.getFileExtension(possibleTorrentFile);
        if (""String_Node_Str"".equalsIgnoreCase(fileExtension)) {
          list.remove(getDownloadItem(downloader));
          downloadManager.downloadTorrent(possibleTorrentFile,false);
        }
      }
    }
 catch (    SaveLocationException sle) {
      activityCallback.handleSaveLocationException(new DownloadAction(){
        @Override public void download(        File saveFile,        boolean overwrite) throws SaveLocationException {
          list.remove(getDownloadItem(downloader));
          downloadManager.downloadTorrent(saveFile,overwrite);
        }
      }
,sle,false);
    }
  }
}","@Override public void handleEvent(DownloadStatusEvent event){
  DownloadStatus downloadStatus=event.getType();
  if (DownloadStatus.COMPLETE == downloadStatus) {
    if (downloader instanceof BTTorrentFileDownloader) {
      BTMetaInfo btMetaInfo=null;
      try {
        BTTorrentFileDownloader btTorrentFileDownloader=(BTTorrentFileDownloader)downloader;
        btMetaInfo=btTorrentFileDownloader.getBtMetaInfo();
        list.remove(getDownloadItem(downloader));
        downloadManager.downloadTorrent(btMetaInfo,true);
      }
 catch (      SaveLocationException sle) {
        final BTMetaInfo btMetaInfoCopy=btMetaInfo;
        activityCallback.handleSaveLocationException(new DownloadAction(){
          @Override public void download(          File saveFile,          boolean overwrite) throws SaveLocationException {
            list.remove(getDownloadItem(downloader));
            downloadManager.downloadTorrent(btMetaInfoCopy,overwrite);
          }
        }
,sle,false);
      }
    }
 else {
      File possibleTorrentFile=null;
      try {
        possibleTorrentFile=downloader.getSaveFile();
        String fileExtension=FileUtils.getFileExtension(possibleTorrentFile);
        if (""String_Node_Str"".equalsIgnoreCase(fileExtension)) {
          list.remove(getDownloadItem(downloader));
          downloadManager.downloadTorrent(possibleTorrentFile,false);
        }
      }
 catch (      SaveLocationException sle) {
        final File torrentFile=possibleTorrentFile;
        activityCallback.handleSaveLocationException(new DownloadAction(){
          @Override public void download(          File saveFile,          boolean overwrite) throws SaveLocationException {
            list.remove(getDownloadItem(downloader));
            downloadManager.downloadTorrent(torrentFile,overwrite);
          }
        }
,sle,false);
      }
    }
  }
}",0.73088
3881,"@Override public void download(File saveFile,boolean overwrite) throws SaveLocationException {
  list.remove(getDownloadItem(downloader));
  downloadManager.downloadTorrent(saveFile,overwrite);
}","@Override public void download(File saveFile,boolean overwrite) throws SaveLocationException {
  list.remove(getDownloadItem(downloader));
  downloadManager.downloadTorrent(torrentFile,overwrite);
}",0.9770992366412212
3882,"private void runFileOpen(File file){
  String filename=file.getPath();
  if (filename.endsWith(""String_Node_Str"")) {
    initializer.setStartup();
  }
 else   if (filename.endsWith(""String_Node_Str"")) {
    if (!lifecycleManager.isStarted()) {
      externalControl.enqueueControlRequest(file.getAbsolutePath());
    }
 else {
      try {
        downloadManager.downloadTorrent(file,false);
      }
 catch (      SaveLocationException e) {
        activityCallback.handleSaveLocationException(new DownloadAction(){
          @Override public void download(          File saveFile,          boolean overwrite) throws SaveLocationException {
            downloadManager.downloadTorrent(saveFile,overwrite);
          }
        }
,e,false);
      }
    }
  }
 else {
    NativeLaunchUtils.safeLaunchFile(file);
  }
}","private void runFileOpen(final File file){
  String filename=file.getPath();
  if (filename.endsWith(""String_Node_Str"")) {
    initializer.setStartup();
  }
 else   if (filename.endsWith(""String_Node_Str"")) {
    if (!lifecycleManager.isStarted()) {
      externalControl.enqueueControlRequest(file.getAbsolutePath());
    }
 else {
      try {
        downloadManager.downloadTorrent(file,false);
      }
 catch (      SaveLocationException e) {
        activityCallback.handleSaveLocationException(new DownloadAction(){
          @Override public void download(          File saveFile,          boolean overwrite) throws SaveLocationException {
            downloadManager.downloadTorrent(file,overwrite);
          }
        }
,e,false);
      }
    }
  }
 else {
    NativeLaunchUtils.safeLaunchFile(file);
  }
}",0.992638036809816
3883,"@Override public void download(File saveFile,boolean overwrite) throws SaveLocationException {
  downloadManager.downloadTorrent(saveFile,overwrite);
}","@Override public void download(File saveFile,boolean overwrite) throws SaveLocationException {
  downloadManager.downloadTorrent(file,overwrite);
}",0.9798657718120806
3884,"@Override public void run(){
  resultsList.setIgnoreRepaints(true);
  boolean setRowSize=false;
  for (int row=0; row < model.getRowCount(); row++) {
    VisualSearchResult vsr=(VisualSearchResult)model.getElementAt(row);
    RowDisplayResult result=vsrToRowDisplayResultMap.get(vsr);
    if (result == null || result.isStale(vsr)) {
      result=rowHeightRule.getDisplayResult(vsr,searchInfo.getQuery());
      vsrToRowDisplayResultMap.put(vsr,result);
    }
    int newRowHeight=result.getConfig().getRowHeight();
    if (resultsList.getRowHeight(row) != newRowHeight) {
      LOG.debugf(""String_Node_Str"",row,vsr.getHeading(),result.getConfig());
      resultsList.setRowHeight(row,newRowHeight);
      setRowSize=true;
    }
  }
  resultsList.setIgnoreRepaints(false);
  if (setRowSize) {
    if (resultsList.isEditing()) {
      resultsList.editingCanceled(new ChangeEvent(resultsList));
    }
    resultsList.updateViewSizeSequence();
    resultsList.resizeAndRepaint();
  }
}","@Override public void run(){
  resultsList.setIgnoreRepaints(true);
  boolean setRowSize=false;
  for (int row=0; row < model.getRowCount(); row++) {
    VisualSearchResult vsr=(VisualSearchResult)model.getElementAt(row);
    RowDisplayResult result=vsrToRowDisplayResultMap.get(vsr);
    if (result == null || result.isStale(vsr)) {
      result=rowHeightRule.getDisplayResult(vsr,searchInfo.getQuery());
      vsrToRowDisplayResultMap.put(vsr,result);
    }
    int newRowHeight=result.getConfig().getRowHeight();
    if (vsr.getSimilarityParent() == null) {
      if (resultsList.getRowHeight(row) != newRowHeight) {
        LOG.debugf(""String_Node_Str"",row,vsr.getHeading(),result.getConfig());
        resultsList.setRowHeight(row,newRowHeight);
        setRowSize=true;
      }
    }
  }
  resultsList.setIgnoreRepaints(false);
  if (setRowSize) {
    if (resultsList.isEditing()) {
      resultsList.editingCanceled(new ChangeEvent(resultsList));
    }
    resultsList.updateViewSizeSequence();
    resultsList.resizeAndRepaint();
  }
}",0.9698765432098766
3885,"@Override public void listChanged(ListEvent<VisualSearchResult> listChanges){
  final EventTableModel model=(EventTableModel)resultsList.getModel();
  if (model.getRowCount() == 0) {
    return;
  }
  Runnable runner=new Runnable(){
    @Override public void run(){
      resultsList.setIgnoreRepaints(true);
      boolean setRowSize=false;
      for (int row=0; row < model.getRowCount(); row++) {
        VisualSearchResult vsr=(VisualSearchResult)model.getElementAt(row);
        RowDisplayResult result=vsrToRowDisplayResultMap.get(vsr);
        if (result == null || result.isStale(vsr)) {
          result=rowHeightRule.getDisplayResult(vsr,searchInfo.getQuery());
          vsrToRowDisplayResultMap.put(vsr,result);
        }
        int newRowHeight=result.getConfig().getRowHeight();
        if (resultsList.getRowHeight(row) != newRowHeight) {
          LOG.debugf(""String_Node_Str"",row,vsr.getHeading(),result.getConfig());
          resultsList.setRowHeight(row,newRowHeight);
          setRowSize=true;
        }
      }
      resultsList.setIgnoreRepaints(false);
      if (setRowSize) {
        if (resultsList.isEditing()) {
          resultsList.editingCanceled(new ChangeEvent(resultsList));
        }
        resultsList.updateViewSizeSequence();
        resultsList.resizeAndRepaint();
      }
    }
  }
;
  SwingUtilities.invokeLater(runner);
}","@Override public void listChanged(ListEvent<VisualSearchResult> listChanges){
  final EventTableModel model=(EventTableModel)resultsList.getModel();
  if (model.getRowCount() == 0) {
    return;
  }
  Runnable runner=new Runnable(){
    @Override public void run(){
      resultsList.setIgnoreRepaints(true);
      boolean setRowSize=false;
      for (int row=0; row < model.getRowCount(); row++) {
        VisualSearchResult vsr=(VisualSearchResult)model.getElementAt(row);
        RowDisplayResult result=vsrToRowDisplayResultMap.get(vsr);
        if (result == null || result.isStale(vsr)) {
          result=rowHeightRule.getDisplayResult(vsr,searchInfo.getQuery());
          vsrToRowDisplayResultMap.put(vsr,result);
        }
        int newRowHeight=result.getConfig().getRowHeight();
        if (vsr.getSimilarityParent() == null) {
          if (resultsList.getRowHeight(row) != newRowHeight) {
            LOG.debugf(""String_Node_Str"",row,vsr.getHeading(),result.getConfig());
            resultsList.setRowHeight(row,newRowHeight);
            setRowSize=true;
          }
        }
      }
      resultsList.setIgnoreRepaints(false);
      if (setRowSize) {
        if (resultsList.isEditing()) {
          resultsList.editingCanceled(new ChangeEvent(resultsList));
        }
        resultsList.updateViewSizeSequence();
        resultsList.resizeAndRepaint();
      }
    }
  }
;
  SwingUtilities.invokeLater(runner);
}",0.97534833869239
3886,"private void configureList(final EventList<VisualSearchResult> eventList,RowSelectionPreserver preserver,final Navigator navigator,final SearchInfo searchInfo,final PropertiesFactory<VisualSearchResult> properties,final ListViewRowHeightRule rowHeightRule){
  ListViewTableFormat tableFormat=new ListViewTableFormat();
  final RangeList<VisualSearchResult> maxSizedList=new RangeList<VisualSearchResult>(newVisibleFilterList(eventList));
  maxSizedList.setHeadRange(0,MAX_DISPLAYED_RESULT_SIZE + 1);
  resultsList=new ListViewTable(maxSizedList,tableFormat);
  resultsList.setShowGrid(true,false);
  preserver.addRowPreservationListener(resultsList);
  ListViewDisplayedRowsLimit displayLimit=new ListViewDisplayedRowsLimit(){
    @Override public int getLastDisplayedRow(){
      return MAX_DISPLAYED_RESULT_SIZE;
    }
    @Override public int getTotalResultsReturned(){
      return eventList.size();
    }
  }
;
  ListViewTableEditorRenderer renderer=listViewTableEditorRendererFactory.create(new ActionColumnTableCellEditor(this),searchInfo.getQuery(),navigator,resultsList.getTableColors().selectionColor,this,displayLimit);
  TableColumnModel tcm=resultsList.getColumnModel();
  int columnCount=tableFormat.getColumnCount();
  for (int i=0; i < columnCount; i++) {
    TableColumn tc=tcm.getColumn(i);
    tc.setCellRenderer(renderer);
  }
  ListViewTableEditorRenderer editor=listViewTableEditorRendererFactory.create(new ActionColumnTableCellEditor(this),searchInfo.getQuery(),navigator,resultsList.getTableColors().selectionColor,this,displayLimit);
  resultsList.setDefaultEditor(VisualSearchResult.class,editor);
  for (int i=0; i < tableFormat.getColumnCount(); i++) {
    resultsList.getColumnModel().getColumn(i).setPreferredWidth(tableFormat.getInitialWidth(i));
  }
  resultsList.setRowHeightEnabled(true);
  maxSizedList.addListEventListener(new ListEventListener<VisualSearchResult>(){
    @Override public void listChanged(    ListEvent<VisualSearchResult> listChanges){
      final EventTableModel model=(EventTableModel)resultsList.getModel();
      if (model.getRowCount() == 0) {
        return;
      }
      Runnable runner=new Runnable(){
        @Override public void run(){
          resultsList.setIgnoreRepaints(true);
          boolean setRowSize=false;
          for (int row=0; row < model.getRowCount(); row++) {
            VisualSearchResult vsr=(VisualSearchResult)model.getElementAt(row);
            RowDisplayResult result=vsrToRowDisplayResultMap.get(vsr);
            if (result == null || result.isStale(vsr)) {
              result=rowHeightRule.getDisplayResult(vsr,searchInfo.getQuery());
              vsrToRowDisplayResultMap.put(vsr,result);
            }
            int newRowHeight=result.getConfig().getRowHeight();
            if (resultsList.getRowHeight(row) != newRowHeight) {
              LOG.debugf(""String_Node_Str"",row,vsr.getHeading(),result.getConfig());
              resultsList.setRowHeight(row,newRowHeight);
              setRowSize=true;
            }
          }
          resultsList.setIgnoreRepaints(false);
          if (setRowSize) {
            if (resultsList.isEditing()) {
              resultsList.editingCanceled(new ChangeEvent(resultsList));
            }
            resultsList.updateViewSizeSequence();
            resultsList.resizeAndRepaint();
          }
        }
      }
;
      SwingUtilities.invokeLater(runner);
    }
  }
);
  resultsList.setRowHeight(ROW_HEIGHT);
  resultsList.addMouseListener(new ResultDownloaderAdaptor());
}","private void configureList(final EventList<VisualSearchResult> eventList,RowSelectionPreserver preserver,final Navigator navigator,final SearchInfo searchInfo,final PropertiesFactory<VisualSearchResult> properties,final ListViewRowHeightRule rowHeightRule){
  ListViewTableFormat tableFormat=new ListViewTableFormat();
  final RangeList<VisualSearchResult> maxSizedList=new RangeList<VisualSearchResult>(newVisibleFilterList(eventList));
  maxSizedList.setHeadRange(0,MAX_DISPLAYED_RESULT_SIZE + 1);
  resultsList=new ListViewTable(maxSizedList,tableFormat);
  resultsList.setShowGrid(true,false);
  preserver.addRowPreservationListener(resultsList);
  ListViewDisplayedRowsLimit displayLimit=new ListViewDisplayedRowsLimit(){
    @Override public int getLastDisplayedRow(){
      return MAX_DISPLAYED_RESULT_SIZE;
    }
    @Override public int getTotalResultsReturned(){
      return eventList.size();
    }
  }
;
  ListViewTableEditorRenderer renderer=listViewTableEditorRendererFactory.create(new ActionColumnTableCellEditor(this),searchInfo.getQuery(),navigator,resultsList.getTableColors().selectionColor,this,displayLimit);
  TableColumnModel tcm=resultsList.getColumnModel();
  int columnCount=tableFormat.getColumnCount();
  for (int i=0; i < columnCount; i++) {
    TableColumn tc=tcm.getColumn(i);
    tc.setCellRenderer(renderer);
  }
  ListViewTableEditorRenderer editor=listViewTableEditorRendererFactory.create(new ActionColumnTableCellEditor(this),searchInfo.getQuery(),navigator,resultsList.getTableColors().selectionColor,this,displayLimit);
  resultsList.setDefaultEditor(VisualSearchResult.class,editor);
  for (int i=0; i < tableFormat.getColumnCount(); i++) {
    resultsList.getColumnModel().getColumn(i).setPreferredWidth(tableFormat.getInitialWidth(i));
  }
  resultsList.setRowHeightEnabled(true);
  maxSizedList.addListEventListener(new ListEventListener<VisualSearchResult>(){
    @Override public void listChanged(    ListEvent<VisualSearchResult> listChanges){
      final EventTableModel model=(EventTableModel)resultsList.getModel();
      if (model.getRowCount() == 0) {
        return;
      }
      Runnable runner=new Runnable(){
        @Override public void run(){
          resultsList.setIgnoreRepaints(true);
          boolean setRowSize=false;
          for (int row=0; row < model.getRowCount(); row++) {
            VisualSearchResult vsr=(VisualSearchResult)model.getElementAt(row);
            RowDisplayResult result=vsrToRowDisplayResultMap.get(vsr);
            if (result == null || result.isStale(vsr)) {
              result=rowHeightRule.getDisplayResult(vsr,searchInfo.getQuery());
              vsrToRowDisplayResultMap.put(vsr,result);
            }
            int newRowHeight=result.getConfig().getRowHeight();
            if (vsr.getSimilarityParent() == null) {
              if (resultsList.getRowHeight(row) != newRowHeight) {
                LOG.debugf(""String_Node_Str"",row,vsr.getHeading(),result.getConfig());
                resultsList.setRowHeight(row,newRowHeight);
                setRowSize=true;
              }
            }
          }
          resultsList.setIgnoreRepaints(false);
          if (setRowSize) {
            if (resultsList.isEditing()) {
              resultsList.editingCanceled(new ChangeEvent(resultsList));
            }
            resultsList.updateViewSizeSequence();
            resultsList.resizeAndRepaint();
          }
        }
      }
;
      SwingUtilities.invokeLater(runner);
    }
  }
);
  resultsList.setRowHeight(ROW_HEIGHT);
  resultsList.addMouseListener(new ResultDownloaderAdaptor());
}",0.98919904614953
3887,"public IntentDialog(String version){
  super();
  ResizeUtils.forceSize(this,new Dimension(514,402));
  setTitle(""String_Node_Str"" + version);
  setModal(true);
  setResizable(false);
  setAlwaysOnTop(true);
  JPanel contentPane=new JPanel(new BorderLayout());
  contentPane.setBackground(backgroundColor);
  add(contentPane);
  JPanel panel=new JPanel(new MigLayout(""String_Node_Str""));
  panel.setOpaque(false);
  headingLabel=new JLabel();
  headingLabel.setFont(headingFont);
  agreeLabel=new MultiLineLabel(""String_Node_Str"",500);
  agreeLabel.setFont(smallFont);
  copyrightButton=new HyperlinkButton(urlAction);
  copyrightButton.setFocusPainted(false);
  copyrightButton.setFont(smallFont);
  FontUtils.underline(copyrightButton);
  copyrightButton.setForeground(new Color(0x2152a6));
  agreementButton=new HyperlinkButton(urlAction);
  agreementButton.setFocusPainted(false);
  agreementButton.setFont(smallFont);
  FontUtils.underline(agreementButton);
  agreementButton.setForeground(new Color(0x2152a6));
  privacyButton=new HyperlinkButton(urlAction);
  privacyButton.setFocusPainted(false);
  privacyButton.setFont(smallFont);
  FontUtils.underline(privacyButton);
  privacyButton.setForeground(new Color(0x2152a6));
  bodyLabel=new MultiLineLabel(""String_Node_Str"",500);
  bodyLabel.setFont(smallFont);
  languageLabel=new JLabel();
  languageLabel.setFont(smallFont);
  agreeButton=new JXButton();
  decorateButton(agreeButton);
  agreeButton.setBackgroundPainter(new IntentGreenButtonBackgroundPainter());
  exitButton=new JXButton();
  decorateButton(exitButton);
  exitButton.setBackgroundPainter(new IntentLightButtonBackgroundPainter());
  JComboBox languageDropDown=createLanguageDropDown(normalFont);
  JPanel bottomPanel=new JPanel(new BorderLayout());
  JPanel outerPanel=new JPanel(new BorderLayout());
  JPanel innerPanel=new JPanel(new MigLayout(""String_Node_Str""));
  JPanel langInnerPanel=new JPanel(new MigLayout(""String_Node_Str""));
  bottomPanel.setOpaque(false);
  outerPanel.setOpaque(false);
  innerPanel.setOpaque(false);
  langInnerPanel.setOpaque(false);
  bottomPanel.setBorder(BorderFactory.createEmptyBorder(0,14,14,14));
  JXPanel headerBar=new JXPanel(new MigLayout(""String_Node_Str""));
  headerBar.setBackgroundPainter(new GenericBarPainter<JXPanel>(new GradientPaint(0,0,headerGradientTop,0,1,headerGradientBottom,false),headerTopBorder1,headerTopBorder2,headerBottomBorder1,headerBottomBorder2));
  int indent=14;
  headerBar.add(headingLabel,""String_Node_Str"");
  panel.add(bodyLabel,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(copyrightButton,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(agreementButton,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(privacyButton,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(agreeLabel,""String_Node_Str"" + indent + ""String_Node_Str"");
  langInnerPanel.add(languageLabel);
  langInnerPanel.add(languageDropDown);
  bottomPanel.add(langInnerPanel,BorderLayout.WEST);
  innerPanel.add(agreeButton);
  innerPanel.add(exitButton);
  outerPanel.add(innerPanel,BorderLayout.SOUTH);
  bottomPanel.add(outerPanel,BorderLayout.EAST);
  setTextContents();
  contentPane.add(headerBar,BorderLayout.NORTH);
  contentPane.add(panel,BorderLayout.CENTER);
  contentPane.add(bottomPanel,BorderLayout.SOUTH);
  pack();
}","public IntentDialog(String version){
  super();
  ResizeUtils.forceSize(this,new Dimension(514,402));
  setTitle(""String_Node_Str"" + version);
  setModal(true);
  setResizable(false);
  setAlwaysOnTop(true);
  JPanel contentPane=new JPanel(new BorderLayout());
  contentPane.setBackground(backgroundColor);
  add(contentPane);
  JPanel panel=new JPanel(new MigLayout(""String_Node_Str""));
  panel.setOpaque(false);
  headingLabel=new JLabel();
  headingLabel.setFont(headingFont);
  agreeLabel=new MultiLineLabel(""String_Node_Str"",500);
  agreeLabel.setFont(smallFont);
  copyrightButton=new HyperlinkButton(urlAction);
  copyrightButton.setFocusPainted(false);
  copyrightButton.setFont(smallFont);
  FontUtils.underline(copyrightButton);
  copyrightButton.setForeground(new Color(0x2152a6));
  licenseButton=new HyperlinkButton(urlAction);
  licenseButton.setFocusPainted(false);
  licenseButton.setFont(smallFont);
  FontUtils.underline(licenseButton);
  licenseButton.setForeground(new Color(0x2152a6));
  privacyButton=new HyperlinkButton(urlAction);
  privacyButton.setFocusPainted(false);
  privacyButton.setFont(smallFont);
  FontUtils.underline(privacyButton);
  privacyButton.setForeground(new Color(0x2152a6));
  bodyLabel=new MultiLineLabel(""String_Node_Str"",500);
  bodyLabel.setFont(smallFont);
  languageLabel=new JLabel();
  languageLabel.setFont(smallFont);
  agreeButton=new JXButton();
  decorateButton(agreeButton);
  agreeButton.setBackgroundPainter(new IntentGreenButtonBackgroundPainter());
  exitButton=new JXButton();
  decorateButton(exitButton);
  exitButton.setBackgroundPainter(new IntentLightButtonBackgroundPainter());
  JComboBox languageDropDown=createLanguageDropDown(normalFont);
  JPanel bottomPanel=new JPanel(new BorderLayout());
  JPanel outerPanel=new JPanel(new BorderLayout());
  JPanel innerPanel=new JPanel(new MigLayout(""String_Node_Str""));
  JPanel langInnerPanel=new JPanel(new MigLayout(""String_Node_Str""));
  bottomPanel.setOpaque(false);
  outerPanel.setOpaque(false);
  innerPanel.setOpaque(false);
  langInnerPanel.setOpaque(false);
  bottomPanel.setBorder(BorderFactory.createEmptyBorder(0,14,14,14));
  JXPanel headerBar=new JXPanel(new MigLayout(""String_Node_Str""));
  headerBar.setBackgroundPainter(new GenericBarPainter<JXPanel>(new GradientPaint(0,0,headerGradientTop,0,1,headerGradientBottom,false),headerTopBorder1,headerTopBorder2,headerBottomBorder1,headerBottomBorder2));
  int indent=14;
  headerBar.add(headingLabel,""String_Node_Str"");
  panel.add(bodyLabel,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(copyrightButton,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(licenseButton,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(privacyButton,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(agreeLabel,""String_Node_Str"" + indent + ""String_Node_Str"");
  langInnerPanel.add(languageLabel);
  langInnerPanel.add(languageDropDown);
  bottomPanel.add(langInnerPanel,BorderLayout.WEST);
  innerPanel.add(agreeButton);
  innerPanel.add(exitButton);
  outerPanel.add(innerPanel,BorderLayout.SOUTH);
  bottomPanel.add(outerPanel,BorderLayout.EAST);
  setTextContents();
  contentPane.add(headerBar,BorderLayout.NORTH);
  contentPane.add(panel,BorderLayout.CENTER);
  contentPane.add(bottomPanel,BorderLayout.SOUTH);
  pack();
}",0.964702363146874
3888,"/** 
 * Allows a soft localised refresh of the text within the panel based on the language selected in the combo box.
 */
private void setTextContents(){
  String heading=I18n.tr(""String_Node_Str"");
  String bodyText1=I18n.tr(""String_Node_Str"");
  String copyText=I18n.tr(""String_Node_Str"");
  String privacyText=I18n.tr(""String_Node_Str"");
  String licenseText=I18n.tr(""String_Node_Str"");
  String agreementText=I18n.tr(""String_Node_Str"");
  String languageText=I18n.tr(""String_Node_Str"");
  Action exitAction=new AbstractAction(I18n.tr(""String_Node_Str"")){
    @Override public void actionPerformed(    ActionEvent e){
      finish(false);
    }
  }
;
  Action agreeAction=new AbstractAction(I18n.tr(""String_Node_Str"")){
    @Override public void actionPerformed(    ActionEvent e){
      finish(true);
    }
  }
;
  headingLabel.setText(heading);
  bodyLabel.setText(bodyText1);
  copyrightButton.setText(copyText);
  agreementButton.setText(privacyText);
  privacyButton.setText(licenseText);
  agreeLabel.setText(agreementText);
  languageLabel.setText(languageText);
  exitButton.setAction(exitAction);
  agreeButton.setAction(agreeAction);
}","/** 
 * Allows a soft localised refresh of the text within the panel based on the language selected in the combo box.
 */
private void setTextContents(){
  String heading=I18n.tr(""String_Node_Str"");
  String bodyText1=I18n.tr(""String_Node_Str"");
  String copyText=I18n.tr(""String_Node_Str"");
  String privacyText=I18n.tr(""String_Node_Str"");
  String licenseText=I18n.tr(""String_Node_Str"");
  String agreementText=I18n.tr(""String_Node_Str"");
  String languageText=I18n.tr(""String_Node_Str"");
  Action exitAction=new AbstractAction(I18n.tr(""String_Node_Str"")){
    @Override public void actionPerformed(    ActionEvent e){
      finish(false);
    }
  }
;
  Action agreeAction=new AbstractAction(I18n.tr(""String_Node_Str"")){
    @Override public void actionPerformed(    ActionEvent e){
      finish(true);
    }
  }
;
  headingLabel.setText(heading);
  bodyLabel.setText(bodyText1);
  copyrightButton.setText(copyText);
  licenseButton.setText(licenseText);
  privacyButton.setText(privacyText);
  agreeLabel.setText(agreementText);
  languageLabel.setText(languageText);
  exitButton.setAction(exitAction);
  agreeButton.setAction(agreeAction);
}",0.980819529206626
3889,"/** 
 * Handles the specified SaveLocationException. The method may prompt the user for input, and should be executed from the UI thread.
 */
private void handleException(final DownloadAction downLoadAction,final SaveLocationException sle,final boolean supportNewSaveDir){
  if (sle.getErrorCode() == SaveLocationException.LocationCode.FILE_ALREADY_DOWNLOADING) {
    return;
  }
  if ((sle.getErrorCode() != SaveLocationException.LocationCode.FILE_ALREADY_EXISTS) && (sle.getErrorCode() != SaveLocationException.LocationCode.FILE_IS_ALREADY_DOWNLOADED_TO)) {
    String message=I18n.tr(""String_Node_Str"",sle.getErrorCode(),sle.getFile());
    LOG.error(message,sle);
    FocusJOptionPane.showMessageDialog(GuiUtils.getMainFrame(),message,I18n.tr(""String_Node_Str""),JOptionPane.INFORMATION_MESSAGE);
    return;
  }
  File saveFile=null;
  if (supportNewSaveDir && SwingUiSettings.AUTO_RENAME_DUPLICATE_FILES.getValue()) {
    saveFile=getAutoSaveFile(sle);
  }
 else {
    if (supportNewSaveDir) {
      saveFile=FileChooser.getSaveAsFile(GuiUtils.getMainFrame(),I18n.tr(""String_Node_Str""),sle.getFile());
    }
 else {
      saveFile=sle.getFile();
    }
    if (saveFile == null) {
      return;
    }
  }
  if (saveFile.exists()) {
    createOverwriteDialogue(saveFile,downLoadAction,sle,supportNewSaveDir);
  }
 else {
    download(downLoadAction,supportNewSaveDir,saveFile,false);
  }
}","/** 
 * Handles the specified SaveLocationException. The method may prompt the user for input, and should be executed from the UI thread.
 */
private void handleException(final DownloadAction downLoadAction,final SaveLocationException sle,final boolean supportNewSaveDir){
  if (sle.getErrorCode() == SaveLocationException.LocationCode.FILE_ALREADY_DOWNLOADING) {
    return;
  }
  if ((sle.getErrorCode() != SaveLocationException.LocationCode.FILE_ALREADY_EXISTS) && (sle.getErrorCode() != SaveLocationException.LocationCode.FILE_IS_ALREADY_DOWNLOADED_TO)) {
    showErrorMessage(sle);
    return;
  }
 else   if (sle.getErrorCode() == SaveLocationException.LocationCode.FILE_IS_ALREADY_DOWNLOADED_TO && !supportNewSaveDir) {
    showErrorMessage(sle);
    return;
  }
  File saveFile=null;
  if (supportNewSaveDir && SwingUiSettings.AUTO_RENAME_DUPLICATE_FILES.getValue()) {
    saveFile=getAutoSaveFile(sle);
  }
 else {
    if (supportNewSaveDir) {
      saveFile=FileChooser.getSaveAsFile(GuiUtils.getMainFrame(),I18n.tr(""String_Node_Str""),sle.getFile());
    }
 else {
      saveFile=sle.getFile();
    }
    if (saveFile == null) {
      return;
    }
  }
  if (saveFile.exists()) {
    createOverwriteDialogue(saveFile,downLoadAction,sle,supportNewSaveDir);
  }
 else {
    download(downLoadAction,supportNewSaveDir,saveFile,false);
  }
}",0.6537618699780862
3890,"public Dialog(DialogParam param){
  this.iconManager=param.getIconManager();
  this.propertiableHeadings=param.getPropertiableHeadings();
  this.smallFont=param.getSmallFont();
  this.mediumFont=param.getMediumFont();
  this.largeFont=param.getLargeFont();
  mainPanel=new JPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  locateOnDisk=newHyperlink();
  locateInLibrary=newHyperlink();
  copyToClipboard=newHyperlink();
  moreFileInfo=newHyperlink();
  add(mainPanel);
  mainPanel.setBackground(param.getBackgroundColor());
  setFont(mediumFont,heading,filename,fileSize);
  setFont(smallFont,metadata,copyToClipboard,moreFileInfo,locateOnDisk,locateInLibrary,title,genre,unEditableGenre,rating,year,description,artist,album,track,author,platform,company,fileLocation);
  decorateEditorPane(fileLocation);
  descriptionScrollPane.setBorder(artist.getBorder());
  description.setRows(3);
  JPanel buttons=newPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  buttons.add(new JButton(new OKAction()));
  buttons.add(new JButton(new CancelAction()));
  mainPanel.add(buttons,""String_Node_Str"");
  overview=newPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  JPanel linksPanel=new JPanel(new BorderLayout());
  linksPanel.setOpaque(false);
  linksPanel.add(copyToClipboard,BorderLayout.NORTH);
  linksPanel.add(moreFileInfo,BorderLayout.SOUTH);
  overview.add(icon,""String_Node_Str"");
  overview.add(heading,""String_Node_Str"");
  overview.add(linksPanel,""String_Node_Str"");
  overview.add(metadata,""String_Node_Str"");
  addOverview();
  unEditableGenre.setVisible(false);
}","public Dialog(DialogParam param){
  this.iconManager=param.getIconManager();
  this.propertiableHeadings=param.getPropertiableHeadings();
  this.smallFont=param.getSmallFont();
  this.mediumFont=param.getMediumFont();
  this.largeFont=param.getLargeFont();
  mainPanel=new JPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  locateOnDisk=newHyperlink();
  locateInLibrary=newHyperlink();
  copyToClipboard=newHyperlink();
  moreFileInfo=newHyperlink();
  add(mainPanel);
  mainPanel.setBackground(param.getBackgroundColor());
  setFont(mediumFont,heading,filename,fileSize);
  setFont(smallFont,metadata,copyToClipboard,moreFileInfo,locateOnDisk,locateInLibrary,title,genre,unEditableGenre,rating,year,description,artist,album,track,author,platform,company,fileLocation);
  decorateEditorPane(heading);
  decorateEditorPane(fileLocation);
  descriptionScrollPane.setBorder(artist.getBorder());
  description.setRows(3);
  JPanel buttons=newPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  buttons.add(new JButton(new OKAction()));
  buttons.add(new JButton(new CancelAction()));
  mainPanel.add(buttons,""String_Node_Str"");
  overview=newPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  JPanel linksPanel=new JPanel(new BorderLayout());
  linksPanel.setOpaque(false);
  linksPanel.add(copyToClipboard,BorderLayout.NORTH);
  linksPanel.add(moreFileInfo,BorderLayout.SOUTH);
  overview.add(icon,""String_Node_Str"");
  overview.add(heading,""String_Node_Str"");
  overview.add(linksPanel,""String_Node_Str"");
  overview.add(metadata,""String_Node_Str"");
  addOverview();
  unEditableGenre.setVisible(false);
}",0.9907324364723468
3891,"private void decorateEditorPane(JEditorPane editor){
  editor.setOpaque(false);
  editor.setEditable(false);
  editor.setPreferredSize(new Dimension(100,30));
}","private void decorateEditorPane(JEditorPane editor){
  editor.setOpaque(false);
  editor.setBorder(BorderFactory.createEmptyBorder());
  editor.setEditable(false);
  editor.setPreferredSize(new Dimension(100,20));
}",0.848
3892,"public void setupColumnOrder(){
  stopListening();
  for (int i=0; i < table.getColumnCount(); i++) {
    TableColumnExt column=table.getColumnExt(i);
    ColumnStateInfo info=format.getColumnInfo(column.getModelIndex());
    if (i != info.getPreferredViewIndex()) {
      if (info.getPreferredViewIndex() >= 0 && info.getPreferredViewIndex() < table.getColumnCount()) {
        table.getColumnModel().moveColumn(i,info.getPreferredViewIndex());
      }
    }
  }
  startListening();
}","/** 
 * Sets the column order of the table based on the preffered index of each column. Because table.getColumnModel.move is not stable. Meaning moving an item to index 2 might  move the item already there to the left, or maybe to the right. We have to jump through a few hoops to make it stable. First we make a list ordering all columns in the reverse preffered order, then move each item from where it currently is in the column model to the zero index. Since items cannot be moved to the left of the zero index this makes the move stable, and places the items in the proper preffered index order.
 */
public void setupColumnOrder(){
  stopListening();
  List<TableColumn> columns=new ArrayList<TableColumn>();
  for (int i=0; i < table.getColumnCount(); i++) {
    TableColumn tableColumn=table.getColumn(i);
    columns.add(tableColumn);
  }
  Collections.sort(columns,new Comparator<TableColumn>(){
    @Override public int compare(    TableColumn o1,    TableColumn o2){
      ColumnStateInfo info1=format.getColumnInfo(o1.getModelIndex());
      ColumnStateInfo info2=format.getColumnInfo(o2.getModelIndex());
      Integer prefferedIndex1=info1.getPreferredViewIndex();
      Integer prefferedIndex2=info2.getPreferredViewIndex();
      return prefferedIndex1.compareTo(prefferedIndex2) * -1;
    }
  }
);
  for (  TableColumn tableColumn : columns) {
    int currentIndex=getCurrentIndex(tableColumn);
    if (currentIndex > 0 && currentIndex < table.getColumnCount()) {
      table.getColumnModel().moveColumn(currentIndex,0);
    }
  }
  startListening();
}",0.3232716650438169
3893,"private void initComponents(){
  this.setBackgroundPainter(this.createCellPainter());
  statusViewLayout=new CardLayout();
  this.setLayout(statusViewLayout);
  fullPanel=new JPanel(new GridBagLayout());
  minPanel=new JPanel(new GridBagLayout());
  fullPanel.setOpaque(false);
  minPanel.setOpaque(false);
  Border blankBorder=BorderFactory.createEmptyBorder(0,0,0,0);
  fullPanel.setBorder(blankBorder);
  minPanel.setBorder(blankBorder);
  this.setBorder(blankBorder);
  this.add(fullPanel,FULL_LAYOUT);
  this.add(minPanel,MIN_LAYOUT);
  this.statusViewLayout.show(this,FULL_LAYOUT);
  minIconLabel=new JLabel();
  minTitleLabel=new LabelContainer();
  minStatusLabel=new JLabel();
  minStatusLabel.setFont(statusFontPlainMin);
  minStatusLabel.setForeground(statusLabelColour);
  minButtonPanel=new DownloadButtonPanel(editorListener);
  minButtonPanel.setOpaque(false);
  minLinkButton=new JXHyperlink();
  minLinkButton.addActionListener(editorListener);
  minLinkButton.setForeground(linkColour);
  minLinkButton.setClickedColor(linkColour);
  minLinkButton.setFont(statusFontPlainMin);
  fullIconLabel=new JLabel();
  fullTitleLabel=new LabelContainer();
  fullStatusLabel=new JLabel();
  fullStatusLabel.setFont(statusFontPlainFull);
  fullStatusLabel.setForeground(statusLabelColour);
  fullStatusLabel.setPreferredSize(new Dimension(20,20));
  fullProgressBar=progressBarFactory.create(0,100);
  Dimension size=new Dimension(progressBarWidth,16);
  fullProgressBar.setMaximumSize(size);
  fullProgressBar.setMinimumSize(size);
  fullProgressBar.setPreferredSize(size);
  fullTimeLabel=new JLabel();
  fullTimeLabel.setFont(statusFontPlainFull);
  fullButtonPanel=new DownloadButtonPanel(editorListener);
  fullButtonPanel.setOpaque(false);
  cancelLink=new HyperlinkButton();
  cancelLink.setText(I18n.tr(""String_Node_Str""));
  cancelLink.setFont(statusFontPlainMin);
  cancelLink.setActionCommand(DownloadActionHandler.CANCEL_COMMAND);
  FontUtils.underline(cancelLink);
  launchButton=new HyperlinkButton();
  launchButton.setText(I18n.tr(""String_Node_Str""));
  launchButton.setFont(statusFontPlainMin);
  launchButton.setActionCommand(DownloadActionHandler.LAUNCH_COMMAND);
  FontUtils.underline(launchButton);
  removeLinkSpacer=new JLabel(I18n.tr(""String_Node_Str""));
  removeLinkSpacer.setMinimumSize(new Dimension(0,cancelLink.getPreferredSize().height));
  removeLinkSpacer.setFont(statusFontPlainMin);
  removeLinkSpacer.setForeground(errorLabelColour);
  createFullView();
  createMinView();
}","private void initComponents(){
  this.setBackgroundPainter(this.createCellPainter());
  statusViewLayout=new CardLayout();
  this.setLayout(statusViewLayout);
  fullPanel=new JPanel(new GridBagLayout());
  minPanel=new JPanel(new GridBagLayout());
  fullPanel.setOpaque(false);
  minPanel.setOpaque(false);
  Border blankBorder=BorderFactory.createEmptyBorder(0,0,0,0);
  fullPanel.setBorder(blankBorder);
  minPanel.setBorder(blankBorder);
  this.setBorder(blankBorder);
  this.add(fullPanel,FULL_LAYOUT);
  this.add(minPanel,MIN_LAYOUT);
  this.statusViewLayout.show(this,FULL_LAYOUT);
  minIconLabel=new JLabel();
  minTitleLabel=new LabelContainer();
  minStatusLabel=new JLabel();
  minStatusLabel.setFont(statusFontPlainMin);
  minStatusLabel.setForeground(statusLabelColour);
  minButtonPanel=new DownloadButtonPanel(editorListener);
  minButtonPanel.setOpaque(false);
  minLinkButton=new JXHyperlink();
  minLinkButton.addActionListener(editorListener);
  minLinkButton.setForeground(linkColour);
  minLinkButton.setClickedColor(linkColour);
  minLinkButton.setFont(statusFontPlainMin);
  fullIconLabel=new JLabel();
  fullTitleLabel=new LabelContainer();
  fullStatusLabel=new JLabel();
  fullStatusLabel.setFont(statusFontPlainFull);
  fullStatusLabel.setForeground(statusLabelColour);
  fullProgressBar=progressBarFactory.create(0,100);
  Dimension size=new Dimension(progressBarWidth,16);
  fullProgressBar.setMaximumSize(size);
  fullProgressBar.setMinimumSize(size);
  fullProgressBar.setPreferredSize(size);
  fullTimeLabel=new JLabel();
  fullTimeLabel.setFont(statusFontPlainFull);
  fullButtonPanel=new DownloadButtonPanel(editorListener);
  fullButtonPanel.setOpaque(false);
  cancelLink=new HyperlinkButton();
  cancelLink.setText(I18n.tr(""String_Node_Str""));
  cancelLink.setFont(statusFontPlainMin);
  cancelLink.setActionCommand(DownloadActionHandler.CANCEL_COMMAND);
  FontUtils.underline(cancelLink);
  launchButton=new HyperlinkButton();
  launchButton.setText(I18n.tr(""String_Node_Str""));
  launchButton.setFont(statusFontPlainMin);
  launchButton.setActionCommand(DownloadActionHandler.LAUNCH_COMMAND);
  FontUtils.underline(launchButton);
  removeLinkSpacer=new JLabel(I18n.tr(""String_Node_Str""));
  removeLinkSpacer.setMinimumSize(new Dimension(0,cancelLink.getPreferredSize().height));
  removeLinkSpacer.setFont(statusFontPlainMin);
  removeLinkSpacer.setForeground(errorLabelColour);
  createFullView();
  createMinView();
}",0.988334674175382
3894,"public void updateLibraryPanel(EventList<RemoteFileItem> eventList,LibraryState libraryState){
  if (!disposed) {
switch (libraryState) {
case FAILED_TO_LOAD:
      this.eventList=null;
    emptyPanelMessage.setMessageType(MessageTypes.LW_CONNECTION_ERROR);
  if (!isSharingCardShown()) {
    showEmptyCard();
  }
break;
case LOADED:
if (eventList.size() == 0) {
emptyPanelMessage.setMessageType(MessageTypes.LW_NO_FILES);
if (!isSharingCardShown()) {
  showEmptyCard();
}
}
 else {
setLibraryCard(factory.createFriendLibrary(friend,friendFileList,eventList,this));
if (isEmptyCardShown()) {
  showLibraryCard();
}
}
break;
case LOADING:
if (this.eventList != eventList) {
this.eventList=eventList;
}
if (eventList.size() == 0) {
emptyPanelMessage.setMessageType(MessageTypes.LW_LOADING);
if (!isSharingCardShown()) {
showEmptyCard();
}
}
 else {
setLibraryCard(factory.createFriendLibrary(friend,friendFileList,eventList,this));
if (isEmptyCardShown()) {
showLibraryCard();
}
}
break;
}
}
}","public void updateLibraryPanel(EventList<RemoteFileItem> eventList,LibraryState libraryState){
  if (!disposed) {
switch (libraryState) {
case FAILED_TO_LOAD:
      this.eventList=null;
    emptyPanelMessage.setMessageType(MessageTypes.LW_CONNECTION_ERROR);
  if (!isSharingCardShown()) {
    showEmptyCard();
  }
break;
case LOADED:
if (this.eventList != eventList) {
this.eventList=eventList;
}
if (eventList.size() == 0) {
emptyPanelMessage.setMessageType(MessageTypes.LW_NO_FILES);
if (!isSharingCardShown()) {
showEmptyCard();
}
}
 else {
setLibraryCard(factory.createFriendLibrary(friend,friendFileList,eventList,this));
if (isEmptyCardShown()) {
super.showLibraryCard();
}
}
break;
case LOADING:
if (this.eventList != eventList) {
this.eventList=eventList;
}
if (eventList.size() == 0) {
emptyPanelMessage.setMessageType(MessageTypes.LW_LOADING);
if (!isSharingCardShown()) {
showEmptyCard();
}
}
 else {
setLibraryCard(factory.createFriendLibrary(friend,friendFileList,eventList,this));
if (isEmptyCardShown()) {
super.showLibraryCard();
}
}
break;
}
}
}",0.961519727228446
3895,"private void configureTable(EventList<VisualSearchResult> eventList,final ResultsTableFormat<VisualSearchResult> tableFormat,Navigator navigator,PropertiesFactory<VisualSearchResult> properties){
  CollectionList<VisualSearchResult,VisualSearchResult> explodedParentResults=new CollectionList<VisualSearchResult,VisualSearchResult>(eventList,new CollectionList.Model<VisualSearchResult,VisualSearchResult>(){
    @Override public List<VisualSearchResult> getChildren(    VisualSearchResult parent){
      return parent.getSimilarResults();
    }
  }
);
  CompositeList<VisualSearchResult> allTogetherList=new CompositeList<VisualSearchResult>(eventList.getPublisher(),eventList.getReadWriteLock());
  allTogetherList.addMemberList(eventList);
  allTogetherList.addMemberList(explodedParentResults);
  SortedList<VisualSearchResult> sortedList=new SortedList<VisualSearchResult>(allTogetherList);
  resultsTable=new ConfigurableTable<VisualSearchResult>(sortedList,tableFormat,true);
  EventListJXTableSorting.install(resultsTable,sortedList);
  setupCellRenderers(tableFormat);
  resultsTable.setPopupHandler(new SearchPopupHandler(resultsTable,this,properties));
  resultsTable.setDoubleClickHandler(new ClassicDoubleClickHandler(resultsTable,this,navigator,libraryNavigator));
  resultsTable.setRowHeight(TABLE_ROW_HEIGHT);
  resultsTable.setupColumnHandler();
  TableColors tableColors=new TableColors();
  resultsTable.addHighlighter(new ColorHighlighter(new DownloadedHighlightPredicate(sortedList),null,tableColors.getDisabledForegroundColor(),null,tableColors.getDisabledForegroundColor()));
}","private void configureTable(EventList<VisualSearchResult> eventList,final ResultsTableFormat<VisualSearchResult> tableFormat,Navigator navigator,PropertiesFactory<VisualSearchResult> properties){
  SortedList<VisualSearchResult> sortedList=new SortedList<VisualSearchResult>(eventList);
  resultsTable=new ConfigurableTable<VisualSearchResult>(sortedList,tableFormat,true);
  EventListJXTableSorting.install(resultsTable,sortedList);
  setupCellRenderers(tableFormat);
  resultsTable.setPopupHandler(new SearchPopupHandler(resultsTable,this,properties));
  resultsTable.setDoubleClickHandler(new ClassicDoubleClickHandler(resultsTable,this,navigator,libraryNavigator));
  resultsTable.setRowHeight(TABLE_ROW_HEIGHT);
  resultsTable.setupColumnHandler();
  TableColors tableColors=new TableColors();
  resultsTable.addHighlighter(new ColorHighlighter(new DownloadedHighlightPredicate(sortedList),null,tableColors.getDisabledForegroundColor(),null,tableColors.getDisabledForegroundColor()));
}",0.743342338865303
3896,"public void run(){
  reviewBug(info);
}","public void run(){
  dialog.dispose();
  System.exit(1);
}",0.5773195876288659
3897,"public void actionPerformed(ActionEvent e){
  String userComments=userCommentsTextArea.getText();
  if (!userComments.equals(defaultDesc))   info.addUserComments(userComments);
  sendToServlet(info);
  dialog.dispose();
}","public void actionPerformed(ActionEvent e){
  String userComments=userCommentsTextArea.getText();
  if (!userComments.equals(defaultDesc))   info.addUserComments(userComments);
  sendButton.setEnabled(false);
  sendButton.setText(""String_Node_Str"");
  new Thread(""String_Node_Str""){
    public void run(){
      try {
        sendToServlet(info);
      }
  finally {
        SwingUtilities.invokeLater(new Runnable(){
          public void run(){
            dialog.dispose();
            System.exit(1);
          }
        }
);
      }
    }
  }
.start();
}",0.4794871794871795
3898,"/** 
 * Reviews the bug.
 */
public static void reviewBug(final LocalClientInfo info){
  final JDialog dialog=new LimeJDialog();
  dialog.setSize(new Dimension(300,100));
  dialog.setTitle(""String_Node_Str"");
  JPanel mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  mainPanel.setLayout(new GridBagLayout());
  String msg=""String_Node_Str"";
  MultiLineLabel label=new MultiLineLabel(msg,500);
  JPanel labelPanel=new JPanel();
  labelPanel.setLayout(new GridBagLayout());
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=0;
  constraints.gridwidth=GridBagConstraints.REMAINDER;
  constraints.gridheight=GridBagConstraints.REMAINDER;
  constraints.weightx=1.0;
  constraints.weighty=1.0;
  labelPanel.add(label,constraints);
  final JPanel bugSpecificsPanel=new JPanel();
  bugSpecificsPanel.setLayout(new GridBagLayout());
  bugSpecificsPanel.setVisible(false);
  JTextArea showBug=new JTextArea(info.toBugReport());
  showBug.setColumns(50);
  showBug.setEditable(false);
  showBug.setCaretPosition(0);
  showBug.setLineWrap(true);
  showBug.setWrapStyleWord(true);
  JScrollPane showBugScroller=new JScrollPane(showBug);
  showBugScroller.setBorder(BorderFactory.createEtchedBorder());
  showBugScroller.setPreferredSize(new Dimension(500,200));
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=0;
  bugSpecificsPanel.add(showBugScroller,constraints);
  final String defaultDesc=""String_Node_Str"";
  final JTextArea userCommentsTextArea=new JTextArea(defaultDesc);
  userCommentsTextArea.setLineWrap(true);
  userCommentsTextArea.setWrapStyleWord(true);
  userCommentsTextArea.addFocusListener(new FocusAdapter(){
    @Override public void focusGained(    FocusEvent e){
      if (userCommentsTextArea.getText().equals(defaultDesc)) {
        userCommentsTextArea.selectAll();
      }
    }
  }
);
  JScrollPane userCommentsScrollPane=new JScrollPane(userCommentsTextArea);
  userCommentsScrollPane.setBorder(BorderFactory.createEtchedBorder());
  userCommentsScrollPane.setPreferredSize(new Dimension(500,60));
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=1;
  constraints.insets=new Insets(10,0,0,0);
  bugSpecificsPanel.add(userCommentsScrollPane,constraints);
  final HyperlinkButton showHideBugLink=new HyperlinkButton(""String_Node_Str"");
  showHideBugLink.addActionListener(new AbstractAction(){
    boolean panelVisible=false;
    @Override public void actionPerformed(    ActionEvent e){
      if (panelVisible) {
        bugSpecificsPanel.setVisible(false);
        showHideBugLink.setText(""String_Node_Str"");
        dialog.pack();
      }
 else {
        bugSpecificsPanel.setVisible(true);
        showHideBugLink.setText(""String_Node_Str"");
      }
      dialog.pack();
      panelVisible=!panelVisible;
    }
  }
);
  JButton sendButton=new JButton(""String_Node_Str"");
  sendButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      String userComments=userCommentsTextArea.getText();
      if (!userComments.equals(defaultDesc))       info.addUserComments(userComments);
      sendToServlet(info);
      dialog.dispose();
    }
  }
);
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=0;
  mainPanel.add(labelPanel,constraints);
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=1;
  constraints.insets=new Insets(10,0,0,0);
  constraints.anchor=GridBagConstraints.LINE_START;
  mainPanel.add(showHideBugLink,constraints);
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=2;
  constraints.fill=GridBagConstraints.BOTH;
  constraints.weightx=1.0;
  constraints.weighty=1.0;
  constraints.insets=new Insets(30,0,6,0);
  mainPanel.add(bugSpecificsPanel,constraints);
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=4;
  mainPanel.add(sendButton,constraints);
  mainPanel.validate();
  dialog.getContentPane().add(mainPanel);
  dialog.pack();
  sendButton.requestFocusInWindow();
  dialog.setLocationRelativeTo(null);
  for (  Window window : Window.getWindows()) {
    if (window == dialog) {
      continue;
    }
    window.setVisible(false);
    window.dispose();
  }
  dialog.setVisible(true);
  dialog.toFront();
}","/** 
 * Reviews the bug.
 */
public static void reviewBug(final LocalClientInfo info){
  final JDialog dialog=new LimeJDialog();
  dialog.setSize(new Dimension(300,100));
  dialog.setTitle(""String_Node_Str"");
  JPanel mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  mainPanel.setLayout(new GridBagLayout());
  String msg=""String_Node_Str"";
  MultiLineLabel label=new MultiLineLabel(msg,500);
  JPanel labelPanel=new JPanel();
  labelPanel.setLayout(new GridBagLayout());
  GridBagConstraints constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=0;
  constraints.gridwidth=GridBagConstraints.REMAINDER;
  constraints.gridheight=GridBagConstraints.REMAINDER;
  constraints.weightx=1.0;
  constraints.weighty=1.0;
  labelPanel.add(label,constraints);
  final JPanel bugSpecificsPanel=new JPanel();
  bugSpecificsPanel.setLayout(new GridBagLayout());
  bugSpecificsPanel.setVisible(false);
  JTextArea showBug=new JTextArea(info.toBugReport());
  showBug.setColumns(50);
  showBug.setEditable(false);
  showBug.setCaretPosition(0);
  showBug.setLineWrap(true);
  showBug.setWrapStyleWord(true);
  JScrollPane showBugScroller=new JScrollPane(showBug);
  showBugScroller.setBorder(BorderFactory.createEtchedBorder());
  showBugScroller.setPreferredSize(new Dimension(500,200));
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=0;
  bugSpecificsPanel.add(showBugScroller,constraints);
  final String defaultDesc=""String_Node_Str"";
  final JTextArea userCommentsTextArea=new JTextArea(defaultDesc);
  userCommentsTextArea.setLineWrap(true);
  userCommentsTextArea.setWrapStyleWord(true);
  userCommentsTextArea.addFocusListener(new FocusAdapter(){
    @Override public void focusGained(    FocusEvent e){
      if (userCommentsTextArea.getText().equals(defaultDesc)) {
        userCommentsTextArea.selectAll();
      }
    }
  }
);
  JScrollPane userCommentsScrollPane=new JScrollPane(userCommentsTextArea);
  userCommentsScrollPane.setBorder(BorderFactory.createEtchedBorder());
  userCommentsScrollPane.setPreferredSize(new Dimension(500,60));
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=1;
  constraints.insets=new Insets(10,0,0,0);
  bugSpecificsPanel.add(userCommentsScrollPane,constraints);
  final HyperlinkButton showHideBugLink=new HyperlinkButton(""String_Node_Str"");
  showHideBugLink.addActionListener(new AbstractAction(){
    boolean panelVisible=false;
    @Override public void actionPerformed(    ActionEvent e){
      if (panelVisible) {
        bugSpecificsPanel.setVisible(false);
        showHideBugLink.setText(""String_Node_Str"");
        dialog.pack();
      }
 else {
        bugSpecificsPanel.setVisible(true);
        showHideBugLink.setText(""String_Node_Str"");
      }
      dialog.pack();
      panelVisible=!panelVisible;
    }
  }
);
  final JButton sendButton=new JButton(""String_Node_Str"");
  sendButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      String userComments=userCommentsTextArea.getText();
      if (!userComments.equals(defaultDesc))       info.addUserComments(userComments);
      sendButton.setEnabled(false);
      sendButton.setText(""String_Node_Str"");
      new Thread(""String_Node_Str""){
        public void run(){
          try {
            sendToServlet(info);
          }
  finally {
            SwingUtilities.invokeLater(new Runnable(){
              public void run(){
                dialog.dispose();
                System.exit(1);
              }
            }
);
          }
        }
      }
.start();
    }
  }
);
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=0;
  mainPanel.add(labelPanel,constraints);
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=1;
  constraints.insets=new Insets(10,0,0,0);
  constraints.anchor=GridBagConstraints.LINE_START;
  mainPanel.add(showHideBugLink,constraints);
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=2;
  constraints.fill=GridBagConstraints.BOTH;
  constraints.weightx=1.0;
  constraints.weighty=1.0;
  constraints.insets=new Insets(30,0,6,0);
  mainPanel.add(bugSpecificsPanel,constraints);
  constraints=new GridBagConstraints();
  constraints.gridx=0;
  constraints.gridy=4;
  mainPanel.add(sendButton,constraints);
  mainPanel.validate();
  dialog.getContentPane().add(mainPanel);
  dialog.pack();
  sendButton.requestFocusInWindow();
  dialog.setLocationRelativeTo(null);
  for (  Window window : Window.getWindows()) {
    if (window == dialog) {
      continue;
    }
    window.setVisible(false);
    window.dispose();
  }
  dialog.setVisible(true);
  dialog.toFront();
}",0.9526820758831226
3899,"/** 
 * Contacts the application servlet and sends it the information  contained in the <tt>LocalClientInfo</tt> object.  This method  also builds a <tt>RemoteClientInfo</tt> object from the information  obtained from the servlet.
 * @return a <tt>RemoteClientInfo</tt> object that encapsulates the data about when to next send a bug.
 * @param localInfo is an object encapsulating information about thelocal machine to send to the remote server
 */
synchronized RemoteClientInfo getRemoteBugInfo(LocalClientInfo localInfo){
  RemoteClientInfo remoteInfo=new RemoteClientInfo();
  HttpResponse response=null;
  LimeHttpClient client=ALLOW_NIO ? limeHttpClient.get() : new SimpleLimeHttpClient();
  try {
    NameValuePair[] params=getNameValuePairs(localInfo.getPostRequestParams());
    HttpPost post=new HttpPost(SERVLET_URL);
    post.addHeader(""String_Node_Str"",""String_Node_Str"");
    post.addHeader(""String_Node_Str"",LimeWireUtils.getHttpServer());
    post.addHeader(""String_Node_Str"",""String_Node_Str"");
    post.setEntity(new UrlEncodedFormEntity(Arrays.asList(params)));
    HttpConnectionParams.setConnectionTimeout(client.getParams(),CONNECT_TIMEOUT);
    HttpClientParams.setRedirecting(client.getParams(),false);
    response=client.execute(post);
    String result;
    if (response.getEntity() != null) {
      result=EntityUtils.toString(response.getEntity());
    }
 else {
      result=null;
    }
    String body=result;
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + response);
    if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK)     remoteInfo.addRemoteInfo(body);
 else {
      if (LOG.isWarnEnabled())       LOG.warn(""String_Node_Str"" + response.getStatusLine().getStatusCode());
      remoteInfo.connectFailed();
    }
  }
 catch (  IOException e) {
    fail(remoteInfo,e);
  }
 finally {
    client.releaseConnection(response);
  }
  return remoteInfo;
}","/** 
 * Contacts the application servlet and sends it the information  contained in the <tt>LocalClientInfo</tt> object.  This method  also builds a <tt>RemoteClientInfo</tt> object from the information  obtained from the servlet.
 * @return a <tt>RemoteClientInfo</tt> object that encapsulates the data about when to next send a bug.
 * @param localInfo is an object encapsulating information about thelocal machine to send to the remote server
 */
synchronized RemoteClientInfo getRemoteBugInfo(LocalClientInfo localInfo){
  RemoteClientInfo remoteInfo=new RemoteClientInfo();
  HttpResponse response=null;
  LimeHttpClient client=ALLOW_NIO && limeHttpClient != null ? limeHttpClient.get() : new SimpleLimeHttpClient();
  try {
    NameValuePair[] params=getNameValuePairs(localInfo.getPostRequestParams());
    HttpPost post=new HttpPost(SERVLET_URL);
    post.addHeader(""String_Node_Str"",""String_Node_Str"");
    post.addHeader(""String_Node_Str"",LimeWireUtils.getHttpServer());
    post.addHeader(""String_Node_Str"",""String_Node_Str"");
    post.setEntity(new UrlEncodedFormEntity(Arrays.asList(params)));
    HttpConnectionParams.setConnectionTimeout(client.getParams(),CONNECT_TIMEOUT);
    HttpClientParams.setRedirecting(client.getParams(),false);
    response=client.execute(post);
    String result;
    if (response.getEntity() != null) {
      result=EntityUtils.toString(response.getEntity());
    }
 else {
      result=null;
    }
    String body=result;
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + response);
    if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK)     remoteInfo.addRemoteInfo(body);
 else {
      if (LOG.isWarnEnabled())       LOG.warn(""String_Node_Str"" + response.getStatusLine().getStatusCode());
      remoteInfo.connectFailed();
    }
  }
 catch (  IOException e) {
    fail(remoteInfo,e);
  }
 finally {
    client.releaseConnection(response);
  }
  return remoteInfo;
}",0.9932572614107884
3900,"@Override public FriendFileList getOrCreateFriendShareList(Friend friend){
  LOG.debugf(""String_Node_Str"",friend.getId());
  if (friendLocalFileLists.containsKey(friend.getId())) {
    LOG.debugf(""String_Node_Str"",friend.getId());
    return friendLocalFileLists.get(friend.getId());
  }
  FriendFileListImpl newList=new FriendFileListImpl(fileManager,friend.getId());
  FriendFileList existing=friendLocalFileLists.putIfAbsent(friend.getId(),newList);
  if (existing == null) {
    LOG.debugf(""String_Node_Str"",friend.getId());
    newList.commit();
    friendShareListEventListener.handleEvent(new FriendShareListEvent(FriendShareListEvent.Type.FRIEND_SHARE_LIST_ADDED,newList,friend));
    return newList;
  }
 else {
    LOG.debugf(""String_Node_Str"",friend.getId());
    newList.dispose();
    return existing;
  }
}","@Override public FriendFileList getOrCreateFriendShareList(Friend friend){
  LOG.debugf(""String_Node_Str"",friend.getId());
  FriendFileList list=friendLocalFileLists.get(friend.getId());
  if (list != null) {
    LOG.debugf(""String_Node_Str"",friend.getId());
    return list;
  }
  FriendFileListImpl newList=new FriendFileListImpl(fileManager,friend.getId());
  FriendFileList existing=friendLocalFileLists.putIfAbsent(friend.getId(),newList);
  if (existing == null) {
    LOG.debugf(""String_Node_Str"",friend.getId());
    newList.commit();
    friendShareListEventListener.handleEvent(new FriendShareListEvent(FriendShareListEvent.Type.FRIEND_SHARE_LIST_ADDED,newList,friend));
    return newList;
  }
 else {
    LOG.debugf(""String_Node_Str"",friend.getId());
    newList.dispose();
    return existing;
  }
}",0.9178921568627452
3901,"public RemoteFileItem create(FriendPresence presence,FileMetaData fileMetaData) throws InvalidDataException, SaveLocationException {
  RemoteFileDesc remoteFileDesc=createRfdFromChatResult(presence,fileMetaData);
  RemoteFileDescAdapter remoteFileDescAdapter=new RemoteFileDescAdapter(remoteFileDescDeserializer.createClone(remoteFileDesc,(XMPPAddress)((AddressFeature)presence.getFeature(AddressFeature.ID)).getFeature()),IpPort.EMPTY_SET,presence);
  return new CoreRemoteFileItem(remoteFileDescAdapter);
}","public RemoteFileItem create(FriendPresence presence,FileMetaData fileMetaData) throws InvalidDataException, SaveLocationException {
  XMPPAddress presenceAddress=getAddressFromPresence(presence);
  RemoteFileDesc remoteFileDesc=createRfdFromChatResult(presenceAddress,fileMetaData);
  RemoteFileDescAdapter remoteFileDescAdapter=new RemoteFileDescAdapter(remoteFileDescDeserializer.createClone(remoteFileDesc,presenceAddress),IpPort.EMPTY_SET,presence);
  return new CoreRemoteFileItem(remoteFileDescAdapter);
}",0.4686274509803921
3902,"private RemoteFileDesc createRfdFromChatResult(FriendPresence presence,FileMetaData fileMeta) throws SaveLocationException, InvalidDataException {
  Address address=((AddressFeature)presence.getFeature(AddressFeature.ID)).getFeature();
  byte[] clientGuid=DataUtils.EMPTY_GUID;
  Set<String> urnsAsString=fileMeta.getURNsAsString();
  Set<URN> urns=new HashSet<URN>();
  for (  String urnStr : urnsAsString) {
    try {
      urns.add(URN.createUrnFromString(urnStr));
    }
 catch (    IOException iox) {
      throw new InvalidDataException(iox);
    }
  }
  return remoteFileDescFactory.createRemoteFileDesc(address,fileMeta.getIndex(),fileMeta.getName(),fileMeta.getSize(),clientGuid,0,false,0,true,null,urns,false,null,fileMeta.getCreateTime().getTime());
}","private RemoteFileDesc createRfdFromChatResult(XMPPAddress address,FileMetaData fileMeta) throws SaveLocationException, InvalidDataException {
  byte[] clientGuid=DataUtils.EMPTY_GUID;
  Set<String> urnsAsString=fileMeta.getURNsAsString();
  Set<URN> urns=new HashSet<URN>();
  for (  String urnStr : urnsAsString) {
    try {
      urns.add(URN.createUrnFromString(urnStr));
    }
 catch (    IOException iox) {
      throw new InvalidDataException(iox);
    }
  }
  return remoteFileDescFactory.createRemoteFileDesc(address,fileMeta.getIndex(),fileMeta.getName(),fileMeta.getSize(),clientGuid,0,false,0,true,null,urns,false,null,fileMeta.getCreateTime().getTime());
}",0.909853249475891
3903,"public static void assertFileRenameFails(String reason,ManagedFileList fileList,File old,File newFile) throws Exception {
  FileDesc oldFd=fileList.getFileDesc(old);
  Future<FileDesc> future=fileList.fileRenamed(old,newFile);
  try {
    future.get(1,TimeUnit.SECONDS);
    fail(""String_Node_Str"");
  }
 catch (  ExecutionException expected) {
    assertInstanceof(FileListChangeFailedException.class,expected.getCause());
    FileListChangeFailedException cause=(FileListChangeFailedException)expected.getCause();
    assertEquals(FileListChangedEvent.Type.CHANGE_FAILED,cause.getEvent().getType());
    assertEquals(old,cause.getEvent().getOldFile());
    assertEquals(newFile,cause.getEvent().getFile());
    assertEquals(oldFd,cause.getEvent().getOldValue());
    assertEquals(reason,cause.getReason());
  }
}","public static void assertFileRenameFails(String reason,ManagedFileList fileList,File old,File newFile) throws Exception {
  FileDesc oldFd=fileList.getFileDesc(old);
  Future<FileDesc> future=fileList.fileRenamed(old,newFile);
  try {
    future.get(1,TimeUnit.SECONDS);
    fail(""String_Node_Str"");
  }
 catch (  ExecutionException expected) {
    assertInstanceof(FileListChangeFailedException.class,expected.getCause());
    FileListChangeFailedException cause=(FileListChangeFailedException)expected.getCause();
    assertEquals(FileListChangedEvent.Type.CHANGE_FAILED,cause.getEvent().getType());
    assertEquals(old,cause.getEvent().getOldFile());
    assertEquals(newFile,cause.getEvent().getFile());
    assertEquals(oldFd,cause.getEvent().getOldValue());
    assertEquals(reason,cause.getReason().toString());
  }
}",0.9932885906040269
3904,"public static void assertFileChangedFails(String reason,ManagedFileList fileList,File file) throws Exception {
  FileDesc oldFd=fileList.getFileDesc(file);
  Future<FileDesc> future=fileList.fileChanged(file,LimeXMLDocument.EMPTY_LIST);
  try {
    future.get(1,TimeUnit.SECONDS);
    fail(""String_Node_Str"");
  }
 catch (  ExecutionException expected) {
    assertInstanceof(FileListChangeFailedException.class,expected.getCause());
    FileListChangeFailedException cause=(FileListChangeFailedException)expected.getCause();
    assertEquals(FileListChangedEvent.Type.CHANGE_FAILED,cause.getEvent().getType());
    assertEquals(file,cause.getEvent().getOldFile());
    assertEquals(file,cause.getEvent().getFile());
    assertEquals(oldFd,cause.getEvent().getOldValue());
    assertEquals(reason,cause.getReason());
  }
}","public static void assertFileChangedFails(String reason,ManagedFileList fileList,File file) throws Exception {
  FileDesc oldFd=fileList.getFileDesc(file);
  Future<FileDesc> future=fileList.fileChanged(file,LimeXMLDocument.EMPTY_LIST);
  try {
    future.get(1,TimeUnit.SECONDS);
    fail(""String_Node_Str"");
  }
 catch (  ExecutionException expected) {
    assertInstanceof(FileListChangeFailedException.class,expected.getCause());
    FileListChangeFailedException cause=(FileListChangeFailedException)expected.getCause();
    assertEquals(FileListChangedEvent.Type.CHANGE_FAILED,cause.getEvent().getType());
    assertEquals(file,cause.getEvent().getOldFile());
    assertEquals(file,cause.getEvent().getFile());
    assertEquals(oldFd,cause.getEvent().getOldValue());
    assertEquals(reason,cause.getReason().toString());
  }
}",0.9933534743202416
3905,"public static void assertAddFails(String reason,FileList fileList,File... files) throws Exception {
  for (  File file : files) {
    try {
      FileDesc fd=fileList.add(file).get(5,TimeUnit.SECONDS);
      fail(""String_Node_Str"" + fd);
    }
 catch (    ExecutionException expected) {
      assertInstanceof(FileListChangeFailedException.class,expected.getCause());
      FileListChangeFailedException cause=(FileListChangeFailedException)expected.getCause();
      assertEquals(FileListChangedEvent.Type.ADD_FAILED,cause.getEvent().getType());
      assertEquals(file,cause.getEvent().getFile());
      assertEquals(reason,cause.getReason());
    }
  }
}","public static void assertAddFails(String reason,FileList fileList,File... files) throws Exception {
  for (  File file : files) {
    try {
      FileDesc fd=fileList.add(file).get(5,TimeUnit.SECONDS);
      fail(""String_Node_Str"" + fd);
    }
 catch (    ExecutionException expected) {
      assertInstanceof(FileListChangeFailedException.class,expected.getCause());
      FileListChangeFailedException cause=(FileListChangeFailedException)expected.getCause();
      assertEquals(FileListChangedEvent.Type.ADD_FAILED,cause.getEvent().getType());
      assertEquals(file,cause.getEvent().getFile());
      assertEquals(reason,cause.getReason().toString());
    }
  }
}",0.9916981132075472
3906,"private void initManualPanel(){
  RootLibraryManagerItem root=new RootLibraryManagerItem(AutoDirectoryManageConfig.getDefaultManagedDirectories(libraryData));
  Collection<File> autoManage=AutoDirectoryManageConfig.getDefaultManagedDirectories(libraryData);
  for (  File file : autoManage) {
    root.addChild(new LibraryManagerItemImpl(root,libraryData,file,false));
  }
  if (shouldKeepExistingDirectorySettings) {
    for (    File file : libraryData.getDirectoriesToManageRecursively()) {
      root.addChild(new LibraryManagerItemImpl(root,libraryData,file,false));
    }
  }
  treeTable.setTreeTableModel(new LibraryManagerModel(root));
}","private void initManualPanel(){
  RootLibraryManagerItem root=new RootLibraryManagerItem(AutoDirectoryManageConfig.getDefaultManagedDirectories(libraryData));
  Set<File> totalList=new HashSet<File>();
  totalList.addAll(AutoDirectoryManageConfig.getDefaultManagedDirectories(libraryData));
  if (shouldKeepExistingDirectorySettings) {
    totalList.addAll(libraryData.getDirectoriesToManageRecursively());
  }
  for (  File file : totalList) {
    root.addChild(new LibraryManagerItemImpl(root,libraryData,file,false));
  }
  treeTable.setTreeTableModel(new LibraryManagerModel(root));
}",0.6001622060016221
3907,"@Inject FriendStatusPanel(final FriendActions friendActions,final ChatFramePanel friendsPanel,IconLibrary iconLibrary){
  GuiUtils.assignResources(this);
  JPanel chatPanel=new JPanel(new BorderLayout());
  Border insideBorder=BorderFactory.createEmptyBorder(-1,0,0,0);
  Border outsideBorder=BorderFactory.createLineBorder(buttonBorderColor);
  chatPanelVisibleBorder=new CompoundBorder(insideBorder,outsideBorder);
  chatPanel.setOpaque(true);
  chatPanel.setBackground(chatBackground);
  chatButton=new JXButton(new AbstractAction(I18n.tr(""String_Node_Str"")){
    @Override public void actionPerformed(    ActionEvent e){
      if (!friendActions.isSignedIn()) {
        friendActions.signIn();
      }
 else {
        friendsPanel.setAdjacentEdgeWidth(mainComponent.getWidth());
        friendsPanel.toggleVisibility();
        mainComponent.setBorder(friendsPanel.isVisible() ? chatPanelVisibleBorder : null);
        chatButton.setSize(chatButton.getWidth(),chatButton.getHeight() + 1);
      }
    }
  }
);
  RectanglePainter<JXButton> backgroundPainter=new RectanglePainter<JXButton>(chatBackground,chatBackground);
  backgroundPainter.setBorderWidth(0.0f);
  chatButton.setBackgroundPainter(backgroundPainter);
  chatButton.setIcon(iconLibrary.getChatting());
  chatButton.setFont(chatButtonFont);
  chatButton.setForeground(chatButtonForeground);
  chatButton.setFocusPainted(false);
  chatButton.setHorizontalAlignment(AbstractButton.LEFT);
  chatButton.setHorizontalTextPosition(AbstractButton.RIGHT);
  Insets insets=new Insets(1,2,0,25);
  chatButton.setMargin(insets);
  chatButton.setPaintBorderInsets(true);
  chatPanel.add(chatButton);
  friendsPanel.setUnseenMessageListener(new UnseenMessageFlasher(chatButton,iconLibrary));
  mainComponent=chatPanel;
}","@Inject FriendStatusPanel(final ChatFramePanel friendsPanel,IconLibrary iconLibrary){
  GuiUtils.assignResources(this);
  JPanel chatPanel=new JPanel(new BorderLayout());
  chatPanel.setBorder(BorderFactory.createEmptyBorder(0,0,0,25));
  Border insideBorder=BorderFactory.createEmptyBorder(-1,0,0,0);
  Border outsideBorder=BorderFactory.createLineBorder(buttonBorderColor);
  chatPanelVisibleBorder=new CompoundBorder(insideBorder,outsideBorder);
  chatPanel.setOpaque(true);
  chatPanel.setBackground(chatBackground);
  final RectanglePainter<JXButton> backgroundPainter=new RectanglePainter<JXButton>();
  chatButton=new JXButton(new AbstractAction(I18n.tr(""String_Node_Str"")){
    @Override public void actionPerformed(    ActionEvent e){
      friendsPanel.setAdjacentEdgeWidth(mainComponent.getWidth());
      friendsPanel.toggleVisibility();
      boolean friendsVisible=friendsPanel.isVisible();
      backgroundPainter.setBorderPaint(friendsVisible ? chatBackground : null);
      mainComponent.setBorder(friendsVisible ? chatPanelVisibleBorder : null);
    }
  }
);
  backgroundPainter.setFillPaint(chatBackground);
  backgroundPainter.setBorderWidth(0.0f);
  chatButton.setBackgroundPainter(backgroundPainter);
  chatButton.setIcon(iconLibrary.getChatting());
  chatButton.setFont(chatButtonFont);
  chatButton.setForeground(chatButtonForeground);
  chatButton.setFocusPainted(false);
  chatButton.setHorizontalAlignment(AbstractButton.LEFT);
  chatPanel.add(chatButton);
  friendsPanel.setUnseenMessageListener(new UnseenMessageFlasher(chatButton,iconLibrary));
  mainComponent=chatPanel;
}",0.7695497630331753
3908,"@Override public void applySettings(){
  InstallSettings.SCAN_FILES.setValue(true);
  Collection<File> manage;
  Collection<File> exclude;
  if (manualButton.isSelected()) {
    LibraryManagerModel model=treeTable.getLibraryModel();
    manage=model.getRootChildrenAsFiles();
    exclude=model.getAllExcludedSubfolders();
  }
 else {
    manage=AutoDirectoryManageConfig.getDefaultManagedDirectories(libraryData);
    exclude=Collections.emptySet();
  }
  libraryData.setManagedOptions(manage,exclude,libraryData.getManagedCategories());
}","@Override public void applySettings(){
  InstallSettings.SCAN_FILES.setValue(true);
  Collection<File> manage;
  Collection<File> exclude=new HashSet<File>();
  if (manualButton.isSelected()) {
    LibraryManagerModel model=treeTable.getLibraryModel();
    manage=model.getRootChildrenAsFiles();
    exclude.addAll(model.getAllExcludedSubfolders());
  }
 else {
    manage=new HashSet<File>();
    manage.addAll(AutoDirectoryManageConfig.getDefaultManagedDirectories(libraryData));
    manage.addAll(libraryData.getDirectoriesToManageRecursively());
  }
  exclude.addAll(libraryData.getDirectoriesToExcludeFromManaging());
  libraryData.setManagedOptions(manage,exclude,libraryData.getManagedCategories());
}",0.8115477145148356
3909,"private Painter<JTextField> createStatusBackgroundPainter(){
  CompoundPainter<JTextField> compoundPainter=new CompoundPainter<JTextField>();
  RectanglePainter<JTextField> painter=new RectanglePainter<JTextField>();
  painter.setRounded(true);
  painter.setFillPaint(innerBackground);
  painter.setRoundWidth(this.arcWidth);
  painter.setRoundHeight(this.arcHeight);
  painter.setInsets(new Insets(2,2,2,2));
  painter.setBorderPaint(null);
  painter.setFillVertical(true);
  painter.setFillHorizontal(true);
  painter.setAntialiasing(true);
  painter.setCacheable(true);
  compoundPainter.setPainters(painter,new BorderPainter<JTextField>(this.arcWidth,this.arcHeight,this.innerBorder,this.bevelLeft,this.bevelTop1,this.bevelTop2,this.bevelRight,this.bevelBottom,AccentType.SHADOW));
  compoundPainter.setCacheable(true);
  return compoundPainter;
}","private Painter<JXPanel> createStatusBackgroundPainter(){
  CompoundPainter<JXPanel> compoundPainter=new CompoundPainter<JXPanel>();
  RectanglePainter<JXPanel> painter=new RectanglePainter<JXPanel>();
  painter.setRounded(true);
  painter.setFillPaint(innerBackground);
  painter.setRoundWidth(this.arcWidth);
  painter.setRoundHeight(this.arcHeight);
  painter.setInsets(new Insets(2,2,2,2));
  painter.setBorderPaint(null);
  painter.setFillVertical(true);
  painter.setFillHorizontal(true);
  painter.setAntialiasing(true);
  painter.setCacheable(true);
  compoundPainter.setPainters(painter,new BorderPainter<JXPanel>(this.arcWidth,this.arcHeight,this.innerBorder,this.bevelLeft,this.bevelTop1,this.bevelTop2,this.bevelRight,this.bevelBottom,AccentType.SHADOW));
  compoundPainter.setCacheable(true);
  return compoundPainter;
}",0.9465558194774348
3910,"public IntentDialog(){
  super();
  ResizeUtils.forceSize(this,new Dimension(590,400));
  setTitle(title);
  setModal(true);
  setResizable(false);
  setAlwaysOnTop(true);
  JPanel contentPane=new JPanel(new BorderLayout());
  contentPane.setBackground(backgroundColor);
  add(contentPane);
  JPanel panel=new JPanel(new MigLayout(""String_Node_Str""));
  panel.setOpaque(false);
  headingLabel=new JLabel();
  headingLabel.setFont(headingFont);
  agreeLabel=new MultiLineLabel(""String_Node_Str"",500);
  agreeLabel.setFont(normalFont);
  linkButton=new HyperlinkButton(""String_Node_Str"",urlAction);
  linkButton.setFont(normalFont);
  linkButton.setForeground(new Color(0x2152a6));
  bodyLabel=new MultiLineLabel(""String_Node_Str"",500);
  bodyLabel.setFont(normalFont);
  agreeButton=new JButton();
  exitButton=new JButton();
  setTextContents();
  int indent=50;
  panel.add(headingLabel,""String_Node_Str"");
  panel.add(bodyLabel,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(linkButton,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(agreeLabel,""String_Node_Str"" + indent + ""String_Node_Str"");
  JPanel bottomPanel=new JPanel(new BorderLayout());
  bottomPanel.setOpaque(false);
  JPanel innerPanel=new JPanel(new FlowLayout());
  innerPanel.setOpaque(false);
  innerPanel.add(agreeButton);
  innerPanel.add(exitButton);
  bottomPanel.add(innerPanel,BorderLayout.EAST);
  JPanel langInnerPanel=new JPanel(new FlowLayout());
  langInnerPanel.setOpaque(false);
  langInnerPanel.setBorder(BorderFactory.createEmptyBorder(0,44,0,0));
  JComboBox languageDropDown=createLanguageDropDown(normalFont);
  langInnerPanel.add(languageDropDown);
  bottomPanel.add(langInnerPanel,BorderLayout.WEST);
  contentPane.add(panel,BorderLayout.NORTH);
  contentPane.add(bottomPanel,BorderLayout.SOUTH);
  pack();
}","public IntentDialog(){
  super();
  ResizeUtils.forceSize(this,new Dimension(590,400));
  setTitle(title);
  setModal(true);
  setResizable(false);
  setAlwaysOnTop(true);
  JPanel contentPane=new JPanel(new BorderLayout());
  contentPane.setBackground(backgroundColor);
  add(contentPane);
  JPanel panel=new JPanel(new MigLayout(""String_Node_Str""));
  panel.setOpaque(false);
  headingLabel=new JLabel();
  headingLabel.setFont(headingFont);
  agreeLabel=new MultiLineLabel(""String_Node_Str"",500);
  agreeLabel.setFont(normalFont);
  linkButton=new HyperlinkButton(""String_Node_Str"",urlAction);
  linkButton.setFont(normalFont);
  linkButton.setForeground(new Color(0x2152a6));
  bodyLabel=new MultiLineLabel(""String_Node_Str"",500);
  bodyLabel.setFont(normalFont);
  agreeButton=new JButton();
  exitButton=new JButton();
  int indent=50;
  panel.add(headingLabel,""String_Node_Str"");
  panel.add(bodyLabel,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(linkButton,""String_Node_Str"" + indent + ""String_Node_Str"");
  panel.add(agreeLabel,""String_Node_Str"" + indent + ""String_Node_Str"");
  JPanel bottomPanel=new JPanel(new BorderLayout());
  bottomPanel.setOpaque(false);
  JPanel innerPanel=new JPanel(new FlowLayout());
  innerPanel.setOpaque(false);
  innerPanel.add(agreeButton);
  innerPanel.add(exitButton);
  bottomPanel.add(innerPanel,BorderLayout.EAST);
  JPanel langInnerPanel=new JPanel(new FlowLayout());
  langInnerPanel.setOpaque(false);
  langInnerPanel.setBorder(BorderFactory.createEmptyBorder(0,44,0,0));
  JComboBox languageDropDown=createLanguageDropDown(normalFont);
  langInnerPanel.add(languageDropDown);
  bottomPanel.add(langInnerPanel,BorderLayout.WEST);
  setTextContents();
  contentPane.add(panel,BorderLayout.NORTH);
  contentPane.add(bottomPanel,BorderLayout.SOUTH);
  pack();
}",0.9884868421052632
3911,"private JComboBox createLanguageDropDown(Font normalFont){
  final JComboBox languageDropDown=new JComboBox();
  Locale[] locales=LanguageUtils.getLocales(normalFont);
  languageDropDown.setRenderer(new LocaleRenderer());
  languageDropDown.setFont(normalFont);
  languageDropDown.setModel(new DefaultComboBoxModel(locales));
  Locale locale=LanguageUtils.guessLocale();
  languageDropDown.setSelectedItem(locale);
  languageDropDown.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED) {
        Locale locale=(Locale)languageDropDown.getSelectedItem();
        LanguageUtils.setLocale(locale);
        setTextContents();
      }
    }
  }
);
  return languageDropDown;
}","private JComboBox createLanguageDropDown(Font normalFont){
  final JComboBox languageDropDown=new JComboBox();
  Locale[] locales=LanguageUtils.getLocales(normalFont);
  languageDropDown.setRenderer(new LocaleRenderer());
  languageDropDown.setFont(normalFont);
  languageDropDown.setModel(new DefaultComboBoxModel(locales));
  languageDropDown.setSelectedItem(LanguageUtils.guessBestAvailableLocale(locales));
  LanguageUtils.setLocale((Locale)languageDropDown.getSelectedItem());
  languageDropDown.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      if (e.getStateChange() == ItemEvent.SELECTED) {
        Locale locale=(Locale)languageDropDown.getSelectedItem();
        LanguageUtils.setLocale(locale);
        setTextContents();
      }
    }
  }
);
  return languageDropDown;
}",0.8958203368683718
3912,"public ShapeDialog(){
  super(new MigLayout(""String_Node_Str""));
  GuiUtils.assignResources(this);
  setOpaque(false);
  setVisible(false);
  setBackgroundPainter(new DialogShadowPainter());
  addComponentListener(new ComponentAdapter(){
    @Override public void componentShown(    ComponentEvent e){
      addListeners();
    }
    @Override public void componentHidden(    ComponentEvent e){
      removeListeners();
    }
  }
);
  componentListener=new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      setSize(getPreferredSize());
      repaint();
    }
  }
;
}","public ShapeDialog(){
  super(new MigLayout(""String_Node_Str""));
  GuiUtils.assignResources(this);
  setOpaque(false);
  setVisible(false);
  setBackgroundPainter(new DialogShadowPainter());
  addComponentListener(new ComponentAdapter(){
    @Override public void componentShown(    ComponentEvent e){
      addListeners();
      resize();
    }
    @Override public void componentHidden(    ComponentEvent e){
      removeListeners();
    }
  }
);
  componentListener=new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      setSize(getPreferredSize());
      repaint();
    }
  }
;
}",0.987012987012987
3913,"/** 
 * @param c the Component shown
 * @param owner the dialog owner.  Dialog will be centered in frame if this is null
 * @param autoClose Dialog will have PopupMenu close behavior (clicking away or pressing esc closes dialog)
 */
public void show(Component c,Component owner,boolean autoClose){
  removeAll();
  int inset=(owner != null && isPositionedRelativeToOwner) ? 0 : SHADOW_INSETS;
  add(c,""String_Node_Str"" + inset + ""String_Node_Str""+ inset+ ""String_Node_Str""+ inset+ ""String_Node_Str""+ inset);
  this.component=c;
  this.owner=owner;
  this.isAutoClose=autoClose;
  setVisible(true);
  resize();
}","/** 
 * @param c the Component shown
 * @param owner the dialog owner.  Dialog will be centered in frame if this is null
 * @param autoClose Dialog will have PopupMenu close behavior (clicking away or pressing esc closes dialog)
 */
public void show(Component c,Component owner,boolean autoClose){
  removeAll();
  int inset=(owner != null && isPositionedRelativeToOwner) ? 0 : SHADOW_INSETS;
  add(c,""String_Node_Str"" + inset + ""String_Node_Str""+ inset+ ""String_Node_Str""+ inset+ ""String_Node_Str""+ inset);
  this.component=c;
  this.owner=owner;
  this.isAutoClose=autoClose;
  setVisible(true);
}",0.9900826446280993
3914,"@Override public void componentShown(ComponentEvent e){
  addListeners();
}","@Override public void componentShown(ComponentEvent e){
  addListeners();
  resize();
}",0.925925925925926
3915,"@Override protected JComponent createCategoryButton(Action action,Category category){
  MySelectionPanel component=new MySelectionPanel(action,new ShareAllAction(category),category,this);
  addNavigation(component.getButton());
  return component;
}","@Override protected JComponent createCategoryButton(Action action,Category category){
  MySelectionPanel component=new MySelectionPanel(action,new ShareCategoryAction(category),category,this);
  addNavigation(component.getButton());
  return component;
}",0.978131212723658
3916,"@Override public void actionPerformed(ActionEvent e){
  categoryShareWidget.setShareable(category);
  categoryShareWidget.show((JComponent)e.getSource());
}","@Override public void actionPerformed(ActionEvent e){
  if (LibrarySettings.SNAPSHOT_SHARING_ENABLED.getValue()) {
  }
 else {
    categoryShareWidget.setShareable(category);
    categoryShareWidget.show((JComponent)e.getSource());
  }
}",0.7938931297709924
3917,"public MySelectionPanel(Action action,Action shareAction,Category category,LibraryPanel panel){
  super(new MigLayout(""String_Node_Str""));
  this.libraryPanel=panel;
  GuiUtils.assignResources(this);
  setOpaque(false);
  button=new JButton(action);
  button.setContentAreaFilled(false);
  button.setBorderPainted(false);
  button.setFocusPainted(false);
  button.setBorder(BorderFactory.createEmptyBorder(2,8,2,0));
  button.setHorizontalAlignment(SwingConstants.LEFT);
  button.setOpaque(false);
  button.getAction().addPropertyChangeListener(new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent evt){
      if (evt.getPropertyName().equals(Action.SELECTED_KEY)) {
        if (Boolean.TRUE.equals(evt.getNewValue())) {
          setOpaque(true);
          setBackground(selectedBackground);
          button.setForeground(selectedTextColor);
          if (shareButton != null) {
            shareButton.setVisible(true);
          }
        }
 else {
          setOpaque(false);
          button.setForeground(textColor);
          if (shareButton != null) {
            shareButton.setVisible(false);
          }
        }
        repaint();
      }
 else       if (evt.getPropertyName().equals(""String_Node_Str"")) {
        boolean value=(Boolean)evt.getNewValue();
        setVisible(value);
        if (value == false && button.getAction().getValue(Action.SELECTED_KEY) != null && button.getAction().getValue(Action.SELECTED_KEY).equals(Boolean.TRUE)) {
          libraryPanel.selectFirst();
        }
      }
    }
  }
);
  add(button,""String_Node_Str"");
  if (category == Category.AUDIO || category == Category.VIDEO || category == Category.IMAGE) {
    shareButton=new HyperlinkButton(null,shareAction);
    shareButton.setContentAreaFilled(false);
    shareButton.setBorderPainted(false);
    shareButton.setFocusPainted(false);
    shareButton.setBorder(BorderFactory.createEmptyBorder(2,0,2,4));
    shareButton.setOpaque(false);
    shareButton.setVisible(false);
    FontUtils.underline(shareButton);
    shareButton.setFont(shareButtonFont);
    shareButton.setForeground(shareForegroundColor);
    shareButton.setRolloverForeground(shareMouseOverColor);
    add(shareButton,""String_Node_Str"");
  }
}","public MySelectionPanel(Action action,Action shareAction,Category category,LibraryPanel panel){
  super(new MigLayout(""String_Node_Str""));
  this.libraryPanel=panel;
  GuiUtils.assignResources(this);
  setOpaque(false);
  button=new JButton(action);
  button.setContentAreaFilled(false);
  button.setBorderPainted(false);
  button.setFocusPainted(false);
  button.setBorder(BorderFactory.createEmptyBorder(2,8,2,0));
  button.setHorizontalAlignment(SwingConstants.LEFT);
  button.setOpaque(false);
  button.getAction().addPropertyChangeListener(new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent evt){
      if (evt.getPropertyName().equals(Action.SELECTED_KEY)) {
        if (Boolean.TRUE.equals(evt.getNewValue())) {
          setOpaque(true);
          setBackground(selectedBackground);
          button.setForeground(selectedTextColor);
          if (shareButton != null) {
            shareButton.setVisible(true);
          }
        }
 else {
          setOpaque(false);
          button.setForeground(textColor);
          if (shareButton != null) {
            shareButton.setVisible(false);
          }
        }
        repaint();
      }
 else       if (evt.getPropertyName().equals(""String_Node_Str"")) {
        boolean value=(Boolean)evt.getNewValue();
        setVisible(value);
        if (value == false && button.getAction().getValue(Action.SELECTED_KEY) != null && button.getAction().getValue(Action.SELECTED_KEY).equals(Boolean.TRUE)) {
          libraryPanel.selectFirst();
        }
      }
    }
  }
);
  add(button,""String_Node_Str"");
  if (category == Category.AUDIO || category == Category.VIDEO || category == Category.IMAGE) {
    shareButton=new HyperlinkButton(shareAction);
    shareButton.setBorder(BorderFactory.createEmptyBorder(2,0,2,4));
    shareButton.setVisible(false);
    shareButton.setFont(shareButtonFont);
    shareButton.setForeground(shareForegroundColor);
    shareButton.setRolloverForeground(shareMouseOverColor);
    add(shareButton,""String_Node_Str"");
  }
}",0.9501275806077476
3918,"/** 
 * Sets the custom default UI color and behavior properties
 */
private void initUIDefaults(){
  if (OSUtils.isAnyMac()) {
    initMacUIDefaults();
  }
  initBackgrounds();
  Paint highlightBackground=new Color(0xdaf2b5);
  UIManager.put(""String_Node_Str"",highlightBackground);
  UIManager.put(""String_Node_Str"",highlightBackground);
  UIManager.put(""String_Node_Str"",highlightBackground);
  UIManager.put(""String_Node_Str"",highlightBackground);
  Color highlightForeground=Color.BLACK;
  UIManager.put(""String_Node_Str"",highlightForeground);
  UIManager.put(""String_Node_Str"",highlightForeground);
  UIManager.put(""String_Node_Str"",highlightForeground);
  UIManager.put(""String_Node_Str"",highlightForeground);
  UIManager.put(""String_Node_Str"",false);
}","/** 
 * Sets the custom default UI color and behavior properties
 */
private void initUIDefaults(){
  if (OSUtils.isAnyMac()) {
    initMacUIDefaults();
  }
  initBackgrounds();
  Paint highlightBackground=new Color(0xdaf2b5);
  UIManager.put(""String_Node_Str"",highlightBackground);
  UIManager.put(""String_Node_Str"",highlightBackground);
  UIManager.put(""String_Node_Str"",highlightBackground);
  UIManager.put(""String_Node_Str"",highlightBackground);
  Color highlightForeground=Color.BLACK;
  UIManager.put(""String_Node_Str"",highlightForeground);
  UIManager.put(""String_Node_Str"",highlightForeground);
  UIManager.put(""String_Node_Str"",highlightForeground);
  UIManager.put(""String_Node_Str"",highlightForeground);
  UIManager.put(""String_Node_Str"",false);
  if (OSUtils.isWindows()) {
    replaceIconIfFailing(""String_Node_Str"",upFolderVistaFixIcon);
    replaceIconIfFailing(""String_Node_Str"",detailsViewVistaFixIcon);
    replaceIconIfFailing(""String_Node_Str"",listViewVistaFixIcon);
    replaceIconIfFailing(""String_Node_Str"",newFolderVistaFixIcon);
  }
}",0.834524463991204
3919,"public synchronized boolean addDownload(Collection<? extends RemoteFileDesc> c,boolean cache){
  if (stopped || isCompleted())   return false;
  List<RemoteFileDesc> l=new ArrayList<RemoteFileDesc>(c.size());
  for (  RemoteFileDesc rfd : c) {
    if (allowAddition(rfd)) {
      if (hostIsAllowed(rfd)) {
        l.add(rfd);
      }
    }
  }
  return addDownloadForced(l,cache);
}","public synchronized boolean addDownload(Collection<? extends RemoteFileDesc> c,boolean cache){
  if (stopped || isCompleted())   return false;
  List<RemoteFileDesc> l=new ArrayList<RemoteFileDesc>(c.size());
  for (  RemoteFileDesc rfd : c) {
    if (allowAddition(rfd)) {
      if (hostIsAllowed(rfd)) {
        l.add(rfd);
      }
    }
  }
  if (l.size() > 0) {
    return addDownloadForced(l,cache);
  }
 else {
    return false;
  }
}",0.927007299270073
3920,"@Override public void showProperties(RemoteFileItem propertiable){
  icon.setIcon(categoryIconManager.getIcon(propertiable.getCategory()));
  location.setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  location.add(fileLocation);
  populateCommonFields(propertiable);
  populateCopyToClipboard(propertiable);
  fileLocation.setText(propertiable.getSources().get(0).getFriendPresence().getPresenceId());
  showDialog(propertiable.getFileName(),propertiable.getCategory());
}","@Override public void showProperties(RemoteFileItem propertiable){
  icon.setIcon(categoryIconManager.getIcon(propertiable.getCategory()));
  location.setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  location.add(fileLocation,""String_Node_Str"");
  populateCommonFields(propertiable);
  populateCopyToClipboard(propertiable);
  fileLocation.setText(propertiable.getSources().get(0).getFriendPresence().getPresenceId());
  showDialog(propertiable.getFileName(),propertiable.getCategory());
}",0.9824902723735408
3921,"@Override public void initOptions(){
  String[] bannedWords=FilterSettings.BANNED_EXTENSIONS.getValue();
  eventList.addAll(new ArrayList<String>(Arrays.asList(bannedWords)));
}","@Override public void initOptions(){
  eventList.clear();
  String[] bannedWords=FilterSettings.BANNED_EXTENSIONS.getValue();
  eventList.addAll(new ArrayList<String>(Arrays.asList(bannedWords)));
}",0.944
3922,"/** 
 * Initializes the components in the container.
 */
private void initComponents(){
  setLayout(new BorderLayout());
  setOpaque(false);
  scrollPane.setBorder(BorderFactory.createLineBorder(Color.LIGHT_GRAY));
  scrollPane.setPreferredSize(new Dimension(120,295));
  connectionTable.setPopupHandler(new TablePopupHandler(){
    @Override public boolean isPopupShowing(    int row){
      return false;
    }
    @Override public void maybeShowPopup(    Component component,    int x,    int y){
      int row=connectionTable.rowAtPoint(new Point(x,y));
      if ((row >= 0) && !connectionTable.isRowSelected(row)) {
        connectionTable.setRowSelectionInterval(row,row);
      }
      popupMenu.show(component,x,y);
    }
  }
);
  connectionTable.setDoubleClickHandler(new TableDoubleClickHandler(){
    @Override public void handleDoubleClick(    int row){
      if (row >= 0) {
        connectionTable.setRowSelectionInterval(row,row);
      }
      viewLibrary();
    }
  }
);
  JMenuItem menuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  menuItem.addActionListener(new ViewLibraryAction());
  popupMenu.add(menuItem);
  popupMenu.addSeparator();
  menuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  menuItem.addActionListener(new RemoveConnectionAction());
  popupMenu.add(menuItem);
  add(scrollPane,BorderLayout.CENTER);
  scrollPane.setViewportView(connectionTable);
}","/** 
 * Initializes the components in the container.
 */
private void initComponents(){
  setLayout(new BorderLayout());
  setOpaque(false);
  scrollPane.setBorder(BorderFactory.createLineBorder(Color.LIGHT_GRAY));
  scrollPane.setPreferredSize(new Dimension(120,120));
  connectionTable.setPopupHandler(new TablePopupHandler(){
    @Override public boolean isPopupShowing(    int row){
      return false;
    }
    @Override public void maybeShowPopup(    Component component,    int x,    int y){
      int row=connectionTable.rowAtPoint(new Point(x,y));
      if ((row >= 0) && !connectionTable.isRowSelected(row)) {
        connectionTable.setRowSelectionInterval(row,row);
      }
      popupMenu.show(component,x,y);
    }
  }
);
  connectionTable.setDoubleClickHandler(new TableDoubleClickHandler(){
    @Override public void handleDoubleClick(    int row){
      if (row >= 0) {
        connectionTable.setRowSelectionInterval(row,row);
      }
      viewLibrary();
    }
  }
);
  JMenuItem menuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  menuItem.addActionListener(new ViewLibraryAction());
  popupMenu.add(menuItem);
  popupMenu.addSeparator();
  menuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  menuItem.addActionListener(new RemoveConnectionAction());
  popupMenu.add(menuItem);
  add(scrollPane,BorderLayout.CENTER);
  scrollPane.setViewportView(connectionTable);
}",0.9985611510791368
3923,"@Override public boolean isShared(SharingTarget friend){
  for (  LocalFileItem item : fileItems) {
    if (friend.isGnutellaNetwork()) {
      if (!gnutellaList.contains(item.getFile())) {
        return false;
      }
    }
 else {
switch (item.getCategory()) {
case AUDIO:
        if (!shareListManager.getOrCreateFriendShareList(friend.getFriend()).isAddNewAudioAlways()) {
          return false;
        }
      break;
case VIDEO:
    if (!shareListManager.getOrCreateFriendShareList(friend.getFriend()).isAddNewVideoAlways()) {
      return false;
    }
  break;
case IMAGE:
if (!shareListManager.getOrCreateFriendShareList(friend.getFriend()).isAddNewImageAlways()) {
  return false;
}
break;
}
if (shareListManager.getOrCreateFriendShareList(friend.getFriend()).contains(item.getFile())) {
return false;
}
}
}
return true;
}","@Override public boolean isShared(SharingTarget friend){
  return false;
}",0.1631753031973539
3924,"protected void populateCommonFields(final PropertiableFile propertiable){
  heading.setText(propertiableHeadings.getHeading(propertiable));
  filename.setText(propertiable.getFileName());
  subheading.setText(propertiableHeadings.getSubHeading(propertiable));
  fileSize.setText(str(propertiable.getProperty(FilePropertyKey.FILE_SIZE)));
  genre.setModel(new DefaultComboBoxModel(new Object[]{propertiable.getProperty(FilePropertyKey.GENRE)}));
  rating.setModel(new DefaultComboBoxModel(new Object[]{propertiable.getProperty(FilePropertyKey.RATING)}));
  platform.setModel(new DefaultComboBoxModel(new Object[]{propertiable.getProperty(FilePropertyKey.PLATFORM)}));
  populateMetadata(propertiable);
  title.setText(str(propertiable.getProperty(FilePropertyKey.TITLE)));
  artist.setText(str(propertiable.getProperty(FilePropertyKey.AUTHOR)));
  author.setText(str(propertiable.getProperty(FilePropertyKey.AUTHOR)));
  company.setText(str(propertiable.getProperty(FilePropertyKey.COMPANY)));
  album.setText(str(propertiable.getProperty(FilePropertyKey.ALBUM)));
  year.setText(str(propertiable.getProperty(FilePropertyKey.YEAR)));
  track.setText(str(propertiable.getProperty(FilePropertyKey.TRACK_NUMBER)));
  description.setText(str(propertiable.getProperty(FilePropertyKey.COMMENTS)));
}","protected void populateCommonFields(final PropertiableFile propertiable){
  heading.setText(propertiableHeadings.getHeading(propertiable));
  filename.setText(propertiable.getFileName());
  subheading.setText(propertiableHeadings.getSubHeading(propertiable));
  fileSize.setText(propertiableHeadings.getFileSize(propertiable));
  genre.setModel(new DefaultComboBoxModel(new Object[]{propertiable.getProperty(FilePropertyKey.GENRE)}));
  rating.setModel(new DefaultComboBoxModel(new Object[]{propertiable.getProperty(FilePropertyKey.RATING)}));
  platform.setModel(new DefaultComboBoxModel(new Object[]{propertiable.getProperty(FilePropertyKey.PLATFORM)}));
  populateMetadata(propertiable);
  title.setText(str(propertiable.getProperty(FilePropertyKey.TITLE)));
  artist.setText(str(propertiable.getProperty(FilePropertyKey.AUTHOR)));
  author.setText(str(propertiable.getProperty(FilePropertyKey.AUTHOR)));
  company.setText(str(propertiable.getProperty(FilePropertyKey.COMPANY)));
  album.setText(str(propertiable.getProperty(FilePropertyKey.ALBUM)));
  year.setText(str(propertiable.getProperty(FilePropertyKey.YEAR)));
  track.setText(str(propertiable.getProperty(FilePropertyKey.TRACK_NUMBER)));
  description.setText(str(propertiable.getProperty(FilePropertyKey.COMMENTS)));
}",0.961926961926962
3925,"protected void populateMetadata(PropertiableFile propFile){
  Map<String,String> metadata=new LinkedHashMap<String,String>();
switch (propFile.getCategory()) {
case AUDIO:
    addBitrateMetadata(str(propFile.getProperty(FilePropertyKey.BITRATE)),metadata);
  break;
case VIDEO:
addBitrateMetadata(str(propFile.getProperty(FilePropertyKey.BITRATE)),metadata);
addDimensionMetadata(str(propFile.getProperty(FilePropertyKey.WIDTH)),str(propFile.getProperty(FilePropertyKey.HEIGHT)),metadata);
break;
case IMAGE:
addDimensionMetadata(str(propFile.getProperty(FilePropertyKey.WIDTH)),str(propFile.getProperty(FilePropertyKey.HEIGHT)),metadata);
break;
case DOCUMENT:
addDateCreatedMetadata(str(propFile.getProperty(FilePropertyKey.DATE_CREATED)),metadata);
break;
}
addHashMetadata(propFile.getUrn(),metadata);
setMetadataText(metadata);
}","protected void populateMetadata(PropertiableFile propFile){
  Map<String,String> metadata=new LinkedHashMap<String,String>();
switch (propFile.getCategory()) {
case AUDIO:
    addBitrateMetadata(str(propFile.getProperty(FilePropertyKey.BITRATE)),metadata);
  break;
case VIDEO:
addBitrateMetadata(str(propFile.getProperty(FilePropertyKey.BITRATE)),metadata);
addDimensionMetadata(str(propFile.getProperty(FilePropertyKey.WIDTH)),str(propFile.getProperty(FilePropertyKey.HEIGHT)),metadata);
break;
case IMAGE:
addDimensionMetadata(str(propFile.getProperty(FilePropertyKey.WIDTH)),str(propFile.getProperty(FilePropertyKey.HEIGHT)),metadata);
break;
case DOCUMENT:
addDateCreatedMetadata(convertDate(propFile),metadata);
break;
}
addHashMetadata(propFile.getUrn(),metadata);
setMetadataText(metadata);
}",0.95593635250918
3926,"@Override public String getSubHeading(PropertiableFile propertiable){
  String subheading=""String_Node_Str"";
switch (propertiable.getCategory()) {
case AUDIO:
{
      String albumTitle=getPropertyString(propertiable,FilePropertyKey.ALBUM);
      Long qualityScore=getQualityScore(propertiable);
      Long length=getLength(propertiable);
      boolean insertHyphen=false;
      if (!StringUtils.isEmpty(albumTitle)) {
        subheading+=albumTitle;
        insertHyphen=true;
      }
      if (qualityScore != null) {
        if (insertHyphen) {
          subheading+=""String_Node_Str"";
        }
        subheading+=I18n.tr(""String_Node_Str"",GuiUtils.toQualityString(qualityScore));
        insertHyphen=true;
      }
      if (length != null) {
        subheading=addLength(subheading,length,insertHyphen);
      }
 else {
        Long fileSize=getFileSize(propertiable);
        subheading=addFileSize(subheading,fileSize,insertHyphen);
      }
    }
  break;
case VIDEO:
{
  Long qualityScore=getQualityScore(propertiable);
  Long length=getLength(propertiable);
  Long fileSize=getFileSize(propertiable);
  boolean insertHyphen=false;
  if (qualityScore != null) {
    subheading+=I18n.tr(""String_Node_Str"",GuiUtils.toQualityString(qualityScore));
    insertHyphen=true;
  }
  subheading=addLength(subheading,length,insertHyphen);
  subheading=addFileSize(subheading,fileSize,insertHyphen);
}
break;
case IMAGE:
{
Object time=propertiable.getProperty(FilePropertyKey.DATE_CREATED);
if (time != null && time instanceof Long) {
subheading=DATE_FORMAT.format(new java.util.Date((Long)time));
}
}
break;
case PROGRAM:
{
Long fileSize=getFileSize(propertiable);
if (fileSize != null) {
subheading=GuiUtils.toUnitbytes(fileSize);
}
}
break;
case DOCUMENT:
case OTHER:
default :
{
subheading=iconManager.getMIMEDescription(propertiable);
subheading=subheading == null ? ""String_Node_Str"" : subheading;
Long fileSize=getFileSize(propertiable);
subheading=addFileSize(subheading,fileSize,!""String_Node_Str"".equals(subheading));
}
}
return subheading == null ? ""String_Node_Str"" : subheading;
}","@Override public String getSubHeading(PropertiableFile propertiable){
  String subheading=""String_Node_Str"";
switch (propertiable.getCategory()) {
case AUDIO:
{
      String albumTitle=getPropertyString(propertiable,FilePropertyKey.ALBUM);
      Long qualityScore=getQualityScore(propertiable);
      Long length=getLength(propertiable);
      boolean insertHyphen=false;
      if (!StringUtils.isEmpty(albumTitle)) {
        subheading+=albumTitle;
        insertHyphen=true;
      }
      if (qualityScore != null) {
        if (insertHyphen) {
          subheading+=""String_Node_Str"";
        }
        subheading+=I18n.tr(""String_Node_Str"",GuiUtils.toQualityString(qualityScore));
        insertHyphen=true;
      }
      if (length != null) {
        subheading=addLength(subheading,length,insertHyphen);
      }
 else {
        Long fileSize=getFileSizeLong(propertiable);
        subheading=addFileSize(subheading,fileSize,insertHyphen);
      }
    }
  break;
case VIDEO:
{
  Long qualityScore=getQualityScore(propertiable);
  Long length=getLength(propertiable);
  Long fileSize=getFileSizeLong(propertiable);
  boolean insertHyphen=false;
  if (qualityScore != null) {
    subheading+=I18n.tr(""String_Node_Str"",GuiUtils.toQualityString(qualityScore));
    insertHyphen=true;
  }
  subheading=addLength(subheading,length,insertHyphen);
  subheading=addFileSize(subheading,fileSize,insertHyphen);
}
break;
case IMAGE:
{
Object time=propertiable.getProperty(FilePropertyKey.DATE_CREATED);
if (time != null && time instanceof Long) {
subheading=DATE_FORMAT.format(new java.util.Date((Long)time));
}
}
break;
case PROGRAM:
{
subheading=getFileSize(propertiable);
}
break;
case DOCUMENT:
case OTHER:
default :
{
subheading=iconManager.getMIMEDescription(propertiable);
subheading=subheading == null ? ""String_Node_Str"" : subheading;
Long fileSize=getFileSizeLong(propertiable);
subheading=addFileSize(subheading,fileSize,!""String_Node_Str"".equals(subheading));
}
}
return subheading == null ? ""String_Node_Str"" : subheading;
}",0.9650485436893204
3927,"private Long getFileSize(PropertiableFile propertiable){
  return CommonUtils.parseLongNoException(getPropertyString(propertiable,FilePropertyKey.FILE_SIZE));
}","public String getFileSize(PropertiableFile propertiable){
  Long fileSize=getFileSizeLong(propertiable);
  if (fileSize != null) {
    return GuiUtils.toUnitbytes(fileSize);
  }
  return ""String_Node_Str"";
}",0.2615803814713896
3928,"/** 
 * Constructs a new EventListener for list change events. 
 */
protected EventListener<FileListChangedEvent> newEventListener(){
  return new EventListener<FileListChangedEvent>(){
    @Override public void handleEvent(    FileListChangedEvent event){
switch (event.getType()) {
case ADDED:
        addFileDesc(event.getFileDesc());
      break;
case CHANGED:
    changeFileDesc(event.getOldValue(),event.getFileDesc());
  break;
case REMOVED:
removeFileDesc(event.getFileDesc());
break;
case CLEAR:
clearFileDescs();
break;
}
}
}
;
}","/** 
 * Constructs a new EventListener for list change events. 
 */
protected EventListener<FileListChangedEvent> newEventListener(){
  return new EventListener<FileListChangedEvent>(){
    @Override public void handleEvent(    FileListChangedEvent event){
switch (event.getType()) {
case ADDED:
        addFileDesc(event.getFileDesc());
      break;
case CHANGED:
    changeFileDesc(event.getOldValue(),event.getFileDesc());
  break;
case REMOVED:
removeFileDesc(event.getFileDesc());
break;
case CLEAR:
clearFileDescs();
break;
case AUDIO_COLLECTION:
if (event.getType() == FileListChangedEvent.Type.AUDIO_COLLECTION) {
audioCollectionUpdate(event.isShared());
}
break;
case VIDEO_COLLECTION:
if (event.getType() == FileListChangedEvent.Type.VIDEO_COLLECTION) {
videoCollectionUpdate(event.isShared());
}
break;
case IMAGE_COLLECTION:
if (event.getType() == FileListChangedEvent.Type.IMAGE_COLLECTION) {
imageCollectionUpdate(event.isShared());
}
break;
}
}
}
;
}",0.7167553191489362
3929,"@Override public void handleEvent(FileListChangedEvent event){
switch (event.getType()) {
case ADDED:
    addFileDesc(event.getFileDesc());
  break;
case CHANGED:
changeFileDesc(event.getOldValue(),event.getFileDesc());
break;
case REMOVED:
removeFileDesc(event.getFileDesc());
break;
case CLEAR:
clearFileDescs();
break;
}
}","@Override public void handleEvent(FileListChangedEvent event){
switch (event.getType()) {
case ADDED:
    addFileDesc(event.getFileDesc());
  break;
case CHANGED:
changeFileDesc(event.getOldValue(),event.getFileDesc());
break;
case REMOVED:
removeFileDesc(event.getFileDesc());
break;
case CLEAR:
clearFileDescs();
break;
case AUDIO_COLLECTION:
if (event.getType() == FileListChangedEvent.Type.AUDIO_COLLECTION) {
audioCollectionUpdate(event.isShared());
}
break;
case VIDEO_COLLECTION:
if (event.getType() == FileListChangedEvent.Type.VIDEO_COLLECTION) {
videoCollectionUpdate(event.isShared());
}
break;
case IMAGE_COLLECTION:
if (event.getType() == FileListChangedEvent.Type.IMAGE_COLLECTION) {
imageCollectionUpdate(event.isShared());
}
break;
}
}",0.604089219330855
3930,"public void setAddNewImageAlways(boolean value){
  getCoreFileList().setAddNewImageAlways(value);
  fireImageCollectionChange(propertyChange,value);
  setSharing(value,Category.IMAGE);
}","public void setAddNewImageAlways(boolean value){
  getCoreFileList().setAddNewImageAlways(value);
  imageCollectionUpdate(value);
}",0.8012618296529969
3931,"public void setAddNewAudioAlways(boolean value){
  getCoreFileList().setAddNewAudioAlways(value);
  fireAudioCollectionChange(propertyChange,value);
  setSharing(value,Category.AUDIO);
}","public void setAddNewAudioAlways(boolean value){
  getCoreFileList().setAddNewAudioAlways(value);
  audioCollectionUpdate(value);
}",0.7949526813880127
3932,"public void setAddNewVideoAlways(boolean value){
  getCoreFileList().setAddNewVideoAlways(value);
  fireVideoCollectionChange(propertyChange,value);
  setSharing(value,Category.VIDEO);
}","public void setAddNewVideoAlways(boolean value){
  getCoreFileList().setAddNewVideoAlways(value);
  videoCollectionUpdate(value);
}",0.7949526813880127
3933,"public FileListChangedEvent(FileList list,Type type,FileDesc oldValue,FileDesc newValue){
}","public FileListChangedEvent(Type type,boolean state){
}",0.6438356164383562
3934,"@Override protected void saveChange(File file,boolean added){
  if (isSmartlySharedType(file)) {
    if (!added) {
      stopSmartSharingType(file);
    }
  }
 else {
    data.setSharedWithFriend(file,id,added);
  }
}","@Override protected void saveChange(File file,boolean added){
  data.setSharedWithFriend(file,id,added);
}",0.6563467492260062
3935,"/** 
 * Changes the smart sharing value for images. If true, all new images added to the library will be shared with this list, if false, new images added to  the library will not be automatically shared with this list but current images will not be removed.
 */
@Override public void setAddNewImageAlways(boolean value){
  if (value != addNewImagesAlways) {
    if (value == false) {
      LibrarySettings.removeFiendShareNewFiles(LibrarySettings.SHARE_NEW_IMAGES_ALWAYS,id);
    }
 else {
      LibrarySettings.addFriendShareNewFiles(LibrarySettings.SHARE_NEW_IMAGES_ALWAYS,id);
    }
    addNewImagesAlways=value;
  }
}","/** 
 * Changes the smart sharing value for images. If true, all new images added to the library will be shared with this list, if false, new images added to  the library will not be automatically shared with this list but current images will not be removed.
 */
@Override public void setAddNewImageAlways(boolean value){
  if (value != addNewImagesAlways) {
    if (value == false) {
      LibrarySettings.removeFiendShareNewFiles(LibrarySettings.SHARE_NEW_IMAGES_ALWAYS,id);
    }
 else {
      LibrarySettings.addFriendShareNewFiles(LibrarySettings.SHARE_NEW_IMAGES_ALWAYS,id);
    }
    fireCollectionEvent(FileListChangedEvent.Type.IMAGE_COLLECTION,value);
    addNewImagesAlways=value;
  }
}",0.9431387414708112
3936,"/** 
 * Changes the smart sharing value for audio files. If true, all new audio files added to the library will be shared with this list, if false, new audio files added to  the library will not be automatically shared with this list but current audio files will not be removed.
 */
@Override public void setAddNewAudioAlways(boolean value){
  if (value != addNewAudioAlways) {
    if (value == false) {
      LibrarySettings.removeFiendShareNewFiles(LibrarySettings.SHARE_NEW_AUDIO_ALWAYS,id);
    }
 else {
      LibrarySettings.addFriendShareNewFiles(LibrarySettings.SHARE_NEW_AUDIO_ALWAYS,id);
    }
    addNewAudioAlways=value;
  }
}","/** 
 * Changes the smart sharing value for audio files. If true, all new audio files added to the library will be shared with this list, if false, new audio files added to  the library will not be automatically shared with this list but current audio files will not be removed.
 */
@Override public void setAddNewAudioAlways(boolean value){
  if (value != addNewAudioAlways) {
    if (value == false) {
      LibrarySettings.removeFiendShareNewFiles(LibrarySettings.SHARE_NEW_AUDIO_ALWAYS,id);
    }
 else {
      LibrarySettings.addFriendShareNewFiles(LibrarySettings.SHARE_NEW_AUDIO_ALWAYS,id);
    }
    fireCollectionEvent(FileListChangedEvent.Type.AUDIO_COLLECTION,value);
    addNewAudioAlways=value;
  }
}",0.9400444115470022
3937,"/** 
 * Changes the smart sharing value for videos. If true, all new videos added to the library will be shared with this list, if false, new videos added to  the library will not be automatically shared with this list but current videos will not be removed.
 */
@Override public void setAddNewVideoAlways(boolean value){
  if (value != addNewVideoAlways) {
    if (value == false) {
      LibrarySettings.removeFiendShareNewFiles(LibrarySettings.SHARE_NEW_VIDEO_ALWAYS,id);
    }
 else {
      LibrarySettings.addFriendShareNewFiles(LibrarySettings.SHARE_NEW_VIDEO_ALWAYS,id);
    }
    addNewVideoAlways=value;
  }
}","/** 
 * Changes the smart sharing value for videos. If true, all new videos added to the library will be shared with this list, if false, new videos added to  the library will not be automatically shared with this list but current videos will not be removed.
 */
@Override public void setAddNewVideoAlways(boolean value){
  if (value != addNewVideoAlways) {
    if (value == false) {
      LibrarySettings.removeFiendShareNewFiles(LibrarySettings.SHARE_NEW_VIDEO_ALWAYS,id);
    }
 else {
      LibrarySettings.addFriendShareNewFiles(LibrarySettings.SHARE_NEW_VIDEO_ALWAYS,id);
    }
    fireCollectionEvent(FileListChangedEvent.Type.VIDEO_COLLECTION,value);
    addNewVideoAlways=value;
  }
}",0.9336384439359268
3938,"public MiniPlayerPanel(AudioPlayer player){
  super(new HorizontalLayout());
  GuiUtils.assignResources(this);
  this.player=player;
  setOpaque(false);
  playPauseButton=new JButton();
  playPauseButton.setMargin(new Insets(0,0,0,0));
  playPauseButton.setBorderPainted(false);
  playPauseButton.setContentAreaFilled(false);
  playPauseButton.setFocusPainted(false);
  playPauseButton.setRolloverEnabled(true);
  playPauseButton.setIcon(playIcon);
  playPauseButton.setRolloverIcon(playIconRollover);
  playPauseButton.setPressedIcon(playIconPressed);
  playPauseButton.setHideActionText(true);
  playPauseButton.addActionListener(new PlayListener());
  statusButton=new MarqueeButton(""String_Node_Str"",16);
  statusButton.setFont(font);
  statusButton.setForeground(foregroundColor);
  statusButton.addActionListener(new ShowPlayerListener());
  add(playPauseButton);
  add(statusButton);
  setMaximumSize(getPreferredSize());
  player.addAudioPlayerListener(new PlayerListener());
}","public MiniPlayerPanel(AudioPlayer player){
  GuiUtils.assignResources(this);
  this.player=player;
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  setOpaque(false);
  playPauseButton=new JXButton();
  playPauseButton.setMargin(new Insets(0,0,0,0));
  playPauseButton.setBorderPainted(false);
  playPauseButton.setContentAreaFilled(false);
  playPauseButton.setFocusPainted(false);
  playPauseButton.setRolloverEnabled(true);
  playPauseButton.setIcon(playIcon);
  Dimension playPauseDimensions=new Dimension(playIcon.getIconWidth(),playIcon.getIconHeight());
  playPauseButton.setMaximumSize(playPauseDimensions);
  playPauseButton.setPreferredSize(playPauseDimensions);
  playPauseButton.setRolloverIcon(playIconRollover);
  playPauseButton.setPressedIcon(playIconPressed);
  playPauseButton.setHideActionText(true);
  playPauseButton.addActionListener(new PlayListener());
  statusButton=new MarqueeButton(""String_Node_Str"",16);
  Dimension statusButtonDimensions=new Dimension(Integer.MAX_VALUE,playIcon.getIconHeight());
  statusButton.setMaximumSize(statusButtonDimensions);
  statusButton.setFont(font);
  statusButton.setForeground(foregroundColor);
  statusButton.addActionListener(new ShowPlayerListener());
  add(playPauseButton,""String_Node_Str"");
  add(statusButton,""String_Node_Str"");
  setMaximumSize(getPreferredSize());
  player.addAudioPlayerListener(new PlayerListener());
}",0.7055900621118012
3939,"@Override public void handleEvent(ConnectivityChangeEvent event){
  LOG.debug(""String_Node_Str"");
synchronized (librariesToBrowse) {
    for (Iterator<PresenceLibrary> i=librariesToBrowse.iterator(); i.hasNext(); ) {
      PresenceLibrary presenceLibrary=i.next();
      FriendPresence friendPresence=presenceLibrary.getPresence();
      AddressFeature addressFeature=(AddressFeature)friendPresence.getFeature(AddressFeature.ID);
      if (addressFeature != null) {
        Address address=addressFeature.getFeature();
        if (socketsManager.canConnect(address) || socketsManager.canResolve(address)) {
          i.remove();
          browse(presenceLibrary,friendPresence);
        }
      }
    }
  }
}","@Override public void handleEvent(ConnectivityChangeEvent event){
  LOG.debug(""String_Node_Str"");
  remoteLibraryManager.getReadWriteLock().writeLock().lock();
  try {
synchronized (librariesToBrowse) {
      for (Iterator<PresenceLibrary> i=librariesToBrowse.iterator(); i.hasNext(); ) {
        PresenceLibrary presenceLibrary=i.next();
        FriendPresence friendPresence=presenceLibrary.getPresence();
        AddressFeature addressFeature=(AddressFeature)friendPresence.getFeature(AddressFeature.ID);
        if (addressFeature != null) {
          Address address=addressFeature.getFeature();
          if (socketsManager.canConnect(address) || socketsManager.canResolve(address)) {
            i.remove();
            browse(presenceLibrary,friendPresence);
          }
        }
      }
    }
  }
  finally {
    remoteLibraryManager.getReadWriteLock().writeLock().unlock();
  }
}",0.886107634543179
3940,"@Inject public PresenceLibraryBrowser(BrowseFactory browseFactory,RemoteLibraryManager remoteLibraryManager,SocketsManager socketsManager,XMPPRemoteFileDescDeserializer remoteFileDescDeserializer){
  this.browseFactory=browseFactory;
  this.remoteLibraryManager=remoteLibraryManager;
  this.socketsManager=socketsManager;
  this.remoteFileDescDeserializer=remoteFileDescDeserializer;
  socketsManager.addListener(new ConnectivityChangeListener());
}","@Inject public PresenceLibraryBrowser(BrowseFactory browseFactory,RemoteLibraryManagerImpl remoteLibraryManager,SocketsManager socketsManager,XMPPRemoteFileDescDeserializer remoteFileDescDeserializer){
  this.browseFactory=browseFactory;
  this.remoteLibraryManager=remoteLibraryManager;
  this.socketsManager=socketsManager;
  this.remoteFileDescDeserializer=remoteFileDescDeserializer;
  socketsManager.addListener(new ConnectivityChangeListener());
}",0.9955654101995566
3941,"public void update(org.jivesoftware.smack.packet.Presence presence){
synchronized (this) {
    this.type=Type.valueOf(presence.getType().toString());
    this.status=presence.getStatus();
    this.priority=presence.getPriority();
    this.mode=presence.getMode() != null ? Mode.valueOf(presence.getMode().toString()) : Mode.available;
  }
}","public void update(org.jivesoftware.smack.packet.Presence presence){
  rwLock.writeLock().lock();
  try {
    this.type=Type.valueOf(presence.getType().toString());
    this.status=presence.getStatus();
    this.priority=presence.getPriority();
    this.mode=presence.getMode() != null ? Mode.valueOf(presence.getMode().toString()) : Mode.available;
  }
  finally {
    rwLock.writeLock().unlock();
  }
}",0.8629032258064516
3942,"@Override public String getStatus(){
synchronized (this) {
    return status;
  }
}","@Override public String getStatus(){
  rwLock.readLock().lock();
  try {
    return status;
  }
  finally {
    rwLock.readLock().unlock();
  }
}",0.5701754385964912
3943,"@Override public Type getType(){
synchronized (this) {
    return type;
  }
}","@Override public Type getType(){
  rwLock.readLock().lock();
  try {
    return type;
  }
  finally {
    rwLock.readLock().unlock();
  }
}",0.5462962962962963
3944,"@Override public int getPriority(){
synchronized (this) {
    return priority;
  }
}","@Override public int getPriority(){
  rwLock.readLock().lock();
  try {
    return priority;
  }
  finally {
    rwLock.readLock().unlock();
  }
}",0.5739130434782609
3945,"@Override public Mode getMode(){
synchronized (this) {
    return mode;
  }
}","@Override public Mode getMode(){
  rwLock.readLock().lock();
  try {
    return mode;
  }
  finally {
    rwLock.readLock().unlock();
  }
}",0.5462962962962963
3946,"/** 
 * Returns presence if presence is   {@link FriendPresence} and the resourceid matches the one in <code>address</code> and the address is available in the presence. Also ensures that auth-token and address feature are set.
 */
private FriendPresence getMatchingPresence(XMPPAddress xmppAddress,String resourceId,FriendPresence presence){
  String originalId=xmppAddress.getFullId();
  int slash=originalId.indexOf('/');
  if (slash == -1) {
    LOG.debugf(""String_Node_Str"",originalId);
    return null;
  }
  int toOffset=Math.min(originalId.length(),slash + 5);
  if (originalId.substring(0,toOffset).equals(resourceId.substring(0,toOffset))) {
    Address address=addressRegistry.get(xmppAddress);
    Feature authTokenFeature=presence.getFeature(AuthTokenFeature.ID);
    if (address != null && authTokenFeature != null) {
      return presence;
    }
    LOG.debugf(""String_Node_Str"",address,authTokenFeature);
  }
  return null;
}","/** 
 * Returns presence if presence is   {@link FriendPresence} and the resourceid matches the one in <code>address</code> and the address is available in the presence. Also ensures that auth-token and address feature are set.
 */
private FriendPresence getMatchingPresence(XMPPAddress xmppAddress,String resourceId,FriendPresence presence){
  String originalId=xmppAddress.getFullId();
  int slash=originalId.indexOf('/');
  if (slash == -1) {
    LOG.debugf(""String_Node_Str"",originalId);
    return null;
  }
  int toOffset=Math.min(originalId.length(),slash + 5);
  if (originalId.substring(0,toOffset).equals(resourceId.substring(0,toOffset))) {
    Address address=addressRegistry.get(new XMPPAddress(resourceId));
    Feature authTokenFeature=presence.getFeature(AuthTokenFeature.ID);
    if (address != null && authTokenFeature != null) {
      return presence;
    }
    LOG.debugf(""String_Node_Str"",address,authTokenFeature);
  }
  return null;
}",0.987355110642782
3947,"private void handleAddressUpdate(AddressIQ iq){
synchronized (this) {
    User user=connection.getUser(StringUtils.parseBareAddress(iq.getFrom()));
    if (user != null) {
      FriendPresence presence=user.getFriendPresences().get(iq.getFrom());
      if (presence != null) {
        LOG.debugf(""String_Node_Str"",presence.getPresenceId(),iq.getAddress());
        presence.addFeature(new AddressFeature(iq.getAddress()));
      }
 else {
        LOG.debugf(""String_Node_Str"",iq.getAddress(),iq.getFrom());
        pendingAddresses.put(iq.getFrom(),address);
      }
    }
  }
}","private void handleAddressUpdate(AddressIQ iq){
synchronized (this) {
    User user=connection.getUser(StringUtils.parseBareAddress(iq.getFrom()));
    if (user != null) {
      FriendPresence presence=user.getFriendPresences().get(iq.getFrom());
      if (presence != null) {
        LOG.debugf(""String_Node_Str"",presence.getPresenceId(),iq.getAddress());
        presence.addFeature(new AddressFeature(iq.getAddress()));
      }
 else {
        LOG.debugf(""String_Node_Str"",iq.getAddress(),iq.getFrom());
        pendingAddresses.put(iq.getFrom(),iq.getAddress());
      }
    }
  }
}",0.9810996563573884
3948,"@Override public void initializeFeature(FriendPresence friendPresence){
synchronized (AddressIQListener.this) {
    if (address != null) {
      sendAddress(address,friendPresence.getPresenceId());
    }
    if (pendingAddresses.containsKey(friendPresence.getPresenceId())) {
      LOG.debugf(""String_Node_Str"",friendPresence.getPresenceId(),address);
      friendPresence.addFeature(new AddressFeature(pendingAddresses.remove(friendPresence.getPresenceId())));
    }
  }
}","@Override public void initializeFeature(FriendPresence friendPresence){
synchronized (AddressIQListener.this) {
    if (address != null) {
      sendAddress(address,friendPresence.getPresenceId());
    }
    if (pendingAddresses.containsKey(friendPresence.getPresenceId())) {
      Address pendingAddress=pendingAddresses.remove(friendPresence.getPresenceId());
      LOG.debugf(""String_Node_Str"",friendPresence.getPresenceId(),pendingAddress);
      friendPresence.addFeature(new AddressFeature(pendingAddress));
    }
  }
}",0.8637274549098196
3949,"/** 
 * Attempts to log in a connection using the specified configuration. Any existing connections will be logged out first.
 */
public void login(XMPPConnectionConfiguration configuration);","/** 
 * Attempts to log in a connection using the specified configuration. Any existing connections will be logged out first.
 */
public XMPPConnection login(XMPPConnectionConfiguration configuration) throws XMPPException ;",0.9033816425120772
3950,"protected void configure(){
  install(new LimeWireFriendXmppModule());
  bind(XMPPService.class).to(XMPPServiceImpl.class);
  EventMulticaster<RosterEvent> rosterMulticaster=new EventMulticasterImpl<RosterEvent>();
  bind(new TypeLiteral<EventBroadcaster<RosterEvent>>(){
  }
).toInstance(rosterMulticaster);
  bind(new TypeLiteral<ListenerSupport<RosterEvent>>(){
  }
).toInstance(rosterMulticaster);
  EventMulticaster<FileOfferEvent> fileOfferMulticaster=new EventMulticasterImpl<FileOfferEvent>();
  bind(new TypeLiteral<EventBroadcaster<FileOfferEvent>>(){
  }
).toInstance(fileOfferMulticaster);
  bind(new TypeLiteral<ListenerSupport<FileOfferEvent>>(){
  }
).toInstance(fileOfferMulticaster);
  EventMulticaster<LibraryChangedEvent> libraryChangedMulticaster=new EventMulticasterImpl<LibraryChangedEvent>();
  bind(new TypeLiteral<EventBroadcaster<LibraryChangedEvent>>(){
  }
).toInstance(libraryChangedMulticaster);
  bind(new TypeLiteral<ListenerSupport<LibraryChangedEvent>>(){
  }
).toInstance(libraryChangedMulticaster);
  EventMulticaster<XMPPConnectionEvent> connectionMulticaster=new EventMulticasterImpl<XMPPConnectionEvent>();
  bind(new TypeLiteral<EventBroadcaster<XMPPConnectionEvent>>(){
  }
).toInstance(connectionMulticaster);
  bind(new TypeLiteral<ListenerSupport<XMPPConnectionEvent>>(){
  }
).toInstance(connectionMulticaster);
  bind(XMPPAddressResolver.class).asEagerSingleton();
  bind(XMPPAddressSerializer.class).asEagerSingleton();
  bind(XMPPAuthenticator.class).asEagerSingleton();
}","protected void configure(){
  install(new LimeWireFriendXmppModule());
  bind(XMPPService.class).to(XMPPServiceImpl.class);
  EventMulticaster<RosterEvent> rosterMulticaster=new EventMulticasterImpl<RosterEvent>();
  bind(new TypeLiteral<EventBroadcaster<RosterEvent>>(){
  }
).toInstance(rosterMulticaster);
  bind(new TypeLiteral<ListenerSupport<RosterEvent>>(){
  }
).toInstance(rosterMulticaster);
  EventMulticaster<FileOfferEvent> fileOfferMulticaster=new EventMulticasterImpl<FileOfferEvent>();
  bind(new TypeLiteral<EventBroadcaster<FileOfferEvent>>(){
  }
).toInstance(fileOfferMulticaster);
  bind(new TypeLiteral<ListenerSupport<FileOfferEvent>>(){
  }
).toInstance(fileOfferMulticaster);
  EventMulticaster<LibraryChangedEvent> libraryChangedMulticaster=new EventMulticasterImpl<LibraryChangedEvent>();
  bind(new TypeLiteral<EventBroadcaster<LibraryChangedEvent>>(){
  }
).toInstance(libraryChangedMulticaster);
  bind(new TypeLiteral<ListenerSupport<LibraryChangedEvent>>(){
  }
).toInstance(libraryChangedMulticaster);
  EventMulticaster<XMPPConnectionEvent> connectionMulticaster=new EventMulticasterImpl<XMPPConnectionEvent>();
  bind(new TypeLiteral<EventMulticaster<XMPPConnectionEvent>>(){
  }
).toInstance(connectionMulticaster);
  bind(new TypeLiteral<EventBroadcaster<XMPPConnectionEvent>>(){
  }
).toInstance(connectionMulticaster);
  bind(new TypeLiteral<ListenerSupport<XMPPConnectionEvent>>(){
  }
).toInstance(connectionMulticaster);
  bind(XMPPAddressResolver.class).asEagerSingleton();
  bind(XMPPAddressSerializer.class).asEagerSingleton();
  bind(XMPPAuthenticator.class).asEagerSingleton();
}",0.9631277813095996
3951,"@Override public void reconnectionSuccessful(){
  connectionBroadcaster.broadcast(new XMPPConnectionEvent(XMPPConnectionImpl.this,XMPPConnectionEvent.Type.CONNECTED));
}","@Override public void reconnectionSuccessful(){
}",0.4495412844036697
3952,"public void login() throws XMPPException {
  connectionBroadcaster.broadcast(new XMPPConnectionEvent(this,XMPPConnectionEvent.Type.CONNECTING));
  loggingIn.set(true);
synchronized (this) {
    try {
      org.jivesoftware.smack.XMPPConnection.DEBUG_ENABLED=configuration.isDebugEnabled();
      connection=new org.jivesoftware.smack.XMPPConnection(getConnectionConfig(configuration));
      connection.addRosterListener(new RosterListenerImpl(connection));
      if (LOG.isInfoEnabled())       LOG.info(""String_Node_Str"" + configuration.getServiceName() + ""String_Node_Str""+ configuration.getHost()+ ""String_Node_Str""+ configuration.getPort()+ ""String_Node_Str"");
      connection.connect();
      LOG.info(""String_Node_Str"");
      if (LOG.isInfoEnabled())       LOG.infof(""String_Node_Str"" + configuration.getUsername() + ""String_Node_Str""+ configuration.getResource());
      connection.login(configuration.getUsername(),configuration.getPassword(),configuration.getResource());
      LOG.info(""String_Node_Str"");
      connectionBroadcaster.broadcast(new XMPPConnectionEvent(this,XMPPConnectionEvent.Type.CONNECTED));
    }
 catch (    org.jivesoftware.smack.XMPPException e) {
      throw new XMPPException(e);
    }
 finally {
      loggingIn.set(false);
    }
  }
}","public void login() throws XMPPException {
  connectionBroadcaster.broadcast(new XMPPConnectionEvent(this,XMPPConnectionEvent.Type.CONNECTING));
  loggingIn.set(true);
synchronized (this) {
    try {
      org.jivesoftware.smack.XMPPConnection.addConnectionCreationListener(smackConnectionListener);
      org.jivesoftware.smack.XMPPConnection.DEBUG_ENABLED=configuration.isDebugEnabled();
      connection=new org.jivesoftware.smack.XMPPConnection(getConnectionConfig(configuration));
      connection.addRosterListener(new RosterListenerImpl(connection));
      if (LOG.isInfoEnabled())       LOG.info(""String_Node_Str"" + configuration.getServiceName() + ""String_Node_Str""+ configuration.getHost()+ ""String_Node_Str""+ configuration.getPort()+ ""String_Node_Str"");
      connection.connect();
      LOG.info(""String_Node_Str"");
      if (LOG.isInfoEnabled())       LOG.infof(""String_Node_Str"" + configuration.getUsername() + ""String_Node_Str""+ configuration.getResource());
      connection.login(configuration.getUsername(),configuration.getPassword(),configuration.getResource());
      LOG.info(""String_Node_Str"");
      connectionBroadcaster.broadcast(new XMPPConnectionEvent(this,XMPPConnectionEvent.Type.CONNECTED));
    }
 catch (    org.jivesoftware.smack.XMPPException e) {
      connectionBroadcaster.broadcast(new XMPPConnectionEvent(this,XMPPConnectionEvent.Type.CONNECT_FAILED,e));
      if (connection != null && connection.isConnected()) {
        connection.disconnect();
      }
      org.jivesoftware.smack.XMPPConnection.removeConnectionCreationListener(smackConnectionListener);
      throw new XMPPException(e);
    }
 finally {
      loggingIn.set(false);
    }
  }
}",0.8595543551654288
3953,"public void logout(){
synchronized (this) {
    if (connection != null) {
      if (LOG.isInfoEnabled())       LOG.info(""String_Node_Str"" + configuration.getServiceName() + ""String_Node_Str""+ configuration.getHost()+ ""String_Node_Str""+ configuration.getPort()+ ""String_Node_Str"");
      try {
        connection.disconnect();
      }
 catch (      NullPointerException npe) {
      }
      addressIQListener.dispose();
      authTokenIQListener.dispose();
      addressIQListener=null;
      fileTransferIQListener=null;
      authTokenIQListener=null;
synchronized (users) {
        users.clear();
      }
      LOG.info(""String_Node_Str"");
    }
  }
}","public void logout(){
synchronized (this) {
    if (connection != null && connection.isAuthenticated()) {
      LOG.infof(""String_Node_Str"",configuration.getServiceName(),configuration.getHost(),configuration.getPort());
      connection.disconnect();
synchronized (users) {
        users.clear();
      }
      XMPPConnection.removeConnectionCreationListener(smackConnectionListener);
      connection=null;
      LOG.info(""String_Node_Str"");
    }
  }
}",0.2310469314079422
3954,"@Override public void reconnectionFailed(Exception e){
  connectionBroadcaster.broadcast(new XMPPConnectionEvent(XMPPConnectionImpl.this,XMPPConnectionEvent.Type.RECONNECTING_FAILED,e));
}","@Override public void reconnectionFailed(Exception e){
}",0.4590163934426229
3955,"@Override public void reconnectingIn(int seconds){
  connectionBroadcaster.broadcast(new XMPPConnectionEvent(XMPPConnectionImpl.this,XMPPConnectionEvent.Type.RECONNECTING));
}","@Override public void reconnectingIn(int seconds){
}",0.4581497797356828
3956,"XMPPConnectionImpl(XMPPConnectionConfiguration configuration,EventBroadcaster<RosterEvent> rosterBroadcaster,EventBroadcaster<FileOfferEvent> fileOfferBroadcaster,EventBroadcaster<LibraryChangedEvent> libraryChangedEventEventBroadcaster,EventBroadcaster<XMPPConnectionEvent> connectionBroadcaster,AddressFactory addressFactory,XMPPAuthenticator authenticator,EventMulticaster<FeatureEvent> featureSupport){
  this.configuration=configuration;
  this.fileOfferBroadcaster=fileOfferBroadcaster;
  this.libraryChangedEventEventBroadcaster=libraryChangedEventEventBroadcaster;
  this.connectionBroadcaster=connectionBroadcaster;
  this.addressFactory=addressFactory;
  this.authenticator=authenticator;
  this.rosterListeners=new EventListenerList<RosterEvent>();
  if (configuration.getRosterListener() != null) {
    this.rosterListeners.addListener(configuration.getRosterListener());
  }
  this.rosterListeners.addListener(new EventRebroadcaster<RosterEvent>(rosterBroadcaster));
  this.users=new TreeMap<String,UserImpl>(String.CASE_INSENSITIVE_ORDER);
  this.featureSupport=featureSupport;
}","XMPPConnectionImpl(XMPPConnectionConfiguration configuration,EventBroadcaster<RosterEvent> rosterBroadcaster,EventBroadcaster<FileOfferEvent> fileOfferBroadcaster,EventBroadcaster<LibraryChangedEvent> libraryChangedEventEventBroadcaster,EventBroadcaster<XMPPConnectionEvent> connectionBroadcaster,AddressFactory addressFactory,XMPPAuthenticator authenticator,EventMulticaster<FeatureEvent> featureSupport){
  this.configuration=configuration;
  this.fileOfferBroadcaster=fileOfferBroadcaster;
  this.libraryChangedEventEventBroadcaster=libraryChangedEventEventBroadcaster;
  this.connectionBroadcaster=connectionBroadcaster;
  this.addressFactory=addressFactory;
  this.authenticator=authenticator;
  this.rosterListeners=new EventListenerList<RosterEvent>();
  if (configuration.getRosterListener() != null) {
    this.rosterListeners.addListener(configuration.getRosterListener());
  }
  this.rosterListeners.addListener(new EventRebroadcaster<RosterEvent>(rosterBroadcaster));
  this.users=new TreeMap<String,UserImpl>(String.CASE_INSENSITIVE_ORDER);
  this.featureSupport=featureSupport;
  smackConnectionListener=new SmackConnectionListener();
}",0.9745876058849756
3957,"@Override public void connectionClosedOnError(Exception e){
  connectionBroadcaster.broadcast(new XMPPConnectionEvent(XMPPConnectionImpl.this,XMPPConnectionEvent.Type.DISCONNECTED,e));
}","@Override public void connectionClosedOnError(Exception e){
  cleanup();
  connectionBroadcaster.broadcast(new XMPPConnectionEvent(XMPPConnectionImpl.this,XMPPConnectionEvent.Type.DISCONNECTED,e));
}",0.9662337662337662
3958,"public void connectionCreated(final org.jivesoftware.smack.XMPPConnection connection){
  if (XMPPConnectionImpl.this.connection != connection) {
    return;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + connection.toString());
  }
  connection.addConnectionListener(new SmackConnectionListener());
synchronized (ProviderManager.getInstance()) {
    if (ProviderManager.getInstance().getIQProvider(""String_Node_Str"",""String_Node_Str"") == null) {
      ProviderManager.getInstance().addIQProvider(""String_Node_Str"",""String_Node_Str"",new AddressIQProvider(addressFactory));
    }
    if (ProviderManager.getInstance().getIQProvider(""String_Node_Str"",""String_Node_Str"") == null) {
      ProviderManager.getInstance().addIQProvider(""String_Node_Str"",""String_Node_Str"",FileTransferIQ.getIQProvider());
    }
    if (ProviderManager.getInstance().getIQProvider(""String_Node_Str"",""String_Node_Str"") == null) {
      ProviderManager.getInstance().addIQProvider(""String_Node_Str"",""String_Node_Str"",new AuthTokenIQProvider());
    }
    if (ProviderManager.getInstance().getIQProvider(""String_Node_Str"",""String_Node_Str"") == null) {
      ProviderManager.getInstance().addIQProvider(""String_Node_Str"",""String_Node_Str"",LibraryChangedIQ.getIQProvider());
    }
  }
  ChatStateManager.getInstance(connection);
  ServiceDiscoveryManager.getInstanceFor(connection).addFeature(XMPPServiceImpl.LW_SERVICE_NS);
synchronized (XMPPConnectionImpl.this) {
    Address address=null;
    if (lastEvent != null) {
      address=lastEvent.getSource();
    }
    addressIQListener=new AddressIQListener(XMPPConnectionImpl.this,addressFactory,address,featureSupport);
  }
  connection.addPacketListener(addressIQListener,addressIQListener.getPacketFilter());
  fileTransferIQListener=new FileTransferIQListener(fileOfferBroadcaster);
  connection.addPacketListener(fileTransferIQListener,fileTransferIQListener.getPacketFilter());
  authTokenIQListener=new AuthTokenIQListener(XMPPConnectionImpl.this,authenticator,featureSupport);
  connection.addPacketListener(authTokenIQListener,authTokenIQListener.getPacketFilter());
  libChangedIQListener=new LibraryChangedIQListener(libraryChangedEventEventBroadcaster,XMPPConnectionImpl.this);
  connection.addPacketListener(libChangedIQListener,libChangedIQListener.getPacketFilter());
}","@Override public void connectionCreated(XMPPConnection connection){
  if (XMPPConnectionImpl.this.connection != connection) {
    return;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + connection.toString());
  }
  connection.addConnectionListener(this);
synchronized (ProviderManager.getInstance()) {
    if (ProviderManager.getInstance().getIQProvider(""String_Node_Str"",""String_Node_Str"") == null) {
      ProviderManager.getInstance().addIQProvider(""String_Node_Str"",""String_Node_Str"",new AddressIQProvider(addressFactory));
    }
    if (ProviderManager.getInstance().getIQProvider(""String_Node_Str"",""String_Node_Str"") == null) {
      ProviderManager.getInstance().addIQProvider(""String_Node_Str"",""String_Node_Str"",FileTransferIQ.getIQProvider());
    }
    if (ProviderManager.getInstance().getIQProvider(""String_Node_Str"",""String_Node_Str"") == null) {
      ProviderManager.getInstance().addIQProvider(""String_Node_Str"",""String_Node_Str"",new AuthTokenIQProvider());
    }
    if (ProviderManager.getInstance().getIQProvider(""String_Node_Str"",""String_Node_Str"") == null) {
      ProviderManager.getInstance().addIQProvider(""String_Node_Str"",""String_Node_Str"",LibraryChangedIQ.getIQProvider());
    }
  }
  ChatStateManager.getInstance(connection);
  ServiceDiscoveryManager.getInstanceFor(connection).addFeature(XMPPServiceImpl.LW_SERVICE_NS);
synchronized (XMPPConnectionImpl.this) {
    Address address=null;
    if (lastEvent != null) {
      address=lastEvent.getSource();
    }
    addressIQListener=new AddressIQListener(XMPPConnectionImpl.this,addressFactory,address,featureSupport);
  }
  connection.addPacketListener(addressIQListener,addressIQListener.getPacketFilter());
  fileTransferIQListener=new FileTransferIQListener(fileOfferBroadcaster);
  connection.addPacketListener(fileTransferIQListener,fileTransferIQListener.getPacketFilter());
  authTokenIQListener=new AuthTokenIQListener(XMPPConnectionImpl.this,authenticator,featureSupport);
  connection.addPacketListener(authTokenIQListener,authTokenIQListener.getPacketFilter());
  libChangedIQListener=new LibraryChangedIQListener(libraryChangedEventEventBroadcaster,XMPPConnectionImpl.this);
  connection.addPacketListener(libChangedIQListener,libChangedIQListener.getPacketFilter());
}",0.9843682153712549
3959,"@Override public void connectionClosed(){
  connectionBroadcaster.broadcast(new XMPPConnectionEvent(XMPPConnectionImpl.this,XMPPConnectionEvent.Type.DISCONNECTED));
}","@Override public void connectionClosed(){
  cleanup();
  connectionBroadcaster.broadcast(new XMPPConnectionEvent(XMPPConnectionImpl.this,XMPPConnectionEvent.Type.DISCONNECTED));
}",0.9623188405797102
3960,"@Override @BlockingEvent public void handleEvent(XMPPConnectionEvent event){
  if (event.getType() == XMPPConnectionEvent.Type.DISCONNECTED && event.getData() != null) {
synchronized (XMPPServiceImpl.this) {
      XMPPConnection connection=event.getSource();
      XMPPConnectionConfiguration configuration=connection.getConfiguration();
      connections.remove(connection);
      connection=null;
      long sleepTime=10000;
      while (connection == null) {
        try {
          LOG.debugf(""String_Node_Str"" + configuration.getServiceName());
          connection=login(configuration);
        }
 catch (        XMPPException e) {
        }
        try {
          Thread.sleep(sleepTime);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
}","@Override @BlockingEvent public void handleEvent(XMPPConnectionEvent event){
  if (event.getType() == XMPPConnectionEvent.Type.DISCONNECTED && event.getData() != null) {
    XMPPConnection connection=event.getSource();
    XMPPConnectionConfiguration configuration=connection.getConfiguration();
synchronized (XMPPServiceImpl.this) {
      connections.remove(connection);
    }
    connection=null;
    long sleepTime=10000;
    while (connection == null) {
      try {
        LOG.debugf(""String_Node_Str"" + configuration.getServiceName());
        connection=login(configuration,true);
      }
 catch (      XMPPException e) {
      }
      try {
        Thread.sleep(sleepTime);
      }
 catch (      InterruptedException e) {
      }
    }
  }
}",0.7439423706614277
3961,"@Override public XMPPConnection login(XMPPConnectionConfiguration configuration) throws XMPPException {
synchronized (this) {
    if (!multipleConnectionsAllowed) {
      XMPPConnection activeConnection=getActiveConnection();
      if (activeConnection != null && activeConnection.getConfiguration().equals(configuration)) {
        return activeConnection;
      }
 else {
        logout();
      }
    }
    XMPPConnectionImpl connection=new XMPPConnectionImpl(configuration,rosterBroadcaster.get(),fileOfferBroadcaster.get(),libraryChangedBroadcaster.get(),connectionBroadcaster.get(),addressFactory,authenticator,featureSupport);
    if (lastAddressEvent != null) {
      connection.handleEvent(lastAddressEvent);
    }
    try {
      connection.login();
      connections.add(connection);
      return connection;
    }
 catch (    XMPPException e) {
      LOG.debug(e.getMessage(),e);
      throw new XMPPException(e);
    }
  }
}","public XMPPConnection login(XMPPConnectionConfiguration configuration,boolean isReconnect) throws XMPPException {
synchronized (this) {
    if (!multipleConnectionsAllowed) {
      XMPPConnection activeConnection=getActiveConnection();
      if (isReconnect) {
        if (activeConnection != null) {
          return activeConnection;
        }
      }
 else {
        if (activeConnection != null && activeConnection.getConfiguration().equals(configuration)) {
          return activeConnection;
        }
 else {
          logout();
        }
      }
    }
    XMPPConnectionImpl connection=new XMPPConnectionImpl(configuration,rosterBroadcaster.get(),fileOfferBroadcaster.get(),libraryChangedBroadcaster.get(),connectionBroadcaster.get(),addressFactory,authenticator,featureSupport);
    if (lastAddressEvent != null) {
      connection.handleEvent(lastAddressEvent);
    }
    try {
      connection.login();
      connections.add(connection);
      return connection;
    }
 catch (    XMPPException e) {
      LOG.debug(e.getMessage(),e);
      throw new XMPPException(e);
    }
  }
}",0.9142011834319528
3962,"@Override public void setEnabled(boolean b){
  if (this.isEnabled() != b) {
    this.foregroundPainter.clearCache();
  }
  super.setEnabled(b);
}","@Override public void setEnabled(boolean b){
  if (this.isEnabled() != b) {
    this.foregroundPainter.clearCache();
    this.backgroundPainter.clearCache();
  }
  super.setEnabled(b);
}",0.8761329305135952
3963,"public LimeProgressBar(AbstractPainter<JProgressBar> foregroundPainter,Painter<JComponent> backgroundPainter){
  this.foregroundPainter=foregroundPainter;
  this.backgroundPainter=backgroundPainter;
  this.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
}","public LimeProgressBar(AbstractPainter<JProgressBar> foregroundPainter,AbstractPainter<JComponent> backgroundPainter){
  this.foregroundPainter=foregroundPainter;
  this.backgroundPainter=backgroundPainter;
  this.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
}",0.9848484848484848
3964,"@Override public void setValue(int v){
  if (this.getValue() != v) {
    this.foregroundPainter.clearCache();
  }
  super.setValue(v);
}","@Override public void setValue(int v){
  if (this.getValue() != v) {
    this.foregroundPainter.clearCache();
    this.backgroundPainter.clearCache();
  }
  super.setValue(v);
}",0.8690095846645367
3965,"public void setBackgroundPainter(Painter<JComponent> painter){
  this.backgroundPainter=painter;
}","public void setBackgroundPainter(AbstractPainter<JComponent> painter){
  this.backgroundPainter=painter;
}",0.9607843137254902
3966,"private void createMinView(){
  GridBagConstraints gbc=new GridBagConstraints();
  Insets insets=new Insets(0,10,0,0);
  gbc.insets=insets;
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.CENTER;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridheight=5;
  minPanel.add(minIconLabel,gbc);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.gridx=1;
  gbc.weightx=1;
  gbc.weighty=0;
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  gbc.gridheight=1;
  minPanel.add(minTitleLabel,gbc);
  gbc.insets=new Insets(5,4,0,0);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.anchor=GridBagConstraints.CENTER;
  gbc.gridx=4;
  gbc.gridy=0;
  gbc.weightx=1;
  gbc.weighty=0;
  gbc.gridwidth=1;
  gbc.gridheight=5;
  minPanel.add(minButtonPanel,gbc);
  gbc.insets=insets;
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=1;
  gbc.gridy=1;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=1;
  gbc.gridheight=0;
  minPanel.add(minStatusLabel,gbc);
  gbc.insets=new Insets(0,0,0,0);
  gbc.gridx++;
  minPanel.add(minLinkButton,gbc);
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=1;
  gbc.gridy=2;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=3;
  gbc.gridheight=0;
  minPanel.add(Box.createHorizontalStrut(progressBarWidth - 16),gbc);
}","private void createMinView(){
  GridBagConstraints gbc=new GridBagConstraints();
  Insets insets=new Insets(0,10,0,0);
  gbc.insets=insets;
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.CENTER;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridheight=5;
  minPanel.add(minIconLabel,gbc);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.gridx=1;
  gbc.weightx=1;
  gbc.weighty=0;
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  gbc.gridheight=1;
  minPanel.add(minTitleLabel,gbc);
  gbc.insets=new Insets(6,4,0,0);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.anchor=GridBagConstraints.CENTER;
  gbc.gridx=4;
  gbc.gridy=0;
  gbc.weightx=1;
  gbc.weighty=0;
  gbc.gridwidth=1;
  gbc.gridheight=5;
  minPanel.add(minButtonPanel,gbc);
  gbc.insets=insets;
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=1;
  gbc.gridy=1;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=1;
  gbc.gridheight=0;
  minPanel.add(minStatusLabel,gbc);
  gbc.insets=new Insets(0,0,0,0);
  gbc.gridx++;
  minPanel.add(minLinkButton,gbc);
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=1;
  gbc.gridy=2;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=3;
  gbc.gridheight=0;
  minPanel.add(Box.createHorizontalStrut(progressBarWidth - 16),gbc);
}",0.9992647058823528
3967,"public ProgressBarBackgroundPainter(Paint background,Paint border,Paint borderDisabled){
  this.background=background;
  this.border=border;
  this.borderDisabled=borderDisabled;
  this.setAntialiasing(false);
  this.setCacheable(true);
}","public ProgressBarBackgroundPainter(Paint background,Paint border,Paint borderDisabled){
  this.background=background;
  this.border=border;
  this.borderDisabled=borderDisabled;
  this.setAntialiasing(false);
  this.setCacheable(false);
}",0.9853249475890984
3968,"public Painter<JComponent> createBackgroundPainter(){
  return new ProgressBarBackgroundPainter(new GradientPaint(0,0,this.barBackgroundGradientTop,0,1,this.barBackgroundGradientBottom),this.border,this.borderDisabled);
}","public AbstractPainter<JComponent> createBackgroundPainter(){
  return new ProgressBarBackgroundPainter(new GradientPaint(0,0,this.barBackgroundGradientTop,0,1,this.barBackgroundGradientBottom),this.border,this.borderDisabled);
}",0.9822222222222222
3969,"@Override public synchronized XMPPConnection getLoggedInConnection(){
  try {
    return connections.pop();
  }
 catch (  NoSuchElementException nsex) {
    return null;
  }
}","@Override public synchronized XMPPConnection getLoggedInConnection(){
  return connections.peek();
}",0.7054545454545454
3970,"protected void setUp() throws Exception {
  super.setUp();
  injector=createInjector(getModules());
  registry=injector.getInstance(ServiceRegistry.class);
  registry.initialize();
  registry.start();
  service=injector.getInstance(XMPPServiceImpl.class);
  service.setMultipleConnectionsAllowed(true);
  aliceRosterListener=new RosterListenerMock();
  bobRosterListener=new RosterListenerMock();
  alice=new XMPPConnectionConfigurationMock(USERNAME_1,PASSWORD_1,HOST,PORT,SERVICE,aliceRosterListener);
  bob=new XMPPConnectionConfigurationMock(USERNAME_2,PASSWORD_2,HOST,PORT,SERVICE,bobRosterListener);
  service.login(alice);
  service.login(bob);
  Thread.sleep(SLEEP);
  assertEquals(""String_Node_Str"",1,aliceRosterListener.roster.get(USERNAME_2).size());
  assertEquals(""String_Node_Str"",1,bobRosterListener.roster.get(USERNAME_1).size());
}","protected void setUp() throws Exception {
  super.setUp();
  injector=createInjector(getModules());
  registry=injector.getInstance(ServiceRegistry.class);
  registry.initialize();
  registry.start();
  service=injector.getInstance(XMPPServiceImpl.class);
  service.setMultipleConnectionsAllowed(true);
  service.setXmppErrorListener(new XMPPErrorListener(){
    public void register(    XMPPService xmppService){
      xmppService.setXmppErrorListener(this);
    }
    public void error(    XMPPException exception){
      exception.printStackTrace();
    }
  }
);
  aliceRosterListener=new RosterListenerMock();
  bobRosterListener=new RosterListenerMock();
  alice=new XMPPConnectionConfigurationMock(USERNAME_1,PASSWORD_1,HOST,PORT,SERVICE,aliceRosterListener);
  bob=new XMPPConnectionConfigurationMock(USERNAME_2,PASSWORD_2,HOST,PORT,SERVICE,bobRosterListener);
  service.login(alice);
  service.login(bob);
  Thread.sleep(SLEEP);
  assertEquals(""String_Node_Str"",1,aliceRosterListener.roster.get(USERNAME_2).size());
  assertEquals(""String_Node_Str"",1,bobRosterListener.roster.get(USERNAME_1).size());
}",0.8656106285130302
3971,"protected void configure(){
  binder().install(new LimeWireXMPPModule());
  bind(XmppPresenceLibraryAdder.class);
  bind(FriendShareListRefresher.FriendShareListEventImpl.class);
  bind(RemoteFileItemFactory.class).to(RemoteFileItemFactoryImpl.class);
  bind(CoreGlueXMPPService.class);
}","protected void configure(){
  binder().install(new LimeWireXMPPModule());
  bind(XmppPresenceLibraryAdder.class);
  bind(FriendShareListRefresher.FriendShareListEventImpl.class);
  bind(RemoteFileItemFactory.class).to(RemoteFileItemFactoryImpl.class);
  bind(CoreGlueXMPPService.class);
  bind(PasswordManager.class).to(PasswordManagerImpl.class);
  bind(XMPPResourceFactory.class).to(XMPPResourceFactoryImpl.class);
}",0.8158640226628895
3972,"@Inject public XMPPServiceImpl(Provider<EventBroadcaster<RosterEvent>> rosterBroadcaster,Provider<EventBroadcaster<FileOfferEvent>> fileOfferBroadcaster,Provider<EventBroadcaster<LibraryChangedEvent>> libraryChangedBroadcaster,Provider<EventBroadcaster<XMPPConnectionEvent>> connectionBroadcaster,AddressFactory addressFactory,XMPPAuthenticator authenticator,ListenerSupport<FriendPresenceEvent> presenceSupport,ApplicationServices applicationServices){
  this.rosterBroadcaster=rosterBroadcaster;
  this.fileOfferBroadcaster=fileOfferBroadcaster;
  this.libraryChangedBroadcaster=libraryChangedBroadcaster;
  this.connectionBroadcaster=connectionBroadcaster;
  this.addressFactory=addressFactory;
  this.authenticator=authenticator;
  this.presenceSupport=presenceSupport;
  byte[] hash=new SHA1().digest(applicationServices.getMyGUID());
  byte[] base64=Base64.encodeBase64(hash);
  resource=StringUtils.getUTF8String(base64);
  connections=new LinkedList<XMPPConnectionImpl>();
  multipleConnectionsAllowed=false;
}","@Inject public XMPPServiceImpl(Provider<EventBroadcaster<RosterEvent>> rosterBroadcaster,Provider<EventBroadcaster<FileOfferEvent>> fileOfferBroadcaster,Provider<EventBroadcaster<LibraryChangedEvent>> libraryChangedBroadcaster,Provider<EventBroadcaster<XMPPConnectionEvent>> connectionBroadcaster,AddressFactory addressFactory,XMPPAuthenticator authenticator,ListenerSupport<FriendPresenceEvent> presenceSupport){
  this.rosterBroadcaster=rosterBroadcaster;
  this.fileOfferBroadcaster=fileOfferBroadcaster;
  this.libraryChangedBroadcaster=libraryChangedBroadcaster;
  this.connectionBroadcaster=connectionBroadcaster;
  this.addressFactory=addressFactory;
  this.authenticator=authenticator;
  this.presenceSupport=presenceSupport;
  connections=new LinkedList<XMPPConnectionImpl>();
  multipleConnectionsAllowed=false;
}",0.8940793047256925
3973,"@Override public synchronized void login(XMPPConnectionConfiguration configuration){
  if (!multipleConnectionsAllowed)   logout();
  XMPPConnectionImpl connection=new XMPPConnectionImpl(configuration,rosterBroadcaster.get(),fileOfferBroadcaster.get(),libraryChangedBroadcaster.get(),connectionBroadcaster.get(),addressFactory,authenticator,presenceSupport,resource);
  connection.initialize();
  if (lastAddressEvent != null)   connection.handleEvent(lastAddressEvent);
  try {
    connection.login();
    connections.add(connection);
  }
 catch (  XMPPException e) {
    LOG.error(e.getMessage(),e);
    errorListener.error(e);
  }
}","@Override public synchronized void login(XMPPConnectionConfiguration configuration){
  if (!multipleConnectionsAllowed)   logout();
  XMPPConnectionImpl connection=new XMPPConnectionImpl(configuration,rosterBroadcaster.get(),fileOfferBroadcaster.get(),libraryChangedBroadcaster.get(),connectionBroadcaster.get(),addressFactory,authenticator,presenceSupport);
  connection.initialize();
  if (lastAddressEvent != null)   connection.handleEvent(lastAddressEvent);
  try {
    connection.login();
    connections.add(connection);
  }
 catch (  XMPPException e) {
    LOG.error(e.getMessage(),e);
    errorListener.error(e);
  }
}",0.992862807295797
3974,"@Override protected void configure(){
  bind(XMPPService.class).to(MockXmppService.class);
  EventMulticaster<RosterEvent> rosterMulticaster=new EventMulticasterImpl<RosterEvent>();
  bind(new TypeLiteral<EventBroadcaster<RosterEvent>>(){
  }
).toInstance(rosterMulticaster);
  bind(new TypeLiteral<ListenerSupport<RosterEvent>>(){
  }
).toInstance(rosterMulticaster);
  EventMulticaster<FileOfferEvent> fileOfferMulticaster=new EventMulticasterImpl<FileOfferEvent>();
  bind(new TypeLiteral<EventBroadcaster<FileOfferEvent>>(){
  }
).toInstance(fileOfferMulticaster);
  bind(new TypeLiteral<ListenerSupport<FileOfferEvent>>(){
  }
).toInstance(fileOfferMulticaster);
  EventMulticaster<XMPPConnectionEvent> connectionMulticaster=new EventMulticasterImpl<XMPPConnectionEvent>();
  bind(new TypeLiteral<EventBroadcaster<XMPPConnectionEvent>>(){
  }
).toInstance(connectionMulticaster);
  bind(new TypeLiteral<ListenerSupport<XMPPConnectionEvent>>(){
  }
).toInstance(connectionMulticaster);
  bind(RemoteFileItemFactory.class).to(MockRemoteFileItemFactory.class);
  EventMulticaster<FriendEvent> knownMulticaster=new EventMulticasterImpl<FriendEvent>();
  EventMulticaster<FriendEvent> availMulticaster=new EventMulticasterImpl<FriendEvent>();
  EventMulticaster<FriendPresenceEvent> presenceMulticaster=new EventMulticasterImpl<FriendPresenceEvent>();
  bind(new TypeLiteral<ListenerSupport<FriendEvent>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(knownMulticaster);
  bind(new TypeLiteral<EventBroadcaster<FriendEvent>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(knownMulticaster);
  bind(new TypeLiteral<ListenerSupport<FriendEvent>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(availMulticaster);
  bind(new TypeLiteral<EventBroadcaster<FriendEvent>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(availMulticaster);
  bind(new TypeLiteral<ListenerSupport<FriendPresenceEvent>>(){
  }
).toInstance(presenceMulticaster);
  bind(new TypeLiteral<EventBroadcaster<FriendPresenceEvent>>(){
  }
).toInstance(presenceMulticaster);
}","@Override protected void configure(){
  bind(XMPPService.class).to(MockXmppService.class);
  EventMulticaster<RosterEvent> rosterMulticaster=new EventMulticasterImpl<RosterEvent>();
  bind(new TypeLiteral<EventBroadcaster<RosterEvent>>(){
  }
).toInstance(rosterMulticaster);
  bind(new TypeLiteral<ListenerSupport<RosterEvent>>(){
  }
).toInstance(rosterMulticaster);
  EventMulticaster<FileOfferEvent> fileOfferMulticaster=new EventMulticasterImpl<FileOfferEvent>();
  bind(new TypeLiteral<EventBroadcaster<FileOfferEvent>>(){
  }
).toInstance(fileOfferMulticaster);
  bind(new TypeLiteral<ListenerSupport<FileOfferEvent>>(){
  }
).toInstance(fileOfferMulticaster);
  EventMulticaster<XMPPConnectionEvent> connectionMulticaster=new EventMulticasterImpl<XMPPConnectionEvent>();
  bind(new TypeLiteral<EventBroadcaster<XMPPConnectionEvent>>(){
  }
).toInstance(connectionMulticaster);
  bind(new TypeLiteral<ListenerSupport<XMPPConnectionEvent>>(){
  }
).toInstance(connectionMulticaster);
  bind(PasswordManager.class).to(MockPasswordManager.class);
  bind(RemoteFileItemFactory.class).to(MockRemoteFileItemFactory.class);
  EventMulticaster<FriendEvent> knownMulticaster=new EventMulticasterImpl<FriendEvent>();
  EventMulticaster<FriendEvent> availMulticaster=new EventMulticasterImpl<FriendEvent>();
  EventMulticaster<FriendPresenceEvent> presenceMulticaster=new EventMulticasterImpl<FriendPresenceEvent>();
  bind(new TypeLiteral<ListenerSupport<FriendEvent>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(knownMulticaster);
  bind(new TypeLiteral<EventBroadcaster<FriendEvent>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(knownMulticaster);
  bind(new TypeLiteral<ListenerSupport<FriendEvent>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(availMulticaster);
  bind(new TypeLiteral<EventBroadcaster<FriendEvent>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(availMulticaster);
  bind(new TypeLiteral<ListenerSupport<FriendPresenceEvent>>(){
  }
).toInstance(presenceMulticaster);
  bind(new TypeLiteral<EventBroadcaster<FriendPresenceEvent>>(){
  }
).toInstance(presenceMulticaster);
}",0.9857775705292608
3975,"@Inject public LibrarySharePanel(List<SharingTarget> allFriends){
  GuiUtils.assignResources(this);
  this.allFriends=allFriends;
  setLayout(new FlowLayout(FlowLayout.LEFT,0,0));
  setOpaque(false);
  setBorder(new LineBorder(Color.BLACK));
  mainPanel=new JXPanel(new GridBagLayout());
  mainPanel.setOpaque(false);
  inputField=new JTextField(12);
  inputField.setBorder(null);
  shareLabel=new JLabel(I18n.tr(""String_Node_Str""));
  shareFriendList=GlazedListsFactory.threadSafeList(GlazedListsFactory.sortedList(new BasicEventList<SharingTarget>(),new SharingTargetComparator()));
  shareTable=new ToolTipTable(new EventTableModel<SharingTarget>(shareFriendList,new LibraryShareTableFormat(1)));
  shareTable.setTableHeader(null);
  final ShareRendererEditor removeEditor=new ShareRendererEditor(removeIcon,removeIconRollover,removeIconPressed);
  removeEditor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      unshareFriend(removeEditor.getFriend());
      removeEditor.cancelCellEditing();
      inputField.requestFocusInWindow();
    }
  }
);
  shareTable.setHighlighters(new ColorHighlighter());
  shareTable.setRowHeight(removeEditor.getPreferredSize().height);
  shareTable.getColumnModel().getColumn(1).setCellEditor(removeEditor);
  shareTable.getColumnModel().getColumn(1).setPreferredWidth(removeEditor.getPreferredSize().width);
  shareTable.getColumnModel().getColumn(1).setMaxWidth(removeEditor.getPreferredSize().width);
  shareTable.getColumnModel().getColumn(1).setCellRenderer(new ShareRendererEditor(removeIcon,removeIconRollover,removeIconPressed));
  shareTable.setShowGrid(false);
  shareTable.setOpaque(false);
  shareTable.setColumnSelectionAllowed(false);
  shareTable.setRowSelectionAllowed(false);
  TextFilterator<SharingTarget> textFilter=new TextFilterator<SharingTarget>(){
    @Override public void getFilterStrings(    List<String> baseList,    SharingTarget element){
      baseList.add(element.getFriend().getName());
      baseList.add(element.getFriend().getId());
    }
  }
;
  noShareFriendList=GlazedLists.threadSafeList(GlazedListsFactory.sortedList(new BasicEventList<SharingTarget>(),new SharingTargetComparator()));
  final TextMatcherEditor<SharingTarget> textMatcher=new TextMatcherEditor<SharingTarget>(textFilter);
  noShareFilterList=GlazedListsFactory.filterList(noShareFriendList,textMatcher);
  friendCombo=new JComboBox(new EventComboBoxModel<SharingTarget>(noShareFilterList));
  ShareComboBoxUI comboUI=new ShareComboBoxUI();
  friendCombo.setUI(comboUI);
  friendCombo.setEditor(new ShareComboBoxEditor());
  friendCombo.setEditable(true);
  comboPopup=comboUI.getPopup();
  friendCombo.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (friendCombo.isPopupVisible() && (e.getModifiers() & InputEvent.BUTTON1_MASK) != 0) {
        shareSelectedFriend();
      }
    }
  }
);
  inputField.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (noShareFilterList.size() == 0 || !friendCombo.isPopupVisible() && (""String_Node_Str"".equals(inputField.getText()) || inputField.getText() == null)) {
        dialog.setVisible(false);
      }
 else       if (friendCombo.getSelectedIndex() >= 0) {
        shareSelectedFriend();
        friendCombo.hidePopup();
      }
    }
  }
);
  inputField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      update();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      update();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      update();
    }
    private void update(){
      textMatcher.setFilterText(inputField.getText().split(""String_Node_Str""));
      if (noShareFilterList.size() > 0) {
        friendCombo.setSelectedIndex(0);
        if (isVisible()) {
          friendCombo.showPopup();
        }
      }
    }
  }
);
  shareScroll=new JScrollPane(shareTable);
  shareScroll.setBorder(new EmptyBorder(0,shareTableIndent,0,0));
  shareScroll.setOpaque(false);
  friendLabel=new JLabel(I18n.tr(""String_Node_Str""));
  shareFriendList.addListEventListener(new ListEventListener<SharingTarget>(){
    @Override public void listChanged(    ListEvent<SharingTarget> listChanges){
      adjustFriendLabelVisibility();
    }
  }
);
  Dimension labelSize=friendLabel.getPreferredSize().width > shareLabel.getPreferredSize().width ? friendLabel.getPreferredSize() : shareLabel.getPreferredSize();
  friendLabel.setPreferredSize(labelSize);
  shareLabel.setPreferredSize(labelSize);
  bottomLabel=new MultiLineLabel(""String_Node_Str"",WIDTH);
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.weightx=1.0;
  gbc.weighty=0;
  gbc.fill=GridBagConstraints.BOTH;
  gbc.insets=new Insets(0,HGAP,0,HGAP);
  gbc.gridy=0;
  gbc.weighty=0;
  mainPanel.add(shareLabel,gbc);
  gbc.gridy++;
  gbc.weighty=1.0;
  mainPanel.add(shareScroll,gbc);
  gbc.gridy++;
  mainPanel.add(friendLabel,gbc);
  gbc.gridy++;
  gbc.weighty=1.0;
  mainPanel.add(friendCombo,gbc);
  gbc.gridy++;
  mainPanel.add(bottomLabel,gbc);
  add(mainPanel);
  EventAnnotationProcessor.subscribe(this);
  setKeyStrokes(this);
  setKeyStrokes(mainPanel);
  setKeyStrokes(inputField);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      if (dialog.isVisible()) {
        dialog.pack();
      }
    }
    @Override public void componentShown(    ComponentEvent e){
      inputField.requestFocusInWindow();
    }
  }
);
  eventListener=new AWTEventListener(){
    @Override public void eventDispatched(    AWTEvent event){
      if (dialog.isVisible()) {
        if ((event.getID() == MouseEvent.MOUSE_PRESSED)) {
          MouseEvent e=(MouseEvent)event;
          if (LibrarySharePanel.this != e.getComponent() && !contains(e.getComponent())) {
            dialog.setVisible(false);
          }
        }
 else         if (event.getID() == KeyEvent.KEY_TYPED) {
          KeyEvent e=(KeyEvent)event;
          if (e.getKeyChar() == KeyEvent.VK_ESCAPE) {
            dialog.setVisible(false);
          }
        }
      }
    }
  }
;
}","@Inject public LibrarySharePanel(List<SharingTarget> allFriends){
  GuiUtils.assignResources(this);
  this.allFriends=allFriends;
  setLayout(new FlowLayout(FlowLayout.LEFT,0,0));
  setOpaque(false);
  setBorder(new LineBorder(Color.BLACK));
  mainPanel=new JXPanel(new GridBagLayout());
  mainPanel.setOpaque(false);
  inputField=new JTextField(12);
  inputField.setBorder(null);
  shareLabel=new JLabel(I18n.tr(""String_Node_Str""));
  shareFriendList=GlazedListsFactory.threadSafeList(GlazedListsFactory.sortedList(new BasicEventList<SharingTarget>(),new SharingTargetComparator()));
  shareTable=new ToolTipTable(new EventTableModel<SharingTarget>(shareFriendList,new LibraryShareTableFormat(1)));
  shareTable.setTableHeader(null);
  final ShareRendererEditor removeEditor=new ShareRendererEditor(removeIcon,removeIconRollover,removeIconPressed);
  removeEditor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      unshareFriend(removeEditor.getFriend());
      removeEditor.cancelCellEditing();
      inputField.requestFocusInWindow();
    }
  }
);
  shareTable.setHighlighters(new ColorHighlighter());
  shareTable.setRowHeight(removeEditor.getPreferredSize().height);
  shareTable.getColumnModel().getColumn(1).setCellEditor(removeEditor);
  shareTable.getColumnModel().getColumn(1).setPreferredWidth(removeEditor.getPreferredSize().width);
  shareTable.getColumnModel().getColumn(1).setMaxWidth(removeEditor.getPreferredSize().width);
  shareTable.getColumnModel().getColumn(1).setCellRenderer(new ShareRendererEditor(removeIcon,removeIconRollover,removeIconPressed));
  shareTable.setShowGrid(false);
  shareTable.setOpaque(false);
  shareTable.setColumnSelectionAllowed(false);
  shareTable.setRowSelectionAllowed(false);
  TextFilterator<SharingTarget> textFilter=new TextFilterator<SharingTarget>(){
    @Override public void getFilterStrings(    List<String> baseList,    SharingTarget element){
      baseList.add(element.getFriend().getName());
      baseList.add(element.getFriend().getId());
    }
  }
;
  noShareFriendList=GlazedLists.threadSafeList(GlazedListsFactory.sortedList(new BasicEventList<SharingTarget>(),new SharingTargetComparator()));
  final TextMatcherEditor<SharingTarget> textMatcher=new TextMatcherEditor<SharingTarget>(textFilter);
  noShareFilterList=GlazedListsFactory.filterList(noShareFriendList,textMatcher);
  friendCombo=new JComboBox(new EventComboBoxModel<SharingTarget>(noShareFilterList));
  ShareComboBoxUI comboUI=new ShareComboBoxUI();
  friendCombo.setUI(comboUI);
  friendCombo.setEditor(new ShareComboBoxEditor());
  friendCombo.setEditable(true);
  comboPopup=comboUI.getPopup();
  MouseListener shareListener=new MouseAdapter(){
    private int pressedRow;
    @Override public void mousePressed(    MouseEvent e){
      pressedRow=comboPopup.getList().locationToIndex(e.getPoint());
    }
    @Override public void mouseReleased(    MouseEvent e){
      if (pressedRow == comboPopup.getList().locationToIndex(e.getPoint())) {
        shareSelectedFriend();
      }
    }
  }
;
  comboPopup.getList().addMouseListener(shareListener);
  inputField.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (noShareFilterList.size() == 0 || !friendCombo.isPopupVisible() && (""String_Node_Str"".equals(inputField.getText()) || inputField.getText() == null)) {
        dialog.setVisible(false);
      }
 else       if (friendCombo.getSelectedIndex() >= 0) {
        shareSelectedFriend();
        friendCombo.hidePopup();
      }
    }
  }
);
  inputField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      update();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      update();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      update();
    }
    private void update(){
      textMatcher.setFilterText(inputField.getText().split(""String_Node_Str""));
      if (noShareFilterList.size() > 0) {
        friendCombo.setSelectedIndex(0);
        if (isVisible()) {
          friendCombo.showPopup();
        }
      }
    }
  }
);
  shareScroll=new JScrollPane(shareTable);
  shareScroll.setBorder(new EmptyBorder(0,shareTableIndent,0,0));
  shareScroll.setOpaque(false);
  friendLabel=new JLabel(I18n.tr(""String_Node_Str""));
  shareFriendList.addListEventListener(new ListEventListener<SharingTarget>(){
    @Override public void listChanged(    ListEvent<SharingTarget> listChanges){
      adjustFriendLabelVisibility();
    }
  }
);
  Dimension labelSize=friendLabel.getPreferredSize().width > shareLabel.getPreferredSize().width ? friendLabel.getPreferredSize() : shareLabel.getPreferredSize();
  friendLabel.setPreferredSize(labelSize);
  shareLabel.setPreferredSize(labelSize);
  bottomLabel=new MultiLineLabel(""String_Node_Str"",WIDTH);
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.weightx=1.0;
  gbc.weighty=0;
  gbc.fill=GridBagConstraints.BOTH;
  gbc.insets=new Insets(0,HGAP,0,HGAP);
  gbc.gridy=0;
  gbc.weighty=0;
  mainPanel.add(shareLabel,gbc);
  gbc.gridy++;
  gbc.weighty=1.0;
  mainPanel.add(shareScroll,gbc);
  gbc.gridy++;
  mainPanel.add(friendLabel,gbc);
  gbc.gridy++;
  gbc.weighty=1.0;
  mainPanel.add(friendCombo,gbc);
  gbc.gridy++;
  mainPanel.add(bottomLabel,gbc);
  add(mainPanel);
  EventAnnotationProcessor.subscribe(this);
  setKeyStrokes(this);
  setKeyStrokes(mainPanel);
  setKeyStrokes(inputField);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      if (dialog.isVisible()) {
        dialog.pack();
      }
    }
    @Override public void componentShown(    ComponentEvent e){
      inputField.requestFocusInWindow();
    }
  }
);
  eventListener=new AWTEventListener(){
    @Override public void eventDispatched(    AWTEvent event){
      if (dialog.isVisible()) {
        if ((event.getID() == MouseEvent.MOUSE_PRESSED)) {
          MouseEvent e=(MouseEvent)event;
          if (LibrarySharePanel.this != e.getComponent() && !contains(e.getComponent())) {
            dialog.setVisible(false);
          }
        }
 else         if (event.getID() == KeyEvent.KEY_TYPED) {
          KeyEvent e=(KeyEvent)event;
          if (e.getKeyChar() == KeyEvent.VK_ESCAPE) {
            dialog.setVisible(false);
          }
        }
      }
    }
  }
;
}",0.9514425350780388
3976,"@Override protected void doPaint(Graphics2D g,X object,int width,int height){
  int singleArcHeight=this.arcHeight / 2;
  g.setClip(0,0,width - 2,7);
  g.setPaint(this.bevelTop2);
  g.drawRoundRect(1,2,width - 2,height - 5,this.arcWidth,this.arcHeight);
  g.setPaint(this.bevelTop1);
  g.drawRoundRect(1,1,width - 3,height - 4,this.arcWidth,this.arcHeight);
  g.setClip(0,singleArcHeight,width - 2,height);
  g.setPaint(this.bevelBottom);
  g.drawRoundRect(1,1,width - 4,height - 4,this.arcWidth,this.arcHeight);
  g.setClip(0,singleArcHeight - 1,width - 2,height);
  g.setPaint(PaintUtils.resizeGradient(this.bevelLeft,0,height - singleArcHeight + 1));
  g.drawLine(2,singleArcHeight - 1,2,height - singleArcHeight);
  g.setPaint(PaintUtils.resizeGradient(this.bevelRight,0,height - singleArcHeight + 1));
  g.drawLine(width - 3,singleArcHeight - 1,width - 3,height - singleArcHeight);
  if (this.hasBubble) {
    g.setPaint(BUBBLE_PAINT3);
    g.drawRoundRect(0,0,width - 1,height - 1,this.arcWidth,this.arcHeight);
    g.setPaint(BUBBLE_PAINT2);
    g.drawLine(0,singleArcHeight,0,height / 2);
    g.drawLine(width - 1,singleArcHeight,width - 1,height / 2);
    g.setPaint(BUBBLE_PAINT1);
    g.drawLine(0,height / 2,0,height - singleArcHeight);
    g.drawLine(width - 1,height / 2,width - 1,height - singleArcHeight);
  }
  g.setClip(0,0,width,height);
  g.setPaint(PaintUtils.resizeGradient(this.border,0,height));
  g.drawRoundRect(1,0,width - 3,height - 2,this.arcWidth,this.arcHeight);
}","@Override protected void doPaint(Graphics2D g,X object,int width,int height){
  int singleArcHeight=this.arcHeight / 2;
  g.setClip(0,0,width - 2,7);
  g.setPaint(this.bevelTop2);
  g.drawRoundRect(1,2,width - 2,height - 5,this.arcWidth,this.arcHeight);
  g.setPaint(this.bevelTop1);
  g.drawRoundRect(1,1,width - 3,height - 4,this.arcWidth,this.arcHeight);
  g.setClip(0,singleArcHeight,width - 2,height);
  g.setPaint(this.bevelBottom);
  g.drawRoundRect(1,1,width - 4,height - 4,this.arcWidth,this.arcHeight);
  g.setClip(0,singleArcHeight - 1,width - 2,height);
  g.setPaint(PaintUtils.resizeGradient(this.bevelLeft,0,height - singleArcHeight + 1));
  g.drawLine(2,singleArcHeight - 1,2,height - singleArcHeight);
  g.setPaint(PaintUtils.resizeGradient(this.bevelRight,0,height - singleArcHeight + 1));
  g.drawLine(width - 3,singleArcHeight - 1,width - 3,height - singleArcHeight);
  if (this.hasBubble) {
    g.setClip(0,singleArcHeight,width,height);
    g.setPaint(BUBBLE_PAINT3);
    g.drawRoundRect(0,0,width - 1,height - 1,this.arcWidth,this.arcHeight);
    g.setPaint(BUBBLE_PAINT2);
    g.drawLine(0,singleArcHeight,0,height / 2);
    g.drawLine(width - 1,singleArcHeight,width - 1,height / 2);
    g.setPaint(BUBBLE_PAINT1);
    g.drawLine(0,height / 2,0,height - singleArcHeight);
    g.drawLine(width - 1,height / 2,width - 1,height - singleArcHeight);
  }
  g.setClip(0,0,width,height);
  g.setPaint(PaintUtils.resizeGradient(this.border,0,height));
  g.drawRoundRect(1,0,width - 3,height - 2,this.arcWidth,this.arcHeight);
}",0.9845242015146526
3977,"@Inject public LibrarySharePanel(List<SharingTarget> allFriends){
  GuiUtils.assignResources(this);
  this.allFriends=allFriends;
  setLayout(new FlowLayout(FlowLayout.LEFT,0,0));
  setOpaque(false);
  setBorder(new LineBorder(Color.BLACK));
  mainPanel=new JXPanel(new GridBagLayout());
  mainPanel.setOpaque(false);
  inputField=new JTextField(12);
  inputField.setBorder(null);
  shareLabel=new JLabel(I18n.tr(""String_Node_Str""));
  shareFriendList=GlazedListsFactory.threadSafeList(GlazedListsFactory.sortedList(new BasicEventList<SharingTarget>(),new SharingTargetComparator()));
  shareTable=new ToolTipTable(new EventTableModel<SharingTarget>(shareFriendList,new LibraryShareTableFormat(1)));
  shareTable.setTableHeader(null);
  final ShareRendererEditor removeEditor=new ShareRendererEditor(removeIcon,removeIconRollover,removeIconPressed);
  removeEditor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      unshareFriend(removeEditor.getFriend());
      removeEditor.cancelCellEditing();
      inputField.requestFocusInWindow();
    }
  }
);
  shareTable.setHighlighters(new ColorHighlighter());
  shareTable.setRowHeight(removeEditor.getPreferredSize().height);
  shareTable.getColumnModel().getColumn(1).setCellEditor(removeEditor);
  shareTable.getColumnModel().getColumn(1).setPreferredWidth(removeEditor.getPreferredSize().width);
  shareTable.getColumnModel().getColumn(1).setMaxWidth(removeEditor.getPreferredSize().width);
  shareTable.getColumnModel().getColumn(1).setCellRenderer(new ShareRendererEditor(removeIcon,removeIconRollover,removeIconPressed));
  shareTable.setShowGrid(false);
  shareTable.setOpaque(false);
  shareTable.setColumnSelectionAllowed(false);
  shareTable.setRowSelectionAllowed(false);
  TextFilterator<SharingTarget> textFilter=new TextFilterator<SharingTarget>(){
    @Override public void getFilterStrings(    List<String> baseList,    SharingTarget element){
      baseList.add(element.getFriend().getName());
      baseList.add(element.getFriend().getId());
    }
  }
;
  noShareFriendList=GlazedLists.threadSafeList(GlazedListsFactory.sortedList(new BasicEventList<SharingTarget>(),new SharingTargetComparator()));
  final TextMatcherEditor<SharingTarget> textMatcher=new TextMatcherEditor<SharingTarget>(textFilter);
  noShareFilterList=GlazedListsFactory.filterList(noShareFriendList,textMatcher);
  friendCombo=new JComboBox(new EventComboBoxModel<SharingTarget>(noShareFilterList));
  ShareComboBoxUI comboUI=new ShareComboBoxUI();
  friendCombo.setUI(comboUI);
  friendCombo.setEditor(new ShareComboBoxEditor());
  friendCombo.setEditable(true);
  comboPopup=comboUI.getPopup();
  friendCombo.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0) {
        shareSelectedFriend();
      }
    }
  }
);
  inputField.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (noShareFilterList.size() == 0 || !friendCombo.isPopupVisible() && (""String_Node_Str"".equals(inputField.getText()) || inputField.getText() == null)) {
        dialog.setVisible(false);
      }
 else       if (friendCombo.getSelectedIndex() >= 0) {
        shareSelectedFriend();
        friendCombo.hidePopup();
      }
    }
  }
);
  inputField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      update();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      update();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      update();
    }
    private void update(){
      textMatcher.setFilterText(inputField.getText().split(""String_Node_Str""));
      if (noShareFilterList.size() > 0) {
        friendCombo.setSelectedIndex(0);
        if (isVisible()) {
          friendCombo.showPopup();
        }
      }
    }
  }
);
  shareScroll=new JScrollPane(shareTable);
  shareScroll.setBorder(new EmptyBorder(0,shareTableIndent,0,0));
  shareScroll.setOpaque(false);
  friendLabel=new JLabel(I18n.tr(""String_Node_Str""));
  shareFriendList.addListEventListener(new ListEventListener<SharingTarget>(){
    @Override public void listChanged(    ListEvent<SharingTarget> listChanges){
      adjustFriendLabelVisibility();
    }
  }
);
  Dimension labelSize=friendLabel.getPreferredSize().width > shareLabel.getPreferredSize().width ? friendLabel.getPreferredSize() : shareLabel.getPreferredSize();
  friendLabel.setPreferredSize(labelSize);
  shareLabel.setPreferredSize(labelSize);
  bottomLabel=new MultiLineLabel(""String_Node_Str"",WIDTH);
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.weightx=1.0;
  gbc.weighty=0;
  gbc.fill=GridBagConstraints.BOTH;
  gbc.insets=new Insets(0,HGAP,0,HGAP);
  gbc.gridy=0;
  gbc.weighty=0;
  mainPanel.add(shareLabel,gbc);
  gbc.gridy++;
  gbc.weighty=1.0;
  mainPanel.add(shareScroll,gbc);
  gbc.gridy++;
  mainPanel.add(friendLabel,gbc);
  gbc.gridy++;
  gbc.weighty=1.0;
  mainPanel.add(friendCombo,gbc);
  gbc.gridy++;
  mainPanel.add(bottomLabel,gbc);
  add(mainPanel);
  EventAnnotationProcessor.subscribe(this);
  setKeyStrokes(this);
  setKeyStrokes(mainPanel);
  setKeyStrokes(inputField);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      if (dialog.isVisible()) {
        dialog.pack();
      }
    }
    @Override public void componentShown(    ComponentEvent e){
      inputField.requestFocusInWindow();
    }
  }
);
  eventListener=new AWTEventListener(){
    @Override public void eventDispatched(    AWTEvent event){
      if (dialog.isVisible()) {
        if ((event.getID() == MouseEvent.MOUSE_PRESSED)) {
          MouseEvent e=(MouseEvent)event;
          if (LibrarySharePanel.this != e.getComponent() && !contains(e.getComponent())) {
            dialog.setVisible(false);
          }
        }
 else         if (event.getID() == KeyEvent.KEY_TYPED) {
          KeyEvent e=(KeyEvent)event;
          if (e.getKeyChar() == KeyEvent.VK_ESCAPE) {
            dialog.setVisible(false);
          }
        }
      }
    }
  }
;
}","@Inject public LibrarySharePanel(List<SharingTarget> allFriends){
  GuiUtils.assignResources(this);
  this.allFriends=allFriends;
  setLayout(new FlowLayout(FlowLayout.LEFT,0,0));
  setOpaque(false);
  setBorder(new LineBorder(Color.BLACK));
  mainPanel=new JXPanel(new GridBagLayout());
  mainPanel.setOpaque(false);
  inputField=new JTextField(12);
  inputField.setBorder(null);
  shareLabel=new JLabel(I18n.tr(""String_Node_Str""));
  shareFriendList=GlazedListsFactory.threadSafeList(GlazedListsFactory.sortedList(new BasicEventList<SharingTarget>(),new SharingTargetComparator()));
  shareTable=new ToolTipTable(new EventTableModel<SharingTarget>(shareFriendList,new LibraryShareTableFormat(1)));
  shareTable.setTableHeader(null);
  final ShareRendererEditor removeEditor=new ShareRendererEditor(removeIcon,removeIconRollover,removeIconPressed);
  removeEditor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      unshareFriend(removeEditor.getFriend());
      removeEditor.cancelCellEditing();
      inputField.requestFocusInWindow();
    }
  }
);
  shareTable.setHighlighters(new ColorHighlighter());
  shareTable.setRowHeight(removeEditor.getPreferredSize().height);
  shareTable.getColumnModel().getColumn(1).setCellEditor(removeEditor);
  shareTable.getColumnModel().getColumn(1).setPreferredWidth(removeEditor.getPreferredSize().width);
  shareTable.getColumnModel().getColumn(1).setMaxWidth(removeEditor.getPreferredSize().width);
  shareTable.getColumnModel().getColumn(1).setCellRenderer(new ShareRendererEditor(removeIcon,removeIconRollover,removeIconPressed));
  shareTable.setShowGrid(false);
  shareTable.setOpaque(false);
  shareTable.setColumnSelectionAllowed(false);
  shareTable.setRowSelectionAllowed(false);
  TextFilterator<SharingTarget> textFilter=new TextFilterator<SharingTarget>(){
    @Override public void getFilterStrings(    List<String> baseList,    SharingTarget element){
      baseList.add(element.getFriend().getName());
      baseList.add(element.getFriend().getId());
    }
  }
;
  noShareFriendList=GlazedLists.threadSafeList(GlazedListsFactory.sortedList(new BasicEventList<SharingTarget>(),new SharingTargetComparator()));
  final TextMatcherEditor<SharingTarget> textMatcher=new TextMatcherEditor<SharingTarget>(textFilter);
  noShareFilterList=GlazedListsFactory.filterList(noShareFriendList,textMatcher);
  friendCombo=new JComboBox(new EventComboBoxModel<SharingTarget>(noShareFilterList));
  ShareComboBoxUI comboUI=new ShareComboBoxUI();
  friendCombo.setUI(comboUI);
  friendCombo.setEditor(new ShareComboBoxEditor());
  friendCombo.setEditable(true);
  comboPopup=comboUI.getPopup();
  friendCombo.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (friendCombo.isPopupVisible() && (e.getModifiers() & InputEvent.BUTTON1_MASK) != 0) {
        shareSelectedFriend();
      }
    }
  }
);
  inputField.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (noShareFilterList.size() == 0 || !friendCombo.isPopupVisible() && (""String_Node_Str"".equals(inputField.getText()) || inputField.getText() == null)) {
        dialog.setVisible(false);
      }
 else       if (friendCombo.getSelectedIndex() >= 0) {
        shareSelectedFriend();
        friendCombo.hidePopup();
      }
    }
  }
);
  inputField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void changedUpdate(    DocumentEvent e){
      update();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      update();
    }
    @Override public void removeUpdate(    DocumentEvent e){
      update();
    }
    private void update(){
      textMatcher.setFilterText(inputField.getText().split(""String_Node_Str""));
      if (noShareFilterList.size() > 0) {
        friendCombo.setSelectedIndex(0);
        if (isVisible()) {
          friendCombo.showPopup();
        }
      }
    }
  }
);
  shareScroll=new JScrollPane(shareTable);
  shareScroll.setBorder(new EmptyBorder(0,shareTableIndent,0,0));
  shareScroll.setOpaque(false);
  friendLabel=new JLabel(I18n.tr(""String_Node_Str""));
  shareFriendList.addListEventListener(new ListEventListener<SharingTarget>(){
    @Override public void listChanged(    ListEvent<SharingTarget> listChanges){
      adjustFriendLabelVisibility();
    }
  }
);
  Dimension labelSize=friendLabel.getPreferredSize().width > shareLabel.getPreferredSize().width ? friendLabel.getPreferredSize() : shareLabel.getPreferredSize();
  friendLabel.setPreferredSize(labelSize);
  shareLabel.setPreferredSize(labelSize);
  bottomLabel=new MultiLineLabel(""String_Node_Str"",WIDTH);
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.weightx=1.0;
  gbc.weighty=0;
  gbc.fill=GridBagConstraints.BOTH;
  gbc.insets=new Insets(0,HGAP,0,HGAP);
  gbc.gridy=0;
  gbc.weighty=0;
  mainPanel.add(shareLabel,gbc);
  gbc.gridy++;
  gbc.weighty=1.0;
  mainPanel.add(shareScroll,gbc);
  gbc.gridy++;
  mainPanel.add(friendLabel,gbc);
  gbc.gridy++;
  gbc.weighty=1.0;
  mainPanel.add(friendCombo,gbc);
  gbc.gridy++;
  mainPanel.add(bottomLabel,gbc);
  add(mainPanel);
  EventAnnotationProcessor.subscribe(this);
  setKeyStrokes(this);
  setKeyStrokes(mainPanel);
  setKeyStrokes(inputField);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      if (dialog.isVisible()) {
        dialog.pack();
      }
    }
    @Override public void componentShown(    ComponentEvent e){
      inputField.requestFocusInWindow();
    }
  }
);
  eventListener=new AWTEventListener(){
    @Override public void eventDispatched(    AWTEvent event){
      if (dialog.isVisible()) {
        if ((event.getID() == MouseEvent.MOUSE_PRESSED)) {
          MouseEvent e=(MouseEvent)event;
          if (LibrarySharePanel.this != e.getComponent() && !contains(e.getComponent())) {
            dialog.setVisible(false);
          }
        }
 else         if (event.getID() == KeyEvent.KEY_TYPED) {
          KeyEvent e=(KeyEvent)event;
          if (e.getKeyChar() == KeyEvent.VK_ESCAPE) {
            dialog.setVisible(false);
          }
        }
      }
    }
  }
;
}",0.9974321938693628
3978,"private Component makeLeftPanel(final Navigator navigator){
  itemIconLabel=new JLabel();
  itemIconLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
  itemIconLabel.setOpaque(false);
  heading.setContentType(""String_Node_Str"");
  heading.setEditable(false);
  heading.setMaximumSize(new Dimension(Integer.MAX_VALUE,25));
  heading.setOpaque(false);
  heading.addMouseListener(new MouseAdapter(){
    @Override public void mouseEntered(    MouseEvent e){
      populateHeading(rowHeightRule.getDisplayResult(vsr,searchText),vsr.getDownloadState(),true);
    }
    @Override public void mouseExited(    MouseEvent e){
      populateHeading(rowHeightRule.getDisplayResult(vsr,searchText),vsr.getDownloadState(),false);
    }
  }
);
  subheadingLabel.setForeground(subHeadingLabelColor);
  subheadingLabel.setFont(subHeadingFont);
  metadataLabel.setForeground(metadataLabelColor);
  metadataLabel.setFont(metadataFont);
  downloadSourceCount.setForeground(downloadSourceCountColor);
  downloadSourceCount.setFont(downloadSourceCountFont);
  JXPanel itemIconPanel=new JXPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  itemIconPanel.setOpaque(false);
  itemIconPanel.add(itemIconLabel);
  searchResultTextPanel=new JXPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  searchResultTextPanel.setOpaque(false);
  searchResultTextPanel.add(heading,""String_Node_Str"");
  searchResultTextPanel.add(subheadingLabel,""String_Node_Str"");
  searchResultTextPanel.add(metadataLabel,""String_Node_Str"");
  JXPanel panel=new JXPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  panel.setOpaque(false);
  panel.add(itemIconPanel);
  panel.add(searchResultTextPanel,""String_Node_Str"");
  panel.add(downloadSourceCount);
  heading.addHyperlinkListener(new HyperlinkListener(){
    @Override public void hyperlinkUpdate(    HyperlinkEvent e){
      if (EventType.ACTIVATED == e.getEventType()) {
        if (e.getDescription().equals(""String_Node_Str"")) {
          actionButtonPanel.startDownload();
          table.editingStopped(new ChangeEvent(table));
        }
 else         if (e.getDescription().equals(""String_Node_Str"")) {
          navigator.getNavItem(NavCategory.DOWNLOAD,MainDownloadPanel.NAME).select(vsr);
        }
 else         if (e.getDescription().equals(""String_Node_Str"")) {
          navigator.getNavItem(NavCategory.LIBRARY,LibraryNavigator.NAME_PREFIX + vsr.getCategory()).select(vsr);
        }
      }
    }
  }
);
  return panel;
}","private Component makeLeftPanel(final Navigator navigator){
  itemIconLabel=new JLabel();
  itemIconLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
  itemIconLabel.setOpaque(false);
  heading.setContentType(""String_Node_Str"");
  heading.setEditable(false);
  heading.setMaximumSize(new Dimension(Integer.MAX_VALUE,25));
  heading.setOpaque(false);
  heading.addMouseListener(new MouseAdapter(){
    @Override public void mouseEntered(    MouseEvent e){
      populateHeading(rowHeightRule.getDisplayResult(vsr,searchText),vsr.getDownloadState(),true);
    }
    @Override public void mouseExited(    MouseEvent e){
      populateHeading(rowHeightRule.getDisplayResult(vsr,searchText),vsr.getDownloadState(),false);
    }
  }
);
  subheadingLabel.setForeground(subHeadingLabelColor);
  subheadingLabel.setFont(subHeadingFont);
  metadataLabel.setForeground(metadataLabelColor);
  metadataLabel.setFont(metadataFont);
  downloadSourceCount.setForeground(downloadSourceCountColor);
  downloadSourceCount.setFont(downloadSourceCountFont);
  JXPanel itemIconPanel=new JXPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  itemIconPanel.setOpaque(false);
  itemIconPanel.add(itemIconLabel);
  searchResultTextPanel=new JXPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  searchResultTextPanel.setOpaque(false);
  searchResultTextPanel.add(heading,""String_Node_Str"");
  searchResultTextPanel.add(subheadingLabel,""String_Node_Str"");
  searchResultTextPanel.add(metadataLabel,""String_Node_Str"");
  JXPanel panel=new JXPanel(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  panel.setOpaque(false);
  panel.add(itemIconPanel);
  panel.add(searchResultTextPanel,""String_Node_Str"");
  panel.add(downloadSourceCount,""String_Node_Str"");
  heading.addHyperlinkListener(new HyperlinkListener(){
    @Override public void hyperlinkUpdate(    HyperlinkEvent e){
      if (EventType.ACTIVATED == e.getEventType()) {
        if (e.getDescription().equals(""String_Node_Str"")) {
          actionButtonPanel.startDownload();
          table.editingStopped(new ChangeEvent(table));
        }
 else         if (e.getDescription().equals(""String_Node_Str"")) {
          navigator.getNavItem(NavCategory.DOWNLOAD,MainDownloadPanel.NAME).select(vsr);
        }
 else         if (e.getDescription().equals(""String_Node_Str"")) {
          navigator.getNavItem(NavCategory.LIBRARY,LibraryNavigator.NAME_PREFIX + vsr.getCategory()).select(vsr);
        }
      }
    }
  }
);
  return panel;
}",0.9964678178963892
3979,"private Action getAddFile(final LibraryManager libraryManager){
  return new AbstractAction(I18n.tr(""String_Node_Str"")){
    @Override public void actionPerformed(    ActionEvent e){
      List<File> files=FileChooser.getInput(FileMenu.this,I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),FileChooser.getLastInputDirectory(),JFileChooser.FILES_ONLY,JFileChooser.APPROVE_OPTION,true,new FileFilter(){
        @Override public boolean accept(        File f){
          return f.isDirectory() || LibraryUtils.isFilePhysicallyManagable(f);
        }
        @Override public String getDescription(){
          return I18n.tr(""String_Node_Str"");
        }
      }
);
      if (files != null) {
        for (        File file : files) {
          libraryManager.getLibraryManagedList().addFile(file);
        }
      }
    }
  }
;
}","private Action getAddFile(final LibraryManager libraryManager){
  return new AbstractAction(I18n.tr(""String_Node_Str"")){
    @Override public void actionPerformed(    ActionEvent e){
      List<File> files=FileChooser.getInput(FileMenu.this,I18n.tr(""String_Node_Str""),I18n.tr(""String_Node_Str""),FileChooser.getLastInputDirectory(),JFileChooser.FILES_ONLY,JFileChooser.APPROVE_OPTION,true,new FileFilter(){
        @Override public boolean accept(        File f){
          return f.isDirectory() || libraryManager.getLibraryData().isFileManageable(f);
        }
        @Override public String getDescription(){
          return I18n.tr(""String_Node_Str"");
        }
      }
);
      if (files != null) {
        for (        File file : files) {
          libraryManager.getLibraryManagedList().addFile(file);
        }
      }
    }
  }
;
}",0.9605734767025088
3980,"@Override public void mouseExited(MouseEvent e){
  getTopLevelAncestor().setCursor(getCursor());
  this.hide=false;
}","@Override public void mouseExited(MouseEvent e){
  setCursor(Cursor.getDefaultCursor());
  this.hide=false;
}",0.8407079646017699
3981,"@Override public void mouseEntered(MouseEvent e){
  getTopLevelAncestor().setCursor(mouseOverCursor);
  if (menu == null)   return;
  if (menu.isVisible())   this.hide=true;
}","@Override public void mouseEntered(MouseEvent e){
  setCursor(mouseOverCursor);
  if (menu == null)   return;
  if (menu.isVisible())   this.hide=true;
}",0.9329268292682928
3982,"private void initModel(){
  this.setModel(this.getModel());
  this.addMouseListener(new MouseAdapter(){
    private boolean hide=false;
    @Override public void mouseEntered(    MouseEvent e){
      getTopLevelAncestor().setCursor(mouseOverCursor);
      if (menu == null)       return;
      if (menu.isVisible())       this.hide=true;
    }
    @Override public void mouseExited(    MouseEvent e){
      getTopLevelAncestor().setCursor(getCursor());
      this.hide=false;
    }
    @Override public void mousePressed(    MouseEvent e){
      if (menu == null)       return;
      if (this.hide) {
        this.hide=false;
        return;
      }
      updateMenu();
      if (getText() == null)       menu.setPreferredSize(new Dimension(getWidth(),(int)menu.getPreferredSize().getHeight()));
      menu.show((Component)e.getSource(),0,getHeight() - 1);
      this.hide=true;
    }
  }
);
}","private void initModel(){
  this.setModel(this.getModel());
  this.addMouseListener(new MouseAdapter(){
    private boolean hide=false;
    @Override public void mouseEntered(    MouseEvent e){
      setCursor(mouseOverCursor);
      if (menu == null)       return;
      if (menu.isVisible())       this.hide=true;
    }
    @Override public void mouseExited(    MouseEvent e){
      setCursor(Cursor.getDefaultCursor());
      this.hide=false;
    }
    @Override public void mousePressed(    MouseEvent e){
      if (menu == null)       return;
      if (this.hide) {
        this.hide=false;
        return;
      }
      updateMenu();
      if (getText() == null)       menu.setPreferredSize(new Dimension(getWidth(),(int)menu.getPreferredSize().getHeight()));
      menu.show((Component)e.getSource(),0,getHeight() - 1);
      this.hide=true;
    }
  }
);
}",0.9646924829157176
3983,"/** 
 * Sets the painter to be used when the tab is selected. 
 */
public void setSelectionPainter(Painter<?> selectedPainter){
  for (  FancyTab tab : tabs) {
    if (tab.isHighlighted()) {
      tab.setBackgroundPainter(selectedPainter);
    }
  }
  props.setSelectedPainter(selectedPainter);
}","/** 
 * Sets the painter to be used when the tab is selected. 
 */
public void setSelectionPainter(Painter<?> selectedPainter){
  for (  FancyTab tab : tabs) {
    if (tab.isSelected()) {
      tab.setBackgroundPainter(selectedPainter);
    }
  }
  props.setSelectedPainter(selectedPainter);
}",0.9779286926994908
3984,"@Override protected void startup(){
  GuiUtils.assignResources(this);
  initColors();
  String title=getContext().getResourceMap().getString(""String_Node_Str"");
  JFrame frame=new LimeJFrame(title);
  frame.setName(""String_Node_Str"");
  getMainView().setFrame(frame);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  Injector localInjector=createInjector();
  LimeWireSwingUI ui=localInjector.getInstance(LimeWireSwingUI.class);
  ui.showTrayIcon();
  getMainFrame().setJMenuBar(ui.getMenuBar());
  addExitListener(new TrayExitListener(ui.getTrayNotifier()));
  addExitListener(new ShutdownListener(getMainFrame(),localInjector.getInstance(Application.class)));
  show(ui.getLayer());
  restoreView();
  ui.goHome();
  ui.focusOnSearch();
  getMainFrame().setSize(new Dimension(1024,768));
  started=true;
  ui.showSetupWizard();
  for (  ApplicationLifecycleListener listener : lifecycleListeners) {
    listener.startupComplete();
  }
}","@Override protected void startup(){
  GuiUtils.assignResources(this);
  initColors();
  String title=getContext().getResourceMap().getString(""String_Node_Str"");
  JFrame frame=new LimeJFrame(title);
  frame.setName(""String_Node_Str"");
  getMainView().setFrame(frame);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  Injector localInjector=createInjector();
  LimeWireSwingUI ui=localInjector.getInstance(LimeWireSwingUI.class);
  ui.showTrayIcon();
  getMainFrame().setJMenuBar(ui.getMenuBar());
  addExitListener(new TrayExitListener(ui.getTrayNotifier()));
  addExitListener(new ShutdownListener(getMainFrame(),localInjector.getInstance(Application.class)));
  show(ui);
  restoreView();
  ui.goHome();
  ui.focusOnSearch();
  getMainFrame().setSize(new Dimension(1024,768));
  started=true;
  for (  ApplicationLifecycleListener listener : lifecycleListeners) {
    listener.startupComplete();
  }
}",0.9824561403508772
3985,"public SimpleFuture(T t){
  this.t=t;
}","public SimpleFuture(Throwable throwable){
  this.t=null;
  this.exception=throwable;
}",0.624
3986,"/** 
 * Returns all of the files URNs, from youngest to oldest.
 */
public List<URN> getFiles(){
  return getFiles(Integer.MAX_VALUE);
}","/** 
 * Returns all of the files URNs, from youngest to oldest.
 */
public Collection<URN> getFiles(){
  return getFiles(Integer.MAX_VALUE);
}",0.9568345323741008
3987,"/** 
 * Responds to a what is new request.
 */
private Set<Response> queryWhatsNew(QueryRequest request){
  boolean includeXML=request.shouldIncludeXMLInResponse();
  List<URN> urnList=creationTimeCache.get().getFiles(request,3);
  if (urnList.size() == 0)   return Collections.emptySet();
  Set<Response> resps=new HashSet<Response>(urnList.size());
  for (int i=0; i < urnList.size(); i++) {
    URN currURN=urnList.get(i);
    FileDesc desc=fileManager.getGnutellaSharedFileList().getFileDesc(currURN);
    if ((desc == null) || (desc instanceof IncompleteFileDesc))     throw new RuntimeException(""String_Node_Str"");
    Response r=responseFactory.get().createResponse(desc);
    if (includeXML)     addXMLToResponse(r,desc);
    resps.add(r);
  }
  return resps;
}","/** 
 * Responds to a what is new request.
 */
private Set<Response> queryWhatsNew(QueryRequest request){
  boolean includeXML=request.shouldIncludeXMLInResponse();
  Collection<URN> urnList=creationTimeCache.get().getFiles(request,3);
  if (urnList.size() == 0)   return Collections.emptySet();
  Set<Response> resps=new HashSet<Response>(urnList.size());
  for (  URN urn : urnList) {
    FileDesc desc=fileManager.getGnutellaSharedFileList().getFileDesc(urn);
    if ((desc == null) || (desc instanceof IncompleteFileDesc))     throw new RuntimeException(""String_Node_Str"");
    Response r=responseFactory.get().createResponse(desc);
    if (includeXML)     addXMLToResponse(r,desc);
    resps.add(r);
  }
  return resps;
}",0.928428093645485
3988,"@Override public void initialize(){
  fileManager.getManagedFileList().addManagedListStatusListener(new EventListener<ManagedListStatusEvent>(){
    @Override public void handleEvent(    ManagedListStatusEvent event){
      handleManagedListStatusEvent(event);
    }
  }
);
  fileManager.getGnutellaSharedFileList().addFileListListener(new EventListener<FileListChangedEvent>(){
    @Override public void handleEvent(    FileListChangedEvent event){
      handleFileListEvent(event);
    }
  }
);
}","void initialize(){
  fileManager.getManagedFileList().addManagedListStatusListener(new EventListener<ManagedListStatusEvent>(){
    @Override public void handleEvent(    ManagedListStatusEvent event){
      handleManagedListStatusEvent(event);
    }
  }
);
  fileManager.getGnutellaSharedFileList().addFileListListener(new EventListener<FileListChangedEvent>(){
    @Override public void handleEvent(    FileListChangedEvent event){
      handleFileListEvent(event);
    }
  }
);
}",0.390194075587334
3989,"@Inject void register(ServiceRegistry registry){
  registry.register(new Service(){
    @Override public String getServiceName(){
      return ""String_Node_Str"";
    }
    @Override public void initialize(){
      fileManager.getManagedFileList().addManagedListStatusListener(new EventListener<ManagedListStatusEvent>(){
        @Override public void handleEvent(        ManagedListStatusEvent event){
          handleManagedListStatusEvent(event);
        }
      }
);
      fileManager.getGnutellaSharedFileList().addFileListListener(new EventListener<FileListChangedEvent>(){
        @Override public void handleEvent(        FileListChangedEvent event){
          handleFileListEvent(event);
        }
      }
);
    }
    @Override public void start(){
    }
    @Override public void stop(){
    }
  }
);
}","@Inject void register(ServiceRegistry registry){
  registry.register(new Service(){
    @Override public String getServiceName(){
      return ""String_Node_Str"";
    }
    @Override public void initialize(){
      CreationTimeCache.this.initialize();
    }
    @Override public void start(){
    }
    @Override public void stop(){
    }
  }
);
}",0.4231433506044905
3990,"/** 
 * Tests the getFiles().iterator() method.
 */
public void testSettersAndGetters() throws Exception {
  MyFileManager fileManager=(MyFileManager)injector.getInstance(FileManager.class);
  Iterator iter=null;
  Map TIME_MAP=null;
  Long old=new Long(1);
  Long middle=new Long(2);
  Long young=new Long(3);
  deleteCacheFile();
  CreationTimeCache ctCache=new CreationTimeCache(fileManager);
  assertFalse(ctCache.getFiles().iterator().hasNext());
  TIME_MAP=getUrnToTime(ctCache);
  assertEquals(0,TIME_MAP.size());
  ctCache.addTime(hash1,middle.longValue());
  ctCache.commitTime(hash1);
  ctCache.persistCache();
  iter=ctCache.getFiles().iterator();
  assertEquals(hash1,iter.next());
  assertFalse(iter.hasNext());
  ctCache=null;
  ctCache=new CreationTimeCache(fileManager);
  iter=ctCache.getFiles().iterator();
  assertEquals(hash1,iter.next());
  assertFalse(iter.hasNext());
  TIME_MAP=getUrnToTime(ctCache);
  assertEquals(1,TIME_MAP.size());
  ctCache.addTime(hash2,old.longValue());
  ctCache.commitTime(hash2);
  ctCache.addTime(hash3,young.longValue());
  ctCache.commitTime(hash3);
  ctCache.addTime(hash4,middle.longValue());
  ctCache.commitTime(hash4);
  ctCache.removeTime(hash1);
  ctCache.persistCache();
  iter=ctCache.getFiles().iterator();
  assertEquals(hash3,iter.next());
  iter.next();
  assertEquals(hash2,iter.next());
  assertFalse(iter.hasNext());
  ctCache=null;
  ctCache=new CreationTimeCache(fileManager);
  iter=ctCache.getFiles().iterator();
  assertEquals(hash3,iter.next());
  assertEquals(hash4,iter.next());
  assertEquals(hash2,iter.next());
  assertFalse(iter.hasNext());
  TIME_MAP=getUrnToTime(ctCache);
  assertEquals(3,TIME_MAP.size());
  ctCache.removeTime(hash3);
  ctCache.persistCache();
  fileManager.setExcludeURN(hash4);
  ctCache=new CreationTimeCache(fileManager);
  iter=ctCache.getFiles().iterator();
  assertEquals(hash2,iter.next());
  assertFalse(iter.hasNext());
  TIME_MAP=getUrnToTime(ctCache);
  assertEquals(1,TIME_MAP.size());
  ctCache=null;
  fileManager.clearExcludeURN();
}","/** 
 * Tests the getFiles().iterator() method.
 */
public void testSettersAndGetters() throws Exception {
  Iterator iter=null;
  Map TIME_MAP=null;
  Long old=new Long(1);
  Long middle=new Long(2);
  Long young=new Long(3);
  deleteCacheFile();
  CreationTimeCache ctCache=new CreationTimeCache(fileManager);
  assertFalse(ctCache.getFiles().iterator().hasNext());
  TIME_MAP=getUrnToTime(ctCache);
  assertEquals(0,TIME_MAP.size());
  ctCache.addTime(hash1,middle.longValue());
  ctCache.commitTime(hash1);
  ctCache.persistCache();
  iter=ctCache.getFiles().iterator();
  assertEquals(hash1,iter.next());
  assertFalse(iter.hasNext());
  ctCache=null;
  ctCache=new CreationTimeCache(fileManager);
  iter=ctCache.getFiles().iterator();
  assertEquals(hash1,iter.next());
  assertFalse(iter.hasNext());
  TIME_MAP=getUrnToTime(ctCache);
  assertEquals(1,TIME_MAP.size());
  ctCache.addTime(hash2,old.longValue());
  ctCache.commitTime(hash2);
  ctCache.addTime(hash3,young.longValue());
  ctCache.commitTime(hash3);
  ctCache.addTime(hash4,middle.longValue());
  ctCache.commitTime(hash4);
  ctCache.removeTime(hash1);
  ctCache.persistCache();
  iter=ctCache.getFiles().iterator();
  assertEquals(hash3,iter.next());
  iter.next();
  assertEquals(hash2,iter.next());
  assertFalse(iter.hasNext());
  ctCache=null;
  ctCache=new CreationTimeCache(fileManager);
  iter=ctCache.getFiles().iterator();
  assertEquals(hash3,iter.next());
  assertEquals(hash4,iter.next());
  assertEquals(hash2,iter.next());
  assertFalse(iter.hasNext());
  TIME_MAP=getUrnToTime(ctCache);
  assertEquals(3,TIME_MAP.size());
  ctCache.removeTime(hash3);
  ctCache.persistCache();
  fileManager.getGnutellaSharedFileList().remove(fd4);
  ctCache=new CreationTimeCache(fileManager);
  iter=ctCache.getFiles().iterator();
  assertEquals(hash2,iter.next());
  assertFalse(iter.hasNext());
  TIME_MAP=getUrnToTime(ctCache);
  assertEquals(1,TIME_MAP.size());
}",0.9528822055137844
3991,"@Override protected void configure(){
  bind(FileManager.class).to(MyFileManager.class);
}","@Override protected void configure(){
  bind(FileManager.class).to(FileManagerStub.class);
}",0.967032967032967
3992,"/** 
 * Tests the getFiles().iterator() method.
 */
public void testGetFiles() throws Exception {
  Map<URN,Long> toSerialize=new HashMap<URN,Long>();
  Long old=new Long(1);
  Long middle=new Long(2);
  Long young=new Long(3);
  toSerialize.put(hash1,middle);
  toSerialize.put(hash2,young);
  toSerialize.put(hash3,old);
  toSerialize.put(hash4,middle);
  ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(new File(_settingsDir,CREATION_CACHE_FILE)));
  oos.writeObject(toSerialize);
  oos.close();
  CreationTimeCache ctCache=new CreationTimeCache(fileManager);
  assertEquals(ctCache.getCreationTime(hash1),middle);
  assertEquals(ctCache.getCreationTime(hash2),young);
  assertEquals(ctCache.getCreationTime(hash3),old);
  assertEquals(ctCache.getCreationTime(hash4),middle);
{
    Iterator iter=ctCache.getFiles().iterator();
    assertEquals(hash2,iter.next());
    URN urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    assertEquals(hash3,iter.next());
    assertFalse(iter.hasNext());
  }
{
    Iterator iter=ctCache.getFiles(4).iterator();
    assertEquals(hash2,iter.next());
    URN urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    assertEquals(hash3,iter.next());
    assertFalse(iter.hasNext());
  }
{
    Iterator iter=ctCache.getFiles(3).iterator();
    assertEquals(hash2,iter.next());
    URN urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    assertFalse(iter.hasNext());
  }
{
    Iterator iter=ctCache.getFiles(2).iterator();
    assertEquals(hash2,iter.next());
    URN urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    assertFalse(iter.hasNext());
  }
{
    Iterator iter=ctCache.getFiles(1).iterator();
    assertEquals(hash2,iter.next());
    assertFalse(iter.hasNext());
  }
{
    try {
      ctCache.getFiles(0).iterator();
      fail(""String_Node_Str"");
    }
 catch (    IllegalArgumentException expected) {
    }
  }
}","/** 
 * Tests the getFiles().iterator() method.
 */
public void testGetFiles() throws Exception {
  Map<URN,Long> toSerialize=new HashMap<URN,Long>();
  Long old=new Long(1);
  Long middle=new Long(2);
  Long young=new Long(3);
  toSerialize.put(hash1,middle);
  toSerialize.put(hash2,young);
  toSerialize.put(hash3,old);
  toSerialize.put(hash4,middle);
  ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(new File(_settingsDir,CREATION_CACHE_FILE)));
  oos.writeObject(toSerialize);
  oos.close();
  CreationTimeCache ctCache=new CreationTimeCache(fileManager);
  assertEquals(ctCache.getCreationTime(hash1),middle);
  assertEquals(ctCache.getCreationTime(hash2),young);
  assertEquals(ctCache.getCreationTime(hash3),old);
  assertEquals(ctCache.getCreationTime(hash4),middle);
{
    Iterator iter=ctCache.getFiles().iterator();
    assertEquals(hash2,iter.next());
    URN urn=(URN)iter.next();
    assertTrue(""String_Node_Str"" + urn,urn.equals(hash1) || urn.equals(hash4));
    urn=(URN)iter.next();
    assertTrue(""String_Node_Str"" + urn,urn.equals(hash1) || urn.equals(hash4));
    assertEquals(hash3,iter.next());
    assertFalse(iter.hasNext());
  }
{
    Iterator iter=ctCache.getFiles(4).iterator();
    assertEquals(hash2,iter.next());
    URN urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    assertEquals(hash3,iter.next());
    assertFalse(iter.hasNext());
  }
{
    Iterator iter=ctCache.getFiles(3).iterator();
    assertEquals(hash2,iter.next());
    URN urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    assertFalse(iter.hasNext());
  }
{
    Iterator iter=ctCache.getFiles(2).iterator();
    assertEquals(hash2,iter.next());
    URN urn=(URN)iter.next();
    assertTrue(urn.equals(hash1) || urn.equals(hash4));
    assertFalse(iter.hasNext());
  }
{
    Iterator iter=ctCache.getFiles(1).iterator();
    assertEquals(hash2,iter.next());
    assertFalse(iter.hasNext());
  }
{
    try {
      ctCache.getFiles(0).iterator();
      fail(""String_Node_Str"");
    }
 catch (    IllegalArgumentException expected) {
    }
  }
}",0.9893899204244032
3993,"@Override public void setUp() throws Exception {
  hash1=URN.createSHA1Urn(""String_Node_Str"");
  hash2=URN.createSHA1Urn(""String_Node_Str"");
  hash3=URN.createSHA1Urn(""String_Node_Str"");
  hash4=URN.createSHA1Urn(""String_Node_Str"");
  injector=LimeTestUtils.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(FileManager.class).to(MyFileManager.class);
    }
  }
);
  fileManager=(MyFileManager)injector.getInstance(FileManager.class);
  fileManager.setDefaultUrn(hash1);
  fileManager.setValidUrns(new HashSet<URN>(Arrays.asList(hash1,hash2,hash3,hash4)));
}","@Override public void setUp() throws Exception {
  hash1=URN.createSHA1Urn(""String_Node_Str"");
  hash2=URN.createSHA1Urn(""String_Node_Str"");
  hash3=URN.createSHA1Urn(""String_Node_Str"");
  hash4=URN.createSHA1Urn(""String_Node_Str"");
  injector=LimeTestUtils.createInjector(new AbstractModule(){
    @Override protected void configure(){
      bind(FileManager.class).to(FileManagerStub.class);
    }
  }
);
  fileManager=(FileManagerStub)injector.getInstance(FileManager.class);
  fd1=new FileDescStub(""String_Node_Str"",hash1,0);
  fd2=new FileDescStub(""String_Node_Str"",hash2,1);
  fd3=new FileDescStub(""String_Node_Str"",hash3,2);
  fd4=new FileDescStub(""String_Node_Str"",hash4,3);
  fileManager.getGnutellaSharedFileList().add(fd1);
  fileManager.getGnutellaSharedFileList().add(fd2);
  fileManager.getGnutellaSharedFileList().add(fd3);
  fileManager.getGnutellaSharedFileList().add(fd4);
}",0.640268456375839
3994,"/** 
 * Pumps through each waiting download, either removing it because it was stopped, or adding it because there's an active slot and it requires attention.
 */
protected synchronized void pumpDownloads(){
  int index=1;
  for (Iterator<CoreDownloader> i=waiting.iterator(); i.hasNext(); ) {
    CoreDownloader md=i.next();
    if (md.isAlive()) {
      continue;
    }
 else     if (md.shouldBeRemoved()) {
      i.remove();
      cleanupCompletedDownload(md,false);
    }
 else     if (storeDownloadCount == 0 && md.getDownloadType() == DownloaderType.STORE) {
      i.remove();
      storeDownloadCount++;
      active.add(md);
      md.startDownload();
    }
 else     if (hasFreeSlot() && (md.shouldBeRestarted()) && (md.getDownloadType() != DownloaderType.STORE)) {
      i.remove();
      if (md.getDownloadType() == DownloaderType.INNETWORK)       innetworkCount++;
      active.add(md);
      md.startDownload();
    }
 else {
      if (md.isQueuable())       md.setInactivePriority(index++);
      md.handleInactivity();
    }
  }
}","/** 
 * Pumps through each waiting download, either removing it because it was stopped, or adding it because there's an active slot and it requires attention.
 */
protected synchronized void pumpDownloads(){
  int index=1;
  for (Iterator<CoreDownloader> i=waiting.iterator(); i.hasNext(); ) {
    CoreDownloader md=i.next();
    if (md.isAlive()) {
      continue;
    }
 else     if (md.shouldBeRemoved()) {
      i.remove();
      cleanupCompletedDownload(md,false);
    }
 else     if (storeDownloadCount < 3 && md.getDownloadType() == DownloaderType.STORE) {
      i.remove();
      storeDownloadCount++;
      active.add(md);
      md.startDownload();
    }
 else     if (hasFreeSlot() && (md.shouldBeRestarted()) && (md.getDownloadType() != DownloaderType.STORE)) {
      i.remove();
      if (md.getDownloadType() == DownloaderType.INNETWORK)       innetworkCount++;
      active.add(md);
      md.startDownload();
    }
 else {
      if (md.isQueuable())       md.setInactivePriority(index++);
      md.handleInactivity();
    }
  }
}",0.9966459032103496
3995,"@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  LocalFileItem item=(LocalFileItem)value;
  setIcon(thumbnailManager.getThumbnailForFile(item.getFile(),list,index));
  if (isSelected)   this.setBorder(selectedBorder);
 else   this.setBorder(border);
  return this;
}","@Override public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  LocalFileItem item=(LocalFileItem)value;
  setIcon(thumbnailManager.getThumbnailForFile(item.getFile(),list,index));
  if (thumbnailManager.isErrorIcon(item.getFile()))   setText(item.getFileName());
 else   setText(""String_Node_Str"");
  if (isSelected)   this.setBorder(selectedBorder);
 else   this.setBorder(border);
  return this;
}",0.8501827040194885
3996,"public ImageCellRenderer(int width,int height,ThumbnailManager thumbnailManager){
  super(width,height);
  this.thumbnailManager=thumbnailManager;
  super.topPadding=topPadding;
  GuiUtils.assignResources(this);
  setBackground(this.cellBackgroundColor);
  border=BorderFactory.createMatteBorder(1,1,1,1,cellBorderColor);
  selectedBorder=BorderFactory.createMatteBorder(2,2,2,2,cellBorderSelectionColor);
}","public ImageCellRenderer(int width,int height,ThumbnailManager thumbnailManager){
  super(width,height);
  this.thumbnailManager=thumbnailManager;
  GuiUtils.assignResources(this);
  setBackground(this.cellBackgroundColor);
  border=BorderFactory.createMatteBorder(1,1,1,1,cellBorderColor);
  selectedBorder=BorderFactory.createMatteBorder(2,2,2,2,cellBorderSelectionColor);
}",0.5287356321839081
3997,"/** 
 * Sets the subComponent on this. This gets painted below the image.
 */
public void setButtonComponent(JComponent buttonPanel){
  this.removeAll();
  this.buttonComponent=buttonPanel;
  calculateSubPanelDimensions();
  add(buttonPanel);
}","/** 
 * Sets the subComponent on this. This gets painted below the image.
 */
public void setButtonComponent(JComponent buttonPanel){
  this.removeAll();
  this.buttonComponent=buttonPanel;
  calculateSubPanelDimensions();
  add(buttonPanel);
  add(label);
}",0.9721115537848606
3998,"public ImageLabel(int width,int height){
  GuiUtils.assignResources(this);
  setOpaque(true);
  setPreferredSize(new Dimension(width,height));
  setSize(getPreferredSize());
  setLayout(null);
}","public ImageLabel(int width,int height){
  GuiUtils.assignResources(this);
  setOpaque(true);
  setPreferredSize(new Dimension(width,height));
  setSize(getPreferredSize());
  setLayout(null);
  label=new JLabel();
  label.setVisible(false);
  label.setOpaque(false);
  label.setForeground(Color.BLACK);
  label.setHorizontalAlignment(SwingConstants.CENTER);
  calculateLabelDimnensions();
  add(label);
}",0.6477462437395659
3999,"public LibraryImageCellRenderer(int width,int height,ThumbnailManager thumbnailManager){
  super(width,height,thumbnailManager);
}","public LibraryImageCellRenderer(int width,int height,ThumbnailManager thumbnailManager){
  super(width,height,thumbnailManager);
  GuiUtils.assignResources(this);
  border=BorderFactory.createMatteBorder(1,1,1,1,cellBorderColor);
  selectedBorder=BorderFactory.createMatteBorder(2,2,2,2,cellBorderSelectionColor);
}",0.5842696629213483
4000,"public ShareTableRendererEditor(Action shareAction){
  GuiUtils.assignResources(this);
  gnutellaLabel=new JLabel(shareGnutellaIcon);
  friendsLabel=new JLabel(shareFriendsIcon);
  shareButton=new IconButton(shareButtonIcon,shareButtonIcon,shareButtonPressedIcon);
  shareButton.addActionListener(shareAction);
  friendsLabel.setHorizontalTextPosition(SwingConstants.RIGHT);
  friendsLabel.setIconTextGap(4);
  setLayout(new MigLayout(""String_Node_Str""));
  add(gnutellaLabel);
  add(friendsLabel,""String_Node_Str"");
  add(shareButton);
}","public ShareTableRendererEditor(Action shareAction){
  GuiUtils.assignResources(this);
  setOpaque(false);
  gnutellaLabel=new JLabel(shareGnutellaIcon);
  friendsLabel=new JLabel(shareFriendsIcon);
  shareButton=new IconButton(shareButtonIcon,shareButtonIcon,shareButtonPressedIcon);
  shareButton.addActionListener(shareAction);
  friendsLabel.setHorizontalTextPosition(SwingConstants.RIGHT);
  friendsLabel.setIconTextGap(4);
  setLayout(new MigLayout(""String_Node_Str""));
  add(gnutellaLabel);
  add(friendsLabel,""String_Node_Str"");
  add(shareButton);
}",0.9817518248175182
