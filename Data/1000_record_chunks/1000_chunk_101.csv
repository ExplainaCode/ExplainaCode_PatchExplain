record_number,buggy_code,fixed_code,code_similarity
100001,"/** 
 * Return the entry basic block for the CFG.
 * @return the entry basic block for the CFG.
 */
public T entry(){
  return getNode(0);
}","/** 
 * Return the entry basic block for the CFG.
 */
public T entry(){
  return getNode(0);
}",0.8034188034188035
100002,"/** 
 * Return the exit basic block for the CFG.
 * @return the exit basic block for the CFG.
 */
public T exit(){
  return exit;
}","/** 
 * Return the exit basic block for the CFG.
 */
public T exit(){
  return exit;
}",0.7926267281105991
100003,"/** 
 * @param method
 */
protected AbstractCFG(IMethod method){
  this.method=method;
  this.catchBlocks=new BitVector(10);
}","protected AbstractCFG(IMethod method){
  this.method=method;
  this.catchBlocks=new BitVector(10);
}",0.8849557522123894
100004,"public static ExplodedInterproceduralCFG make(CallGraph CG){
  return new ExplodedInterproceduralCFG(CG);
}","public static ExplodedInterproceduralCFG make(CallGraph cg){
  return new ExplodedInterproceduralCFG(cg);
}",0.9626168224299064
100005,"public boolean isEntryBlock(){
  return original.isEntryBlock();
}","public boolean isEntryBlock(){
  return instructionIndex == ENTRY_INDEX;
}",0.7
100006,"public int getPredNodeCount(ExplodedBasicBlock b) throws IllegalArgumentException {
  if (b == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (b.isEntryBlock()) {
    return 0;
  }
  if (b.equals(exit) || b.instructionIndex == b.original.getFirstInstructionIndex()) {
    return ir.getControlFlowGraph().getPredNodeCount(b.original);
  }
 else {
    return 1;
  }
}","public int getPredNodeCount(ExplodedBasicBlock b) throws IllegalArgumentException {
  if (b == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (b.isEntryBlock()) {
    return 0;
  }
  if (b.isExitBlock()) {
    return ir.getControlFlowGraph().getPredNodeCount(ir.getControlFlowGraph().exit());
  }
  if (b.instructionIndex == b.original.getFirstInstructionIndex()) {
    if (b.original.isEntryBlock()) {
      return 1;
    }
 else {
      return ir.getControlFlowGraph().getPredNodeCount(b.original);
    }
  }
 else {
    return 1;
  }
}",0.7866805411030177
100007,"public boolean isCatchBlock(){
  return (original.isCatchBlock() && instructionIndex == original.getFirstInstructionIndex());
}","public boolean isCatchBlock(){
  if (original == null) {
    return false;
  }
  return (original.isCatchBlock() && instructionIndex == original.getFirstInstructionIndex());
}",0.8410596026490066
100008,"public ExplodedBasicBlock(int instructionIndex,ISSABasicBlock original){
}","public ExplodedBasicBlock(int instructionIndex,ISSABasicBlock original){
  this.instructionIndex=instructionIndex;
  this.original=original;
}",0.6851851851851852
100009,"public boolean isExitBlock(){
  return original.isExitBlock();
}","public boolean isExitBlock(){
  return instructionIndex == EXIT_INDEX;
}",0.6764705882352942
100010,"private T getDominator(T node){
  return getInfo(node).dominator;
}","private T getDominator(T node){
}",0.66
100011,"/** 
 * The goal of this step is to perform a DFS numbering on the CFG, starting at the root. The exit node is not included.
 */
private void step1(){
  reachableNodeCount=0;
  DFSDiscoverTimeIterator<T> dfs=new SlowDFSDiscoverTimeIterator<T>(G,root){
    public static final long serialVersionUID=88831771771711L;
    @Override protected void visitEdge(    T from,    T to){
      if (DEBUG)       System.out.println(""String_Node_Str"" + from + ""String_Node_Str""+ to);
      setParent(to,from);
    }
  }
;
  while (dfs.hasNext()) {
    T node=dfs.next();
    vertex[++reachableNodeCount]=node;
    setSemi(node,reachableNodeCount);
    if (DEBUG)     System.out.println(node + ""String_Node_Str"" + reachableNodeCount);
  }
}","/** 
 * The goal of this step is to perform a DFS numbering on the CFG, starting at the root. The exit node is not included.
 */
private void step1(){
}",0.3470319634703196
100012,"@Override protected final DominatorInfo getInfo(T node){
  return (DominatorInfo)infoMap[getGraph().getNumber(node)];
}","@Override protected final DominatorInfo getInfo(T node){
}",0.655367231638418
100013,"/** 
 * @param catchClasses Set of TypeReference
 * @param klass an Exception Class
 * @return true iff klass is a subclass of some element of the Set
 * @throws IllegalArgumentException if catchClasses is null
 */
public static boolean catches(Set<IClass> catchClasses,IClass klass,IClassHierarchy cha){
  if (catchClasses == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (catchClasses.size() == 1) {
    IClass c=catchClasses.iterator().next();
    if (c.getReference().equals(TypeReference.JavaLangThread)) {
      return true;
    }
  }
  for (  IClass c : catchClasses) {
    if (cha.isAssignableFrom(c,klass)) {
      return true;
    }
  }
  return false;
}","/** 
 * @param catchClasses Set of TypeReference
 * @param klass an Exception Class
 * @return true iff klass is a subclass of some element of the Set
 * @throws IllegalArgumentException if catchClasses is null
 */
public static boolean catches(Set<IClass> catchClasses,IClass klass,IClassHierarchy cha){
  if (catchClasses == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (catchClasses.size() == 1) {
    IClass c=catchClasses.iterator().next();
    if (c != null && c.getReference().equals(TypeReference.JavaLangThread)) {
      return true;
    }
  }
  for (  IClass c : catchClasses) {
    if (c != null && cha.isAssignableFrom(c,klass)) {
      return true;
    }
  }
  return false;
}",0.9816124469589816
100014,"/** 
 * Compute an analysis scope for the current selection
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(IStructuredSelection selection) throws JavaModelException, IOException {
  Collection<EclipseProjectPath> projectPaths=HashSetFactory.make();
  for (Iterator it=selection.iterator(); it.hasNext(); ) {
    Object object=it.next();
    if (object instanceof IJavaElement) {
      IJavaElement e=(IJavaElement)object;
      IJavaProject jp=e.getJavaProject();
      projectPaths.add(EclipseProjectPath.make(ResourcesPlugin.getWorkspace().getRoot().getLocation(),jp));
    }
 else {
      Assertions.UNREACHABLE(object.getClass());
    }
  }
  AnalysisScope scope=mergeProjectPaths(projectPaths);
  return scope;
}","/** 
 * Compute an analysis scope for the current selection
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(IStructuredSelection selection) throws JavaModelException, IOException {
  Collection<EclipseProjectPath> projectPaths=HashSetFactory.make();
  for (Iterator it=selection.iterator(); it.hasNext(); ) {
    Object object=it.next();
    if (object instanceof IJavaElement) {
      IJavaElement e=(IJavaElement)object;
      IJavaProject jp=e.getJavaProject();
      projectPaths.add(EclipseProjectPath.make(jp));
    }
 else {
      Assertions.UNREACHABLE(object.getClass());
    }
  }
  AnalysisScope scope=mergeProjectPaths(projectPaths);
  return scope;
}",0.9629629629629628
100015,"protected EclipseProjectPath(IPath workspaceRootPath,IJavaProject project) throws JavaModelException, IOException {
}","protected EclipseProjectPath(IJavaProject project) throws JavaModelException, IOException {
}",0.8857142857142857
100016,"public static EclipseProjectPath make(IPath workspaceRootPath,IJavaProject project) throws JavaModelException, IOException {
  if (workspaceRootPath == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new EclipseProjectPath(workspaceRootPath,project);
}","public static EclipseProjectPath make(IJavaProject project) throws JavaModelException, IOException {
  return new EclipseProjectPath(project);
}",0.6728971962616822
100017,"protected IPath makeAbsolute(IPath p){
  if (p.toFile().exists()) {
    return p;
  }
  return workspaceRootPath.append(p);
}","protected IPath makeAbsolute(IPath p){
  if (p.toFile().exists()) {
    return p;
  }
  String projectName=p.segment(0);
  IJavaProject jp=JdtUtil.getJavaProject(projectName);
  if (jp != null) {
    if (jp.getProject().getRawLocation() != null) {
      return jp.getProject().getRawLocation().append(p.removeFirstSegments(1));
    }
 else {
      IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
      return workspaceRoot.getLocation().append(p);
    }
  }
 else {
    Assertions.UNREACHABLE(""String_Node_Str"" + p);
    return null;
  }
}",0.3318777292576419
100018,"/** 
 * compute the analysis scope for a project in the current workspace
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(String projectName) throws JavaModelException, IOException {
  IJavaProject jp=getProjectFromWorkspace(projectName);
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  EclipseProjectPath path=EclipseProjectPath.make(workspaceRoot.getLocation(),jp);
  return path.toAnalysisScope(null);
}","/** 
 * compute the analysis scope for a project in the current workspace
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(String projectName) throws JavaModelException, IOException {
  IJavaProject jp=getProjectFromWorkspace(projectName);
  EclipseProjectPath path=EclipseProjectPath.make(jp);
  return path.toAnalysisScope(null);
}",0.715765247410817
100019,"@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : mam.getFieldWrites(convertToHeapModel(loadBase,mam.getHeapModel()),field)) {
      IR ir=fieldWrite.getNode().getIR();
      SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[fieldWrite.getInstructionIndex()];
      if (s == null) {
        continue;
      }
      PointerKey putfieldBase=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getRef());
      PointerKey writtenPk=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getVal());
      Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,putfieldBase);
      for (      State nextState : reachedFlowStates) {
        System.err.println(""String_Node_Str"" + s);
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}","@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : mam.getFieldWrites(convertToHeapModel(loadBase,mam.getHeapModel()),field)) {
      IR ir=fieldWrite.getNode().getIR();
      SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[fieldWrite.getInstructionIndex()];
      if (s == null) {
        continue;
      }
      PointerKey putfieldBase=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getRef());
      PointerKey writtenPk=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getVal());
      Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,putfieldBase);
      for (      State nextState : reachedFlowStates) {
        if (DEBUG_TOPLEVEL) {
          System.err.println(""String_Node_Str"" + s);
        }
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}",0.988929889298893
100020,"public void makePassOverFieldStmts(){
  for (  StoreEdge storeEdge : encounteredStores) {
    PointerKeyAndState storedValAndState=storeEdge.val;
    IField field=storeEdge.field;
    PointerKeyAndState baseAndState=storeEdge.base;
    IntSet trackedSet=find(pkToTrackedSet,baseAndState);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      if (forwInstKeyToFields.get(ikAndState).contains(field)) {
        if (!addToInitWorklist(storedValAndState)) {
          InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
          findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storedValAndState));
        }
      }
    }
  }
  for (  LoadEdge loadEdge : encounteredLoads) {
    PointerKeyAndState loadedValAndState=loadEdge.val;
    IField field=loadEdge.field;
    PointerKey basePointerKey=loadEdge.base.getPointerKey();
    State loadDstState=loadedValAndState.getState();
    PointerKeyAndState baseAndStateToHandle=new PointerKeyAndState(basePointerKey,loadDstState);
    if (Assertions.verifyAssertions) {
      boolean basePointerOkay=pointsToQueried.get(basePointerKey).contains(loadDstState) || !pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadDstState) || initWorklist.contains(loadedValAndState);
      if (!basePointerOkay) {
      }
    }
    final IntSet curP2Set=find(pkToP2Set,baseAndStateToHandle);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(curP2Set)) {
      InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
      if (addAllToP2Set(pkToP2Set,loadedValAndState,find(instFieldKeyToP2Set,ifk),AssignLabel.noFilter())) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + loadEdge);
        }
        addToPToWorklist(loadedValAndState);
      }
    }
    PointerKeyAndState baseAndState=loadEdge.base;
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToTrackedSet,baseAndState))) {
      if (backInstKeyToFields.get(ikAndState).contains(field)) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedValAndState).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + loadEdge);
          }
          addToTrackedPToWorklist(loadedValAndState);
        }
      }
    }
  }
}","public void makePassOverFieldStmts(){
  for (  StoreEdge storeEdge : encounteredStores) {
    PointerKeyAndState storedValAndState=storeEdge.val;
    IField field=storeEdge.field;
    PointerKeyAndState baseAndState=storeEdge.base;
    IntSet trackedSet=find(pkToTrackedSet,baseAndState);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      if (forwInstKeyToFields.get(ikAndState).contains(field)) {
        if (!addToInitWorklist(storedValAndState)) {
          InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
          findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storedValAndState));
        }
      }
    }
  }
  for (  LoadEdge loadEdge : encounteredLoads) {
    PointerKeyAndState loadedValAndState=loadEdge.val;
    IField field=loadEdge.field;
    PointerKey basePointerKey=loadEdge.base.getPointerKey();
    State loadDstState=loadedValAndState.getState();
    PointerKeyAndState baseAndStateToHandle=new PointerKeyAndState(basePointerKey,loadDstState);
    if (Assertions.verifyAssertions) {
      boolean basePointerOkay=pointsToQueried.get(basePointerKey).contains(loadDstState) || !pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadDstState) || initWorklist.contains(loadedValAndState);
      if (!basePointerOkay) {
      }
    }
    final IntSet curP2Set=find(pkToP2Set,baseAndStateToHandle);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(curP2Set)) {
      InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
      if (pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadedValAndState.getState())) {
        if (addAllToP2Set(pkToP2Set,loadedValAndState,find(instFieldKeyToP2Set,ifk),AssignLabel.noFilter())) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + loadEdge);
          }
          addToPToWorklist(loadedValAndState);
        }
      }
    }
    PointerKeyAndState baseAndState=loadEdge.base;
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToTrackedSet,baseAndState))) {
      if (backInstKeyToFields.get(ikAndState).contains(field)) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedValAndState).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + loadEdge);
          }
          addToTrackedPToWorklist(loadedValAndState);
        }
      }
    }
  }
}",0.973819830962688
100021,"private boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals,IFlowLabel label){
  final PointerKey pk=pkAndState.getPointerKey();
  if (pk instanceof FilteredPointerKey) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pk);
    }
    final TypeFilter typeFilter=((FilteredPointerKey)pk).getTypeFilter();
    vals=updateValsForFilter(vals,typeFilter);
  }
  if (label instanceof IFlowLabelWithFilter) {
    TypeFilter typeFilter=((IFlowLabelWithFilter)label).getFilter();
    if (typeFilter != null) {
      vals=updateValsForFilter(vals,typeFilter);
    }
  }
  boolean added=findOrCreate(p2setMap,pkAndState).addAll(vals);
  if (DEBUG && added) {
  }
  return added;
}","private boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals,IFlowLabel label){
  final PointerKey pk=pkAndState.getPointerKey();
  if (pk instanceof FilteredPointerKey) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pk);
    }
    final TypeFilter typeFilter=((FilteredPointerKey)pk).getTypeFilter();
    vals=updateValsForFilter(vals,typeFilter);
  }
  if (label instanceof IFlowLabelWithFilter) {
    TypeFilter typeFilter=((IFlowLabelWithFilter)label).getFilter();
    if (typeFilter != null) {
      vals=updateValsForFilter(vals,typeFilter);
    }
  }
  boolean added=findOrCreate(p2setMap,pkAndState).addAll(vals);
  if (DEBUG && added) {
    System.err.println(""String_Node_Str"" + pkAndState + ""String_Node_Str"");
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(vals)) {
      System.err.println(ikAndState);
    }
    System.err.println(""String_Node_Str"");
  }
  return added;
}",0.8642981945253349
100022,"@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : mam.getFieldWrites(convertToHeapModel(loadBase,mam.getHeapModel()),field)) {
      IR ir=fieldWrite.getNode().getIR();
      SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[fieldWrite.getInstructionIndex()];
      if (s == null) {
        continue;
      }
      PointerKey putfieldBase=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getRef());
      PointerKey writtenPk=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getVal());
      Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,putfieldBase);
      for (      State nextState : reachedFlowStates) {
        if (DEBUG_TOPLEVEL) {
          System.err.println(""String_Node_Str"" + s);
        }
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}","@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : getWrites(field,loadBase)) {
      Collection<Pair<PointerKey,PointerKey>> baseAndStoredPairs=getBaseAndStored(fieldWrite,field);
      if (baseAndStoredPairs == null) {
        continue;
      }
      for (      Pair<PointerKey,PointerKey> p : baseAndStoredPairs) {
        PointerKey base=p.fst;
        PointerKey stored=p.snd;
        Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,base);
        for (        State nextState : reachedFlowStates) {
          if (DEBUG_TOPLEVEL) {
            System.err.println(""String_Node_Str"" + base + ""String_Node_Str""+ nextState);
          }
          h.propagate(new PointerKeyAndState(stored,nextState));
        }
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}",0.7465388711395101
100023,"Iterator<PointerKey> getArrayWrites(PointerKey arrayRef){
  arrayRef=convertToHeapModel(arrayRef,mam.getHeapModel());
  Collection<MemoryAccess> arrayWrites=mam.getArrayWrites(arrayRef);
  for (  MemoryAccess a : arrayWrites) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : arrayWrites) {
    final CGNode node=a.getNode();
    IR ir=node.getIR();
    SSAInstruction instruction=ir.getInstructions()[a.getInstructionIndex()];
    if (instruction == null) {
      continue;
    }
    if (instruction instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction s=(SSAArrayStoreInstruction)instruction;
      PointerKey r=heapModel.getPointerKeyForLocal(node,s.getValue());
      written.add(r);
    }
 else     if (instruction instanceof SSANewInstruction) {
      SSANewInstruction n=(SSANewInstruction)instruction;
      InstanceKey iKey=heapModel.getInstanceKeyForAllocation(node,n.getNewSite());
      if (iKey == null) {
        continue;
      }
      IClass klass=iKey.getConcreteType();
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass.isArrayClass() && ((ArrayClass)klass).getElementClass().isArrayClass());
      }
      int dim=0;
      InstanceKey lastInstance=iKey;
      while (klass != null && klass.isArrayClass()) {
        klass=((ArrayClass)klass).getElementClass();
        if (klass != null && klass.isArrayClass()) {
          InstanceKey ik=heapModel.getInstanceKeyForMultiNewArray(node,n.getNewSite(),dim);
          PointerKey pk=heapModel.getPointerKeyForArrayContents(lastInstance);
          written.add(pk);
          lastInstance=ik;
          dim++;
        }
      }
    }
 else {
      Assertions.UNREACHABLE();
    }
  }
  return written.iterator();
}","Iterator<PointerKey> getArrayWrites(PointerKey arrayRef){
  arrayRef=convertToHeapModel(arrayRef,mam.getHeapModel());
  Collection<MemoryAccess> arrayWrites=mam.getArrayWrites(arrayRef);
  for (  MemoryAccess a : arrayWrites) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : arrayWrites) {
    final CGNode node=a.getNode();
    IR ir=node.getIR();
    SSAInstruction instruction=ir.getInstructions()[a.getInstructionIndex()];
    if (instruction == null) {
      continue;
    }
    if (instruction instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction s=(SSAArrayStoreInstruction)instruction;
      PointerKey r=heapModel.getPointerKeyForLocal(node,s.getValue());
      written.add(r);
    }
 else     if (instruction instanceof SSANewInstruction) {
      NewMultiDimInfo multiDimInfo=DemandPointerFlowGraph.getInfoForNewMultiDim((SSANewInstruction)instruction,heapModel,node);
      for (      Pair<PointerKey,PointerKey> arrStoreInstr : multiDimInfo.arrStoreInstrs) {
        written.add(arrStoreInstr.snd);
      }
    }
 else {
      Assertions.UNREACHABLE();
    }
  }
  return written.iterator();
}",0.6466866466866467
100024,"/** 
 * Add constraints to represent the flow of exceptions to the exceptional return value for this node
 */
protected void addNodePassthruExceptionConstraints(CGNode node,IR ir){
  List<ProgramCounter> peis=SSAPropagationCallGraphBuilder.getIncomingPEIs(ir,ir.getExitBlock());
  PointerKey exception=heapModel.getPointerKeyForExceptionalReturnValue(node);
  addExceptionDefConstraints(ir,node,peis,exception,PropagationCallGraphBuilder.THROWABLE_SET);
}","/** 
 * Add constraints to represent the flow of exceptions to the exceptional return value for this node
 */
protected void addNodePassthruExceptionConstraints(CGNode node,IR ir){
  List<ProgramCounter> peis=SSAPropagationCallGraphBuilder.getIncomingPEIs(ir,ir.getExitBlock());
  PointerKey exception=heapModel.getPointerKeyForExceptionalReturnValue(node);
  IClass c=node.getClassHierarchy().lookupClass(TypeReference.JavaLangThrowable);
  addExceptionDefConstraints(ir,node,peis,exception,Collections.singleton(c));
}",0.8492307692307692
100025,"/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<TypeReference> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            addNode(exceptionVar);
            addNode(ik);
            addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}","/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<IClass> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            addNode(exceptionVar);
            addNode(ik);
            addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}",0.9953465589027676
100026,"@Override public void visitGetCaughtException(SSAGetCaughtExceptionInstruction instruction){
  List<ProgramCounter> peis=SSAPropagationCallGraphBuilder.getIncomingPEIs(ir,getBasicBlock());
  PointerKey def=heapModel.getPointerKeyForLocal(node,instruction.getDef());
  Set<TypeReference> types=SSAPropagationCallGraphBuilder.getCaughtExceptionTypes(instruction,ir);
  addExceptionDefConstraints(ir,node,peis,def,types);
}","@Override public void visitGetCaughtException(SSAGetCaughtExceptionInstruction instruction){
  List<ProgramCounter> peis=SSAPropagationCallGraphBuilder.getIncomingPEIs(ir,getBasicBlock());
  PointerKey def=heapModel.getPointerKeyForLocal(node,instruction.getDef());
  Set<IClass> types=SSAPropagationCallGraphBuilder.getCaughtExceptionTypes(instruction,ir);
  addExceptionDefConstraints(ir,node,peis,def,types);
}",0.9771908763505402
100027,"/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<TypeReference> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      g.addNode(exceptionVar);
      g.addNode(e);
      g.addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      g.addNode(exceptionVar);
      g.addNode(e);
      g.addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            g.addNode(exceptionVar);
            g.addNode(ik);
            g.addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}","/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<IClass> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      g.addNode(exceptionVar);
      g.addNode(e);
      g.addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      g.addNode(exceptionVar);
      g.addNode(e);
      g.addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            g.addNode(exceptionVar);
            g.addNode(ik);
            g.addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}",0.9953872299101724
100028,"public int[] computeColumnWidths(){
  int[] result=new int[getNumberOfColumns()];
  for (int i=0; i < getNumberOfColumns(); i++) {
    result[i]=columnHeadings.get(i).toString().length() + 1;
  }
  for (int j=0; j < getNumberOfRows(); j++) {
    for (int i=0; i < getNumberOfColumns(); i++) {
      result[i]=Math.max(result[i],getElement(j,i).toString().length() + 1);
    }
  }
  return result;
}","public int[] computeColumnWidths(){
  int[] result=new int[getNumberOfColumns()];
  for (int i=0; i < getNumberOfColumns(); i++) {
    result[i]=columnHeadings.get(i).toString().length() + 1;
  }
  for (int j=0; j < getNumberOfRows(); j++) {
    for (int i=0; i < getNumberOfColumns(); i++) {
      T element=getElement(j,i);
      result[i]=element == null ? result[i] : Math.max(result[i],element.toString().length() + 1);
    }
  }
  return result;
}",0.8766157461809636
100029,"private IMethod makeUnaryNumberCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(4,2,""String_Node_Str""));
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(new JavaScriptInvoke(4,5,new int[]{2},6,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeUnaryNumberCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(new JavaScriptInvoke(4,5,new int[]{2},6,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9459962756052142
100030,"private IMethod makeNullaryStringCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addConstant(new Integer(2),new ConstantValue(""String_Node_Str""));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeNullaryStringCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addConstant(new Integer(2),new ConstantValue(""String_Node_Str""));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9619921363040628
100031,"private IMethod makeUnaryObjectConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Object);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeUnaryObjectConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Object);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9548989113530326
100032,"private IMethod makeArrayLengthConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Array);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(5,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(6,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Array)));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",5));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",2));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(6,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeArrayLengthConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Array);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(5,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(6,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Array)));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",5));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",2));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(6,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9186535764375876
100033,"private IMethod makeNullaryNumberCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addConstant(new Integer(2),new ConstantValue(0.0));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeNullaryNumberCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addConstant(new Integer(2),new ConstantValue(0.0));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(2,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9605442176870748
100034,"private IMethod makeNullaryObjectConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Object);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addStatement(new JavaScriptStaticPropertyRead(4,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",4));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeNullaryObjectConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Object);
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addStatement(new JavaScriptStaticPropertyRead(4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",4));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9305666400638468
100035,"private IMethod makeNullaryValueConstructor(IClass cls,Object value){
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addStatement(new JavaScriptStaticPropertyRead(4,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(5,NewSiteReference.make(S.getNextProgramCounter(),cls.getReference())));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",4));
  S.addConstant(new Integer(8),new ConstantValue(value));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",8));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeNullaryValueConstructor(IClass cls,Object value){
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,1);
  S.addStatement(new JavaScriptStaticPropertyRead(4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(5,NewSiteReference.make(S.getNextProgramCounter(),cls.getReference())));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",4));
  S.getNextProgramCounter();
  S.addConstant(new Integer(8),new ConstantValue(value));
  S.addStatement(new JavaScriptStaticPropertyWrite(5,""String_Node_Str"",8));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.925545571245186
100036,"private IMethod makeUnaryStringCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(4,2,""String_Node_Str""));
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(new JavaScriptInvoke(4,5,new int[]{2},6,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeUnaryStringCall(IClass cls){
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(new JavaScriptInvoke(4,5,new int[]{2},6,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9459962756052142
100037,"private IMethod makeUnaryValueConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(5,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(6,NewSiteReference.make(S.getNextProgramCounter(),cls.getReference())));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",5));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",2));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(6,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeUnaryValueConstructor(IClass cls){
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(new JavaScriptStaticPropertyRead(5,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(6,NewSiteReference.make(S.getNextProgramCounter(),cls.getReference())));
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",5));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptStaticPropertyWrite(6,""String_Node_Str"",2));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(6,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.9178470254957508
100038,"private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(new JavaScriptStaticPropertyRead(nargs + 4,1,""String_Node_Str""));
  S.addStatement(new JavaScriptNewInstruction(nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 4));
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(new JavaScriptInvoke(1,nargs + 7,args,nargs + 8,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(nargs + 7,false));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(nargs + 5,false));
  return record(key,new JavaScriptConstructor(ref,S,cls));
}","private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(new JavaScriptStaticPropertyRead(nargs + 4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 4));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(new JavaScriptInvoke(1,nargs + 7,args,nargs + 8,cs));
  S.addStatement(SSAInstructionFactory.ReturnInstruction(nargs + 7,false));
  S.getNextProgramCounter();
  S.addStatement(SSAInstructionFactory.ReturnInstruction(nargs + 5,false));
  S.getNextProgramCounter();
  return record(key,new JavaScriptConstructor(ref,S,cls));
}",0.949740034662045
100039,"private IMethod makeArrayContentsConstructor(IClass cls,int nargs){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Array);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addConstant(new Integer(nargs + 3),new ConstantValue(""String_Node_Str""));
  S.addStatement(new JavaScriptPropertyRead(nargs + 4,1,nargs + 3));
  S.addStatement(new JavaScriptNewInstruction(nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Array)));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 4));
  S.addConstant(new Integer(nargs + 7),new ConstantValue(nargs));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 7));
  int vn=nargs + 9;
  for (int i=0; i < nargs; i++, vn+=2) {
    S.addConstant(new Integer(vn),new ConstantValue(i));
    S.addStatement(new JavaScriptPropertyWrite(nargs + 5,vn,i + 1));
  }
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  return new JavaScriptConstructor(ref,S,cls);
}","private IMethod makeArrayContentsConstructor(IClass cls,int nargs){
  MethodReference ref=JavaScriptMethods.makeCtorReference(JavaScriptTypes.Array);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addConstant(new Integer(nargs + 3),new ConstantValue(""String_Node_Str""));
  S.addStatement(new JavaScriptPropertyRead(nargs + 4,1,nargs + 3));
  S.getNextProgramCounter();
  S.addStatement(new JavaScriptNewInstruction(nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Array)));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 4));
  S.getNextProgramCounter();
  S.addConstant(new Integer(nargs + 7),new ConstantValue(nargs));
  S.addStatement(new JavaScriptStaticPropertyWrite(nargs + 5,""String_Node_Str"",nargs + 7));
  S.getNextProgramCounter();
  int vn=nargs + 9;
  for (int i=0; i < nargs; i++, vn+=2) {
    S.addConstant(new Integer(vn),new ConstantValue(i));
    S.addStatement(new JavaScriptPropertyWrite(nargs + 5,vn,i + 1));
    S.getNextProgramCounter();
  }
  S.addStatement(SSAInstructionFactory.ReturnInstruction(5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls);
}",0.934228187919463
100040,"@Override public void visitAssignGlobal(AssignGlobalLabel label,Object dst){
  for (Iterator<? extends Object> readIter=g.getReadsOfStaticField((StaticFieldKey)dst); readIter.hasNext(); ) {
    final PointerKey predPk=(PointerKey)readIter.next();
    doTransition(curState,AssignGlobalBarLabel.v(),new Function<State,Object>(){
      public Object apply(      State predPkState){
        PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
        if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
          addToTrackedPToWorklist(predPkAndState);
        }
        return null;
      }
    }
);
  }
}","@Override public void visitAssignGlobal(AssignGlobalLabel label,Object dst){
  for (Iterator<? extends Object> writesToStaticField=g.getWritesToStaticField((StaticFieldKey)dst); writesToStaticField.hasNext(); ) {
    final PointerKey writtenPk=(PointerKey)writesToStaticField.next();
    doTransition(curState,label,new Function<State,Object>(){
      public Object apply(      State nextState){
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
        return null;
      }
    }
);
  }
}",0.629661751951431
100041,"@Override public void visitNew(NewLabel label,Object dst){
  final InstanceKey ik=(InstanceKey)dst;
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ik + ""String_Node_Str""+ curPk);
  }
  doTransition(curState,label,new Function<State,Object>(){
    public Object apply(    State newState){
      InstanceKeyAndState ikAndState=new InstanceKeyAndState(ik,newState);
      int n=ikAndStates.add(ikAndState);
      findOrCreate(pkToP2Set,curPkAndState).add(n);
      addToPToWorklist(curPkAndState);
      return null;
    }
  }
);
}","@Override public void visitNew(NewLabel label,Object dst){
  final InstanceKey ik=(InstanceKey)dst;
  if (DEBUG_TOPLEVEL) {
    System.err.println(""String_Node_Str"" + ik + ""String_Node_Str""+ curPk);
  }
  doTransition(curState,label,new Function<State,Object>(){
    public Object apply(    State newState){
      if (!pred.test(ik)) {
        foundBadInstanceKey=true;
      }
      return null;
    }
  }
);
}",0.7052631578947368
100042,"private Collection<IMethod> getOTFTargets(CallSiteAndCGNode callSiteAndCGNode,SSAAbstractInvokeInstruction[] callInstrs,State callerState){
  final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
  final CGNode caller=callSiteAndCGNode.getCGNode();
  Collection<IMethod> result=HashSetFactory.make();
  for (  SSAAbstractInvokeInstruction callInstr : callInstrs) {
    PointerKey thisArg=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(0));
    PointerKeyAndState thisArgAndState=new PointerKeyAndState(thisArg,callerState);
    OrdinalSet<InstanceKeyAndState> thisPToSet=getPToSetFromComputer(ptoComputer,thisArgAndState);
    for (    InstanceKeyAndState ikAndState : thisPToSet) {
      InstanceKey ik=ikAndState.getInstanceKey();
      IMethod targetMethod=options.getMethodTargetSelector().getCalleeTarget(caller,call,ik.getConcreteType());
      if (targetMethod == null) {
        continue;
      }
      result.add(targetMethod);
    }
  }
  return result;
}","private Collection<IMethod> getOTFTargets(CallSiteAndCGNode callSiteAndCGNode,SSAAbstractInvokeInstruction[] callInstrs,State callerState){
  if (DEBUG_TOPLEVEL) {
    System.err.println(""String_Node_Str"" + callSiteAndCGNode);
  }
  final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
  final CGNode caller=callSiteAndCGNode.getCGNode();
  Collection<IMethod> result=HashSetFactory.make();
  for (  SSAAbstractInvokeInstruction callInstr : callInstrs) {
    PointerKey thisArg=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(0));
    PointerKeyAndState thisArgAndState=new PointerKeyAndState(thisArg,callerState);
    OrdinalSet<InstanceKeyAndState> thisPToSet=getPToSetFromComputer(ptoComputer,thisArgAndState);
    for (    InstanceKeyAndState ikAndState : thisPToSet) {
      InstanceKey ik=ikAndState.getInstanceKey();
      IMethod targetMethod=options.getMethodTargetSelector().getCalleeTarget(caller,call,ik.getConcreteType());
      if (targetMethod == null) {
        continue;
      }
      result.add(targetMethod);
    }
  }
  return result;
}",0.9561022672455378
100043,"/** 
 * track a field of some instance key, as we are interested in statements that read or write to the field
 * @param ikAndState
 * @param field
 * @param ikToFields either {@link #forwInstKeyToFields} or {@link #backInstKeyToFields}
 */
private void trackInstanceField(InstanceKeyAndState ikAndState,IField field,MultiMap<InstanceKeyAndState,IField> ikToFields){
  State state=ikAndState.getState();
  if (Assertions.verifyAssertions) {
  }
  ikToFields.put(ikAndState,field);
  for (Iterator<? extends Object> iter=g.getPredNodes(ikAndState.getInstanceKey(),NewLabel.v()); iter.hasNext(); ) {
    PointerKey ikPred=(PointerKey)iter.next();
    PointerKeyAndState ikPredAndState=new PointerKeyAndState(ikPred,state);
    int mappedIndex=ikAndStates.getMappedIndex(ikAndState);
    if (Assertions.verifyAssertions) {
      Assertions._assert(mappedIndex != -1);
    }
    if (findOrCreate(pkToTrackedSet,ikPredAndState).add(mappedIndex)) {
      addToTrackedPToWorklist(ikPredAndState);
    }
  }
}","/** 
 * track a field of some instance key, as we are interested in statements that read or write to the field
 * @param ikAndState
 * @param field
 * @param ikToFields either {@link #forwInstKeyToFields} or {@link #backInstKeyToFields}
 */
private void trackInstanceField(InstanceKeyAndState ikAndState,IField field,MultiMap<InstanceKeyAndState,IField> ikToFields){
  if (Assertions.verifyAssertions) {
  }
  ikToFields.put(ikAndState,field);
  addPredsOfIKeyAndStateToTrackedPointsTo(ikAndState);
}",0.5996002664890073
100044,"@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=label.getField();
  PointerKey dstPtrKey=(PointerKey)dst;
  if (refineFieldAccesses(field,curPk,dstPtrKey,label.bar(),curState)) {
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      boolean needField=backInstKeyToFields.get(ikAndState).contains(field);
      PointerKeyAndState loadedVal=new PointerKeyAndState(dstPtrKey,curState);
      addEncounteredLoad(new LoadEdge(curPkAndState,field,loadedVal));
      if (needField) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedVal).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          addToTrackedPToWorklist(loadedVal);
        }
      }
    }
  }
}","@Override public void visitGetField(GetFieldLabel label,Object dst){
  IField field=(label).getField();
  PointerKey loadBase=(PointerKey)dst;
  if (refineFieldAccesses(field,loadBase,curPk,label,curState)) {
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + field);
    }
    OrdinalSet<InstanceKeyAndState> basePToSet=h.getPToSetFromComputer(ptoComputer,new PointerKeyAndState(loadBase,curState));
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"" + basePToSet);
    }
    h.computeFlowsTo(ptoComputer,basePToSet);
    if (DEBUG_TOPLEVEL) {
      System.err.println(""String_Node_Str"");
    }
    for (    MemoryAccess fieldWrite : mam.getFieldWrites(convertToHeapModel(loadBase,mam.getHeapModel()),field)) {
      IR ir=fieldWrite.getNode().getIR();
      SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[fieldWrite.getInstructionIndex()];
      if (s == null) {
        continue;
      }
      PointerKey putfieldBase=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getRef());
      PointerKey writtenPk=heapModel.getPointerKeyForLocal(fieldWrite.getNode(),s.getVal());
      Collection<State> reachedFlowStates=h.getFlowedToStates(ptoComputer,basePToSet,putfieldBase);
      for (      State nextState : reachedFlowStates) {
        System.err.println(""String_Node_Str"" + s);
        h.propagate(new PointerKeyAndState(writtenPk,nextState));
      }
    }
  }
 else {
    for (Iterator<PointerKey> writesToInstanceField=g.getWritesToInstanceField(loadBase,field); writesToInstanceField.hasNext(); ) {
      final PointerKey writtenPk=writesToInstanceField.next();
      doTransition(curState,MatchLabel.v(),new Function<State,Object>(){
        public Object apply(        State nextState){
          h.propagate(new PointerKeyAndState(writtenPk,nextState));
          return null;
        }
      }
);
    }
  }
}",0.1856444945509207
100045,"public Object apply(State nextState){
  propagate(new PointerKeyAndState(retVal,nextState));
  return null;
}","public Object apply(State nextState){
  h.propagate(new PointerKeyAndState(succPk,nextState));
  return null;
}",0.9363636363636364
100046,"private void computeFlowsTo(PointsToComputer ptoComputer,OrdinalSet<InstanceKeyAndState> basePToSet,IField field){
  for (  InstanceKeyAndState ikAndState : basePToSet) {
    ptoComputer.trackInstanceField(ikAndState,field,ptoComputer.forwInstKeyToFields);
  }
  ptoComputer.worklistLoop();
}","private void computeFlowsTo(PointsToComputer ptoComputer,OrdinalSet<InstanceKeyAndState> basePToSet){
}",0.5215189873417722
100047,"@Override public void visitAssign(AssignLabel label,Object dst){
  final PointerKey predPk=(PointerKey)dst;
  doTransition(curState,AssignBarLabel.noFilter(),new Function<State,Object>(){
    public Object apply(    State predPkState){
      PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
      if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
        addToTrackedPToWorklist(predPkAndState);
      }
      return null;
    }
  }
);
}","@Override public void visitAssign(AssignLabel label,Object dst){
  final PointerKey succPk=(PointerKey)dst;
  doTransition(curState,label,new Function<State,Object>(){
    public Object apply(    State nextState){
      h.propagate(new PointerKeyAndState(succPk,nextState));
      return null;
    }
  }
);
}",0.4408060453400503
100048,"private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  while (s.available() > 0) {
    byte[] data=new byte[s.available()];
    int nRead=s.read(data);
    b.write(data,0,nRead);
  }
}","private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      int nRead=s.read(data);
      b.write(data,0,nRead);
    }
  }
 catch (  IOException e) {
  }
}",0.8831683168316832
100049,"private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  while (s.available() > 0) {
    byte[] data=new byte[s.available()];
    s.read(data);
    p.print(new String(data));
  }
}","private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      s.read(data);
      p.print(new String(data));
    }
  }
 catch (  IOException e) {
  }
}",0.8752642706131079
100050,"public Iterator<? extends T> getReturnSites(T c){
  return delegate.getCallSites(c);
}","public Iterator<? extends T> getReturnSites(T c,P callee){
  return delegate.getCallSites(c,callee);
}",0.9148936170212766
100051,"public Iterator<? extends T> getCallSites(T r){
  return delegate.getReturnSites(r);
}","public Iterator<? extends T> getCallSites(T r,P callee){
  return delegate.getReturnSites(r,callee);
}",0.9148936170212766
100052,"/** 
 * @return the blocks in the supergraph that represents exit nodes forprocedure p
 */
T[] getExitsForProcedure(P procedure);","/** 
 * @return the blocks in the supergraph that represents exit nodes for procedure p
 */
T[] getExitsForProcedure(P procedure);",0.996138996138996
100053,"/** 
 * @param call a ""call"" node in the supergraph
 * @return an Iterator of nodes that are normal (non-call) successors of thiscall. This should only apply to backwards problems, where we might have, say, a call and a goto flow into a return site.
 */
Iterator<T> getNormalSuccessors(T call);","/** 
 * @param call a ""call"" node in the supergraph
 * @return an Iterator of nodes that are normal (non-call) successors of this call. This should only apply tobackwards problems, where we might have, say, a call and a goto flow into a return site.
 */
Iterator<T> getNormalSuccessors(T call);",0.9965986394557824
100054,"/** 
 * @param call a ""call"" node in the supergraph
 * @return the corresponding return nodes. There may be many, because ofexceptional control flow.
 */
Iterator<? extends T> getReturnSites(T call);","/** 
 * @param call a ""call"" node in the supergraph
 * @param callee a ""called"" ""procedure"" in the supergraph.  if callee is null, answer return sites for which no callee was found.
 * @return the corresponding return nodes. There may be many, because of exceptional control flow.
 */
Iterator<? extends T> getReturnSites(T call,P callee);",0.7397769516728625
100055,"/** 
 * @param r a ""return"" node in the supergraph
 * @return the corresponding call nodes. There may be many.
 */
Iterator<? extends T> getCallSites(T r);","/** 
 * @param r a ""return"" node in the supergraph
 * @param callee a ""called"" ""procedure"" in the supergraph.  if callee is null, answer return sites for which no callee was found.
 * @return the corresponding call nodes. There may be many.
 */
Iterator<? extends T> getCallSites(T ret,P callee);",0.6873614190687362
100056,"/** 
 * @return the blocks in the supergraph that represents entry nodes forprocedure p
 */
T[] getEntriesForProcedure(P procedure);","/** 
 * @return the blocks in the supergraph that represents entry nodes for procedure p
 */
T[] getEntriesForProcedure(P procedure);",0.9962264150943396
100057,"@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getReturnSites(Object object){
  if (object instanceof BasicBlockInContext) {
    return partialIPFG.getReturnSites((BasicBlockInContext)object);
  }
 else {
    CGNode n=nodeManager.getProcOfCollapsedNode(object);
    return new NonNullSingletonIterator<CollapsedNode>(nodeManager.getCollapsedExit(n));
  }
}","@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getReturnSites(Object object,CGNode callee){
  if (object instanceof BasicBlockInContext) {
    return partialIPFG.getReturnSites((BasicBlockInContext)object);
  }
 else {
    CGNode n=nodeManager.getProcOfCollapsedNode(object);
    return new NonNullSingletonIterator<CollapsedNode>(nodeManager.getCollapsedExit(n));
  }
}",0.9819121447028424
100058,"/** 
 * This could be done more efficiently.
 */
private void computeTransverseEdges(){
  for (  BasicBlockInContext<ISSABasicBlock> bb : partialIPFG) {
    if (partialIPFG.hasCall(bb)) {
      Set targets=partialIPFG.getCallTargets(bb);
      for (Iterator it2=targets.iterator(); it2.hasNext(); ) {
        CGNode n=(CGNode)it2.next();
        if (!noCollapse.contains(n)) {
          Object s_n=nodeManager.getCollapsedEntry(n);
          Set<Object> incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,s_n);
          incoming.add(bb);
          Set<Object> outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,bb);
          outgoing.add(s_n);
          Object e_n=nodeManager.getCollapsedExit(n);
          for (Iterator returnSites=getReturnSites(bb); returnSites.hasNext(); ) {
            Object ret=returnSites.next();
            Set<Object> in=MapUtil.findOrCreateSet(incomingTransverseEdges,ret);
            in.add(e_n);
            Set<Object> out=MapUtil.findOrCreateSet(outgoingTransverseEdges,e_n);
            out.add(ret);
          }
        }
      }
    }
  }
  for (Iterator it=nodeManager.iterateCollapsedNodes(); it.hasNext(); ) {
    Object n=it.next();
    if (!nodeManager.isCollapsedEntry(n)) {
      continue;
    }
    CGNode node=nodeManager.getProcOfCollapsedNode(n);
    for (Iterator it2=cg.getSuccNodes(node); it2.hasNext(); ) {
      CGNode outNode=(CGNode)it2.next();
      if (noCollapse.contains(outNode)) {
        ControlFlowGraph<ISSABasicBlock> cfg=partialIPFG.getCFG(outNode);
        BasicBlockInContext<ISSABasicBlock> entry=new BasicBlockInContext<ISSABasicBlock>(outNode,cfg.entry());
        Set<Object> incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,entry);
        incoming.add(n);
        Set<Object> outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,n);
        outgoing.add(entry);
        BasicBlockInContext<ISSABasicBlock> exit=new BasicBlockInContext<ISSABasicBlock>(outNode,cfg.exit());
        Object retSite=nodeManager.getCollapsedExit(node);
        incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,retSite);
        incoming.add(exit);
        outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,exit);
        outgoing.add(retSite);
      }
    }
  }
}","/** 
 * This could be done more efficiently.
 */
private void computeTransverseEdges(){
  for (  BasicBlockInContext<ISSABasicBlock> bb : partialIPFG) {
    if (partialIPFG.hasCall(bb)) {
      Set targets=partialIPFG.getCallTargets(bb);
      for (Iterator it2=targets.iterator(); it2.hasNext(); ) {
        CGNode n=(CGNode)it2.next();
        if (!noCollapse.contains(n)) {
          Object s_n=nodeManager.getCollapsedEntry(n);
          Set<Object> incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,s_n);
          incoming.add(bb);
          Set<Object> outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,bb);
          outgoing.add(s_n);
          Object e_n=nodeManager.getCollapsedExit(n);
          for (Iterator returnSites=getReturnSites(bb,n); returnSites.hasNext(); ) {
            Object ret=returnSites.next();
            Set<Object> in=MapUtil.findOrCreateSet(incomingTransverseEdges,ret);
            in.add(e_n);
            Set<Object> out=MapUtil.findOrCreateSet(outgoingTransverseEdges,e_n);
            out.add(ret);
          }
        }
      }
    }
  }
  for (Iterator it=nodeManager.iterateCollapsedNodes(); it.hasNext(); ) {
    Object n=it.next();
    if (!nodeManager.isCollapsedEntry(n)) {
      continue;
    }
    CGNode node=nodeManager.getProcOfCollapsedNode(n);
    for (Iterator it2=cg.getSuccNodes(node); it2.hasNext(); ) {
      CGNode outNode=(CGNode)it2.next();
      if (noCollapse.contains(outNode)) {
        ControlFlowGraph<ISSABasicBlock> cfg=partialIPFG.getCFG(outNode);
        BasicBlockInContext<ISSABasicBlock> entry=new BasicBlockInContext<ISSABasicBlock>(outNode,cfg.entry());
        Set<Object> incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,entry);
        incoming.add(n);
        Set<Object> outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,n);
        outgoing.add(entry);
        BasicBlockInContext<ISSABasicBlock> exit=new BasicBlockInContext<ISSABasicBlock>(outNode,cfg.exit());
        Object retSite=nodeManager.getCollapsedExit(node);
        incoming=MapUtil.findOrCreateSet(incomingTransverseEdges,retSite);
        incoming.add(exit);
        outgoing=MapUtil.findOrCreateSet(outgoingTransverseEdges,exit);
        outgoing.add(retSite);
      }
    }
  }
}",0.9995573262505534
100059,"@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getSuccNodes(Object N){
  if (N instanceof IBasicBlock) {
    Set<Object> xverse=outgoingTransverseEdges.get(N);
    if (xverse == null) {
      return partialIPFG.getSuccNodes((BasicBlockInContext)N);
    }
 else {
      return new CompoundIterator<Object>(partialIPFG.getSuccNodes((BasicBlockInContext)N),xverse.iterator());
    }
  }
 else {
    if (isEntry(N)) {
      Set<Object> result=HashSetFactory.make(4);
      CGNode n=nodeManager.getProcOfCollapsedNode(N);
      for (Iterator it=cg.getSuccNodes(n); it.hasNext(); ) {
        CGNode s=(CGNode)it.next();
        if (!noCollapse.contains(s)) {
          result.add(nodeManager.getCollapsedEntry(s));
        }
      }
      result.add(nodeManager.getCollapsedExit(n));
      Set<Object> xverse=outgoingTransverseEdges.get(N);
      if (xverse != null) {
        result.addAll(xverse);
      }
      return result.iterator();
    }
 else {
      CGNode n=nodeManager.getProcOfCollapsedNode(N);
      Object entry=nodeManager.getCollapsedEntry(n);
      HashSet<Object> result=HashSetFactory.make(4);
      for (Iterator it=getPredNodes(entry); it.hasNext(); ) {
        Object callSite=it.next();
        for (Iterator returnSites=getReturnSites(callSite); returnSites.hasNext(); ) {
          result.add(returnSites.next());
        }
      }
      return result.iterator();
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getSuccNodes(Object N){
  if (N instanceof IBasicBlock) {
    Set<Object> xverse=outgoingTransverseEdges.get(N);
    if (xverse == null) {
      return partialIPFG.getSuccNodes((BasicBlockInContext)N);
    }
 else {
      return new CompoundIterator<Object>(partialIPFG.getSuccNodes((BasicBlockInContext)N),xverse.iterator());
    }
  }
 else {
    if (isEntry(N)) {
      Set<Object> result=HashSetFactory.make(4);
      CGNode n=nodeManager.getProcOfCollapsedNode(N);
      for (Iterator it=cg.getSuccNodes(n); it.hasNext(); ) {
        CGNode s=(CGNode)it.next();
        if (!noCollapse.contains(s)) {
          result.add(nodeManager.getCollapsedEntry(s));
        }
      }
      result.add(nodeManager.getCollapsedExit(n));
      Set<Object> xverse=outgoingTransverseEdges.get(N);
      if (xverse != null) {
        result.addAll(xverse);
      }
      return result.iterator();
    }
 else {
      CGNode n=nodeManager.getProcOfCollapsedNode(N);
      Object entry=nodeManager.getCollapsedEntry(n);
      HashSet<Object> result=HashSetFactory.make(4);
      for (Iterator it=getPredNodes(entry); it.hasNext(); ) {
        Object callSite=it.next();
        for (Iterator returnSites=getReturnSites(callSite,n); returnSites.hasNext(); ) {
          result.add(returnSites.next());
        }
      }
      return result.iterator();
    }
  }
}",0.9992957746478872
100060,"@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getCallSites(Object object){
  if (object instanceof BasicBlockInContext) {
    return partialIPFG.getCallSites((BasicBlockInContext<ISSABasicBlock>)object);
  }
 else {
    CGNode n=nodeManager.getProcOfCollapsedNode(object);
    return new NonNullSingletonIterator<CollapsedNode>(nodeManager.getCollapsedEntry(n));
  }
}","@SuppressWarnings(""String_Node_Str"") public Iterator<? extends Object> getCallSites(Object object,CGNode callee){
  if (object instanceof BasicBlockInContext) {
    return partialIPFG.getCallSites((BasicBlockInContext<ISSABasicBlock>)object,callee);
  }
 else {
    CGNode n=nodeManager.getProcOfCollapsedNode(object);
    return new NonNullSingletonIterator<CollapsedNode>(nodeManager.getCollapsedEntry(n));
  }
}",0.9739776951672864
100061,"/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 */
private void propagateToReturnSites(final PathEdge<T> edge,IntSet succ,final T c,final IntSet D4){
  if (DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + succ);
    for (IntIterator it=succ.intIterator(); it.hasNext(); ) {
      int x=it.next();
      System.err.println(""String_Node_Str"" + x + ""String_Node_Str""+ supergraph.getNode(x));
    }
  }
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!succ.contains(supergraph.getNumber(retSite))) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        public void act(        final int d4){
          if (D5 != null) {
            D5.foreach(new IntSetAction(){
              public void act(              final int d5){
                for (int i=0; i < entries.length; i++) {
                  final T s_p=entries[i];
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + s_p);
                  }
                  IntSet D3=getInversePathEdges(s_p,c,d4);
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + D3);
                  }
                  if (D3 != null) {
                    D3.foreach(new IntSetAction(){
                      public void act(                      int d3){
                        propagate(s_p,d3,retSite,d5);
                      }
                    }
);
                  }
                }
              }
            }
);
          }
        }
      }
;
      D4.foreach(action);
    }
  }
}","/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 */
private void propagateToReturnSites(final PathEdge<T> edge,IntSet succ,final T c,final IntSet D4){
  if (DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + succ);
    for (IntIterator it=succ.intIterator(); it.hasNext(); ) {
      int x=it.next();
      System.err.println(""String_Node_Str"" + x + ""String_Node_Str""+ supergraph.getNode(x));
    }
  }
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c,supergraph.getProcOf(edge.target)); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!succ.contains(supergraph.getNumber(retSite))) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        public void act(        final int d4){
          if (D5 != null) {
            D5.foreach(new IntSetAction(){
              public void act(              final int d5){
                for (int i=0; i < entries.length; i++) {
                  final T s_p=entries[i];
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + s_p);
                  }
                  IntSet D3=getInversePathEdges(s_p,c,d4);
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + D3);
                  }
                  if (D3 != null) {
                    D3.foreach(new IntSetAction(){
                      public void act(                      int d3){
                        propagate(s_p,d3,retSite,d5);
                      }
                    }
);
                  }
                }
              }
            }
);
          }
        }
      }
;
      D4.foreach(action);
    }
  }
}",0.9939501779359432
100062,"/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
protected void processCall(final PathEdge<T> edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  final int c=supergraph.getNumber(edge.target);
  final Collection<T> returnSites=Iterator2Collection.toCollection(supergraph.getReturnSites(edge.target));
  for (Iterator<? extends T> it=supergraph.getCalledNodes(edge.target); it.hasNext(); ) {
    final T callee=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + callee);
    }
    MutableSparseIntSet reached=MutableSparseIntSet.makeEmpty();
    for (    final T returnSite : returnSites) {
      IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.target,callee,returnSite);
      IntSet r=computeFlow(edge.d2,f);
      if (r != null) {
        reached.addAll(r);
      }
    }
    IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.target,callee,null);
    IntSet r=computeFlow(edge.d2,f);
    if (r != null) {
      reached.addAll(r);
    }
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      final LocalSummaryEdges summaries=summaryEdges.get(supergraph.getProcOf(callee));
      final CallFlowEdges callFlow=findOrCreateCallFlowEdges(callee);
      final int s_p_num=supergraph.getLocalBlockNumber(callee);
      reached.foreach(new IntSetAction(){
        public void act(        final int d1){
          propagate(callee,d1,callee,d1);
          callFlow.addCallEdge(c,edge.d2,d1);
          if (summaries != null) {
            P p=supergraph.getProcOf(callee);
            T[] exits=supergraph.getExitsForProcedure(p);
            for (int e=0; e < exits.length; e++) {
              T exit=exits[e];
              if (DEBUG_LEVEL > 0 && Assertions.verifyAssertions) {
                Assertions._assert(supergraph.containsNode(exit));
              }
              for (Iterator<? extends T> succ=supergraph.getSuccNodes(exit); succ.hasNext(); ) {
                final T returnSite=succ.next();
                if (returnSites.contains(returnSite)) {
                  int x_num=supergraph.getLocalBlockNumber(exit);
                  IntSet reachedBySummary=summaries.getSummaryEdges(s_p_num,x_num,d1);
                  if (reachedBySummary != null) {
                    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(edge.target,exit,returnSite);
                    reachedBySummary.foreach(new IntSetAction(){
                      public void act(                      int d2){
                        if (retf instanceof IBinaryReturnFlowFunction) {
                          final IntSet D5=computeBinaryFlow(edge.d2,d2,(IBinaryReturnFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.entry,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
 else {
                          final IntSet D5=computeFlow(d2,(IUnaryFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.entry,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
                      }
                    }
);
                  }
                }
              }
            }
          }
        }
      }
);
    }
  }
  for (Iterator<? extends T> it=supergraph.getNormalSuccessors(edge.target); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.target,m);
    IntSet D3=computeFlow(edge.d2,f);
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        public void act(        int d3){
          propagate(edge.entry,edge.d1,m,d3);
        }
      }
);
    }
  }
  for (  final T returnSite : returnSites) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + returnSite);
    }
    IUnaryFlowFunction f=null;
    if (hasCallee(returnSite)) {
      f=flowFunctionMap.getCallToReturnFlowFunction(edge.target,returnSite);
    }
 else {
      f=flowFunctionMap.getCallNoneToReturnFlowFunction(edge.target,returnSite);
    }
    IntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      reached.foreach(new IntSetAction(){
        public void act(        int x){
          if (Assertions.verifyAssertions) {
            Assertions._assert(x >= 0);
            Assertions._assert(edge.d1 >= 0);
          }
          propagate(edge.entry,edge.d1,returnSite,x);
        }
      }
);
    }
  }
}","/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
protected void processCall(final PathEdge<T> edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  final int c=supergraph.getNumber(edge.target);
  Collection<T> allReturnSites=HashSetFactory.make();
  allReturnSites.addAll(Iterator2Collection.toCollection(supergraph.getReturnSites(edge.target,null)));
  for (Iterator<? extends T> it=supergraph.getCalledNodes(edge.target); it.hasNext(); ) {
    final T callee=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + callee);
    }
    MutableSparseIntSet reached=MutableSparseIntSet.makeEmpty();
    final Collection<T> returnSites=Iterator2Collection.toCollection(supergraph.getReturnSites(edge.target,supergraph.getProcOf(callee)));
    allReturnSites.addAll(returnSites);
    for (    final T returnSite : returnSites) {
      IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.target,callee,returnSite);
      IntSet r=computeFlow(edge.d2,f);
      if (r != null) {
        reached.addAll(r);
      }
    }
    IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.target,callee,null);
    IntSet r=computeFlow(edge.d2,f);
    if (r != null) {
      reached.addAll(r);
    }
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      final LocalSummaryEdges summaries=summaryEdges.get(supergraph.getProcOf(callee));
      final CallFlowEdges callFlow=findOrCreateCallFlowEdges(callee);
      final int s_p_num=supergraph.getLocalBlockNumber(callee);
      reached.foreach(new IntSetAction(){
        public void act(        final int d1){
          propagate(callee,d1,callee,d1);
          callFlow.addCallEdge(c,edge.d2,d1);
          if (summaries != null) {
            P p=supergraph.getProcOf(callee);
            T[] exits=supergraph.getExitsForProcedure(p);
            for (int e=0; e < exits.length; e++) {
              T exit=exits[e];
              if (DEBUG_LEVEL > 0 && Assertions.verifyAssertions) {
                Assertions._assert(supergraph.containsNode(exit));
              }
              for (Iterator<? extends T> succ=supergraph.getSuccNodes(exit); succ.hasNext(); ) {
                final T returnSite=succ.next();
                if (returnSites.contains(returnSite)) {
                  int x_num=supergraph.getLocalBlockNumber(exit);
                  IntSet reachedBySummary=summaries.getSummaryEdges(s_p_num,x_num,d1);
                  if (reachedBySummary != null) {
                    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(edge.target,exit,returnSite);
                    reachedBySummary.foreach(new IntSetAction(){
                      public void act(                      int d2){
                        if (retf instanceof IBinaryReturnFlowFunction) {
                          final IntSet D5=computeBinaryFlow(edge.d2,d2,(IBinaryReturnFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.entry,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
 else {
                          final IntSet D5=computeFlow(d2,(IUnaryFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.entry,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
                      }
                    }
);
                  }
                }
              }
            }
          }
        }
      }
);
    }
  }
  for (Iterator<? extends T> it=supergraph.getNormalSuccessors(edge.target); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.target,m);
    IntSet D3=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + D3);
    }
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        public void act(        int d3){
          propagate(edge.entry,edge.d1,m,d3);
        }
      }
);
    }
  }
  for (  final T returnSite : allReturnSites) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + returnSite);
    }
    IUnaryFlowFunction f=null;
    if (hasCallee(returnSite)) {
      f=flowFunctionMap.getCallToReturnFlowFunction(edge.target,returnSite);
    }
 else {
      f=flowFunctionMap.getCallNoneToReturnFlowFunction(edge.target,returnSite);
    }
    IntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      reached.foreach(new IntSetAction(){
        public void act(        int x){
          if (Assertions.verifyAssertions) {
            Assertions._assert(x >= 0);
            Assertions._assert(edge.d1 >= 0);
          }
          propagate(edge.entry,edge.d1,returnSite,x);
        }
      }
);
    }
  }
}",0.9689172692271576
100063,"/** 
 * Check to see if a particular call site should be bypassed, before checking normal resolution of the receiver.
 * @throws IllegalArgumentException if site is null
 */
public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass dispatchType){
  if (site == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MethodReference ref=site.getDeclaredTarget();
  IMethod resolved=null;
  if (ClassHierarchyMethodTargetSelector.feasibleChaResolution(cha,site,dispatchType)) {
    if (site.isVirtual() || site.isInterface()) {
      if (dispatchType != null) {
        resolved=cha.resolveMethod(dispatchType,ref.getSelector());
      }
    }
 else {
      IClass computedDispatchType=cha.lookupClass(site.getDeclaredTarget().getDeclaringClass());
      if (computedDispatchType != null) {
        resolved=cha.resolveMethod(computedDispatchType,ref.getSelector());
      }
    }
  }
  IMethod target=(resolved == null) ? findOrCreateSyntheticMethod(ref,site.isStatic()) : getBypassInternal(resolved,site.isStatic());
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + target);
  }
  if (target != null) {
    return target;
  }
 else {
    if (canIgnore(site.getDeclaredTarget())) {
      if (DEBUG)       System.err.println(""String_Node_Str"" + site);
      return null;
    }
    target=parent.getCalleeTarget(caller,site,dispatchType);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + target);
    }
    if (target != null) {
      IMethod bypassTarget=getBypassInternal(target,site.isStatic());
      if (DEBUG)       System.err.println(""String_Node_Str"" + target);
      return (bypassTarget == null) ? target : bypassTarget;
    }
 else     return target;
  }
}","/** 
 * Check to see if a particular call site should be bypassed, before checking normal resolution of the receiver.
 * @throws IllegalArgumentException if site is null
 */
public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass dispatchType){
  if (site == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MethodReference ref=site.getDeclaredTarget();
  IMethod resolved=null;
  if (ClassHierarchyMethodTargetSelector.feasibleChaResolution(cha,site,dispatchType)) {
    if (site.isVirtual() || site.isInterface()) {
      if (dispatchType != null) {
        resolved=cha.resolveMethod(dispatchType,ref.getSelector());
      }
    }
 else {
      IClass computedDispatchType=cha.lookupClass(site.getDeclaredTarget().getDeclaringClass());
      if (computedDispatchType != null) {
        resolved=cha.resolveMethod(computedDispatchType,ref.getSelector());
      }
    }
  }
  IMethod target=(resolved == null) ? findOrCreateSyntheticMethod(ref,site.isStatic()) : getBypassInternal(resolved,site.isStatic());
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + target);
  }
  if (target != null) {
    return target;
  }
 else {
    if (canIgnore(site.getDeclaredTarget())) {
      return findOrCreateSyntheticMethod(site.getDeclaredTarget(),site.isStatic());
    }
    target=parent.getCalleeTarget(caller,site,dispatchType);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + target);
    }
    if (target != null) {
      IMethod bypassTarget=getBypassInternal(target,site.isStatic());
      if (DEBUG)       System.err.println(""String_Node_Str"" + target);
      return (bypassTarget == null) ? target : bypassTarget;
    }
 else     return target;
  }
}",0.8516579406631762
100064,"/** 
 * A debugging aid. TODO: move this elsewhere
 */
public static void clearSoftCaches(){
  float occupancy=1f - ((float)Runtime.getRuntime().freeMemory() / (float)Runtime.getRuntime().totalMemory());
  if (occupancy < OCCUPANCY_TRIGGER) {
    return;
  }
  if (getAnalysisCache() != null) {
    getAnalysisCache().getSSACache().wipe();
    getAnalysisCache().getCFGCache().wipe();
  }
  IClassHierarchy cha=getClassHierarchy();
  if (cha != null) {
    for (    IClass klass : cha) {
      if (klass instanceof ShrikeClass) {
        ShrikeClass c=(ShrikeClass)klass;
        c.clearSoftCaches();
      }
 else {
        for (Iterator it2=klass.getDeclaredMethods().iterator(); it2.hasNext(); ) {
          IMethod m=(IMethod)it2.next();
          if (m instanceof ShrikeCTMethod) {
            ((ShrikeCTMethod)m).clearCaches();
          }
        }
      }
    }
  }
}","/** 
 * A debugging aid. TODO: move this elsewhere
 */
public static void clearSoftCaches(){
  float occupancy=1f - ((float)Runtime.getRuntime().freeMemory() / (float)Runtime.getRuntime().totalMemory());
  if (occupancy < OCCUPANCY_TRIGGER) {
    return;
  }
  AnalysisCache cache=getAnalysisCache();
  if (cache != null) {
    cache.getSSACache().wipe();
    cache.getCFGCache().wipe();
  }
  IClassHierarchy cha=getClassHierarchy();
  if (cha != null) {
    for (    IClass klass : cha) {
      if (klass instanceof ShrikeClass) {
        ShrikeClass c=(ShrikeClass)klass;
        c.clearSoftCaches();
      }
 else {
        for (Iterator it2=klass.getDeclaredMethods().iterator(); it2.hasNext(); ) {
          IMethod m=(IMethod)it2.next();
          if (m instanceof ShrikeCTMethod) {
            ((ShrikeCTMethod)m).clearCaches();
          }
        }
      }
    }
  }
}",0.9469480889903024
100065,"/** 
 * @return the IClass that represents the array element type, or null if theelement type is a primitive
 */
public IClass getElementClass(){
  TypeReference elementType=getReference().getArrayElementType();
  if (elementType.isPrimitiveType()) {
    return null;
  }
  return loader.lookupClass(elementType.getName());
}","/** 
 * @return the IClass that represents the array element type, or null if the element type is a primitive
 */
public IClass getElementClass(){
  TypeReference elementType=getReference().getArrayElementType();
  if (elementType.isPrimitiveType()) {
    return null;
  }
  return loader.lookupClass(elementType.getName());
}",0.998463901689708
100066,"/** 
 * @return the IClass that represents the innermost array element type, ornull if the element type is a primitive
 */
public IClass getInnermostElementClass(){
  TypeReference elementType=getReference().getInnermostElementType();
  if (elementType.isPrimitiveType()) {
    return null;
  }
  return loader.lookupClass(elementType.getName());
}","/** 
 * @return the IClass that represents the innermost array element type, or null if the element type is a primitive
 */
public IClass getInnermostElementClass(){
  TypeReference elementType=getReference().getInnermostElementType();
  if (elementType.isPrimitiveType()) {
    return null;
  }
  return loader.lookupClass(elementType.getName());
}",0.9985652797704448
100067,"public Collection<IClass> getAllImplementedInterfaces(){
  HashSet<IClass> result=HashSetFactory.make(2);
  result.add(loader.lookupClass(TypeReference.array_interfaces[0]));
  result.add(loader.lookupClass(TypeReference.array_interfaces[1]));
  return result;
}","public Collection<IClass> getAllImplementedInterfaces(){
  HashSet<IClass> result=HashSetFactory.make(2);
  IClass klass=loader.lookupClass(TypeReference.array_interfaces[0]);
  if (klass != null) {
    result.add(klass);
  }
  klass=loader.lookupClass(TypeReference.array_interfaces[1]);
  if (klass != null) {
    result.add(klass);
  }
  return result;
}",0.6946688206785138
100068,"public Iterator<PointerKey> getReadsOfInstanceField(PointerKey pk,IField f){
  if (f == ArrayContents.v()) {
    return getArrayReads(pk);
  }
  Collection<MemoryAccess> reads=mam.getFieldReads(pk,f);
  for (  MemoryAccess a : reads) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> readInto=new ArrayList<PointerKey>();
  for (  MemoryAccess a : reads) {
    IR ir=a.getNode().getIR();
    SSAGetInstruction s=(SSAGetInstruction)ir.getInstructions()[a.getInstructionIndex()];
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getDef());
    readInto.add(r);
  }
  return readInto.iterator();
}","public Iterator<PointerKey> getReadsOfInstanceField(PointerKey pk,IField f){
  if (f == ArrayContents.v()) {
    return getArrayReads(pk);
  }
  Collection<MemoryAccess> reads=mam.getFieldReads(pk,f);
  for (  MemoryAccess a : reads) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> readInto=new ArrayList<PointerKey>();
  for (  MemoryAccess a : reads) {
    IR ir=a.getNode().getIR();
    SSAGetInstruction s=(SSAGetInstruction)ir.getInstructions()[a.getInstructionIndex()];
    if (s == null) {
      continue;
    }
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getDef());
    readInto.add(r);
  }
  return readInto.iterator();
}",0.9667440061871616
100069,"protected Iterator<PointerKey> getArrayReads(PointerKey arrayRef){
  Collection<MemoryAccess> arrayReads=mam.getArrayReads(arrayRef);
  for (Iterator<MemoryAccess> it=arrayReads.iterator(); it.hasNext(); ) {
    MemoryAccess a=it.next();
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> read=new ArrayList<PointerKey>();
  for (Iterator<MemoryAccess> it=arrayReads.iterator(); it.hasNext(); ) {
    MemoryAccess a=it.next();
    IR ir=a.getNode().getIR();
    SSAArrayLoadInstruction s=(SSAArrayLoadInstruction)ir.getInstructions()[a.getInstructionIndex()];
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getDef());
    read.add(r);
  }
  return read.iterator();
}","protected Iterator<PointerKey> getArrayReads(PointerKey arrayRef){
  Collection<MemoryAccess> arrayReads=mam.getArrayReads(arrayRef);
  for (Iterator<MemoryAccess> it=arrayReads.iterator(); it.hasNext(); ) {
    MemoryAccess a=it.next();
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> read=new ArrayList<PointerKey>();
  for (Iterator<MemoryAccess> it=arrayReads.iterator(); it.hasNext(); ) {
    MemoryAccess a=it.next();
    IR ir=a.getNode().getIR();
    SSAArrayLoadInstruction s=(SSAArrayLoadInstruction)ir.getInstructions()[a.getInstructionIndex()];
    if (s == null) {
      continue;
    }
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getDef());
    read.add(r);
  }
  return read.iterator();
}",0.9700348432055748
100070,"private void init(Graph<T> G,Iterator<? extends T> nodes){
  this.G=G;
  while (nodes.hasNext()) {
    T o=nodes.next();
    if (!visited.contains(o)) {
      Q.add(o);
      visited.add(o);
    }
  }
  index=0;
  T current=Q.get(0);
  visitChildren(current);
}","private void init(Graph<T> G,Iterator<? extends T> nodes){
  this.G=G;
  while (nodes.hasNext()) {
    T o=nodes.next();
    if (!visited.contains(o)) {
      Q.add(o);
      visited.add(o);
    }
  }
  index=0;
  if (Q.size() > 0) {
    T current=Q.get(0);
    visitChildren(current);
  }
}",0.9420289855072465
100071,"public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(node.getContext() instanceof JavaTypeContext))   return false;
  return node.getMethod().getReference().equals(CLASS_NEW_INSTANCE_REF);
}","public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(node.getContext() instanceof JavaTypeContext)) {
    return false;
  }
  return node.getMethod().getReference().equals(CLASS_NEW_INSTANCE_REF);
}",0.9854545454545456
100072,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (callee.getReference().equals(ClassNewInstanceContextInterpreter.CLASS_NEW_INSTANCE_REF) && isTypeConstant(receiver)) {
    IClass c=(IClass)((ConstantKey)receiver).getValue();
    return new JavaTypeContext(new PointType(c));
  }
  return null;
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (callee.getReference().equals(ClassNewInstanceContextInterpreter.CLASS_NEW_INSTANCE_REF) && isTypeConstant(receiver)) {
    IClass c=(IClass)((ConstantKey)receiver).getValue();
    if (!c.isAbstract() && !c.isInterface()) {
      return new JavaTypeContext(new PointType(c));
    }
  }
  return null;
}",0.9286640726329444
100073,"/** 
 * Set up a method summary which allocates and returns an instance of concrete type T.
 * @param T
 */
private void addStatementsForConcreteType(final TypeReference T){
  int alloc=addStatementsForConcreteSimpleType(T);
  if (alloc == -1) {
    return;
  }
  if (T.isArrayType()) {
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=alloc;
    int exc=getExceptionsForType(T);
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
    calls.add(s);
    allInstructions.add(s);
  }
 else {
  }
}","/** 
 * Set up a method summary which allocates and returns an instance of concrete type T.
 * @param T
 */
private void addStatementsForConcreteType(final TypeReference T){
  int alloc=addStatementsForConcreteSimpleType(T);
  if (alloc == -1) {
    return;
  }
  if (T.isArrayType()) {
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=alloc;
    int exc=getExceptionsForType(T);
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
    calls.add(s);
    allInstructions.add(s);
  }
}",0.9917920656634748
100074,"private void addStatementsForSetOfTypes(Iterator it){
  if (!it.hasNext()) {
    SSAReturnInstruction r=new SSAReturnInstruction(nextLocal,false);
    allInstructions.add(r);
  }
  for (; it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    TypeReference T=klass.getReference();
    if (klass.isAbstract() || typesAllocated.contains(T)) {
      continue;
    }
    typesAllocated.add(T);
    int i=getLocalForType(T);
    NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
    SSANewInstruction a=null;
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      initValueNumberForConstantOne();
      Arrays.fill(sizes,valueNumberForConstantOne);
      a=new SSANewInstruction(i,ref,sizes);
    }
 else {
      a=new SSANewInstruction(i,ref);
    }
    allocations.add(a);
    allInstructions.add(a);
    SSAReturnInstruction r=new SSAReturnInstruction(i,false);
    allInstructions.add(r);
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=i;
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,getExceptionsForType(T),site);
    calls.add(s);
    allInstructions.add(s);
  }
}","private void addStatementsForSetOfTypes(Iterator it){
  if (!it.hasNext()) {
    SSAReturnInstruction r=new SSAReturnInstruction(nextLocal,false);
    allInstructions.add(r);
  }
  for (; it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    TypeReference T=klass.getReference();
    if (klass.isAbstract() || klass.isInterface() || typesAllocated.contains(T)) {
      continue;
    }
    typesAllocated.add(T);
    int i=getLocalForType(T);
    NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
    SSANewInstruction a=null;
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      initValueNumberForConstantOne();
      Arrays.fill(sizes,valueNumberForConstantOne);
      a=new SSANewInstruction(i,ref,sizes);
    }
 else {
      a=new SSANewInstruction(i,ref);
    }
    allocations.add(a);
    allInstructions.add(a);
    SSAReturnInstruction r=new SSAReturnInstruction(i,false);
    allInstructions.add(r);
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=i;
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,getExceptionsForType(T),site);
    calls.add(s);
    allInstructions.add(s);
  }
}",0.9915781764921274
100075,"/** 
 * Private constructor ... only for internal use.
 * @throws IllegalArgumentException if type is null
 */
public PointType(IClass type){
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.type=type;
  if (Assertions.verifyAssertions) {
    Assertions._assert(type.getReference().isReferenceType());
  }
}","/** 
 * Private constructor ... only for internal use.
 * @throws IllegalArgumentException if type is null
 */
public PointType(IClass type){
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.type=type;
  if (Assertions.verifyAssertions) {
    Assertions._assert(type.getReference().isReferenceType());
    Assertions._assert(!type.isInterface());
  }
}",0.9395973154362416
100076,"public void map(Object astType,CAstType castType){
  fMap.put(astType,castType);
}","@SuppressWarnings(""String_Node_Str"") public void map(Object astType,CAstType castType){
  fMap.put(astType,castType);
}",0.8159203980099502
100077,"/** 
 * TODO: clean this up. Create the IR for the synthetic method (e.g. Method.invoke)
 * @param method is something like Method.invoke or Construction.newInstance
 * @param target is the method being called reflectively
 */
private IR makeIR(IMethod method,IMethod target,ReceiverInstanceContext context){
  SpecializedMethod m=new SpecializedMethod(method,method.getDeclaringClass(),method.isStatic(),false);
  Map<Integer,ConstantValue> constants=HashMapFactory.make();
  int nextLocal=method.getNumberOfParameters() + 1;
  int nargs=target.getNumberOfParameters();
  int args[]=new int[nargs];
  int i=0;
  int pc=0;
  int parametersVn=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    TypeReference allocatedType=target.getDeclaringClass().getReference();
    m.addInstruction(allocatedType,new SSANewInstruction(args[i++]=nextLocal++,NewSiteReference.make(pc++,allocatedType)),true);
    parametersVn=2;
  }
 else {
    parametersVn=3;
    if (target.isStatic()) {
    }
 else {
      args[i++]=2;
    }
  }
  for (int j=i; j < nargs; j++) {
    int indexConst=nextLocal++;
    m.addInstruction(null,new SSAArrayLoadInstruction(args[i++]=nextLocal++,parametersVn,indexConst,TypeReference.JavaLangObject),false);
    constants.put(new Integer(indexConst),new ConstantValue(j - 1));
    pc++;
  }
  int exceptions=nextLocal++;
  int result=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),IInvokeInstruction.Dispatch.SPECIAL)),false);
    m.addInstruction(null,new SSAReturnInstruction(args[0],false),false);
  }
 else {
    Dispatch d=target.isStatic() ? Dispatch.STATIC : Dispatch.VIRTUAL;
    if (target.getReturnType().equals(TypeReference.Void)) {
      m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
    }
 else {
      result=nextLocal++;
      m.addInstruction(null,new SSAInvokeInstruction(result,args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
      m.addInstruction(null,new SSAReturnInstruction(result,false),false);
    }
  }
  SSAInstruction[] instrs=new SSAInstruction[m.allInstructions.size()];
  m.allInstructions.<SSAInstruction>toArray(instrs);
  return new SyntheticIR(method,context,new InducedCFG(instrs,method,context),instrs,SSAOptions.defaultOptions(),constants);
}","/** 
 * TODO: clean this up. Create the IR for the synthetic method (e.g. Method.invoke)
 * @param method is something like Method.invoke or Construction.newInstance
 * @param target is the method being called reflectively
 */
private IR makeIR(IMethod method,IMethod target,ReceiverInstanceContext context){
  SpecializedMethod m=new SpecializedMethod(method,method.getDeclaringClass(),method.isStatic(),false);
  Map<Integer,ConstantValue> constants=HashMapFactory.make();
  int nextLocal=method.getNumberOfParameters() + 1;
  int nargs=target.getNumberOfParameters();
  int args[]=new int[nargs];
  int pc=0;
  int parametersVn=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    TypeReference allocatedType=target.getDeclaringClass().getReference();
    m.addInstruction(allocatedType,new SSANewInstruction(args[0]=nextLocal++,NewSiteReference.make(pc++,allocatedType)),true);
    parametersVn=2;
  }
 else {
    parametersVn=3;
    if (target.isStatic()) {
    }
 else {
      args[0]=2;
    }
  }
  int nextArg=target.isStatic() ? 0 : 1;
  int nextParameter=0;
  for (int j=nextArg; j < nargs; j++) {
    int indexConst=nextLocal++;
    constants.put(new Integer(indexConst),new ConstantValue(nextParameter++));
    int temp=nextLocal++;
    m.addInstruction(null,new SSAArrayLoadInstruction(temp,parametersVn,indexConst,TypeReference.JavaLangObject),false);
    pc++;
    args[j]=nextLocal++;
    TypeReference type=target.getParameterType(j);
    SSACheckCastInstruction cast=SSAInstructionFactory.CheckCastInstruction(args[j],temp,type);
    m.addInstruction(null,cast,false);
    pc++;
  }
  int exceptions=nextLocal++;
  int result=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),IInvokeInstruction.Dispatch.SPECIAL)),false);
    m.addInstruction(null,new SSAReturnInstruction(args[0],false),false);
  }
 else {
    Dispatch d=target.isStatic() ? Dispatch.STATIC : Dispatch.VIRTUAL;
    if (target.getReturnType().equals(TypeReference.Void)) {
      m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
    }
 else {
      result=nextLocal++;
      m.addInstruction(null,new SSAInvokeInstruction(result,args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
      m.addInstruction(null,new SSAReturnInstruction(result,false),false);
    }
  }
  SSAInstruction[] instrs=new SSAInstruction[m.allInstructions.size()];
  m.allInstructions.<SSAInstruction>toArray(instrs);
  return new SyntheticIR(method,context,new InducedCFG(instrs,method,context),instrs,SSAOptions.defaultOptions(),constants);
}",0.9061837796185706
100078,"Iterator<PointerKey> getArrayWrites(PointerKey arrayRef){
  Collection<MemoryAccess> arrayWrites=mam.getArrayWrites(arrayRef);
  for (  MemoryAccess a : arrayWrites) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : arrayWrites) {
    final CGNode node=a.getNode();
    IR ir=node.getIR();
    SSAInstruction instruction=ir.getInstructions()[a.getInstructionIndex()];
    if (instruction == null) {
      continue;
    }
    if (instruction instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction s=(SSAArrayStoreInstruction)instruction;
      PointerKey r=heapModel.getPointerKeyForLocal(node,s.getValue());
      written.add(r);
    }
 else     if (instruction instanceof SSANewInstruction) {
      SSANewInstruction n=(SSANewInstruction)instruction;
      InstanceKey iKey=heapModel.getInstanceKeyForAllocation(node,n.getNewSite());
      IClass klass=iKey.getConcreteType();
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass.isArrayClass() && ((ArrayClass)klass).getElementClass().isArrayClass());
      }
      int dim=0;
      InstanceKey lastInstance=iKey;
      while (klass != null && klass.isArrayClass()) {
        klass=((ArrayClass)klass).getElementClass();
        if (klass != null && klass.isArrayClass()) {
          InstanceKey ik=heapModel.getInstanceKeyForMultiNewArray(node,n.getNewSite(),dim);
          PointerKey pk=heapModel.getPointerKeyForArrayContents(lastInstance);
          written.add(pk);
          lastInstance=ik;
          dim++;
        }
      }
    }
 else {
      Assertions.UNREACHABLE();
    }
  }
  return written.iterator();
}","Iterator<PointerKey> getArrayWrites(PointerKey arrayRef){
  Collection<MemoryAccess> arrayWrites=mam.getArrayWrites(arrayRef);
  for (  MemoryAccess a : arrayWrites) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : arrayWrites) {
    final CGNode node=a.getNode();
    IR ir=node.getIR();
    SSAInstruction instruction=ir.getInstructions()[a.getInstructionIndex()];
    if (instruction == null) {
      continue;
    }
    if (instruction instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction s=(SSAArrayStoreInstruction)instruction;
      PointerKey r=heapModel.getPointerKeyForLocal(node,s.getValue());
      written.add(r);
    }
 else     if (instruction instanceof SSANewInstruction) {
      SSANewInstruction n=(SSANewInstruction)instruction;
      InstanceKey iKey=heapModel.getInstanceKeyForAllocation(node,n.getNewSite());
      if (iKey == null) {
        continue;
      }
      IClass klass=iKey.getConcreteType();
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass.isArrayClass() && ((ArrayClass)klass).getElementClass().isArrayClass());
      }
      int dim=0;
      InstanceKey lastInstance=iKey;
      while (klass != null && klass.isArrayClass()) {
        klass=((ArrayClass)klass).getElementClass();
        if (klass != null && klass.isArrayClass()) {
          InstanceKey ik=heapModel.getInstanceKeyForMultiNewArray(node,n.getNewSite(),dim);
          PointerKey pk=heapModel.getPointerKeyForArrayContents(lastInstance);
          written.add(pk);
          lastInstance=ik;
          dim++;
        }
      }
    }
 else {
      Assertions.UNREACHABLE();
    }
  }
  return written.iterator();
}",0.9848308051341892
100079,"public Iterator<PointerKey> getWritesToInstanceField(PointerKey pk,IField f){
  if (f == ArrayContents.v()) {
    return getArrayWrites(pk);
  }
  Collection<MemoryAccess> writes=mam.getFieldWrites(pk,f);
  for (  MemoryAccess a : writes) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : writes) {
    IR ir=a.getNode().getIR();
    SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[a.getInstructionIndex()];
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getVal());
    written.add(r);
  }
  return written.iterator();
}","public Iterator<PointerKey> getWritesToInstanceField(PointerKey pk,IField f){
  if (f == ArrayContents.v()) {
    return getArrayWrites(pk);
  }
  Collection<MemoryAccess> writes=mam.getFieldWrites(pk,f);
  for (  MemoryAccess a : writes) {
    addSubgraphForNode(a.getNode());
  }
  ArrayList<PointerKey> written=new ArrayList<PointerKey>();
  for (  MemoryAccess a : writes) {
    IR ir=a.getNode().getIR();
    SSAPutInstruction s=(SSAPutInstruction)ir.getInstructions()[a.getInstructionIndex()];
    if (s == null) {
      continue;
    }
    PointerKey r=heapModel.getPointerKeyForLocal(a.getNode(),s.getVal());
    written.add(r);
  }
  return written.iterator();
}",0.9668976135488836
100080,"@Override protected MachineState makeEdgeVariable(BasicBlock from,BasicBlock to){
  if (Assertions.verifyAssertions) {
    Assertions._assert(from != null);
    Assertions._assert(to != null);
  }
  MachineState result=new MachineState(71167 * (from.hashCode() + to.hashCode()),from);
  return result;
}","@Override protected MachineState makeEdgeVariable(BasicBlock from,BasicBlock to){
  if (Assertions.verifyAssertions) {
    Assertions._assert(from != null);
    Assertions._assert(to != null);
  }
  MachineState result=new MachineState(71167 * from.hashCode() + to.hashCode(),from);
  return result;
}",0.9966887417218544
100081,"protected void visitInvokeInternal(SSAAbstractInvokeInstruction instruction){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  if (instruction.getCallSite().isStatic()) {
    CGNode n=getTargetForCall(node,instruction.getCallSite(),(InstanceKey)null);
    if (n == null) {
      Warnings.add(ResolutionFailure.create(node,instruction));
    }
 else {
      getBuilder().processResolvedCall(node,instruction,n,computeInvariantParameters(instruction),uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    PointerKey receiver=getPointerKeyForLocal(instruction.getReceiver());
    if (contentsAreInvariant(symbolTable,du,instruction.getReceiver())) {
      system.recordImplicitPointsToSet(receiver);
      InstanceKey[] ik=getInvariantContents(instruction.getReceiver());
      for (int i=0; i < ik.length; i++) {
        system.findOrCreateIndexForInstanceKey(ik[i]);
        CGNode n=getTargetForCall(node,instruction.getCallSite(),ik[i]);
        if (n == null) {
          Warnings.add(ResolutionFailure.create(node,instruction));
        }
 else {
          getBuilder().processResolvedCall(node,instruction,n,computeInvariantParameters(instruction),uniqueCatch);
          processClassInitializer(n.getMethod().getDeclaringClass());
        }
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ receiver);
      }
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,computeInvariantParameters(instruction),uniqueCatch);
      system.newSideEffect(dispatchOperator,receiver);
    }
  }
}","protected void visitInvokeInternal(SSAAbstractInvokeInstruction instruction){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  if (instruction.getCallSite().isStatic()) {
    CGNode n=getTargetForCall(node,instruction.getCallSite(),(InstanceKey)null);
    if (n == null) {
      Warnings.add(ResolutionFailure.create(node,instruction.getCallSite()));
    }
 else {
      getBuilder().processResolvedCall(node,instruction,n,computeInvariantParameters(instruction),uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    PointerKey receiver=getPointerKeyForLocal(instruction.getReceiver());
    if (contentsAreInvariant(symbolTable,du,instruction.getReceiver())) {
      system.recordImplicitPointsToSet(receiver);
      InstanceKey[] ik=getInvariantContents(instruction.getReceiver());
      for (int i=0; i < ik.length; i++) {
        system.findOrCreateIndexForInstanceKey(ik[i]);
        CGNode n=getTargetForCall(node,instruction.getCallSite(),ik[i]);
        if (n == null) {
          Warnings.add(ResolutionFailure.create(node,instruction));
        }
 else {
          getBuilder().processResolvedCall(node,instruction,n,computeInvariantParameters(instruction),uniqueCatch);
          processClassInitializer(n.getMethod().getDeclaringClass());
        }
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ receiver);
      }
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,computeInvariantParameters(instruction),uniqueCatch);
      system.newSideEffect(dispatchOperator,receiver);
    }
  }
}",0.9963312368972748
100082,"/** 
 * Create nodes corresponding to <ul> <li> phi instructions <li> getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir,Collection<SSAInstruction> visited){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s != null && !visited.contains(s)) {
      visited.add(s);
      if (s instanceof SSAPhiInstruction) {
        delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
      }
 else       if (s instanceof SSAGetCaughtExceptionInstruction) {
        delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
      }
 else       if (s instanceof SSAPiInstruction) {
        delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
      }
 else {
        Assertions.UNREACHABLE(s.toString());
      }
    }
  }
}","/** 
 * Create nodes corresponding to <ul> <li> phi instructions <li> getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAPhiInstruction) {
      delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
    }
 else     if (s instanceof SSAGetCaughtExceptionInstruction) {
      delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
    }
 else     if (s instanceof SSAPiInstruction) {
      delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
    }
  }
}",0.581913499344692
100083,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref,ir);
    }
  }
  return visited;
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private void createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref,ir);
    }
  }
}",0.8981191222570533
100084,"/** 
 * Create all nodes in this PDG. Each node is a Statement.
 */
private void createNodes(Map<CGNode,OrdinalSet<PointerKey>> ref,ControlDependenceOptions cOptions,IR ir){
  if (ir != null) {
    Collection<SSAInstruction> visited=createNormalStatements(ir,ref);
    createSpecialStatements(ir,visited);
  }
  createCalleeParams(ref);
  createReturnStatements();
  delegate.addNode(new MethodEntryStatement(node));
  delegate.addNode(new MethodExitStatement(node));
}","/** 
 * Create all nodes in this PDG. Each node is a Statement.
 */
private void createNodes(Map<CGNode,OrdinalSet<PointerKey>> ref,ControlDependenceOptions cOptions,IR ir){
  if (ir != null) {
    createNormalStatements(ir,ref);
    createSpecialStatements(ir);
  }
  createCalleeParams(ref);
  createReturnStatements();
  delegate.addNode(new MethodEntryStatement(node));
  delegate.addNode(new MethodExitStatement(node));
}",0.9519553072625698
100085,"private ResolutionFailure(CGNode node,Object ref){
  this(node,ref,null);
}","private ResolutionFailure(CGNode node,T ref){
  this(node,ref,null);
}",0.9517241379310344
100086,"@Override public int hashCode(){
  return getMethod().hashCode() * 8999 + ref.hashCode() * 8461 + getLevel();
}","@Override public int hashCode(){
  final int prime=31;
  int result=super.hashCode();
  result=prime * result + ((message == null) ? 0 : message.hashCode());
  result=prime * result + ((ref == null) ? 0 : ref.hashCode());
  return result;
}",0.4045584045584046
100087,"@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass().equals(obj.getClass())) {
    ResolutionFailure other=(ResolutionFailure)obj;
    return (getMethod().equals(other.getMethod()) && getLevel() == other.getLevel() && ref.equals(other.ref));
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!super.equals(obj))   return false;
  if (getClass() != obj.getClass())   return false;
  final ResolutionFailure other=(ResolutionFailure)obj;
  if (message == null) {
    if (other.message != null)     return false;
  }
 else   if (!message.equals(other.message))   return false;
  if (ref == null) {
    if (other.ref != null)     return false;
  }
 else   if (!ref.equals(other.ref))   return false;
  return true;
}",0.2829736211031175
100088,"public static ResolutionFailure create(CGNode node,Object ref,String msg) throws IllegalArgumentException {
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new ResolutionFailure(node,ref,msg);
}","public static <T>ResolutionFailure create(CGNode node,T ref){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new ResolutionFailure<T>(node,ref);
}",0.859122401847575
100089,"@Override public int hashCode(){
  return method.hashCode();
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((declaringClass == null) ? 0 : declaringClass.hashCode());
  result=prime * result + ((method == null) ? 0 : method.hashCode());
  return result;
}",0.3192182410423452
100090,"@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass().equals(obj.getClass())) {
    SyntheticMethod other=(SyntheticMethod)obj;
    return (method.equals(other.method));
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  final SyntheticMethod other=(SyntheticMethod)obj;
  if (declaringClass == null) {
    if (other.declaringClass != null)     return false;
  }
 else   if (!declaringClass.equals(other.declaringClass))   return false;
  if (method == null) {
    if (other.method != null)     return false;
  }
 else   if (!method.equals(other.method))   return false;
  return true;
}",0.4151898734177215
100091,"private SSAInstruction[] makeStatements(JavaTypeContext context){
  ArrayList<SSAInstruction> statements=new ArrayList<SSAInstruction>();
  int nextLocal=1;
  int retValue=nextLocal++;
  TypeReference tr=context.getType().getTypeReference();
  if (tr != null) {
    SSALoadClassInstruction l=new SSALoadClassInstruction(retValue,tr);
    statements.add(l);
    SSAReturnInstruction R=new SSAReturnInstruction(retValue,false);
    statements.add(R);
  }
 else {
    SSAThrowInstruction t=new SSAThrowInstruction(retValue);
    statements.add(t);
  }
  SSAInstruction[] result=new SSAInstruction[statements.size()];
  Iterator<SSAInstruction> it=statements.iterator();
  for (int i=0; i < result.length; i++) {
    result[i]=it.next();
  }
  return result;
}","private SSAInstruction[] makeStatements(JavaTypeContext context){
  ArrayList<SSAInstruction> statements=new ArrayList<SSAInstruction>();
  int retValue=2;
  TypeReference tr=context.getType().getTypeReference();
  if (tr != null) {
    SSALoadClassInstruction l=new SSALoadClassInstruction(retValue,tr);
    statements.add(l);
    SSAReturnInstruction R=new SSAReturnInstruction(retValue,false);
    statements.add(R);
  }
 else {
    SSAThrowInstruction t=new SSAThrowInstruction(retValue);
    statements.add(t);
  }
  SSAInstruction[] result=new SSAInstruction[statements.size()];
  statements.toArray(result);
  return result;
}",0.8610511159107271
100092,"@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else {
    if (rhs instanceof PointType) {
      PointType other=(PointType)rhs;
      if (type.equals(other.type)) {
        return this;
      }
 else       if (type.isArrayClass() || other.type.isArrayClass()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
 else {
        return new ConeType(type.getClassHierarchy().getLeastCommonSuperclass(this.type,other.type));
      }
    }
 else     if (rhs instanceof ConeType) {
      ConeType other=(ConeType)rhs;
      TypeReference T=other.getType().getReference();
      if (type.isArrayClass() || T.isArrayType()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
      IClass typeKlass=type;
      if (type.getClassHierarchy().isSubclassOf(typeKlass,other.getType())) {
        return other;
      }
 else       if (other.isInterface()) {
        if (type.getClassHierarchy().implementsInterface(typeKlass,other.getType())) {
          return other;
        }
      }
      return other.meet(new ConeType(other.getType()));
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + rhs.getClass());
      return null;
    }
  }
}","@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else {
    if (rhs instanceof PointType) {
      PointType other=(PointType)rhs;
      if (type.equals(other.type)) {
        return this;
      }
 else       if (type.isArrayClass() || other.type.isArrayClass()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
 else {
        return new ConeType(type.getClassHierarchy().getLeastCommonSuperclass(this.type,other.type));
      }
    }
 else     if (rhs instanceof ConeType) {
      ConeType other=(ConeType)rhs;
      TypeReference T=other.getType().getReference();
      if (type.isArrayClass() || T.isArrayType()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
      IClass typeKlass=type;
      if (type.getClassHierarchy().isSubclassOf(typeKlass,other.getType())) {
        return other;
      }
 else       if (other.isInterface()) {
        if (type.getClassHierarchy().implementsInterface(typeKlass,other.getType())) {
          return other;
        }
      }
      return other.meet(new ConeType(this.getType()));
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + rhs.getClass());
      return null;
    }
  }
}",0.9964014394242304
100093,"/** 
 * Does c implement i?
 * @return true iff i is an interface and c is a class that implements i, r cis an interface that extends i.
 */
public boolean implementsInterface(IClass c,IClass i){
  if (!i.isInterface()) {
    return false;
  }
  Set impls=implementors.get(i);
  if (impls != null && impls.contains(c)) {
    return true;
  }
  return false;
}","/** 
 * Does c implement i?
 * @return true iff i is an interface and c is a class that implements i, r c is an interface that extends i.
 */
public boolean implementsInterface(IClass c,IClass i){
  if (!i.isInterface()) {
    return false;
  }
  if (c.equals(i)) {
    return true;
  }
  Set impls=implementors.get(i);
  if (impls != null && impls.contains(c)) {
    return true;
  }
  return false;
}",0.9434954007884364
100094,"/** 
 * Get the targets for a method ref invoked on a class klass. The klass had better not be an interface.
 * @param ref method to invoke
 * @param klass declaringClass of receiver
 * @return Set the set of method implementations that might receive themessage
 */
private Set<IMethod> computeTargetsNotInterface(MethodReference ref,IClass klass){
  Node n=findNode(klass);
  HashSet<IMethod> result=HashSetFactory.make(3);
  if (n == null)   return result;
  Selector selector=ref.getSelector();
  IMethod resolved=resolveMethod(klass,selector);
  if (resolved != null) {
    result.add(resolved);
  }
  result.addAll(computeOverriders(n,selector));
  return result;
}","/** 
 * Get the targets for a method ref invoked on a class klass. The klass had better not be an interface.
 * @param ref method to invoke
 * @param klass declaringClass of receiver
 * @return Set the set of method implementations that might receive the message
 */
private Set<IMethod> computeTargetsNotInterface(MethodReference ref,IClass klass){
  Node n=findNode(klass);
  HashSet<IMethod> result=HashSetFactory.make(3);
  if (n == null)   return result;
  Selector selector=ref.getSelector();
  IMethod resolved=resolveMethod(klass,selector);
  if (resolved != null) {
    result.add(resolved);
  }
  result.addAll(computeOverriders(n,selector));
  return result;
}",0.999254287844892
100095,"/** 
 * Is c a subclass of T?
 * @throws IllegalArgumentException if c is null
 */
public boolean isSubclassOf(IClass c,IClass T){
  if (c == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    Assertions._assert(T != null,""String_Node_Str"");
  }
  if (c.isArrayClass()) {
    if (T.getReference() == TypeReference.JavaLangObject) {
      return true;
    }
 else     if (T.getReference().isArrayType()) {
      TypeReference elementType=T.getReference().getArrayElementType();
      if (elementType.isPrimitiveType()) {
        return elementType.equals(c.getReference().getArrayElementType());
      }
 else {
        IClass elementKlass=lookupClass(elementType);
        if (elementKlass == null) {
          Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + elementType));
          return false;
        }
        IClass ce=((ArrayClass)c).getElementClass();
        if (ce == null) {
          return false;
        }
        return isSubclassOf(ce,elementKlass);
      }
    }
 else {
      return false;
    }
  }
 else {
    if (T.getReference().isArrayType()) {
      return false;
    }
    if (c.getReference().equals(T.getReference())) {
      return true;
    }
    Node n1=map.get(c);
    if (n1 == null) {
      return false;
    }
    Node n2=map.get(T);
    if (n2 == null) {
      return false;
    }
    if (n1.left == -1) {
      return slowIsSubclass(c,T);
    }
 else     if (n2.left == -1) {
      return slowIsSubclass(c,T);
    }
 else {
      return (n2.left <= n1.left) && (n1.left <= n2.right);
    }
  }
}","/** 
 * Is c a subclass of T?
 * @throws IllegalArgumentException if c is null
 */
public boolean isSubclassOf(IClass c,IClass T){
  if (c == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    Assertions._assert(T != null,""String_Node_Str"");
  }
  if (c.isArrayClass()) {
    if (T.getReference() == TypeReference.JavaLangObject) {
      return true;
    }
 else     if (T.getReference().isArrayType()) {
      TypeReference elementType=T.getReference().getArrayElementType();
      if (elementType.isPrimitiveType()) {
        return elementType.equals(c.getReference().getArrayElementType());
      }
 else {
        IClass elementKlass=lookupClass(elementType);
        if (elementKlass == null) {
          Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + elementType));
          return false;
        }
        IClass ce=((ArrayClass)c).getElementClass();
        if (ce == null) {
          return false;
        }
        if (elementKlass.isInterface()) {
          return implementsInterface(ce,elementKlass);
        }
 else {
          return isSubclassOf(ce,elementKlass);
        }
      }
    }
 else {
      return false;
    }
  }
 else {
    if (T.getReference().isArrayType()) {
      return false;
    }
    if (c.getReference().equals(T.getReference())) {
      return true;
    }
    Node n1=map.get(c);
    if (n1 == null) {
      return false;
    }
    Node n2=map.get(T);
    if (n2 == null) {
      return false;
    }
    if (n1.left == -1) {
      return slowIsSubclass(c,T);
    }
 else     if (n2.left == -1) {
      return slowIsSubclass(c,T);
    }
 else {
      return (n2.left <= n1.left) && (n1.left <= n2.right);
    }
  }
}",0.961987428913499
100096,"/** 
 * @return the canonical IField that represents a given field , or null ifnone found
 * @throws IllegalArgumentException if f is null
 * @throws IllegalArgumentException if klass is null
 */
public IField resolveField(IClass klass,FieldReference f){
  if (klass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return klass.getField(f.getName());
}","/** 
 * @return the canonical IField that represents a given field , or null if none found
 * @throws IllegalArgumentException if f is null
 * @throws IllegalArgumentException if klass is null
 */
public IField resolveField(IClass klass,FieldReference f){
  if (klass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return klass.getField(f.getName());
}",0.9989189189189188
100097,"/** 
 * Compute a set of <n, d1> pairs that represent return statement factoids that should be considered reached in a partially balanced parentheses tabulation. We assume that the given   {@link TabulationResult} represents a solution to a fully balanced tabulation. We look atany exit statements that were reached, and compute the corresponding return factoids that could be reached, if we ignored parentheses. We return the set of such factoids, which represent roots to restart tabulation with.
 */
public static <T,P>Collection<Pair<T,Integer>> computeNewSeeds(TabulationResult<T,P> tabulation,PartiallyBalancedTabulationProblem<T,P> problem){
  Collection<Pair<T,Integer>> result=HashSetFactory.make();
  ISupergraph<T,P> supergraph=tabulation.getProblem().getSupergraph();
  for (  PathEdge<T> entry : tabulation.getSeeds()) {
    for (    T exit : supergraph.getExitsForProcedure(supergraph.getProcOf(entry.getEntry()))) {
      IntSet reached=tabulation.getSummaryTargets(entry.getEntry(),entry.getD1(),exit);
      if (reached != null) {
        for (IntIterator it=reached.intIterator(); it.hasNext(); ) {
          int d2=it.next();
          for (Iterator<? extends T> it2=supergraph.getSuccNodes(exit); it2.hasNext(); ) {
            T retSite=it2.next();
            IFlowFunction f=problem.getFunctionMap().getUnbalancedReturnFlowFunction(exit,retSite);
            if (f instanceof IUnaryFlowFunction) {
              IUnaryFlowFunction uf=(IUnaryFlowFunction)f;
              IntSet facts=uf.getTargets(d2);
              for (IntIterator it4=facts.intIterator(); it4.hasNext(); ) {
                int d3=it4.next();
                result.add(Pair.make(retSite,d3));
              }
            }
 else {
              Assertions.UNREACHABLE(""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  return result;
}","/** 
 * Compute a set of <n, d1> pairs that represent return statement factoids that should be considered reached in a partially balanced parentheses tabulation. We assume that the given   {@link TabulationResult} represents a solution to a fully balanced tabulation. We look atany exit statements that were reached, and compute the corresponding return factoids that could be reached, if we ignored parentheses. We return the set of such factoids, which represent roots to restart tabulation with.
 */
public static <T,P>Collection<Pair<T,Integer>> computeNewSeeds(TabulationResult<T,P> tabulation,PartiallyBalancedTabulationProblem<T,P> problem){
  Collection<Pair<T,Integer>> result=HashSetFactory.make();
  ISupergraph<T,P> supergraph=tabulation.getProblem().getSupergraph();
  for (  PathEdge<T> entry : tabulation.getSeeds()) {
    for (    T exit : supergraph.getExitsForProcedure(supergraph.getProcOf(entry.getEntry()))) {
      IntSet reached=tabulation.getSummaryTargets(entry.getEntry(),entry.getD1(),exit);
      if (reached != null) {
        for (IntIterator it=reached.intIterator(); it.hasNext(); ) {
          int d2=it.next();
          for (Iterator<? extends T> it2=supergraph.getSuccNodes(exit); it2.hasNext(); ) {
            T retSite=it2.next();
            IFlowFunction f=problem.getFunctionMap().getUnbalancedReturnFlowFunction(exit,retSite);
            if (f instanceof IUnaryFlowFunction) {
              IUnaryFlowFunction uf=(IUnaryFlowFunction)f;
              IntSet facts=uf.getTargets(d2);
              if (facts != null) {
                for (IntIterator it4=facts.intIterator(); it4.hasNext(); ) {
                  int d3=it4.next();
                  result.add(Pair.make(retSite,d3));
                }
              }
            }
 else {
              Assertions.UNREACHABLE(""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  return result;
}",0.9843376692328112
100098,"/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  Collection<IClass> c=HashSetFactory.make();
  for (  IClass klass : klasses) {
    if (klass.isArrayClass()) {
      c.add(klass);
    }
 else     if (this.klasses.contains(klass)) {
      c.add(klass);
    }
  }
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(c);
  return result;
}","/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  Collection<IClass> c=HashSetFactory.make();
  for (  IClass klass : klasses) {
    if (klass.isArrayClass()) {
      TypeReference elementType=klass.getReference().getArrayElementType();
      if (elementType.isPrimitiveType()) {
        c.add(klass);
      }
 else {
        c.add(klass.getClassHierarchy().lookupClass(TypeReference.JavaLangObject.getArrayTypeForElementType()));
      }
    }
 else     if (this.klasses.contains(klass)) {
      c.add(klass);
    }
  }
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(c);
  return result;
}",0.8306288032454361
100099,"/** 
 * Add any methods that look like they might be DispatchAction targets, based on the method signature. TODO: instead, parse the struts xml directly.
 * @param klass an Action
 */
private void addSpeculativeDispatchMethods(IClass klass,IClassHierarchy cha){
  IClass C=klass;
  while (C != null) {
    for (Iterator<IMethod> it=C.getDeclaredMethods().iterator(); it.hasNext(); ) {
      IMethod M=(IMethod)it.next();
      Descriptor D=M.getDescriptor();
      if (D.equals(executeDesc) || D.equals(httpExecuteDesc)) {
        MethodReference m=MethodReference.findOrCreate(klass.getReference(),M.getName(),M.getDescriptor());
        entrypoints.put(m,new StrutsActionEntrypoint(C,M,cha));
      }
    }
    try {
      C=C.getSuperclass();
    }
 catch (    ClassHierarchyException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","/** 
 * Add any methods that look like they might be DispatchAction targets, based on the method signature. TODO: instead, parse the struts xml directly.
 * @param klass an Action
 */
private void addSpeculativeDispatchMethods(IClass klass,IClassHierarchy cha){
  IClass c=klass;
  while (c != null) {
    for (Iterator<IMethod> it=c.getDeclaredMethods().iterator(); it.hasNext(); ) {
      IMethod M=(IMethod)it.next();
      Descriptor D=M.getDescriptor();
      if (D.equals(executeDesc) || D.equals(httpExecuteDesc)) {
        MethodReference m=MethodReference.findOrCreate(klass.getReference(),M.getName(),M.getDescriptor());
        entrypoints.put(m,new StrutsActionEntrypoint(klass,M,cha));
      }
    }
    try {
      c=c.getSuperclass();
    }
 catch (    ClassHierarchyException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9907514450867052
100100,"public static boolean isConcreteStrutsPlugIn(IClass klass){
  TypeReference plugInType=TypeReference.findOrCreate(ClassLoaderReference.Application,plugInName);
  IClass plugInClass=klass.getClassHierarchy().lookupClass(plugInType);
  if (klass.isAbstract()) {
    return false;
  }
  if (klass.getReference().equals(plugInType)) {
    return false;
  }
  if (klass.getClassHierarchy().isAssignableFrom(plugInClass,klass)) {
    return true;
  }
  return false;
}","public static boolean isConcreteStrutsPlugIn(IClass klass){
  TypeReference plugInType=TypeReference.findOrCreate(ClassLoaderReference.Application,plugInName);
  IClass plugInClass=klass.getClassHierarchy().lookupClass(plugInType);
  if (plugInClass == null) {
    return false;
  }
  if (klass.isAbstract()) {
    return false;
  }
  if (klass.getReference().equals(plugInType)) {
    return false;
  }
  if (klass.getClassHierarchy().isAssignableFrom(plugInClass,klass)) {
    return true;
  }
  return false;
}",0.9476923076923076
100101,"protected CGNode makeFakeRootNode(){
  return findOrCreateNode(new JSFakeRoot(cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}","protected CGNode makeFakeRootNode() throws CancelException {
  return findOrCreateNode(new JSFakeRoot(cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}",0.9183673469387756
100102,"protected CGNode makeFakeRootNode(){
  return findOrCreateNode(new AstFakeRoot(FakeRootMethod.rootMethod,cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}","protected CGNode makeFakeRootNode() throws CancelException {
  return findOrCreateNode(new AstFakeRoot(FakeRootMethod.rootMethod,cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}",0.9310344827586208
100103,"protected CGNode makeFakeRootNode(){
  return findOrCreateNode(new CrossLanguageFakeRoot(cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}","protected CGNode makeFakeRootNode() throws CancelException {
  return findOrCreateNode(new CrossLanguageFakeRoot(cha,options,getAnalysisCache()),Everywhere.EVERYWHERE);
}",0.9240506329113924
100104,"@SuppressWarnings(""String_Node_Str"") public AbstractRootMethod getLanguageRoot(Atom language){
  if (!languageRoots.containsKey(language)) {
    AbstractRootMethod languageRoot=roots.get(language,this);
    CGNode languageRootNode=findOrCreateNode(languageRoot,Everywhere.EVERYWHERE);
    languageRootNodes.add(languageRootNode);
    CallSiteReference site=CallSiteReference.make(1,languageRoot.getReference(),IInvokeInstruction.Dispatch.STATIC);
    CGNode fakeRootNode=getFakeRootNode();
    CrossLanguageFakeRoot fakeRootMethod=(CrossLanguageFakeRoot)fakeRootNode.getMethod();
    site=fakeRootMethod.addInvocationInternal(new int[0],site).getCallSite();
    fakeRootNode.addTarget(site,languageRootNode);
    languageRoots.put(language,languageRoot);
  }
  return (AbstractRootMethod)languageRoots.get(language);
}","@SuppressWarnings(""String_Node_Str"") public AbstractRootMethod getLanguageRoot(Atom language){
  if (!languageRoots.containsKey(language)) {
    AbstractRootMethod languageRoot=roots.get(language,this);
    CGNode languageRootNode=null;
    try {
      languageRootNode=findOrCreateNode(languageRoot,Everywhere.EVERYWHERE);
    }
 catch (    CancelException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
    languageRootNodes.add(languageRootNode);
    CallSiteReference site=CallSiteReference.make(1,languageRoot.getReference(),IInvokeInstruction.Dispatch.STATIC);
    CGNode fakeRootNode=getFakeRootNode();
    CrossLanguageFakeRoot fakeRootMethod=(CrossLanguageFakeRoot)fakeRootNode.getMethod();
    site=fakeRootMethod.addInvocationInternal(new int[0],site).getCallSite();
    fakeRootNode.addTarget(site,languageRootNode);
    languageRoots.put(language,languageRoot);
  }
  return (AbstractRootMethod)languageRoots.get(language);
}",0.9196177627880832
100105,"/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
@SuppressWarnings(""String_Node_Str"") private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,String fileExtension) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,fileExtension);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      Set<Module> s=MapUtil.findOrCreateSet(binaryModules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    File file=makeAbsolute(e.getPath()).toFile();
    Set<Module> s=MapUtil.findOrCreateSet(sourceModules,Loader.SOURCE);
    s.add(new SourceDirectoryTreeModule(file,fileExtension));
    if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      s=MapUtil.findOrCreateSet(binaryModules,loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,fileExtension);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        Set<Module> s=MapUtil.findOrCreateSet(binaryModules,loader);
        s.add(new BinaryDirectoryTreeModule(output));
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}","/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
@SuppressWarnings(""String_Node_Str"") private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,String fileExtension) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,fileExtension);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
catch (    FileNotFoundException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      Set<Module> s=MapUtil.findOrCreateSet(binaryModules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    File file=makeAbsolute(e.getPath()).toFile();
    Set<Module> s=MapUtil.findOrCreateSet(sourceModules,Loader.SOURCE);
    s.add(new SourceDirectoryTreeModule(file,fileExtension));
    if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      s=MapUtil.findOrCreateSet(binaryModules,loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,fileExtension);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        Set<Module> s=MapUtil.findOrCreateSet(binaryModules,loader);
        s.add(new BinaryDirectoryTreeModule(output));
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}",0.9886939571150096
100106,"protected void addCtorInvokeInstruction(final TypeReference T,int alloc){
  MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
  CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
  int[] params=new int[1];
  params[0]=alloc;
  int exc=getExceptionsForType(T);
  SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
  calls.add(s);
  allInstructions.add(s);
}","/** 
 * Add an instruction to invoke the default constructor on the object of value number alloc of type t.
 */
protected void addCtorInvokeInstruction(final TypeReference t,int alloc){
  MethodReference init=MethodReference.findOrCreate(t,MethodReference.initAtom,MethodReference.defaultInitDesc);
  CallSiteReference site=CallSiteReference.make(getCallSiteForType(t),init,IInvokeInstruction.Dispatch.SPECIAL);
  int[] params=new int[1];
  params[0]=alloc;
  int exc=getExceptionsForType(t);
  SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
  calls.add(s);
  allInstructions.add(s);
}",0.8905109489051095
100107,"/** 
 * @param T
 * @return value number of the newly allocated object
 */
protected int addStatementsForConcreteSimpleType(final TypeReference T){
}","/** 
 * @param t type of object to allocate
 * @return value number of the newly allocated object
 */
protected int addStatementsForConcreteSimpleType(final TypeReference t){
}",0.9046153846153846
100108,"/** 
 * Set up a method summary which allocates and returns an instance of concrete type T.
 * @param T
 */
private void addStatementsForConcreteType(final TypeReference T){
  int alloc=addStatementsForConcreteSimpleType(T);
  if (alloc == -1) {
    return;
  }
  if (T.isArrayType()) {
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=alloc;
    int exc=getExceptionsForType(T);
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
    calls.add(s);
    allInstructions.add(s);
  }
}","/** 
 * Set up a method summary which allocates and returns an instance of concrete type T.
 * @param T
 */
private void addStatementsForConcreteType(final TypeReference T){
  int alloc=addStatementsForConcreteSimpleType(T);
  if (alloc == -1) {
    return;
  }
  if (T.isArrayType()) {
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=alloc;
    int exc=getExceptionsForType(T);
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,exc,site);
    calls.add(s);
    allInstructions.add(s);
  }
 else {
  }
}",0.9917920656634748
100109,"/** 
 * TODO: clean this up.
 */
private IR makeIR(IMethod method,IMethod target,ReceiverInstanceContext context){
  SpecializedMethod m=new SpecializedMethod(method,method.getDeclaringClass(),method.isStatic(),false);
  Map<Integer,ConstantValue> constants=HashMapFactory.make();
  int nextLocal=method.getNumberOfParameters() + 1;
  int nargs=target.getNumberOfParameters();
  int args[]=new int[nargs];
  int i=0;
  int pc=0;
  int parametersVn=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    TypeReference allocatedType=target.getDeclaringClass().getReference();
    m.addInstruction(allocatedType,new SSANewInstruction(args[i++]=nextLocal++,NewSiteReference.make(pc++,allocatedType)),true);
    parametersVn=2;
  }
 else {
    args[i++]=2;
    parametersVn=3;
  }
  for (int j=1; j < nargs; j++) {
    int indexConst=nextLocal++;
    m.addInstruction(null,new SSAArrayLoadInstruction(args[i++]=nextLocal++,parametersVn,indexConst,TypeReference.JavaLangObject),false);
    constants.put(new Integer(indexConst),new ConstantValue(j - 1));
    pc++;
  }
  int exceptions=nextLocal++;
  int result=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),IInvokeInstruction.Dispatch.SPECIAL)),false);
    m.addInstruction(null,new SSAReturnInstruction(args[0],false),false);
  }
 else {
    Dispatch d=target.isStatic() ? Dispatch.STATIC : Dispatch.VIRTUAL;
    if (target.getReturnType().equals(TypeReference.Void)) {
      m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
    }
 else {
      result=nextLocal++;
      m.addInstruction(null,new SSAInvokeInstruction(result,args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
      m.addInstruction(null,new SSAReturnInstruction(result,false),false);
    }
  }
  SSAInstruction[] instrs=new SSAInstruction[m.allInstructions.size()];
  m.allInstructions.<SSAInstruction>toArray(instrs);
  return new SyntheticIR(method,context,new InducedCFG(instrs,method,context),instrs,SSAOptions.defaultOptions(),constants);
}","/** 
 * TODO: clean this up. Create the IR for the synthetic method (e.g. Method.invoke)
 * @param method is something like Method.invoke or Construction.newInstance
 * @param target is the method being called reflectively
 */
private IR makeIR(IMethod method,IMethod target,ReceiverInstanceContext context){
  SpecializedMethod m=new SpecializedMethod(method,method.getDeclaringClass(),method.isStatic(),false);
  Map<Integer,ConstantValue> constants=HashMapFactory.make();
  int nextLocal=method.getNumberOfParameters() + 1;
  int nargs=target.getNumberOfParameters();
  int args[]=new int[nargs];
  int i=0;
  int pc=0;
  int parametersVn=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    TypeReference allocatedType=target.getDeclaringClass().getReference();
    m.addInstruction(allocatedType,new SSANewInstruction(args[i++]=nextLocal++,NewSiteReference.make(pc++,allocatedType)),true);
    parametersVn=2;
  }
 else {
    parametersVn=3;
    if (target.isStatic()) {
    }
 else {
      args[i++]=2;
    }
  }
  for (int j=i; j < nargs; j++) {
    int indexConst=nextLocal++;
    m.addInstruction(null,new SSAArrayLoadInstruction(args[i++]=nextLocal++,parametersVn,indexConst,TypeReference.JavaLangObject),false);
    constants.put(new Integer(indexConst),new ConstantValue(j - 1));
    pc++;
  }
  int exceptions=nextLocal++;
  int result=-1;
  if (method.getReference().equals(CTOR_NEW_INSTANCE)) {
    m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),IInvokeInstruction.Dispatch.SPECIAL)),false);
    m.addInstruction(null,new SSAReturnInstruction(args[0],false),false);
  }
 else {
    Dispatch d=target.isStatic() ? Dispatch.STATIC : Dispatch.VIRTUAL;
    if (target.getReturnType().equals(TypeReference.Void)) {
      m.addInstruction(null,new SSAInvokeInstruction(args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
    }
 else {
      result=nextLocal++;
      m.addInstruction(null,new SSAInvokeInstruction(result,args,exceptions,CallSiteReference.make(pc++,target.getReference(),d)),false);
      m.addInstruction(null,new SSAReturnInstruction(result,false),false);
    }
  }
  SSAInstruction[] instrs=new SSAInstruction[m.allInstructions.size()];
  m.allInstructions.<SSAInstruction>toArray(instrs);
  return new SyntheticIR(method,context,new InducedCFG(instrs,method,context),instrs,SSAOptions.defaultOptions(),constants);
}",0.9404429155020426
100110,"public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(node.getContext() instanceof ReceiverInstanceContext)) {
    return false;
  }
  return node.getMethod().getReference().equals(METHOD_INVOKE) || node.getMethod().getReference().equals(CTOR_NEW_INSTANCE);
}","public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(node.getContext() instanceof ReceiverInstanceContext)) {
    return false;
  }
  ReceiverInstanceContext r=(ReceiverInstanceContext)node.getContext();
  if (!(r.getReceiver() instanceof ConstantKey)) {
    return false;
  }
  return node.getMethod().getReference().equals(METHOD_INVOKE) || node.getMethod().getReference().equals(CTOR_NEW_INSTANCE);
}",0.8238153098420413
100111,"/** 
 * Creates a callee target based on the following criteria: <ol> <li> If the method being invoked through reflection is definitely static, then do not create a callee target for any <code>callee</code> method that is not static. In this case, return <code>null</code>. <li> If the method being invoked through reflection takes a constant number of parameters, <code>n</code>, then do not create a callee target for any <code>callee</code> method that takes a number of parameters different from <code>n</code>.  In this case, return <code>null</code>. <li> Otherwise, return a new   {@link ReceiverInstanceContext} for <code>receiver</code>.</ol>       
 */
public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (!mayUnderstand(caller,site,callee,receiver)) {
    return null;
  }
  IR ir=caller.getIR();
  SSAAbstractInvokeInstruction[] invokeInstructions=ir.getCalls(site);
  if (invokeInstructions.length != 1) {
    return new ReceiverInstanceContext(receiver);
  }
  SymbolTable st=ir.getSymbolTable();
  ConstantKey receiverConstantKey=(ConstantKey)receiver;
  IMethod m=(IMethod)receiverConstantKey.getValue();
  boolean isStatic=m.isStatic();
  boolean isConstructor=isConstructorConstant(receiver);
  if (!isConstructor) {
    int recvUse=invokeInstructions[0].getUse(1);
    if (st.isNullConstant(recvUse) && !isStatic) {
      return null;
    }
  }
  int numberOfParams=isStatic ? m.getNumberOfParameters() : m.getNumberOfParameters() - 1;
  int paramIndex=isConstructor ? 1 : 2;
  int paramUse=invokeInstructions[0].getUse(paramIndex);
  SSAInstruction instr=caller.getDU().getDef(paramUse);
  if (!(instr instanceof SSANewInstruction)) {
    return new ReceiverInstanceContext(receiver);
  }
  SSANewInstruction newInstr=(SSANewInstruction)instr;
  if (!newInstr.getConcreteType().isArrayType()) {
    return null;
  }
  int vn=newInstr.getUse(0);
  try {
    int arrayLength=st.getIntValue(vn);
    if (arrayLength == numberOfParams) {
      return new ReceiverInstanceContext(receiver);
    }
 else {
      return new IllegalArgumentExceptionContext();
    }
  }
 catch (  IllegalArgumentException e) {
    return new ReceiverInstanceContext(receiver);
  }
}","/** 
 * Creates a callee target based on the following criteria: <ol> <li> If the method being invoked through reflection is definitely static, then do not create a callee target for any <code>callee</code> method that is not static. In this case, return <code>null</code>. <li> If the method being invoked through reflection takes a constant number of parameters, <code>n</code>, then do not create a callee target for any <code>callee</code> method that takes a number of parameters different from <code>n</code>. In this case, return <code>null</code>. <li> Otherwise, return a new   {@link ReceiverInstanceContext} for <code>receiver</code>.</ol>
 */
public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (!mayUnderstand(caller,site,callee,receiver)) {
    return null;
  }
  IR ir=caller.getIR();
  SSAAbstractInvokeInstruction[] invokeInstructions=ir.getCalls(site);
  if (invokeInstructions.length != 1) {
    return new ReceiverInstanceContext(receiver);
  }
  SymbolTable st=ir.getSymbolTable();
  ConstantKey receiverConstantKey=(ConstantKey)receiver;
  IMethod m=(IMethod)receiverConstantKey.getValue();
  boolean isStatic=m.isStatic();
  boolean isConstructor=isConstructorConstant(receiver);
  if (!isConstructor) {
    int recvUse=invokeInstructions[0].getUse(1);
    if (st.isNullConstant(recvUse) && !isStatic) {
      return null;
    }
  }
  int numberOfParams=isStatic ? m.getNumberOfParameters() : m.getNumberOfParameters() - 1;
  int paramIndex=isConstructor ? 1 : 2;
  int paramUse=invokeInstructions[0].getUse(paramIndex);
  SSAInstruction instr=caller.getDU().getDef(paramUse);
  if (!(instr instanceof SSANewInstruction)) {
    return new ReceiverInstanceContext(receiver);
  }
  SSANewInstruction newInstr=(SSANewInstruction)instr;
  if (!newInstr.getConcreteType().isArrayType()) {
    return null;
  }
  int vn=newInstr.getUse(0);
  try {
    int arrayLength=st.getIntValue(vn);
    if (arrayLength == numberOfParams) {
      return new ReceiverInstanceContext(receiver);
    }
 else {
      return new IllegalArgumentExceptionContext();
    }
  }
 catch (  IllegalArgumentException e) {
    return new ReceiverInstanceContext(receiver);
  }
}",0.9982078853046596
100112,"/** 
 * This object may understand a dispatch to Constructor.newInstance().
 */
public boolean mayUnderstand(CGNode caller,CallSiteReference site,IMethod targetMethod,InstanceKey instance){
  if (targetMethod.getReference().equals(ReflectiveInvocationInterpreter.METHOD_INVOKE) || isConstructorConstant(instance) && targetMethod.getReference().equals(ReflectiveInvocationInterpreter.CTOR_NEW_INSTANCE)) {
    return true;
  }
  return false;
}","/** 
 * This object may understand a dispatch to Constructor.newInstance().
 */
public boolean mayUnderstand(CGNode caller,CallSiteReference site,IMethod targetMethod,InstanceKey instance){
  if (instance instanceof ConstantKey) {
    if (targetMethod.getReference().equals(ReflectiveInvocationInterpreter.METHOD_INVOKE) || isConstructorConstant(instance) && targetMethod.getReference().equals(ReflectiveInvocationInterpreter.CTOR_NEW_INSTANCE)) {
      return true;
    }
  }
  return false;
}",0.9455709711846318
100113,"/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  final boolean[] r=new boolean[instructions.length];
  r[0]=true;
  BranchVisitor branchVisitor=makeBranchVisitor(r);
  PEIVisitor peiVisitor=makePEIVisitor(r);
  for (int i=0; i < instructions.length; i++) {
    if (instructions[i] != null) {
      branchVisitor.setIndex(i);
      instructions[i].visit(branchVisitor);
      peiVisitor.setIndex(i);
      instructions[i].visit(peiVisitor);
    }
  }
  BasicBlock b=null;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      b=new BasicBlock(i);
      addNode(b);
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + b);
      }
    }
    i2block[i]=b;
  }
  BasicBlock exit=new BasicBlock(-1);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + exit);
  }
  addNode(exit);
}","/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  final boolean[] r=new boolean[instructions.length];
  r[0]=true;
  BranchVisitor branchVisitor=makeBranchVisitor(r);
  PEIVisitor peiVisitor=makePEIVisitor(r);
  for (int i=0; i < instructions.length; i++) {
    if (instructions[i] != null) {
      branchVisitor.setIndex(i);
      instructions[i].visit(branchVisitor);
      peiVisitor.setIndex(i);
      instructions[i].visit(peiVisitor);
    }
  }
  BasicBlock b=null;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      b=new BasicBlock(i);
      addNode(b);
      int j=i;
      while (instructions[j] instanceof SSAPhiInstruction) {
        b.addPhi((SSAPhiInstruction)instructions[j]);
        j++;
      }
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + b);
      }
    }
    i2block[i]=b;
  }
  BasicBlock exit=new BasicBlock(-1);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + exit);
  }
  addNode(exit);
  clearPhis(instructions);
}",0.9119683481701286
100114,"@Override public void visitGoto(SSAGotoInstruction instruction){
  Assertions.UNREACHABLE(""String_Node_Str"");
  breakBasicBlock();
}","@Override public void visitGoto(SSAGotoInstruction instruction){
  Assertions.UNREACHABLE(""String_Node_Str"");
  breakBasicBlock(index);
}",0.9814126394052044
100115,"/** 
 * TODO: we do not yet support induced CFGS with exception handlers.
 * @param instructions
 * @throws IllegalArgumentException  if instructions is null
 */
public InducedCFG(SSAInstruction[] instructions,IMethod method,Context context){
  super(method);
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.context=context;
  this.instructions=instructions;
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + method);
  }
  i2block=new BasicBlock[instructions.length];
  if (instructions.length == 0) {
    makeEmptyBlocks();
  }
 else {
    makeBasicBlocks();
  }
  init();
  computeEdges();
  if (DEBUG) {
    try {
      GraphIntegrity.check(this);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","/** 
 * TODO: we do not yet support induced CFGS with exception handlers. NOTE: SIDE EFFECT!!! ... nulls out phi instructions in the instruction array!
 * @throws IllegalArgumentException if instructions is null
 */
public InducedCFG(SSAInstruction[] instructions,IMethod method,Context context){
  super(method);
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.context=context;
  this.instructions=instructions;
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + method);
  }
  i2block=new BasicBlock[instructions.length];
  if (instructions.length == 0) {
    makeEmptyBlocks();
  }
 else {
    makeBasicBlocks();
  }
  init();
  computeEdges();
  if (DEBUG) {
    try {
      GraphIntegrity.check(this);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9187279151943464
100116,"@Override public void visitReturn(SSAReturnInstruction instruction){
  breakBasicBlock();
}","@Override public void visitReturn(SSAReturnInstruction instruction){
  breakBasicBlock(index);
}",0.9732620320855616
100117,"@Override public void visitConditionalBranch(SSAConditionalBranchInstruction instruction){
  Assertions.UNREACHABLE(""String_Node_Str"");
  breakBasicBlock();
}","@Override public void visitConditionalBranch(SSAConditionalBranchInstruction instruction){
  Assertions.UNREACHABLE(""String_Node_Str"");
  breakBasicBlock(index);
}",0.9844236760124612
100118,"public InducedCFG makeControlFlowGraph(){
  return new InducedCFG(getStatements(),this,Everywhere.EVERYWHERE);
}","/** 
 * Create an   {@link InducedCFG} from an instruction array.NOTE: SIDE EFFECT!!! ... nulls out phi instructions in the instruction array!
 */
public InducedCFG makeControlFlowGraph(SSAInstruction[] instructions){
  return new InducedCFG(instructions,this,Everywhere.EVERYWHERE);
}",0.4886649874055415
100119,"@Override public IR makeIR(SSAOptions options){
  SSAInstruction instrs[]=getStatements(options);
  Map<Integer,ConstantValue> constants=null;
  if (valueNumberForConstantOne > -1) {
    constants=HashMapFactory.make(1);
    constants.put(new Integer(valueNumberForConstantOne),new ConstantValue(new Integer(1)));
  }
  return new SyntheticIR(this,Everywhere.EVERYWHERE,makeControlFlowGraph(),instrs,options,constants);
}","@Override public IR makeIR(SSAOptions options){
  SSAInstruction instrs[]=getStatements(options);
  Map<Integer,ConstantValue> constants=null;
  if (valueNumberForConstantOne > -1) {
    constants=HashMapFactory.make(1);
    constants.put(new Integer(valueNumberForConstantOne),new ConstantValue(new Integer(1)));
  }
  InducedCFG cfg=makeControlFlowGraph(instrs);
  return new SyntheticIR(this,Everywhere.EVERYWHERE,cfg,instrs,options,constants);
}",0.9172413793103448
100120,"@Override public IR makeIR(SSAOptions options){
  SSAInstruction instrs[]=getStatements(options);
  return new SyntheticIR(this,Everywhere.EVERYWHERE,makeControlFlowGraph(),instrs,options,summary.getConstants());
}","@Override public IR makeIR(SSAOptions options){
  SSAInstruction instrs[]=getStatements(options);
  return new SyntheticIR(this,Everywhere.EVERYWHERE,makeControlFlowGraph(instrs),instrs,options,summary.getConstants());
}",0.9861751152073732
100121,"/** 
 * Creates the union of two ordinal sets.
 * @param A ordinal set a
 * @param B ordinal set b
 * @return union of a and b
 * @throws IllegalArgumentException iff A or B is null
 */
public static <T>OrdinalSet<T> unify(OrdinalSet<T> A,OrdinalSet<T> B){
  if (A == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (B == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    if (A.size() != 0 && B.size() != 0) {
      Assertions._assert(A.mapping.equals(B.mapping));
    }
  }
  if (A.S != null && B.S == null) {
    return new OrdinalSet<T>(A.S,A.mapping);
  }
 else   if (A.S == null && B.S != null) {
    return new OrdinalSet<T>(B.S,B.mapping);
  }
  IntSet union=A.S.union(B.S);
  return new OrdinalSet<T>(union,A.mapping);
}","/** 
 * Creates the union of two ordinal sets.
 * @param A ordinal set a
 * @param B ordinal set b
 * @return union of a and b
 * @throws IllegalArgumentException iff A or B is null
 */
public static <T>OrdinalSet<T> unify(OrdinalSet<T> A,OrdinalSet<T> B){
  if (A == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (B == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    if (A.size() != 0 && B.size() != 0) {
      Assertions._assert(A.mapping.equals(B.mapping));
    }
  }
  if (A.S == null) {
    return (B.S == null) ? OrdinalSet.<T>empty() : new OrdinalSet<T>(B.S,B.mapping);
  }
 else   if (B.S == null) {
    return (A.S == null) ? OrdinalSet.<T>empty() : new OrdinalSet<T>(A.S,A.mapping);
  }
  IntSet union=A.S.union(B.S);
  return new OrdinalSet<T>(union,A.mapping);
}",0.8054567022538552
100122,"protected void addInstruction(final TypeReference T,SSAInstruction instr,boolean isAllocation){
  if (isAllocation) {
    if (types.contains(T))     return;
  }
  types.add(T);
  allInstructions.add(instr);
  if (isAllocation)   allocations.add(instr);
}","protected void addInstruction(final TypeReference T,SSAInstruction instr,boolean isAllocation){
  if (isAllocation) {
    if (typesAllocated.contains(T)) {
      return;
    }
 else {
      typesAllocated.add(T);
    }
  }
  allInstructions.add(instr);
  if (isAllocation) {
    allocations.add(instr);
  }
}",0.8932384341637011
100123,"/** 
 * @param type
 * @return a TypeAbstraction object representing this type. We just useConeTypes by default, since we don't propagate information allowing us to distinguish between points and cones yet.
 */
protected TypeAbstraction typeRef2TypeAbstraction(IClassHierarchy cha,TypeReference type){
  IClass klass=cha.lookupClass(type);
  if (klass != null) {
    return new ConeType(klass);
  }
  Assertions.UNREACHABLE(type.toString());
  return null;
}","/** 
 * @param type
 * @return a TypeAbstraction object representing this type. We just use ConeTypes by default, since we don't propagateinformation allowing us to distinguish between points and cones yet.
 */
protected TypeAbstraction typeRef2TypeAbstraction(IClassHierarchy cha,TypeReference type){
  IClass klass=cha.lookupClass(type);
  if (klass != null) {
    return new ConeType(klass);
  }
  Assertions.UNREACHABLE(type.toString());
  return null;
}",0.9978165938864628
100124,"protected int addStatementsForConcreteSimpleType(final TypeReference T){
  if (types.contains(T))   return -1;
  types.add(T);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + T);
  }
  NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
  int alloc=getLocalForType(T);
  SSANewInstruction a=new SSANewInstruction(alloc,ref);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + a);
  }
  addInstruction(T,a,true);
  SSAReturnInstruction r=new SSAReturnInstruction(alloc,false);
  addInstruction(T,r,false);
  return alloc;
}","/** 
 * @param T
 * @return value number of the newly allocated object
 */
protected int addStatementsForConcreteSimpleType(final TypeReference T){
}",0.2132564841498559
100125,"protected void addStatementsForTypeAbstraction(TypeAbstraction T){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ method);
  }
  T=interceptType(T);
  if (T == null) {
    return;
  }
  if ((T instanceof PointType) || (T instanceof ConeType)) {
    TypeReference ref=T.getType().getReference();
    NewSiteReference site=NewSiteReference.make(0,ref);
    IClass klass=options.getClassTargetSelector().getAllocatedTarget(null,site);
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + klass + ""String_Node_Str""+ T);
    }
    if (T instanceof PointType) {
      addStatementsForConcreteType(ref);
    }
 else     if (T instanceof ConeType) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + T);
      }
      if (((ConeType)T).isInterface()) {
        Set implementors=T.getType().getClassHierarchy().getImplementors(ref);
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ implementors);
        }
        if (implementors.isEmpty()) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + T);
          }
          Warnings.add(NoSubtypesWarning.create(T));
        }
        if (implementors.size() > CONE_BOUND) {
          Warnings.add(ManySubtypesWarning.create(T,implementors.size()));
        }
        addStatementsForSetOfTypes(implementors.iterator());
      }
 else {
        Collection<IClass> subclasses=T.getType().getClassHierarchy().computeSubClasses(ref);
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ subclasses);
        }
        if (subclasses.isEmpty()) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + T);
          }
          Warnings.add(NoSubtypesWarning.create(T));
        }
        if (subclasses.size() > CONE_BOUND) {
          Warnings.add(ManySubtypesWarning.create(T,subclasses.size()));
        }
        addStatementsForSetOfTypes(subclasses.iterator());
      }
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + T.getClass());
    }
  }
 else   if (T instanceof SetType) {
    addStatementsForSetOfTypes(((SetType)T).iteratePoints());
  }
 else {
    Assertions.UNREACHABLE(""String_Node_Str"" + T.getClass());
  }
}","protected void addStatementsForTypeAbstraction(TypeAbstraction T){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ method);
  }
  T=interceptType(T);
  if (T == null) {
    return;
  }
  if ((T instanceof PointType) || (T instanceof ConeType)) {
    TypeReference ref=T.getType().getReference();
    NewSiteReference site=NewSiteReference.make(0,ref);
    IClass klass=options.getClassTargetSelector().getAllocatedTarget(null,site);
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + klass + ""String_Node_Str""+ T);
    }
    if (T instanceof PointType) {
      if (!typesAllocated.contains(ref)) {
        addStatementsForConcreteType(ref);
      }
    }
 else     if (T instanceof ConeType) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + T);
      }
      if (((ConeType)T).isInterface()) {
        Set implementors=T.getType().getClassHierarchy().getImplementors(ref);
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ implementors);
        }
        if (implementors.isEmpty()) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + T);
          }
          Warnings.add(NoSubtypesWarning.create(T));
        }
        if (implementors.size() > CONE_BOUND) {
          Warnings.add(ManySubtypesWarning.create(T,implementors.size()));
        }
        addStatementsForSetOfTypes(implementors.iterator());
      }
 else {
        Collection<IClass> subclasses=T.getType().getClassHierarchy().computeSubClasses(ref);
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + T + ""String_Node_Str""+ subclasses);
        }
        if (subclasses.isEmpty()) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + T);
          }
          Warnings.add(NoSubtypesWarning.create(T));
        }
        if (subclasses.size() > CONE_BOUND) {
          Warnings.add(ManySubtypesWarning.create(T,subclasses.size()));
        }
        addStatementsForSetOfTypes(subclasses.iterator());
      }
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + T.getClass());
    }
  }
 else   if (T instanceof SetType) {
    addStatementsForSetOfTypes(((SetType)T).iteratePoints());
  }
 else {
    Assertions.UNREACHABLE(""String_Node_Str"" + T.getClass());
  }
}",0.9882405147548258
100126,"private void addStatementsForSetOfTypes(Iterator it){
  if (!it.hasNext()) {
    SSAReturnInstruction r=new SSAReturnInstruction(nextLocal,false);
    allInstructions.add(r);
  }
  for (; it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    TypeReference T=klass.getReference();
    if (klass.isAbstract() || types.contains(T)) {
      continue;
    }
    types.add(T);
    int i=getLocalForType(T);
    NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
    SSANewInstruction a=null;
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      initValueNumberForConstantOne();
      Arrays.fill(sizes,valueNumberForConstantOne);
      a=new SSANewInstruction(i,ref,sizes);
    }
 else {
      a=new SSANewInstruction(i,ref);
    }
    allocations.add(a);
    allInstructions.add(a);
    SSAReturnInstruction r=new SSAReturnInstruction(i,false);
    allInstructions.add(r);
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=i;
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,getExceptionsForType(T),site);
    calls.add(s);
    allInstructions.add(s);
  }
}","private void addStatementsForSetOfTypes(Iterator it){
  if (!it.hasNext()) {
    SSAReturnInstruction r=new SSAReturnInstruction(nextLocal,false);
    allInstructions.add(r);
  }
  for (; it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    TypeReference T=klass.getReference();
    if (klass.isAbstract() || typesAllocated.contains(T)) {
      continue;
    }
    typesAllocated.add(T);
    int i=getLocalForType(T);
    NewSiteReference ref=NewSiteReference.make(getNewSiteForType(T),T);
    SSANewInstruction a=null;
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      initValueNumberForConstantOne();
      Arrays.fill(sizes,valueNumberForConstantOne);
      a=new SSANewInstruction(i,ref,sizes);
    }
 else {
      a=new SSANewInstruction(i,ref);
    }
    allocations.add(a);
    allInstructions.add(a);
    SSAReturnInstruction r=new SSAReturnInstruction(i,false);
    allInstructions.add(r);
    MethodReference init=MethodReference.findOrCreate(T,MethodReference.initAtom,MethodReference.defaultInitDesc);
    CallSiteReference site=CallSiteReference.make(getCallSiteForType(T),init,IInvokeInstruction.Dispatch.SPECIAL);
    int[] params=new int[1];
    params[0]=i;
    SSAInvokeInstruction s=new SSAInvokeInstruction(params,getExceptionsForType(T),site);
    calls.add(s);
    allInstructions.add(s);
  }
}",0.9933085501858736
100127,"/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in thevalue of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.worked(monitor,1);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}","/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in thevalue of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.throwExceptionIfCanceled(monitor);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}",0.9883616830796778
100128,"/** 
 * @return a set of ConcreteTypeKeys that represent the exceptions the PEI may throw.
 */
public InstanceKey getInstanceKeyForPEI(CGNode node,ProgramCounter peiLoc,TypeReference type){
  return new ConcreteTypeKey(cha.lookupClass(type));
}","/** 
 * @return a set of ConcreteTypeKeys that represent the exceptions the PEI may throw.
 */
public InstanceKey getInstanceKeyForPEI(CGNode node,ProgramCounter peiLoc,TypeReference type){
  IClass klass=cha.lookupClass(type);
  if (klass == null) {
    return null;
  }
  return new ConcreteTypeKey(cha.lookupClass(type));
}",0.856140350877193
100129,"/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
private void addExceptionDefConstraints(IR ir,DefUse du,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set catchClasses){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + node);
  }
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + peiLoc);
    }
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pei);
    }
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=getPointerKeyForLocal(node,s.getException());
      if (!SHORT_CIRCUIT_SINGLE_USES || !hasUniqueCatchBlock(s,ir)) {
        addAssignmentsForCatchPointerKey(exceptionVar,catchClasses,e);
      }
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=getPointerKeyForLocal(node,s.getException());
      if (contentsAreInvariant(ir.getSymbolTable(),du,s.getException())) {
        InstanceKey[] ik=getInvariantContents(ir.getSymbolTable(),du,node,s.getException(),this);
        for (int i=0; i < ik.length; i++) {
          system.findOrCreateIndexForInstanceKey(ik[i]);
          assignInstanceToCatch(exceptionVar,catchClasses,ik[i]);
        }
      }
 else {
        addAssignmentsForCatchPointerKey(exceptionVar,catchClasses,e);
      }
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=getInstanceKeyForPEI(node,peiLoc,type,instanceKeyFactory);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            system.newConstraint(exceptionVar,getInstanceKeyForPEI(node,peiLoc,type,instanceKeyFactory));
          }
        }
      }
    }
  }
}","/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
private void addExceptionDefConstraints(IR ir,DefUse du,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set catchClasses){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + node);
  }
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + peiLoc);
    }
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pei);
    }
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=getPointerKeyForLocal(node,s.getException());
      if (!SHORT_CIRCUIT_SINGLE_USES || !hasUniqueCatchBlock(s,ir)) {
        addAssignmentsForCatchPointerKey(exceptionVar,catchClasses,e);
      }
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=getPointerKeyForLocal(node,s.getException());
      if (contentsAreInvariant(ir.getSymbolTable(),du,s.getException())) {
        InstanceKey[] ik=getInvariantContents(ir.getSymbolTable(),du,node,s.getException(),this);
        for (int i=0; i < ik.length; i++) {
          system.findOrCreateIndexForInstanceKey(ik[i]);
          assignInstanceToCatch(exceptionVar,catchClasses,ik[i]);
        }
      }
 else {
        addAssignmentsForCatchPointerKey(exceptionVar,catchClasses,e);
      }
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=getInstanceKeyForPEI(node,peiLoc,type,instanceKeyFactory);
          if (ik == null) {
            continue;
          }
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            system.newConstraint(exceptionVar,getInstanceKeyForPEI(node,peiLoc,type,instanceKeyFactory));
          }
        }
      }
    }
  }
}",0.9883677298311444
100130,"/** 
 * Usage: GVSlice -appJar [jar file name] -mainClass [main class] -srcCaller [method name] -srcCallee [method name] -dd [data dependence options] -cd [control dependence options] -dir [forward|backward] <ul> <li> ""jar file name"" should be something like ""c:/temp/testdata/java_cup.jar"" <li> ""main class"" should beshould be something like ""c:/temp/testdata/java_cup.jar"" <li> ""method name"" should be the name of a method. This takes a slice from the statement that calls ""srcCallee"" from ""srcCaller"" <li> ""data dependence options"" can be one of ""-full"", ""-no_base_ptrs"", ""-no_base_no_heap"", ""-no_heap"", ""-no_base_no_heap_no_cast"", or ""-none"".
 * @throws CancelException
 * @throws IllegalArgumentException
 * @see com.ibm.wala.ipa.slicer.Slicer.DataDependenceOptions <li> ""control dependence options"" can be ""-full"" or ""-none"" <li> the -dir argument tells whether to compute a forwards or backwards slice. </ul>
 */
public static void main(String[] args) throws WalaException, IllegalArgumentException, CancelException {
  run(args);
}","/** 
 * Usage: GVSlice -appJar [jar file name] -mainClass [main class] -srcCaller [method name] -srcCallee [method name] -dd [data dependence options] -cd [control dependence options] -dir [forward|backward] <ul> <li> ""jar file name"" should be something like ""c:/temp/testdata/java_cup.jar"" <li> ""main class"" should beshould be something like ""c:/temp/testdata/java_cup.jar"" <li> ""method name"" should be the name of a method. This takes a slice from the statement that calls ""srcCallee"" from ""srcCaller"" <li> ""data dependence options"" can be one of ""-full"", ""-no_base_ptrs"", ""-no_base_no_heap"", ""-no_heap"", ""-no_base_no_heap_no_cast"", or ""-none"".
 * @throws CancelException
 * @throws IllegalArgumentException
 * @throws IOException 
 * @see com.ibm.wala.ipa.slicer.Slicer.DataDependenceOptions <li> ""control dependence options"" can be ""-full"" or ""-none"" <li> the -dir argument tells whether to compute a forwards or backwards slice. </ul>
 */
public static void main(String[] args) throws WalaException, IllegalArgumentException, CancelException, IOException {
  run(args);
}",0.9825059101654846
100131,"/** 
 * Compute a slice from a call statements, dot it, and fire off ghostview to visualize the result
 * @param appJar should be something like ""c:/temp/testdata/java_cup.jar""
 * @param mainClass should be something like ""c:/temp/testdata/java_cup.jar""
 * @param srcCaller name of the method containing the statement of interest
 * @param srcCallee name of the method called by the statement of interest
 * @param goBackward do a backward slice?
 * @param dOptions options controlling data dependence
 * @param cOptions options controlling control dependence
 * @return a Process running ghostview to visualize the dot'ted representation of the slice
 * @throws CancelException
 * @throws IllegalArgumentException
 */
public static Process run(String appJar,String mainClass,String srcCaller,String srcCallee,boolean goBackward,DataDependenceOptions dOptions,ControlDependenceOptions cOptions) throws IllegalArgumentException, CancelException {
  try {
    AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(appJar,new File(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,mainClass);
    AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
    CallGraphBuilder builder=Util.makeVanillaZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
    CallGraph cg=builder.makeCallGraph(options,null);
    SDG sdg=new SDG(cg,builder.getPointerAnalysis(),dOptions,cOptions);
    CGNode callerNode=SlicerTest.findMethod(cg,srcCaller);
    Statement s=SlicerTest.findCallTo(callerNode,srcCallee);
    System.err.println(""String_Node_Str"" + s);
    Collection<Statement> slice=null;
    if (goBackward) {
      slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),dOptions,cOptions);
    }
 else {
      s=getReturnStatementForCall(s);
      slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),dOptions,cOptions);
    }
    SlicerTest.dumpSlice(slice);
    Graph<Statement> g=pruneSDG(sdg,slice);
    sanityCheck(slice,g);
    Properties p=null;
    try {
      p=WalaExamplesProperties.loadProperties();
      p.putAll(WalaProperties.loadProperties());
    }
 catch (    WalaException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
    String psFile=p.getProperty(WalaProperties.OUTPUT_DIR) + File.separatorChar + PS_FILE;
    String dotExe=p.getProperty(WalaExamplesProperties.DOT_EXE);
    DotUtil.dotify(g,makeNodeDecorator(),GVTypeHierarchy.DOT_FILE,psFile,dotExe);
    String gvExe=p.getProperty(WalaExamplesProperties.GHOSTVIEW_EXE);
    return GVUtil.launchGV(psFile,gvExe);
  }
 catch (  WalaException e) {
    e.printStackTrace();
    return null;
  }
}","/** 
 * Compute a slice from a call statements, dot it, and fire off ghostview to visualize the result
 * @param appJar should be something like ""c:/temp/testdata/java_cup.jar""
 * @param mainClass should be something like ""c:/temp/testdata/java_cup.jar""
 * @param srcCaller name of the method containing the statement of interest
 * @param srcCallee name of the method called by the statement of interest
 * @param goBackward do a backward slice?
 * @param dOptions options controlling data dependence
 * @param cOptions options controlling control dependence
 * @return a Process running ghostview to visualize the dot'ted representation of the slice
 * @throws CancelException
 * @throws IllegalArgumentException
 */
public static Process run(String appJar,String mainClass,String srcCaller,String srcCallee,boolean goBackward,DataDependenceOptions dOptions,ControlDependenceOptions cOptions) throws IllegalArgumentException, CancelException, IOException {
  try {
    AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(appJar,FileProvider.getFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,mainClass);
    AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
    CallGraphBuilder builder=Util.makeVanillaZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
    CallGraph cg=builder.makeCallGraph(options,null);
    SDG sdg=new SDG(cg,builder.getPointerAnalysis(),dOptions,cOptions);
    CGNode callerNode=SlicerTest.findMethod(cg,srcCaller);
    Statement s=SlicerTest.findCallTo(callerNode,srcCallee);
    System.err.println(""String_Node_Str"" + s);
    Collection<Statement> slice=null;
    if (goBackward) {
      slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),dOptions,cOptions);
    }
 else {
      s=getReturnStatementForCall(s);
      slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),dOptions,cOptions);
    }
    SlicerTest.dumpSlice(slice);
    Graph<Statement> g=pruneSDG(sdg,slice);
    sanityCheck(slice,g);
    Properties p=null;
    try {
      p=WalaExamplesProperties.loadProperties();
      p.putAll(WalaProperties.loadProperties());
    }
 catch (    WalaException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
    String psFile=p.getProperty(WalaProperties.OUTPUT_DIR) + File.separatorChar + PS_FILE;
    String dotExe=p.getProperty(WalaExamplesProperties.DOT_EXE);
    DotUtil.dotify(g,makeNodeDecorator(),GVTypeHierarchy.DOT_FILE,psFile,dotExe);
    String gvExe=p.getProperty(WalaExamplesProperties.GHOSTVIEW_EXE);
    return GVUtil.launchGV(psFile,gvExe);
  }
 catch (  WalaException e) {
    e.printStackTrace();
    return null;
  }
}",0.9941437444543034
100132,"@Override public void visitPut(SSAPutInstruction instruction){
  IField f=pa.getClassHierarchy().resolveField(instruction.getDeclaredField());
  if (f != null) {
    if (instruction.isStatic()) {
      result.add(h.getPointerKeyForStaticField(f));
    }
 else {
      PointerKey ref=h.getPointerKeyForLocal(n,instruction.getRef());
      for (      InstanceKey i : pa.getPointsToSet(ref)) {
        result.add(h.getPointerKeyForInstanceField(i,f));
      }
    }
  }
}","@Override public void visitPut(SSAPutInstruction instruction){
  IField f=pa.getClassHierarchy().resolveField(instruction.getDeclaredField());
  if (f != null) {
    if (instruction.isStatic()) {
      result.add(h.getPointerKeyForStaticField(f));
    }
 else {
      PointerKey ref=h.getPointerKeyForLocal(n,instruction.getRef());
      if (ref != null) {
        for (        InstanceKey i : pa.getPointsToSet(ref)) {
          result.add(h.getPointerKeyForInstanceField(i,f));
        }
      }
    }
  }
}",0.947799385875128
100133,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
private void addExceptionalEdges(Instruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (Exceptions.isPEI(last)) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last.getOpcode() == OP_athrow) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        exceptionTypes=Exceptions.getExceptionTypes(getMethod().getDeclaringClass().getReference().getClassLoader(),last,cha);
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
 else {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
            }
          }
          if (caughtException != null) {
            HashSet<TypeReference> caught=HashSetFactory.make(exceptionTypes.size());
            for (Iterator it=exceptionTypes.iterator(); it.hasNext(); ) {
              TypeReference t=(TypeReference)it.next();
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  IClass caughtClass=cha.lookupClass(caughtException);
                  if (cha.isSubclassOf(klass,caughtClass) || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (cha.isSubclassOf(klass,caughtClass)) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
private void addExceptionalEdges(Instruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (Exceptions.isPEI(last)) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last.getOpcode() == OP_athrow) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        exceptionTypes=Exceptions.getExceptionTypes(getMethod().getDeclaringClass().getReference().getClassLoader(),last,cha);
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            addExceptionalEdgeTo(b);
            exceptionTypes.clear();
            caughtException=null;
          }
          if (caughtException != null) {
            HashSet<TypeReference> caught=HashSetFactory.make(exceptionTypes.size());
            for (Iterator it=exceptionTypes.iterator(); it.hasNext(); ) {
              TypeReference t=(TypeReference)it.next();
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  IClass caughtClass=cha.lookupClass(caughtException);
                  if (cha.isSubclassOf(klass,caughtClass) || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (cha.isSubclassOf(klass,caughtClass)) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9767952336155534
100134,"/** 
 * If the   {@link CallSiteReference} invokes Class.forName(s) and s is a string constant, return a{@link JavaTypeContext} representing the type named by s, if we can resolve it in the {@link IClassHierarchy}.
 * @see com.ibm.wala.ipa.callgraph.ContextSelector#getCalleeTarget(com.ibm.wala.ipa.callgraph.CGNode,com.ibm.wala.classLoader.CallSiteReference,com.ibm.wala.classLoader.IMethod,com.ibm.wala.ipa.callgraph.propagation.InstanceKey)
 */
public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (callee.equals(forNameMethod)) {
    IR ir=caller.getIR();
    SymbolTable symbolTable=ir.getSymbolTable();
    SSAAbstractInvokeInstruction[] invokeInstructions=caller.getIR().getCalls(site);
    if (invokeInstructions.length != 1) {
      return null;
    }
    int use=invokeInstructions[0].getUse(0);
    if (symbolTable.isStringConstant(use)) {
      String className=StringStuff.deployment2CanonicalTypeString(symbolTable.getStringValue(use));
      TypeReference t=TypeReference.findOrCreate(caller.getMethod().getDeclaringClass().getClassLoader().getReference(),className);
      IClass klass=caller.getClassHierarchy().lookupClass(t);
      if (klass != null) {
        return new JavaTypeContext(new PointType(klass));
      }
    }
  }
  return null;
}","/** 
 * If the   {@link CallSiteReference} invokes Class.forName(s) and s is a string constant, return a{@link JavaTypeContext} representing the type named by s, if we can resolve it in the {@link IClassHierarchy}.
 * @see com.ibm.wala.ipa.callgraph.ContextSelector#getCalleeTarget(com.ibm.wala.ipa.callgraph.CGNode,com.ibm.wala.classLoader.CallSiteReference,com.ibm.wala.classLoader.IMethod,com.ibm.wala.ipa.callgraph.propagation.InstanceKey)
 */
public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey receiver){
  if (callee.getReference().equals(ForNameContextInterpreter.FOR_NAME_REF)) {
    IR ir=caller.getIR();
    SymbolTable symbolTable=ir.getSymbolTable();
    SSAAbstractInvokeInstruction[] invokeInstructions=caller.getIR().getCalls(site);
    if (invokeInstructions.length != 1) {
      return null;
    }
    int use=invokeInstructions[0].getUse(0);
    if (symbolTable.isStringConstant(use)) {
      String className=StringStuff.deployment2CanonicalTypeString(symbolTable.getStringValue(use));
      TypeReference t=TypeReference.findOrCreate(caller.getMethod().getDeclaringClass().getClassLoader().getReference(),className);
      IClass klass=caller.getClassHierarchy().lookupClass(t);
      if (klass != null) {
        return new JavaTypeContext(new PointType(klass));
      }
    }
  }
  return null;
}",0.9806259314456036
100135,"public ForNameContextSelector(final IClassHierarchy cha){
}","public ForNameContextSelector(){
}",0.7311827956989247
100136,"/** 
 * This object may understand a dispatch to Class.forName(s) when s is a string constant.
 */
public boolean mayUnderstand(CGNode caller,CallSiteReference site,IMethod targetMethod,InstanceKey instance){
  if (targetMethod.equals(forNameMethod)) {
    IR ir=caller.getIR();
    SymbolTable symbolTable=ir.getSymbolTable();
    SSAAbstractInvokeInstruction[] invokeInstructions=caller.getIR().getCalls(site);
    if (invokeInstructions.length != 1) {
      return false;
    }
    int use=invokeInstructions[0].getUse(0);
    if (symbolTable.isStringConstant(use)) {
      return true;
    }
  }
  return false;
}","/** 
 * This object may understand a dispatch to Class.forName(s) when s is a string constant.
 */
public boolean mayUnderstand(CGNode caller,CallSiteReference site,IMethod targetMethod,InstanceKey instance){
  if (targetMethod.getReference().equals(ForNameContextInterpreter.FOR_NAME_REF)) {
    IR ir=caller.getIR();
    SymbolTable symbolTable=ir.getSymbolTable();
    SSAAbstractInvokeInstruction[] invokeInstructions=caller.getIR().getCalls(site);
    if (invokeInstructions.length != 1) {
      return false;
    }
    int use=invokeInstructions[0].getUse(0);
    if (symbolTable.isStringConstant(use)) {
      return true;
    }
  }
  return false;
}",0.9591836734693876
100137,"/** 
 * First check ""forName"" logic, then factory logic.
 */
private ReflectionContextSelector(IClassHierarchy cha,MethodTargetSelector methodTargetSelector){
  super(new ForNameContextSelector(cha),new FactoryContextSelector(cha,methodTargetSelector));
}","/** 
 * First check ""forName"" logic, then factory logic.
 */
private ReflectionContextSelector(IClassHierarchy cha,MethodTargetSelector methodTargetSelector){
  super(new ForNameContextSelector(),new FactoryContextSelector(cha,methodTargetSelector));
}",0.9940828402366864
100138,"@Override public void visitLoadClass(SSALoadClassInstruction instruction){
  PointerKey def=getPointerKeyForLocal(instruction.getDef());
  InstanceKey iKey=getInstanceKeyForClassObject(instruction.getLoadedClass());
  if (!contentsAreInvariant(symbolTable,du,instruction.getDef())) {
    system.newConstraint(def,iKey);
  }
 else {
    system.findOrCreateIndexForInstanceKey(iKey);
    system.recordImplicitPointsToSet(def);
  }
}","@Override public void visitLoadClass(SSALoadClassInstruction instruction){
  PointerKey def=getPointerKeyForLocal(instruction.getDef());
  InstanceKey iKey=getInstanceKeyForClassObject(instruction.getLoadedClass());
  IClass klass=getClassHierarchy().lookupClass(instruction.getLoadedClass());
  if (klass != null) {
    processClassInitializer(klass);
  }
  if (!contentsAreInvariant(symbolTable,du,instruction.getDef())) {
    system.newConstraint(def,iKey);
  }
 else {
    system.findOrCreateIndexForInstanceKey(iKey);
    system.recordImplicitPointsToSet(def);
  }
}",0.8591408591408591
100139,"/** 
 * Does m represent a static factory method we know about from the standard libraries, that we usually wish to model with one level of call-string context?
 */
public static boolean isWellKnownStaticFactory(MethodReference m){
  if (m.getDeclaringClass().equals(TypeReference.JavaLangSystem)) {
    if (m.getName().toString().equals(""String_Node_Str"")) {
      return true;
    }
  }
  if (m.equals(synthArraycopy)) {
    return true;
  }
  if (m.equals(ArraysAsList)) {
    return true;
  }
  if (m.equals(ArraysCopyOfRange)) {
    return true;
  }
  if (m.equals(ArraysCopyOf)) {
    return true;
  }
  if (m.equals(ArraysCopyOf2)) {
    return true;
  }
  if (m.equals(StringValueOf)) {
    return true;
  }
  return false;
}","/** 
 * Does m represent a static factory method we know about from the standard libraries, that we usually wish to model with one level of call-string context?
 */
public static boolean isWellKnownStaticFactory(MethodReference m){
  if (m.getDeclaringClass().equals(TypeReference.JavaLangSystem)) {
    if (m.getName().toString().equals(""String_Node_Str"")) {
      return true;
    }
  }
  if (m.equals(synthArraycopy)) {
    return true;
  }
  if (m.equals(ArraysAsList)) {
    return true;
  }
  if (m.equals(ArraysCopyOfRange)) {
    return true;
  }
  if (m.equals(ArraysCopyOf)) {
    return true;
  }
  if (m.equals(ArraysCopyOf2)) {
    return true;
  }
  if (m.equals(StringValueOf)) {
    return true;
  }
  if (m.equals(HashtableNewEntry)) {
    return true;
  }
  return false;
}",0.9422572178477692
100140,"/** 
 * Create nodes in the graph corresponding to in/out parameter passing for a call instruction
 */
private void addParamPassingStatements(int callIndex,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)node.getIR().getInstructions()[callIndex];
  Collection<Statement> params=MapUtil.findOrCreateSet(callerParamStatements,call.getCallSite());
  Collection<Statement> rets=MapUtil.findOrCreateSet(callerReturnStatements,call.getCallSite());
  for (int j=0; j < call.getNumberOfUses(); j++) {
    Statement st=new ParamCaller(node,callIndex,call.getUse(j));
    delegate.addNode(st);
    params.add(st);
  }
  if (!call.getDeclaredResultType().equals(TypeReference.Void)) {
    Statement st=new NormalReturnCaller(node,callIndex);
    delegate.addNode(st);
    rets.add(st);
  }
{
    if (!dOptions.isIgnoreExceptions()) {
      Statement st=new ExceptionalReturnCaller(node,callIndex);
      delegate.addNode(st);
      rets.add(st);
    }
  }
  if (!dOptions.isIgnoreHeap()) {
    OrdinalSet<PointerKey> uref=unionHeapLocations(cg,node,call,ref);
    for (    PointerKey p : uref) {
      Statement st=new HeapStatement.HeapParamCaller(node,callIndex,p);
      delegate.addNode(st);
      params.add(st);
    }
    OrdinalSet<PointerKey> umod=unionHeapLocations(cg,node,call,mod);
    for (    PointerKey p : umod) {
      Statement st=new HeapStatement.HeapReturnCaller(node,callIndex,p);
      delegate.addNode(st);
      rets.add(st);
    }
  }
}","/** 
 * Create nodes in the graph corresponding to in/out parameter passing for a call instruction
 */
private void addParamPassingStatements(int callIndex,Map<CGNode,OrdinalSet<PointerKey>> ref,IR ir){
  SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ir.getInstructions()[callIndex];
  Collection<Statement> params=MapUtil.findOrCreateSet(callerParamStatements,call.getCallSite());
  Collection<Statement> rets=MapUtil.findOrCreateSet(callerReturnStatements,call.getCallSite());
  for (int j=0; j < call.getNumberOfUses(); j++) {
    Statement st=new ParamCaller(node,callIndex,call.getUse(j));
    delegate.addNode(st);
    params.add(st);
  }
  if (!call.getDeclaredResultType().equals(TypeReference.Void)) {
    Statement st=new NormalReturnCaller(node,callIndex);
    delegate.addNode(st);
    rets.add(st);
  }
{
    if (!dOptions.isIgnoreExceptions()) {
      Statement st=new ExceptionalReturnCaller(node,callIndex);
      delegate.addNode(st);
      rets.add(st);
    }
  }
  if (!dOptions.isIgnoreHeap()) {
    OrdinalSet<PointerKey> uref=unionHeapLocations(cg,node,call,ref);
    for (    PointerKey p : uref) {
      Statement st=new HeapStatement.HeapParamCaller(node,callIndex,p);
      delegate.addNode(st);
      params.add(st);
    }
    OrdinalSet<PointerKey> umod=unionHeapLocations(cg,node,call,mod);
    for (    PointerKey p : umod) {
      Statement st=new HeapStatement.HeapReturnCaller(node,callIndex,p);
      delegate.addNode(st);
      rets.add(st);
    }
  }
}",0.993368700265252
100141,"/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(){
}","/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(IR ir,Map<SSAInstruction,Integer> instructionIndices){
}",0.9064748201438848
100142,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref);
    }
  }
  return visited;
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref,ir);
    }
  }
  return visited;
}",0.9978494623655914
100143,"/** 
 * Create all nodes in this PDG. Each node is a Statement.
 * @param dOptions
 */
private void createNodes(Map<CGNode,OrdinalSet<PointerKey>> ref,ControlDependenceOptions cOptions){
  IR ir=node.getIR();
  if (ir != null) {
    Collection<SSAInstruction> visited=createNormalStatements(ir,ref);
    createSpecialStatements(ir,visited);
  }
  createCalleeParams(ref);
  createReturnStatements();
  delegate.addNode(new MethodEntryStatement(node));
  delegate.addNode(new MethodExitStatement(node));
}","/** 
 * Create all nodes in this PDG. Each node is a Statement.
 */
private void createNodes(Map<CGNode,OrdinalSet<PointerKey>> ref,ControlDependenceOptions cOptions,IR ir){
  if (ir != null) {
    Collection<SSAInstruction> visited=createNormalStatements(ir,ref);
    createSpecialStatements(ir,visited);
  }
  createCalleeParams(ref);
  createReturnStatements();
  delegate.addNode(new MethodEntryStatement(node));
  delegate.addNode(new MethodExitStatement(node));
}",0.9578622816032888
100144,"private void createScalarEdges(ControlDependenceOptions cOptions){
  createScalarDataDependenceEdges();
  createControlDependenceEdges(cOptions);
}","private void createScalarEdges(ControlDependenceOptions cOptions,IR ir,Map<SSAInstruction,Integer> instructionIndices){
  createScalarDataDependenceEdges(ir,instructionIndices);
  createControlDependenceEdges(cOptions,ir,instructionIndices);
}",0.7538461538461538
100145,"public static synchronized Statement ssaInstruction2Statement(CGNode node,SSAInstruction s,Map<SSAInstruction,Integer> instructionIndices){
}","public static synchronized Statement ssaInstruction2Statement(CGNode node,SSAInstruction s,Map<SSAInstruction,Integer> instructionIndices,IR ir){
}",0.9791666666666666
100146,"/** 
 * Create all control dependence edges in this PDG.
 */
private void createControlDependenceEdges(ControlDependenceOptions cOptions){
}","/** 
 * Create all control dependence edges in this PDG.
 */
private void createControlDependenceEdges(ControlDependenceOptions cOptions,IR ir,Map<SSAInstruction,Integer> instructionIndices){
}",0.8408408408408409
100147,"private void populate(){
  if (!isPopulated) {
    isPopulated=true;
    instructionIndices=computeInstructionIndices(node.getIR());
    createNodes(ref,cOptions);
    createScalarEdges(cOptions);
  }
}","/** 
 * WARNING: Since we're using a   {@link HashMap} of {@link SSAInstruction}s, and equals() of   {@link SSAInstruction}assumes a canonical representative for each instruction, we <bf>must</bf> ensure that we use the same IR object throughout initialization!!
 */
private void populate(){
  if (!isPopulated) {
    IR ir=node.getIR();
    isPopulated=true;
    Map<SSAInstruction,Integer> instructionIndices=computeInstructionIndices(ir);
    createNodes(ref,cOptions,ir);
    createScalarEdges(cOptions,ir,instructionIndices);
  }
}",0.3495934959349593
100148,"/** 
 * handle flow from return value to callers, or from actual to formals
 * @param curPkAndState
 * @param handler
 */
private void handleBackInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler,final boolean addGraphs){
  final PointerKey curPk=curPkAndState.getPointerKey();
  final State curState=curPkAndState.getState();
  if (curPk instanceof ReturnValueKey) {
    final ReturnValueKey returnKey=(ReturnValueKey)curPk;
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    final CGNode callee=returnKey.getNode();
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + callee);
    }
    final boolean isExceptional=returnKey instanceof ExceptionReturnValueKey;
    for (    final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(returnKey)) {
      final CGNode caller=callSiteAndCGNode.getCGNode();
      final IR ir=getIR(caller);
      if (ir == null)       continue;
      final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
      if (!addGraphs) {
        if (!g.hasSubgraphForNode(caller)) {
          continue;
        }
      }
      final ReturnBarLabel returnBarLabel=ReturnBarLabel.make(callSiteAndCGNode);
      doTransition(curState,returnBarLabel,new Function<State,Object>(){
        private void propagateToCaller(){
          g.addSubgraphForNode(caller);
          SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
          for (int i=0; i < callInstrs.length; i++) {
            SSAAbstractInvokeInstruction callInstr=callInstrs[i];
            PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(returnAtCallerKey));
              Assertions._assert(g.containsNode(returnKey));
            }
            handler.handle(curPkAndState,returnAtCallerKey,returnBarLabel);
          }
        }
        public Object apply(        State callerState){
          SSAAbstractInvokeInstruction callInstr=ir.getCalls(call)[0];
          PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
          Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call,(LocalPointerKey)returnAtCallerKey);
          if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
            propagateToCaller();
          }
 else {
            if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
              propagateToCaller();
            }
 else {
              queryCallTargets(callSiteAndCGNode,ir,callerState);
            }
          }
          return null;
        }
      }
);
    }
  }
  if (curPk instanceof LocalPointerKey) {
    LocalPointerKey localPk=(LocalPointerKey)curPk;
    CGNode caller=localPk.getNode();
    for (Iterator<SSAInvokeInstruction> iter=g.getInstrsPassingParam(localPk); iter.hasNext(); ) {
      SSAInvokeInstruction callInstr=iter.next();
      for (int i=0; i < callInstr.getNumberOfUses(); i++) {
        if (localPk.getValueNumber() != callInstr.getUse(i))         continue;
        CallSiteReference callSiteRef=callInstr.getCallSite();
        CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
        Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef,localPk);
        if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
          for (          CGNode callee : possibleCallees) {
            if (!addGraphs) {
              if (!g.hasSubgraphForNode(callee)) {
                continue;
              }
            }
            if (callee.getIR() == null) {
              continue;
            }
            g.addSubgraphForNode(callee);
            PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(paramVal));
            }
            handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
          }
        }
 else {
          if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
            Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
            for (            CGNode callee : possibleCallees) {
              if (targetMethods.contains(callee.getMethod())) {
                if (caller.getIR() == null) {
                  continue;
                }
                g.addSubgraphForNode(callee);
                PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(g.containsNode(paramVal));
                }
                handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
              }
            }
          }
 else {
            queryCallTargets(callSiteAndCGNode,getIR(caller),curState);
          }
        }
      }
    }
  }
}","/** 
 * handle flow from return value to callers, or from actual to formals
 * @param curPkAndState
 * @param handler
 */
private void handleBackInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler,final boolean addGraphs){
  final PointerKey curPk=curPkAndState.getPointerKey();
  final State curState=curPkAndState.getState();
  if (curPk instanceof ReturnValueKey) {
    final ReturnValueKey returnKey=(ReturnValueKey)curPk;
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    final CGNode callee=returnKey.getNode();
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + callee);
    }
    final boolean isExceptional=returnKey instanceof ExceptionReturnValueKey;
    for (    final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(returnKey)) {
      final CGNode caller=callSiteAndCGNode.getCGNode();
      final IR ir=getIR(caller);
      if (ir == null)       continue;
      final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
      if (!addGraphs) {
        if (!g.hasSubgraphForNode(caller)) {
          continue;
        }
      }
      final ReturnBarLabel returnBarLabel=ReturnBarLabel.make(callSiteAndCGNode);
      doTransition(curState,returnBarLabel,new Function<State,Object>(){
        private void propagateToCaller(){
          g.addSubgraphForNode(caller);
          SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
          for (int i=0; i < callInstrs.length; i++) {
            SSAAbstractInvokeInstruction callInstr=callInstrs[i];
            PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(returnAtCallerKey));
              Assertions._assert(g.containsNode(returnKey));
            }
            handler.handle(curPkAndState,returnAtCallerKey,returnBarLabel);
          }
        }
        public Object apply(        State callerState){
          SSAAbstractInvokeInstruction callInstr=ir.getCalls(call)[0];
          PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
          Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call,(LocalPointerKey)returnAtCallerKey);
          if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
            propagateToCaller();
          }
 else {
            if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
              propagateToCaller();
            }
 else {
              queryCallTargets(callSiteAndCGNode,ir,callerState);
            }
          }
          return null;
        }
      }
);
    }
  }
  if (curPk instanceof LocalPointerKey) {
    LocalPointerKey localPk=(LocalPointerKey)curPk;
    CGNode caller=localPk.getNode();
    for (Iterator<SSAInvokeInstruction> iter=g.getInstrsPassingParam(localPk); iter.hasNext(); ) {
      SSAInvokeInstruction callInstr=iter.next();
      for (int i=0; i < callInstr.getNumberOfUses(); i++) {
        if (localPk.getValueNumber() != callInstr.getUse(i))         continue;
        CallSiteReference callSiteRef=callInstr.getCallSite();
        CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
        Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef,localPk);
        if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
          for (          CGNode callee : possibleCallees) {
            if (!addGraphs) {
              if (!g.hasSubgraphForNode(callee)) {
                continue;
              }
            }
            if (callee.getIR() == null) {
              continue;
            }
            g.addSubgraphForNode(callee);
            PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(paramVal));
            }
            handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
          }
        }
 else {
          if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
            Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
            for (            CGNode callee : possibleCallees) {
              if (targetMethods.contains(callee.getMethod())) {
                if (callee.getIR() == null) {
                  continue;
                }
                g.addSubgraphForNode(callee);
                PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(g.containsNode(paramVal));
                }
                handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
              }
            }
          }
 else {
            queryCallTargets(callSiteAndCGNode,getIR(caller),curState);
          }
        }
      }
    }
  }
}",0.9998007571229328
100149,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
private void addExceptionalEdges(Instruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (Exceptions.isPEI(last)) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last.getOpcode() == OP_athrow) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        exceptionTypes=Exceptions.getExceptionTypes(getMethod().getDeclaringClass().getReference().getClassLoader(),last,cha);
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
          if (caughtException == null) {
            addExceptionalEdgeTo(b);
            exceptionTypes.clear();
          }
 else {
            HashSet<TypeReference> caught=HashSetFactory.make(exceptionTypes.size());
            for (Iterator it=exceptionTypes.iterator(); it.hasNext(); ) {
              TypeReference t=(TypeReference)it.next();
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  IClass caughtClass=cha.lookupClass(caughtException);
                  if (cha.isSubclassOf(klass,caughtClass) || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (cha.isSubclassOf(klass,caughtClass)) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
private void addExceptionalEdges(Instruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (Exceptions.isPEI(last)) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last.getOpcode() == OP_athrow) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        exceptionTypes=Exceptions.getExceptionTypes(getMethod().getDeclaringClass().getReference().getClassLoader(),last,cha);
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
 else {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
            }
          }
          if (caughtException != null) {
            HashSet<TypeReference> caught=HashSetFactory.make(exceptionTypes.size());
            for (Iterator it=exceptionTypes.iterator(); it.hasNext(); ) {
              TypeReference t=(TypeReference)it.next();
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  IClass caughtClass=cha.lookupClass(caughtException);
                  if (cha.isSubclassOf(klass,caughtClass) || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (cha.isSubclassOf(klass,caughtClass)) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9820340070580686
100150,"public void testReflect1() throws WalaException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.REFLECT1_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  Warnings.clear();
  CallGraphTest.doCallGraphs(options,new AnalysisCache(),cha,scope,useShortProfile(),false);
  for (Iterator<Warning> it=Warnings.iterator(); it.hasNext(); ) {
    Warning w=(Warning)it.next();
    if (w.toString().indexOf(""String_Node_Str"") > 0) {
      continue;
    }
    if (w.toString().indexOf(""String_Node_Str"") >= 0) {
      assertTrue(w.toString(),false);
    }
  }
}","/** 
 * test that when analyzing Reflect1.main(), there is no warning about ""Integer"".
 */
public void testReflect1() throws WalaException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.REFLECT1_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  Warnings.clear();
  CallGraphTest.doCallGraphs(options,new AnalysisCache(),cha,scope,useShortProfile(),false);
  for (Iterator<Warning> it=Warnings.iterator(); it.hasNext(); ) {
    Warning w=(Warning)it.next();
    if (w.toString().indexOf(""String_Node_Str"") > 0) {
      continue;
    }
    if (w.toString().indexOf(""String_Node_Str"") >= 0) {
      assertTrue(w.toString(),false);
    }
  }
}",0.9506775067750678
100151,"/** 
 * handle possible updated flow in both directions for a call parameter
 * @param src
 * @param dst
 */
private void repropCallArg(PointerKeyAndState src,PointerKeyAndState dst,IFlowLabel dstToSrcLabel){
  for (  PointerKeyAndState srcToHandle : matchingPToQueried(dst,src.getPointerKey(),dstToSrcLabel)) {
    handleCopy(srcToHandle,dst,dstToSrcLabel.bar());
  }
  IntSet trackedSet=find(pkToTrackedSet,dst);
  if (!trackedSet.isEmpty()) {
    if (findOrCreate(pkToTrackedSet,src).addAll(trackedSet)) {
      addToTrackedPToWorklist(src);
    }
  }
}","/** 
 * handle possible updated flow in both directions for a call parameter
 * @param src
 * @param dst
 */
private void repropCallArg(PointerKeyAndState src,PointerKeyAndState dst,IFlowLabel dstToSrcLabel){
  if (DEBUG) {
  }
  for (  PointerKeyAndState srcToHandle : matchingPToQueried(dst,src.getPointerKey(),dstToSrcLabel)) {
    handleCopy(srcToHandle,dst,dstToSrcLabel.bar());
  }
  for (  PointerKeyAndState dstToHandle : matchingTrackedQueried(src,dst.getPointerKey(),dstToSrcLabel)) {
    IntSet trackedSet=find(pkToTrackedSet,dstToHandle);
    if (!trackedSet.isEmpty()) {
      if (findOrCreate(pkToTrackedSet,src).addAll(trackedSet)) {
        addToTrackedPToWorklist(src);
      }
    }
  }
}",0.8811410459587956
100152,"/** 
 * @return the points-to set of <code>pk</code>, or <code>null</code> ifthe points-to set can't be computed in the allocated budget
 */
public Collection<InstanceKey> getPointsTo(PointerKey pk){
  return getPointsTo(pk,Predicate.<Collection<InstanceKey>>falsePred()).snd;
}","/** 
 * @return the points-to set of <code>pk</code>, or <code>null</code> if the points-to set can't be computed inthe allocated budget
 */
public Collection<InstanceKey> getPointsTo(PointerKey pk){
  return getPointsTo(pk,Predicate.<Collection<InstanceKey>>falsePred()).snd;
}",0.9964028776978416
100153,"private void propagateToCallee(){
  if (caller.getIR() == null) {
    return;
  }
  g.addSubgraphForNode(caller);
  SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
  for (int i=0; i < callInstrs.length; i++) {
    SSAAbstractInvokeInstruction callInstr=callInstrs[i];
    PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
    if (Assertions.verifyAssertions) {
      Assertions._assert(g.containsNode(actualPk));
      Assertions._assert(g.containsNode(localPk));
    }
    handler.handle(curPkAndState,actualPk,paramLabel);
  }
}","private void propagateToCallee(){
  g.addSubgraphForNode(caller);
  SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
  for (int i=0; i < callInstrs.length; i++) {
    SSAAbstractInvokeInstruction callInstr=callInstrs[i];
    PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
    if (Assertions.verifyAssertions) {
      Assertions._assert(g.containsNode(actualPk));
      Assertions._assert(g.containsNode(localPk));
    }
    handler.handle(curPkAndState,actualPk,paramLabel);
  }
}",0.9569120287253142
100154,"/** 
 * track a field of some instance key, as we are interested in statements that read or write to the field
 * @param ikAndState
 * @param field
 * @param ikToFields either  {@link #forwInstKeyToFields} or{@link #backInstKeyToFields}
 */
private void trackInstanceField(InstanceKeyAndState ikAndState,IField field,MultiMap<InstanceKeyAndState,IField> ikToFields){
  State state=ikAndState.getState();
  if (Assertions.verifyAssertions) {
    Assertions._assert(refineFieldAccesses(field));
  }
  ikToFields.put(ikAndState,field);
  for (Iterator<? extends Object> iter=g.getPredNodes(ikAndState.getInstanceKey(),NewLabel.v()); iter.hasNext(); ) {
    PointerKey ikPred=(PointerKey)iter.next();
    PointerKeyAndState ikPredAndState=new PointerKeyAndState(ikPred,state);
    int mappedIndex=ikAndStates.getMappedIndex(ikAndState);
    if (Assertions.verifyAssertions) {
      Assertions._assert(mappedIndex != -1);
    }
    if (findOrCreate(pkToTrackedSet,ikPredAndState).add(mappedIndex)) {
      addToTrackedPToWorklist(ikPredAndState);
    }
  }
}","/** 
 * track a field of some instance key, as we are interested in statements that read or write to the field
 * @param ikAndState
 * @param field
 * @param ikToFields either {@link #forwInstKeyToFields} or {@link #backInstKeyToFields}
 */
private void trackInstanceField(InstanceKeyAndState ikAndState,IField field,MultiMap<InstanceKeyAndState,IField> ikToFields){
  State state=ikAndState.getState();
  if (Assertions.verifyAssertions) {
    Assertions._assert(refineFieldAccesses(field));
  }
  ikToFields.put(ikAndState,field);
  for (Iterator<? extends Object> iter=g.getPredNodes(ikAndState.getInstanceKey(),NewLabel.v()); iter.hasNext(); ) {
    PointerKey ikPred=(PointerKey)iter.next();
    PointerKeyAndState ikPredAndState=new PointerKeyAndState(ikPred,state);
    int mappedIndex=ikAndStates.getMappedIndex(ikAndState);
    if (Assertions.verifyAssertions) {
      Assertions._assert(mappedIndex != -1);
    }
    if (findOrCreate(pkToTrackedSet,ikPredAndState).add(mappedIndex)) {
      addToTrackedPToWorklist(ikPredAndState);
    }
  }
}",0.9990503323836656
100155,"/** 
 * @param curPkAndState
 * @param predPk
 * @param label the label of the edge from curPk to predPk (must be barred)
 * @return those {@link PointerKeyAndState}s whose points-to sets have been queried, such that the   {@link PointerKey} is predPk, andtransitioning from its state on <code>label.bar()</code> yields the state of <code>curPkAndState</code>
 */
Collection<PointerKeyAndState> matchingPToQueried(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  Collection<PointerKeyAndState> ret=ArraySet.make();
  if (Assertions.verifyAssertions) {
    Assertions._assert(label.isBarred());
  }
  IFlowLabel unbarredLabel=label.bar();
  final State curState=curPkAndState.getState();
  Set<State> predPkStates=pointsToQueried.get(predPk);
  for (  State predState : predPkStates) {
    State transState=stateMachine.transition(predState,unbarredLabel);
    if (transState.equals(curState)) {
      ret.add(new PointerKeyAndState(predPk,predState));
    }
  }
  return ret;
}","/** 
 * @param curPkAndState
 * @param predPk
 * @param label the label of the edge from curPk to predPk (must be barred)
 * @return those {@link PointerKeyAndState}s whose points-to sets have been queried, such that the  {@link PointerKey} is predPk, and transitioning from its state on <code>label.bar()</code> yields thestate of <code>curPkAndState</code>
 */
Collection<PointerKeyAndState> matchingPToQueried(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  Collection<PointerKeyAndState> ret=ArraySet.make();
  if (Assertions.verifyAssertions) {
    Assertions._assert(label.isBarred());
  }
  IFlowLabel unbarredLabel=label.bar();
  final State curState=curPkAndState.getState();
  Set<State> predPkStates=pointsToQueried.get(predPk);
  for (  State predState : predPkStates) {
    State transState=stateMachine.transition(predState,unbarredLabel);
    if (transState.equals(curState)) {
      ret.add(new PointerKeyAndState(predPk,predState));
    }
  }
  return ret;
}",0.9984992496248124
100156,"void handleCopy(PointerKeyAndState curPkAndState,PointerKeyAndState succPkAndState){
  if (!addToInitWorklist(succPkAndState)) {
    if (addAllToP2Set(pkToP2Set,curPkAndState,find(pkToP2Set,succPkAndState))) {
      addToPToWorklist(curPkAndState);
    }
  }
}","void handleCopy(PointerKeyAndState curPkAndState,PointerKeyAndState succPkAndState,IFlowLabel label){
  if (!addToInitWorklist(succPkAndState)) {
    if (addAllToP2Set(pkToP2Set,curPkAndState,find(pkToP2Set,succPkAndState),label)) {
      addToPToWorklist(curPkAndState);
    }
  }
}",0.9576427255985268
100157,"public void makePassOverFieldStmts(){
  for (  StoreEdge storeEdge : encounteredStores) {
    PointerKeyAndState storedValAndState=storeEdge.val;
    IField field=storeEdge.field;
    PointerKeyAndState baseAndState=storeEdge.base;
    IntSet trackedSet=find(pkToTrackedSet,baseAndState);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      if (forwInstKeyToFields.get(ikAndState).contains(field)) {
        if (!addToInitWorklist(storedValAndState)) {
          InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
          findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storedValAndState));
        }
      }
    }
  }
  for (  LoadEdge loadEdge : encounteredLoads) {
    PointerKeyAndState loadedValAndState=loadEdge.val;
    IField field=loadEdge.field;
    PointerKey basePointerKey=loadEdge.base.getPointerKey();
    State loadDstState=loadedValAndState.getState();
    PointerKeyAndState baseAndStateToHandle=new PointerKeyAndState(basePointerKey,loadDstState);
    if (Assertions.verifyAssertions) {
      boolean basePointerOkay=pointsToQueried.get(basePointerKey).contains(loadDstState) || !pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadDstState) || initWorklist.contains(loadedValAndState);
      Assertions._assert(basePointerOkay,""String_Node_Str"" + loadedValAndState + ""String_Node_Str""+ baseAndStateToHandle);
    }
    final IntSet curP2Set=find(pkToP2Set,baseAndStateToHandle);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(curP2Set)) {
      InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
      if (addAllToP2Set(pkToP2Set,loadedValAndState,find(instFieldKeyToP2Set,ifk))) {
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + loadEdge);
        }
        addToPToWorklist(loadedValAndState);
      }
    }
    PointerKeyAndState baseAndState=loadEdge.base;
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToTrackedSet,baseAndState))) {
      if (backInstKeyToFields.get(ikAndState).contains(field)) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedValAndState).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + loadEdge);
          }
          addToTrackedPToWorklist(loadedValAndState);
        }
      }
    }
  }
}","public void makePassOverFieldStmts(){
  for (  StoreEdge storeEdge : encounteredStores) {
    PointerKeyAndState storedValAndState=storeEdge.val;
    IField field=storeEdge.field;
    PointerKeyAndState baseAndState=storeEdge.base;
    IntSet trackedSet=find(pkToTrackedSet,baseAndState);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
      if (forwInstKeyToFields.get(ikAndState).contains(field)) {
        if (!addToInitWorklist(storedValAndState)) {
          InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
          findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storedValAndState));
        }
      }
    }
  }
  for (  LoadEdge loadEdge : encounteredLoads) {
    PointerKeyAndState loadedValAndState=loadEdge.val;
    IField field=loadEdge.field;
    PointerKey basePointerKey=loadEdge.base.getPointerKey();
    State loadDstState=loadedValAndState.getState();
    PointerKeyAndState baseAndStateToHandle=new PointerKeyAndState(basePointerKey,loadDstState);
    if (Assertions.verifyAssertions) {
      boolean basePointerOkay=pointsToQueried.get(basePointerKey).contains(loadDstState) || !pointsToQueried.get(loadedValAndState.getPointerKey()).contains(loadDstState) || initWorklist.contains(loadedValAndState);
      Assertions._assert(basePointerOkay,""String_Node_Str"" + loadedValAndState + ""String_Node_Str""+ baseAndStateToHandle);
    }
    final IntSet curP2Set=find(pkToP2Set,baseAndStateToHandle);
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(curP2Set)) {
      InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
      if (addAllToP2Set(pkToP2Set,loadedValAndState,find(instFieldKeyToP2Set,ifk),AssignLabel.noFilter())) {
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + loadEdge);
        }
        addToPToWorklist(loadedValAndState);
      }
    }
    PointerKeyAndState baseAndState=loadEdge.base;
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToTrackedSet,baseAndState))) {
      if (backInstKeyToFields.get(ikAndState).contains(field)) {
        InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
        if (findOrCreate(pkToTrackedSet,loadedValAndState).addAll(find(instFieldKeyToTrackedSet,ifk))) {
          if (DEBUG) {
            Trace.println(""String_Node_Str"" + loadEdge);
          }
          addToTrackedPToWorklist(loadedValAndState);
        }
      }
    }
  }
}",0.995258709544424
100158,"public void handleTrackedPointsToWorklist(){
  while (!trackedPointsToWorklist.isEmpty()) {
    incrementNumNodesTraversed();
    final PointerKeyAndState curPkAndState=trackedPointsToWorklist.iterator().next();
    trackedPointsToWorklist.remove(curPkAndState);
    final PointerKey curPk=curPkAndState.getPointerKey();
    final State curState=curPkAndState.getState();
    if (DEBUG)     Trace.println(""String_Node_Str"" + curPkAndState);
    final MutableIntSet trackedSet=find(pkToTrackedSet,curPkAndState);
    IFlowLabelVisitor succVisitor=new AbstractFlowLabelVisitor(){
      @Override public void visitPutField(      PutFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          for (          InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
            boolean needField=forwInstKeyToFields.get(ikAndState).contains(field);
            PointerKeyAndState storeDst=new PointerKeyAndState((PointerKey)dst,curState);
            encounteredStores.add(new StoreEdge(curPkAndState,field,storeDst));
            if (needField) {
              if (!addToInitWorklist(storeDst)) {
                InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
                findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storeDst));
              }
            }
          }
        }
      }
    }
;
    g.visitSuccs(curPk,succVisitor);
    IFlowLabelVisitor predVisitor=new AbstractFlowLabelVisitor(){
      @Override public void visitAssignGlobal(      AssignGlobalLabel label,      Object dst){
        for (Iterator<? extends Object> readIter=g.getReadsOfStaticField((StaticFieldKey)dst); readIter.hasNext(); ) {
          final PointerKey predPk=(PointerKey)readIter.next();
          doTransition(curState,AssignGlobalBarLabel.v(),new Function<State,Object>(){
            public Object apply(            State predPkState){
              PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
              if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
                addToTrackedPToWorklist(predPkAndState);
              }
              return null;
            }
          }
);
        }
      }
      @Override public void visitPutField(      PutFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          PointerKeyAndState storeBase=new PointerKeyAndState((PointerKey)dst,curState);
          encounteredStores.add(new StoreEdge(storeBase,field,curPkAndState));
          if (!addToInitWorklist(storeBase)) {
            for (            InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToP2Set,storeBase))) {
              InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
              findOrCreate(instFieldKeyToTrackedSet,ifk).addAll(trackedSet);
              trackInstanceField(ikAndState,field,backInstKeyToFields);
            }
          }
        }
 else {
          for (Iterator<PointerKey> readIter=g.getReadsOfInstanceField(field); readIter.hasNext(); ) {
            final PointerKey predPk=readIter.next();
            doTransition(curState,MatchBarLabel.v(),new Function<State,Object>(){
              public Object apply(              State predPkState){
                PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
                if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
                  addToTrackedPToWorklist(predPkAndState);
                }
                return null;
              }
            }
);
          }
        }
      }
      @Override public void visitGetField(      GetFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          for (          InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
            boolean needField=backInstKeyToFields.get(ikAndState).contains(field);
            PointerKeyAndState loadedVal=new PointerKeyAndState((PointerKey)dst,curState);
            addEncounteredLoad(new LoadEdge(curPkAndState,field,loadedVal));
            if (needField) {
              InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
              if (findOrCreate(pkToTrackedSet,loadedVal).addAll(find(instFieldKeyToTrackedSet,ifk))) {
                addToTrackedPToWorklist(loadedVal);
              }
            }
          }
        }
      }
      @Override public void visitAssign(      AssignLabel label,      Object dst){
        final PointerKey predPk=(PointerKey)dst;
        doTransition(curState,AssignBarLabel.v(),new Function<State,Object>(){
          public Object apply(          State predPkState){
            PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
            if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
              addToTrackedPToWorklist(predPkAndState);
            }
            return null;
          }
        }
);
      }
    }
;
    g.visitPreds(curPk,predVisitor);
    handleBackInterproc(curPkAndState,new CopyHandler(){
      @Override void handle(      PointerKeyAndState src,      final PointerKey dst,      IFlowLabel label){
        if (Assertions.verifyAssertions) {
          Assertions._assert(src == curPkAndState);
        }
        doTransition(curState,label,new Function<State,Object>(){
          public Object apply(          State dstState){
            PointerKeyAndState dstAndState=new PointerKeyAndState(dst,dstState);
            if (findOrCreate(pkToTrackedSet,dstAndState).addAll(trackedSet)) {
              addToTrackedPToWorklist(dstAndState);
            }
            return null;
          }
        }
);
      }
    }
,true);
  }
}","public void handleTrackedPointsToWorklist(){
  while (!trackedPointsToWorklist.isEmpty()) {
    incrementNumNodesTraversed();
    final PointerKeyAndState curPkAndState=trackedPointsToWorklist.iterator().next();
    trackedPointsToWorklist.remove(curPkAndState);
    final PointerKey curPk=curPkAndState.getPointerKey();
    final State curState=curPkAndState.getState();
    if (DEBUG)     Trace.println(""String_Node_Str"" + curPkAndState);
    final MutableIntSet trackedSet=find(pkToTrackedSet,curPkAndState);
    IFlowLabelVisitor succVisitor=new AbstractFlowLabelVisitor(){
      @Override public void visitPutField(      PutFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          for (          InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
            boolean needField=forwInstKeyToFields.get(ikAndState).contains(field);
            PointerKeyAndState storeDst=new PointerKeyAndState((PointerKey)dst,curState);
            encounteredStores.add(new StoreEdge(curPkAndState,field,storeDst));
            if (needField) {
              if (!addToInitWorklist(storeDst)) {
                InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
                findOrCreate(instFieldKeyToP2Set,ifk).addAll(find(pkToP2Set,storeDst));
              }
            }
          }
        }
      }
    }
;
    g.visitSuccs(curPk,succVisitor);
    IFlowLabelVisitor predVisitor=new AbstractFlowLabelVisitor(){
      @Override public void visitAssignGlobal(      AssignGlobalLabel label,      Object dst){
        for (Iterator<? extends Object> readIter=g.getReadsOfStaticField((StaticFieldKey)dst); readIter.hasNext(); ) {
          final PointerKey predPk=(PointerKey)readIter.next();
          doTransition(curState,AssignGlobalBarLabel.v(),new Function<State,Object>(){
            public Object apply(            State predPkState){
              PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
              if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
                addToTrackedPToWorklist(predPkAndState);
              }
              return null;
            }
          }
);
        }
      }
      @Override public void visitPutField(      PutFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          PointerKeyAndState storeBase=new PointerKeyAndState((PointerKey)dst,curState);
          encounteredStores.add(new StoreEdge(storeBase,field,curPkAndState));
          if (!addToInitWorklist(storeBase)) {
            for (            InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToP2Set,storeBase))) {
              InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
              findOrCreate(instFieldKeyToTrackedSet,ifk).addAll(trackedSet);
              trackInstanceField(ikAndState,field,backInstKeyToFields);
            }
          }
        }
 else {
          for (Iterator<PointerKey> readIter=g.getReadsOfInstanceField(field); readIter.hasNext(); ) {
            final PointerKey predPk=readIter.next();
            doTransition(curState,MatchBarLabel.v(),new Function<State,Object>(){
              public Object apply(              State predPkState){
                PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
                if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
                  addToTrackedPToWorklist(predPkAndState);
                }
                return null;
              }
            }
);
          }
        }
      }
      @Override public void visitGetField(      GetFieldLabel label,      Object dst){
        IField field=label.getField();
        if (refineFieldAccesses(field)) {
          for (          InstanceKeyAndState ikAndState : makeOrdinalSet(trackedSet)) {
            boolean needField=backInstKeyToFields.get(ikAndState).contains(field);
            PointerKeyAndState loadedVal=new PointerKeyAndState((PointerKey)dst,curState);
            addEncounteredLoad(new LoadEdge(curPkAndState,field,loadedVal));
            if (needField) {
              InstanceFieldKeyAndState ifk=getInstFieldKey(ikAndState,field);
              if (findOrCreate(pkToTrackedSet,loadedVal).addAll(find(instFieldKeyToTrackedSet,ifk))) {
                addToTrackedPToWorklist(loadedVal);
              }
            }
          }
        }
      }
      @Override public void visitAssign(      AssignLabel label,      Object dst){
        final PointerKey predPk=(PointerKey)dst;
        doTransition(curState,AssignBarLabel.noFilter(),new Function<State,Object>(){
          public Object apply(          State predPkState){
            PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
            if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
              addToTrackedPToWorklist(predPkAndState);
            }
            return null;
          }
        }
);
      }
    }
;
    g.visitPreds(curPk,predVisitor);
    handleBackInterproc(curPkAndState,new CopyHandler(){
      @Override void handle(      PointerKeyAndState src,      final PointerKey dst,      IFlowLabel label){
        if (Assertions.verifyAssertions) {
          Assertions._assert(src == curPkAndState);
        }
        doTransition(curState,label,new Function<State,Object>(){
          public Object apply(          State dstState){
            PointerKeyAndState dstAndState=new PointerKeyAndState(dst,dstState);
            if (findOrCreate(pkToTrackedSet,dstAndState).addAll(trackedSet)) {
              addToTrackedPToWorklist(dstAndState);
            }
            return null;
          }
        }
);
      }
    }
,true);
  }
}",0.9992263388635776
100159,"void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  for (  PointerKeyAndState predPkAndState : matchingPToQueried(curPkAndState,predPk,label)) {
    if (addAllToP2Set(pkToP2Set,predPkAndState,find(pkToP2Set,curPkAndState))) {
      addToPToWorklist(predPkAndState);
    }
  }
}","void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  for (  PointerKeyAndState predPkAndState : matchingPToQueried(curPkAndState,predPk,label)) {
    if (addAllToP2Set(pkToP2Set,predPkAndState,find(pkToP2Set,curPkAndState),label)) {
      addToPToWorklist(predPkAndState);
    }
  }
}",0.990625
100160,"void handleInitWorklist(){
  while (!initWorklist.isEmpty()) {
    incrementNumNodesTraversed();
    final PointerKeyAndState curPkAndState=initWorklist.iterator().next();
    initWorklist.remove(curPkAndState);
    final PointerKey curPk=curPkAndState.getPointerKey();
    final State curState=curPkAndState.getState();
    if (DEBUG)     Trace.println(""String_Node_Str"" + curPkAndState);
    if (Assertions.verifyAssertions && curPk instanceof LocalPointerKey) {
      Assertions._assert(g.hasSubgraphForNode(((LocalPointerKey)curPk).getNode()));
    }
    IFlowLabelVisitor v=new AbstractFlowLabelVisitor(){
      @Override public void visitNew(      NewLabel label,      Object dst){
        final InstanceKey ik=(InstanceKey)dst;
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + ik + ""String_Node_Str""+ curPk);
        }
        doTransition(curState,label,new Function<State,Object>(){
          public Object apply(          State newState){
            InstanceKeyAndState ikAndState=new InstanceKeyAndState(ik,newState);
            int n=ikAndStates.add(ikAndState);
            findOrCreate(pkToP2Set,curPkAndState).add(n);
            addToPToWorklist(curPkAndState);
            return null;
          }
        }
);
      }
      @Override public void visitGetField(      GetFieldLabel label,      Object dst){
        IField field=(label).getField();
        if (refineFieldAccesses(field)) {
          PointerKey loadBase=(PointerKey)dst;
          PointerKeyAndState loadBaseAndState=new PointerKeyAndState(loadBase,curState);
          addEncounteredLoad(new LoadEdge(loadBaseAndState,field,curPkAndState));
          if (!addToInitWorklist(loadBaseAndState)) {
            for (            InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToP2Set,loadBaseAndState))) {
              trackInstanceField(ikAndState,field,forwInstKeyToFields);
            }
          }
        }
 else {
          handleAllCopies(curPkAndState,g.getWritesToInstanceField(field),MatchLabel.v());
        }
      }
      @Override public void visitAssignGlobal(      AssignGlobalLabel label,      Object dst){
        handleAllCopies(curPkAndState,g.getWritesToStaticField((StaticFieldKey)dst),AssignGlobalLabel.v());
      }
      @Override public void visitAssign(      AssignLabel label,      Object dst){
        handleCopy(curPkAndState,(PointerKey)dst,AssignLabel.v());
      }
    }
;
    g.visitSuccs(curPk,v);
    handleForwInterproc(curPkAndState,new CopyHandler(){
      @Override void handle(      PointerKeyAndState src,      PointerKey dst,      IFlowLabel label){
        handleCopy(src,dst,label);
      }
    }
);
  }
}","void handleInitWorklist(){
  while (!initWorklist.isEmpty()) {
    incrementNumNodesTraversed();
    final PointerKeyAndState curPkAndState=initWorklist.iterator().next();
    initWorklist.remove(curPkAndState);
    final PointerKey curPk=curPkAndState.getPointerKey();
    final State curState=curPkAndState.getState();
    if (DEBUG)     Trace.println(""String_Node_Str"" + curPkAndState);
    if (Assertions.verifyAssertions && curPk instanceof LocalPointerKey) {
      Assertions._assert(g.hasSubgraphForNode(((LocalPointerKey)curPk).getNode()));
    }
    IFlowLabelVisitor v=new AbstractFlowLabelVisitor(){
      @Override public void visitNew(      NewLabel label,      Object dst){
        final InstanceKey ik=(InstanceKey)dst;
        if (DEBUG) {
          Trace.println(""String_Node_Str"" + ik + ""String_Node_Str""+ curPk);
        }
        doTransition(curState,label,new Function<State,Object>(){
          public Object apply(          State newState){
            InstanceKeyAndState ikAndState=new InstanceKeyAndState(ik,newState);
            int n=ikAndStates.add(ikAndState);
            findOrCreate(pkToP2Set,curPkAndState).add(n);
            addToPToWorklist(curPkAndState);
            return null;
          }
        }
);
      }
      @Override public void visitGetField(      GetFieldLabel label,      Object dst){
        IField field=(label).getField();
        if (refineFieldAccesses(field)) {
          PointerKey loadBase=(PointerKey)dst;
          PointerKeyAndState loadBaseAndState=new PointerKeyAndState(loadBase,curState);
          addEncounteredLoad(new LoadEdge(loadBaseAndState,field,curPkAndState));
          if (!addToInitWorklist(loadBaseAndState)) {
            for (            InstanceKeyAndState ikAndState : makeOrdinalSet(find(pkToP2Set,loadBaseAndState))) {
              trackInstanceField(ikAndState,field,forwInstKeyToFields);
            }
          }
        }
 else {
          handleAllCopies(curPkAndState,g.getWritesToInstanceField(field),MatchLabel.v());
        }
      }
      @Override public void visitAssignGlobal(      AssignGlobalLabel label,      Object dst){
        handleAllCopies(curPkAndState,g.getWritesToStaticField((StaticFieldKey)dst),AssignGlobalLabel.v());
      }
      @Override public void visitAssign(      AssignLabel label,      Object dst){
        handleCopy(curPkAndState,(PointerKey)dst,AssignLabel.noFilter());
      }
    }
;
    g.visitSuccs(curPk,v);
    handleForwInterproc(curPkAndState,new CopyHandler(){
      @Override void handle(      PointerKeyAndState src,      PointerKey dst,      IFlowLabel label){
        handleCopy(src,dst,label);
      }
    }
);
  }
}",0.9983079526226736
100161,"/** 
 * handle flow from return value to callers, or from actual to formals
 * @param curPkAndState
 * @param handler
 */
private void handleBackInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler,final boolean addGraphs){
  final PointerKey curPk=curPkAndState.getPointerKey();
  final State curState=curPkAndState.getState();
  if (curPk instanceof ReturnValueKey) {
    final ReturnValueKey returnKey=(ReturnValueKey)curPk;
    if (DEBUG) {
      Trace.println(""String_Node_Str"");
    }
    final CGNode callee=returnKey.getNode();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + callee);
    }
    final boolean isExceptional=returnKey instanceof ExceptionReturnValueKey;
    for (    final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(returnKey)) {
      final CGNode caller=callSiteAndCGNode.getCGNode();
      final IR ir=getIR(caller);
      if (ir == null)       continue;
      final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
      if (!addGraphs) {
        if (!g.hasSubgraphForNode(caller)) {
          continue;
        }
      }
      final ReturnBarLabel returnBarLabel=ReturnBarLabel.make(callSiteAndCGNode);
      doTransition(curState,returnBarLabel,new Function<State,Object>(){
        private void propagateToCaller(){
          g.addSubgraphForNode(caller);
          SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
          for (int i=0; i < callInstrs.length; i++) {
            SSAAbstractInvokeInstruction callInstr=callInstrs[i];
            PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(returnAtCallerKey));
              Assertions._assert(g.containsNode(returnKey));
            }
            handler.handle(curPkAndState,returnAtCallerKey,returnBarLabel);
          }
        }
        public Object apply(        State callerState){
          Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call);
          if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
            propagateToCaller();
          }
 else {
            if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
              propagateToCaller();
            }
 else {
              queryCallTargets(callSiteAndCGNode,ir,callerState);
            }
          }
          return null;
        }
      }
);
    }
  }
  if (curPk instanceof LocalPointerKey) {
    LocalPointerKey localPk=(LocalPointerKey)curPk;
    CGNode caller=localPk.getNode();
    for (Iterator<SSAInvokeInstruction> iter=g.getInstrsPassingParam(localPk); iter.hasNext(); ) {
      SSAInvokeInstruction callInstr=iter.next();
      for (int i=0; i < callInstr.getNumberOfUses(); i++) {
        if (localPk.getValueNumber() != callInstr.getUse(i))         continue;
        CallSiteReference callSiteRef=callInstr.getCallSite();
        CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
        Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef);
        if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
          for (          CGNode callee : possibleCallees) {
            if (!addGraphs) {
              if (!g.hasSubgraphForNode(callee)) {
                continue;
              }
            }
            if (callee.getIR() == null) {
              continue;
            }
            g.addSubgraphForNode(callee);
            PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(paramVal));
            }
            handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
          }
        }
 else {
          if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
            Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
            for (            CGNode callee : possibleCallees) {
              if (targetMethods.contains(callee.getMethod())) {
                if (caller.getIR() == null) {
                  continue;
                }
                g.addSubgraphForNode(callee);
                PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(g.containsNode(paramVal));
                }
                handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
              }
            }
          }
 else {
            queryCallTargets(callSiteAndCGNode,getIR(caller),curState);
          }
        }
      }
    }
  }
}","/** 
 * handle flow from return value to callers, or from actual to formals
 * @param curPkAndState
 * @param handler
 */
private void handleBackInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler,final boolean addGraphs){
  final PointerKey curPk=curPkAndState.getPointerKey();
  final State curState=curPkAndState.getState();
  if (curPk instanceof ReturnValueKey) {
    final ReturnValueKey returnKey=(ReturnValueKey)curPk;
    if (DEBUG) {
      Trace.println(""String_Node_Str"");
    }
    final CGNode callee=returnKey.getNode();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + callee);
    }
    final boolean isExceptional=returnKey instanceof ExceptionReturnValueKey;
    for (    final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(returnKey)) {
      final CGNode caller=callSiteAndCGNode.getCGNode();
      final IR ir=getIR(caller);
      if (ir == null)       continue;
      final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
      if (!addGraphs) {
        if (!g.hasSubgraphForNode(caller)) {
          continue;
        }
      }
      final ReturnBarLabel returnBarLabel=ReturnBarLabel.make(callSiteAndCGNode);
      doTransition(curState,returnBarLabel,new Function<State,Object>(){
        private void propagateToCaller(){
          g.addSubgraphForNode(caller);
          SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
          for (int i=0; i < callInstrs.length; i++) {
            SSAAbstractInvokeInstruction callInstr=callInstrs[i];
            PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(returnAtCallerKey));
              Assertions._assert(g.containsNode(returnKey));
            }
            handler.handle(curPkAndState,returnAtCallerKey,returnBarLabel);
          }
        }
        public Object apply(        State callerState){
          SSAAbstractInvokeInstruction callInstr=ir.getCalls(call)[0];
          PointerKey returnAtCallerKey=heapModel.getPointerKeyForLocal(caller,isExceptional ? callInstr.getException() : callInstr.getDef());
          Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call,(LocalPointerKey)returnAtCallerKey);
          if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
            propagateToCaller();
          }
 else {
            if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
              propagateToCaller();
            }
 else {
              queryCallTargets(callSiteAndCGNode,ir,callerState);
            }
          }
          return null;
        }
      }
);
    }
  }
  if (curPk instanceof LocalPointerKey) {
    LocalPointerKey localPk=(LocalPointerKey)curPk;
    CGNode caller=localPk.getNode();
    for (Iterator<SSAInvokeInstruction> iter=g.getInstrsPassingParam(localPk); iter.hasNext(); ) {
      SSAInvokeInstruction callInstr=iter.next();
      for (int i=0; i < callInstr.getNumberOfUses(); i++) {
        if (localPk.getValueNumber() != callInstr.getUse(i))         continue;
        CallSiteReference callSiteRef=callInstr.getCallSite();
        CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
        Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef,localPk);
        if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
          for (          CGNode callee : possibleCallees) {
            if (!addGraphs) {
              if (!g.hasSubgraphForNode(callee)) {
                continue;
              }
            }
            if (callee.getIR() == null) {
              continue;
            }
            g.addSubgraphForNode(callee);
            PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
            if (Assertions.verifyAssertions) {
              Assertions._assert(g.containsNode(paramVal));
            }
            handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
          }
        }
 else {
          if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
            Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
            for (            CGNode callee : possibleCallees) {
              if (targetMethods.contains(callee.getMethod())) {
                if (caller.getIR() == null) {
                  continue;
                }
                g.addSubgraphForNode(callee);
                PointerKey paramVal=heapModel.getPointerKeyForLocal(callee,i + 1);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(g.containsNode(paramVal));
                }
                handler.handle(curPkAndState,paramVal,ParamBarLabel.make(callSiteAndCGNode));
              }
            }
          }
 else {
            queryCallTargets(callSiteAndCGNode,getIR(caller),curState);
          }
        }
      }
    }
  }
}",0.9737758656013112
100162,"/** 
 * handle possible updated flow in both directions for a call parameter
 * @param src
 * @param dst
 */
private void repropCallArg(PointerKeyAndState src,PointerKeyAndState dst,IFlowLabel dstToSrcLabel){
  for (  PointerKeyAndState srcToHandle : matchingPToQueried(dst,src.getPointerKey(),dstToSrcLabel)) {
    handleCopy(srcToHandle,dst);
  }
  IntSet trackedSet=find(pkToTrackedSet,dst);
  if (!trackedSet.isEmpty()) {
    if (findOrCreate(pkToTrackedSet,src).addAll(trackedSet)) {
      addToTrackedPToWorklist(src);
    }
  }
}","/** 
 * handle possible updated flow in both directions for a call parameter
 * @param src
 * @param dst
 */
private void repropCallArg(PointerKeyAndState src,PointerKeyAndState dst,IFlowLabel dstToSrcLabel){
  for (  PointerKeyAndState srcToHandle : matchingPToQueried(dst,src.getPointerKey(),dstToSrcLabel)) {
    handleCopy(srcToHandle,dst,dstToSrcLabel.bar());
  }
  IntSet trackedSet=find(pkToTrackedSet,dst);
  if (!trackedSet.isEmpty()) {
    if (findOrCreate(pkToTrackedSet,src).addAll(trackedSet)) {
      addToTrackedPToWorklist(src);
    }
  }
}",0.9816849816849816
100163,"@Override public void visitAssign(AssignLabel label,Object dst){
  final PointerKey predPk=(PointerKey)dst;
  doTransition(curState,AssignBarLabel.v(),new Function<State,Object>(){
    public Object apply(    State predPkState){
      PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
      if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
        addToTrackedPToWorklist(predPkAndState);
      }
      return null;
    }
  }
);
}","@Override public void visitAssign(AssignLabel label,Object dst){
  final PointerKey predPk=(PointerKey)dst;
  doTransition(curState,AssignBarLabel.noFilter(),new Function<State,Object>(){
    public Object apply(    State predPkState){
      PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,predPkState);
      if (findOrCreate(pkToTrackedSet,predPkAndState).addAll(trackedSet)) {
        addToTrackedPToWorklist(predPkAndState);
      }
      return null;
    }
  }
);
}",0.9906735751295336
100164,"/** 
 * handle flow from actuals to formals, and from returned values to variables at the caller
 * @param curPk
 * @param handler
 */
private void handleForwInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler){
  PointerKey curPk=curPkAndState.getPointerKey();
  if (curPk instanceof LocalPointerKey) {
    final LocalPointerKey localPk=(LocalPointerKey)curPk;
    if (g.isParam(localPk)) {
      final CGNode callee=localPk.getNode();
      final int paramPos=localPk.getValueNumber() - 1;
      for (      final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(localPk)) {
        final CGNode caller=callSiteAndCGNode.getCGNode();
        final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
        final IR ir=getIR(caller);
        final ParamLabel paramLabel=ParamLabel.make(callSiteAndCGNode);
        doTransition(curPkAndState.getState(),paramLabel,new Function<State,Object>(){
          private void propagateToCallee(){
            if (caller.getIR() == null) {
              return;
            }
            g.addSubgraphForNode(caller);
            SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
            for (int i=0; i < callInstrs.length; i++) {
              SSAAbstractInvokeInstruction callInstr=callInstrs[i];
              PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
              if (Assertions.verifyAssertions) {
                Assertions._assert(g.containsNode(actualPk));
                Assertions._assert(g.containsNode(localPk));
              }
              handler.handle(curPkAndState,actualPk,paramLabel);
            }
          }
          public Object apply(          State callerState){
            Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call);
            if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
              propagateToCallee();
            }
 else {
              if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
                propagateToCallee();
              }
 else {
                queryCallTargets(callSiteAndCGNode,ir,callerState);
              }
            }
            return null;
          }
        }
);
      }
    }
    SSAInvokeInstruction callInstr=g.getInstrReturningTo(localPk);
    if (callInstr != null) {
      CGNode caller=localPk.getNode();
      boolean isExceptional=localPk.getValueNumber() == callInstr.getException();
      CallSiteReference callSiteRef=callInstr.getCallSite();
      CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
      Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef);
      if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
        for (        CGNode callee : possibleCallees) {
          if (callee.getIR() == null) {
            continue;
          }
          g.addSubgraphForNode(callee);
          PointerKey retVal=isExceptional ? heapModel.getPointerKeyForExceptionalReturnValue(callee) : heapModel.getPointerKeyForReturnValue(callee);
          if (Assertions.verifyAssertions) {
            Assertions._assert(g.containsNode(retVal));
          }
          handler.handle(curPkAndState,retVal,ReturnLabel.make(callSiteAndCGNode));
        }
      }
 else {
        if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
          Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
          for (          CGNode callee : possibleCallees) {
            if (targetMethods.contains(callee.getMethod())) {
              if (callee.getIR() == null) {
                continue;
              }
              g.addSubgraphForNode(callee);
              PointerKey retVal=isExceptional ? heapModel.getPointerKeyForExceptionalReturnValue(callee) : heapModel.getPointerKeyForReturnValue(callee);
              if (Assertions.verifyAssertions) {
                Assertions._assert(g.containsNode(retVal));
              }
              handler.handle(curPkAndState,retVal,ReturnLabel.make(callSiteAndCGNode));
            }
          }
        }
 else {
          queryCallTargets(callSiteAndCGNode,getIR(caller),curPkAndState.getState());
        }
      }
    }
  }
}","/** 
 * handle flow from actuals to formals, and from returned values to variables at the caller
 * @param curPk
 * @param handler
 */
private void handleForwInterproc(final PointerKeyAndState curPkAndState,final CopyHandler handler){
  PointerKey curPk=curPkAndState.getPointerKey();
  if (curPk instanceof LocalPointerKey) {
    final LocalPointerKey localPk=(LocalPointerKey)curPk;
    if (g.isParam(localPk)) {
      final CGNode callee=localPk.getNode();
      final int paramPos=localPk.getValueNumber() - 1;
      for (      final CallSiteAndCGNode callSiteAndCGNode : g.getPotentialCallers(localPk)) {
        final CGNode caller=callSiteAndCGNode.getCGNode();
        final CallSiteReference call=callSiteAndCGNode.getCallSiteReference();
        final IR ir=getIR(caller);
        if (ir == null)         continue;
        final ParamLabel paramLabel=ParamLabel.make(callSiteAndCGNode);
        doTransition(curPkAndState.getState(),paramLabel,new Function<State,Object>(){
          private void propagateToCallee(){
            g.addSubgraphForNode(caller);
            SSAAbstractInvokeInstruction[] callInstrs=ir.getCalls(call);
            for (int i=0; i < callInstrs.length; i++) {
              SSAAbstractInvokeInstruction callInstr=callInstrs[i];
              PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
              if (Assertions.verifyAssertions) {
                Assertions._assert(g.containsNode(actualPk));
                Assertions._assert(g.containsNode(localPk));
              }
              handler.handle(curPkAndState,actualPk,paramLabel);
            }
          }
          public Object apply(          State callerState){
            SSAAbstractInvokeInstruction callInstr=ir.getCalls(call)[0];
            PointerKey actualPk=heapModel.getPointerKeyForLocal(caller,callInstr.getUse(paramPos));
            Set<CGNode> possibleTargets=g.getPossibleTargets(caller,call,(LocalPointerKey)actualPk);
            if (noOnTheFlyNeeded(callSiteAndCGNode,possibleTargets)) {
              propagateToCallee();
            }
 else {
              if (callToOTFTargets.get(callSiteAndCGNode).contains(callee.getMethod())) {
                propagateToCallee();
              }
 else {
                queryCallTargets(callSiteAndCGNode,ir,callerState);
              }
            }
            return null;
          }
        }
);
      }
    }
    SSAInvokeInstruction callInstr=g.getInstrReturningTo(localPk);
    if (callInstr != null) {
      CGNode caller=localPk.getNode();
      boolean isExceptional=localPk.getValueNumber() == callInstr.getException();
      CallSiteReference callSiteRef=callInstr.getCallSite();
      CallSiteAndCGNode callSiteAndCGNode=new CallSiteAndCGNode(callSiteRef,caller);
      Set<CGNode> possibleCallees=g.getPossibleTargets(caller,callSiteRef,localPk);
      if (noOnTheFlyNeeded(callSiteAndCGNode,possibleCallees)) {
        for (        CGNode callee : possibleCallees) {
          if (callee.getIR() == null) {
            continue;
          }
          g.addSubgraphForNode(callee);
          PointerKey retVal=isExceptional ? heapModel.getPointerKeyForExceptionalReturnValue(callee) : heapModel.getPointerKeyForReturnValue(callee);
          if (Assertions.verifyAssertions) {
            Assertions._assert(g.containsNode(retVal));
          }
          handler.handle(curPkAndState,retVal,ReturnLabel.make(callSiteAndCGNode));
        }
      }
 else {
        if (callToOTFTargets.containsKey(callSiteAndCGNode)) {
          Set<IMethod> targetMethods=callToOTFTargets.get(callSiteAndCGNode);
          for (          CGNode callee : possibleCallees) {
            if (targetMethods.contains(callee.getMethod())) {
              if (callee.getIR() == null) {
                continue;
              }
              g.addSubgraphForNode(callee);
              PointerKey retVal=isExceptional ? heapModel.getPointerKeyForExceptionalReturnValue(callee) : heapModel.getPointerKeyForReturnValue(callee);
              if (Assertions.verifyAssertions) {
                Assertions._assert(g.containsNode(retVal));
              }
              handler.handle(curPkAndState,retVal,ReturnLabel.make(callSiteAndCGNode));
            }
          }
        }
 else {
          queryCallTargets(callSiteAndCGNode,getIR(caller),curPkAndState.getState());
        }
      }
    }
  }
}",0.962078163052302
100165,"private boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals){
}","private boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals,IFlowLabel label){
  final PointerKey pk=pkAndState.getPointerKey();
  if (pk instanceof FilteredPointerKey) {
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + pk);
    }
    final TypeFilter typeFilter=((FilteredPointerKey)pk).getTypeFilter();
    vals=updateValsForFilter(vals,typeFilter);
  }
  if (label instanceof IFlowLabelWithFilter) {
    TypeFilter typeFilter=((IFlowLabelWithFilter)label).getFilter();
    if (typeFilter != null) {
      vals=updateValsForFilter(vals,typeFilter);
    }
  }
  boolean added=findOrCreate(p2setMap,pkAndState).addAll(vals);
  if (DEBUG && added) {
    Trace.println(""String_Node_Str"" + pkAndState + ""String_Node_Str"");
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(vals)) {
      Trace.println(ikAndState);
    }
    Trace.println(""String_Node_Str"");
  }
  return added;
}",0.2265552460538533
100166,"public AbstractDemandFlowGraph(final CallGraph cg,final HeapModel heapModel,final MemoryAccessMap mam,final ClassHierarchy cha){
  this.cg=cg;
  this.heapModel=heapModel;
  this.mam=mam;
  this.cha=cha;
}","public AbstractDemandFlowGraph(final CallGraph cg,final HeapModel heapModel,final MemoryAccessMap mam,final ClassHierarchy cha){
  super(mam,heapModel);
  this.cg=cg;
  this.cha=cha;
}",0.8247422680412371
100167,"public Set<CGNode> getPossibleTargets(CGNode node,CallSiteReference site){
  return cg.getPossibleTargets(node,site);
}","public Set<CGNode> getPossibleTargets(CGNode node,CallSiteReference site,LocalPointerKey actualPk){
  return cg.getPossibleTargets(node,site);
}",0.9049429657794676
100168,"private void addPhiConstraints(CGNode node,ControlFlowGraph<ISSABasicBlock> cfg,ISSABasicBlock b){
  for (Iterator<? extends IBasicBlock> iter=cfg.getSuccNodes(b); iter.hasNext(); ) {
    ISSABasicBlock sb=(ISSABasicBlock)iter.next();
    if (sb.isExitBlock()) {
      continue;
    }
    int n=0;
    for (Iterator<? extends IBasicBlock> back=cfg.getPredNodes(sb); back.hasNext(); n++) {
      if (back.next() == b) {
        break;
      }
    }
    if (DEBUG && Assertions.verifyAssertions) {
      Assertions._assert(n < cfg.getPredNodeCount(sb));
    }
    for (Iterator<SSAPhiInstruction> phis=sb.iteratePhis(); phis.hasNext(); ) {
      SSAPhiInstruction phi=phis.next();
      if (phi == null) {
        continue;
      }
      PointerKey def=heapModel.getPointerKeyForLocal(node,phi.getDef());
      if (phi.getUse(n) > 0) {
        PointerKey use=heapModel.getPointerKeyForLocal(node,phi.getUse(n));
        addNode(def);
        addNode(use);
        addEdge(def,use,AssignLabel.v());
      }
    }
  }
}","private void addPhiConstraints(CGNode node,ControlFlowGraph<ISSABasicBlock> cfg,ISSABasicBlock b){
  for (Iterator<? extends IBasicBlock> iter=cfg.getSuccNodes(b); iter.hasNext(); ) {
    ISSABasicBlock sb=(ISSABasicBlock)iter.next();
    if (sb.isExitBlock()) {
      continue;
    }
    int n=0;
    for (Iterator<? extends IBasicBlock> back=cfg.getPredNodes(sb); back.hasNext(); n++) {
      if (back.next() == b) {
        break;
      }
    }
    if (DEBUG && Assertions.verifyAssertions) {
      Assertions._assert(n < cfg.getPredNodeCount(sb));
    }
    for (Iterator<SSAPhiInstruction> phis=sb.iteratePhis(); phis.hasNext(); ) {
      SSAPhiInstruction phi=phis.next();
      if (phi == null) {
        continue;
      }
      PointerKey def=heapModel.getPointerKeyForLocal(node,phi.getDef());
      if (phi.getUse(n) > 0) {
        PointerKey use=heapModel.getPointerKeyForLocal(node,phi.getUse(n));
        addNode(def);
        addNode(use);
        addEdge(def,use,AssignLabel.noFilter());
      }
    }
  }
}",0.9955817378497792
100169,"/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<TypeReference> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.v());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.v());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            addNode(exceptionVar);
            addNode(ik);
            addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}","/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
protected void addExceptionDefConstraints(IR ir,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<TypeReference> catchClasses){
  for (Iterator<ProgramCounter> it=peis.iterator(); it.hasNext(); ) {
    ProgramCounter peiLoc=it.next();
    SSAInstruction pei=ir.getPEI(peiLoc);
    if (pei instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction s=(SSAAbstractInvokeInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
 else     if (pei instanceof SSAAbstractThrowInstruction) {
      SSAAbstractThrowInstruction s=(SSAAbstractThrowInstruction)pei;
      PointerKey e=heapModel.getPointerKeyForLocal(node,s.getException());
      addNode(exceptionVar);
      addNode(e);
      addEdge(exceptionVar,e,AssignLabel.noFilter());
    }
    Collection<TypeReference> types=pei.getExceptionTypes();
    if (types != null) {
      for (Iterator<TypeReference> it2=types.iterator(); it2.hasNext(); ) {
        TypeReference type=it2.next();
        if (type != null) {
          InstanceKey ik=heapModel.getInstanceKeyForPEI(node,peiLoc,type);
          if (Assertions.verifyAssertions) {
            if (!(ik instanceof ConcreteTypeKey)) {
              Assertions._assert(ik instanceof ConcreteTypeKey,""String_Node_Str"" + ik);
            }
          }
          ConcreteTypeKey ck=(ConcreteTypeKey)ik;
          IClass klass=ck.getType();
          if (PropagationCallGraphBuilder.catches(catchClasses,klass,cha)) {
            addNode(exceptionVar);
            addNode(ik);
            addEdge(exceptionVar,ik,NewLabel.v());
          }
        }
      }
    }
  }
}",0.9955839057899902
100170,"public static ApplicationWindow run(String classpath){
  try {
    AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(classpath,new File(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    Graph<IClass> g=typeHierarchy2Graph(cha);
    g=pruneForAppLoader(g);
    final SWTTreeViewer v=new SWTTreeViewer();
    v.setGraphInput(g);
    Collection<IClass> roots=InferGraphRoots.inferRoots(g);
    if (roots.size() < 1) {
      System.err.println(""String_Node_Str"" + roots.size());
      System.exit(-1);
    }
    v.setRootsInput(roots);
    v.run();
    return v.getApplicationWindow();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","public static ApplicationWindow run(String classpath){
  try {
    AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(classpath,FileProvider.getFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    Graph<IClass> g=typeHierarchy2Graph(cha);
    g=pruneForAppLoader(g);
    final SWTTreeViewer v=new SWTTreeViewer();
    v.setGraphInput(g);
    Collection<IClass> roots=InferGraphRoots.inferRoots(g);
    if (roots.size() < 1) {
      System.err.println(""String_Node_Str"" + roots.size());
      System.exit(-1);
    }
    v.setRootsInput(roots);
    v.run();
    return v.getApplicationWindow();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}",0.9863013698630136
100171,"public boolean hasEdge(Statement src,Statement dst){
  addPDGStatementNodes(src.getNode());
  addPDGStatementNodes(dst.getNode());
switch (src.getKind()) {
case NORMAL:
    if (cOptions.equals(ControlDependenceOptions.NONE)) {
      return getPDG(src.getNode()).hasEdge(src,dst);
    }
 else {
      NormalStatement ns=(NormalStatement)src;
      if (dst instanceof MethodEntryStatement) {
        if (ns.getInstruction() instanceof SSAAbstractInvokeInstruction) {
          SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ns.getInstruction();
          return cg.getPossibleTargets(src.getNode(),call.getCallSite()).contains(dst.getNode());
        }
 else {
          return false;
        }
      }
 else {
        return getPDG(src.getNode()).hasEdge(src,dst);
      }
    }
case PHI:
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
  return getPDG(src.getNode()).hasEdge(src,dst);
case EXC_RET_CALLEE:
{
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return false;
  }
  if (dst.getKind().equals(Kind.EXC_RET_CALLER)) {
    ExceptionalReturnCaller r=(ExceptionalReturnCaller)dst;
    return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
  }
 else {
    return false;
  }
}
case NORMAL_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
  return false;
}
if (dst.getKind().equals(Kind.NORMAL_RET_CALLER)) {
  NormalReturnCaller r=(NormalReturnCaller)dst;
  return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
}
 else {
  return false;
}
}
case HEAP_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_RET_CALLER)) {
HeapStatement.HeapReturnCaller r=(HeapStatement.HeapReturnCaller)dst;
HeapStatement h=(HeapStatement)src;
return h.getLocation().equals(r.getLocation()) && cg.getPossibleTargets(r.getNode(),r.getCall().getCallSite()).contains(src.getNode());
}
 else {
return false;
}
}
case PARAM_CALLER:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.PARAM_CALLEE)) {
ParamCallee callee=(ParamCallee)dst;
ParamCaller caller=(ParamCaller)src;
return caller.getValueNumber() == callee.getValueNumber() && cg.getPossibleTargets(caller.getNode(),caller.getInstruction().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
}
case HEAP_PARAM_CALLER:
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_PARAM_CALLEE)) {
HeapStatement.HeapParamCallee callee=(HeapStatement.HeapParamCallee)dst;
HeapStatement.HeapParamCaller caller=(HeapStatement.HeapParamCaller)src;
return caller.getLocation().equals(callee.getLocation()) && cg.getPossibleTargets(caller.getNode(),caller.getCall().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
default :
Assertions.UNREACHABLE();
return false;
}
}","public boolean hasEdge(Statement src,Statement dst){
  addPDGStatementNodes(src.getNode());
  addPDGStatementNodes(dst.getNode());
switch (src.getKind()) {
case NORMAL:
    if (cOptions.equals(ControlDependenceOptions.NONE)) {
      return getPDG(src.getNode()).hasEdge(src,dst);
    }
 else {
      NormalStatement ns=(NormalStatement)src;
      if (dst instanceof MethodEntryStatement) {
        if (ns.getInstruction() instanceof SSAAbstractInvokeInstruction) {
          SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ns.getInstruction();
          return cg.getPossibleTargets(src.getNode(),call.getCallSite()).contains(dst.getNode());
        }
 else {
          return false;
        }
      }
 else {
        return getPDG(src.getNode()).hasEdge(src,dst);
      }
    }
case PHI:
case PI:
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
  return getPDG(src.getNode()).hasEdge(src,dst);
case EXC_RET_CALLEE:
{
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return false;
  }
  if (dst.getKind().equals(Kind.EXC_RET_CALLER)) {
    ExceptionalReturnCaller r=(ExceptionalReturnCaller)dst;
    return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
  }
 else {
    return false;
  }
}
case NORMAL_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
  return false;
}
if (dst.getKind().equals(Kind.NORMAL_RET_CALLER)) {
  NormalReturnCaller r=(NormalReturnCaller)dst;
  return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
}
 else {
  return false;
}
}
case HEAP_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_RET_CALLER)) {
HeapStatement.HeapReturnCaller r=(HeapStatement.HeapReturnCaller)dst;
HeapStatement h=(HeapStatement)src;
return h.getLocation().equals(r.getLocation()) && cg.getPossibleTargets(r.getNode(),r.getCall().getCallSite()).contains(src.getNode());
}
 else {
return false;
}
}
case PARAM_CALLER:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.PARAM_CALLEE)) {
ParamCallee callee=(ParamCallee)dst;
ParamCaller caller=(ParamCaller)src;
return caller.getValueNumber() == callee.getValueNumber() && cg.getPossibleTargets(caller.getNode(),caller.getInstruction().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
}
case HEAP_PARAM_CALLER:
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_PARAM_CALLEE)) {
HeapStatement.HeapParamCallee callee=(HeapStatement.HeapParamCallee)dst;
HeapStatement.HeapParamCaller caller=(HeapStatement.HeapParamCaller)src;
return caller.getLocation().equals(callee.getLocation()) && cg.getPossibleTargets(caller.getNode(),caller.getCall().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
default :
Assertions.UNREACHABLE(src.getKind());
return false;
}
}",0.9963479415670652
100172,"/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  BasicBlock entry=new BasicBlock(-1,-2);
  addNode(entry);
  this.entry=entry;
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  if (instructions.length > 0) {
    final boolean[] r=new boolean[instructions.length];
    r[0]=true;
    BranchVisitor branchVisitor=makeBranchVisitor(r);
    PEIVisitor peiVisitor=makePEIVisitor(r);
    for (int i=0; i < instructions.length; i++) {
      if (instructions[i] != null) {
        branchVisitor.setIndex(i);
        instructions[i].visit(branchVisitor);
        peiVisitor.setIndex(i);
        instructions[i].visit(peiVisitor);
      }
    }
    BasicBlock b=null;
    for (int i=0; i < r.length; i++) {
      if (r[i]) {
        int end=instructions.length - 1;
        for (int j=i; j < instructions.length; j++) {
          if (r[j]) {
            end=j;
            break;
          }
        }
        b=new BasicBlock(i,end);
        addNode(b);
      }
      i2block[i]=b;
    }
  }
  BasicBlock exit=new BasicBlock(-3,-4);
  addNode(exit);
  this.exit=exit;
}","/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  BasicBlock entry=new BasicBlock(-1,-2);
  addNode(entry);
  this.entry=entry;
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  if (instructions.length > 0) {
    final boolean[] r=new boolean[instructions.length];
    r[0]=true;
    BranchVisitor branchVisitor=makeBranchVisitor(r);
    PEIVisitor peiVisitor=makePEIVisitor(r);
    for (int i=0; i < instructions.length; i++) {
      if (instructions[i] != null) {
        branchVisitor.setIndex(i);
        instructions[i].visit(branchVisitor);
        peiVisitor.setIndex(i);
        instructions[i].visit(peiVisitor);
      }
    }
    BasicBlock b=null;
    for (int i=0; i < r.length; i++) {
      if (r[i]) {
        int end=instructions.length - 1;
        for (int j=i + 1; j < instructions.length; j++) {
          if (r[j]) {
            end=j;
            break;
          }
        }
        b=new BasicBlock(i,end);
        addNode(b);
      }
      i2block[i]=b;
    }
  }
  BasicBlock exit=new BasicBlock(-3,-4);
  addNode(exit);
  this.exit=exit;
}",0.9982547993019196
100173,"/** 
 * Initialize the visitor used to perform the flow functions
 */
protected void init(BasicStackMachineVisitor v,com.ibm.wala.shrikeBT.Instruction.Visitor ev){
  this.visitor=v;
  this.edgeVisitor=ev;
}","/** 
 * Initialize the visitors used to perform the flow functions
 */
protected void init(BasicStackMachineVisitor v,com.ibm.wala.shrikeBT.Instruction.Visitor ev){
  this.visitor=v;
  this.edgeVisitor=ev;
}",0.9975786924939468
100174,"@Override public int hashCode(){
  return 3691 * phi.hashCode() + getNode().hashCode();
}","@Override public int hashCode(){
  return 3691 * phi.getDef() + getNode().hashCode();
}",0.9318181818181818
100175,"@Override public int hashCode(){
  return 3691 * pi.hashCode() + getNode().hashCode();
}","@Override public int hashCode(){
  return 3691 * pi.getDef() + getNode().hashCode();
}",0.9310344827586208
100176,"@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass().equals(obj.getClass())) {
    PiStatement other=(PiStatement)obj;
    return getNode().equals(other.getNode()) && pi.equals(other.pi);
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass().equals(obj.getClass())) {
    PiStatement other=(PiStatement)obj;
    return getNode().equals(other.getNode()) && pi.getDef() == other.getPi().getDef();
  }
 else {
    return false;
  }
}",0.8028169014084507
100177,"public Pair<Integer,SSAInstruction> getPi(SSAConditionalBranchInstruction cond,SSAInstruction def1,SSAInstruction def2,SymbolTable symbolTable){
  Pair<Integer,SSAInstruction> result=p1.getPi(cond,def1,def2,symbolTable);
  if (result != null) {
    return result;
  }
  return p2.getPi(cond,def1,def2,symbolTable);
}","public Pair<Integer,SSAInstruction> getPi(SSAAbstractInvokeInstruction call,SymbolTable symbolTable){
  Pair<Integer,SSAInstruction> result=p1.getPi(call,symbolTable);
  if (result != null) {
    return result;
  }
  return p2.getPi(call,symbolTable);
}",0.7627416520210897
100178,"public Pair<Integer,SSAInstruction> getPi(SSAConditionalBranchInstruction cond,SSAInstruction def1,SSAInstruction def2,SymbolTable symbolTable){
  if (def1 instanceof SSAInstanceofInstruction) {
    if (symbolTable.isBooleanOrZeroOneConstant(cond.getUse(1))) {
      return Pair.make(def1.getUse(0),def1);
    }
  }
  if (def2 instanceof SSAInstanceofInstruction) {
    if (symbolTable.isBooleanOrZeroOneConstant(cond.getUse(0))) {
      return Pair.make(def2.getUse(0),def2);
    }
  }
  return null;
}","public Pair<Integer,SSAInstruction> getPi(SSAAbstractInvokeInstruction call,SymbolTable symbolTable){
  return null;
}",0.3381642512077294
100179,"public Pair<Integer,SSAInstruction> getPi(SSAConditionalBranchInstruction cond,SSAInstruction def1,SSAInstruction def2,SymbolTable symbolTable){
  if (symbolTable.isNullConstant(cond.getUse(1))) {
    return Pair.<Integer,SSAInstruction>make(cond.getUse(0),cond);
  }
  if (symbolTable.isNullConstant(cond.getUse(0))) {
    return Pair.<Integer,SSAInstruction>make(cond.getUse(1),cond);
  }
  return null;
}","public Pair<Integer,SSAInstruction> getPi(SSAAbstractInvokeInstruction call,SymbolTable symbolTable){
  return null;
}",0.4
100180,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitSwitch(SwitchInstruction)
 */
@Override public void visitSwitch(com.ibm.wala.shrikeBT.SwitchInstruction instruction){
}","/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitSwitch(SwitchInstruction)
 */
@Override public void visitSwitch(com.ibm.wala.shrikeBT.SwitchInstruction instruction){
  int val=workingState.pop();
  emitInstruction(new SSASwitchInstruction(val,instruction.getDefaultLabel(),instruction.getCasesAndLabels()));
}",0.716
100181,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitInvoke(InvokeInstruction)
 */
@Override public void visitInvoke(com.ibm.wala.shrikeBT.InvokeInstruction instruction){
  int n=instruction.getPoppedCount();
  int[] params=new int[n];
  for (int i=n - 1; i >= 0; i--) {
    params[i]=workingState.pop();
  }
  MethodReference m=MethodReference.findOrCreate(loader,instruction.getClassType(),instruction.getMethodName(),instruction.getMethodSignature());
  IInvokeInstruction.Dispatch code=ShrikeUtil.getInvocationCode(instruction);
  CallSiteReference site=CallSiteReference.make(getCurrentProgramCounter(),m,code);
  int exc=reuseOrCreateException();
  if (instruction.getPushedWordSize() > 0) {
    int result=reuseOrCreateDef();
    workingState.push(result);
    emitInstruction(new SSAInvokeInstruction(result,params,exc,site));
  }
 else {
    emitInstruction(new SSAInvokeInstruction(params,exc,site));
  }
}","@Override public void visitInvoke(InvokeInstruction instruction){
  maybeInsertPi((SSAAbstractInvokeInstruction)getCurrentInstruction());
}",0.224105461393597
100182,"private void maybeInsertPi(SSAConditionalBranchInstruction cond){
  if (piNodePolicy != null) {
    Pair<Integer,SSAInstruction> pi=piNodePolicy.getPi(cond,creators[cond.getUse(0)],creators[cond.getUse(1)],symbolTable);
    if (pi != null) {
      reuseOrCreatePi(pi.snd,pi.fst);
    }
  }
}","private void maybeInsertPi(SSAConditionalBranchInstruction cond){
  if (piNodePolicy != null) {
    Pair<Integer,SSAInstruction> pi=piNodePolicy.getPi(cond,getDef(cond.getUse(0)),getDef(cond.getUse(1)),symbolTable);
    if (pi != null) {
      reuseOrCreatePi(pi.snd,pi.fst);
    }
  }
}",0.9342560553633218
100183,"/** 
 * @param index -index into IR instruction array
 * @param vn -value number
 */
public String[] getLocalNames(int index,int vn){
  try {
    if (!shrikeCFG.getMethod().hasLocalVariableTable()) {
      return null;
    }
 else {
      int[] localNumbers=findLocalsForValueNumber(index,vn);
      if (localNumbers == null) {
        return null;
      }
 else {
        ShrikeCTMethod m=(ShrikeCTMethod)shrikeCFG.getMethod();
        String[] result=new String[localNumbers.length];
        for (int i=0; i < localNumbers.length; i++) {
          result[i]=m.getLocalVariableName(m.getBytecodeIndex(index),localNumbers[i]);
        }
        return result;
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return null;
  }
}","/** 
 * @param index - index into IR instruction array
 * @param vn - value number
 */
public String[] getLocalNames(int index,int vn){
  try {
    if (!shrikeCFG.getMethod().hasLocalVariableTable()) {
      return null;
    }
 else {
      int[] localNumbers=findLocalsForValueNumber(index,vn);
      if (localNumbers == null) {
        return null;
      }
 else {
        ShrikeCTMethod m=(ShrikeCTMethod)shrikeCFG.getMethod();
        String[] result=new String[localNumbers.length];
        for (int i=0; i < localNumbers.length; i++) {
          result[i]=m.getLocalVariableName(m.getBytecodeIndex(index),localNumbers[i]);
        }
        return result;
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return null;
  }
}",0.998719590268886
100184,"/** 
 * @param piCause
 * @param ref
 */
private void reuseOrCreatePi(SSAInstruction piCause,int ref){
  int n=getCurrentInstructionIndex();
  SSACFG.BasicBlock bb=cfg.getBlockForInstruction(n);
  BasicBlock path=getCurrentSuccessor();
  int outNum=shrikeCFG.getNumber(path);
  SSAPiInstruction pi=bb.getPiForRefAndPath(ref,path);
  if (pi == null) {
    pi=new SSAPiInstruction(symbolTable.newSymbol(),ref,outNum,piCause);
    bb.addPiForRefAndPath(ref,path,pi);
  }
  workingState.replaceValue(ref,pi.getDef());
}","/** 
 * @param piCause
 * @param ref
 */
private void reuseOrCreatePi(SSAInstruction piCause,int ref){
  int n=getCurrentInstructionIndex();
  SSACFG.BasicBlock bb=cfg.getBlockForInstruction(n);
  BasicBlock path=getCurrentSuccessor();
  int outNum=shrikeCFG.getNumber(path);
  SSAPiInstruction pi=bb.getPiForRefAndPath(ref,path);
  if (pi == null) {
    pi=new SSAPiInstruction(symbolTable.newSymbol(),ref,bb.getNumber(),outNum,piCause);
    bb.addPiForRefAndPath(ref,path,pi);
  }
  workingState.replaceValue(ref,pi.getDef());
}",0.985645933014354
100185,"/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vncorresponds to some set of locals, then return an array of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  if (locals == null) {
    locals=allocateNewLocalsArray();
  }
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals[p.getY()]=p.getX();
    }
  }
  return extractIndices(locals,vn);
}","/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, thenreturn an array of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  if (locals == null) {
    locals=allocateNewLocalsArray();
  }
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals[p.getY()]=p.getX();
    }
  }
  return extractIndices(locals,vn);
}",0.9986754966887416
100186,"@Override public SSAInstruction copyForSSA(int[] defs,int[] uses){
  if (defs != null && defs.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (uses != null && uses.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSAPiInstruction(defs == null ? result : defs[0],uses == null ? val : uses[0],successorBlock,cause);
}","@Override public SSAInstruction copyForSSA(int[] defs,int[] uses){
  if (defs != null && defs.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (uses != null && uses.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSAPiInstruction(defs == null ? result : defs[0],uses == null ? val : uses[0],piBlock,successorBlock,cause);
}",0.9671717171717172
100187,"/** 
 * @param s the successor block; this PI assignment happens on the transition between this basic block andthe successor block.
 */
SSAPiInstruction(int result,int val,int s,SSAInstruction cause){
  super(null,result,val);
  this.cause=cause;
  this.successorBlock=s;
}","/** 
 * @param s the successor block; this PI assignment happens on the transition between this basic block andthe successor block.
 */
SSAPiInstruction(int result,int val,int piBlock,int s,SSAInstruction cause){
  super(null,result,val);
  this.cause=cause;
  this.successorBlock=s;
  this.piBlock=piBlock;
}",0.9381443298969072
100188,"/** 
 * Add constraints for a call site after we have computed a reachable target for the dispatch Side effect: add edge to the call graph.
 * @param instruction
 * @param constParams if non-null, then constParams[i] holds the set of instance keys that are passed as param i, or null if param i is not invariant
 * @param uniqueCatchKey if non-null, then this is the unique PointerKey that catches all exceptions from this call site.
 */
@SuppressWarnings(""String_Node_Str"") private void processResolvedCall(CGNode caller,SSAAbstractInvokeInstruction instruction,CGNode target,InstanceKey[][] constParams,PointerKey uniqueCatchKey){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + caller + ""String_Node_Str""+ instruction+ ""String_Node_Str""+ target);
  }
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + caller + ""String_Node_Str""+ instruction+ ""String_Node_Str""+ target);
  }
  caller.addTarget(instruction.getCallSite(),target);
  if (FakeRootMethod.isFakeRootMethod(caller.getMethod().getReference())) {
    if (entrypointCallSites.contains(instruction.getCallSite())) {
      callGraph.registerEntrypoint(target);
    }
  }
  if (!haveAlreadyVisited(target)) {
    markDiscovered(target);
  }
  int nUses=instruction.getNumberOfParameters();
  int nExpected=target.getMethod().getNumberOfParameters();
  if (nUses != nExpected) {
    Warnings.add(ResolutionFailure.create(target,instruction,""String_Node_Str"" + nUses + ""String_Node_Str""+ nExpected));
    return;
  }
  boolean needsFilter=!instruction.getCallSite().isStatic() && needsFilterForReceiver(instruction,target);
  for (int i=0; i < instruction.getNumberOfParameters(); i++) {
    final int vn=i + 1;
    if (target.getMethod().getParameterType(i).isReferenceType()) {
      if (constParams != null && constParams[i] != null) {
        InstanceKey[] ik=constParams[i];
        for (int j=0; j < ik.length; j++) {
          if (needsFilter && (i == 0)) {
            FilteredPointerKey.TypeFilter C=getFilter(target);
            PointerKey formal=null;
            if (isRootType(C)) {
              formal=getPointerKeyForLocal(target,vn);
            }
 else {
              formal=getFilteredPointerKeyForLocal(target,vn,C);
            }
            system.newConstraint(formal,ik[j]);
          }
 else {
            PointerKey formal=getPointerKeyForLocal(target,vn);
            system.newConstraint(formal,ik[j]);
          }
        }
      }
 else {
        if (Assertions.verifyAssertions) {
          if (instruction.getUse(i) < 0) {
            Assertions.UNREACHABLE(""String_Node_Str"" + instruction + ""String_Node_Str""+ caller);
          }
        }
        PointerKey actual=getPointerKeyForLocal(caller,instruction.getUse(i));
        if (needsFilter && (i == 0)) {
          FilteredPointerKey.TypeFilter C=getFilter(target);
          if (isRootType(C)) {
            PointerKey formal=getPointerKeyForLocal(target,vn);
            system.newConstraint(formal,assignOperator,actual);
          }
 else {
            FilteredPointerKey formal=getFilteredPointerKeyForLocal(target,vn,C);
            system.newConstraint(formal,filterOperator,actual);
          }
        }
 else {
          PointerKey formal=getPointerKeyForLocal(target,vn);
          system.newConstraint(formal,assignOperator,actual);
        }
      }
    }
  }
  if (instruction.hasDef() && instruction.getDeclaredResultType().isReferenceType()) {
    PointerKey result=getPointerKeyForLocal(caller,instruction.getDef());
    PointerKey ret=getPointerKeyForReturnValue(target);
    system.newConstraint(result,assignOperator,ret);
  }
  PointerKey e=getPointerKeyForLocal(caller,instruction.getException());
  PointerKey er=getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,er);
  }
 else {
    system.newConstraint(e,assignOperator,er);
  }
}","/** 
 * Add constraints for a call site after we have computed a reachable target for the dispatch Side effect: add edge to the call graph.
 * @param instruction
 * @param constParams if non-null, then constParams[i] holds the set of instance keys that are passed as param i, ornull if param i is not invariant
 * @param uniqueCatchKey if non-null, then this is the unique PointerKey that catches all exceptions from this callsite.
 */
@SuppressWarnings(""String_Node_Str"") private void processResolvedCall(CGNode caller,SSAAbstractInvokeInstruction instruction,CGNode target,InstanceKey[][] constParams,PointerKey uniqueCatchKey){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + caller + ""String_Node_Str""+ instruction+ ""String_Node_Str""+ target);
  }
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + caller + ""String_Node_Str""+ instruction+ ""String_Node_Str""+ target);
  }
  caller.addTarget(instruction.getCallSite(),target);
  if (FakeRootMethod.isFakeRootMethod(caller.getMethod().getReference())) {
    if (entrypointCallSites.contains(instruction.getCallSite())) {
      callGraph.registerEntrypoint(target);
    }
  }
  if (!haveAlreadyVisited(target)) {
    markDiscovered(target);
  }
  int nUses=instruction.getNumberOfParameters();
  int nExpected=target.getMethod().getNumberOfParameters();
  if (nUses != nExpected) {
    Warnings.add(ResolutionFailure.create(target,instruction,""String_Node_Str"" + nUses + ""String_Node_Str""+ nExpected));
    return;
  }
  boolean needsFilter=!instruction.getCallSite().isStatic() && needsFilterForReceiver(instruction,target);
  for (int i=0; i < instruction.getNumberOfParameters(); i++) {
    final int vn=i + 1;
    if (target.getMethod().getParameterType(i).isReferenceType()) {
      if (constParams != null && constParams[i] != null) {
        InstanceKey[] ik=constParams[i];
        for (int j=0; j < ik.length; j++) {
          if (needsFilter && (i == 0)) {
            FilteredPointerKey.TypeFilter C=getFilter(target);
            PointerKey formal=null;
            if (isRootType(C)) {
              formal=getPointerKeyForLocal(target,vn);
            }
 else {
              formal=getFilteredPointerKeyForLocal(target,vn,C);
            }
            system.newConstraint(formal,ik[j]);
          }
 else {
            PointerKey formal=getPointerKeyForLocal(target,vn);
            system.newConstraint(formal,ik[j]);
          }
        }
      }
 else {
        if (Assertions.verifyAssertions) {
          if (instruction.getUse(i) < 0) {
            Assertions.UNREACHABLE(""String_Node_Str"" + instruction + ""String_Node_Str""+ caller);
          }
        }
        PointerKey actual=getPointerKeyForLocal(caller,instruction.getUse(i));
        if (needsFilter && (i == 0)) {
          FilteredPointerKey.TypeFilter C=getFilter(target);
          if (isRootType(C)) {
            PointerKey formal=getPointerKeyForLocal(target,vn);
            system.newConstraint(formal,assignOperator,actual);
          }
 else {
            FilteredPointerKey formal=getFilteredPointerKeyForLocal(target,vn,C);
            system.newConstraint(formal,filterOperator,actual);
          }
        }
 else {
          PointerKey formal=getPointerKeyForLocal(target,vn);
          system.newConstraint(formal,assignOperator,actual);
        }
      }
    }
  }
  if (instruction.hasDef() && instruction.getDeclaredResultType().isReferenceType()) {
    PointerKey result=getPointerKeyForLocal(caller,instruction.getDef());
    PointerKey ret=getPointerKeyForReturnValue(target);
    system.newConstraint(result,assignOperator,ret);
  }
  PointerKey e=getPointerKeyForLocal(caller,instruction.getException());
  PointerKey er=getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,er);
  }
 else {
    system.newConstraint(e,assignOperator,er);
  }
}",0.9997454823110206
100189,"/** 
 * @param call
 * @param node
 * @param constParams if non-null, then constParams[i] holds the String constant that is passed as param i, or null if param i is not a String constant
 */
DispatchOperator(SSAAbstractInvokeInstruction call,ExplicitCallGraph.ExplicitNode node,InstanceKey[][] constParams,PointerKey uniqueCatch){
  this.call=call;
  this.node=node;
  this.constParams=constParams;
  this.uniqueCatch=uniqueCatch;
}","/** 
 * @param call
 * @param node
 * @param constParams if non-null, then constParams[i] holds the String constant that is passed as param i, or nullif param i is not a String constant
 */
DispatchOperator(SSAAbstractInvokeInstruction call,ExplicitCallGraph.ExplicitNode node,InstanceKey[][] constParams,PointerKey uniqueCatch){
  this.call=call;
  this.node=node;
  this.constParams=constParams;
  this.uniqueCatch=uniqueCatch;
}",0.9988412514484356
100190,"private int booleanConstantTest(SSAConditionalBranchInstruction c,int v){
  int result=0;
  if ((symbolTable.isZeroOrFalse(c.getUse(0)) && c.getUse(1) == v) || (symbolTable.isZeroOrFalse(c.getUse(1)) && c.getUse(0) == v)) {
    result=-1;
  }
 else   if ((symbolTable.isOneOrTrue(c.getUse(0)) && c.getUse(1) == v) || (symbolTable.isOneOrTrue(c.getUse(1)) && c.getUse(0) == v)) {
    result=1;
  }
  if (c.getOperator() == ConditionalBranchInstruction.Operator.NE) {
    result=-result;
  }
  return result;
}","/** 
 * TODO: What is this doing? Document me!
 */
private int booleanConstantTest(SSAConditionalBranchInstruction c,int v){
  int result=0;
  if ((symbolTable.isZeroOrFalse(c.getUse(0)) && c.getUse(1) == v) || (symbolTable.isZeroOrFalse(c.getUse(1)) && c.getUse(0) == v)) {
    result=-1;
  }
 else   if ((symbolTable.isOneOrTrue(c.getUse(0)) && c.getUse(1) == v) || (symbolTable.isOneOrTrue(c.getUse(1)) && c.getUse(0) == v)) {
    result=1;
  }
  if (c.getOperator() == ConditionalBranchInstruction.Operator.NE) {
    result=-result;
  }
  return result;
}",0.9522024367385192
100191,"/** 
 * TODO: lift most of this logic to PropagationCallGraphBuilder Add a call to the class initializer from the root method.
 * @param klass
 */
private void processClassInitializer(IClass klass){
  if (Assertions.verifyAssertions) {
    Assertions._assert(klass != null);
  }
  if (getBuilder().clinitVisited.contains(klass)) {
    return;
  }
  getBuilder().clinitVisited.add(klass);
  if (klass.getClassInitializer() != null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + klass);
    }
    FakeWorldClinitMethod fakeWorldClinitMethod=(FakeWorldClinitMethod)callGraph.getFakeWorldClinitNode().getMethod();
    MethodReference m=klass.getClassInitializer().getReference();
    CallSiteReference site=CallSiteReference.make(1,m,IInvokeInstruction.Dispatch.STATIC);
    IMethod targetMethod=getOptions().getMethodTargetSelector().getCalleeTarget(callGraph.getFakeRootNode(),site,null);
    if (targetMethod != null) {
      CGNode target=getTargetForCall(callGraph.getFakeRootNode(),site,(InstanceKey)null);
      if (target != null && callGraph.getPredNodeCount(target) == 0) {
        SSAAbstractInvokeInstruction s=fakeWorldClinitMethod.addInvocation(new int[0],site);
        PointerKey uniqueCatch=getBuilder().getPointerKeyForExceptionalReturnValue(callGraph.getFakeRootNode());
        getBuilder().processResolvedCall(callGraph.getFakeWorldClinitNode(),s,target,null,uniqueCatch);
      }
    }
  }
  try {
    IClass sc=klass.getSuperclass();
    if (sc != null) {
      processClassInitializer(sc);
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
}","/** 
 * TODO: lift most of this logic to PropagationCallGraphBuilder Add a call to the class initializer from the root method.
 */
private void processClassInitializer(IClass klass){
  if (Assertions.verifyAssertions) {
    Assertions._assert(klass != null);
  }
  if (getBuilder().clinitVisited.contains(klass)) {
    return;
  }
  getBuilder().clinitVisited.add(klass);
  if (klass.getClassInitializer() != null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + klass);
    }
    FakeWorldClinitMethod fakeWorldClinitMethod=(FakeWorldClinitMethod)callGraph.getFakeWorldClinitNode().getMethod();
    MethodReference m=klass.getClassInitializer().getReference();
    CallSiteReference site=CallSiteReference.make(1,m,IInvokeInstruction.Dispatch.STATIC);
    IMethod targetMethod=getOptions().getMethodTargetSelector().getCalleeTarget(callGraph.getFakeRootNode(),site,null);
    if (targetMethod != null) {
      CGNode target=getTargetForCall(callGraph.getFakeRootNode(),site,(InstanceKey)null);
      if (target != null && callGraph.getPredNodeCount(target) == 0) {
        SSAAbstractInvokeInstruction s=fakeWorldClinitMethod.addInvocation(new int[0],site);
        PointerKey uniqueCatch=getBuilder().getPointerKeyForExceptionalReturnValue(callGraph.getFakeRootNode());
        getBuilder().processResolvedCall(callGraph.getFakeWorldClinitNode(),s,target,null,uniqueCatch);
      }
    }
  }
  try {
    IClass sc=klass.getSuperclass();
    if (sc != null) {
      processClassInitializer(sc);
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
}",0.9950124688279302
100192,"/** 
 * TODO: lift most of this logic to PropagationCallGraphBuilder Add a call to the class initializer from the root method.
 * @param klass
 */
private void processClassInitializer(IClass klass){
  if (Assertions.verifyAssertions) {
    Assertions._assert(klass != null);
  }
  if (getBuilder().clinitVisited.contains(klass)) {
    return;
  }
  getBuilder().clinitVisited.add(klass);
  if (klass.getClassInitializer() != null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + klass);
    }
    FakeWorldClinitMethod fakeWorldClinitMethod=(FakeWorldClinitMethod)callGraph.getFakeWorldClinitNode().getMethod();
    MethodReference m=klass.getClassInitializer().getReference();
    CallSiteReference site=CallSiteReference.make(1,m,IInvokeInstruction.Dispatch.STATIC);
    IMethod targetMethod=getOptions().getMethodTargetSelector().getCalleeTarget(callGraph.getFakeRootNode(),site,null);
    if (targetMethod != null) {
      CGNode target=getTargetForCall(callGraph.getFakeRootNode(),site,(InstanceKey)null);
      if (callGraph.getPredNodeCount(target) == 0) {
        SSAAbstractInvokeInstruction s=fakeWorldClinitMethod.addInvocation(new int[0],site);
        PointerKey uniqueCatch=getBuilder().getPointerKeyForExceptionalReturnValue(callGraph.getFakeRootNode());
        getBuilder().processResolvedCall(callGraph.getFakeWorldClinitNode(),s,target,null,uniqueCatch);
      }
    }
  }
  try {
    IClass sc=klass.getSuperclass();
    if (sc != null) {
      processClassInitializer(sc);
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
}","/** 
 * TODO: lift most of this logic to PropagationCallGraphBuilder Add a call to the class initializer from the root method.
 * @param klass
 */
private void processClassInitializer(IClass klass){
  if (Assertions.verifyAssertions) {
    Assertions._assert(klass != null);
  }
  if (getBuilder().clinitVisited.contains(klass)) {
    return;
  }
  getBuilder().clinitVisited.add(klass);
  if (klass.getClassInitializer() != null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + klass);
    }
    FakeWorldClinitMethod fakeWorldClinitMethod=(FakeWorldClinitMethod)callGraph.getFakeWorldClinitNode().getMethod();
    MethodReference m=klass.getClassInitializer().getReference();
    CallSiteReference site=CallSiteReference.make(1,m,IInvokeInstruction.Dispatch.STATIC);
    IMethod targetMethod=getOptions().getMethodTargetSelector().getCalleeTarget(callGraph.getFakeRootNode(),site,null);
    if (targetMethod != null) {
      CGNode target=getTargetForCall(callGraph.getFakeRootNode(),site,(InstanceKey)null);
      if (target != null && callGraph.getPredNodeCount(target) == 0) {
        SSAAbstractInvokeInstruction s=fakeWorldClinitMethod.addInvocation(new int[0],site);
        PointerKey uniqueCatch=getBuilder().getPointerKeyForExceptionalReturnValue(callGraph.getFakeRootNode());
        getBuilder().processResolvedCall(callGraph.getFakeWorldClinitNode(),s,target,null,uniqueCatch);
      }
    }
  }
  try {
    IClass sc=klass.getSuperclass();
    if (sc != null) {
      processClassInitializer(sc);
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
}",0.9943855271366188
100193,"/** 
 * @param appJar something like ""c:/temp/testdata/java_cup.jar""
 * @return a call graph
 * @throws CancelException
 * @throws IllegalArgumentException
 */
public static Graph<CGNode> buildPrunedCallGraph(String appJar,File exclusionFile) throws WalaException, IllegalArgumentException, CancelException {
  AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(appJar,exclusionFile != null ? exclusionFile : new File(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha);
  AnalysisOptions options=new AnalysisOptions(scope,entrypoints);
  com.ibm.wala.ipa.callgraph.CallGraphBuilder builder=Util.makeZeroOneContainerCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  System.err.println(CallGraphStats.getStats(cg));
  Graph<CGNode> g=pruneForAppLoader(cg);
  return g;
}","/** 
 * @param appJar something like ""c:/temp/testdata/java_cup.jar""
 * @return a call graph
 * @throws CancelException
 * @throws IllegalArgumentException
 */
public static Graph<CGNode> buildPrunedCallGraph(String appJar,File exclusionFile) throws WalaException, IllegalArgumentException, CancelException {
  AnalysisScope scope=AnalysisScopeReader.makeJavaBinaryAnalysisScope(appJar,exclusionFile != null ? exclusionFile : new File(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha);
  AnalysisOptions options=new AnalysisOptions(scope,entrypoints);
  com.ibm.wala.ipa.callgraph.CallGraphBuilder builder=Util.makeZeroCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  System.err.println(CallGraphStats.getStats(cg));
  Graph<CGNode> g=pruneForAppLoader(cg);
  return g;
}",0.9938335046248716
100194,"/** 
 * Get the WCCM archive representing a particular module
 * @param M the module to analyze
 * @return Archive, or null if no WCCM conversion is possible
 */
@SuppressWarnings(""String_Node_Str"") public static Archive getArchive(Module M){
  CommonarchiveFactory factory=CommonarchiveFactoryImpl.getActiveFactory();
  try {
    if (M instanceof JarFileModule) {
      String fileName=((JarFileModule)M).getAbsolutePath();
      return factory.openArchive(fileName);
    }
 else     if (M instanceof TopLevelArchiveModule) {
      TopLevelArchiveModule AM=(TopLevelArchiveModule)M;
      return AM.materializeArchive();
    }
 else     if (M instanceof ClassFileModule) {
      return null;
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + M.getClass());
      return null;
    }
  }
 catch (  OpenFailureException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return null;
  }
}","/** 
 * Get the WCCM archive representing a particular module
 * @param M the module to analyze
 * @return Archive, or null if no WCCM conversion is possible
 */
@SuppressWarnings(""String_Node_Str"") public static Archive getArchive(Module M){
  CommonarchiveFactory factory=CommonarchiveFactoryImpl.getActiveFactory();
  try {
    if (M instanceof JarFileModule) {
      String fileName=((JarFileModule)M).getAbsolutePath();
      return factory.openArchive(fileName);
    }
 else     if (M instanceof TopLevelArchiveModule) {
      TopLevelArchiveModule AM=(TopLevelArchiveModule)M;
      return AM.materializeArchive();
    }
 else     if (M instanceof ClassFileModule) {
      return null;
    }
 else {
      return null;
    }
  }
 catch (  OpenFailureException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return null;
  }
}",0.8410896708286039
100195,"public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return getTypesForContext(node.getContext()) != null;
}","public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (node.getMethod().isSynthetic()) {
    SyntheticMethod s=(SyntheticMethod)node.getMethod();
    if (s.isFactoryMethod()) {
      return getTypesForContext(node.getContext()) != null;
    }
  }
  return false;
}",0.6984732824427481
100196,"/** 
 * Dump stats about the class hierarchy to stdout.
 * @param cha
 */
public static void printStats(ClassHierarchy cha) throws IllegalArgumentException {
  if (cha == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IClassLoader[] loaders=cha.getLoaders();
  for (int i=0; i < loaders.length; i++) {
    System.out.println(""String_Node_Str"" + loaders[i]);
    System.out.println(""String_Node_Str"" + loaders[i].getNumberOfClasses());
    System.out.println(""String_Node_Str"" + loaders[i].getNumberOfMethods());
  }
}","/** 
 * Dump stats about the class hierarchy to stdout.
 * @param cha
 */
public static void printStats(IClassHierarchy cha) throws IllegalArgumentException {
  if (cha == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IClassLoader[] loaders=cha.getLoaders();
  for (int i=0; i < loaders.length; i++) {
    System.out.println(""String_Node_Str"" + loaders[i]);
    System.out.println(""String_Node_Str"" + loaders[i].getNumberOfClasses());
    System.out.println(""String_Node_Str"" + loaders[i].getNumberOfMethods());
  }
}",0.999080036798528
100197,"/** 
 * Does m represent a static factory method we know about from the standard libraries, that we usually wish to model with one level of call-string context?
 */
public static boolean isWellKnownStaticFactory(MethodReference m){
  if (m.equals(synthArraycopy)) {
    return true;
  }
  if (m.equals(ArraysAsList)) {
    return true;
  }
  return false;
}","/** 
 * Does m represent a static factory method we know about from the standard libraries, that we usually wish to model with one level of call-string context?
 */
public static boolean isWellKnownStaticFactory(MethodReference m){
  if (m.getDeclaringClass().equals(TypeReference.JavaLangSystem)) {
    if (m.getName().toString().equals(""String_Node_Str"")) {
      return true;
    }
  }
  if (m.equals(synthArraycopy)) {
    return true;
  }
  if (m.equals(ArraysAsList)) {
    return true;
  }
  return false;
}",0.8197474167623421
100198,"public void testSlice2() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> computeBackwardSlice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  Collection<Statement> slice=computeBackwardSlice;
  dumpSlice(slice);
  assertEquals(22,slice.size());
}","public void testSlice2() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> computeBackwardSlice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  Collection<Statement> slice=computeBackwardSlice;
  dumpSlice(slice);
  assertEquals(30,slice.size());
}",0.9981220657276996
100199,"/** 
 * For a statement s, compute the set of statements that may def the heap value read by s.
 */
OrdinalSet<Statement> computeResult(Statement s,Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<? extends ISSABasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExplodedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement){
switch (s.getKind()) {
case NORMAL:
    NormalStatement n=(NormalStatement)s;
  Collection<PointerKey> ref=modRef.getRef(node,h,pa,n.getInstruction(),exclusions);
if (!ref.isEmpty()) {
  ISSABasicBlock bb=cfg.getBlockForInstruction(n.getInstructionIndex());
  BitVectorVariable v=solver.getIn(bb);
  MutableSparseIntSet defs=MutableSparseIntSet.makeEmpty();
  for (  PointerKey p : ref) {
    if (pointerKeyMod.get(p) != null) {
      defs.addAll(pointerKeyMod.get(p).intersection(v.getValue()));
    }
  }
  return new OrdinalSet<Statement>(defs,domain);
}
 else {
  return OrdinalSet.empty();
}
case HEAP_RET_CALLEE:
{
HeapStatement.ReturnCallee r=(HeapStatement.ReturnCallee)s;
PointerKey p=r.getLocation();
BitVectorVariable v=solver.getIn(cfg.exit());
if (pointerKeyMod.get(p) == null) {
  return OrdinalSet.empty();
}
return new OrdinalSet<Statement>(pointerKeyMod.get(p).intersection(v.getValue()),domain);
}
case HEAP_RET_CALLER:
{
HeapStatement.ReturnCaller r=(HeapStatement.ReturnCaller)s;
ISSABasicBlock bb=cfg.getBlockForInstruction(r.getCallIndex());
BitVectorVariable v=solver.getIn(bb);
if (allCalleesMod(cg,r,mod) || pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case HEAP_PARAM_CALLER:
{
HeapStatement.ParamCaller r=(HeapStatement.ParamCaller)s;
NormalStatement call=ssaInstructionIndex2Statement.get(r.getCallIndex());
ISSABasicBlock callBlock=cfg.getBlockForInstruction(call.getInstructionIndex());
BitVectorVariable v=solver.getIn(callBlock);
if (pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PARAM_CALLER:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case PHI:
case PI:
case CATCH:
case METHOD_ENTRY:
return OrdinalSet.empty();
case HEAP_PARAM_CALLEE:
return OrdinalSet.empty();
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}","/** 
 * For a statement s, compute the set of statements that may def the heap value read by s.
 */
OrdinalSet<Statement> computeResult(Statement s,Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<? extends ISSABasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExplodedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement){
}",0.2958656330749354
100200,"/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  final boolean[] r=new boolean[instructions.length];
  r[0]=true;
  BranchVisitor branchVisitor=makeBranchVisitor(r);
  PEIVisitor peiVisitor=makePEIVisitor(r);
  for (int i=0; i < instructions.length; i++) {
    if (instructions[i] != null) {
      branchVisitor.setIndex(i);
      instructions[i].visit(branchVisitor);
      peiVisitor.setIndex(i);
      instructions[i].visit(peiVisitor);
    }
  }
  BasicBlock b=null;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      b=new BasicBlock(i);
      addNode(b);
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + b);
      }
    }
    i2block[i]=b;
  }
  BasicBlock exit=new BasicBlock(-1);
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + exit);
  }
  addNode(exit);
}","/** 
 * Walk through the instructions and compute basic block boundaries.
 */
private void makeBasicBlocks(){
  BasicBlock entry=new BasicBlock(-1,-2);
  addNode(entry);
  this.entry=entry;
  SSAInstruction[] instructions=(SSAInstruction[])getInstructions();
  if (instructions.length > 0) {
    final boolean[] r=new boolean[instructions.length];
    r[0]=true;
    BranchVisitor branchVisitor=makeBranchVisitor(r);
    PEIVisitor peiVisitor=makePEIVisitor(r);
    for (int i=0; i < instructions.length; i++) {
      if (instructions[i] != null) {
        branchVisitor.setIndex(i);
        instructions[i].visit(branchVisitor);
        peiVisitor.setIndex(i);
        instructions[i].visit(peiVisitor);
      }
    }
    BasicBlock b=null;
    for (int i=0; i < r.length; i++) {
      if (r[i]) {
        int end=instructions.length - 1;
        for (int j=i; j < instructions.length; j++) {
          if (r[j]) {
            end=j;
            break;
          }
        }
        b=new BasicBlock(i,end);
        addNode(b);
      }
      i2block[i]=b;
    }
  }
  BasicBlock exit=new BasicBlock(-3,-4);
  addNode(exit);
  this.exit=exit;
}",0.6679574056147144
100201,"BasicBlock(int start){
  this.start=start;
}","BasicBlock(int start,int end){
  this.start=start;
  this.end=end;
}",0.7857142857142857
100202,"/** 
 * TODO: we do not yet support induced CFGS with exception handlers.
 * @param instructions
 * @throws IllegalArgumentException  if instructions is null
 */
public InducedCFG(SSAInstruction[] instructions,IMethod method,Context context){
  super(method);
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.context=context;
  this.instructions=instructions;
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + method);
  }
  i2block=new BasicBlock[instructions.length];
  if (instructions.length == 0) {
    makeEmptyBlocks();
  }
 else {
    makeBasicBlocks();
  }
  init();
  computeEdges();
  if (DEBUG) {
    try {
      GraphIntegrity.check(this);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","/** 
 * TODO: we do not yet support induced CFGS with exception handlers.
 * @param instructions
 * @throws IllegalArgumentException if instructions is null
 */
public InducedCFG(SSAInstruction[] instructions,IMethod method,Context context){
  super(method);
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.context=context;
  this.instructions=instructions;
  i2block=new BasicBlock[instructions.length];
  makeBasicBlocks();
  init();
  computeEdges();
  if (DEBUG) {
    try {
      GraphIntegrity.check(this);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.8988015978695073
100203,"public boolean isEntryBlock(){
  return getNumber() == 0;
}","public boolean isEntryBlock(){
  return this.equals(entry);
}",0.7833333333333333
100204,"/** 
 * Method getLastInstructionIndex.
 * @return int
 */
public int getLastInstructionIndex(){
  int exitNumber=InducedCFG.this.getNumber(exit());
  if (getGraphNodeId() == exitNumber) {
    return -2;
  }
  if (getGraphNodeId() == (exitNumber - 1)) {
    return getInstructions().length - 1;
  }
 else {
    BasicBlock next=getNode(getGraphNodeId() + 1);
    return next.getFirstInstructionIndex() - 1;
  }
}","public int getLastInstructionIndex(){
  return end;
}",0.2155172413793103
100205,"public boolean isExitBlock(){
  return getLastInstructionIndex() == -2;
}","public boolean isExitBlock(){
  return this.equals(exit);
}",0.7272727272727273
100206,"/** 
 * Compute outgoing edges in the control flow graph.
 */
private void computeEdges(){
  for (Iterator it=iterator(); it.hasNext(); ) {
    BasicBlock b=(BasicBlock)it.next();
    if (b.equals(exit()))     continue;
    b.computeOutgoingEdges();
  }
}","/** 
 * Compute outgoing edges in the control flow graph.
 */
private void computeEdges(){
  for (Iterator it=iterator(); it.hasNext(); ) {
    BasicBlock b=(BasicBlock)it.next();
    if (b.equals(exit()))     continue;
    if (b.equals(entry())) {
      addNormalEdge(b,getNode(b.getGraphNodeId() + 1));
      continue;
    }
    SSAInstruction last=(SSAInstruction)getInstructions()[b.getLastInstructionIndex()];
    if (last.isPEI()) {
      addExceptionalEdge(b,exit());
    }
    if (true) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + getNode(b.getGraphNodeId() + 1));
      }
      addNormalEdge(b,getNode(b.getGraphNodeId() + 1));
    }
    if (last instanceof SSAReturnInstruction) {
      BasicBlock exit=exit();
      addNormalEdge(b,exit);
    }
  }
}",0.4521739130434782
100207,"/** 
 * Compute an analysis scope for the current selection
 */
protected AnalysisScope computeScope(){
  IStructuredSelection selection=(IStructuredSelection)currentSelection;
  Collection<EclipseProjectPath> projectPaths=HashSetFactory.make();
  for (Iterator it=selection.iterator(); it.hasNext(); ) {
    Object object=it.next();
    if (object instanceof IJavaElement) {
      IJavaElement e=(IJavaElement)object;
      IJavaProject jp=e.getJavaProject();
      projectPaths.add(EclipseProjectPath.make(ResourcesPlugin.getWorkspace().getRoot().getLocation(),jp));
    }
 else {
      Assertions.UNREACHABLE(object.getClass());
    }
  }
  AnalysisScope scope=mergeProjectPaths(projectPaths);
  return scope;
}","/** 
 * Compute an analysis scope for the current selection
 * @throws IOException 
 * @throws JavaModelException 
 */
protected AnalysisScope computeScope() throws JavaModelException, IOException {
  IStructuredSelection selection=(IStructuredSelection)currentSelection;
  Collection<EclipseProjectPath> projectPaths=HashSetFactory.make();
  for (Iterator it=selection.iterator(); it.hasNext(); ) {
    Object object=it.next();
    if (object instanceof IJavaElement) {
      IJavaElement e=(IJavaElement)object;
      IJavaProject jp=e.getJavaProject();
      projectPaths.add(EclipseProjectPath.make(ResourcesPlugin.getWorkspace().getRoot().getLocation(),jp));
    }
 else {
      Assertions.UNREACHABLE(object.getClass());
    }
  }
  AnalysisScope scope=mergeProjectPaths(projectPaths);
  return scope;
}",0.937623112278398
100208,"private EclipseProjectPath(IPath workspaceRootPath,IJavaProject project){
}","private EclipseProjectPath(IPath workspaceRootPath,IJavaProject project) throws JavaModelException, IOException {
}",0.7894736842105263
100209,"public static EclipseProjectPath make(IPath workspaceRootPath,IJavaProject project){
  if (workspaceRootPath == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new EclipseProjectPath(workspaceRootPath,project);
}","public static EclipseProjectPath make(IPath workspaceRootPath,IJavaProject project) throws JavaModelException, IOException {
  if (workspaceRootPath == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new EclipseProjectPath(workspaceRootPath,project);
}",0.9242424242424242
100210,"/** 
 * compute the analysis scope for a project in the current workspace
 */
public static AnalysisScope computeScope(String projectName){
  IJavaProject jp=getProjectFromWorkspace(projectName);
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  EclipseProjectPath path=EclipseProjectPath.make(workspaceRoot.getLocation(),jp);
  return path.toAnalysisScope(null);
}","/** 
 * compute the analysis scope for a project in the current workspace
 * @throws IOException 
 * @throws JavaModelException 
 */
public static AnalysisScope computeScope(String projectName) throws JavaModelException, IOException {
  IJavaProject jp=getProjectFromWorkspace(projectName);
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  EclipseProjectPath path=EclipseProjectPath.make(workspaceRoot.getLocation(),jp);
  return path.toAnalysisScope(null);
}",0.8914285714285715
100211,"@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (Assertions.verifyAssertions) {
        Assertions._assert(defaultExceptions.size() == 1);
      }
      TypeReference t=defaultExceptions.iterator().next();
      IClass klass=cha.lookupClass(t);
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass != null);
      }
      v.setType(new PointType(klass));
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}","@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (defaultExceptions.size() == 0) {
        continue;
      }
      if (Assertions.verifyAssertions) {
        Assertions._assert(defaultExceptions.size() == 1);
      }
      TypeReference t=defaultExceptions.iterator().next();
      IClass klass=cha.lookupClass(t);
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass != null);
      }
      v.setType(new PointType(klass));
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}",0.98568167669641
100212,"private void processBytecodesWithShrikeBT(BytecodeInfo info) throws InvalidClassFileException {
  info.decoder=makeDecoder();
  if (Assertions.verifyAssertions) {
    if (!isAbstract() && info.decoder == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + getReference());
    }
  }
  if (info.decoder == null) {
    return;
  }
  info.pcMap=info.decoder.getInstructionsToBytecodes();
  processDebugInfo(info);
  SimpleVisitor simpleVisitor=new SimpleVisitor(info);
  Instruction[] instructions=info.decoder.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    simpleVisitor.setInstructionIndex(i);
    instructions[i].visit(simpleVisitor);
    if (Exceptions.isPEI(instructions[i])) {
      Collection<TypeReference> t=Exceptions.getIndependentExceptionTypes(instructions[i]);
      simpleVisitor.implicitExceptions.addAll(t);
    }
  }
  copyVisitorSetsToArrays(simpleVisitor,info);
}","private void processBytecodesWithShrikeBT(BytecodeInfo info) throws InvalidClassFileException {
  info.decoder=makeDecoder();
  if (Assertions.verifyAssertions) {
    if (!isAbstract() && info.decoder == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + getReference());
    }
  }
  if (info.decoder == null) {
    return;
  }
  info.pcMap=info.decoder.getInstructionsToBytecodes();
  processDebugInfo(info);
  SimpleVisitor simpleVisitor=new SimpleVisitor(info);
  Instruction[] instructions=info.decoder.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    simpleVisitor.setInstructionIndex(i);
    instructions[i].visit(simpleVisitor);
    if (Exceptions.isPEI(instructions[i])) {
      Collection<TypeReference> t=Exceptions.getIndependentExceptionTypes(instructions[i]);
      if (t != null) {
        simpleVisitor.implicitExceptions.addAll(t);
      }
    }
  }
  copyVisitorSetsToArrays(simpleVisitor,info);
}",0.9821717990275528
100213,"@Override public Collection<TypeReference> getExceptionTypes(){
  return Exceptions.getNullPointerException();
}","@Override public Collection<TypeReference> getExceptionTypes(){
  Collection<TypeReference> empty=Collections.emptySet();
  return isStatic() ? empty : Exceptions.getNullPointerException();
}",0.7392739273927392
100214,"/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
case OP_ldiv:
case OP_lrem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}","/** 
 * @param pei a potentially-excepting instruction
 * @return the exception types that pei may throw, independent of the classhierarchy.   null if none. Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
case OP_ldiv:
case OP_lrem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}",0.989247311827957
100215,"private Set getTypesForContext(Context context){
  XMLReflectionReader spec=(XMLReflectionReader)userSpec;
  if (spec != null && context instanceof CallerSiteContext) {
    CallerSiteContext site=(CallerSiteContext)context;
    MemberReference m=site.getCaller().getMethod().getReference();
    ReflectionSummary summary=spec.getSummary(m);
    if (summary != null) {
      Set types=summary.getTypesForProgramLocation(site.getSite().getProgramCounter());
      if (types != null) {
        return types;
      }
    }
  }
  Set types=map.get(context);
  return types;
}","private Set getTypesForContext(Context context){
  XMLReflectionReader spec=(XMLReflectionReader)userSpec;
  if (spec != null && context instanceof CallerSiteContext) {
    CallerSiteContext site=(CallerSiteContext)context;
    MemberReference m=site.getCaller().getMethod().getReference();
    ReflectionSummary summary=spec.getSummary(m);
    if (summary != null) {
      Set types=summary.getTypesForProgramLocation(site.getCallSite().getProgramCounter());
      if (types != null) {
        return types;
      }
    }
  }
  Set types=map.get(context);
  return types;
}",0.9965034965034965
100216,"@Override public int hashCode(){
  return programCounter;
}","@Override public int hashCode(){
  return programCounter + 77;
}",0.959349593495935
100217,"@Override public int hashCode(){
  return callSite.hashCode() * super.hashCode();
}","@Override public int hashCode(){
  return callSite.hashCode() * 19 + super.hashCode();
}",0.9707602339181286
100218,"protected IClassHierarchy buildClassHierarchy(){
  IClassHierarchy cha=null;
  ClassLoaderFactory factory=getClassLoaderFactory(scope.getExclusions(),getTranslatorExtension());
  try {
    cha=ClassHierarchy.make(getScope(),factory);
  }
 catch (  ClassHierarchyException e) {
    System.err.println(""String_Node_Str"");
    System.err.println(e.toString());
    e.printStackTrace();
  }
  return cha;
}","public IClassHierarchy buildClassHierarchy(){
  IClassHierarchy cha=null;
  ClassLoaderFactory factory=getClassLoaderFactory(scope.getExclusions(),getTranslatorExtension());
  try {
    cha=ClassHierarchy.make(getScope(),factory);
  }
 catch (  ClassHierarchyException e) {
    System.err.println(""String_Node_Str"");
    System.err.println(e.toString());
    e.printStackTrace();
  }
  return cha;
}",0.9837702871410736
100219,"protected IClassHierarchy buildClassHierarchy(){
  try {
    return ClassHierarchy.make(getScope(),loaderFactory,JavaScriptLoader.JS);
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE(e.toString());
    return null;
  }
}","public IClassHierarchy buildClassHierarchy(){
  try {
    return ClassHierarchy.make(getScope(),loaderFactory,JavaScriptLoader.JS);
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE(e.toString());
    return null;
  }
}",0.972972972972973
100220,"/** 
 * @param lifecycleEntrypoints Should EJB lifecycle entrypoints be considered as call graph entrypoints?
 */
public J2EEAnalysisScope(String baseScope,ClassLoader loader,String exclusionsFile,boolean lifecycleEntrypoints){
  super(baseScope,exclusionsFile,loader);
  this.lifecycleEntrypoints=lifecycleEntrypoints;
}","/** 
 * @param lifecycleEntrypoints Should EJB lifecycle entrypoints be considered as call graph entrypoints?
 */
public J2EEAnalysisScope(String baseScope,ClassLoader loader,String exclusionsFile,boolean lifecycleEntrypoints){
  super(Collections.singleton(Language.JAVA));
  AnalysisScope base=AnalysisScopeReader.read(baseScope,exclusionsFile,loader);
  for (  ClassLoaderReference cl : base.getLoaders()) {
    for (    Module m : base.getModules(cl)) {
      addToScope(cl,m);
    }
  }
  if (exclusionsFile != null) {
    FileOfClasses file=new FileOfClasses(exclusionsFile,loader);
    setExclusions(file);
  }
  this.lifecycleEntrypoints=lifecycleEntrypoints;
}",0.6484848484848484
100221,"/** 
 * @throws IllegalArgumentException  if method == null
 */
protected TypeReference[][] makeParameterTypes(IMethod method) throws IllegalArgumentException {
  if (method == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  TypeReference[][] result=new TypeReference[method.getNumberOfParameters()][];
  for (int i=0; i < result.length; i++) {
    TypeReference t=method.getParameterType(i);
    if (!t.isPrimitiveType()) {
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        t=null;
      }
 else       if (klass.isAbstract()) {
        t=chooseAConcreteSubClass(klass);
      }
 else       if (klass.isInterface()) {
        t=chooseAnImplementor(klass);
      }
 else       if (klass.isArrayClass()) {
        ArrayClass arrayKlass=(ArrayClass)klass;
        IClass innermost=arrayKlass.getInnermostElementClass();
        if (innermost != null && innermost.isInterface()) {
          TypeReference impl=chooseAnImplementor(innermost);
          if (impl == null) {
            t=null;
          }
 else {
            t=TypeReference.findOrCreateArrayOf(impl);
            for (int dim=1; dim < arrayKlass.getDimensionality(); dim++) {
              t=TypeReference.findOrCreateArrayOf(t);
            }
          }
        }
      }
    }
    result[i]=(t == null) ? new TypeReference[0] : new TypeReference[]{t};
  }
  return result;
}","/** 
 * @throws IllegalArgumentException  if method == null
 */
protected TypeReference[][] makeParameterTypes(IMethod method) throws IllegalArgumentException {
  if (method == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  TypeReference[][] result=new TypeReference[method.getNumberOfParameters()][];
  for (int i=0; i < result.length; i++) {
    TypeReference t=method.getParameterType(i);
    if (!t.isPrimitiveType()) {
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        t=null;
      }
 else       if (!klass.isInterface() && klass.isAbstract()) {
        t=chooseAConcreteSubClass(klass);
      }
 else       if (klass.isInterface()) {
        t=chooseAnImplementor(klass);
      }
 else       if (klass.isArrayClass()) {
        ArrayClass arrayKlass=(ArrayClass)klass;
        IClass innermost=arrayKlass.getInnermostElementClass();
        if (innermost != null && innermost.isInterface()) {
          TypeReference impl=chooseAnImplementor(innermost);
          if (impl == null) {
            t=null;
          }
 else {
            t=TypeReference.findOrCreateArrayOf(impl);
            for (int dim=1; dim < arrayKlass.getDimensionality(); dim++) {
              t=TypeReference.findOrCreateArrayOf(t);
            }
          }
        }
      }
    }
    result[i]=(t == null) ? new TypeReference[0] : new TypeReference[]{t};
  }
  return result;
}",0.9914285714285714
100222,"/** 
 * If s is a call statement, return the statement representing the normal return from s
 */
public static Statement getReturnStatementForCall(Statement s){
  if (s.getKind() == Kind.NORMAL) {
    SSAInstruction st=((NormalStatement)s).getInstruction();
    if (st instanceof SSAInvokeInstruction) {
      return new ParamStatement.NormalReturnCaller(s.getNode(),(SSAInvokeInstruction)st);
    }
 else {
      return s;
    }
  }
 else {
    return s;
  }
}","/** 
 * If s is a call statement, return the statement representing the normal return from s
 */
public static Statement getReturnStatementForCall(Statement s){
  if (s.getKind() == Kind.NORMAL) {
    SSAInstruction st=((NormalStatement)s).getInstruction();
    if (st instanceof SSAInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)st;
      if (call.getCallSite().getDeclaredTarget().getReturnType().equals(TypeReference.Void)) {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + call.getCallSite().getDeclaredTarget().getSignature() + ""String_Node_Str"");
      }
      return new ParamStatement.NormalReturnCaller(s.getNode(),(SSAInvokeInstruction)st);
    }
 else {
      return s;
    }
  }
 else {
    return s;
  }
}",0.7073552425665102
100223,"public IVocabulary getVocabulary(){
  return BasicVocabulary.make(Collections.emptySet());
}","public IVocabulary getVocabulary(){
  return BasicVocabulary.make(Collections.<IFunction>emptySet());
}",0.9435897435897436
100224,"public IMethod getCalleeTarget(CGNode N,CallSiteReference site,IClass receiver){
  MethodReference m=site.getDeclaredTarget();
  if (isEJBSuperInterface(m.getDeclaringClass())) {
    IClass inferred=getReceiverClassFromTypeInference(N,site);
    if (inferred != null) {
      receiver=inferred;
    }
  }
  if (FakeRootMethod.isFakeRootMethod(N.getMethod().getReference())) {
    if (deployment.isMessageDriven(m.getDeclaringClass())) {
      if (m.getName().equals(onMessageAtom) && m.getDescriptor().equals(onMessageDesc)) {
        return hijackOnMessageEntrypoint(m);
      }
    }
 else     if (receiver != null && cha.implementsInterface(receiver,ServletEntrypoints.Servlet)) {
      IMethod resolved=cha.resolveMethod(receiver,m.getSelector());
      if (!resolved.isInit() && !resolved.isClinit()) {
        return hijackServletEntrypoint(m);
      }
    }
  }
  m=specializeForReceiverType(receiver,m);
  SyntheticMethod X=methodReferenceIntercept(m);
  if (X != null) {
    return X;
  }
  IMethod target=parent.getCalleeTarget(N,site,receiver);
  if (target == null) {
    return null;
  }
  X=methodReferenceIntercept(target.getReference());
  if (X != null) {
    return X;
  }
 else {
    return target;
  }
}","public IMethod getCalleeTarget(CGNode N,CallSiteReference site,IClass receiver){
  MethodReference m=site.getDeclaredTarget();
  if (isEJBSuperInterface(m.getDeclaringClass())) {
    IClass inferred=getReceiverClassFromTypeInference(N,site);
    if (inferred != null) {
      receiver=inferred;
    }
  }
  IClass servlet=cha.lookupClass(ServletEntrypoints.Servlet);
  if (FakeRootMethod.isFakeRootMethod(N.getMethod().getReference())) {
    if (deployment.isMessageDriven(m.getDeclaringClass())) {
      if (m.getName().equals(onMessageAtom) && m.getDescriptor().equals(onMessageDesc)) {
        return hijackOnMessageEntrypoint(m);
      }
    }
 else     if (receiver != null && cha.implementsInterface(receiver,servlet)) {
      IMethod resolved=cha.resolveMethod(receiver,m.getSelector());
      if (!resolved.isInit() && !resolved.isClinit()) {
        return hijackServletEntrypoint(m);
      }
    }
  }
  m=specializeForReceiverType(receiver,m);
  SyntheticMethod X=methodReferenceIntercept(m);
  if (X != null) {
    return X;
  }
  IMethod target=parent.getCalleeTarget(N,site,receiver);
  if (target == null) {
    return null;
  }
  X=methodReferenceIntercept(target.getReference());
  if (X != null) {
    return X;
  }
 else {
    return target;
  }
}",0.9666532744073926
100225,"/** 
 * @param scope scope of analysis
 * @param cha loaded class hierarchy
 */
public ServletEntrypoints(J2EEAnalysisScope scope,IClassHierarchy cha){
  TypeReference servletType=TypeReference.findOrCreate(scope.getExtensionLoader(),servletName);
  TypeReference actionServletType=TypeReference.findOrCreate(scope.getApplicationLoader(),actionServlet);
  IClass actionServletClass=cha.lookupClass(actionServletType);
  ClassLoaderReference appLoaderRef=scope.getApplicationLoader();
  IClassLoader appLoader=cha.getLoader(appLoaderRef);
  for (Iterator<IClass> it=appLoader.iterateAllClasses(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    if (DEBUG) {
      Trace.println(getClass() + ""String_Node_Str"" + klass);
    }
    if (cha.lookupClass(klass.getReference()) == null) {
      continue;
    }
    if (cha.lookupClass(actionServletType) != null) {
      if (cha.isSubclassOf(klass,actionServletClass)) {
        continue;
      }
    }
    if (cha.implementsInterface(klass,servletType)) {
      servlets.add(klass);
      final TypeReference type=klass.getReference();
      for (int i=0; i < servletMethodNames.length; i++) {
        Atom name=servletMethodNames[i];
        Descriptor desc=servletMethodDescs[i];
        MethodReference M=MethodReference.findOrCreate(type,name,desc);
        IMethod m=cha.resolveMethod(M);
        if (cha.resolveMethod(M) != null) {
          entrypoints.add(new DefaultEntrypoint(m,cha){
            /** 
 * Assume all ServletRequest and ServletResponse are HTTP flavor.
 */
            public TypeReference[] getParameterTypes(            int i){
              if (i == 0) {
                return new TypeReference[]{type};
              }
 else {
                TypeReference[] tArray=super.getParameterTypes(i);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(tArray.length == 1);
                }
                TypeReference T=tArray[0];
                TypeName n=T.getName();
                TypeReference Tp=concreteParameterMap.get(n);
                if (Tp != null) {
                  T=Tp;
                }
                return new TypeReference[]{T};
              }
            }
          }
);
        }
      }
    }
  }
}","/** 
 * @param scope scope of analysis
 * @param cha loaded class hierarchy
 */
public ServletEntrypoints(J2EEAnalysisScope scope,IClassHierarchy cha){
  TypeReference servletType=TypeReference.findOrCreate(scope.getExtensionLoader(),servletName);
  TypeReference actionServletType=TypeReference.findOrCreate(scope.getApplicationLoader(),actionServlet);
  IClass actionServletClass=cha.lookupClass(actionServletType);
  ClassLoaderReference appLoaderRef=scope.getApplicationLoader();
  IClassLoader appLoader=cha.getLoader(appLoaderRef);
  IClass servlet=cha.lookupClass(servletType);
  for (Iterator<IClass> it=appLoader.iterateAllClasses(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    if (DEBUG) {
      Trace.println(getClass() + ""String_Node_Str"" + klass);
    }
    if (cha.lookupClass(klass.getReference()) == null) {
      continue;
    }
    if (cha.lookupClass(actionServletType) != null) {
      if (cha.isSubclassOf(klass,actionServletClass)) {
        continue;
      }
    }
    if (cha.implementsInterface(klass,servlet)) {
      servlets.add(klass);
      final TypeReference type=klass.getReference();
      for (int i=0; i < servletMethodNames.length; i++) {
        Atom name=servletMethodNames[i];
        Descriptor desc=servletMethodDescs[i];
        MethodReference M=MethodReference.findOrCreate(type,name,desc);
        IMethod m=cha.resolveMethod(M);
        if (cha.resolveMethod(M) != null) {
          entrypoints.add(new DefaultEntrypoint(m,cha){
            /** 
 * Assume all ServletRequest and ServletResponse are HTTP flavor.
 */
            public TypeReference[] getParameterTypes(            int i){
              if (i == 0) {
                return new TypeReference[]{type};
              }
 else {
                TypeReference[] tArray=super.getParameterTypes(i);
                if (Assertions.verifyAssertions) {
                  Assertions._assert(tArray.length == 1);
                }
                TypeReference T=tArray[0];
                TypeName n=T.getName();
                TypeReference Tp=concreteParameterMap.get(n);
                if (Tp != null) {
                  T=Tp;
                }
                return new TypeReference[]{T};
              }
            }
          }
);
        }
      }
    }
  }
}",0.9887491727332892
100226,"@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else {
    if (rhs instanceof PointType) {
      PointType other=(PointType)rhs;
      if (type.equals(other.type)) {
        return this;
      }
 else       if (type.isArrayClass() || other.type.isArrayClass()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
 else {
        return new ConeType(type.getClassHierarchy().getLeastCommonSuperclass(this.type,other.type));
      }
    }
 else     if (rhs instanceof ConeType) {
      ConeType other=(ConeType)rhs;
      TypeReference T=other.getType().getReference();
      if (type.isArrayClass() || T.isArrayType()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
      IClass typeKlass=type;
      if (type.getClassHierarchy().isSubclassOf(typeKlass,other.getType())) {
        return other;
      }
 else       if (other.isInterface()) {
        if (type.getClassHierarchy().implementsInterface(typeKlass,T)) {
          return other;
        }
      }
      return other.meet(new ConeType(other.getType()));
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + rhs.getClass());
      return null;
    }
  }
}","@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else {
    if (rhs instanceof PointType) {
      PointType other=(PointType)rhs;
      if (type.equals(other.type)) {
        return this;
      }
 else       if (type.isArrayClass() || other.type.isArrayClass()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
 else {
        return new ConeType(type.getClassHierarchy().getLeastCommonSuperclass(this.type,other.type));
      }
    }
 else     if (rhs instanceof ConeType) {
      ConeType other=(ConeType)rhs;
      TypeReference T=other.getType().getReference();
      if (type.isArrayClass() || T.isArrayType()) {
        return new ConeType(type.getClassHierarchy().getRootClass());
      }
      IClass typeKlass=type;
      if (type.getClassHierarchy().isSubclassOf(typeKlass,other.getType())) {
        return other;
      }
 else       if (other.isInterface()) {
        if (type.getClassHierarchy().implementsInterface(typeKlass,other.getType())) {
          return other;
        }
      }
      return other.meet(new ConeType(other.getType()));
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + rhs.getClass());
      return null;
    }
  }
}",0.9935691318327974
100227,"/** 
 * @return Collection of (IClass) interfaces this class implements, includingall ancestors of interfaces immediately implemented
 */
Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException ;","/** 
 * @return Collection of (IClass) interfaces this class implements, includingall ancestors of interfaces immediately implemented.
 */
Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException ;",0.9977220956719818
100228,"/** 
 * @return Collection of (IClass) interfaces this class directly implements
 */
Collection<IClass> getDirectInterfaces() throws ClassHierarchyException ;","/** 
 * @return Collection of (IClass) interfaces this class directly implementsIf this class is an interface, returns the interfaces it immediately extends.
 */
Collection<IClass> getDirectInterfaces() throws ClassHierarchyException ;",0.8040712468193384
100229,"public IMethod getMethod(Selector selector){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + selector + ""String_Node_Str""+ this);
  }
  if (methodMap == null) {
    try {
      computeMethodMap();
    }
 catch (    InvalidClassFileException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
  IMethod result=methodMap.get(selector);
  if (result != null) {
    return result;
  }
  if (inheritCache != null) {
    result=inheritCache.get(selector);
    if (result != null) {
      return result;
    }
  }
  try {
    if (!selector.equals(MethodReference.clinitSelector) && !selector.equals(MethodReference.initSelector)) {
      ShrikeClass superclass=(ShrikeClass)getSuperclass();
      if (superclass != null) {
        IMethod inherit=superclass.getMethod(selector);
        if (inherit != null) {
          if (inheritCache == null) {
            inheritCache=new BimodalMap<Selector,IMethod>(5);
          }
          inheritCache.put(selector,inherit);
          return inherit;
        }
      }
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
  try {
    if (isInterface() || isAbstract()) {
      final Iterator<IClass> it=(isInterface()) ? getAllAncestorInterfaces().iterator() : getAllImplementedInterfaces().iterator();
      while (it.hasNext()) {
        IClass k=it.next();
        result=k.getMethod(selector);
        if (result != null) {
          return result;
        }
      }
    }
  }
 catch (  ClassHierarchyException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE(""String_Node_Str"" + this);
  }
  return null;
}","public IMethod getMethod(Selector selector){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + selector + ""String_Node_Str""+ this);
  }
  if (methodMap == null) {
    try {
      computeMethodMap();
    }
 catch (    InvalidClassFileException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
  IMethod result=methodMap.get(selector);
  if (result != null) {
    return result;
  }
  if (inheritCache != null) {
    result=inheritCache.get(selector);
    if (result != null) {
      return result;
    }
  }
  try {
    if (!selector.equals(MethodReference.clinitSelector) && !selector.equals(MethodReference.initSelector)) {
      ShrikeClass superclass=(ShrikeClass)getSuperclass();
      if (superclass != null) {
        IMethod inherit=superclass.getMethod(selector);
        if (inherit != null) {
          if (inheritCache == null) {
            inheritCache=new BimodalMap<Selector,IMethod>(5);
          }
          inheritCache.put(selector,inherit);
          return inherit;
        }
      }
    }
  }
 catch (  ClassHierarchyException e) {
    Assertions.UNREACHABLE();
  }
  try {
    if (isInterface() || isAbstract()) {
      final Iterator<IClass> it=getAllImplementedInterfaces().iterator();
      while (it.hasNext()) {
        IClass k=it.next();
        result=k.getMethod(selector);
        if (result != null) {
          return result;
        }
      }
    }
  }
 catch (  ClassHierarchyException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE(""String_Node_Str"" + this);
  }
  return null;
}",0.9817150063051704
100230,"public IField getField(Atom name){
  if (fieldMap.containsKey(name)) {
    return fieldMap.get(name);
  }
 else {
    IField f=findDeclaredField(name);
    if (f != null) {
      fieldMap.put(name,f);
      return f;
    }
 else     if (superClass != null) {
      f=superClass.getField(name);
      if (f != null) {
        fieldMap.put(name,f);
        return f;
      }
    }
    try {
      Collection<IClass> ifaces=isInterface() ? getAllAncestorInterfaces() : getAllImplementedInterfaces();
      for (      IClass i : ifaces) {
        f=i.getField(name);
        if (f != null) {
          fieldMap.put(name,f);
          return f;
        }
      }
    }
 catch (    ClassHierarchyException e) {
    }
  }
  return null;
}","public IField getField(Atom name){
  if (fieldMap.containsKey(name)) {
    return fieldMap.get(name);
  }
 else {
    IField f=findDeclaredField(name);
    if (f != null) {
      fieldMap.put(name,f);
      return f;
    }
 else     if (superClass != null) {
      f=superClass.getField(name);
      if (f != null) {
        fieldMap.put(name,f);
        return f;
      }
    }
    try {
      for (      IClass i : getAllImplementedInterfaces()) {
        f=i.getField(name);
        if (f != null) {
          fieldMap.put(name,f);
          return f;
        }
      }
    }
 catch (    ClassHierarchyException e) {
    }
  }
  return null;
}",0.8932461873638344
100231,"public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  if (Assertions.verifyAssertions) {
    if (isInterface()) {
      Assertions.UNREACHABLE(""String_Node_Str"" + this);
    }
  }
  if (allInterfaces != null) {
    return allInterfaces;
  }
 else {
    Collection<IClass> C=computeAllInterfacesAsCollection();
    allInterfaces=Collections.unmodifiableCollection(C);
    return allInterfaces;
  }
}","public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  if (allInterfaces != null) {
    return allInterfaces;
  }
 else {
    Collection<IClass> C=computeAllInterfacesAsCollection();
    allInterfaces=Collections.unmodifiableCollection(C);
    return allInterfaces;
  }
}",0.8274932614555256
100232,"/** 
 * @return true if it may be possible to resolve a call to a site on the concrete type dispatchType
 */
public static boolean feasibleChaResolution(IClassHierarchy cha,CallSiteReference site,IClass dispatchType){
  if (dispatchType == null) {
    return false;
  }
  if (dispatchType.isInterface()) {
    if (site.getDeclaredTarget().getSelector().equals(MethodReference.clinitSelector)) {
      return true;
    }
 else {
      return false;
    }
  }
  TypeReference targetType=site.getDeclaredTarget().getDeclaringClass();
  IClass resolvedType=cha.lookupClass(targetType);
  if (resolvedType == null) {
    return false;
  }
 else {
    if (resolvedType.isInterface()) {
      return cha.implementsInterface(dispatchType,resolvedType.getReference());
    }
 else {
      return cha.isSubclassOf(dispatchType,resolvedType);
    }
  }
}","/** 
 * @return true if it may be possible to resolve a call to a site on the concrete type dispatchType
 */
public static boolean feasibleChaResolution(IClassHierarchy cha,CallSiteReference site,IClass dispatchType){
  if (dispatchType == null) {
    return false;
  }
  if (dispatchType.isInterface()) {
    if (site.getDeclaredTarget().getSelector().equals(MethodReference.clinitSelector)) {
      return true;
    }
 else {
      return false;
    }
  }
  TypeReference targetType=site.getDeclaredTarget().getDeclaringClass();
  IClass resolvedType=cha.lookupClass(targetType);
  if (resolvedType == null) {
    return false;
  }
 else {
    if (resolvedType.isInterface()) {
      return cha.implementsInterface(dispatchType,resolvedType);
    }
 else {
      return cha.isSubclassOf(dispatchType,resolvedType);
    }
  }
}",0.9910233393177738
100233,"/** 
 * @param C
 * @return true iff C is a container class from java.util
 * @throws IllegalArgumentException  if C is null
 */
public static boolean isContainer(IClass C,IClassHierarchy cha){
  if (C == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (ClassLoaderReference.Primordial.equals(C.getClassLoader().getReference()) && TypeReference.JavaUtilCollection.getName().getPackage().equals(C.getReference().getName().getPackage())) {
    if (C.isInterface()) {
      IClass collection=cha.lookupClass(TypeReference.JavaUtilCollection);
      IClass map=cha.lookupClass(TypeReference.JavaUtilMap);
      if (Assertions.verifyAssertions) {
        Assertions._assert(collection != null);
        Assertions._assert(map != null);
      }
      Collection s;
      try {
        s=C.getAllAncestorInterfaces();
      }
 catch (      ClassHierarchyException e) {
        return false;
      }
      if (s.contains(collection) || s.contains(map)) {
        return true;
      }
    }
 else {
      if (cha.implementsInterface(C,TypeReference.JavaUtilCollection) || cha.implementsInterface(C,TypeReference.JavaUtilMap)) {
        return true;
      }
    }
  }
  if (miscContainers.contains(C.getReference())) {
    return true;
  }
  if (C.isArrayClass() && ((ArrayClass)C).getElementClass() != null && ((ArrayClass)C).getElementClass().getReference().isReferenceType()) {
    return true;
  }
  return false;
}","/** 
 * @param C
 * @return true iff C is a container class from java.util
 * @throws IllegalArgumentException  if C is null
 */
public static boolean isContainer(IClass C,IClassHierarchy cha){
  if (C == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (ClassLoaderReference.Primordial.equals(C.getClassLoader().getReference()) && TypeReference.JavaUtilCollection.getName().getPackage().equals(C.getReference().getName().getPackage())) {
    IClass collection=cha.lookupClass(TypeReference.JavaUtilCollection);
    IClass map=cha.lookupClass(TypeReference.JavaUtilMap);
    if (C.isInterface()) {
      if (Assertions.verifyAssertions) {
        Assertions._assert(collection != null);
        Assertions._assert(map != null);
      }
      Collection s;
      try {
        s=C.getAllImplementedInterfaces();
      }
 catch (      ClassHierarchyException e) {
        return false;
      }
      if (s.contains(collection) || s.contains(map)) {
        return true;
      }
    }
 else {
      if (cha.implementsInterface(C,collection) || cha.implementsInterface(C,map)) {
        return true;
      }
    }
  }
  if (miscContainers.contains(C.getReference())) {
    return true;
  }
  if (C.isArrayClass() && ((ArrayClass)C).getElementClass() != null && ((ArrayClass)C).getElementClass().getReference().isReferenceType()) {
    return true;
  }
  return false;
}",0.7408978437610463
100234,"private OrdinalSet<InstanceKey> computeImplicitPointsToSetAtCheckCast(CGNode node,SSACheckCastInstruction instruction){
  PointerKey rhs=pointerKeys.getPointerKeyForLocal(node,instruction.getVal());
  OrdinalSet<InstanceKey> rhsSet=getPointsToSet(rhs);
  MutableSparseIntSet S=MutableSparseIntSet.makeEmpty();
  IClass klass=getCallGraph().getClassHierarchy().lookupClass(instruction.getDeclaredResultType());
  if (klass == null) {
    return rhsSet;
  }
 else {
    if (klass.isInterface()) {
      for (Iterator it=rhsSet.iterator(); it.hasNext(); ) {
        InstanceKey ik=(InstanceKey)it.next();
        if (getCallGraph().getClassHierarchy().implementsInterface(ik.getConcreteType(),klass.getReference())) {
          S.add(getInstanceKeyMapping().getMappedIndex(ik));
        }
      }
    }
 else {
      for (Iterator it=rhsSet.iterator(); it.hasNext(); ) {
        InstanceKey ik=(InstanceKey)it.next();
        if (getCallGraph().getClassHierarchy().isSubclassOf(ik.getConcreteType(),klass)) {
          S.add(getInstanceKeyMapping().getMappedIndex(ik));
        }
      }
    }
  }
  return new OrdinalSet<InstanceKey>(S,instanceKeys);
}","private OrdinalSet<InstanceKey> computeImplicitPointsToSetAtCheckCast(CGNode node,SSACheckCastInstruction instruction){
  PointerKey rhs=pointerKeys.getPointerKeyForLocal(node,instruction.getVal());
  OrdinalSet<InstanceKey> rhsSet=getPointsToSet(rhs);
  MutableSparseIntSet S=MutableSparseIntSet.makeEmpty();
  IClass klass=getCallGraph().getClassHierarchy().lookupClass(instruction.getDeclaredResultType());
  if (klass == null) {
    return rhsSet;
  }
 else {
    if (klass.isInterface()) {
      for (Iterator it=rhsSet.iterator(); it.hasNext(); ) {
        InstanceKey ik=(InstanceKey)it.next();
        if (getCallGraph().getClassHierarchy().implementsInterface(ik.getConcreteType(),klass)) {
          S.add(getInstanceKeyMapping().getMappedIndex(ik));
        }
      }
    }
 else {
      for (Iterator it=rhsSet.iterator(); it.hasNext(); ) {
        InstanceKey ik=(InstanceKey)it.next();
        if (getCallGraph().getClassHierarchy().isSubclassOf(ik.getConcreteType(),klass)) {
          S.add(getInstanceKeyMapping().getMappedIndex(ik));
        }
      }
    }
  }
  return new OrdinalSet<InstanceKey>(S,instanceKeys);
}",0.9934354485776804
100235,"public void act(int i){
  InstanceKey I=system.getInstanceKey(i);
  if (!I.getConcreteType().isArrayClass()) {
    return;
  }
  TypeReference C=I.getConcreteType().getReference().getArrayElementType();
  if (C.isPrimitiveType()) {
    return;
  }
  IClass contents=getClassHierarchy().lookupClass(C);
  if (Assertions.verifyAssertions) {
    if (contents == null) {
      Assertions._assert(false,""String_Node_Str"" + C + ""String_Node_Str""+ I.getConcreteType());
    }
  }
  PointerKey p=getPointerKeyForArrayContents(I);
  if (contents.isInterface()) {
    if (getClassHierarchy().implementsInterface(instance.getConcreteType(),contents.getReference())) {
      sideEffect.b|=system.newConstraint(p,instance);
    }
  }
 else {
    if (getClassHierarchy().isSubclassOf(instance.getConcreteType(),contents)) {
      sideEffect.b|=system.newConstraint(p,instance);
    }
  }
}","public void act(int i){
  InstanceKey I=system.getInstanceKey(i);
  if (!I.getConcreteType().isArrayClass()) {
    return;
  }
  TypeReference C=I.getConcreteType().getReference().getArrayElementType();
  if (C.isPrimitiveType()) {
    return;
  }
  IClass contents=getClassHierarchy().lookupClass(C);
  if (Assertions.verifyAssertions) {
    if (contents == null) {
      Assertions._assert(false,""String_Node_Str"" + C + ""String_Node_Str""+ I.getConcreteType());
    }
  }
  PointerKey p=getPointerKeyForArrayContents(I);
  if (contents.isInterface()) {
    if (getClassHierarchy().implementsInterface(instance.getConcreteType(),contents)) {
      sideEffect.b|=system.newConstraint(p,instance);
    }
  }
 else {
    if (getClassHierarchy().isSubclassOf(instance.getConcreteType(),contents)) {
      sideEffect.b|=system.newConstraint(p,instance);
    }
  }
}",0.9913544668587896
100236,"private void registerArrayInstanceWithAllInterfacesOfElement(int index,IClass elementClass,int dim){
  Collection ifaces=null;
  try {
    ifaces=(elementClass.isInterface()) ? elementClass.getAllAncestorInterfaces() : elementClass.getAllImplementedInterfaces();
  }
 catch (  ClassHierarchyException e) {
    Warnings.add(ClassHierarchyWarning.create(e.getMessage()));
    return;
  }
  for (Iterator it=ifaces.iterator(); it.hasNext(); ) {
    IClass I=(IClass)it.next();
    TypeReference iArrayRef=makeArray(I.getReference(),dim);
    IClass iArrayClass=null;
    iArrayClass=I.getClassLoader().lookupClass(iArrayRef.getName());
    MutableIntSet set=findOrCreateSparseSetForClass(iArrayClass);
    set.add(index);
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + iArrayClass + ""String_Node_Str""+ set);
    }
  }
}","private void registerArrayInstanceWithAllInterfacesOfElement(int index,IClass elementClass,int dim){
  Collection ifaces=null;
  try {
    ifaces=elementClass.getAllImplementedInterfaces();
  }
 catch (  ClassHierarchyException e) {
    Warnings.add(ClassHierarchyWarning.create(e.getMessage()));
    return;
  }
  for (Iterator it=ifaces.iterator(); it.hasNext(); ) {
    IClass I=(IClass)it.next();
    TypeReference iArrayRef=makeArray(I.getReference(),dim);
    IClass iArrayClass=null;
    iArrayClass=I.getClassLoader().lookupClass(iArrayRef.getName());
    MutableIntSet set=findOrCreateSparseSetForClass(iArrayClass);
    set.add(index);
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + iArrayClass + ""String_Node_Str""+ set);
    }
  }
}",0.9537682077264092
100237,"/** 
 * Does c implement T?
 * @param c
 * @param T
 * @return true iff T is an interface and c is a class that implements T,
 */
public boolean implementsInterface(IClass c,TypeReference T){
  IClass tClass=lookupClass(T);
  if (Assertions.verifyAssertions) {
    if (tClass == null) {
      Assertions._assert(false,""String_Node_Str"" + T);
    }
  }
  if (!tClass.isInterface()) {
    return false;
  }
  Set impls=implementors.get(tClass);
  if (impls != null && impls.contains(c)) {
    return true;
  }
  return false;
}","/** 
 * Does c implement i?
 * @return true iff i is an interface and c is a class that implements i, rc is an interface that extends i.
 */
public boolean implementsInterface(IClass c,IClass i){
  if (!i.isInterface()) {
    return false;
  }
  Set impls=implementors.get(i);
  if (impls != null && impls.contains(c)) {
    return true;
  }
  return false;
}",0.6809954751131222
100238,"/** 
 * @param klass
 * @return true if the add succeeded; false if it failed for some reason
 * @throws IllegalArgumentException if klass is null
 */
public boolean addClass(IClass klass){
  if (klass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + klass);
  }
  Set<IClass> loadedSuperclasses;
  Collection loadedSuperInterfaces;
  try {
    loadedSuperclasses=computeSuperclasses(klass);
    loadedSuperInterfaces=klass.isInterface() ? null : klass.getAllImplementedInterfaces();
  }
 catch (  ClassHierarchyException e) {
    if (klass instanceof ShrikeClass) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + klass);
      }
    }
    Warnings.add(ClassExclusion.create(klass.getReference(),e.getMessage()));
    return false;
  }
  Node node=findOrCreateNode(klass);
  if (klass.getReference().equals(language.getRootType())) {
    Assertions._assert(root == null);
    root=node;
  }
  Set workingSuperclasses=HashSetFactory.make(loadedSuperclasses);
  while (node != null) {
    IClass c=node.getJavaClass();
    IClass superclass=null;
    try {
      superclass=c.getSuperclass();
    }
 catch (    ClassHierarchyException e1) {
      Assertions.UNREACHABLE();
    }
    if (superclass != null) {
      workingSuperclasses.remove(superclass);
      Node supernode=findOrCreateNode(superclass);
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + node.getJavaClass() + ""String_Node_Str""+ supernode.getJavaClass());
      }
      supernode.addChild(node);
      if (supernode.getJavaClass().getReference().equals(language.getRootType())) {
        node=null;
      }
 else {
        node=supernode;
      }
    }
 else {
      node=null;
    }
  }
  if (loadedSuperInterfaces != null) {
    for (Iterator it3=loadedSuperInterfaces.iterator(); it3.hasNext(); ) {
      IClass iface=(IClass)it3.next();
      try {
        computeSuperclasses(iface);
      }
 catch (      ClassHierarchyException e) {
        Warnings.add(ClassExclusion.create(iface.getReference(),e.getMessage()));
        continue;
      }
      if (DEBUG && Assertions.verifyAssertions) {
        if (!iface.isInterface()) {
          Assertions._assert(false,""String_Node_Str"" + iface);
        }
        if (klass.isInterface()) {
          Assertions._assert(false,""String_Node_Str"" + klass);
        }
      }
      recordImplements(klass,iface);
    }
  }
  return true;
}","/** 
 * @param klass
 * @return true if the add succeeded; false if it failed for some reason
 * @throws IllegalArgumentException if klass is null
 */
public boolean addClass(IClass klass){
  if (klass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + klass);
  }
  Set<IClass> loadedSuperclasses;
  Collection loadedSuperInterfaces;
  try {
    loadedSuperclasses=computeSuperclasses(klass);
    loadedSuperInterfaces=klass.getAllImplementedInterfaces();
  }
 catch (  ClassHierarchyException e) {
    if (klass instanceof ShrikeClass) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + klass);
      }
    }
    Warnings.add(ClassExclusion.create(klass.getReference(),e.getMessage()));
    return false;
  }
  Node node=findOrCreateNode(klass);
  if (klass.getReference().equals(language.getRootType())) {
    Assertions._assert(root == null);
    root=node;
  }
  Set workingSuperclasses=HashSetFactory.make(loadedSuperclasses);
  while (node != null) {
    IClass c=node.getJavaClass();
    IClass superclass=null;
    try {
      superclass=c.getSuperclass();
    }
 catch (    ClassHierarchyException e1) {
      Assertions.UNREACHABLE();
    }
    if (superclass != null) {
      workingSuperclasses.remove(superclass);
      Node supernode=findOrCreateNode(superclass);
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + node.getJavaClass() + ""String_Node_Str""+ supernode.getJavaClass());
      }
      supernode.addChild(node);
      if (supernode.getJavaClass().getReference().equals(language.getRootType())) {
        node=null;
      }
 else {
        node=supernode;
      }
    }
 else {
      node=null;
    }
  }
  if (loadedSuperInterfaces != null) {
    for (Iterator it3=loadedSuperInterfaces.iterator(); it3.hasNext(); ) {
      IClass iface=(IClass)it3.next();
      try {
        computeSuperclasses(iface);
      }
 catch (      ClassHierarchyException e) {
        Warnings.add(ClassExclusion.create(iface.getReference(),e.getMessage()));
        continue;
      }
      if (DEBUG && Assertions.verifyAssertions) {
        if (!iface.isInterface()) {
          Assertions._assert(false,""String_Node_Str"" + iface);
        }
        if (klass.isInterface()) {
          Assertions._assert(false,""String_Node_Str"" + klass);
        }
      }
      recordImplements(klass,iface);
    }
  }
  return true;
}",0.9940585945502972
100239,"/** 
 * Find the possible receivers of a call to a method reference
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
private Set<IMethod> computePossibleTargets(IClass declaredClass,MethodReference ref){
  if (declaredClass.isInterface()) {
    HashSet<IMethod> result=HashSetFactory.make(3);
    Set impls=implementors.get(declaredClass);
    if (impls == null) {
      return Collections.emptySet();
    }
    for (Iterator it=impls.iterator(); it.hasNext(); ) {
      IClass klass=(IClass)it.next();
      if (Assertions.verifyAssertions) {
        Assertions._assert(!klass.isInterface());
      }
      result.addAll(computeTargetsNotInterface(ref,klass));
    }
    return result;
  }
 else {
    return computeTargetsNotInterface(ref,declaredClass);
  }
}","/** 
 * Find the possible receivers of a call to a method reference
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
private Set<IMethod> computePossibleTargets(IClass declaredClass,MethodReference ref){
  if (declaredClass.isInterface()) {
    HashSet<IMethod> result=HashSetFactory.make(3);
    Set impls=implementors.get(declaredClass);
    if (impls == null) {
      return Collections.emptySet();
    }
    for (Iterator it=impls.iterator(); it.hasNext(); ) {
      IClass klass=(IClass)it.next();
      if (!klass.isInterface()) {
        result.addAll(computeTargetsNotInterface(ref,klass));
      }
    }
    return result;
  }
 else {
    return computeTargetsNotInterface(ref,declaredClass);
  }
}",0.926517571884984
100240,"/** 
 * Does an expression c1 x := c2 y typecheck? i.e. is c2 a subtype of c1?
 * @throws IllegalArgumentException if c1 is null
 * @throws IllegalArgumentException if c2 is null
 */
public boolean isAssignableFrom(IClass c1,IClass c2){
  if (c2 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (c1 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (c1.isInterface()) {
    if (c2.isInterface()) {
      return isSubclassOf(c2,c1);
    }
 else {
      return implementsInterface(c2,c1.getReference());
    }
  }
 else {
    if (c2.isInterface()) {
      return c1.equals(getRootClass());
    }
 else {
      return isSubclassOf(c2,c1);
    }
  }
}","/** 
 * Does an expression c1 x := c2 y typecheck? i.e. is c2 a subtype of c1?
 * @throws IllegalArgumentException if c1 is null
 * @throws IllegalArgumentException if c2 is null
 */
public boolean isAssignableFrom(IClass c1,IClass c2){
  if (c2 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (c1 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (c1.isInterface()) {
    return implementsInterface(c2,c1);
  }
 else {
    if (c2.isInterface()) {
      return c1.equals(getRootClass());
    }
 else {
      return isSubclassOf(c2,c1);
    }
  }
}",0.7646610814927647
100241,"/** 
 * Does c implement T?
 * @return true iff T is an interface and c is a class that implements T,
 */
public boolean implementsInterface(IClass c,TypeReference T);","/** 
 * Does c implement i?
 * @return true iff i is an interface and c is a class that implements i,
 */
public boolean implementsInterface(IClass c,IClass i);",0.9174311926605504
100242,"public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  Collection<IClass> realIfaces=realType.isInterface() ? realType.getAllAncestorInterfaces() : realType.getAllImplementedInterfaces();
  if (realType.isInterface()) {
    HashSet<IClass> result=HashSetFactory.make(realIfaces);
    result.add(realType);
    return result;
  }
 else {
    return realIfaces;
  }
}","public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  Collection<IClass> realIfaces=realType.getAllImplementedInterfaces();
  if (realType.isInterface()) {
    HashSet<IClass> result=HashSetFactory.make(realIfaces);
    result.add(realType);
    return result;
  }
 else {
    return realIfaces;
  }
}",0.9147496617050068
100243,"public boolean implementsInterface(IClass c,TypeReference T){
  return getHierarchy(c).implementsInterface(c,T);
}","public boolean implementsInterface(IClass c,IClass i){
  return getHierarchy(c).implementsInterface(c,i);
}",0.8959276018099548
100244,"public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  Assertions._assert(!isInterface());
  return gatherInterfaces();
}","public Collection<IClass> getAllImplementedInterfaces() throws ClassHierarchyException {
  return gatherInterfaces();
}",0.8623188405797102
100245,"public static AnalysisScope makeScope(URL[] files,JavaScriptLoaderFactory loaders) throws IOException {
  return new CAstAnalysisScope(files,loaders);
}","public static AnalysisScope makeScope(URL[] files,JavaScriptLoaderFactory loaders) throws IOException {
  AnalysisScope result=new CAstAnalysisScope(files,loaders);
  result.addLanguageToScope(JavaScriptLoader.JS);
  return result;
}",0.7532467532467533
100246,"/** 
 * delete all files (recursively) in a directory. This is dangerous. Use with care.
 * @throws IOException if there's a problem deleting some file
 */
public static void deleteContents(String directory) throws IOException {
  Collection fl=listFiles(directory,null,true);
  for (Iterator it=fl.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    if (!f.isDirectory()) {
      boolean result=f.delete();
      if (!result) {
        throw new IOException(""String_Node_Str"" + f);
      }
    }
  }
  int lastCount=Integer.MAX_VALUE;
  do {
    Collection f2=listFiles(directory,null,true);
    if (f2.size() == lastCount) {
      throw new IOException(""String_Node_Str"");
    }
    for (Iterator it=f2.iterator(); it.hasNext(); ) {
      File f=(File)it.next();
      f.delete();
    }
  }
 while (listFiles(directory,null,true).size() > 0);
}","/** 
 * delete all files (recursively) in a directory. This is dangerous. Use with care.
 * @throws IOException if there's a problem deleting some file
 */
public static void deleteContents(String directory) throws IOException {
  Collection fl=listFiles(directory,null,true);
  for (Iterator it=fl.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    if (!f.isDirectory()) {
      boolean result=f.delete();
      if (!result) {
        throw new IOException(""String_Node_Str"" + f);
      }
    }
  }
  int lastCount=Integer.MAX_VALUE;
  do {
    Collection f2=listFiles(directory,null,true);
    if (f2.size() == lastCount) {
      throw new IOException(""String_Node_Str"");
    }
    lastCount=f2.size();
    for (Iterator it=f2.iterator(); it.hasNext(); ) {
      File f=(File)it.next();
      f.delete();
    }
  }
 while (listFiles(directory,null,true).size() > 0);
}",0.985607369027058
100247,"public static <T>Dominators make(Graph<T> G,T root){
  if (G instanceof NumberedGraph) {
    return new NumberedDominators((NumberedGraph)G,(INodeWithNumber)root);
  }
 else {
    return new GenericDominators(G,root);
  }
}","@SuppressWarnings(""String_Node_Str"") public static <T>Dominators<T> make(Graph<T> G,T root){
  if (G instanceof NumberedGraph && root instanceof INodeWithNumber) {
    return new NumberedDominators((NumberedGraph)G,(INodeWithNumber)root);
  }
 else {
    return new GenericDominators<T>(G,root);
  }
}",0.851145038167939
100248,"public String toString(){
  StringBuffer sb=new StringBuffer();
  for (Iterator<? extends T> i=G.iterator(); i.hasNext(); ) {
    T node=i.next();
    sb.append(""String_Node_Str"" + node + ""String_Node_Str"");
    for (Iterator j=dominators(node); j.hasNext(); )     sb.append(""String_Node_Str"" + j.next() + ""String_Node_Str"");
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  for (Iterator<? extends T> i=G.iterator(); i.hasNext(); ) {
    T node=i.next();
    sb.append(""String_Node_Str"" + node + ""String_Node_Str"");
    for (Iterator j=dominators(node); j.hasNext(); )     sb.append(""String_Node_Str"" + j.next() + ""String_Node_Str"");
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}",0.9873096446700508
100249,"protected DominatorInfo getInfo(T node){
  if (!infoMap.containsKey(node))   infoMap.put(node,new DominatorInfo(node));
  return infoMap.get(node);
}","@Override protected DominatorInfo getInfo(T node){
  if (!infoMap.containsKey(node))   infoMap.put(node,new DominatorInfo(node));
  return infoMap.get(node);
}",0.9675324675324676
100250,"protected final DominatorInfo getInfo(T node){
  return (DominatorInfo)infoMap[node.getGraphNodeId()];
}","@Override protected final DominatorInfo getInfo(T node){
  return (DominatorInfo)infoMap[node.getGraphNodeId()];
}",0.9541284403669724
100251,"public NumberedGraph<T> getGraph(){
  return (NumberedGraph)G;
}","@Override public NumberedGraph<T> getGraph(){
  return (NumberedGraph<T>)G;
}",0.9078014184397164
100252,"/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  klasses=HashSetFactory.make(klasses);
  klasses.retainAll(this.klasses);
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(klasses);
  return result;
}","/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  Collection<IClass> c=HashSetFactory.make();
  for (  IClass klass : klasses) {
    if (klass.isArrayClass()) {
      c.add(klass);
    }
 else     if (this.klasses.contains(klass)) {
      c.add(klass);
    }
  }
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(c);
  return result;
}",0.8430379746835444
100253,"/** 
 * @param klasses Collection<IClass>
 * @throws AssertionError  if klasses is null
 */
private TypeBasedPointerAnalysis(AnalysisOptions options,Collection<IClass> klasses,CallGraph cg) throws AssertionError {
  super(cg,makeInstanceKeys(klasses));
  this.klasses=klasses;
  heapModel=new TypeBasedHeapModel(options,klasses,cg);
}","/** 
 * @param klasses Collection<IClass>
 * @throws AssertionError if klasses is null
 */
private TypeBasedPointerAnalysis(AnalysisOptions options,Collection<IClass> klasses,CallGraph cg) throws AssertionError {
  super(cg,makeInstanceKeys(klasses));
  this.klasses=klasses;
  heapModel=new TypeBasedHeapModel(options,klasses,cg);
}",0.9985007496251874
100254,"@Override public void putAll(Map<? extends K,? extends V> arg0){
  if (arg0 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  Map.Entry<K,V> E : entrySet()) {
    put(E.getKey(),E.getValue());
  }
}","@Override public void putAll(Map<? extends K,? extends V> arg0){
  if (arg0 == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  Map.Entry<? extends K,? extends V> E : arg0.entrySet()) {
    put(E.getKey(),E.getValue());
  }
}",0.9486652977412732
100255,"private OrdinalSet<InstanceKey> toOrdinalInstanceKeySet(Collection c){
  BimodalMutableIntSet s=new BimodalMutableIntSet();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    int index=getInstanceKeyMapping().getMappedIndex(new ConcreteTypeKey(klass));
    if (index >= 0) {
      s.add(index);
    }
  }
  return new OrdinalSet<InstanceKey>(s,getInstanceKeyMapping());
}","private OrdinalSet<InstanceKey> toOrdinalInstanceKeySet(Collection c){
  BimodalMutableIntSet s=new BimodalMutableIntSet();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    int index=getInstanceKeyMapping().add(new ConcreteTypeKey(klass));
    s.add(index);
  }
  return new OrdinalSet<InstanceKey>(s,getInstanceKeyMapping());
}",0.8297055057618438
100256,"@Override protected void initializeVariables(){
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(TypeAbstraction.TOP);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (Assertions.verifyAssertions) {
        Assertions._assert(defaultExceptions.size() == 1);
      }
      TypeReference t=defaultExceptions.iterator().next();
      IClass klass=cha.lookupClass(t);
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass != null);
      }
      v.setType(new PointType(klass));
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}","@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (Assertions.verifyAssertions) {
        Assertions._assert(defaultExceptions.size() == 1);
      }
      TypeReference t=defaultExceptions.iterator().next();
      IClass klass=cha.lookupClass(t);
      if (Assertions.verifyAssertions) {
        Assertions._assert(klass != null);
      }
      v.setType(new PointType(klass));
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}",0.932649420160571
100257,"/** 
 * @return Returns the iKeyFactory.
 */
protected ClassBasedInstanceKeys getIKeyFactory(){
  return iKeyFactory;
}","protected ClassBasedInstanceKeys getIKeyFactory(){
  return iKeyFactory;
}",0.7668393782383419
100258,"/** 
 */
private Map<PointerKey,Object> computePointerKeys(IClass klass){
  Map<PointerKey,Object> result=HashMapFactory.make();
  if (klass.isArrayClass()) {
    ArrayClass a=(ArrayClass)klass;
    if (a.getElementClass() != null && a.getElementClass().isReferenceType()) {
      PointerKey p=pointerKeys.getPointerKeyForArrayContents(new ConcreteTypeKey(a));
      result.put(p,p);
    }
  }
 else {
    try {
      for (Iterator<IField> it=klass.getAllFields().iterator(); it.hasNext(); ) {
        IField f=it.next();
        if (!f.getFieldTypeReference().isPrimitiveType()) {
          if (f.isStatic()) {
            PointerKey p=pointerKeys.getPointerKeyForStaticField(f);
            result.put(p,p);
          }
 else {
            PointerKey p=pointerKeys.getPointerKeyForInstanceField(new ConcreteTypeKey(klass),f);
            result.put(p,p);
          }
        }
      }
    }
 catch (    ClassHierarchyException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
  return result;
}","private Map<PointerKey,Object> computePointerKeys(IClass klass){
  Map<PointerKey,Object> result=HashMapFactory.make();
  if (klass.isArrayClass()) {
    ArrayClass a=(ArrayClass)klass;
    if (a.getElementClass() != null && a.getElementClass().isReferenceType()) {
      PointerKey p=pointerKeys.getPointerKeyForArrayContents(new ConcreteTypeKey(a));
      result.put(p,p);
    }
  }
 else {
    try {
      for (Iterator<IField> it=klass.getAllFields().iterator(); it.hasNext(); ) {
        IField f=it.next();
        if (!f.getFieldTypeReference().isPrimitiveType()) {
          if (f.isStatic()) {
            PointerKey p=pointerKeys.getPointerKeyForStaticField(f);
            result.put(p,p);
          }
 else {
            PointerKey p=pointerKeys.getPointerKeyForInstanceField(new ConcreteTypeKey(klass),f);
            result.put(p,p);
          }
        }
      }
    }
 catch (    ClassHierarchyException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
  return result;
}",0.9955730447614364
100259,"public PointerKey getPointerKeyForLocal(CGNode node,int valueNumber){
  initPKeysForNode(node);
  PointerKey p=pointerKeys.getPointerKeyForLocal(node,valueNumber);
  Object result=pKeys.get(p);
  if (result == null) {
    return null;
  }
  if (result instanceof FilteredPointerKey) {
    return (PointerKey)result;
  }
 else {
    if (result instanceof ConcreteTypeKey) {
      ConcreteTypeKey c=(ConcreteTypeKey)result;
      if (c.getConcreteType().getReference().equals(TypeReference.JavaLangString)) {
        return pointerKeys.getFilteredPointerKeyForLocal(node,valueNumber,new FilteredPointerKey.SingleClassFilter(c.getConcreteType()));
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"" + result.getClass());
        return null;
      }
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + result.getClass());
      return null;
    }
  }
}","/** 
 * Note that this always returns a    {@link FilteredPointerKey}, since the   {@link TypeBasedPointerAnalysis} relies on thetype filter to compute points to sets.
 * @see com.ibm.wala.ipa.callgraph.propagation.PointerKeyFactory#getPointerKeyForLocal(com.ibm.wala.ipa.callgraph.CGNode,int)
 */
public FilteredPointerKey getPointerKeyForLocal(CGNode node,int valueNumber){
  initPKeysForNode(node);
  PointerKey p=pointerKeys.getPointerKeyForLocal(node,valueNumber);
  Object result=pKeys.get(p);
  if (result == null) {
    return null;
  }
  if (result instanceof FilteredPointerKey) {
    return (FilteredPointerKey)result;
  }
 else {
    if (result instanceof ConcreteTypeKey) {
      ConcreteTypeKey c=(ConcreteTypeKey)result;
      if (c.getConcreteType().getReference().equals(TypeReference.JavaLangString)) {
        return pointerKeys.getFilteredPointerKeyForLocal(node,valueNumber,new FilteredPointerKey.SingleClassFilter(c.getConcreteType()));
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"" + result.getClass());
        return null;
      }
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"" + result.getClass());
      return null;
    }
  }
}",0.8312318137730359
100260,"public boolean isCatchBlock(){
  return original.isCatchBlock();
}","public boolean isCatchBlock(){
  return (original.isCatchBlock() && instructionIndex == original.getFirstInstructionIndex());
}",0.6839378238341969
100261,"@SuppressWarnings(""String_Node_Str"") public String getLabel(Object o) throws WalaException {
  T t=(T)o;
  if (t instanceof BasicBlockInContext) {
    BasicBlockInContext bb=(BasicBlockInContext)t;
    if (bb.getDelegate() instanceof ExplodedBasicBlock) {
      ExplodedBasicBlock delegate=(ExplodedBasicBlock)bb.getDelegate();
      String s=delegate.getNumber() + ""String_Node_Str"" + result.getResult(t)+ ""String_Node_Str""+ delegate.getInstruction();
      for (Iterator<SSAPhiInstruction> phis=delegate.iteratePhis(); phis.hasNext(); ) {
        SSAPhiInstruction phi=phis.next();
        s+=""String_Node_Str"" + phi;
      }
      return s;
    }
  }
  return t + ""String_Node_Str"" + result.getResult(t);
}","@SuppressWarnings(""String_Node_Str"") public String getLabel(Object o) throws WalaException {
  T t=(T)o;
  if (t instanceof BasicBlockInContext) {
    BasicBlockInContext bb=(BasicBlockInContext)t;
    if (bb.getDelegate() instanceof ExplodedBasicBlock) {
      ExplodedBasicBlock delegate=(ExplodedBasicBlock)bb.getDelegate();
      String s=delegate.getNumber() + ""String_Node_Str"" + result.getResult(t)+ ""String_Node_Str""+ delegate.getInstruction();
      for (Iterator<SSAPhiInstruction> phis=delegate.iteratePhis(); phis.hasNext(); ) {
        SSAPhiInstruction phi=phis.next();
        s+=""String_Node_Str"" + phi;
      }
      if (delegate.isCatchBlock()) {
        s+=""String_Node_Str"" + delegate.getCatchInstruction();
      }
      return s;
    }
  }
  return t + ""String_Node_Str"" + result.getResult(t);
}",0.9161205766710354
100262,"/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}","/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
case OP_ldiv:
case OP_lrem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}",0.9924242424242424
100263,"/** 
 * TODO: move this elsewhere. Move it into shrike and develop new way to track peis.
 * @throws IllegalArgumentException  if s is null
 */
public static boolean isPEI(Instruction s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (s.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_aastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
case OP_getfield:
case OP_putfield:
case OP_idiv:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
case OP_irem:
case OP_new:
case OP_newarray:
case OP_anewarray:
case OP_arraylength:
case OP_athrow:
case OP_checkcast:
case OP_monitorenter:
case OP_monitorexit:
case OP_multianewarray:
    return true;
case OP_ldc_w:
  return (((ConstantInstruction)s).getType().equals(TYPE_Class));
default :
return false;
}
}","/** 
 * TODO: move this elsewhere. Move it into shrike and develop new way to track peis.
 * @throws IllegalArgumentException  if s is null
 */
public static boolean isPEI(Instruction s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (s.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_aastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
case OP_getfield:
case OP_putfield:
case OP_idiv:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
case OP_irem:
case OP_ldiv:
case OP_lrem:
case OP_new:
case OP_newarray:
case OP_anewarray:
case OP_arraylength:
case OP_athrow:
case OP_checkcast:
case OP_monitorenter:
case OP_monitorexit:
case OP_multianewarray:
    return true;
case OP_ldc_w:
  return (((ConstantInstruction)s).getType().equals(TYPE_Class));
default :
return false;
}
}",0.9863813229571984
100264,"/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
protected void processCall(final PathEdge edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  final int c=supergraph.getNumber(edge.n);
  final Collection<T> returnSites=Iterator2Collection.toCollection(supergraph.getReturnSites(edge.n));
  final Collection<T> returnSitesWithCallee=HashSetFactory.make();
  for (Iterator<? extends T> it=supergraph.getCalledNodes(edge.n); it.hasNext(); ) {
    final T callee=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + callee);
    }
    IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.n,callee);
    SparseIntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      final LocalSummaryEdges summaries=summaryEdges.get(supergraph.getProcOf(callee));
      final CallFlowEdges callFlow=findOrCreateCallFlowEdges(callee);
      final int s_p_num=supergraph.getLocalBlockNumber(callee);
      reached.foreach(new IntSetAction(){
        public void act(        final int d1){
          propagate(callee,d1,callee,d1);
          callFlow.addCallEdge(c,edge.d2,d1);
          if (summaries != null) {
            P p=supergraph.getProcOf(callee);
            T[] exits=supergraph.getExitsForProcedure(p);
            for (int e=0; e < exits.length; e++) {
              T exit=exits[e];
              if (DEBUG_LEVEL > 0 && Assertions.verifyAssertions) {
                Assertions._assert(supergraph.containsNode(exit));
              }
              for (Iterator<? extends T> succ=supergraph.getSuccNodes(exit); succ.hasNext(); ) {
                final T returnSite=succ.next();
                if (returnSites.contains(returnSite)) {
                  returnSitesWithCallee.add(returnSite);
                  int x_num=supergraph.getLocalBlockNumber(exit);
                  IntSet reachedBySummary=summaries.getSummaryEdges(s_p_num,x_num,d1);
                  if (reachedBySummary != null) {
                    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(edge.n,exit,returnSite);
                    reachedBySummary.foreach(new IntSetAction(){
                      public void act(                      int d2){
                        if (retf instanceof IBinaryReturnFlowFunction) {
                          final SparseIntSet D5=computeBinaryFlow(edge.d2,d2,(IBinaryReturnFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.s_p,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
 else {
                          final SparseIntSet D5=computeFlow(d2,(IUnaryFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.s_p,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
                      }
                    }
);
                  }
                }
              }
            }
          }
        }
      }
);
    }
  }
  for (Iterator<? extends T> it=supergraph.getNormalSuccessors(edge.n); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.n,m);
    SparseIntSet D3=computeFlow(edge.d2,f);
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        public void act(        int d3){
          propagate(edge.s_p,edge.d1,m,d3);
        }
      }
);
    }
  }
  for (  final T returnSite : returnSites) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + returnSite);
    }
    IUnaryFlowFunction f=null;
    if (returnSitesWithCallee.contains(returnSite)) {
      f=flowFunctionMap.getCallToReturnFlowFunction(edge.n,returnSite);
    }
 else {
      f=flowFunctionMap.getCallNoneToReturnFlowFunction(edge.n,returnSite);
    }
    SparseIntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      reached.foreach(new IntSetAction(){
        public void act(        int x){
          if (Assertions.verifyAssertions) {
            Assertions._assert(x >= 0);
            Assertions._assert(edge.d1 >= 0);
          }
          propagate(edge.s_p,edge.d1,returnSite,x);
        }
      }
);
    }
  }
}","/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
protected void processCall(final PathEdge edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  final int c=supergraph.getNumber(edge.n);
  final Collection<T> returnSites=Iterator2Collection.toCollection(supergraph.getReturnSites(edge.n));
  for (Iterator<? extends T> it=supergraph.getCalledNodes(edge.n); it.hasNext(); ) {
    final T callee=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + callee);
    }
    IUnaryFlowFunction f=flowFunctionMap.getCallFlowFunction(edge.n,callee);
    SparseIntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      final LocalSummaryEdges summaries=summaryEdges.get(supergraph.getProcOf(callee));
      final CallFlowEdges callFlow=findOrCreateCallFlowEdges(callee);
      final int s_p_num=supergraph.getLocalBlockNumber(callee);
      reached.foreach(new IntSetAction(){
        public void act(        final int d1){
          propagate(callee,d1,callee,d1);
          callFlow.addCallEdge(c,edge.d2,d1);
          if (summaries != null) {
            P p=supergraph.getProcOf(callee);
            T[] exits=supergraph.getExitsForProcedure(p);
            for (int e=0; e < exits.length; e++) {
              T exit=exits[e];
              if (DEBUG_LEVEL > 0 && Assertions.verifyAssertions) {
                Assertions._assert(supergraph.containsNode(exit));
              }
              for (Iterator<? extends T> succ=supergraph.getSuccNodes(exit); succ.hasNext(); ) {
                final T returnSite=succ.next();
                if (returnSites.contains(returnSite)) {
                  int x_num=supergraph.getLocalBlockNumber(exit);
                  IntSet reachedBySummary=summaries.getSummaryEdges(s_p_num,x_num,d1);
                  if (reachedBySummary != null) {
                    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(edge.n,exit,returnSite);
                    reachedBySummary.foreach(new IntSetAction(){
                      public void act(                      int d2){
                        if (retf instanceof IBinaryReturnFlowFunction) {
                          final SparseIntSet D5=computeBinaryFlow(edge.d2,d2,(IBinaryReturnFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.s_p,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
 else {
                          final SparseIntSet D5=computeFlow(d2,(IUnaryFlowFunction)retf);
                          if (D5 != null) {
                            D5.foreach(new IntSetAction(){
                              public void act(                              int d5){
                                propagate(edge.s_p,edge.d1,returnSite,d5);
                              }
                            }
);
                          }
                        }
                      }
                    }
);
                  }
                }
              }
            }
          }
        }
      }
);
    }
  }
  for (Iterator<? extends T> it=supergraph.getNormalSuccessors(edge.n); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.n,m);
    SparseIntSet D3=computeFlow(edge.d2,f);
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        public void act(        int d3){
          propagate(edge.s_p,edge.d1,m,d3);
        }
      }
);
    }
  }
  for (  final T returnSite : returnSites) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + returnSite);
    }
    IUnaryFlowFunction f=null;
    if (hasCallee(returnSite)) {
      f=flowFunctionMap.getCallToReturnFlowFunction(edge.n,returnSite);
    }
 else {
      f=flowFunctionMap.getCallNoneToReturnFlowFunction(edge.n,returnSite);
    }
    SparseIntSet reached=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + reached);
    }
    if (reached != null) {
      reached.foreach(new IntSetAction(){
        public void act(        int x){
          if (Assertions.verifyAssertions) {
            Assertions._assert(x >= 0);
            Assertions._assert(edge.d1 >= 0);
          }
          propagate(edge.s_p,edge.d1,returnSite,x);
        }
      }
);
    }
  }
}",0.9846407586846716
100265,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public Collection<? extends Object> getRootsInput(){
  return rootsInput;
}","public Collection<? extends Object> getRootsInput(){
  return rootsInput;
}",0.6756756756756757
100266,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public void setRootsInput(Collection<? extends Object> newRootsInput){
  rootsInput=newRootsInput;
}","public void setRootsInput(Collection<? extends Object> newRootsInput){
  rootsInput=newRootsInput;
}",0.7352941176470589
100267,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public List<IAction> getPopUpActions(){
  return popUpActions;
}","public List<IAction> getPopUpActions(){
  return popUpActions;
}",0.64
100268,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public Graph getGraphInput(){
  return graphInput;
}","public Graph getGraphInput(){
  return graphInput;
}",0.5909090909090909
100269,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public NodeDecorator getNodeDecoratorInput(){
  return nodeDecoratorInput;
}","public NodeDecorator getNodeDecoratorInput(){
  return nodeDecoratorInput;
}",0.6785714285714286
100270,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public void setNodeDecoratorInput(NodeDecorator newNodeDecoratorInput){
  nodeDecoratorInput=newNodeDecoratorInput;
}","public void setNodeDecoratorInput(NodeDecorator newNodeDecoratorInput){
  nodeDecoratorInput=newNodeDecoratorInput;
}",0.7647058823529411
100271,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public void setGraphInput(Graph newGraphInput){
  graphInput=newGraphInput;
}","public void setGraphInput(Graph newGraphInput){
  graphInput=newGraphInput;
}",0.6814159292035398
100272,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
@Override public String toString(){
  StringBuffer result=new StringBuffer(super.toString());
  result.append(""String_Node_Str"");
  result.append(graphInput);
  result.append(""String_Node_Str"");
  result.append(rootsInput);
  result.append(""String_Node_Str"");
  result.append(nodeDecoratorInput);
  result.append(""String_Node_Str"");
  result.append(popUpActions);
  result.append(')');
  return result.toString();
}","@Override public String toString(){
  StringBuffer result=new StringBuffer(super.toString());
  result.append(""String_Node_Str"");
  result.append(graphInput);
  result.append(""String_Node_Str"");
  result.append(rootsInput);
  result.append(""String_Node_Str"");
  result.append(nodeDecoratorInput);
  result.append(""String_Node_Str"");
  result.append(popUpActions);
  result.append(')');
  return result.toString();
}",0.9201773835920176
100273,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public SWTTreeViewer(){
  super();
}","public SWTTreeViewer(){
  super();
}",0.5
100274,"/** 
 * get the ""normal"" successors (sic) for a return site; i.e., the ""normal"" CFG predecessors that are not call nodes.
 * @see com.ibm.wala.dataflow.IFDS.ISupergraph#getCalledNodes(java.lang.Object)
 */
public Iterator<T> getNormalSuccessors(final T ret){
  Iterator<? extends Object> allPreds=delegate.getPredNodes(ret);
  Filter sameProc=new Filter(){
    @SuppressWarnings(""String_Node_Str"") public boolean accepts(    Object o){
      return getProcOf(ret).equals(getProcOf((T)o));
    }
  }
;
  Iterator<Object> sameProcPreds=new FilterIterator<Object>(allPreds,sameProc);
  Filter notCall=new Filter(){
    @SuppressWarnings(""String_Node_Str"") public boolean accepts(    Object o){
      return !delegate.isCall((T)o);
    }
  }
;
  return new FilterIterator<T>(sameProcPreds,notCall);
}","/** 
 * get the ""normal"" successors (sic) for a return site; i.e., the ""normal"" CFG predecessors that are not call nodes.
 * @see com.ibm.wala.dataflow.IFDS.ISupergraph#getCalledNodes(java.lang.Object)
 */
public Iterator<T> getNormalSuccessors(final T ret){
  Iterator<? extends Object> allPreds=delegate.getPredNodes(ret);
  Filter sameProc=new Filter<T>(){
    public boolean accepts(    T o){
      return getProcOf(ret).equals(getProcOf(o)) && !delegate.isExit(o);
    }
  }
;
  Iterator<Object> sameProcPreds=new FilterIterator<Object>(allPreds,sameProc);
  Filter notCall=new Filter<T>(){
    public boolean accepts(    T o){
      return !delegate.isCall(o);
    }
  }
;
  return new FilterIterator<T>(sameProcPreds,notCall);
}",0.488569562377531
100275,"@SuppressWarnings(""String_Node_Str"") public boolean accepts(Object o){
  return !delegate.isCall((T)o);
}","public boolean accepts(T o){
  return !delegate.isCall(o);
}",0.7151515151515152
100276,"/** 
 * @throws IllegalArgumentException if dst is null
 */
public void addExceptionalEdge(T src,T dst){
  if (dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (dst.equals(exit())) {
    exceptionalToExit.set(getNumber(src));
  }
 else {
    exceptionalEdgeManager.addEdge(src,dst);
    SimpleIntVector v=exceptionalSuccessors.get(getNumber(src));
    if (v == null) {
      v=new SimpleIntVector(-1);
      exceptionalSuccessors.set(getNumber(src),v);
    }
    v.set(v.getMaxIndex() + 1,getNumber(dst));
  }
}","/** 
 * @throws IllegalArgumentException if dst is null
 */
public void addExceptionalEdge(T src,T dst){
  if (dst == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (dst.equals(exit())) {
    exceptionalToExit.set(getNumber(src));
  }
 else {
    exceptionalEdgeManager.addEdge(src,dst);
    SimpleIntVector v=exceptionalSuccessors.get(getNumber(src));
    if (v == null) {
      v=new SimpleIntVector(-1);
      exceptionalSuccessors.set(getNumber(src),v);
      v.set(0,getNumber(dst));
      return;
    }
    if (v.get(v.getMaxIndex()) != getNumber(dst)) {
      v.set(v.getMaxIndex() + 1,getNumber(dst));
    }
  }
}",0.9121338912133892
100277,"@Override public PointerAnalysis getPointerAnalysis(){
  return new TypeBasedPointerAnalysis(getOptions(),allocatedClasses,getCallGraph());
}","@Override public PointerAnalysis getPointerAnalysis(){
  return TypeBasedPointerAnalysis.make(getOptions(),allocatedClasses,getCallGraph());
}",0.9681978798586572
100278,"public InstanceKey getInstanceKeyForAllocation(CGNode node,NewSiteReference allocation) throws UnimplementedError {
  Assertions.UNREACHABLE();
  return null;
}","public InstanceKey getInstanceKeyForAllocation(CGNode node,NewSiteReference allocation) throws UnimplementedError {
  return iKeyFactory.getInstanceKeyForAllocation(node,allocation);
}",0.7616279069767442
100279,"public InstanceKey getInstanceKeyForMultiNewArray(CGNode node,NewSiteReference allocation,int dim) throws UnimplementedError {
  Assertions.UNREACHABLE();
  return null;
}","public InstanceKey getInstanceKeyForMultiNewArray(CGNode node,NewSiteReference allocation,int dim) throws UnimplementedError {
  return iKeyFactory.getInstanceKeyForMultiNewArray(node,allocation,dim);
}",0.7238605898123325
100280,"/** 
 * @param klasses Collection<IClass>
 * @throws AssertionError  if klasses is null
 */
public TypeBasedPointerAnalysis(AnalysisOptions options,Collection<IClass> klasses,CallGraph cg) throws AssertionError {
  super(cg,makeInstanceKeys(klasses));
  this.klasses=klasses;
  heapModel=new TypeBasedHeapModel(options,klasses,cg);
}","/** 
 * @param klasses Collection<IClass>
 * @throws AssertionError  if klasses is null
 */
private TypeBasedPointerAnalysis(AnalysisOptions options,Collection<IClass> klasses,CallGraph cg) throws AssertionError {
  super(cg,makeInstanceKeys(klasses));
  this.klasses=klasses;
  heapModel=new TypeBasedHeapModel(options,klasses,cg);
}",0.9835082458770614
100281,"private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    klasses=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
  }
  klasses=HashSetFactory.make(klasses);
  klasses.retainAll(this.klasses);
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(klasses);
  return result;
}","/** 
 * Compute the set of   {@link InstanceKey}s which may represent a particular type.
 */
private OrdinalSet<InstanceKey> computeOrdinalInstanceSet(IClass type){
  Collection<IClass> klasses=null;
  if (type.isInterface()) {
    klasses=getCallGraph().getClassHierarchy().getImplementors(type.getReference());
  }
 else {
    Collection<IClass> sc=getCallGraph().getClassHierarchy().computeSubClasses(type.getReference());
    klasses=HashSetFactory.make();
    for (    IClass c : sc) {
      if (!c.isInterface()) {
        klasses.add(c);
      }
    }
  }
  klasses=HashSetFactory.make(klasses);
  klasses.retainAll(this.klasses);
  OrdinalSet<InstanceKey> result=toOrdinalInstanceKeySet(klasses);
  return result;
}",0.7860696517412935
100282,"/** 
 * @param c Collection<IClass>
 */
private OrdinalSet<InstanceKey> toOrdinalInstanceKeySet(Collection c){
  BimodalMutableIntSet s=new BimodalMutableIntSet();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    int index=getInstanceKeyMapping().getMappedIndex(new ConcreteTypeKey(klass));
    if (index >= 0) {
      s.add(index);
    }
  }
  return new OrdinalSet<InstanceKey>(s,getInstanceKeyMapping());
}","private OrdinalSet<InstanceKey> toOrdinalInstanceKeySet(Collection c){
  BimodalMutableIntSet s=new BimodalMutableIntSet();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    IClass klass=(IClass)it.next();
    int index=getInstanceKeyMapping().getMappedIndex(new ConcreteTypeKey(klass));
    if (index >= 0) {
      s.add(index);
    }
  }
  return new OrdinalSet<InstanceKey>(s,getInstanceKeyMapping());
}",0.9535962877030162
100283,"public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Statement src,Statement dest){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Statement s=src;
switch (s.getKind()) {
case NORMAL_RET_CALLER:
case PARAM_CALLER:
    return ReachabilityFunctions.killReachability;
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
  if (dest instanceof HeapStatement) {
    HeapStatement hd=(HeapStatement)dest;
    HeapStatement hs=(HeapStatement)src;
    if (hs.getLocation().equals(hd.getLocation())) {
      return IdentityFlowFunction.identity();
    }
 else {
      return ReachabilityFunctions.killReachability;
    }
  }
 else {
    return ReachabilityFunctions.killReachability;
  }
case NORMAL:
return ReachabilityFunctions.killReachability;
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}","public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Statement src,Statement dest){
  if (src == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Statement s=src;
switch (s.getKind()) {
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case EXC_RET_CALLER:
    return ReachabilityFunctions.killReachability;
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
  if (dest instanceof HeapStatement) {
    HeapStatement hd=(HeapStatement)dest;
    HeapStatement hs=(HeapStatement)src;
    if (hs.getLocation().equals(hd.getLocation())) {
      return IdentityFlowFunction.identity();
    }
 else {
      return ReachabilityFunctions.killReachability;
    }
  }
 else {
    return ReachabilityFunctions.killReachability;
  }
case NORMAL:
return ReachabilityFunctions.killReachability;
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}",0.9884169884169884
100284,"/** 
 * @param x set of factoid numbers that previously have been established to hold at a program point
 * @param j a new factoid number which has been discovered to hold at a program point
 * @return the factoid number z which should actually be propagated, based ona merge of the new fact j into the old state represented by x
 */
int merge(IntSet x,int j);","/** 
 * @param x set of factoid numbers that previously have been established to hold at a program point
 * @param j a new factoid number which has been discovered to hold at a program point
 * @return the factoid number z which should actually be propagated, based ona merge of the new fact j into the old state represented by x. return -1 if no fact should be propagated.
 */
int merge(IntSet x,int j);",0.9424083769633508
100285,"@Override public SSAInstruction copyForSSA(int[] defs,int[] uses){
  if (uses != null && uses.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSABinaryOpInstruction(operator,defs == null || defs.length == 0 ? result : defs[0],uses == null ? val1 : uses[0],uses == null ? val2 : uses[1]);
}","@Override public SSAInstruction copyForSSA(int[] defs,int[] uses){
  if (uses != null && uses.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSABinaryOpInstruction(operator,defs == null || defs.length == 0 ? result : defs[0],uses == null ? val1 : uses[0],uses == null ? val2 : uses[1],mayBeInteger);
}",0.9807407407407408
100286,"SSABinaryOpInstruction(BinaryOpInstruction.IOperator operator,int result,int val1,int val2){
  super();
  this.result=result;
  this.val1=val1;
  this.val2=val2;
  this.operator=operator;
  Assertions._assert(val1 != -1 && val2 != -1);
}","SSABinaryOpInstruction(BinaryOpInstruction.IOperator operator,int result,int val1,int val2,boolean mayBeInteger){
  super();
  this.result=result;
  this.val1=val1;
  this.val2=val2;
  this.operator=operator;
  this.mayBeInteger=mayBeInteger;
  Assertions._assert(val1 != -1 && val2 != -1);
}",0.8960302457466919
100287,"/** 
 * @see com.ibm.wala.ssa.SSAInstruction#getDef()
 */
@Override public boolean hasDef(){
  return true;
}","@Override public boolean hasDef(){
  return true;
}",0.6375
100288,"@Override public boolean isPEI(){
  return operator == BinaryOpInstruction.Operator.DIV || operator == BinaryOpInstruction.Operator.REM;
}","@Override public boolean isPEI(){
  return mayBeInteger && operator == BinaryOpInstruction.Operator.DIV || operator == BinaryOpInstruction.Operator.REM;
}",0.9452054794520548
100289,"/** 
 * UGH! This must be the Shrike OPCODE, not the Shrike OPERATOR code!!!!!
 * @artifact 38486
 * @return instruction opcode
 */
public BinaryOpInstruction.IOperator getOperator(){
  return operator;
}","/** 
 * Ugh.  clean up shrike operator stuff.
 */
public BinaryOpInstruction.IOperator getOperator(){
  return operator;
}",0.5950920245398773
100290,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitShift(ShiftInstruction)
 */
@Override public void visitShift(com.ibm.wala.shrikeBT.ShiftInstruction instruction){
  int val2=workingState.pop();
  int val1=workingState.pop();
  int result=reuseOrCreateDef();
  workingState.push(result);
  emitInstruction(new SSABinaryOpInstruction(instruction.getOperator(),result,val1,val2));
}","/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitShift(ShiftInstruction)
 */
@Override public void visitShift(com.ibm.wala.shrikeBT.ShiftInstruction instruction){
  int val2=workingState.pop();
  int val1=workingState.pop();
  int result=reuseOrCreateDef();
  workingState.push(result);
  emitInstruction(new SSABinaryOpInstruction(instruction.getOperator(),result,val1,val2,true));
}",0.9936305732484076
100291,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitBinaryOp(BinaryOpInstruction)
 */
@Override public void visitBinaryOp(com.ibm.wala.shrikeBT.BinaryOpInstruction instruction){
  int val2=workingState.pop();
  int val1=workingState.pop();
  int result=reuseOrCreateDef();
  workingState.push(result);
  emitInstruction(new SSABinaryOpInstruction(instruction.getOperator(),result,val1,val2));
}","/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitBinaryOp(BinaryOpInstruction)
 */
@Override public void visitBinaryOp(com.ibm.wala.shrikeBT.BinaryOpInstruction instruction){
  int val2=workingState.pop();
  int val1=workingState.pop();
  int result=reuseOrCreateDef();
  workingState.push(result);
  boolean isFloat=instruction.getType().equals(TYPE_double) || instruction.getType().equals(TYPE_float);
  emitInstruction(new SSABinaryOpInstruction(instruction.getOperator(),result,val1,val2,!isFloat));
}",0.8758169934640523
100292,"public static SSABinaryOpInstruction BinaryOpInstruction(BinaryOpInstruction.IOperator operator,int result,int val1,int val2){
  return new SSABinaryOpInstruction(operator,result,val1,val2);
}","public static SSABinaryOpInstruction BinaryOpInstruction(BinaryOpInstruction.IOperator operator,int result,int val1,int val2,boolean mayBeInteger){
  return new SSABinaryOpInstruction(operator,result,val1,val2,mayBeInteger);
}",0.9186602870813396
100293,"/** 
 * @return the cfg for n, or null if none found
 * @throws IllegalArgumentException if n == null
 */
@Override public ControlFlowGraph<ExplodedBasicBlock> getCFG(CGNode n) throws IllegalArgumentException {
  if (n == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IR ir=n.getIR();
  return ExplodedControlFlowGraph.make(ir);
}","/** 
 * @return the cfg for n, or null if none found
 * @throws IllegalArgumentException if n == null
 */
@Override public ControlFlowGraph<ExplodedBasicBlock> getCFG(CGNode n) throws IllegalArgumentException {
  if (n == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IR ir=n.getIR();
  if (ir == null) {
    return null;
  }
  return ExplodedControlFlowGraph.make(ir);
}",0.9456953642384106
100294,"/** 
 * Assuming a set of facts holds, simplify a CNF formula
 */
private static Collection<? extends IMaxTerm> simplifyCNF(ICNFFormula f,Collection<IMaxTerm> facts,ISemiDecisionProcedure dec){
  Collection<IMaxTerm> result=HashSetFactory.make();
  Collection<IMaxTerm> removedClauses=HashSetFactory.make();
  for (  IMaxTerm d : collectClauses(Collections.singleton(f))) {
    Collection<IMaxTerm> otherFacts=HashSetFactory.make(facts);
    otherFacts.addAll(collectClauses(Collections.singleton(f)));
    otherFacts.remove(d);
    otherFacts.removeAll(removedClauses);
    if (d instanceof Disjunction) {
      d=simplifyDisjunction((Disjunction)d,otherFacts,dec);
    }
    if (dec.isContradiction(d,otherFacts)) {
      return Collections.singleton(BooleanConstantFormula.FALSE);
    }
 else     if (facts.contains(d) || dec.isTautology(d,otherFacts)) {
      removedClauses.add(d);
    }
 else {
      result.add(d);
    }
  }
  if (result.isEmpty()) {
    return Collections.singleton(BooleanConstantFormula.TRUE);
  }
  return result;
}","/** 
 * Assuming a set of facts holds, simplify a CNF formula
 */
private static Collection<? extends IMaxTerm> simplifyCNF(ICNFFormula f,Collection<IMaxTerm> facts,ISemiDecisionProcedure dec){
  Collection<IMaxTerm> result=HashSetFactory.make();
  Collection<IMaxTerm> removedClauses=HashSetFactory.make();
  for (  IMaxTerm d : collectClauses(Collections.singleton(f))) {
    Collection<IMaxTerm> otherFacts=HashSetFactory.make(facts);
    otherFacts.addAll(collectClauses(Collections.singleton(f)));
    otherFacts.remove(d);
    otherFacts.removeAll(removedClauses);
    IMaxTerm checkD=d;
    if (d instanceof Disjunction) {
      checkD=simplifyDisjunction((Disjunction)d,otherFacts,dec);
    }
    if (dec.isContradiction(checkD,otherFacts)) {
      return Collections.singleton(BooleanConstantFormula.FALSE);
    }
 else     if (facts.contains(checkD) || dec.isTautology(checkD,otherFacts)) {
      removedClauses.add(d);
    }
 else {
      result.add(checkD);
    }
  }
  if (result.isEmpty()) {
    return Collections.singleton(BooleanConstantFormula.TRUE);
  }
  return result;
}",0.9568884723523898
100295,"/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(){
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return;
  }
  IR ir=node.getIR();
  if (ir == null) {
    return;
  }
  DefUse DU=node.getDU();
  SSAInstruction[] instructions=ir.getInstructions();
  for (Iterator<? extends Statement> it=iterator(); it.hasNext(); ) {
    Statement s=it.next();
switch (s.getKind()) {
case NORMAL:
case CATCH:
case PI:
case PHI:
{
        SSAInstruction statement=statement2SSAInstruction(instructions,s);
        if (!(statement instanceof SSAAbstractInvokeInstruction)) {
          if (dOptions.isTerminateAtCast() && (statement instanceof SSACheckCastInstruction)) {
            break;
          }
          if (dOptions.isTerminateAtCast() && (statement instanceof SSAInstanceofInstruction)) {
            break;
          }
          for (int i=0; i < statement.getNumberOfDefs(); i++) {
            int def=statement.getDef(i);
            for (Iterator<SSAInstruction> it2=DU.getUses(def); it2.hasNext(); ) {
              SSAInstruction use=it2.next();
              if (dOptions.isIgnoreBasePtrs()) {
                if (use instanceof SSANewInstruction) {
                  continue;
                }
                if (hasBasePointer(use)) {
                  int base=getBasePointer(use);
                  if (def == base) {
                    continue;
                  }
                  if (use instanceof SSAArrayReferenceInstruction) {
                    SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
                    if (def == arr.getIndex()) {
                      continue;
                    }
                  }
                }
              }
              Statement u=ssaInstruction2Statement(use);
              addEdge(s,u);
            }
          }
        }
        break;
      }
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
{
      if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
        Assertions._assert(!s.getKind().equals(Kind.EXC_RET_CALLER));
      }
      ValueNumberCarrier a=(ValueNumberCarrier)s;
      for (Iterator<SSAInstruction> it2=DU.getUses(a.getValueNumber()); it2.hasNext(); ) {
        SSAInstruction use=it2.next();
        if (dOptions.isIgnoreBasePtrs()) {
          if (use instanceof SSANewInstruction) {
            continue;
          }
          if (hasBasePointer(use)) {
            int base=getBasePointer(use);
            if (a.getValueNumber() == base) {
              continue;
            }
            if (use instanceof SSAArrayReferenceInstruction) {
              SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
              if (a.getValueNumber() == arr.getIndex()) {
                continue;
              }
            }
          }
        }
        Statement u=ssaInstruction2Statement(use);
        addEdge(s,u);
      }
      break;
    }
case NORMAL_RET_CALLEE:
  for (  NormalStatement ret : computeReturnStatements(ir)) {
    addEdge(ret,s);
  }
break;
case EXC_RET_CALLEE:
if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
Assertions.UNREACHABLE();
}
for (NormalStatement pei : getPEIs(ir)) {
if (dOptions.isTerminateAtCast() && (pei.getInstruction() instanceof SSACheckCastInstruction)) {
continue;
}
if (pei.getInstruction() instanceof SSAAbstractInvokeInstruction) {
SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)pei.getInstruction();
Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
addEdge(st,s);
}
 else {
addEdge(pei,s);
}
}
break;
case PARAM_CALLER:
{
ParamStatement.ParamCaller pac=(ParamStatement.ParamCaller)s;
int vn=pac.getValueNumber();
if (vn > -1) {
if (ir.getSymbolTable().isParameter(vn)) {
Statement a=new ParamStatement.ParamCallee(node,vn);
addEdge(a,pac);
}
 else {
SSAInstruction d=DU.getDef(vn);
if (dOptions.isTerminateAtCast() && (d instanceof SSACheckCastInstruction)) {
break;
}
if (d != null) {
if (d instanceof SSAAbstractInvokeInstruction) {
  SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)d;
  if (vn == call.getException()) {
    Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
    addEdge(st,pac);
  }
 else {
    Statement st=new ParamStatement.NormalReturnCaller(node,call);
    addEdge(st,pac);
  }
}
 else {
  Statement ds=ssaInstruction2Statement(d);
  addEdge(ds,pac);
}
}
}
}
}
break;
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
break;
default :
Assertions.UNREACHABLE(s.toString());
break;
}
}
}","/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(){
}",0.1003184713375796
100296,"/** 
 * Wrap an SSAInstruction in a Statement
 */
public Statement ssaInstruction2Statement(SSAInstruction s){
}","public Statement ssaInstruction2Statement(SSAInstruction s,Map<SSAInstruction,Integer> instructionIndices){
}",0.5610859728506787
100297,"/** 
 * @return for each SSAInstruction, its instruction index in the irinstruction array
 */
private Map<SSAInstruction,Integer> computeInstructionIndices(IR ir){
  Map<SSAInstruction,Integer> result=HashMapFactory.make();
  if (ir != null) {
    SSAInstruction[] instructions=ir.getInstructions();
    for (int i=0; i < instructions.length; i++) {
      SSAInstruction s=instructions[i];
      if (s != null) {
        result.put(s,new Integer(i));
      }
    }
  }
  return result;
}","/** 
 * @return for each SSAInstruction, its instruction index in the irinstruction array
 */
public static Map<SSAInstruction,Integer> computeInstructionIndices(IR ir){
  Map<SSAInstruction,Integer> result=HashMapFactory.make();
  if (ir != null) {
    SSAInstruction[] instructions=ir.getInstructions();
    for (int i=0; i < instructions.length; i++) {
      SSAInstruction s=instructions[i];
      if (s != null) {
        result.put(s,new Integer(i));
      }
    }
  }
  return result;
}",0.9816326530612244
100298,"protected TypeReference[] makeParameterTypes(MethodReference method,int i){
  TypeReference nominal=method.getParameterType(i);
  if (nominal.isPrimitiveType() || nominal.isArrayType())   return new TypeReference[]{nominal};
 else {
    IClass nc=getCha().lookupClass(nominal);
    Collection subcs=nc.isInterface() ? getCha().getImplementors(nominal) : getCha().computeSubClasses(nominal);
    Set<TypeReference> subs=HashSetFactory.make();
    for (Iterator I=subcs.iterator(); I.hasNext(); ) {
      IClass cs=(IClass)I.next();
      if (!cs.isAbstract() && !cs.isInterface())       subs.add(cs.getReference());
    }
    return subs.toArray(new TypeReference[subs.size()]);
  }
}","protected TypeReference[] makeParameterTypes(IMethod method,int i){
  TypeReference nominal=method.getParameterType(i);
  if (nominal.isPrimitiveType() || nominal.isArrayType())   return new TypeReference[]{nominal};
 else {
    IClass nc=getCha().lookupClass(nominal);
    Collection subcs=nc.isInterface() ? getCha().getImplementors(nominal) : getCha().computeSubClasses(nominal);
    Set<TypeReference> subs=HashSetFactory.make();
    for (Iterator I=subcs.iterator(); I.hasNext(); ) {
      IClass cs=(IClass)I.next();
      if (!cs.isAbstract() && !cs.isInterface())       subs.add(cs.getReference());
    }
    return subs.toArray(new TypeReference[subs.size()]);
  }
}",0.9926362297496318
100299,"/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}","/** 
 * @param pei a potentially-excepting insruction
 * @return the exception types that pei may throw, independent of the classhierarchy Notes <ul> <li>this method will <em>NOT</em> return the exception type explicitly thrown by an athrow <li>this method will <em>NOT</em> return the exception types that a called method may throw <li>this method ignores OutOfMemoryError <li>this method ignores linkage errors <li>this method ignores IllegalMonitorState exceptions </ul> TODO: move this elsewhere.
 * @throws IllegalArgumentException  if pei is null
 */
public static Collection<TypeReference> getIndependentExceptionTypes(Instruction pei){
  if (pei == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (pei.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
    return getArrayAccessExceptions();
case OP_aastore:
  return getAaStoreExceptions();
case OP_getfield:
case OP_putfield:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
return getNullPointerException();
case OP_idiv:
case OP_irem:
return getArithmeticException();
case OP_new:
return newScalarExceptions;
case OP_newarray:
case OP_anewarray:
case OP_multianewarray:
return newArrayExceptions;
case OP_arraylength:
return getNullPointerException();
case OP_athrow:
return getNullPointerException();
case OP_checkcast:
return getClassCastException();
case OP_monitorenter:
case OP_monitorexit:
return getNullPointerException();
case OP_ldc_w:
if (((ConstantInstruction)pei).getType().equals(TYPE_Class)) return getClassNotFoundException();
 else return null;
default :
return null;
}
}",0.9961685823754788
100300,"/** 
 * TODO: move this elsewhere. Move it into shrike and develop new way to track peis.
 * @throws IllegalArgumentException  if s is null
 */
public static boolean isPEI(Instruction s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (s.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_aastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
case OP_getfield:
case OP_putfield:
case OP_idiv:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
case OP_new:
case OP_newarray:
case OP_anewarray:
case OP_arraylength:
case OP_athrow:
case OP_checkcast:
case OP_monitorenter:
case OP_monitorexit:
case OP_multianewarray:
    return true;
case OP_ldc_w:
  return (((ConstantInstruction)s).getType().equals(TYPE_Class));
default :
return false;
}
}","/** 
 * TODO: move this elsewhere. Move it into shrike and develop new way to track peis.
 * @throws IllegalArgumentException  if s is null
 */
public static boolean isPEI(Instruction s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (s.getOpcode()) {
case OP_iaload:
case OP_laload:
case OP_faload:
case OP_daload:
case OP_aaload:
case OP_baload:
case OP_caload:
case OP_saload:
case OP_iastore:
case OP_lastore:
case OP_fastore:
case OP_dastore:
case OP_aastore:
case OP_bastore:
case OP_castore:
case OP_sastore:
case OP_getfield:
case OP_putfield:
case OP_idiv:
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
case OP_invokeinterface:
case OP_irem:
case OP_new:
case OP_newarray:
case OP_anewarray:
case OP_arraylength:
case OP_athrow:
case OP_checkcast:
case OP_monitorenter:
case OP_monitorexit:
case OP_multianewarray:
    return true;
case OP_ldc_w:
  return (((ConstantInstruction)s).getType().equals(TYPE_Class));
default :
return false;
}
}",0.99304865938431
100301,"boolean hasNormalEdge(T src,T dst);","/** 
 * This method must return true if and only if a normal edge from src to dst exists in the original CFG and should be kept for the pruned version of that CFG.  Note that this must _must_ return false for any normal edge that is not in the original CFG.
 */
boolean hasNormalEdge(T src,T dst);",0.2108433734939759
100302,"boolean hasExceptionalEdge(T src,T dst);","/** 
 * This method must return true if and only if an exceptional edge from src to dst exists in the original CFG and should be kept for the pruned version of that CFG.  Note that this must _must_ return false for any exceptional edge that is not in the original CFG.
 */
boolean hasExceptionalEdge(T src,T dst);",0.2266288951841359
100303,"public boolean hasNormalEdge(T src,T dst){
  return true;
}","public boolean hasNormalEdge(T src,T dst){
  return cfg.getNormalSuccessors(src).contains(dst);
}",0.7564102564102564
100304,"public static <T extends IBasicBlock>PrunedCFG<T> make(ControlFlowGraph<T> cfg){
  return PrunedCFG.make(cfg,new ExceptionEdgePruner<T>());
}","public static <T extends IBasicBlock>PrunedCFG<T> make(ControlFlowGraph<T> cfg){
  return PrunedCFG.make(cfg,new ExceptionEdgePruner<T>(cfg));
}",0.9894736842105264
100305,"public Iterator<T> getPredNodes(T N){
  return new CompoundIterator<T>(getNormalPredecessors(N),getExceptionalPredecessors(N));
}","public Iterator<T> getPredNodes(final T N){
  return new FilterIterator<T>(cfg.getPredNodes(N),new Filter<T>(){
    public boolean accepts(    T o){
      return currentCFGNodes.containsNode(o) && (filter.hasNormalEdge(o,N) || filter.hasExceptionalEdge(o,N));
    }
  }
);
}",0.3523573200992556
100306,"public Iterator<T> getSuccNodes(T N){
  return new CompoundIterator<T>(getNormalSuccessors(N),getExceptionalSuccessors(N));
}","public Iterator<T> getSuccNodes(final T N){
  return new FilterIterator<T>(cfg.getSuccNodes(N),new Filter<T>(){
    public boolean accepts(    T o){
      return currentCFGNodes.containsNode(o) && (filter.hasNormalEdge(N,o) || filter.hasExceptionalEdge(N,o));
    }
  }
);
}",0.3508771929824561
100307,"/** 
 * @return int set representing the heap def statements that are gen'ed bythe basic block. null if none.
 */
IntSet gen(ExplodedBasicBlock b){
  if (b.isEntryBlock()) {
    return heapEntryStatements();
  }
 else {
    SSAInstruction s=b.getInstruction();
    if (s == null) {
      return null;
    }
 else {
      if (s instanceof SSAInvokeInstruction) {
        Statement st=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
        if (st == null) {
          System.err.println(ssaInstructionIndex2Statement);
          Assertions.UNREACHABLE(""String_Node_Str"" + b + ""String_Node_Str""+ b.getLastInstructionIndex()+ ""String_Node_Str""+ s);
        }
        int domainIndex=domain.getMappedIndex(st);
        assert(domainIndex != -1);
        return heapReturnCaller.getRelated(domainIndex);
      }
 else {
        Collection<PointerKey> gen=modRef.getMod(node,h,pa,s,exclusions);
        if (gen.isEmpty()) {
          return null;
        }
 else {
          NormalStatement n=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
          return SparseIntSet.singleton(domain.getMappedIndex(n));
        }
      }
    }
  }
}","/** 
 * @return int set representing the heap def statements that are gen'ed bythe basic block. null if none.
 */
IntSet gen(ExplodedBasicBlock b){
  if (b.isEntryBlock()) {
    return heapEntryStatements();
  }
 else {
    SSAInstruction s=b.getInstruction();
    if (s == null) {
      return null;
    }
 else {
      if (s instanceof SSAAbstractInvokeInstruction) {
        Statement st=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
        if (st == null) {
          System.err.println(ssaInstructionIndex2Statement);
          Assertions.UNREACHABLE(""String_Node_Str"" + b + ""String_Node_Str""+ b.getLastInstructionIndex()+ ""String_Node_Str""+ s);
        }
        int domainIndex=domain.getMappedIndex(st);
        assert(domainIndex != -1);
        return heapReturnCaller.getRelated(domainIndex);
      }
 else {
        Collection<PointerKey> gen=modRef.getMod(node,h,pa,s,exclusions);
        if (gen.isEmpty()) {
          return null;
        }
 else {
          NormalStatement n=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
          return SparseIntSet.singleton(domain.getMappedIndex(n));
        }
      }
    }
  }
}",0.996572407883462
100308,"public UnaryOperator getEdgeTransferFunction(IBasicBlock src,IBasicBlock dst){
  ExplodedBasicBlock s=(ExplodedBasicBlock)src;
  if (s.getInstruction() != null && !(s.getInstruction() instanceof SSAInvokeInstruction) && !cfg.getNormalSuccessors(src).contains(dst)) {
    return BitVectorIdentity.instance();
  }
 else {
    BitVector kill=kill(s);
    IntSet gen=gen(s);
    if (kill == null) {
      if (gen == null) {
        return BitVectorIdentity.instance();
      }
 else {
        return new BitVectorUnionVector(new BitVectorIntSet(gen).getBitVector());
      }
    }
 else {
      if (gen == null) {
        return new BitVectorMinusVector(kill);
      }
 else {
        return new BitVectorKillGen(kill,new BitVectorIntSet(gen).getBitVector());
      }
    }
  }
}","public UnaryOperator getEdgeTransferFunction(IBasicBlock src,IBasicBlock dst){
  ExplodedBasicBlock s=(ExplodedBasicBlock)src;
  if (s.getInstruction() != null && !(s.getInstruction() instanceof SSAAbstractInvokeInstruction) && !cfg.getNormalSuccessors(src).contains(dst)) {
    return BitVectorIdentity.instance();
  }
 else {
    BitVector kill=kill(s);
    IntSet gen=gen(s);
    if (kill == null) {
      if (gen == null) {
        return BitVectorIdentity.instance();
      }
 else {
        return new BitVectorUnionVector(new BitVectorIntSet(gen).getBitVector());
      }
    }
 else {
      if (gen == null) {
        return new BitVectorMinusVector(kill);
      }
 else {
        return new BitVectorKillGen(kill,new BitVectorIntSet(gen).getBitVector());
      }
    }
  }
}",0.9948652118100128
100309,"public String prettyPrint(ILogicDecorator d){
  if (clauses.size() == 1) {
    return getF1().prettyPrint(d);
  }
 else {
    StringBuffer result=new StringBuffer();
    result.append(""String_Node_Str"");
    result.append(getF1().prettyPrint(d));
    result.append(""String_Node_Str"");
    result.append(d.prettyPrint(getConnective()));
    result.append(""String_Node_Str"");
    result.append(getF2().prettyPrint(d));
    result.append(""String_Node_Str"");
    return result.toString();
  }
}","public String prettyPrint(ILogicDecorator d){
  if (d == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return d.prettyPrint(this);
}",0.3852080123266564
100310,"private static IMaxTerm simplifyDisjunction(Disjunction d,Collection<IMaxTerm> otherFacts,ISemiDecisionProcedure dec){
  Collection<IFormula> result=HashSetFactory.make();
  for (  IFormula f : d.getClauses()) {
    if (dec.isContradiction(f,otherFacts)) {
      result.add(BooleanConstantFormula.FALSE);
    }
 else     if (dec.isTautology(f,otherFacts)) {
      result.add(BooleanConstantFormula.TRUE);
    }
 else {
      result.add(f);
    }
  }
  return Disjunction.make(result);
}","private static IMaxTerm simplifyDisjunction(Disjunction d,Collection<IMaxTerm> otherFacts,ISemiDecisionProcedure dec){
}",0.396039603960396
100311,"/** 
 * @param P governing pointer analysis
 * @throws NullPointerException if P is null
 */
public BasicHeapGraph(final PointerAnalysis P,final CallGraph callGraph) throws NullPointerException {
  super(P.getHeapModel());
  this.pointerAnalysis=P;
  this.callGraph=callGraph;
  final OrdinalSetMapping<PointerKey> pointerKeys=getPointerKeys();
  final NumberedNodeManager<Object> nodeMgr=new NumberedNodeManager<Object>(){
    public Iterator<Object> iterator(){
      return new CompoundIterator<Object>(pointerKeys.iterator(),P.getInstanceKeyMapping().iterator());
    }
    public int getNumberOfNodes(){
      return pointerKeys.getSize() + P.getInstanceKeyMapping().getSize();
    }
    public void addNode(    Object n){
      Assertions.UNREACHABLE();
    }
    public void removeNode(    Object n){
      Assertions.UNREACHABLE();
    }
    public int getNumber(    Object N){
      if (N instanceof PointerKey) {
        return pointerKeys.getMappedIndex((PointerKey)N);
      }
 else {
        if (Assertions.verifyAssertions) {
          if (!(N instanceof InstanceKey)) {
            Assertions.UNREACHABLE(N.getClass().toString());
          }
        }
        int inumber=P.getInstanceKeyMapping().getMappedIndex((InstanceKey)N);
        return (inumber == -1) ? -1 : inumber + pointerKeys.getMaximumIndex();
      }
    }
    public Object getNode(    int number){
      if (number > pointerKeys.getMaximumIndex()) {
        return P.getInstanceKeyMapping().getMappedObject(number - pointerKeys.getSize());
      }
 else {
        return pointerKeys.getMappedObject(number);
      }
    }
    public int getMaxNumber(){
      return getNumberOfNodes() - 1;
    }
    public boolean containsNode(    Object n){
      return getNumber(n) != -1;
    }
    public Iterator<Object> iterateNodes(    IntSet s){
      return new NumberedNodeIterator<Object>(s,this);
    }
  }
;
  final IBinaryNaturalRelation pred=computePredecessors(nodeMgr);
  final IntFunction<Object> toNode=new IntFunction<Object>(){
    public Object apply(    int i){
      return nodeMgr.getNode(i);
    }
  }
;
  this.G=new AbstractNumberedGraph<Object>(){
    private final EdgeManager<Object> edgeMgr=new EdgeManager<Object>(){
      public Iterator<Object> getPredNodes(      Object N){
        int n=nodeMgr.getNumber(N);
        IntSet p=pred.getRelated(n);
        if (p == null) {
          return EmptyIterator.instance();
        }
 else {
          return new IntMapIterator<Object>(p.intIterator(),toNode);
        }
      }
      public int getPredNodeCount(      Object N){
        int n=nodeMgr.getNumber(N);
        return pred.getRelatedCount(n);
      }
      public Iterator<? extends Object> getSuccNodes(      Object N){
        int[] succ=computeSuccNodeNumbers(N,nodeMgr);
        if (succ == null) {
          return EmptyIterator.instance();
        }
        SparseIntSet s=new MutableSparseIntSet(succ);
        return new IntMapIterator<Object>(s.intIterator(),toNode);
      }
      public int getSuccNodeCount(      Object N){
        int[] succ=computeSuccNodeNumbers(N,nodeMgr);
        return succ == null ? 0 : succ.length;
      }
      public void addEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
      }
      public void removeEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
      }
      public void removeAllIncidentEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public void removeIncomingEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public void removeOutgoingEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public boolean hasEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
        return false;
      }
    }
;
    @Override protected NodeManager<Object> getNodeManager(){
      return nodeMgr;
    }
    @Override protected EdgeManager<Object> getEdgeManager(){
      return edgeMgr;
    }
  }
;
}","/** 
 * @param P governing pointer analysis
 * @throws NullPointerException if P is null
 */
public BasicHeapGraph(final PointerAnalysis P,final CallGraph callGraph) throws NullPointerException {
  super(P.getHeapModel());
  this.pointerAnalysis=P;
  this.callGraph=callGraph;
  final OrdinalSetMapping<PointerKey> pointerKeys=getPointerKeys();
  final NumberedNodeManager<Object> nodeMgr=new NumberedNodeManager<Object>(){
    public Iterator<Object> iterator(){
      return new CompoundIterator<Object>(pointerKeys.iterator(),P.getInstanceKeyMapping().iterator());
    }
    public int getNumberOfNodes(){
      return pointerKeys.getSize() + P.getInstanceKeyMapping().getSize();
    }
    public void addNode(    Object n){
      Assertions.UNREACHABLE();
    }
    public void removeNode(    Object n){
      Assertions.UNREACHABLE();
    }
    public int getNumber(    Object N){
      if (N instanceof PointerKey) {
        return pointerKeys.getMappedIndex((PointerKey)N);
      }
 else {
        if (Assertions.verifyAssertions) {
          if (!(N instanceof InstanceKey)) {
            Assertions.UNREACHABLE(N.getClass().toString());
          }
        }
        int inumber=P.getInstanceKeyMapping().getMappedIndex((InstanceKey)N);
        return (inumber == -1) ? -1 : inumber + pointerKeys.getMaximumIndex() + 1;
      }
    }
    public Object getNode(    int number){
      if (number > pointerKeys.getMaximumIndex()) {
        return P.getInstanceKeyMapping().getMappedObject(number - pointerKeys.getSize());
      }
 else {
        return pointerKeys.getMappedObject(number);
      }
    }
    public int getMaxNumber(){
      return getNumberOfNodes() - 1;
    }
    public boolean containsNode(    Object n){
      return getNumber(n) != -1;
    }
    public Iterator<Object> iterateNodes(    IntSet s){
      return new NumberedNodeIterator<Object>(s,this);
    }
  }
;
  final IBinaryNaturalRelation pred=computePredecessors(nodeMgr);
  final IntFunction<Object> toNode=new IntFunction<Object>(){
    public Object apply(    int i){
      return nodeMgr.getNode(i);
    }
  }
;
  this.G=new AbstractNumberedGraph<Object>(){
    private final EdgeManager<Object> edgeMgr=new EdgeManager<Object>(){
      public Iterator<Object> getPredNodes(      Object N){
        int n=nodeMgr.getNumber(N);
        IntSet p=pred.getRelated(n);
        if (p == null) {
          return EmptyIterator.instance();
        }
 else {
          return new IntMapIterator<Object>(p.intIterator(),toNode);
        }
      }
      public int getPredNodeCount(      Object N){
        int n=nodeMgr.getNumber(N);
        return pred.getRelatedCount(n);
      }
      public Iterator<? extends Object> getSuccNodes(      Object N){
        int[] succ=computeSuccNodeNumbers(N,nodeMgr);
        if (succ == null) {
          return EmptyIterator.instance();
        }
        SparseIntSet s=new MutableSparseIntSet(succ);
        return new IntMapIterator<Object>(s.intIterator(),toNode);
      }
      public int getSuccNodeCount(      Object N){
        int[] succ=computeSuccNodeNumbers(N,nodeMgr);
        return succ == null ? 0 : succ.length;
      }
      public void addEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
      }
      public void removeEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
      }
      public void removeAllIncidentEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public void removeIncomingEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public void removeOutgoingEdges(      Object node){
        Assertions.UNREACHABLE();
      }
      public boolean hasEdge(      Object src,      Object dst){
        Assertions.UNREACHABLE();
        return false;
      }
    }
;
    @Override protected NodeManager<Object> getNodeManager(){
      return nodeMgr;
    }
    @Override protected EdgeManager<Object> getEdgeManager(){
      return edgeMgr;
    }
  }
;
}",0.999498997995992
100312,"private JavaLauncher(String programArgs,String mainClass,List<String> xtraClasspath){
  super();
  this.programArgs=programArgs;
  this.mainClass=mainClass;
  this.xtraClasspath=xtraClasspath;
}","private JavaLauncher(String programArgs,String mainClass,List<String> xtraClasspath){
  super();
  this.programArgs=programArgs;
  this.mainClass=mainClass;
  if (xtraClasspath != null) {
    this.xtraClasspath.addAll(xtraClasspath);
  }
}",0.74364896073903
100313,"/** 
 * Launch the java process.
 * @throws WalaException
 */
public Process start() throws WalaException {
  String cp=makeClasspath();
  String heap=""String_Node_Str"";
  String cmd=getJavaExe() + heap + cp+ ""String_Node_Str""+ makeLibPath()+ ""String_Node_Str""+ getMainClass()+ ""String_Node_Str""+ getProgramArgs();
  Process p=spawnProcess(cmd);
  stdOutDrain=isCaptureOutput() ? captureStdOut(p) : drainStdOut(p);
  stdInDrain=drainStdErr(p);
  return p;
}","/** 
 * Launch the java process.
 */
public Process start() throws WalaException {
  System.err.println(System.getProperty(""String_Node_Str""));
  String cp=makeClasspath();
  String heap=""String_Node_Str"";
  String cmd=getJavaExe() + heap + cp+ ""String_Node_Str""+ makeLibPath()+ ""String_Node_Str""+ getMainClass()+ ""String_Node_Str""+ getProgramArgs();
  Process p=spawnProcess(cmd);
  stdOutDrain=isCaptureOutput() ? captureStdOut(p) : drainStdOut(p);
  stdInDrain=drainStdErr(p);
  return p;
}",0.2252631578947368
100314,"private String makeClasspath(){
  String cp=""String_Node_Str"" + System.getProperty(""String_Node_Str"");
  if (getXtraClassPath() == null || getXtraClassPath().isEmpty()) {
    return cp;
  }
 else {
    for (Iterator it=getXtraClassPath().iterator(); it.hasNext(); ) {
      cp+=(String)it.next();
      if (it.hasNext()) {
        cp+=""String_Node_Str"";
      }
    }
    cp+=""String_Node_Str"";
    return cp;
  }
}","private String makeClasspath(){
  String cp=""String_Node_Str"" + System.getProperty(""String_Node_Str"");
  if (getXtraClassPath() == null || getXtraClassPath().isEmpty()) {
    return cp;
  }
 else {
    cp+=""String_Node_Str"";
    for (Iterator it=getXtraClassPath().iterator(); it.hasNext(); ) {
      cp+=(String)it.next();
      if (it.hasNext()) {
        cp+=""String_Node_Str"";
      }
    }
    cp+=""String_Node_Str"";
    return cp;
  }
}",0.968494749124854
100315,"public boolean isImplicit(PointerKey p){
  int i=findOrCreateIndex(p);
  return pointsToSets.get(i) == IMPLICIT;
}","public boolean isImplicit(PointerKey p){
  int i=getIndex(p);
  return i != -1 && pointsToSets.get(i) == IMPLICIT;
}",0.9043478260869564
100316,"public void testPrimordial() throws ClassHierarchyException {
  if (useShortProfile()) {
    return;
  }
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(""String_Node_Str"",""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=makePrimordialMainEntrypoints(scope,cha);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope);
}","public void testPrimordial() throws ClassHierarchyException {
  if (useShortProfile()) {
    return;
  }
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(""String_Node_Str"",""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=makePrimordialMainEntrypoints(scope,cha);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false);
}",0.9939024390243902
100317,"/** 
 * Constructor for SpecJTest.
 * @param arg0
 */
public CallGraphTest(String arg0){
  super(arg0);
}","public CallGraphTest(String arg0){
  super(arg0);
}",0.6538461538461539
100318,"public void testIO() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(""String_Node_Str"",""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=makePrimordialPublicEntrypoints(scope,cha,""String_Node_Str"");
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope);
}","public void testIO() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(""String_Node_Str"",""String_Node_Str"");
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=makePrimordialPublicEntrypoints(scope,cha,""String_Node_Str"");
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false);
}",0.9934924078091106
100319,"public void testJava_cup() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JAVA_CUP);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JAVA_CUP_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  doCallGraphs(options,new AnalysisCache(),cha,scope,null,useShortProfile(),false);
}","public void testJava_cup() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JAVA_CUP);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JAVA_CUP_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  doCallGraphs(options,new AnalysisCache(),cha,scope,null,useShortProfile(),false,true);
}",0.994994994994995
100320,"/** 
 * TODO: refactor this to avoid excessive code bloat.
 */
public static void doCallGraphs(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope,String dcgFile,boolean stopAfterZeroCFA,boolean stopAfterZeroContainerCFA){
  CallGraph cg=CallGraphTestUtil.buildRTA(options,cache,cha,scope);
  try {
    GraphIntegrity.check(cg);
  }
 catch (  UnsoundGraphException e1) {
    e1.printStackTrace();
    assertTrue(e1.getMessage(),false);
  }
  Set<MethodReference> rtaMethods=CallGraphStats.collectMethods(cg);
  Trace.println(""String_Node_Str"" + rtaMethods.size());
  Trace.println(CallGraphStats.getStats(cg));
  Trace.println(""String_Node_Str"");
  cg=CallGraphTestUtil.buildZeroCFA(options,cache,cha,scope);
  Graph<MethodReference> squashZero=checkCallGraph(cg,null,rtaMethods,""String_Node_Str"");
  if (stopAfterZeroCFA) {
    return;
  }
  cg=CallGraphTestUtil.buildZeroOneCFA(options,cache,cha,scope);
  Graph<MethodReference> squashZeroOne=checkCallGraph(cg,squashZero,null,""String_Node_Str"");
  cg=CallGraphTestUtil.buildZeroContainerCFA(options,cache,cha,scope);
  Graph<MethodReference> squashZeroContainer=checkCallGraph(cg,squashZero,null,""String_Node_Str"");
  if (stopAfterZeroContainerCFA)   return;
  cg=CallGraphTestUtil.buildZeroOneContainerCFA(options,cache,cha,scope);
  checkCallGraph(cg,squashZeroContainer,null,""String_Node_Str"");
  checkCallGraph(cg,squashZeroOne,null,""String_Node_Str"");
  if (dcgFile != null) {
    checkAgainstDCG(cg,dcgFile);
  }
  checkICFG(cg);
  return;
}","/** 
 * TODO: refactor this to avoid excessive code bloat.
 */
public static void doCallGraphs(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope,String dcgFile,boolean stopAfterZeroCFA,boolean stopAfterZeroContainerCFA,boolean testPAToString){
  CallGraph cg=CallGraphTestUtil.buildRTA(options,cache,cha,scope);
  try {
    GraphIntegrity.check(cg);
  }
 catch (  UnsoundGraphException e1) {
    e1.printStackTrace();
    assertTrue(e1.getMessage(),false);
  }
  Set<MethodReference> rtaMethods=CallGraphStats.collectMethods(cg);
  Trace.println(""String_Node_Str"" + rtaMethods.size());
  Trace.println(CallGraphStats.getStats(cg));
  Trace.println(""String_Node_Str"");
  cg=CallGraphTestUtil.buildZeroCFA(options,cache,cha,scope,testPAToString);
  Graph<MethodReference> squashZero=checkCallGraph(cg,null,rtaMethods,""String_Node_Str"");
  if (stopAfterZeroCFA) {
    return;
  }
  cg=CallGraphTestUtil.buildZeroOneCFA(options,cache,cha,scope,testPAToString);
  Graph<MethodReference> squashZeroOne=checkCallGraph(cg,squashZero,null,""String_Node_Str"");
  cg=CallGraphTestUtil.buildZeroContainerCFA(options,cache,cha,scope);
  Graph<MethodReference> squashZeroContainer=checkCallGraph(cg,squashZero,null,""String_Node_Str"");
  if (stopAfterZeroContainerCFA)   return;
  cg=CallGraphTestUtil.buildZeroOneContainerCFA(options,cache,cha,scope);
  checkCallGraph(cg,squashZeroContainer,null,""String_Node_Str"");
  checkCallGraph(cg,squashZeroOne,null,""String_Node_Str"");
  if (dcgFile != null) {
    checkAgainstDCG(cg,dcgFile);
  }
  checkICFG(cg);
  return;
}",0.9829855537720706
100321,"public static CallGraph buildZeroCFA(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope){
  Stopwatch S=new Stopwatch(""String_Node_Str"");
  S.start();
  CallGraphBuilder builder=Util.makeZeroCFABuilder(options,cache,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  S.stop();
  Trace.println(S.report());
  return cg;
}","public static CallGraph buildZeroCFA(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope,boolean testPAtoString){
  Stopwatch S=new Stopwatch(""String_Node_Str"");
  S.start();
  CallGraphBuilder builder=Util.makeZeroCFABuilder(options,cache,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  if (testPAtoString) {
    builder.getPointerAnalysis().toString();
  }
  S.stop();
  Trace.println(S.report());
  return cg;
}",0.8829268292682927
100322,"public static CallGraph buildZeroOneCFA(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope){
  Stopwatch S=new Stopwatch(""String_Node_Str"");
  S.start();
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cache,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  S.stop();
  Trace.println(S.report());
  return cg;
}","public static CallGraph buildZeroOneCFA(AnalysisOptions options,AnalysisCache cache,ClassHierarchy cha,AnalysisScope scope,boolean testPAtoString){
  Stopwatch S=new Stopwatch(""String_Node_Str"");
  S.start();
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cache,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  if (testPAtoString) {
    builder.getPointerAnalysis().toString();
  }
  S.stop();
  Trace.println(S.report());
  return cg;
}",0.8846153846153846
100323,"public void testClassConstants() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  TypeReference mainClassRef=TypeReference.findOrCreate(ClassLoaderReference.Application,TestConstants.CLASSCONSTANT_MAIN);
  Assert.assertTrue(cha.lookupClass(mainClassRef) != null);
  Iterable<Entrypoint> entrypoints=Util.makeMainEntrypoints(scope,cha,TestConstants.CLASSCONSTANT_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraph cg=CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope);
  Trace.println(""String_Node_Str"");
  Trace.println(cg);
  MethodReference mainMethodRef=MethodReference.findOrCreate(mainClassRef,""String_Node_Str"",""String_Node_Str"");
  Set<CGNode> mainMethodNodes=cg.getNodes(mainMethodRef);
  Assert.assertFalse(mainMethodNodes.isEmpty());
  CGNode mainMethodNode=(CGNode)mainMethodNodes.iterator().next();
  Trace.println(""String_Node_Str"");
  Trace.println(mainMethodNode.getIR());
  TypeReference classRef=TypeReference.findOrCreate(ClassLoaderReference.Primordial,""String_Node_Str"");
  MethodReference hashCodeRef=MethodReference.findOrCreate(classRef,""String_Node_Str"",""String_Node_Str"");
  Set<CGNode> hashCodeNodes=cg.getNodes(hashCodeRef);
  Assert.assertFalse(hashCodeNodes.isEmpty());
  Assert.assertTrue(cg.hasEdge(mainMethodNode,hashCodeNodes.iterator().next()));
}","public void testClassConstants() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  TypeReference mainClassRef=TypeReference.findOrCreate(ClassLoaderReference.Application,TestConstants.CLASSCONSTANT_MAIN);
  Assert.assertTrue(cha.lookupClass(mainClassRef) != null);
  Iterable<Entrypoint> entrypoints=Util.makeMainEntrypoints(scope,cha,TestConstants.CLASSCONSTANT_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraph cg=CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false);
  Trace.println(""String_Node_Str"");
  Trace.println(cg);
  MethodReference mainMethodRef=MethodReference.findOrCreate(mainClassRef,""String_Node_Str"",""String_Node_Str"");
  Set<CGNode> mainMethodNodes=cg.getNodes(mainMethodRef);
  Assert.assertFalse(mainMethodNodes.isEmpty());
  CGNode mainMethodNode=(CGNode)mainMethodNodes.iterator().next();
  Trace.println(""String_Node_Str"");
  Trace.println(mainMethodNode.getIR());
  TypeReference classRef=TypeReference.findOrCreate(ClassLoaderReference.Primordial,""String_Node_Str"");
  MethodReference hashCodeRef=MethodReference.findOrCreate(classRef,""String_Node_Str"",""String_Node_Str"");
  Set<CGNode> hashCodeNodes=cg.getNodes(hashCodeRef);
  Assert.assertFalse(hashCodeNodes.isEmpty());
  Assert.assertTrue(cg.hasEdge(mainMethodNode,hashCodeNodes.iterator().next()));
}",0.9979757085020244
100324,"public void testJavaCup() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JAVA_CUP);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JAVA_CUP_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope));
}","public void testJavaCup() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JAVA_CUP);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JAVA_CUP_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false));
}",0.9939148073022313
100325,"public void testJLex() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JLEX);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JLEX_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope));
}","public void testJLex() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.JLEX);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.JLEX_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false));
}",0.9937759336099584
100326,"public void testBcelVerifier() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.BCEL);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.BCEL_VERIFIER_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope));
}","public void testBcelVerifier() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.BCEL);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.BCEL_VERIFIER_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  run(CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false));
}",0.9939879759519038
100327,"private CallGraph doGraph(boolean usePiNodes) throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.PI_TEST_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  options.getSSAOptions().setUsePiNodes(usePiNodes);
  return CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope);
}","private CallGraph doGraph(boolean usePiNodes) throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.PI_TEST_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  options.getSSAOptions().setUsePiNodes(usePiNodes);
  return CallGraphTestUtil.buildZeroCFA(options,new AnalysisCache(),cha,scope,false);
}",0.9947552447552448
100328,"/** 
 * Constructor for SpecJTest.
 * @param arg0
 */
public MultiDimArrayTest(String arg0){
  super(arg0);
}","/** 
 * @param arg0
 */
public MultiDimArrayTest(String arg0){
  super(arg0);
}",0.8404255319148937
100329,"@SuppressWarnings(""String_Node_Str"") public Collection<InstanceKey> getPointsTo(PointerKey pk){
  Assertions._assert(pk instanceof LocalPointerKey,""String_Node_Str"");
  LocalPointerKey lpk=(LocalPointerKey)pk;
  SimpleDemandPointerFlowGraph g=new SimpleDemandPointerFlowGraph(cg,heapModel,fam,cha);
  CGNode node=lpk.getNode();
  g.addSubgraphForNode(node);
  if (!g.containsNode(pk)) {
    return Collections.emptySet();
  }
  if (VERBOSE) {
    Trace.println(g.toString());
  }
  Filter iKeyFilter=new Filter(){
    public boolean accepts(    Object o){
      return o instanceof InstanceKey;
    }
  }
;
  SlowDFSDiscoverTimeIterator<Object> dfs=new SlowDFSDiscoverTimeIterator<Object>(g,pk);
  return Iterator2Collection.toCollection((Iterator<? extends InstanceKey>)new FilterIterator<Object>(dfs,iKeyFilter));
}","@SuppressWarnings(""String_Node_Str"") public Collection<InstanceKey> getPointsTo(PointerKey pk){
  Assertions._assert(pk instanceof LocalPointerKey,""String_Node_Str"");
  LocalPointerKey lpk=(LocalPointerKey)pk;
  SimpleDemandPointerFlowGraph g=new SimpleDemandPointerFlowGraph(cg,heapModel,fam,cha);
  CGNode node=lpk.getNode();
  g.addSubgraphForNode(node);
  if (!g.containsNode(pk)) {
    return Collections.emptySet();
  }
  if (VERBOSE) {
    Trace.println(g.toString());
  }
  Filter iKeyFilter=new Filter(){
    public boolean accepts(    Object o){
      return o instanceof InstanceKey;
    }
  }
;
  SlowDFSDiscoverTimeIterator<Object> dfs=new SlowDFSDiscoverTimeIterator<Object>(g,pk);
  return Iterator2Collection.toCollection((Iterator<? extends InstanceKey>)(Iterator)new FilterIterator<Object>(dfs,iKeyFilter));
}",0.9939172749391728
100330,"@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else   if (rhs == this) {
    return this;
  }
 else   if (rhs instanceof PrimitiveType) {
    if (size() > ((PrimitiveType)rhs).size()) {
      return this;
    }
 else {
      return rhs;
    }
  }
 else {
    return TOP;
  }
}","@Override public TypeAbstraction meet(TypeAbstraction rhs){
  if (rhs == TOP) {
    return this;
  }
 else   if (rhs == this) {
    return this;
  }
 else   if (rhs instanceof PrimitiveType) {
    TypeReference other=((PrimitiveType)rhs).reference;
    if (reference == TypeReference.Double) {
      return this;
    }
 else     if (other == TypeReference.Double) {
      return rhs;
    }
 else     if (reference == TypeReference.Float) {
      return this;
    }
 else     if (other == TypeReference.Float) {
      return rhs;
    }
 else {
      if (size() > ((PrimitiveType)rhs).size()) {
        return this;
      }
 else {
        return rhs;
      }
    }
  }
 else {
    return TOP;
  }
}",0.5583657587548638
100331,"private FunctionTerm(IFunction f,List<ITerm> parameters) throws IllegalArgumentException {
  this.f=f;
  this.parameters=parameters;
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","private FunctionTerm(IFunction f,List<ITerm> parameters) throws IllegalArgumentException {
  this.f=f;
  this.parameters=parameters;
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  ITerm t : parameters) {
    if (t == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}",0.6666666666666666
100332,"/** 
 * Does the term t1 match the pattern t2? Note that this deals with wildcards.
 */
private static boolean termsMatch(ITerm t1,ITerm t2){
  if (t1.equals(t2)) {
    return true;
  }
switch (t1.getKind()) {
case CONSTANT:
case VARIABLE:
    return Wildcard.STAR.equals(t2);
case FUNCTION:
  if (Wildcard.STAR.equals(t2)) {
    return true;
  }
 else {
    if (t2 instanceof FunctionTerm) {
      FunctionTerm f1=(FunctionTerm)t1;
      FunctionTerm f2=(FunctionTerm)t2;
      if (f1.getFunction().equals(f2.getFunction())) {
        for (int i=0; i < f1.getParameters().size(); i++) {
          ITerm x=f1.getParameters().get(i);
          ITerm y=f2.getParameters().get(i);
          if (!termsMatch(x,y)) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  }
default :
Assertions.UNREACHABLE();
return false;
}
}","/** 
 * Does the term t1 match the pattern t2? Note that this deals with wildcards. Records bindings from Wildcards to Terms in the binding map ... modified as a side effect.
 */
private static boolean termsMatch(ITerm t1,ITerm t2,Map<Wildcard,ITerm> binding){
  if (t1.equals(t2)) {
    return true;
  }
  if (t2 instanceof Wildcard) {
    Wildcard w=(Wildcard)t2;
    ITerm b=binding.get(w);
    if (b != null) {
      return b.equals(t1);
    }
 else {
      binding.put(w,t1);
      return true;
    }
  }
switch (t1.getKind()) {
case CONSTANT:
case VARIABLE:
    return false;
case FUNCTION:
  if (t2 instanceof FunctionTerm) {
    FunctionTerm f1=(FunctionTerm)t1;
    FunctionTerm f2=(FunctionTerm)t2;
    if (f1.getFunction().equals(f2.getFunction())) {
      for (int i=0; i < f1.getParameters().size(); i++) {
        ITerm x=f1.getParameters().get(i);
        ITerm y=f2.getParameters().get(i);
        if (!termsMatch(x,y,binding)) {
          return false;
        }
      }
      return true;
    }
  }
return false;
default :
Assertions.UNREACHABLE();
return false;
}
}",0.6990788126919141
100333,"/** 
 * does the structure of some formula f suggest an immediate substitution to simplify the system, based on theory of equality?
 * @return a pair (p1, p2) meaning ""substitute p2 for p1""
 */
private static Pair<ITerm,ITerm> getNextEqualitySubstitution(Collection<IFormula> s,Collection<? extends IFormula> theory,Collection<IFormula> alreadyUsed){
  Collection<IFormula> candidates=HashSetFactory.make();
  candidates.addAll(s);
  candidates.addAll(theory);
  for (  IFormula f : candidates) {
    if (!alreadyUsed.contains(f)) {
      Pair<ITerm,ITerm> substitution=equalitySuggestsSubsitution(f);
      if (substitution != null) {
        alreadyUsed.add(f);
        return substitution;
      }
    }
  }
  return null;
}","/** 
 * does the structure of some formula f suggest an immediate substitution to simplify the system, based on theory of equality?
 * @return a pair (p1, p2) meaning ""substitute p2 for p1""
 */
private static Pair<ITerm,ITerm> getNextEqualitySubstitution(Collection<IFormula> s,Collection<? extends IFormula> theory,Collection<IFormula> alreadyUsed){
  Collection<IFormula> candidates=HashSetFactory.make();
  candidates.addAll(s);
  candidates.addAll(theory);
  for (  IFormula f : candidates) {
    if (!alreadyUsed.contains(f)) {
      Pair<ITerm,ITerm> substitution=equalitySuggestsSubstitution(f);
      if (substitution != null) {
        alreadyUsed.add(f);
        return substitution;
      }
    }
  }
  return null;
}",0.9993127147766324
100334,"/** 
 * in term t, substitute t2 for free occurrences of t1
 */
private static ITerm substitute(ITerm t,ITerm t1,ITerm t2){
  if (termsMatch(t,t1)) {
    return t2;
  }
switch (t.getKind()) {
case CONSTANT:
    return t;
case FUNCTION:
  FunctionTerm f=(FunctionTerm)t;
List<ITerm> terms=new LinkedList<ITerm>();
for (ITerm p : f.getParameters()) {
terms.add(substitute(p,t1,t2));
}
return FunctionTerm.make(f.getFunction(),terms);
case VARIABLE:
if (t1.equals(t)) {
return t2;
}
 else {
return t;
}
default :
Assertions.UNREACHABLE();
return null;
}
}","/** 
 * in term t, substitute t2 for free occurrences of t1
 */
private static ITerm substitute(ITerm t,ITerm t1,ITerm t2,Map<Wildcard,ITerm> binding){
}",0.4056737588652482
100335,"private Wildcard(){
}","private Wildcard(int number){
  this.number=number;
}",0.5675675675675675
100336,"@Override public int hashCode(){
  return 151;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + number;
  return result;
}",0.5263157894736842
100337,"@Override public boolean equals(Object obj){
  return this == obj;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  final Wildcard other=(Wildcard)obj;
  if (number != other.number)   return false;
  return true;
}",0.3652694610778443
100338,"@Override public String toString(){
  return ""String_Node_Str"";
}","@Override public String toString(){
  return number == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + number + ""String_Node_Str"";
}",0.6735751295336787
100339,"@SuppressWarnings(""String_Node_Str"") public Collection<? extends IFunction> getFunctions(){
  Set<? extends IFunction> s=HashSetFactory.make();
  s.addAll(a.getFunctions());
  s.addAll(b.getFunctions());
  return s;
}","@SuppressWarnings(""String_Node_Str"") public Collection<? extends IFunction> getFunctions(){
  Collection<? extends IFunction> s=HashSetFactory.make();
  s.addAll(a.getFunctions());
  s.addAll(b.getFunctions());
  return s;
}",0.9705215419501134
100340,"@SuppressWarnings(""String_Node_Str"") public Collection<? extends IRelation> getRelations(){
  Set<? extends IRelation> s=HashSetFactory.make();
  s.addAll(a.getRelations());
  s.addAll(b.getRelations());
  return s;
}","@SuppressWarnings(""String_Node_Str"") public Collection<? extends IRelation> getRelations(){
  Collection<? extends IRelation> s=HashSetFactory.make();
  s.addAll(a.getRelations());
  s.addAll(b.getRelations());
  return s;
}",0.9705215419501134
100341,"public int getMaxNumber(){
  Assertions.UNREACHABLE();
  return 0;
}","public int getMaxNumber(){
  return getNumberOfNodes() - 1;
}",0.6046511627906976
100342,"public int getNumber(){
  if (isEntryBlock()) {
    return 0;
  }
 else   if (isExitBlock()) {
    return getNumberOfNodes() - 1;
  }
 else {
    return instructionIndex;
  }
}","public int getNumber(){
  if (isEntryBlock()) {
    return 0;
  }
 else   if (isExitBlock()) {
    return getNumberOfNodes() - 1;
  }
 else {
    return instructionIndex + 1;
  }
}",0.9887640449438202
100343,"public IBasicBlock getNode(int number){
  if (number == 0) {
    return entry();
  }
 else   if (number == getNumberOfNodes() - 1) {
    return exit();
  }
 else {
    return normalNodes.get(number);
  }
}","public IBasicBlock getNode(int number){
  if (number == 0) {
    return entry();
  }
 else   if (number == getNumberOfNodes() - 1) {
    return exit();
  }
 else {
    return normalNodes.get(number - 1);
  }
}",0.9903381642512076
100344,"/** 
 * Evaluate a meet of the stacks of machine states at the entry of a basic block. TODO: add some efficiency shortcuts. TODO: clean up and refactor.
 * @param bb the basic block at whose entry the meet occurs
 * @return true if the lhs value changes. false otherwise.
 */
private boolean meetStacks(IVariable lhs,IVariable[] rhs,BasicBlock bb,Meeter meeter){
  boolean changed=false;
  MachineState L=(MachineState)lhs;
  int height=computeMeetStackHeight(rhs);
  if (height > -1 && L.stack == null) {
    L.allocateStack();
    L.stackHeight=height;
    changed=true;
  }
  for (int i=0; i < height; i++) {
    int[] R=new int[rhs.length];
    for (int j=0; j < R.length; j++) {
      MachineState m=(MachineState)rhs[j];
      if (m.stack == null) {
        R[j]=TOP;
      }
 else {
        R[j]=m.stack[i];
      }
    }
    int meet=meeter.meetStack(i,R,bb);
    if (L.stack[i] == TOP) {
      if (meet != TOP) {
        changed=true;
        L.stack[i]=meet;
      }
    }
 else     if (meet != L.stack[i]) {
      changed=true;
      L.stack[i]=meet;
    }
  }
  return changed;
}","/** 
 * Evaluate a meet of the stacks of machine states at the entry of a basic block. TODO: add some efficiency shortcuts. TODO: clean up and refactor.
 * @param bb the basic block at whose entry the meet occurs
 * @return true if the lhs value changes. false otherwise.
 */
private boolean meetStacks(IVariable lhs,IVariable[] rhs,BasicBlock bb,Meeter meeter){
  boolean changed=false;
  MachineState L=(MachineState)lhs;
  int height=computeMeetStackHeight(rhs);
  if (height > -1 && L.stack == null) {
    L.allocateStack();
    L.stackHeight=height;
    changed=true;
  }
  for (int i=0; i < height; i++) {
    int[] R=new int[rhs.length];
    for (int j=0; j < R.length; j++) {
      MachineState m=(MachineState)rhs[j];
      if (m.stack == null) {
        R[j]=TOP;
      }
 else {
        R[j]=m.stack[i];
        if (R[j] == 0) {
          R[j]=TOP;
        }
      }
    }
    int meet=meeter.meetStack(i,R,bb);
    if (L.stack[i] == TOP) {
      if (meet != TOP) {
        changed=true;
        L.stack[i]=meet;
      }
    }
 else     if (meet != L.stack[i]) {
      changed=true;
      L.stack[i]=meet;
    }
  }
  return changed;
}",0.9754135002235136
100345,"@Override public String toString(){
  if (isTOP()) {
    return ""String_Node_Str"" + System.identityHashCode(this);
  }
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  result.append(""String_Node_Str"");
  if (stackHeight == 0) {
    result.append(""String_Node_Str"");
  }
 else {
    result.append(array2StringBuffer(stack,stackHeight));
  }
  result.append(""String_Node_Str"");
  result.append(array2StringBuffer(locals,maxLocals));
  result.append(""String_Node_Str"");
  result.append(System.identityHashCode(this));
  return result.toString();
}","@Override public String toString(){
  if (isTOP()) {
    return ""String_Node_Str"" + System.identityHashCode(this);
  }
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  result.append(""String_Node_Str"");
  if (stackHeight == 0) {
    result.append(""String_Node_Str"");
  }
 else {
    result.append(array2StringBuffer(stack,stackHeight));
  }
  result.append(""String_Node_Str"");
  result.append(array2StringBuffer(locals,maxLocals));
  result.append(""String_Node_Str"");
  return result.toString();
}",0.9548872180451128
100346,"public Iterator<SSAPhiInstruction> iteratePhis(){
  compressPhis();
  if (stackSlotPhis == null) {
    if (localPhis == null) {
      return EmptyIterator.instance();
    }
 else {
      return Arrays.asList(localPhis).iterator();
    }
  }
 else {
    if (localPhis == null) {
      return Arrays.asList(stackSlotPhis).iterator();
    }
 else {
      return new CompoundIterator<SSAPhiInstruction>(Arrays.asList(stackSlotPhis).iterator(),Arrays.asList(localPhis).iterator());
    }
  }
}","public Iterator<SSAPhiInstruction> iteratePhis(){
  compressPhis();
  if (stackSlotPhis == null) {
    if (localPhis == null) {
      return EmptyIterator.instance();
    }
 else {
      LinkedList<SSAPhiInstruction> result=new LinkedList<SSAPhiInstruction>();
      for (      SSAPhiInstruction phi : localPhis) {
        if (phi != null) {
          result.add(phi);
        }
      }
      return result.iterator();
    }
  }
 else {
    if (localPhis == null) {
      LinkedList<SSAPhiInstruction> result=new LinkedList<SSAPhiInstruction>();
      for (      SSAPhiInstruction phi : stackSlotPhis) {
        if (phi != null) {
          result.add(phi);
        }
      }
      return result.iterator();
    }
 else {
      LinkedList<SSAPhiInstruction> result=new LinkedList<SSAPhiInstruction>();
      for (      SSAPhiInstruction phi : localPhis) {
        if (phi != null) {
          result.add(phi);
        }
      }
      return result.iterator();
    }
  }
}",0.3591501028101439
100347,"/** 
 * Process the given array reference node. Factored out so that derived languages can reuse this code for specially-marked types of array references (as in X10, for which different instruction types get generated, but whose structure is essentially the same as an ordinary array reference).
 */
protected boolean doVisitArrayRefNode(CAstNode n,CAstNode v,CAstNode a,boolean assign,boolean preOp,Context context,CAstVisitor visitor){
  if (assign ? visitor.visitArrayRefAssign(n,v,a,context,visitor) : visitor.visitArrayRefAssignOp(n,v,a,preOp,context,visitor))   return true;
  visitor.visit(n.getChild(0),context,visitor);
  visitor.visitChildren(n,2,context,visitor);
  if (assign)   visitor.leaveArrayRefAssign(n,v,a,context,visitor);
 else   visitor.leaveArrayRefAssignOp(n,v,a,preOp,context,visitor);
  return true;
}","/** 
 * Process the given array reference node. Factored out so that derived languages can reuse this code for specially-marked types of array references (as in X10, for which different instruction types get generated, but whose structure is essentially the same as an ordinary array reference).
 */
protected boolean doVisitArrayRefNode(CAstNode n,CAstNode v,CAstNode a,boolean assign,boolean preOp,Context context,CAstVisitor visitor){
  if (assign ? visitor.visitArrayRefAssign(n,v,a,context,visitor) : visitor.visitArrayRefAssignOp(n,v,a,preOp,context,visitor))   return true;
  visitor.visit(n.getChild(0),context,visitor);
  visitor.visitChildren(n,2,context,visitor);
  if (assign)   visitor.leaveArrayRefAssign(n,v,a,context,visitor);
 else   visitor.leaveArrayRefAssignOp(n,v,a,preOp,context,visitor);
  return false;
}",0.9957703927492448
100348,"protected boolean visitAssignNodes(CAstNode n,Context context,CAstNode v,CAstNode a,CAstVisitor visitor){
  int NT=a.getKind();
  boolean assign=NT == CAstNode.ASSIGN;
  boolean preOp=NT == CAstNode.ASSIGN_PRE_OP;
switch (n.getKind()) {
case CAstNode.ARRAY_REF:
{
      return doVisitArrayRefNode(n,v,a,assign,preOp,context,visitor);
    }
case CAstNode.OBJECT_REF:
{
    if (assign ? visitor.visitObjectRefAssign(n,v,a,context,visitor) : visitor.visitObjectRefAssignOp(n,v,a,preOp,context,visitor))     return true;
    visitor.visit(n.getChild(0),context,visitor);
    if (assign)     visitor.leaveObjectRefAssign(n,v,a,context,visitor);
 else     visitor.leaveObjectRefAssignOp(n,v,a,preOp,context,visitor);
    break;
  }
case CAstNode.BLOCK_EXPR:
{
  if (assign ? visitor.visitBlockExprAssign(n,v,a,context,visitor) : visitor.visitBlockExprAssignOp(n,v,a,preOp,context,visitor))   return true;
  if (visitor.visitAssignNodes(n.getChild(n.getChildCount() - 1),context,v,a,visitor))   return true;
  if (assign)   visitor.leaveBlockExprAssign(n,v,a,context,visitor);
 else   visitor.leaveBlockExprAssignOp(n,v,a,preOp,context,visitor);
  break;
}
case CAstNode.VAR:
{
if (assign ? visitor.visitVarAssign(n,v,a,context,visitor) : visitor.visitVarAssignOp(n,v,a,preOp,context,visitor)) return true;
if (assign) visitor.leaveVarAssign(n,v,a,context,visitor);
 else visitor.leaveVarAssignOp(n,v,a,preOp,context,visitor);
break;
}
default :
{
if (!visitor.doVisitAssignNodes(n,context,v,a,visitor)) {
Trace.println(""String_Node_Str"" + n.getKind());
throw new UnsupportedOperationException(""String_Node_Str"" + CAstPrinter.print(a,context.top().getSourceMap()));
}
}
}
return false;
}","protected boolean visitAssignNodes(CAstNode n,Context context,CAstNode v,CAstNode a,CAstVisitor visitor){
  int NT=a.getKind();
  boolean assign=NT == CAstNode.ASSIGN;
  boolean preOp=NT == CAstNode.ASSIGN_PRE_OP;
switch (n.getKind()) {
case CAstNode.ARRAY_REF:
{
      if (doVisitArrayRefNode(n,v,a,assign,preOp,context,visitor)) {
        return true;
      }
      break;
    }
case CAstNode.OBJECT_REF:
{
    if (assign ? visitor.visitObjectRefAssign(n,v,a,context,visitor) : visitor.visitObjectRefAssignOp(n,v,a,preOp,context,visitor))     return true;
    visitor.visit(n.getChild(0),context,visitor);
    if (assign)     visitor.leaveObjectRefAssign(n,v,a,context,visitor);
 else     visitor.leaveObjectRefAssignOp(n,v,a,preOp,context,visitor);
    break;
  }
case CAstNode.BLOCK_EXPR:
{
  if (assign ? visitor.visitBlockExprAssign(n,v,a,context,visitor) : visitor.visitBlockExprAssignOp(n,v,a,preOp,context,visitor))   return true;
  if (visitor.visitAssignNodes(n.getChild(n.getChildCount() - 1),context,v,a,visitor))   return true;
  if (assign)   visitor.leaveBlockExprAssign(n,v,a,context,visitor);
 else   visitor.leaveBlockExprAssignOp(n,v,a,preOp,context,visitor);
  break;
}
case CAstNode.VAR:
{
if (assign ? visitor.visitVarAssign(n,v,a,context,visitor) : visitor.visitVarAssignOp(n,v,a,preOp,context,visitor)) return true;
if (assign) visitor.leaveVarAssign(n,v,a,context,visitor);
 else visitor.leaveVarAssignOp(n,v,a,preOp,context,visitor);
break;
}
default :
{
if (!visitor.doVisitAssignNodes(n,context,v,a,visitor)) {
Trace.println(""String_Node_Str"" + n.getKind());
throw new UnsupportedOperationException(""String_Node_Str"" + CAstPrinter.print(a,context.top().getSourceMap()));
}
}
}
return false;
}",0.9838282857982946
100349,"@SuppressWarnings(""String_Node_Str"") public Iterator<T> iterator(){
  return (Iterator<T>)Arrays.asList(store).iterator();
}","@SuppressWarnings(""String_Node_Str"") public Iterator<T> iterator(){
  ArrayList<T> result=new ArrayList<T>();
  for (int i=0; i <= maxIndex; i++) {
    result.add((T)store[i]);
  }
  return result.iterator();
}",0.5209580838323353
100350,"/** 
 * @param index an instruction index from the original SSA IR
 * @return the basic block which contains this instruction.
 */
public IBasicBlock getBlockForInstruction(int index){
  SSAInstruction s=ir.getInstructions()[index];
  return instructionToBlock.get(s);
}","/** 
 * @param index an instruction index from the original SSA IR
 * @return the basic block which contains this instruction.
 */
public IBasicBlock getBlockForInstruction(int index){
  SSAInstruction s=null;
  do {
    s=ir.getInstructions()[index++];
  }
 while (s == null);
  return instructionToBlock.get(s);
}",0.9230769230769232
100351,"/** 
 * return the Instruction-Block for the given instruction.
 * @param inst -instruction
 * @return SingleInstructionBasicBlock containing the given instruction
 */
public SingleInstructionBasicBlock getInstructionBlock(SSAInstruction inst){
  return instructionToBlock.get(inst);
}","/** 
 * return the Instruction-Block for the given instruction. DEPRECATED: use getBlockForInstruction instead.
 * @param inst -instruction
 * @return SingleInstructionBasicBlock containing the given instruction
 */
@Deprecated public SingleInstructionBasicBlock getInstructionBlock(SSAInstruction inst){
  return instructionToBlock.get(inst);
}",0.9047619047619048
100352,"@Override public IFormula getF2(){
  Collection<? extends IFormula> c=HashSetFactory.make(clauses);
  c.remove(getF1());
  return make(c);
}","@Override public IFormula getF2(){
  Collection<? extends IFormula> c=HashSetFactory.make(clauses);
  c.remove(getF1());
  if (c.size() == 1) {
    return c.iterator().next();
  }
 else {
    return make(c);
  }
}",0.7932011331444759
100353,"public void testSlice2() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(30,slice.size());
}","public void testSlice2() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(22,slice.size());
}",0.9977324263038548
100354,"private static Collection<IMaxTerm> collectMaxTerms(IFormula f){
switch (f.getKind()) {
case CONSTANT:
case QUANTIFIED:
case RELATION:
    return Collections.singleton((IMaxTerm)f);
case BINARY:
  AbstractBinaryFormula b=(AbstractBinaryFormula)f;
Collection<IMaxTerm> result=HashSetFactory.make();
result.addAll(collectMaxTerms(b.getF1()));
result.addAll(collectMaxTerms(b.getF2()));
return result;
case NEGATION:
default :
Assertions.UNREACHABLE(f);
return null;
}
}","private static Collection<IMaxTerm> collectMaxTerms(IFormula f){
switch (f.getKind()) {
case CONSTANT:
case QUANTIFIED:
case RELATION:
    return Collections.singleton((IMaxTerm)f);
case BINARY:
  AbstractBinaryFormula b=(AbstractBinaryFormula)f;
if (b.getConnective().equals(BinaryConnective.AND)) {
  Collection<IMaxTerm> result=HashSetFactory.make();
  result.addAll(collectMaxTerms(b.getF1()));
  result.addAll(collectMaxTerms(b.getF2()));
  return result;
}
 else if (b.getConnective().equals(BinaryConnective.OR)) {
  return Collections.singleton(orToMaxTerm(b));
}
 else {
  Assertions.UNREACHABLE();
  return null;
}
case NEGATION:
default :
Assertions.UNREACHABLE(f);
return null;
}
}",0.7310344827586207
100355,"private static Collection<Disjunction> collectClauses(AbstractBinaryFormula b){
  assert(b.getConnective().equals(BinaryConnective.AND));
  Collection<Disjunction> result=HashSetFactory.make();
  IFormula f1=b.getF1();
  if (f1 instanceof AbstractBinaryFormula) {
    AbstractBinaryFormula b1=(AbstractBinaryFormula)f1;
    if (b1.getConnective().equals(BinaryConnective.AND)) {
      result.addAll(collectClauses(b1));
    }
 else {
      result.add(toDisjunction(b1));
    }
  }
 else {
    result.add(toDisjunction(f1));
  }
  IFormula f2=b.getF2();
  if (f2 instanceof AbstractBinaryFormula) {
    AbstractBinaryFormula b2=(AbstractBinaryFormula)f2;
    if (b2.getConnective().equals(BinaryConnective.AND)) {
      result.addAll(collectClauses(b2));
    }
 else {
      result.add(toDisjunction(b2));
    }
  }
 else {
    result.add(toDisjunction(f2));
  }
  return result;
}","private static Collection<Disjunction> collectClauses(AbstractBinaryFormula b){
  if (b.getConnective().equals(BinaryConnective.AND)) {
    Collection<Disjunction> result=HashSetFactory.make();
    IFormula f1=b.getF1();
    if (f1 instanceof AbstractBinaryFormula) {
      AbstractBinaryFormula b1=(AbstractBinaryFormula)f1;
      if (b1.getConnective().equals(BinaryConnective.AND)) {
        result.addAll(collectClauses(b1));
      }
 else {
        result.add(toDisjunction(b1));
      }
    }
 else {
      result.add(toDisjunction(f1));
    }
    IFormula f2=b.getF2();
    if (f2 instanceof AbstractBinaryFormula) {
      AbstractBinaryFormula b2=(AbstractBinaryFormula)f2;
      if (b2.getConnective().equals(BinaryConnective.AND)) {
        result.addAll(collectClauses(b2));
      }
 else {
        result.add(toDisjunction(b2));
      }
    }
 else {
      result.add(toDisjunction(f2));
    }
    return result;
  }
 else {
    return Collections.singleton(toDisjunction(b));
  }
}",0.855923159018143
100356,"private static Disjunction toDisjunction(IFormula f){
switch (f.getKind()) {
case BINARY:
    AbstractBinaryFormula b=(AbstractBinaryFormula)f;
  if (b.getConnective().equals(BinaryConnective.OR)) {
    IFormula f1=b.getF1();
    Disjunction d2=toDisjunction(b.getF2());
    Collection<IFormula> c=HashSetFactory.make();
    c.add(f1);
    c.addAll(d2.getClauses());
    return Disjunction.make(c);
  }
 else {
    Assertions.UNREACHABLE(b.getConnective());
    return null;
  }
case CONSTANT:
case QUANTIFIED:
case RELATION:
return Disjunction.make(Collections.singleton(simplify(f)));
case NEGATION:
default :
Assertions.UNREACHABLE(f.getKind());
return null;
}
}","private static Disjunction toDisjunction(IFormula f){
switch (f.getKind()) {
case BINARY:
    AbstractBinaryFormula b=(AbstractBinaryFormula)f;
  if (b.getConnective().equals(BinaryConnective.OR)) {
    IFormula f1=b.getF1();
    Disjunction d2=toDisjunction(b.getF2());
    Collection<IFormula> c=HashSetFactory.make();
    c.add(f1);
    c.addAll(d2.getClauses());
    return Disjunction.make(c);
  }
 else {
    Assertions.UNREACHABLE(b.getConnective());
    return null;
  }
case CONSTANT:
case QUANTIFIED:
case RELATION:
case NEGATION:
return Disjunction.make(Collections.singleton(simplify(f)));
default :
Assertions.UNREACHABLE(f.getKind());
return null;
}
}",0.9082706766917292
100357,"public static IFormula make(IFormula f){
  if (f instanceof RelationFormula) {
    RelationFormula r=(RelationFormula)f;
    if (r.getRelation().equals(BinaryRelation.EQUALS)) {
      return RelationFormula.make(BinaryRelation.NE,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.NE)) {
      return RelationFormula.make(BinaryRelation.EQUALS,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.GE)) {
      return RelationFormula.make(BinaryRelation.LT,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.GT)) {
      return RelationFormula.make(BinaryRelation.LE,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.LE)) {
      return RelationFormula.make(BinaryRelation.GT,r.getTerms());
    }
    if (r.getRelation().equals(BinaryRelation.LT)) {
      return RelationFormula.make(BinaryRelation.GE,r.getTerms());
    }
  }
  return new NotFormula(f);
}","public static IFormula make(IFormula f){
switch (f.getKind()) {
case RELATION:
    RelationFormula r=(RelationFormula)f;
  if (r.getRelation().equals(BinaryRelation.EQUALS)) {
    return RelationFormula.make(BinaryRelation.NE,r.getTerms());
  }
if (r.getRelation().equals(BinaryRelation.NE)) {
  return RelationFormula.make(BinaryRelation.EQUALS,r.getTerms());
}
if (r.getRelation().equals(BinaryRelation.GE)) {
return RelationFormula.make(BinaryRelation.LT,r.getTerms());
}
if (r.getRelation().equals(BinaryRelation.GT)) {
return RelationFormula.make(BinaryRelation.LE,r.getTerms());
}
if (r.getRelation().equals(BinaryRelation.LE)) {
return RelationFormula.make(BinaryRelation.GT,r.getTerms());
}
if (r.getRelation().equals(BinaryRelation.LT)) {
return RelationFormula.make(BinaryRelation.GE,r.getTerms());
}
return new NotFormula(f);
case CONSTANT:
case BINARY:
case NEGATION:
case QUANTIFIED:
default :
return new NotFormula(f);
}
}",0.8425026968716289
100358,"public String prettyPrint(ILogicDecorator d){
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"");
  result.append(f1.prettyPrint(d));
  result.append(""String_Node_Str"");
  result.append(d.prettyPrint(b));
  result.append(""String_Node_Str"");
  result.append(f2.prettyPrint(d));
  result.append(""String_Node_Str"");
  return result.toString();
}","public String prettyPrint(ILogicDecorator d){
  return d.prettyPrint(this);
}",0.3280898876404494
100359,"public String prettyPrint(IRelation r){
  return r.getSymbol();
}","public String prettyPrint(BinaryFormula f){
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"");
  result.append(f.getF1().prettyPrint(this));
  result.append(""String_Node_Str"");
  result.append(prettyPrint(f.getConnective()));
  result.append(""String_Node_Str"");
  result.append(f.getF2().prettyPrint(this));
  result.append(""String_Node_Str"");
  return result.toString();
}",0.1591397849462365
100360,String prettyPrint(IRelation r);,String prettyPrint(BinaryFormula binaryFormula);,0.65
100361,"/** 
 * For each statement s, return the set of statements that may def the heap value read by s.
 * @param node the node we are computing heap reaching defs for
 * @param ir IR for the node
 * @param pa governing pointer analysis
 * @param mod the set of heap locations which may be written (transitively) by this node. These are logically return values in the SDG.
 * @param statements the statements whose def-use are considered interesting
 * @param exclusions heap locations that should be excluded from data dependence tracking
 * @throws IllegalArgumentException if pa is null
 * @throws IllegalArgumentException if statements is null
 */
public static Map<Statement,OrdinalSet<Statement>> computeReachingDefs(CGNode node,IR ir,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,Collection<Statement> statements,HeapExclusions exclusions){
  if (statements == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.err.println(""String_Node_Str"" + node);
  System.err.println(ir);
  if (VERBOSE) {
    System.err.println(statements.size());
  }
  ExpandedControlFlowGraph cfg=new ExpandedControlFlowGraph(ir);
  OrdinalSetMapping<Statement> domain=createStatementDomain(statements);
  Map<Integer,NormalStatement> ssaInstructionIndex2Statement=mapInstructionsToStatements(domain);
  BitVectorFramework<IBasicBlock,Statement> rd=new BitVectorFramework<IBasicBlock,Statement>(cfg,new RD(node,cfg,pa,domain,ssaInstructionIndex2Statement,exclusions),domain);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  BitVectorSolver<IBasicBlock> solver=new BitVectorSolver<IBasicBlock>(rd);
  solver.solve();
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  return makeResult(solver,domain,node,new DelegatingExtendedHeapModel(pa.getHeapModel()),pa,mod,cfg,ssaInstructionIndex2Statement,exclusions);
}","/** 
 * For each statement s, return the set of statements that may def the heap value read by s.
 * @param node the node we are computing heap reaching defs for
 * @param ir IR for the node
 * @param pa governing pointer analysis
 * @param mod the set of heap locations which may be written (transitively) by this node. These are logically return values in the SDG.
 * @param statements the statements whose def-use are considered interesting
 * @param exclusions heap locations that should be excluded from data dependence tracking
 * @throws IllegalArgumentException if pa is null
 * @throws IllegalArgumentException if statements is null
 */
public static Map<Statement,OrdinalSet<Statement>> computeReachingDefs(CGNode node,IR ir,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,Collection<Statement> statements,HeapExclusions exclusions){
  if (statements == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.err.println(""String_Node_Str"" + node);
  if (VERBOSE) {
    System.err.println(statements.size());
  }
  ExpandedControlFlowGraph cfg=new ExpandedControlFlowGraph(ir);
  OrdinalSetMapping<Statement> domain=createStatementDomain(statements);
  Map<Integer,NormalStatement> ssaInstructionIndex2Statement=mapInstructionsToStatements(domain);
  BitVectorFramework<IBasicBlock,Statement> rd=new BitVectorFramework<IBasicBlock,Statement>(cfg,new RD(node,cfg,pa,domain,ssaInstructionIndex2Statement,exclusions),domain);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  BitVectorSolver<IBasicBlock> solver=new BitVectorSolver<IBasicBlock>(rd);
  solver.solve();
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  return makeResult(solver,domain,node,new DelegatingExtendedHeapModel(pa.getHeapModel()),pa,mod,cfg,ssaInstructionIndex2Statement,exclusions);
}",0.9932642487046632
100362,"/** 
 * map each SSAInstruction index to the NormalStatement which represents it.
 */
private static Map<Integer,NormalStatement> mapInstructionsToStatements(OrdinalSetMapping<Statement> domain){
  Map<Integer,NormalStatement> result=HashMapFactory.make();
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.NORMAL)) {
      NormalStatement n=(NormalStatement)s;
      System.err.println(""String_Node_Str"" + n.getInstructionIndex() + ""String_Node_Str""+ n);
      result.put(n.getInstructionIndex(),n);
    }
  }
  return result;
}","/** 
 * map each SSAInstruction index to the NormalStatement which represents it.
 */
private static Map<Integer,NormalStatement> mapInstructionsToStatements(OrdinalSetMapping<Statement> domain){
  Map<Integer,NormalStatement> result=HashMapFactory.make();
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.NORMAL)) {
      NormalStatement n=(NormalStatement)s;
      result.put(n.getInstructionIndex(),n);
    }
  }
  return result;
}",0.8350100603621731
100363,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 * @param options
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref);
    }
  }
  return visited;
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref);
    }
  }
  return visited;
}",0.9870689655172412
100364,"/** 
 * some code is required here in order to ""hop-over"" dead blocks that only contain null-instructions.
 * @param bb -basic block
 * @param instbb -an instruction basic-block (SingleInstructionBasicBlock)
 */
private void handleLastInstruction(BasicBlock bb,SingleInstructionBasicBlock instbb){
  Set<BBEdge> edgeWorkSet=HashSetFactory.make();
  if (!instbb.isPiBlock()) {
    for (Iterator sit=cfg.getSuccNodes(bb); sit.hasNext(); ) {
      BasicBlock succNode=(BasicBlock)sit.next();
      boolean fallThrough=isFallThroughEdge(bb,succNode);
      edgeWorkSet.add(new BBEdge(bb,succNode,fallThrough));
    }
  }
 else {
    SSAPiInstruction pi=(SSAPiInstruction)instbb.getInstruction();
    int succNum=pi.getSuccessor();
    BasicBlock succNode=(BasicBlock)cfg.getNode(succNum);
    boolean fallThrough=isFallThroughEdge(bb,succNode);
    edgeWorkSet.add(new BBEdge(bb,succNode,fallThrough));
  }
  if (bb.isExitBlock()) {
    addEdge(instbb,exitBlock);
  }
  while (!edgeWorkSet.isEmpty()) {
    Iterator workIt=edgeWorkSet.iterator();
    BBEdge edge=(BBEdge)workIt.next();
    boolean fallThru=false;
    if (isFallThroughEdge(edge.src,edge.dest)) {
      fallThru=true;
    }
    workIt.remove();
    if (edge.dest.isEntryBlock()) {
      addEdge(instbb,entryBlock);
      if (fallThru) {
        fallThroughTargets.put(instbb,entryBlock);
      }
    }
 else     if (edge.dest.isExitBlock()) {
      if (basicBlockHasNonNullInstruction(edge.dest)) {
        SSAInstruction succInst=getBasicBlockEntry(edge.dest);
        SingleInstructionBasicBlock succBlock=getInstructionBlock(succInst);
        addEdge(instbb,succBlock);
        if (fallThru) {
          fallThroughTargets.put(instbb,succBlock);
        }
      }
 else {
        addEdge(instbb,exitBlock);
        if (fallThru) {
          fallThroughTargets.put(instbb,exitBlock);
        }
      }
    }
 else     if (basicBlockHasNonNullInstruction(edge.dest)) {
      SSAInstruction succInst=getBasicBlockEntry(edge.dest);
      SingleInstructionBasicBlock succBlock=getInstructionBlock(succInst);
      addEdge(instbb,succBlock);
      if (fallThru) {
        fallThroughTargets.put(instbb,succBlock);
      }
    }
 else {
      for (Iterator sit=cfg.getSuccNodes(edge.dest); sit.hasNext(); ) {
        BasicBlock succNode=(BasicBlock)sit.next();
        edgeWorkSet.add(new BBEdge(bb,succNode,edge.isFallThrough));
      }
    }
  }
}","/** 
 * some code is required here in order to ""hop-over"" dead blocks that only contain null-instructions.
 * @param bb -basic block
 * @param instbb -an instruction basic-block (SingleInstructionBasicBlock)
 */
private void handleLastInstruction(BasicBlock bb,SingleInstructionBasicBlock instbb){
}",0.2209087550794237
100365,"/** 
 * process a basic block that does not have pi nodes
 * @param bb -basic block
 * @param blockInstructionArray -instructions of the basic-block
 */
private void processNoPi(BasicBlock bb,Object[] blockInstructionArray){
  int size=blockInstructionArray.length;
  for (int i=0; i < size; i++) {
    SSAInstruction inst=(SSAInstruction)blockInstructionArray[i];
    Assertions.productionAssertion(inst != null);
    SingleInstructionBasicBlock currBlock=getInstructionBlock(inst);
    if (i < size - 1) {
      SSAInstruction nextInst=(SSAInstruction)blockInstructionArray[i + 1];
      Assertions.productionAssertion(nextInst != null);
      SingleInstructionBasicBlock nextBlock=getInstructionBlock(nextInst);
      addEdge(currBlock,nextBlock);
      fallThroughTargets.put(currBlock,nextBlock);
    }
 else {
      handleLastInstruction(bb,currBlock);
    }
  }
}","/** 
 * process a basic block that does not have pi nodes
 * @param bb -basic block
 * @param blockInstructionArray -instructions of the basic-block
 */
private void processNoPi(BasicBlock bb,Object[] blockInstructionArray){
  int size=blockInstructionArray.length;
  for (int i=0; i < size; i++) {
    SSAInstruction inst=(SSAInstruction)blockInstructionArray[i];
    Assertions.productionAssertion(inst != null);
    SingleInstructionBasicBlock currBlock=getInstructionBlock(inst);
    if (currBlock == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + inst);
    }
    if (i < size - 1) {
      SSAInstruction nextInst=(SSAInstruction)blockInstructionArray[i + 1];
      Assertions.productionAssertion(nextInst != null);
      SingleInstructionBasicBlock nextBlock=getInstructionBlock(nextInst);
      addEdge(currBlock,nextBlock);
      fallThroughTargets.put(currBlock,nextBlock);
    }
 else {
      handleLastInstruction(bb,currBlock);
    }
  }
}",0.9503003823047516
100366,"/** 
 * create single-instruction basic-blocks distinguish blocks inside exception handler from other blocks. This is pretty horrible.
 */
private void createBasicBlocks(){
  List<IBasicBlock> basicBlockList=new ArrayList<IBasicBlock>();
  entry=0;
  entryBlock=new SingleInstructionBasicBlock(entry,null,-1);
  entryBlock.setIsEntryBlock(true);
  basicBlockList.add(entryBlock);
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    BasicBlock bb=(BasicBlock)it.next();
    for (Iterator phiIt=bb.iteratePhis(); phiIt.hasNext(); ) {
      SSAPhiInstruction phi=(SSAPhiInstruction)phiIt.next();
      if (phi != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,phi,-1));
      }
    }
    for (Iterator piIt=bb.iteratePis(); piIt.hasNext(); ) {
      SSAPiInstruction pi=(SSAPiInstruction)piIt.next();
      if (pi != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,pi,-1));
      }
    }
    for (int i=bb.getFirstInstructionIndex(); i <= bb.getLastInstructionIndex(); i++) {
      SSAInstruction s=instructions[i];
      if (s != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,s,i));
      }
    }
    if (bb instanceof ExceptionHandlerBasicBlock) {
      ExceptionHandlerBasicBlock ebb=(ExceptionHandlerBasicBlock)bb;
      SSAInstruction catchInst=ebb.getCatchInstruction();
      if (catchInst != null) {
        int blockNum=basicBlockList.size();
        new SingleInstructionExceptionHandlerBlock(blockNum,catchInst);
      }
    }
  }
  exit=basicBlockList.size();
  exitBlock=new SingleInstructionBasicBlock(exit,null,-1);
  exitBlock.setIsExitBlock(true);
  basicBlockList.add(exitBlock);
  basicBlocks=new SingleInstructionBasicBlock[basicBlockList.size()];
  for (int i=0; i < basicBlockList.size(); i++) {
    SingleInstructionBasicBlock sibb=(SingleInstructionBasicBlock)basicBlockList.get(i);
    basicBlocks[i]=sibb;
    SSAInstruction blockInstruction=sibb.getInstruction();
    if (blockInstruction != null) {
      instructionToBlock.put(blockInstruction,sibb);
    }
  }
}","/** 
 * create single-instruction basic-blocks distinguish blocks inside exception handler from other blocks. This is pretty horrible.
 */
private void createBasicBlocks(){
  List<IBasicBlock> basicBlockList=new ArrayList<IBasicBlock>();
  entry=0;
  entryBlock=new SingleInstructionBasicBlock(entry,null,-1);
  entryBlock.setIsEntryBlock(true);
  basicBlockList.add(entryBlock);
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    BasicBlock bb=(BasicBlock)it.next();
    for (Iterator phiIt=bb.iteratePhis(); phiIt.hasNext(); ) {
      SSAPhiInstruction phi=(SSAPhiInstruction)phiIt.next();
      if (phi != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,phi,-1));
      }
    }
    for (Iterator piIt=bb.iteratePis(); piIt.hasNext(); ) {
      SSAPiInstruction pi=(SSAPiInstruction)piIt.next();
      if (pi != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,pi,-1));
      }
    }
    for (int i=bb.getFirstInstructionIndex(); i <= bb.getLastInstructionIndex(); i++) {
      SSAInstruction s=instructions[i];
      if (s != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionBasicBlock(blockNum,s,i));
      }
    }
    if (bb instanceof ExceptionHandlerBasicBlock) {
      ExceptionHandlerBasicBlock ebb=(ExceptionHandlerBasicBlock)bb;
      SSAInstruction catchInst=ebb.getCatchInstruction();
      if (catchInst != null) {
        int blockNum=basicBlockList.size();
        basicBlockList.add(new SingleInstructionExceptionHandlerBlock(blockNum,catchInst));
      }
    }
  }
  exit=basicBlockList.size();
  exitBlock=new SingleInstructionBasicBlock(exit,null,-1);
  exitBlock.setIsExitBlock(true);
  basicBlockList.add(exitBlock);
  basicBlocks=new SingleInstructionBasicBlock[basicBlockList.size()];
  for (int i=0; i < basicBlockList.size(); i++) {
    SingleInstructionBasicBlock sibb=(SingleInstructionBasicBlock)basicBlockList.get(i);
    basicBlocks[i]=sibb;
    SSAInstruction blockInstruction=sibb.getInstruction();
    if (blockInstruction != null) {
      instructionToBlock.put(blockInstruction,sibb);
    }
  }
}",0.9954995499549956
100367,"/** 
 * For each statement s, return the set of statements that may def the heap value read by s.
 * @throws IllegalArgumentException if pa is null
 * @throws IllegalArgumentException if statements is null
 */
public static Map<Statement,OrdinalSet<Statement>> computeReachingDefs(CGNode node,IR ir,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,Collection<Statement> statements,HeapExclusions exclusions){
  if (statements == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.err.println(""String_Node_Str"" + node);
  if (VERBOSE) {
    System.err.println(statements.size());
  }
  ExpandedControlFlowGraph cfg=new ExpandedControlFlowGraph(ir);
  OrdinalSetMapping<Statement> domain=createStatementDomain(statements);
  Map<SSAInstruction,NormalStatement> ssaInstruction2Statement=mapInstructionsToStatements(domain);
  BitVectorFramework<IBasicBlock,Statement> rd=new BitVectorFramework<IBasicBlock,Statement>(cfg,new RD(node,cfg,pa,domain,ssaInstruction2Statement,exclusions),domain);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  BitVectorSolver<IBasicBlock> solver=new BitVectorSolver<IBasicBlock>(rd);
  solver.solve();
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  return makeResult(solver,domain,node,new DelegatingExtendedHeapModel(pa.getHeapModel()),pa,mod,cfg,ssaInstruction2Statement,exclusions);
}","/** 
 * For each statement s, return the set of statements that may def the heap value read by s.
 * @param node the node we are computing heap reaching defs for
 * @param ir IR for the node
 * @param pa governing pointer analysis
 * @param mod the set of heap locations which may be written (transitively) by this node. These are logically return values in the SDG.
 * @param statements the statements whose def-use are considered interesting
 * @param exclusions heap locations that should be excluded from data dependence tracking
 * @throws IllegalArgumentException if pa is null
 * @throws IllegalArgumentException if statements is null
 */
public static Map<Statement,OrdinalSet<Statement>> computeReachingDefs(CGNode node,IR ir,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,Collection<Statement> statements,HeapExclusions exclusions){
  if (statements == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.err.println(""String_Node_Str"" + node);
  System.err.println(ir);
  if (VERBOSE) {
    System.err.println(statements.size());
  }
  ExpandedControlFlowGraph cfg=new ExpandedControlFlowGraph(ir);
  OrdinalSetMapping<Statement> domain=createStatementDomain(statements);
  Map<Integer,NormalStatement> ssaInstructionIndex2Statement=mapInstructionsToStatements(domain);
  BitVectorFramework<IBasicBlock,Statement> rd=new BitVectorFramework<IBasicBlock,Statement>(cfg,new RD(node,cfg,pa,domain,ssaInstructionIndex2Statement,exclusions),domain);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  BitVectorSolver<IBasicBlock> solver=new BitVectorSolver<IBasicBlock>(rd);
  solver.solve();
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  return makeResult(solver,domain,node,new DelegatingExtendedHeapModel(pa.getHeapModel()),pa,mod,cfg,ssaInstructionIndex2Statement,exclusions);
}",0.8553864168618267
100368,"/** 
 * map each SSAInstruction to the NormalStatement which represents it.
 */
private static Map<SSAInstruction,NormalStatement> mapInstructionsToStatements(OrdinalSetMapping<Statement> domain){
  Map<SSAInstruction,NormalStatement> ssaInstruction2Statement=HashMapFactory.make();
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.NORMAL)) {
      NormalStatement n=(NormalStatement)s;
      ssaInstruction2Statement.put(n.getInstruction(),n);
    }
  }
  return ssaInstruction2Statement;
}","/** 
 * map each SSAInstruction index to the NormalStatement which represents it.
 */
private static Map<Integer,NormalStatement> mapInstructionsToStatements(OrdinalSetMapping<Statement> domain){
  Map<Integer,NormalStatement> result=HashMapFactory.make();
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.NORMAL)) {
      NormalStatement n=(NormalStatement)s;
      System.err.println(""String_Node_Str"" + n.getInstructionIndex() + ""String_Node_Str""+ n);
      result.put(n.getInstructionIndex(),n);
    }
  }
  return result;
}",0.7383444338725024
100369,"private void initHeapReturnCaller(){
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.HEAP_RET_CALLER)) {
      HeapStatement.ReturnCaller r=(ReturnCaller)s;
      NormalStatement call=ssaInstruction2Statement.get(r.getCall());
      int i=domain.getMappedIndex(call);
      int j=domain.getMappedIndex(r);
      heapReturnCaller.add(i,j);
    }
  }
}","private void initHeapReturnCaller(){
  for (  Statement s : domain) {
    if (s.getKind().equals(Kind.HEAP_RET_CALLER)) {
      HeapStatement.ReturnCaller r=(ReturnCaller)s;
      NormalStatement call=ssaInstructionIndex2Statement.get(r.getCallIndex());
      int i=domain.getMappedIndex(call);
      int j=domain.getMappedIndex(r);
      heapReturnCaller.add(i,j);
    }
  }
}",0.9865591397849462
100370,"/** 
 * @return int set representing the heap def statements that are gen'ed bythe basic block. null if none.
 */
IntSet gen(SingleInstructionBasicBlock b){
  if (b.isEntryBlock()) {
    return heapEntryStatements();
  }
 else {
    SSAInstruction s=b.getInstruction();
    if (s == null) {
      return null;
    }
 else {
      if (s instanceof SSAInvokeInstruction) {
        return heapReturnCaller.getRelated(domain.getMappedIndex(ssaInstruction2Statement.get(s)));
      }
 else {
        Collection<PointerKey> gen=ModRef.getMod(node,h,pa,s,exclusions);
        if (gen.isEmpty()) {
          return null;
        }
 else {
          NormalStatement n=ssaInstruction2Statement.get(s);
          return SparseIntSet.singleton(domain.getMappedIndex(n));
        }
      }
    }
  }
}","/** 
 * @return int set representing the heap def statements that are gen'ed bythe basic block. null if none.
 */
IntSet gen(SingleInstructionBasicBlock b){
  if (b.isEntryBlock()) {
    return heapEntryStatements();
  }
 else {
    SSAInstruction s=b.getInstruction();
    if (s == null) {
      return null;
    }
 else {
      if (s instanceof SSAInvokeInstruction) {
        Statement st=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
        if (st == null) {
          System.err.println(ssaInstructionIndex2Statement);
          Assertions.UNREACHABLE(""String_Node_Str"" + b + ""String_Node_Str""+ b.getLastInstructionIndex()+ ""String_Node_Str""+ s);
        }
        int domainIndex=domain.getMappedIndex(st);
        assert(domainIndex != -1);
        return heapReturnCaller.getRelated(domainIndex);
      }
 else {
        Collection<PointerKey> gen=ModRef.getMod(node,h,pa,s,exclusions);
        if (gen.isEmpty()) {
          return null;
        }
 else {
          NormalStatement n=ssaInstructionIndex2Statement.get(b.getLastInstructionIndex());
          return SparseIntSet.singleton(domain.getMappedIndex(n));
        }
      }
    }
  }
}",0.7591836734693878
100371,"RDMap(BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement,HeapExclusions exclusions){
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  this.exclusions=exclusions;
  Map<PointerKey,MutableIntSet> pointerKeyMod=initPointerKeyMod(domain,node,h,pa);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  eagerPopulate(pointerKeyMod,solver,domain,node,h,pa,mod,cfg,ssaInstruction2Statement);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
}","RDMap(BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement,HeapExclusions exclusions){
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  this.exclusions=exclusions;
  Map<PointerKey,MutableIntSet> pointerKeyMod=initPointerKeyMod(domain,node,h,pa);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
  eagerPopulate(pointerKeyMod,solver,domain,node,h,pa,mod,cfg,ssaInstructionIndex2Statement);
  if (VERBOSE) {
    System.err.println(""String_Node_Str"");
  }
}",0.9802197802197802
100372,"private void eagerPopulate(Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement){
  for (  Statement s : domain) {
    delegate.put(s,computeResult(s,pointerKeyMod,solver,domain,node,h,pa,mod,cfg,ssaInstruction2Statement));
  }
}","private void eagerPopulate(Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstruction2Statement){
  for (  Statement s : domain) {
    delegate.put(s,computeResult(s,pointerKeyMod,solver,domain,node,h,pa,mod,cfg,ssaInstruction2Statement));
  }
}",0.9818569903948772
100373,"/** 
 * For each statement s, compute the set of statements that may def the heap value read by s.
 * @param mod
 * @param ssaInstruction2Statement
 */
private static Map<Statement,OrdinalSet<Statement>> makeResult(BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement,HeapExclusions exclusions){
  return new RDMap(solver,domain,node,h,pa,mod,cfg,ssaInstruction2Statement,exclusions);
}","/** 
 * For each statement s, compute the set of statements that may def the heap value read by s.
 */
private static Map<Statement,OrdinalSet<Statement>> makeResult(BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement,HeapExclusions exclusions){
  return new RDMap(solver,domain,node,h,pa,mod,cfg,ssaInstructionIndex2Statement,exclusions);
}",0.9323843416370108
100374,"public RD(CGNode node,ExpandedControlFlowGraph cfg,PointerAnalysis pa,OrdinalSetMapping<Statement> domain,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement,HeapExclusions exclusions){
  this.node=node;
  this.cfg=cfg;
  this.domain=domain;
  this.pa=pa;
  this.h=new DelegatingExtendedHeapModel(pa.getHeapModel());
  this.ssaInstruction2Statement=ssaInstruction2Statement;
  this.exclusions=exclusions;
  initHeapReturnCaller();
}","public RD(CGNode node,ExpandedControlFlowGraph cfg,PointerAnalysis pa,OrdinalSetMapping<Statement> domain,Map<Integer,NormalStatement> ssaInstructionIndex2Statement,HeapExclusions exclusions){
  this.node=node;
  this.cfg=cfg;
  this.domain=domain;
  this.pa=pa;
  this.h=new DelegatingExtendedHeapModel(pa.getHeapModel());
  this.ssaInstructionIndex2Statement=ssaInstructionIndex2Statement;
  this.exclusions=exclusions;
  initHeapReturnCaller();
}",0.9595505617977528
100375,"/** 
 * For a statement s, compute the set of statements that may def the heap value read by s.
 */
private OrdinalSet<Statement> computeResult(Statement s,Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<SSAInstruction,NormalStatement> ssaInstruction2Statement){
switch (s.getKind()) {
case NORMAL:
    NormalStatement n=(NormalStatement)s;
  Collection<PointerKey> ref=ModRef.getRef(node,h,pa,n.getInstruction(),exclusions);
if (!ref.isEmpty()) {
  IBasicBlock bb=cfg.getBlockForInstruction(n.getInstructionIndex());
  BitVectorVariable v=(BitVectorVariable)solver.getIn(bb);
  MutableSparseIntSet defs=new MutableSparseIntSet();
  for (  PointerKey p : ref) {
    if (pointerKeyMod.get(p) != null) {
      defs.addAll(pointerKeyMod.get(p).intersection(v.getValue()));
    }
  }
  return new OrdinalSet<Statement>(defs,domain);
}
 else {
  return OrdinalSet.empty();
}
case HEAP_RET_CALLEE:
{
HeapStatement.ReturnCallee r=(HeapStatement.ReturnCallee)s;
PointerKey p=r.getLocation();
BitVectorVariable v=(BitVectorVariable)solver.getIn(cfg.exit());
if (pointerKeyMod.get(p) == null) {
  return OrdinalSet.empty();
}
return new OrdinalSet<Statement>(pointerKeyMod.get(p).intersection(v.getValue()),domain);
}
case HEAP_RET_CALLER:
{
HeapStatement.ReturnCaller r=(HeapStatement.ReturnCaller)s;
IBasicBlock bb=cfg.getBlockForInstruction(r.getCall());
BitVectorVariable v=(BitVectorVariable)solver.getIn(bb);
if (allCalleesMod(r,mod) || pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case HEAP_PARAM_CALLER:
{
HeapStatement.ParamCaller r=(HeapStatement.ParamCaller)s;
NormalStatement call=ssaInstruction2Statement.get(r.getCall());
IBasicBlock callBlock=cfg.getBlockForInstruction(call.getInstructionIndex());
BitVectorVariable v=(BitVectorVariable)solver.getIn(callBlock);
if (pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PARAM_CALLER:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case PHI:
case PI:
case CATCH:
case METHOD_ENTRY:
return OrdinalSet.empty();
case HEAP_PARAM_CALLEE:
return OrdinalSet.empty();
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}","/** 
 * For a statement s, compute the set of statements that may def the heap value read by s.
 */
private OrdinalSet<Statement> computeResult(Statement s,Map<PointerKey,MutableIntSet> pointerKeyMod,BitVectorSolver<IBasicBlock> solver,OrdinalSetMapping<Statement> domain,CGNode node,ExtendedHeapModel h,PointerAnalysis pa,Map<CGNode,OrdinalSet<PointerKey>> mod,ExpandedControlFlowGraph cfg,Map<Integer,NormalStatement> ssaInstructionIndex2Statement){
switch (s.getKind()) {
case NORMAL:
    NormalStatement n=(NormalStatement)s;
  Collection<PointerKey> ref=ModRef.getRef(node,h,pa,n.getInstruction(),exclusions);
if (!ref.isEmpty()) {
  IBasicBlock bb=cfg.getBlockForInstruction(n.getInstructionIndex());
  BitVectorVariable v=(BitVectorVariable)solver.getIn(bb);
  MutableSparseIntSet defs=new MutableSparseIntSet();
  for (  PointerKey p : ref) {
    if (pointerKeyMod.get(p) != null) {
      defs.addAll(pointerKeyMod.get(p).intersection(v.getValue()));
    }
  }
  return new OrdinalSet<Statement>(defs,domain);
}
 else {
  return OrdinalSet.empty();
}
case HEAP_RET_CALLEE:
{
HeapStatement.ReturnCallee r=(HeapStatement.ReturnCallee)s;
PointerKey p=r.getLocation();
BitVectorVariable v=(BitVectorVariable)solver.getIn(cfg.exit());
if (pointerKeyMod.get(p) == null) {
  return OrdinalSet.empty();
}
return new OrdinalSet<Statement>(pointerKeyMod.get(p).intersection(v.getValue()),domain);
}
case HEAP_RET_CALLER:
{
HeapStatement.ReturnCaller r=(HeapStatement.ReturnCaller)s;
IBasicBlock bb=cfg.getBlockForInstruction(r.getCall());
BitVectorVariable v=(BitVectorVariable)solver.getIn(bb);
if (allCalleesMod(r,mod) || pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case HEAP_PARAM_CALLER:
{
HeapStatement.ParamCaller r=(HeapStatement.ParamCaller)s;
NormalStatement call=ssaInstructionIndex2Statement.get(r.getCallIndex());
IBasicBlock callBlock=cfg.getBlockForInstruction(call.getInstructionIndex());
BitVectorVariable v=(BitVectorVariable)solver.getIn(callBlock);
if (pointerKeyMod.get(r.getLocation()) == null || v.getValue() == null) {
return OrdinalSet.empty();
}
 else {
return new OrdinalSet<Statement>(pointerKeyMod.get(r.getLocation()).intersection(v.getValue()),domain);
}
}
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PARAM_CALLER:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case PHI:
case PI:
case CATCH:
case METHOD_ENTRY:
return OrdinalSet.empty();
case HEAP_PARAM_CALLEE:
return OrdinalSet.empty();
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}",0.994034302759135
100376,"public ParamCaller(CGNode node,SSAAbstractInvokeInstruction call,PointerKey loc){
  super(node,loc);
  this.call=call;
}","public ParamCaller(CGNode node,int callIndex,PointerKey loc){
  super(node,loc);
  this.callIndex=callIndex;
}",0.808695652173913
100377,"public SSAAbstractInvokeInstruction getCall(){
  return call;
}","public SSAAbstractInvokeInstruction getCall(){
  return (SSAAbstractInvokeInstruction)getNode().getIR().getInstructions()[callIndex];
}",0.6363636363636364
100378,"public ReturnCaller(CGNode node,SSAAbstractInvokeInstruction call,PointerKey loc){
  super(node,loc);
  this.call=call;
}","public ReturnCaller(CGNode node,int callIndex,PointerKey loc){
  super(node,loc);
  this.callIndex=callIndex;
}",0.8103448275862069
100379,"/** 
 * Create nodes in the graph corresponding to in/out parameter passing for a call instruction
 * @param dOptions
 */
private void addParamPassingStatements(SSAAbstractInvokeInstruction call,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<Statement> params=MapUtil.findOrCreateSet(callerParamStatements,call.getCallSite());
  Collection<Statement> rets=MapUtil.findOrCreateSet(callerReturnStatements,call.getCallSite());
  for (int j=0; j < call.getNumberOfUses(); j++) {
    Statement st=new ParamStatement.ParamCaller(node,call,call.getUse(j));
    addNode(st);
    params.add(st);
  }
  if (!call.getDeclaredResultType().equals(TypeReference.Void)) {
    Statement st=new ParamStatement.NormalReturnCaller(node,call);
    addNode(st);
    rets.add(st);
  }
{
    if (!dOptions.isIgnoreExceptions()) {
      Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
      addNode(st);
      rets.add(st);
    }
  }
  if (!dOptions.isIgnoreHeap()) {
    OrdinalSet<PointerKey> uref=unionHeapLocations(node,call,ref);
    for (    PointerKey p : uref) {
      Statement st=new HeapStatement.ParamCaller(node,call,p);
      addNode(st);
      params.add(st);
    }
    OrdinalSet<PointerKey> umod=unionHeapLocations(node,call,mod);
    for (    PointerKey p : umod) {
      Statement st=new HeapStatement.ReturnCaller(node,call,p);
      addNode(st);
      rets.add(st);
    }
  }
}","/** 
 * Create nodes in the graph corresponding to in/out parameter passing for a call instruction
 */
private void addParamPassingStatements(int callIndex,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)node.getIR().getInstructions()[callIndex];
  Collection<Statement> params=MapUtil.findOrCreateSet(callerParamStatements,call.getCallSite());
  Collection<Statement> rets=MapUtil.findOrCreateSet(callerReturnStatements,call.getCallSite());
  for (int j=0; j < call.getNumberOfUses(); j++) {
    Statement st=new ParamStatement.ParamCaller(node,call,call.getUse(j));
    addNode(st);
    params.add(st);
  }
  if (!call.getDeclaredResultType().equals(TypeReference.Void)) {
    Statement st=new ParamStatement.NormalReturnCaller(node,call);
    addNode(st);
    rets.add(st);
  }
{
    if (!dOptions.isIgnoreExceptions()) {
      Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
      addNode(st);
      rets.add(st);
    }
  }
  if (!dOptions.isIgnoreHeap()) {
    OrdinalSet<PointerKey> uref=unionHeapLocations(node,call,ref);
    for (    PointerKey p : uref) {
      Statement st=new HeapStatement.ParamCaller(node,callIndex,p);
      addNode(st);
      params.add(st);
    }
    OrdinalSet<PointerKey> umod=unionHeapLocations(node,call,mod);
    for (    PointerKey p : umod) {
      Statement st=new HeapStatement.ReturnCaller(node,callIndex,p);
      addNode(st);
      rets.add(st);
    }
  }
}",0.9375433726578764
100380,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 * @param options
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements((SSAAbstractInvokeInstruction)s,ref);
    }
  }
  return visited;
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 * @param options
 */
private Collection<SSAInstruction> createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  Collection<SSAInstruction> visited=HashSetFactory.make();
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      addNode(new NormalStatement(node,i));
      visited.add(s);
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref);
    }
  }
  return visited;
}",0.9305555555555556
100381,"public SourceBuffer(Position p) throws IOException {
  this.p=p;
  this.lines=new String[p.getLastLine() - p.getFirstLine() + 1];
  BufferedReader r=new BufferedReader(new InputStreamReader(p.getInputStream()));
  int line=1;
  while (line <= p.getLastLine()) {
    String theLine=r.readLine();
    if (line >= p.getFirstLine()) {
      lines[line - p.getFirstLine()]=line == p.getLastLine() ? theLine.substring(0,p.getLastCol() + 1) : theLine;
    }
    line++;
  }
}","public SourceBuffer(Position p) throws IOException {
  this.p=p;
  this.lines=new String[p.getLastLine() - p.getFirstLine() + 1];
  BufferedReader r=new BufferedReader(new InputStreamReader(p.getInputStream()));
  int line=1;
  while (line <= p.getLastLine()) {
    String theLine=r.readLine();
    if (line >= p.getFirstLine()) {
      lines[line - p.getFirstLine()]=line == p.getLastLine() ? theLine.substring(0,Math.min(theLine.length(),p.getLastCol() + 1)) : theLine;
    }
    line++;
  }
}",0.97196261682243
100382,"/** 
 * @return TypeReference
 */
public FieldReference getDeclaredField(){
  return field;
}","public FieldReference getDeclaredField(){
  return field;
}",0.7763157894736842
100383,"@Override public boolean isPEI(){
  return true;
}","@Override public boolean isPEI(){
  return !isStatic();
}",0.8785046728971962
100384,"/** 
 * @return TypeReference
 */
public TypeReference getDeclaredFieldType(){
  return field.getFieldType();
}","public TypeReference getDeclaredFieldType(){
  return field.getFieldType();
}",0.8191489361702128
100385,"@Override public Collection<TypeReference> getExceptionTypes(){
  return null;
}","@Override public Collection<TypeReference> getExceptionTypes(){
  return Collections.emptySet();
}",0.8764044943820225
100386,"public IField getField(Atom name){
  if (fieldMap.containsKey(name)) {
    return fieldMap.get(name);
  }
 else {
    IField f=findDeclaredField(name);
    if (f != null) {
      fieldMap.put(name,f);
      return f;
    }
 else     if (superClass != null) {
      f=superClass.getField(name);
      if (f != null) {
        fieldMap.put(name,f);
        return f;
      }
    }
  }
  return null;
}","public IField getField(Atom name){
  if (fieldMap.containsKey(name)) {
    return fieldMap.get(name);
  }
 else {
    IField f=findDeclaredField(name);
    if (f != null) {
      fieldMap.put(name,f);
      return f;
    }
 else     if (superClass != null) {
      f=superClass.getField(name);
      if (f != null) {
        fieldMap.put(name,f);
        return f;
      }
    }
    try {
      Collection<IClass> ifaces=isInterface() ? getAllAncestorInterfaces() : getAllImplementedInterfaces();
      for (      IClass i : ifaces) {
        f=i.getField(name);
        if (f != null) {
          fieldMap.put(name,f);
          return f;
        }
      }
    }
 catch (    ClassHierarchyException e) {
    }
  }
  return null;
}",0.6743362831858407
100387,"/** 
 * Find the IMethod in the workspace corresponding to a method selector.
 * @return null if not found
 */
public static IMethod findJavaMethodInWorkspace(String klass,String selector){
  IType type=null;
  try {
    type=findJavaClassInWorkspace(klass);
  }
 catch (  Throwable t) {
    return null;
  }
  if (type == null) {
    return null;
  }
  String name=parseForName(selector,type);
  String[] paramTypes=parseForParameterTypes(selector);
  IMethod m=type.getMethod(name,paramTypes);
  IMethod[] methods=type.findMethods(m);
  if (methods != null && methods.length == 1) {
    return methods[0];
  }
 else {
    try {
      List<IMethod> matches=new ArrayList<IMethod>();
      ITypeParameter[] tp=type.getTypeParameters();
      Collection<String> typeParameterNames=HashSetFactory.make(tp.length);
      for (      ITypeParameter p : tp) {
        typeParameterNames.add(p.getElementName());
      }
      METHODS:       for (      IMethod x : type.getMethods()) {
        if (x.getElementName().equals(name)) {
          if (x.getParameterTypes().length == paramTypes.length) {
            for (int i=0; i < x.getParameterTypes().length; i++) {
              String s1=Signature.getTypeErasure(Signature.getSignatureSimpleName(x.getParameterTypes()[i]));
              String s2=Signature.getTypeErasure(Signature.getSignatureSimpleName(paramTypes[i]));
              if (typeParameterNames.contains(s1)) {
              }
 else {
                if (!s1.equals(s2)) {
                  continue METHODS;
                }
              }
            }
            matches.add(x);
          }
        }
      }
      if (matches.size() == 1) {
        return matches.get(0);
      }
 else {
        System.err.println(""String_Node_Str"" + m);
        return null;
      }
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
      return null;
    }
  }
}","/** 
 * Find the IMethod in the workspace corresponding to a method selector. TODO: this is way too slow.   figure out something better.
 * @return null if not found
 */
public static IMethod findJavaMethodInWorkspace(String klass,String selector){
  IType type=null;
  try {
    type=findJavaClassInWorkspace(klass);
  }
 catch (  Throwable t) {
    return null;
  }
  if (type == null) {
    return null;
  }
  String name=parseForName(selector,type);
  String[] paramTypes=parseForParameterTypes(selector);
  IMethod m=type.getMethod(name,paramTypes);
  IMethod[] methods=type.findMethods(m);
  if (methods != null && methods.length == 1) {
    return methods[0];
  }
 else {
    try {
      List<IMethod> matches=new ArrayList<IMethod>();
      Collection<String> typeParameterNames=getTypeParameterNames(type);
      METHODS:       for (      IMethod x : type.getMethods()) {
        if (x.getElementName().equals(name)) {
          if (x.getParameterTypes().length == paramTypes.length) {
            for (int i=0; i < x.getParameterTypes().length; i++) {
              String s1=Signature.getTypeErasure(Signature.getSignatureSimpleName(x.getParameterTypes()[i]));
              String s2=Signature.getTypeErasure(Signature.getSignatureSimpleName(paramTypes[i]));
              if (typeParameterNames.contains(s1)) {
              }
 else {
                if (!s1.equals(s2)) {
                  continue METHODS;
                }
              }
            }
            matches.add(x);
          }
        }
      }
      if (matches.size() == 1) {
        return matches.get(0);
      }
 else {
        System.err.println(""String_Node_Str"" + m);
        return null;
      }
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
      return null;
    }
  }
}",0.915032679738562
100388,"@Override public void acceptSearchMatch(SearchMatch match) throws CoreException {
  kludge.add((IJavaElement)match.getElement());
}","@Override public void acceptSearchMatch(SearchMatch match) throws CoreException {
  result.add((IMethod)match.getElement());
}",0.9105058365758756
100389,"/** 
 * Find the IType in the workspace corresponding to a class name. TODO: this is too slow. find a better way.
 * @return null if not found
 */
public static IType findJavaClassInWorkspace(String className){
  SearchPattern p=SearchPattern.createPattern(className,IJavaSearchConstants.CLASS,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_EXACT_MATCH);
  IJavaSearchScope scope=SearchEngine.createWorkspaceScope();
  SearchEngine engine=new SearchEngine();
  final Collection<IJavaElement> kludge=HashSetFactory.make();
  SearchRequestor requestor=new SearchRequestor(){
    @Override public void acceptSearchMatch(    SearchMatch match) throws CoreException {
      kludge.add((IJavaElement)match.getElement());
    }
  }
;
  try {
    engine.search(p,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
  if (kludge.size() == 1) {
    System.err.println(""String_Node_Str"" + className);
    return (IType)kludge.iterator().next();
  }
 else {
    System.err.println(""String_Node_Str"" + className);
    return null;
  }
}","/** 
 * Find the IType in the workspace corresponding to a class name. TODO: this is too slow. find a better way.
 * @return null if not found
 */
public static IType findJavaClassInWorkspace(String className){
  SearchPattern p=SearchPattern.createPattern(className,IJavaSearchConstants.CLASS_AND_INTERFACE,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_EXACT_MATCH);
  IJavaSearchScope scope=SearchEngine.createWorkspaceScope();
  SearchEngine engine=new SearchEngine();
  final Collection<IJavaElement> kludge=HashSetFactory.make();
  SearchRequestor requestor=new SearchRequestor(){
    @Override public void acceptSearchMatch(    SearchMatch match) throws CoreException {
      kludge.add((IJavaElement)match.getElement());
    }
  }
;
  try {
    engine.search(p,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
  }
 catch (  CoreException e) {
    e.printStackTrace();
  }
  if (kludge.size() == 1) {
    System.err.println(""String_Node_Str"" + className);
    return (IType)kludge.iterator().next();
  }
 else {
    System.err.println(""String_Node_Str"" + className);
    return null;
  }
}",0.9938271604938272
100390,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static JarFileModule getFromPlugin(String fileName) throws IOException {
  URL url=getFileURLFromPlugin(fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static JarFileModule getFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}",0.98355754857997
100391,"/** 
 * get a file URL for a file from a plugin
 * @param fileName the file name
 * @return the URL, or <code>null</code> if the file is not found
 * @throws IOException
 */
private static URL getFileURLFromPlugin(String fileName) throws IOException {
  URL url=FileLocator.find(CorePlugin.getDefault().getBundle(),new Path(fileName),null);
  if (url == null) {
    fileName=""String_Node_Str"" + fileName;
    url=FileLocator.find(CorePlugin.getDefault().getBundle(),new Path(fileName),null);
    if (url == null) {
      return null;
    }
  }
  url=FileLocator.toFileURL(url);
  url=fixupFileURLSpaces(url);
  return url;
}","/** 
 * get a file URL for a file from a plugin
 * @param fileName the file name
 * @return the URL, or <code>null</code> if the file is not found
 * @throws IOException
 */
private static URL getFileURLFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=FileLocator.find(p.getBundle(),new Path(fileName),null);
  if (url == null) {
    fileName=""String_Node_Str"" + fileName;
    url=FileLocator.find(p.getBundle(),new Path(fileName),null);
    if (url == null) {
      return null;
    }
  }
  url=FileLocator.toFileURL(url);
  url=fixupFileURLSpaces(url);
  return url;
}",0.6760098928277
100392,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static File getFileFromPlugin(String fileName) throws IOException {
  URL url=getFileURLFromPlugin(fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
public static File getFileFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}",0.9691011235955056
100393,"/** 
 */
public static File getFile(String fileName) throws IOException {
  return (CorePlugin.getDefault() == null) ? getFileFromClassLoader(fileName) : getFileFromPlugin(fileName);
}","/** 
 */
public static File getFile(String fileName) throws IOException {
  return (CorePlugin.getDefault() == null) ? getFileFromClassLoader(fileName) : getFileFromPlugin(CorePlugin.getDefault(),fileName);
}",0.9387755102040816
100394,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
public static Module getJarFileModule(String fileName) throws IOException {
  if (CorePlugin.getDefault() == null) {
    return getJarFileFromClassLoader(fileName);
  }
 else {
    try {
      IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
      IFile file=workspaceRoot.getFile(new Path(fileName));
      if (file != null) {
        return new JarFileModule(new JarFile(fileName,false));
      }
    }
 catch (    Exception e) {
    }
    return getFromPlugin(fileName);
  }
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
public static Module getJarFileModule(String fileName) throws IOException {
  if (CorePlugin.getDefault() == null) {
    return getJarFileFromClassLoader(fileName);
  }
 else {
    try {
      IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
      IFile file=workspaceRoot.getFile(new Path(fileName));
      if (file != null) {
        return new JarFileModule(new JarFile(fileName,false));
      }
    }
 catch (    Exception e) {
    }
    return getFromPlugin(CorePlugin.getDefault(),fileName);
  }
}",0.981012658227848
100395,"/** 
 * Add allocation statements to the fake root method for each possible value of parameter i. If necessary, add a phi to combine the values.
 * @param m
 * @param i
 * @return value number holding the parameter to the call; -1 if there wassome error
 */
protected int makeArgument(FakeRootMethod m,int i,WarningSet warnings){
  TypeReference[] p=getParameterTypes(i);
  if (p.length == 1) {
    SSANewInstruction n=m.addAllocation(p[0],warnings);
    return (n == null) ? -1 : n.getDef();
  }
 else {
    int[] values=new int[p.length];
    int countErrors=0;
    for (int j=0; j < p.length; j++) {
      SSANewInstruction n=m.addAllocation(p[j],warnings);
      int value=(n == null) ? -1 : n.getDef();
      if (value == -1) {
        countErrors++;
      }
 else {
        values[j - countErrors]=value;
      }
    }
    if (countErrors > 0) {
      int[] oldValues=values;
      values=new int[oldValues.length - countErrors];
      System.arraycopy(oldValues,0,values,0,values.length);
    }
    return m.addPhi(values);
  }
}","/** 
 * Add allocation statements to the fake root method for each possible value of parameter i. If necessary, add a phi to combine the values.
 * @param m
 * @param i
 * @return value number holding the parameter to the call; -1 if there wassome error
 */
protected int makeArgument(FakeRootMethod m,int i,WarningSet warnings){
  TypeReference[] p=getParameterTypes(i);
  if (p.length == 0) {
    return -1;
  }
 else   if (p.length == 1) {
    SSANewInstruction n=m.addAllocation(p[0],warnings);
    return (n == null) ? -1 : n.getDef();
  }
 else {
    int[] values=new int[p.length];
    int countErrors=0;
    for (int j=0; j < p.length; j++) {
      SSANewInstruction n=m.addAllocation(p[j],warnings);
      int value=(n == null) ? -1 : n.getDef();
      if (value == -1) {
        countErrors++;
      }
 else {
        values[j - countErrors]=value;
      }
    }
    if (countErrors > 0) {
      int[] oldValues=values;
      values=new int[oldValues.length - countErrors];
      System.arraycopy(oldValues,0,values,0,values.length);
    }
    return m.addPhi(values);
  }
}",0.9773584905660376
100396,"/** 
 * Add a call to this entrypoint from the fake root method
 * @param m the Fake Root Method
 * @return the call instruction added, or null if the operation fails
 */
public SSAAbstractInvokeInstruction addCall(FakeRootMethod m,WarningSet warnings){
  int paramValues[];
  CallSiteReference site=makeSite(0);
  if (site == null) {
    return null;
  }
  paramValues=new int[getNumberOfParameters()];
  for (int j=0; j < paramValues.length; j++) {
    paramValues[j]=makeArgument(m,j,warnings);
  }
  return m.addInvocation(paramValues,site);
}","/** 
 * Add a call to this entrypoint from the fake root method
 * @param m the Fake Root Method
 * @return the call instruction added, or null if the operation fails
 */
public SSAAbstractInvokeInstruction addCall(FakeRootMethod m,WarningSet warnings){
  int paramValues[];
  CallSiteReference site=makeSite(0);
  if (site == null) {
    return null;
  }
  paramValues=new int[getNumberOfParameters()];
  for (int j=0; j < paramValues.length; j++) {
    paramValues[j]=makeArgument(m,j,warnings);
    if (paramValues[j] == -1) {
      return null;
    }
  }
  return m.addInvocation(paramValues,site);
}",0.950477845351868
100397,"/** 
 * @param method
 */
protected TypeReference[][] makeParameterTypes(IMethod method){
  TypeReference[][] result=new TypeReference[method.getNumberOfParameters()][];
  for (int i=0; i < result.length; i++) {
    TypeReference t=method.getParameterType(i);
    IClass klass=cha.lookupClass(t);
    if (klass == null) {
      t=null;
    }
 else     if (klass.isAbstract()) {
      t=chooseAConcreteSubClass(klass);
    }
 else     if (klass.isInterface()) {
      t=chooseAnImplementor(klass);
    }
 else     if (klass.isArrayClass()) {
      ArrayClass arrayKlass=(ArrayClass)klass;
      IClass innermost=arrayKlass.getInnermostElementClass();
      if (innermost != null && innermost.isInterface()) {
        TypeReference impl=chooseAnImplementor(innermost);
        if (impl == null) {
          t=null;
        }
 else {
          t=TypeReference.findOrCreateArrayOf(impl);
          for (int dim=1; dim < arrayKlass.getDimensionality(); dim++) {
            t=TypeReference.findOrCreateArrayOf(t);
          }
        }
      }
    }
    result[i]=(t == null) ? new TypeReference[0] : new TypeReference[]{t};
  }
  return result;
}","/** 
 * @param method
 */
protected TypeReference[][] makeParameterTypes(IMethod method){
  TypeReference[][] result=new TypeReference[method.getNumberOfParameters()][];
  for (int i=0; i < result.length; i++) {
    TypeReference t=method.getParameterType(i);
    if (!t.isPrimitiveType()) {
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        t=null;
      }
 else       if (klass.isAbstract()) {
        t=chooseAConcreteSubClass(klass);
      }
 else       if (klass.isInterface()) {
        t=chooseAnImplementor(klass);
      }
 else       if (klass.isArrayClass()) {
        ArrayClass arrayKlass=(ArrayClass)klass;
        IClass innermost=arrayKlass.getInnermostElementClass();
        if (innermost != null && innermost.isInterface()) {
          TypeReference impl=chooseAnImplementor(innermost);
          if (impl == null) {
            t=null;
          }
 else {
            t=TypeReference.findOrCreateArrayOf(impl);
            for (int dim=1; dim < arrayKlass.getDimensionality(); dim++) {
              t=TypeReference.findOrCreateArrayOf(t);
            }
          }
        }
      }
    }
    result[i]=(t == null) ? new TypeReference[0] : new TypeReference[]{t};
  }
  return result;
}",0.9494097807757168
100398,"public TypeName getRawName(){
  String s=rawString().substring(0,rawString().length() - 1);
  s=s.replaceAll(""String_Node_Str"",""String_Node_Str"");
  return TypeName.string2TypeName(s);
}","/** 
 * Return the name of the raw type for this signature
 */
public TypeName getRawName(){
  StringBuffer s=new StringBuffer();
  StringTokenizer t=new StringTokenizer(rawString(),""String_Node_Str"");
  while (t.hasMoreTokens()) {
    String x=t.nextToken();
    s.append(x.replaceAll(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    if (t.hasMoreElements()) {
      s.append('$');
    }
  }
  return TypeName.string2TypeName(s.toString());
}",0.3922155688622754
100399,"/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'*':
{
  args.add(""String_Node_Str"");
  continue;
}
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}","/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'-':
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'*':
{
  args.add(""String_Node_Str"");
  continue;
}
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}",0.9949206349206348
100400,"public static void deleteContents(String directory) throws WalaException {
  Collection fl=listFiles(directory,null,true);
  for (Iterator it=fl.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    if (!f.isDirectory()) {
      f.delete();
    }
  }
  Collection f2=listFiles(directory,null,true);
  for (Iterator it=f2.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    f.delete();
  }
}","/** 
 * delete all files (recursively) in a directory. This is dangerous. Use with care.
 */
public static void deleteContents(String directory) throws WalaException {
  Collection fl=listFiles(directory,null,true);
  for (Iterator it=fl.iterator(); it.hasNext(); ) {
    File f=(File)it.next();
    if (!f.isDirectory()) {
      f.delete();
    }
  }
  do {
    Collection f2=listFiles(directory,null,true);
    for (Iterator it=f2.iterator(); it.hasNext(); ) {
      File f=(File)it.next();
      f.delete();
    }
  }
 while (listFiles(directory,null,true).size() > 0);
}",0.8065173116089613
100401,"public ExplodedSupergraph(ISupergraph<T,?> supergraph,IFlowFunctionMap flowFunctions){
  this.supergraph=supergraph;
  this.flowFunctions=flowFunctions;
}","public ExplodedSupergraph(ISupergraph<T,?> supergraph,IFlowFunctionMap<T> flowFunctions){
  this.supergraph=supergraph;
  this.flowFunctions=flowFunctions;
}",0.990353697749196
100402,"public Iterator<ExplodedSupergraphNode<T>> getPredNodes(ExplodedSupergraphNode<T> node){
  T dest=node.getSupergraphNode();
  HashSet<ExplodedSupergraphNode<T>> result=HashSetFactory.make(supergraph.getPredNodeCount(dest));
  for (Iterator<? extends T> it=supergraph.getPredNodes(dest); it.hasNext(); ) {
    T src=it.next();
    if (supergraph.classifyEdge(src,dest) != ISupergraph.RETURN_EDGE) {
      IFlowFunction f=getFlowFunction(src,dest);
      if (f instanceof IReversibleFlowFunction) {
        IReversibleFlowFunction rf=(IReversibleFlowFunction)f;
        IntSet sources=rf.getSources(node.getFact());
        if (sources != null) {
          for (IntIterator ii=sources.intIterator(); ii.hasNext(); ) {
            int t=ii.next();
            result.add(new ExplodedSupergraphNode<T>(src,t));
          }
        }
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"" + f.getClass());
      }
    }
 else {
      for (Iterator it2=supergraph.getCallSites(dest); it2.hasNext(); ) {
        Object callBlock=it2.next();
        IFlowFunction f=flowFunctions.getReturnFlowFunction(callBlock,src,dest);
        if (f instanceof IReversibleFlowFunction) {
          IReversibleFlowFunction rf=(IReversibleFlowFunction)f;
          IntSet sources=rf.getSources(node.getFact());
          if (sources != null) {
            for (IntIterator ii=sources.intIterator(); ii.hasNext(); ) {
              int t=ii.next();
              result.add(new ExplodedSupergraphNode<T>(src,t));
            }
          }
        }
 else {
          Assertions.UNREACHABLE(""String_Node_Str"" + f.getClass());
        }
      }
    }
  }
  return result.iterator();
}","public Iterator<ExplodedSupergraphNode<T>> getPredNodes(ExplodedSupergraphNode<T> node){
  T dest=node.getSupergraphNode();
  HashSet<ExplodedSupergraphNode<T>> result=HashSetFactory.make(supergraph.getPredNodeCount(dest));
  for (Iterator<? extends T> it=supergraph.getPredNodes(dest); it.hasNext(); ) {
    T src=it.next();
    if (supergraph.classifyEdge(src,dest) != ISupergraph.RETURN_EDGE) {
      IFlowFunction f=getFlowFunction(src,dest);
      if (f instanceof IReversibleFlowFunction) {
        IReversibleFlowFunction rf=(IReversibleFlowFunction)f;
        IntSet sources=rf.getSources(node.getFact());
        if (sources != null) {
          for (IntIterator ii=sources.intIterator(); ii.hasNext(); ) {
            int t=ii.next();
            result.add(new ExplodedSupergraphNode<T>(src,t));
          }
        }
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"" + f.getClass());
      }
    }
 else {
      for (Iterator<? extends T> it2=supergraph.getCallSites(dest); it2.hasNext(); ) {
        T callBlock=it2.next();
        IFlowFunction f=flowFunctions.getReturnFlowFunction(callBlock,src,dest);
        if (f instanceof IReversibleFlowFunction) {
          IReversibleFlowFunction rf=(IReversibleFlowFunction)f;
          IntSet sources=rf.getSources(node.getFact());
          if (sources != null) {
            for (IntIterator ii=sources.intIterator(); ii.hasNext(); ) {
              int t=ii.next();
              result.add(new ExplodedSupergraphNode<T>(src,t));
            }
          }
        }
 else {
          Assertions.UNREACHABLE(""String_Node_Str"" + f.getClass());
        }
      }
    }
  }
  return result.iterator();
}",0.9940191387559808
100403,"public Iterator<ExplodedSupergraphNode<T>> getSuccNodes(ExplodedSupergraphNode<T> node){
  T src=node.getSupergraphNode();
  HashSet<ExplodedSupergraphNode<T>> result=HashSetFactory.make(supergraph.getSuccNodeCount(src));
  for (Iterator<? extends T> it=supergraph.getSuccNodes(src); it.hasNext(); ) {
    T dest=it.next();
    if (supergraph.classifyEdge(src,dest) != ISupergraph.RETURN_EDGE) {
      IUnaryFlowFunction f=(IUnaryFlowFunction)getFlowFunction(src,dest);
      IntSet targets=f.getTargets(node.getFact());
      if (targets != null) {
        for (IntIterator ii=targets.intIterator(); ii.hasNext(); ) {
          int t=ii.next();
          result.add(new ExplodedSupergraphNode<T>(dest,t));
        }
      }
    }
 else {
      for (Iterator it2=supergraph.getCallSites(dest); it2.hasNext(); ) {
        Object callBlock=it2.next();
        IUnaryFlowFunction f=(IUnaryFlowFunction)flowFunctions.getReturnFlowFunction(callBlock,src,dest);
        IntSet targets=f.getTargets(node.getFact());
        if (targets != null) {
          for (IntIterator ii=targets.intIterator(); ii.hasNext(); ) {
            int t=ii.next();
            result.add(new ExplodedSupergraphNode<T>(dest,t));
          }
        }
      }
    }
  }
  return result.iterator();
}","public Iterator<ExplodedSupergraphNode<T>> getSuccNodes(ExplodedSupergraphNode<T> node){
  T src=node.getSupergraphNode();
  HashSet<ExplodedSupergraphNode<T>> result=HashSetFactory.make(supergraph.getSuccNodeCount(src));
  for (Iterator<? extends T> it=supergraph.getSuccNodes(src); it.hasNext(); ) {
    T dest=it.next();
    if (supergraph.classifyEdge(src,dest) != ISupergraph.RETURN_EDGE) {
      IUnaryFlowFunction f=(IUnaryFlowFunction)getFlowFunction(src,dest);
      IntSet targets=f.getTargets(node.getFact());
      if (targets != null) {
        for (IntIterator ii=targets.intIterator(); ii.hasNext(); ) {
          int t=ii.next();
          result.add(new ExplodedSupergraphNode<T>(dest,t));
        }
      }
    }
 else {
      for (Iterator<? extends T> it2=supergraph.getCallSites(dest); it2.hasNext(); ) {
        T callBlock=it2.next();
        IUnaryFlowFunction f=(IUnaryFlowFunction)flowFunctions.getReturnFlowFunction(callBlock,src,dest);
        IntSet targets=f.getTargets(node.getFact());
        if (targets != null) {
          for (IntIterator ii=targets.intIterator(); ii.hasNext(); ) {
            int t=ii.next();
            result.add(new ExplodedSupergraphNode<T>(dest,t));
          }
        }
      }
    }
  }
  return result.iterator();
}",0.9921630094043888
100404,"/** 
 * @param supergraph
 * @param flowFunctions
 * @param solver
 */
public ExplodedSupergraphWithSummaryEdges(ISupergraph<T,?> supergraph,IFlowFunctionMap flowFunctions,TabulationSolver<T,?> solver){
  super(supergraph,flowFunctions);
  this.solver=solver;
}","/** 
 * @param supergraph
 * @param flowFunctions
 * @param solver
 */
public ExplodedSupergraphWithSummaryEdges(ISupergraph<T,?> supergraph,IFlowFunctionMap<T> flowFunctions,TabulationSolver<T,?> solver){
  super(supergraph,flowFunctions);
  this.solver=solver;
}",0.9942857142857144
100405,"/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call-to-return"" edge in the supergraphfrom src->dest, when the supergraph does not contain any callees of src. This happens via, e.g., slicing.
 */
public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Object src,Object dest);","/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call-to-return"" edge in the supergraphfrom src->dest, when the supergraph does not contain any callees of src. This happens via, e.g., slicing.
 */
public IUnaryFlowFunction getCallNoneToReturnFlowFunction(T src,T dest);",0.9593220338983052
100406,"/** 
 * @param call supergraph node of the call instruction for this return edge.
 * @param src
 * @param dest
 * @return the flow function for a ""return"" edge in the supergraph fromsrc->dest
 */
public IFlowFunction getReturnFlowFunction(Object call,Object src,Object dest);","/** 
 * @param call supergraph node of the call instruction for this return edge.
 * @param src
 * @param dest
 * @return the flow function for a ""return"" edge in the supergraph fromsrc->dest
 */
public IFlowFunction getReturnFlowFunction(T call,T src,T dest);",0.9607476635514018
100407,"/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call"" edge in the supergraph fromsrc->dest
 */
public IUnaryFlowFunction getCallFlowFunction(Object src,Object dest);","/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call"" edge in the supergraph fromsrc->dest
 */
public IUnaryFlowFunction getCallFlowFunction(T src,T dest);",0.9615384615384616
100408,"/** 
 * @param src
 * @param dest
 * @return the flow function for a ""normal"" edge in the supergraph fromsrc->dest
 */
public IUnaryFlowFunction getNormalFlowFunction(Object src,Object dest);","/** 
 * @param src
 * @param dest
 * @return the flow function for a ""normal"" edge in the supergraph fromsrc->dest
 */
public IUnaryFlowFunction getNormalFlowFunction(T src,T dest);",0.9623655913978496
100409,"/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call-to-return"" edge in the supergraphfrom src->dest
 */
public IUnaryFlowFunction getCallToReturnFlowFunction(Object src,Object dest);","/** 
 * @param src
 * @param dest
 * @return the flow function for a ""call-to-return"" edge in the supergraphfrom src->dest
 */
public IUnaryFlowFunction getCallToReturnFlowFunction(T src,T dest);",0.965
100410,"public static IdentityFlowFunctions singleton(){
  return SINGLETON;
}","@SuppressWarnings(""String_Node_Str"") public static <T>IdentityFlowFunctions<T> singleton(){
  return SINGLETON;
}",0.7650273224043715
100411,public IFlowFunctionMap getFunctionMap();,public IFlowFunctionMap<T> getFunctionMap();,0.9647058823529412
100412,"public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Object src,Object dest){
  Statement s=(Statement)src;
switch (s.getKind()) {
case NORMAL_RET_CALLER:
case PARAM_CALLER:
    return ReachabilityFunctions.killReachability;
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
  if (dest instanceof HeapStatement) {
    HeapStatement hd=(HeapStatement)dest;
    HeapStatement hs=(HeapStatement)src;
    if (hs.getLocation().equals(hd.getLocation())) {
      return IdentityFlowFunction.identity();
    }
 else {
      return ReachabilityFunctions.killReachability;
    }
  }
 else {
    return ReachabilityFunctions.killReachability;
  }
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}","public IUnaryFlowFunction getCallNoneToReturnFlowFunction(Statement src,Statement dest){
  Statement s=(Statement)src;
switch (s.getKind()) {
case NORMAL_RET_CALLER:
case PARAM_CALLER:
    return ReachabilityFunctions.killReachability;
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
  if (dest instanceof HeapStatement) {
    HeapStatement hd=(HeapStatement)dest;
    HeapStatement hs=(HeapStatement)src;
    if (hs.getLocation().equals(hd.getLocation())) {
      return IdentityFlowFunction.identity();
    }
 else {
      return ReachabilityFunctions.killReachability;
    }
  }
 else {
    return ReachabilityFunctions.killReachability;
  }
default :
Assertions.UNREACHABLE(s.getKind().toString());
return null;
}
}",0.9828947368421052
100413,"public IFlowFunction getReturnFlowFunction(Object call,Object src,Object dest){
  return ReachabilityFunctions.singleton().getReturnFlowFunction(call,src,dest);
}","public IFlowFunction getReturnFlowFunction(Statement call,Statement src,Statement dest){
  return ReachabilityFunctions.singleton().getReturnFlowFunction(call,src,dest);
}",0.9009009009009008
100414,"public IUnaryFlowFunction getCallFlowFunction(Object src,Object dest){
  return ReachabilityFunctions.singleton().getCallFlowFunction(src,dest);
}","public IUnaryFlowFunction getCallFlowFunction(Statement src,Statement dest){
  return ReachabilityFunctions.singleton().getCallFlowFunction(src,dest);
}",0.9261744966442952
100415,"public IUnaryFlowFunction getNormalFlowFunction(Object src,Object dest){
  return ReachabilityFunctions.singleton().getNormalFlowFunction(src,dest);
}","public IUnaryFlowFunction getNormalFlowFunction(Statement src,Statement dest){
  return ReachabilityFunctions.singleton().getNormalFlowFunction(src,dest);
}",0.9281045751633988
100416,"public IUnaryFlowFunction getCallToReturnFlowFunction(Object src,Object dest){
  return ReachabilityFunctions.singleton().getCallToReturnFlowFunction(src,dest);
}","public IUnaryFlowFunction getCallToReturnFlowFunction(Statement src,Statement dest){
  return ReachabilityFunctions.singleton().getCallToReturnFlowFunction(src,dest);
}",0.9333333333333332
100417,"public IFlowFunctionMap getFunctionMap(){
  return f;
}","public IFlowFunctionMap<Statement> getFunctionMap(){
  return f;
}",0.9090909090909092
100418,"/** 
 * Method newPhi.
 * @param rhs
 * @return int
 */
public int newPhi(int[] rhs){
  int result=getNewValueNumber();
  SSAPhiInstruction phi=new SSAPhiInstruction(result,(int[])rhs.clone());
  values[result]=new PhiValue(phi);
  return result;
}","/** 
 * Method newPhi.
 * @param rhs
 * @return int
 */
public int newPhi(int[] rhs) throws IllegalArgumentException {
  int result=getNewValueNumber();
  SSAPhiInstruction phi=new SSAPhiInstruction(result,(int[])rhs.clone());
  values[result]=new PhiValue(phi);
  return result;
}",0.9376181474480152
100419,"public static IWorkspace getWorkspace(){
  return ResourcesPlugin.getWorkspace();
}","/** 
 * @return null if there's a problem
 */
public static IWorkspace getWorkspace(){
  try {
    return ResourcesPlugin.getWorkspace();
  }
 catch (  Throwable t) {
    return null;
  }
}",0.6102941176470589
100420,"@SuppressWarnings(""String_Node_Str"") private static ECallGraph loadFromFile(String fileName,ClassLoader loader){
  Resource r=new XMIResourceImpl(URI.createURI(fileName));
  XMLResource.XMLMap xmlMap=new XMLMapImpl();
  xmlMap.setNoNamespacePackage(CallGraphPackage.eINSTANCE);
  Map<String,XMLMap> options=new HashMap<String,XMLMap>();
  options.put(XMLResource.OPTION_XML_MAP,xmlMap);
  try {
    r.load(options);
  }
 catch (  IOException e) {
    InputStream s=loader.getResourceAsStream(fileName);
    Assertions.productionAssertion(s != null,""String_Node_Str"" + fileName);
    ResourceSet resSet=new ResourceSetImpl();
    r=resSet.createResource(URI.createURI(""String_Node_Str""));
    options=new HashMap<String,XMLMap>();
    try {
      r.load(s,options);
    }
 catch (    IOException e2) {
      e2.printStackTrace();
      Assertions.UNREACHABLE(""String_Node_Str"" + fileName);
    }
  }
  EList contents=r.getContents();
  for (Iterator<EObject> it=contents.iterator(); it.hasNext(); ) {
    Object o=it.next();
    if (o instanceof ECallGraph) {
      return (ECallGraph)o;
    }
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") private static ECallGraph loadFromFile(String fileName,ClassLoader loader) throws IllegalArgumentException {
  Resource r=new XMIResourceImpl(URI.createURI(fileName));
  XMLResource.XMLMap xmlMap=new XMLMapImpl();
  xmlMap.setNoNamespacePackage(CallGraphPackage.eINSTANCE);
  Map<String,XMLMap> options=new HashMap<String,XMLMap>();
  options.put(XMLResource.OPTION_XML_MAP,xmlMap);
  try {
    r.load(options);
  }
 catch (  IOException e) {
    InputStream s=loader.getResourceAsStream(fileName);
    if (s == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + fileName);
    }
    ResourceSet resSet=new ResourceSetImpl();
    r=resSet.createResource(URI.createURI(""String_Node_Str""));
    options=new HashMap<String,XMLMap>();
    try {
      r.load(s,options);
    }
 catch (    IOException e2) {
      e2.printStackTrace();
      Assertions.UNREACHABLE(""String_Node_Str"" + fileName);
    }
  }
  EList contents=r.getContents();
  for (Iterator<EObject> it=contents.iterator(); it.hasNext(); ) {
    Object o=it.next();
    if (o instanceof ECallGraph) {
      return (ECallGraph)o;
    }
  }
  return null;
}",0.9281332164767748
100421,"@SuppressWarnings(""String_Node_Str"") public static ECallGraphWrapper load(String fileName,ClassLoader loader){
  ECallGraph G=loadFromFile(fileName,loader);
  Assertions.productionAssertion(G != null);
  ECallGraphWrapper result=new ECallGraphWrapper();
  for (Iterator<EPair> it=G.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator<EPair> it=G.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}","@SuppressWarnings(""String_Node_Str"") public static ECallGraphWrapper load(String fileName,ClassLoader loader) throws IllegalArgumentException {
  ECallGraph G=loadFromFile(fileName,loader);
  Assertions.productionAssertion(G != null);
  ECallGraphWrapper result=new ECallGraphWrapper();
  for (Iterator<EPair> it=G.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator<EPair> it=G.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}",0.9702970297029704
100422,"/** 
 * @param o an EClassHierarchy
 * @return a ClassHierarchy populated according to the contents of o
 */
@SuppressWarnings(""String_Node_Str"") public static EClassHierarchyWrapper load(EObject o){
  EClassHierarchy cha=(EClassHierarchy)o;
  Assertions.productionAssertion(cha != null);
  EClassHierarchyWrapper result=new EClassHierarchyWrapper();
  for (Iterator<EObject> it=cha.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator it=cha.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=(EPair)it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}","/** 
 * @param o an EClassHierarchy
 * @return a ClassHierarchy populated according to the contents of o
 */
@SuppressWarnings(""String_Node_Str"") public static EClassHierarchyWrapper load(EClassHierarchy cha){
  Assertions.productionAssertion(cha != null);
  EClassHierarchyWrapper result=new EClassHierarchyWrapper();
  for (Iterator<EObject> it=cha.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator it=cha.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=(EPair)it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}",0.3498402555910543
100423,"/** 
 * TODO: refactor
 */
@SuppressWarnings(""String_Node_Str"") public static EInterfaceHierarchyWrapper load(EObject o){
  EInterfaceHierarchy h=(EInterfaceHierarchy)o;
  Assertions.productionAssertion(h != null);
  EInterfaceHierarchyWrapper result=new EInterfaceHierarchyWrapper();
  for (Iterator<EObject> it=h.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator it=h.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=(EPair)it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}","/** 
 * TODO: refactor
 */
@SuppressWarnings(""String_Node_Str"") public static EInterfaceHierarchyWrapper load(EInterfaceHierarchy h){
  Assertions.productionAssertion(h != null);
  EInterfaceHierarchyWrapper result=new EInterfaceHierarchyWrapper();
  for (Iterator<EObject> it=h.getNodes().getContents().iterator(); it.hasNext(); ) {
    result.addNode(it.next());
  }
  for (Iterator it=h.getEdges().getContents().iterator(); it.hasNext(); ) {
    EPair p=(EPair)it.next();
    result.addEdge(p.getX(),p.getY());
  }
  return result;
}",0.2563176895306859
100424,"/** 
 * @param xmlFile an xml file
 * @return List<EObject> serialized in said file.
 */
public static List<EObject> readEObjects(String xmlFile,ClassLoader loader){
}","/** 
 * @param xmlFile an xml file
 * @return List<EObject> serialized in said file.
 */
public static List<EObject> readEObjects(String xmlFile,ClassLoader loader) throws WalaException {
  URL url=loader.getResource(xmlFile);
  URI fileURI=null;
  if (url != null) {
    fileURI=URI.createURI(url.toString());
  }
 else {
    fileURI=URI.createFileURI(xmlFile);
  }
  URIConverter converter=getURIConverter();
  ResourceSet resourceSet=new ResourceSetImpl();
  resourceSet.setURIConverter(converter);
  Resource resource=resourceSet.createResource(fileURI);
  try {
    resource.load(null);
  }
 catch (  IOException e) {
    throw new WalaException(""String_Node_Str"" + xmlFile + ""String_Node_Str"",e);
  }
  return resource.getContents();
}",0.36784140969163
100425,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAComparisonInstruction(opcode,defs == null || defs.length == 0 ? result : defs[0],uses == null ? val1 : uses[0],uses == null ? val2 : uses[1]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAComparisonInstruction(opcode,defs == null || defs.length == 0 ? result : defs[0],uses == null || uses.length == 0 ? val1 : uses[0],uses == null ? val2 : uses[1]);
}",0.9559471365638766
100426,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAGetCaughtExceptionInstruction(bbNumber,defs == null ? exceptionValueNumber : defs[0]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAGetCaughtExceptionInstruction(bbNumber,defs == null || defs.length == 0 ? exceptionValueNumber : defs[0]);
}",0.9415204678362572
100427,"/** 
 * Method getUse.
 * @param j
 * @return value number representing the jth use in this instruction. -1 meansTOP (i.e., the value doesn't matter)
 */
public int getUse(int j){
  Assertions.UNREACHABLE();
  return -1;
}","/** 
 * Method getUse.
 * @param j
 * @return value number representing the jth use in this instruction. -1 meansTOP (i.e., the value doesn't matter)
 */
public int getUse(int j) throws UnsupportedOperationException {
  throw new UnsupportedOperationException();
}",0.7736625514403292
100428,"public String getJavaLibraryVersion(){
  JarFile rtJar=getRtJar();
  Assertions._assert(rtJar != null,""String_Node_Str"");
  try {
    Manifest man=rtJar.getManifest();
    Assertions._assert(man != null,""String_Node_Str"");
    String result=man.getMainAttributes().getValue(""String_Node_Str"");
    if (result == null) {
      Attributes att=man.getMainAttributes();
      System.err.println(""String_Node_Str"" + att);
      Assertions.UNREACHABLE(""String_Node_Str"" + rtJar.getName() + ""String_Node_Str"");
    }
    return result;
  }
 catch (  java.io.IOException e) {
    Assertions.UNREACHABLE(""String_Node_Str"");
    return null;
  }
}","public String getJavaLibraryVersion() throws IllegalStateException {
  JarFile rtJar=getRtJar();
  if (rtJar == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    Manifest man=rtJar.getManifest();
    Assertions._assert(man != null,""String_Node_Str"");
    String result=man.getMainAttributes().getValue(""String_Node_Str"");
    if (result == null) {
      Attributes att=man.getMainAttributes();
      System.err.println(""String_Node_Str"" + att);
      Assertions.UNREACHABLE(""String_Node_Str"" + rtJar.getName() + ""String_Node_Str"");
    }
    return result;
  }
 catch (  java.io.IOException e) {
    Assertions.UNREACHABLE(""String_Node_Str"");
    return null;
  }
}",0.9174174174174174
100429,"public boolean isJava15Libraries(){
  return getJavaLibraryVersion().startsWith(""String_Node_Str"");
}","public boolean isJava15Libraries() throws IllegalStateException {
  return getJavaLibraryVersion().startsWith(""String_Node_Str"");
}",0.8706896551724138
100430,"/** 
 * @return the ClassLoaderReference specified by <code>name</code>.
 */
public ClassLoaderReference getLoader(Atom name){
  if (Assertions.verifyAssertions) {
    if (name.getVal(0) > 'Z') {
      Assertions._assert(name.getVal(0) <= 'Z',""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  return loadersByName.get(name);
}","/** 
 * @return the ClassLoaderReference specified by <code>name</code>.
 */
public ClassLoaderReference getLoader(Atom name) throws IllegalArgumentException {
  if (name.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (Assertions.verifyAssertions) {
    if (name.getVal(0) > 'Z') {
      Assertions._assert(name.getVal(0) <= 'Z',""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  return loadersByName.get(name);
}",0.8438287153652393
100431,"public boolean isJava14Libraries(){
  return getJavaLibraryVersion().startsWith(""String_Node_Str"");
}","public boolean isJava14Libraries() throws IllegalStateException {
  return getJavaLibraryVersion().startsWith(""String_Node_Str"");
}",0.8706896551724138
100432,"/** 
 * build a constraint saying v \in s
 */
public static IFormula makeSetConstraint(Variable v,IntSet s){
  IntIterator it=s.intIterator();
  int first=it.next();
  IFormula result=RelationFormula.makeEquals(v,first);
  while (it.hasNext()) {
    int i=it.next();
    result=BinaryFormula.or(result,RelationFormula.makeEquals(v,i));
  }
  return result;
}","/** 
 * build a constraint saying v \in s
 */
public static IFormula makeSetConstraint(Variable v,IntSet s){
  if (s.isEmpty()) {
    return RelationFormula.makeEquals(IntConstant.make(0),IntConstant.make(1));
  }
  IntIterator it=s.intIterator();
  int first=it.next();
  IFormula result=RelationFormula.makeEquals(v,first);
  while (it.hasNext()) {
    int i=it.next();
    result=BinaryFormula.or(result,RelationFormula.makeEquals(v,i));
  }
  return result;
}",0.8721071863580999
100433,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAComparisonInstruction(opcode,defs == null || defs.length == 0 ? result : defs[0],uses == null || uses.length == 0 ? val1 : uses[0],uses == null ? val2 : uses[1]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses) throws IllegalArgumentException {
  if (uses != null && uses.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + uses.length);
  }
  return new SSAComparisonInstruction(opcode,defs == null || defs.length == 0 ? result : defs[0],uses == null ? val1 : uses[0],uses == null ? val2 : uses[1]);
}",0.7161716171617162
100434,"public SSAPhiInstruction(int result,int[] params){
  super();
  this.result=result;
  this.params=params;
}","public SSAPhiInstruction(int result,int[] params) throws IllegalArgumentException {
  super();
  this.result=result;
  this.params=params;
  if (params.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6331360946745562
100435,"/** 
 * Note: names for class loader references must be unique.
 * @see java.lang.Object#equals(Object)
 */
public boolean equals(Object obj){
  if (Assertions.verifyAssertions) {
    Assertions._assert(this.getClass().equals(obj.getClass()));
  }
  ClassLoaderReference o=(ClassLoaderReference)obj;
  return name.equals(o.name);
}","/** 
 * Note: names for class loader references must be unique.
 * @see java.lang.Object#equals(Object)
 */
public boolean equals(Object obj){
  if (!getClass().equals(obj.getClass())) {
    return false;
  }
 else {
    ClassLoaderReference o=(ClassLoaderReference)obj;
    return name.equals(o.name);
  }
}",0.5446009389671361
100436,"public static TypeSignature make(String s){
  assert(s.length() > 0);
switch (s.charAt(0)) {
case TypeReference.VoidTypeCode:
    Assertions.UNREACHABLE();
  return null;
case TypeReference.BooleanTypeCode:
return BaseType.BOOLEAN;
case TypeReference.ByteTypeCode:
return BaseType.BYTE;
case TypeReference.ShortTypeCode:
return BaseType.SHORT;
case TypeReference.IntTypeCode:
return BaseType.INT;
case TypeReference.LongTypeCode:
return BaseType.LONG;
case TypeReference.FloatTypeCode:
return BaseType.FLOAT;
case TypeReference.DoubleTypeCode:
return BaseType.DOUBLE;
case TypeReference.CharTypeCode:
return BaseType.CHAR;
case 'L':
return ClassTypeSignature.makeClassTypeSig(s);
case 'T':
return TypeVariableSignature.make(s);
case TypeReference.ArrayTypeCode:
return ArrayTypeSignature.make(s);
default :
Assertions.UNREACHABLE(s);
return null;
}
}","public static TypeSignature make(String s) throws IllegalArgumentException {
  assert(s.length() > 0);
switch (s.charAt(0)) {
case TypeReference.VoidTypeCode:
    Assertions.UNREACHABLE();
  return null;
case TypeReference.BooleanTypeCode:
return BaseType.BOOLEAN;
case TypeReference.ByteTypeCode:
return BaseType.BYTE;
case TypeReference.ShortTypeCode:
return BaseType.SHORT;
case TypeReference.IntTypeCode:
return BaseType.INT;
case TypeReference.LongTypeCode:
return BaseType.LONG;
case TypeReference.FloatTypeCode:
return BaseType.FLOAT;
case TypeReference.DoubleTypeCode:
return BaseType.DOUBLE;
case TypeReference.CharTypeCode:
return BaseType.CHAR;
case 'L':
return ClassTypeSignature.makeClassTypeSig(s);
case 'T':
return TypeVariableSignature.make(s);
case TypeReference.ArrayTypeCode:
return ArrayTypeSignature.make(s);
default :
throw new IllegalArgumentException(""String_Node_Str"" + s);
}
}",0.930365296803653
100437,"/** 
 * @param typeSigs Strin TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeSignatures(String typeSigs){
  ArrayList<String> sigs=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeSigs.charAt(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName.toString());
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName.toString());
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName.toString());
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName.toString());
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName.toString());
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName.toString());
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName.toString());
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName.toString());
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName.toString());
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case TypeReference.ArrayTypeCode:
{
switch (typeSigs.charAt(i)) {
case TypeReference.BooleanTypeCode:
case TypeReference.ByteTypeCode:
case TypeReference.IntTypeCode:
sigs.add(typeSigs.substring(i - 1,i + 1));
break;
case 'T':
case TypeReference.ClassTypeCode:
int off=i - 1;
i++;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
break;
default :
Assertions.UNREACHABLE(""String_Node_Str"" + typeSigs.charAt(i));
}
continue;
}
case (byte)'T':
{
int off=i - 1;
while (typeSigs.charAt(i++) != ';') ;
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<String> it=sigs.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeSigs);
}
}
}
}","/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeSignatures(String typeSigs) throws IllegalArgumentException {
  ArrayList<String> sigs=new ArrayList<String>(10);
  if (typeSigs.length() < 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + typeSigs);
  }
  int i=1;
  while (true) {
switch (typeSigs.charAt(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName.toString());
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName.toString());
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName.toString());
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName.toString());
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName.toString());
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName.toString());
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName.toString());
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName.toString());
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName.toString());
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case TypeReference.ArrayTypeCode:
{
switch (typeSigs.charAt(i)) {
case TypeReference.BooleanTypeCode:
case TypeReference.ByteTypeCode:
case TypeReference.IntTypeCode:
sigs.add(typeSigs.substring(i - 1,i + 1));
break;
case 'T':
case TypeReference.ClassTypeCode:
int off=i - 1;
i++;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
break;
default :
Assertions.UNREACHABLE(""String_Node_Str"" + typeSigs.charAt(i));
}
continue;
}
case (byte)'T':
{
int off=i - 1;
while (typeSigs.charAt(i++) != ';') ;
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<String> it=sigs.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeSigs);
}
}
}
}",0.9699624530663328
100438,"/** 
 * Is ""this"" atom a reserved member name? Note: Sun has reserved all member names starting with '<' for future use. At present, only <init> and <clinit> are used.
 */
public final boolean isReservedMemberName(){
  return val[0] == '<';
}","/** 
 * Is ""this"" atom a reserved member name? Note: Sun has reserved all member names starting with '<' for future use. At present, only <init> and <clinit> are used.
 */
public final boolean isReservedMemberName(){
  if (length() == 0) {
    return false;
  }
  return val[0] == '<';
}",0.9149338374291116
100439,"/** 
 * Parse ""this"" array descriptor to obtain number of dimensions in corresponding array type. this: descriptor - something like ""[Ljava/lang/String;"" or ""[[I""
 * @return dimensionality - something like ""1"" or ""2""
 */
public final int parseForArrayDimensionality(){
  for (int i=0; ; ++i)   if (val[i] != '[')   return i;
}","/** 
 * Parse ""this"" array descriptor to obtain number of dimensions in corresponding array type. this: descriptor - something like ""[Ljava/lang/String;"" or ""[[I""
 * @return dimensionality - something like ""1"" or ""2""
 */
public final int parseForArrayDimensionality() throws IllegalArgumentException {
  if (val.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int i=0; ; ++i) {
    if (val[i] != '[') {
      return i;
    }
  }
}",0.8221941992433796
100440,"public byte getVal(int i){
  return val[i];
}","/** 
 * @param i
 * @return
 */
public byte getVal(int i) throws IllegalArgumentException {
  try {
    return val[i];
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str""+ val.length);
  }
}",0.286624203821656
100441,"/** 
 * Is ""this"" atom a class descriptor?
 */
public final boolean isClassDescriptor(){
  return val[0] == 'L';
}","/** 
 * Is ""this"" atom a class descriptor?
 */
public final boolean isClassDescriptor(){
  if (length() == 0) {
    return false;
  }
  return val[0] == 'L';
}",0.8351648351648352
100442,"/** 
 * Parse ""this"" array descriptor to obtain descriptor for array's element type. this: array descriptor - something like ""[I""
 * @return array element descriptor - something like ""I""
 */
public final Atom parseForArrayElementDescriptor(){
  return findOrCreate(val,1,val.length - 1);
}","/** 
 * Parse ""this"" array descriptor to obtain descriptor for array's element type. this: array descriptor - something like ""[I""
 * @return array element descriptor - something like ""I""
 */
public final Atom parseForArrayElementDescriptor() throws IllegalArgumentException {
  if (val.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return findOrCreate(val,1,val.length - 1);
}",0.82689556509299
100443,"/** 
 * Is ""this"" atom a method descriptor?
 */
public final boolean isMethodDescriptor(){
  return val[0] == '(';
}","/** 
 * Is ""this"" atom a method descriptor?
 */
public final boolean isMethodDescriptor() throws IllegalArgumentException {
  if (length() == 0) {
    return false;
  }
  return val[0] == '(';
}",0.7483870967741936
100444,"/** 
 * Return the innermost element type reference for an array
 */
public final Atom parseForInnermostArrayElementDescriptor(){
  int i=0;
  while (val[i] == '[') {
    i++;
  }
  return findOrCreate(val,i,val.length - i);
}","/** 
 * Return the innermost element type reference for an array
 */
public final Atom parseForInnermostArrayElementDescriptor() throws IllegalArgumentException {
  if (val.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int i=0;
  while (val[i] == '[') {
    i++;
  }
  return findOrCreate(val,i,val.length - i);
}",0.7888307155322862
100445,"public T next(){
  int i=numbers.next();
  T result=nodeManager.getNode(i);
  if (Assertions.verifyAssertions) {
    if (result == null) {
      Assertions._assert(result != null,""String_Node_Str"" + i);
    }
  }
  return result;
}","public T next() throws NoSuchElementException {
  int i=numbers.next();
  T result=nodeManager.getNode(i);
  if (Assertions.verifyAssertions) {
    if (result == null) {
      Assertions._assert(result != null,""String_Node_Str"" + i);
    }
  }
  return result;
}",0.9371196754563894
100446,"public Instruction redirectTargets(int[] targetMap){
  return make(targetMap[label[0]]);
}","public Instruction redirectTargets(int[] targetMap) throws IllegalArgumentException {
  try {
    return make(targetMap[label[0]]);
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
}",0.5325443786982249
100447,"public Instruction redirectTargets(int[] targetMap){
  int[] cs=new int[casesAndLabels.length];
  for (int i=0; i < cs.length; i+=2) {
    cs[i]=casesAndLabels[i];
    cs[i + 1]=targetMap[casesAndLabels[i + 1]];
  }
  return make(cs,targetMap[defaultLabel]);
}","public Instruction redirectTargets(int[] targetMap) throws IllegalArgumentException {
  try {
    int[] cs=new int[casesAndLabels.length];
    for (int i=0; i < cs.length; i+=2) {
      cs[i]=casesAndLabels[i];
      cs[i + 1]=targetMap[casesAndLabels[i + 1]];
    }
    return make(cs,targetMap[defaultLabel]);
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
}",0.7558139534883721
100448,"public TypeArgument[] getTypeArguments(){
  if (rawString().indexOf('<') == -1) {
    return null;
  }
 else {
    int start=rawString().indexOf('<');
    int end=endOfTypeArguments();
    return TypeArgument.make(rawString().substring(start,end));
  }
}","public TypeArgument[] getTypeArguments(){
  int lastDot=rawString().lastIndexOf('.');
  if (rawString().indexOf('<',lastDot) == -1) {
    return null;
  }
 else {
    int start=rawString().indexOf('<',lastDot);
    int end=endOfTypeArguments();
    return TypeArgument.make(rawString().substring(start,end));
  }
}",0.8802816901408451
100449,"private int endOfTypeArguments(){
  int i=rawString().indexOf('<') + 1;
  assert(i > 0);
  int depth=1;
  while (depth > 0) {
    if (rawString().charAt(i) == '>') {
      depth--;
    }
    if (rawString().charAt(i) == '<') {
      depth++;
    }
    i++;
  }
  return i;
}","private int endOfTypeArguments(){
  int lastDot=rawString().lastIndexOf('.');
  int i=rawString().indexOf('<',lastDot) + 1;
  assert(i > 0);
  int depth=1;
  while (depth > 0) {
    if (rawString().charAt(i) == '>') {
      depth--;
    }
    if (rawString().charAt(i) == '<') {
      depth++;
    }
    i++;
  }
  return i;
}",0.9066666666666666
100450,"private static TypeArgument makeTypeArgument(String s){
switch (s.charAt(0)) {
case '*':
    return WILDCARD;
case '+':
case '-':
  Assertions.UNREACHABLE();
return null;
default :
TypeSignature sig=TypeSignature.make(s);
return new TypeArgument(sig);
}
}","private static TypeArgument makeTypeArgument(String s){
switch (s.charAt(0)) {
case '*':
    return WILDCARD;
case '+':
{
    TypeSignature sig=TypeSignature.make(s.substring(1));
    return new TypeArgument(sig,WildcardIndicator.PLUS);
  }
case '-':
{
  TypeSignature sig=TypeSignature.make(s.substring(1));
  return new TypeArgument(sig,WildcardIndicator.MINUS);
}
default :
TypeSignature sig=TypeSignature.make(s);
return new TypeArgument(sig,null);
}
}",0.3994374120956399
100451,"/** 
 * @param typeSigs Strin TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}","/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}",0.9926617745163442
100452,"private TypeArgument(TypeSignature sig){
  super(sig.rawString());
  this.sig=sig;
}","private TypeArgument(TypeSignature sig,WildcardIndicator w){
  super(sig.rawString());
  this.sig=sig;
  this.w=w;
}",0.84
100453,"/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}","/** 
 * @param typeSigs TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeArguments(String typeArgs){
  ArrayList<String> args=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeArgs.charAt(i++)) {
case TypeReference.ClassTypeCode:
{
        int off=i - 1;
        int depth=0;
        while (typeArgs.charAt(i++) != ';' || depth > 0) {
          if (typeArgs.charAt(i - 1) == '<') {
            depth++;
          }
          if (typeArgs.charAt(i - 1) == '>') {
            depth--;
          }
        }
        args.add(typeArgs.substring(off,i));
        continue;
      }
case TypeReference.ArrayTypeCode:
{
      int off=i - 1;
      while (typeArgs.charAt(i) == TypeReference.ArrayTypeCode) {
        ++i;
      }
      if (typeArgs.charAt(i++) == TypeReference.ClassTypeCode) {
        while (typeArgs.charAt(i++) != ';')         ;
        args.add(typeArgs.substring(off,i - off - 1));
      }
 else {
        args.add(typeArgs.substring(off,i - off));
      }
      continue;
    }
case (byte)'+':
case (byte)'T':
{
    int off=i - 1;
    while (typeArgs.charAt(i++) != ';')     ;
    args.add(typeArgs.substring(off,i));
    continue;
  }
case (byte)'*':
{
  args.add(""String_Node_Str"");
  continue;
}
case (byte)'>':
int size=args.size();
if (size == 0) {
return null;
}
Iterator<String> it=args.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeArgs);
}
}
}
}",0.9794855096059916
100454,"public boolean isReturn(Statement n){
switch (n.getKind()) {
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case HEAP_RET_CALLER:
    return true;
case EXC_RET_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case NORMAL:
case NORMAL_RET_CALLEE:
case PARAM_CALLEE:
case PARAM_CALLER:
case PHI:
case PI:
case METHOD_ENTRY:
  return false;
default :
Assertions.UNREACHABLE(n.getKind().toString());
return false;
}
}","public boolean isReturn(Statement n){
switch (n.getKind()) {
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case HEAP_RET_CALLER:
    return true;
case EXC_RET_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case NORMAL:
case NORMAL_RET_CALLEE:
case PARAM_CALLEE:
case PARAM_CALLER:
case PHI:
case PI:
case METHOD_ENTRY:
case CATCH:
  return false;
default :
Assertions.UNREACHABLE(n.getKind().toString());
return false;
}
}",0.9865470852017936
100455,"public boolean isEntry(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
    return true;
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case NORMAL_RET_CALLEE:
  return false;
default :
Assertions.UNREACHABLE();
return false;
}
}","public boolean isEntry(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
    return true;
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case NORMAL_RET_CALLEE:
case CATCH:
  return false;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}",0.972027972027972
100456,"public boolean isCall(Statement n){
switch (n.getKind()) {
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case HEAP_PARAM_CALLEE:
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PHI:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
    return false;
case HEAP_PARAM_CALLER:
case PARAM_CALLER:
  return true;
case NORMAL:
if (sdg.getCOptions().equals(ControlDependenceOptions.NONE)) {
  return false;
}
 else {
  NormalStatement s=(NormalStatement)n;
  return s.getInstruction() instanceof SSAAbstractInvokeInstruction;
}
default :
Assertions.UNREACHABLE();
return false;
}
}","public boolean isCall(Statement n){
switch (n.getKind()) {
case EXC_RET_CALLEE:
case EXC_RET_CALLER:
case HEAP_PARAM_CALLEE:
case NORMAL_RET_CALLEE:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case PHI:
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
    return false;
case HEAP_PARAM_CALLER:
case PARAM_CALLER:
  return true;
case NORMAL:
if (sdg.getCOptions().equals(ControlDependenceOptions.NONE)) {
  return false;
}
 else {
  NormalStatement s=(NormalStatement)n;
  return s.getInstruction() instanceof SSAAbstractInvokeInstruction;
}
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}",0.9743164871582436
100457,"public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case PHI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
  return true;
default :
Assertions.UNREACHABLE();
return false;
}
}","public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case PHI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
case METHOD_ENTRY:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
  return true;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}",0.9591567852437418
100458,"/** 
 * @param s a string that holds a sequence of formal type parameters beginningat index begin
 * @return the index where the next formal type parameter ends (actually, end +1)
 */
static int formalTypeParameterEnds(String s,int begin){
  int result=begin;
  while (s.charAt(result) != ':') {
    result++;
  }
  do {
    assert(s.charAt(result) == ':');
switch (s.charAt(++result)) {
case TypeReference.ClassTypeCode:
{
        while (s.charAt(result++) != ';')         ;
        break;
      }
case ':':
    break;
default :
  if (Assertions.verifyAssertions) {
    Assertions._assert(false,""String_Node_Str"" + s + ""String_Node_Str""+ (result - 1));
  }
}
}
 while (s.charAt(result) == ':');
return result;
}","/** 
 * @param s a string that holds a sequence of formal type parameters beginningat index begin
 * @return the index where the next formal type parameter ends (actually, end +1)
 */
static int formalTypeParameterEnds(String s,int begin){
  int result=begin;
  while (s.charAt(result) != ':') {
    result++;
  }
  do {
    assert(s.charAt(result) == ':');
switch (s.charAt(++result)) {
case TypeReference.ClassTypeCode:
{
        int depth=0;
        while (s.charAt(result) != ';' || depth > 0) {
          if (s.charAt(result) == '<') {
            depth++;
          }
          if (s.charAt(result) == '>') {
            depth--;
          }
          result++;
        }
        result++;
        break;
      }
case ':':
    break;
default :
  if (Assertions.verifyAssertions) {
    Assertions._assert(false,""String_Node_Str"" + s + ""String_Node_Str""+ (result - 1));
  }
}
}
 while (s.charAt(result) == ':');
return result;
}",0.851581508515815
100459,"/** 
 * @param typeSigs Strin TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeSignatures(String typeSigs){
  ArrayList<String> sigs=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeSigs.charAt(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName.toString());
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName.toString());
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName.toString());
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName.toString());
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName.toString());
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName.toString());
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName.toString());
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName.toString());
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName.toString());
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case TypeReference.ArrayTypeCode:
{
int off=i - 1;
i++;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)'T':
{
int off=i - 1;
while (typeSigs.charAt(i++) != ';') ;
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<String> it=sigs.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeSigs);
}
}
}
}","/** 
 * @param typeSigs Strin TypeSignature
 * @return tokenize it
 */
static String[] parseForTypeSignatures(String typeSigs){
  ArrayList<String> sigs=new ArrayList<String>(10);
  int i=1;
  while (true) {
switch (typeSigs.charAt(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName.toString());
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName.toString());
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName.toString());
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName.toString());
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName.toString());
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName.toString());
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName.toString());
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName.toString());
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName.toString());
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
continue;
}
case TypeReference.ArrayTypeCode:
{
System.err.println(typeSigs + ""String_Node_Str"" + i);
switch (typeSigs.charAt(i)) {
case TypeReference.BooleanTypeCode:
case TypeReference.ByteTypeCode:
case TypeReference.IntTypeCode:
sigs.add(typeSigs.substring(i - 1,i + 1));
break;
case 'T':
case TypeReference.ClassTypeCode:
int off=i - 1;
i++;
int depth=0;
while (typeSigs.charAt(i++) != ';' || depth > 0) {
if (typeSigs.charAt(i - 1) == '<') {
depth++;
}
if (typeSigs.charAt(i - 1) == '>') {
depth--;
}
}
sigs.add(typeSigs.substring(off,i));
break;
default :
Assertions.UNREACHABLE(""String_Node_Str"" + typeSigs.charAt(i));
}
continue;
}
case (byte)'T':
{
int off=i - 1;
while (typeSigs.charAt(i++) != ';') ;
sigs.add(typeSigs.substring(off,i));
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<String> it=sigs.iterator();
String[] result=new String[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + typeSigs);
}
}
}
}",0.9178765880217786
100460,"/** 
 * @param v
 * @param klass
 * @return -1 if there is no match
 */
public static int getTypeVariablePosition(TypeVariableSignature v,ShrikeClass klass){
  try {
    ClassSignature sig=klass.getClassSignature();
    if (sig == null) {
      return -1;
    }
    FormalTypeParameter[] fp=sig.getFormalTypeParameters();
    if (fp == null) {
      return -1;
    }
    for (int i=0; i < fp.length; i++) {
      FormalTypeParameter f=fp[i];
      if (f.getIdentifier().equals(v.getIdentifier())) {
        return i;
      }
    }
    Assertions.UNREACHABLE();
    return -1;
  }
 catch (  InvalidClassFileException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return -1;
  }
}","/** 
 * @param v
 * @param klass
 * @return -1 if there is no match
 */
public static int getTypeVariablePosition(TypeVariableSignature v,ShrikeClass klass){
  try {
    ClassSignature sig=klass.getClassSignature();
    if (sig == null) {
      return -1;
    }
    FormalTypeParameter[] fp=sig.getFormalTypeParameters();
    if (fp == null) {
      return -1;
    }
    for (int i=0; i < fp.length; i++) {
      FormalTypeParameter f=fp[i];
      if (f.getIdentifier().equals(v.getIdentifier())) {
        return i;
      }
    }
    return -1;
  }
 catch (  InvalidClassFileException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    return -1;
  }
}",0.8531571218795888
100461,"public int getMappedIndex(T o){
  return offset + delegate.getMappedIndex(o);
}","public int getMappedIndex(T o){
  if (delegate.getMappedIndex(o) == -1) {
    return -1;
  }
  return offset + delegate.getMappedIndex(o);
}",0.7214611872146118
100462,"private Set<ModuleEntry> getEntriesRecursive(File dir){
  Set<ModuleEntry> result=new HashSet<ModuleEntry>();
  File[] files=dir.listFiles();
  for (int i=0; i < files.length; i++) {
    if (files[i].isDirectory())     result.addAll(getEntriesRecursive(files[i]));
 else     if (includeFile(files[i]))     result.add(makeFile(files[i]));
  }
  return result;
}","private Set<ModuleEntry> getEntriesRecursive(File dir){
  Set<ModuleEntry> result=HashSetFactory.make();
  File[] files=dir.listFiles();
  if (files != null) {
    for (int i=0; i < files.length; i++) {
      if (files[i].isDirectory()) {
        result.addAll(getEntriesRecursive(files[i]));
      }
 else       if (includeFile(files[i])) {
        result.add(makeFile(files[i]));
      }
    }
  }
 else {
    Trace.println(""String_Node_Str"" + dir);
  }
  return result;
}",0.7697841726618705
100463,"DirectoryTreeModule(File root){
  this.root=root;
}","/** 
 * @param root a directory
 */
DirectoryTreeModule(File root){
}",0.55
100464,"public void bar() throws BadLanguageExceptionEx1 {
  throw new BadLanguageExceptionEx1();
}","public void bar(){
  throw new NullPointerException();
}",0.6394557823129252
100465,"public static void main(String[] args){
  Exception1 e1=new Exception1();
  try {
    FooEx1 f=new FooEx1();
    f.bar();
  }
 catch (  BadLanguageExceptionEx1 e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  Exception1 e1=new Exception1();
  try {
    FooEx1 f=new FooEx1();
    f.bar();
  }
 catch (  BadLanguageExceptionEx1 e) {
    e.printStackTrace();
  }
  try {
    FooEx2 f=new FooEx2();
    f.bar();
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}",0.782258064516129
100466,"private void setCatchInstructions(SSACFG ssacfg,AbstractCFG oldcfg){
  for (int i=0; i < oldcfg.getNumberOfNodes(); i++)   if (oldcfg.isCatchBlock(i)) {
    ExceptionHandlerBasicBlock B=(ExceptionHandlerBasicBlock)ssacfg.getNode(i);
    B.setCatchInstruction((SSAGetCaughtExceptionInstruction)getInstructions()[B.getFirstInstructionIndex()]);
  }
}","private void setCatchInstructions(SSACFG ssacfg,AbstractCFG oldcfg){
  for (int i=0; i < oldcfg.getNumberOfNodes(); i++)   if (oldcfg.isCatchBlock(i)) {
    ExceptionHandlerBasicBlock B=(ExceptionHandlerBasicBlock)ssacfg.getNode(i);
    B.setCatchInstruction((SSAGetCaughtExceptionInstruction)getInstructions()[B.getFirstInstructionIndex()]);
    getInstructions()[B.getFirstInstructionIndex()]=null;
  }
}",0.9230769230769232
100467,"private AstIR(AstMethod method,SSAInstruction[] instructions,SymbolTable symbolTable,SSACFG cfg,SSAOptions options){
  super(method,instructions,symbolTable,cfg,options);
  setCatchInstructions(getControlFlowGraph(),method.cfg);
  localMap=SSAConversion.convert(method,this,options);
  setupCatchTypes(getControlFlowGraph(),method.catchTypes);
  setupLocationMap();
}","private AstIR(AstMethod method,SSAInstruction[] instructions,SymbolTable symbolTable,SSACFG cfg,SSAOptions options){
  super(method,instructions,symbolTable,cfg,options);
  localMap=SSAConversion.convert(method,this,options);
  setCatchInstructions(getControlFlowGraph(),method.cfg);
  setupCatchTypes(getControlFlowGraph(),method.catchTypes);
  setupLocationMap();
}",0.8501362397820164
100468,"/** 
 * This method finishes a pass. All code is updated; instructions are reordered and old labels may not be valid. If no patches were issued, we don't need to do anything at all; this case is detected quickly and no updates are made.
 * @return true iff non-trivial patches were applied
 */
public boolean applyPatches() throws IllegalArgumentException {
  verifyState(DURING_PASS);
  state=EMITTING_CODE;
  if (patchCount == 0) {
    state=BEFORE_END_PASS;
    return false;
  }
  Output w=new Output(nextLabel);
  int[] oldInstructionsToNew=new int[instructions.length];
  w.additionalHandlers=noHandlers;
  w.originalBytecode=0;
  for (Patch p=methodStartPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  ExceptionHandler[] methodHandlers=makeExceptionArray(methodHandlerPatches);
  if (methodHandlers.length > 0) {
    w.codeChanged=true;
  }
  for (int i=0; i < instructions.length; i++) {
    ExceptionHandler[] basicHandlers=mergeHandlers(handlers[i],methodHandlers);
    HandlerPatch hp=instructionHandlerPatches[i];
    w.emitLabel(i);
    w.originalBytecode=instructionsToBytecodes[i];
    w.additionalHandlers=basicHandlers;
    for (Patch p=beforePatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    w.additionalHandlers=mergeHandlers(makeExceptionArray(hp),basicHandlers);
    Patch replace=replacementPatches[i];
    if (replace == null) {
      oldInstructionsToNew[i]=w.newInstructions.size();
      w.internalEmitInstruction(instructions[i]);
    }
 else {
      w.codeChanged=true;
      oldInstructionsToNew[i]=-1;
      replace.emitTo(w);
    }
    w.additionalHandlers=basicHandlers;
    for (Patch p=afterPatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    if (hp != null) {
      w.codeChanged=true;
      GotoInstruction branchOver=GotoInstruction.make(i + 1);
      w.internalEmitInstruction(branchOver);
      for (HandlerPatch hpIterator=hp; hpIterator != null; hpIterator=hpIterator.next) {
        w.additionalHandlers=mergeHandlers(makeExceptionArray(hpIterator.next),basicHandlers);
        w.emitLabel(hpIterator.label);
        hpIterator.patch.emitTo(w);
        w.internalEmitInstruction(branchOver);
      }
    }
  }
  w.originalBytecode=0;
  for (HandlerPatch hpIterator=methodHandlerPatches; hpIterator != null; hpIterator=hpIterator.next) {
    w.additionalHandlers=makeExceptionArray(hpIterator.next);
    w.emitLabel(hpIterator.label);
    hpIterator.patch.emitTo(w);
  }
  w.additionalHandlers=noHandlers;
  for (Patch p=afterMethodPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  state=BEFORE_END_PASS;
  if (!w.codeChanged) {
    return false;
  }
  instructions=new Instruction[w.newInstructions.size()];
  handlers=new ExceptionHandler[instructions.length][];
  instructionsToBytecodes=new int[instructions.length];
  w.newInstructions.toArray(instructions);
  w.newInstructionHandlers.toArray(handlers);
  System.arraycopy(w.instructionsToBytecodes,0,instructionsToBytecodes,0,instructionsToBytecodes.length);
  int[] labelDefs=w.labelDefs;
  int[] newInstructionsToOld=new int[instructions.length];
  for (int i=0; i < instructions.length; i++) {
    instructions[i]=instructions[i].redirectTargets(labelDefs);
    newInstructionsToOld[i]=-1;
  }
  HashSet<ExceptionHandler> adjustedHandlers=null;
  for (int i=0; i < handlers.length; i++) {
    ExceptionHandler[] hs=handlers[i];
    if (hs.length > 0 && (i == 0 || hs != handlers[i - 1])) {
      if (adjustedHandlers == null) {
        adjustedHandlers=new HashSet<ExceptionHandler>();
      }
      for (int j=0; j < hs.length; j++) {
        ExceptionHandler h=hs[j];
        if (!adjustedHandlers.contains(h)) {
          h.handler=labelDefs[h.handler];
          adjustedHandlers.add(h);
        }
      }
    }
  }
  if (methodInfo != null) {
    for (int i=0; i < oldInstructionsToNew.length; i++) {
      if (oldInstructionsToNew[i] != -1) {
        newInstructionsToOld[oldInstructionsToNew[i]]=i;
      }
    }
    methodInfo.update(instructions,handlers,newInstructionsToOld,instructionsToBytecodes);
  }
  return true;
}","/** 
 * This method finishes a pass. All code is updated; instructions are reordered and old labels may not be valid. If no patches were issued, we don't need to do anything at all; this case is detected quickly and no updates are made.
 * @return true iff non-trivial patches were applied
 */
public boolean applyPatches() throws IllegalArgumentException {
  verifyState(DURING_PASS);
  state=EMITTING_CODE;
  if (patchCount == 0) {
    state=BEFORE_END_PASS;
    return false;
  }
  Output w=new Output(nextLabel);
  int[] oldInstructionsToNew=new int[instructions.length];
  w.additionalHandlers=noHandlers;
  w.originalBytecode=0;
  for (Patch p=methodStartPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  ExceptionHandler[] methodHandlers=makeExceptionArray(methodHandlerPatches);
  if (methodHandlers.length > 0) {
    w.codeChanged=true;
  }
  for (int i=0; i < instructions.length; i++) {
    ExceptionHandler[] basicHandlers=mergeHandlers(handlers[i],methodHandlers);
    HandlerPatch hp=instructionHandlerPatches[i];
    w.emitLabel(i);
    w.originalBytecode=instructionsToBytecodes[i];
    w.additionalHandlers=basicHandlers;
    for (Patch p=beforePatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    w.additionalHandlers=mergeHandlers(makeExceptionArray(hp),basicHandlers);
    Patch replace=replacementPatches[i];
    if (replace == null) {
      oldInstructionsToNew[i]=w.newInstructions.size();
      w.internalEmitInstruction(instructions[i]);
    }
 else {
      w.codeChanged=true;
      oldInstructionsToNew[i]=-1;
      replace.emitTo(w);
    }
    w.additionalHandlers=basicHandlers;
    for (Patch p=afterPatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    if (hp != null) {
      w.codeChanged=true;
      GotoInstruction branchOver=GotoInstruction.make(i + 1);
      w.internalEmitInstruction(branchOver);
      for (HandlerPatch hpIterator=hp; hpIterator != null; hpIterator=hpIterator.next) {
        w.additionalHandlers=mergeHandlers(makeExceptionArray(hpIterator.next),basicHandlers);
        w.emitLabel(hpIterator.label);
        hpIterator.patch.emitTo(w);
        w.internalEmitInstruction(branchOver);
      }
    }
  }
  w.originalBytecode=0;
  for (HandlerPatch hpIterator=methodHandlerPatches; hpIterator != null; hpIterator=hpIterator.next) {
    w.additionalHandlers=makeExceptionArray(hpIterator.next);
    w.emitLabel(hpIterator.label);
    hpIterator.patch.emitTo(w);
  }
  w.additionalHandlers=noHandlers;
  for (Patch p=afterMethodPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  state=BEFORE_END_PASS;
  if (!w.codeChanged) {
    return false;
  }
  instructions=new Instruction[w.newInstructions.size()];
  handlers=new ExceptionHandler[instructions.length][];
  instructionsToBytecodes=new int[instructions.length];
  w.newInstructions.toArray(instructions);
  w.newInstructionHandlers.toArray(handlers);
  System.arraycopy(w.instructionsToBytecodes,0,instructionsToBytecodes,0,instructionsToBytecodes.length);
  int[] labelDefs=w.labelDefs;
  int[] newInstructionsToOld=new int[instructions.length];
  for (int i=0; i < instructions.length; i++) {
    instructions[i]=instructions[i].redirectTargets(labelDefs);
    newInstructionsToOld[i]=-1;
  }
  IdentityHashMap<ExceptionHandler,Object> adjustedHandlers=null;
  for (int i=0; i < handlers.length; i++) {
    ExceptionHandler[] hs=handlers[i];
    if (hs.length > 0 && (i == 0 || hs != handlers[i - 1])) {
      if (adjustedHandlers == null) {
        adjustedHandlers=new IdentityHashMap<ExceptionHandler,Object>();
      }
      for (int j=0; j < hs.length; j++) {
        ExceptionHandler h=hs[j];
        if (!adjustedHandlers.containsKey(h)) {
          adjustedHandlers.put(h,null);
          h.handler=labelDefs[h.handler];
        }
      }
    }
  }
  if (methodInfo != null) {
    for (int i=0; i < oldInstructionsToNew.length; i++) {
      if (oldInstructionsToNew[i] != -1) {
        newInstructionsToOld[oldInstructionsToNew[i]]=i;
      }
    }
    methodInfo.update(instructions,handlers,newInstructionsToOld,instructionsToBytecodes);
  }
  return true;
}",0.9853264856933236
100469,"private static String[] getJarsInDirectory(String dir){
  File f=new File(dir);
  Assertions.productionAssertion(f.isDirectory(),""String_Node_Str"" + dir);
  ArrayList<String> list=new ArrayList<String>();
  addJarFilesFromDirectory(f,list);
  String[] result=new String[list.size()];
  int i=0;
  for (Iterator<String> it=list.iterator(); it.hasNext(); ) {
    result[i++]=it.next();
  }
  return result;
}","private static String[] getJarsInDirectory(String dir){
  File f=new File(dir);
  Assertions.productionAssertion(f.isDirectory(),""String_Node_Str"" + dir);
  Collection<File> col=FileUtil.listFiles(dir,""String_Node_Str"",true);
  String[] result=new String[col.size()];
  int i=0;
  for (  File jarFile : col) {
    result[i++]=jarFile.getAbsolutePath();
  }
  return result;
}",0.6837387964148528
100470,"/** 
 * Sets all bits.
 */
public final void setAll(){
  expand(0,length());
  for (int i=0; i < bits.length; i++) {
    bits[i]=MASK;
  }
}","/** 
 * Sets all bits.
 */
public final void setAll(){
  expand(0,length() - 1);
  for (int i=0; i < bits.length; i++) {
    bits[i]=MASK;
  }
}",0.9859154929577464
100471,"/** 
 * Sets a bit.
 * @param bit the bit to be set
 */
public final void set(int bit){
  int shiftBits;
  int subscript;
  if (bit < offset) {
    int newOffset=bit & ~LOW_MASK;
    expand(newOffset,length() - newOffset);
    shiftBits=bit & LOW_MASK;
    subscript=0;
  }
 else {
    bit-=offset;
    shiftBits=bit & LOW_MASK;
    subscript=subscript(bit);
    if (subscript >= bits.length) {
      expand(offset,bit);
    }
  }
  try {
    bits[subscript]|=(1 << shiftBits);
  }
 catch (  RuntimeException e) {
    e.printStackTrace();
    throw e;
  }
}","/** 
 * Sets a bit.
 * @param bit the bit to be set
 */
public final void set(int bit){
  int shiftBits;
  int subscript;
  if (bit < offset) {
    int newOffset=bit & ~LOW_MASK;
    expand(newOffset,length() - 1 - newOffset);
    shiftBits=bit & LOW_MASK;
    subscript=0;
  }
 else {
    bit-=offset;
    shiftBits=bit & LOW_MASK;
    subscript=subscript(bit);
    if (subscript >= bits.length) {
      expand(offset,bit);
    }
  }
  try {
    bits[subscript]|=(1 << shiftBits);
  }
 catch (  RuntimeException e) {
    e.printStackTrace();
    throw e;
  }
}",0.996422182468694
100472,"private JarFile getRtJar(){
  for (Iterator MS=getModules(getPrimordialLoader()).iterator(); MS.hasNext(); ) {
    Module M=(Module)MS.next();
    if (M instanceof JarFileModule) {
      JarFile JF=((JarFileModule)M).getJarFile();
      if (JF.getName().endsWith(File.separator + ""String_Node_Str""))       return JF;
      if (JF.getName().endsWith(File.separator + ""String_Node_Str""))       return JF;
    }
  }
  Assertions.UNREACHABLE();
  return null;
}","/** 
 * @return the rt.jar (1.4) or core.jar (1.5) file, or null if not found.
 */
private JarFile getRtJar(){
  for (Iterator MS=getModules(getPrimordialLoader()).iterator(); MS.hasNext(); ) {
    Module M=(Module)MS.next();
    if (M instanceof JarFileModule) {
      JarFile JF=((JarFileModule)M).getJarFile();
      if (JF.getName().endsWith(File.separator + ""String_Node_Str"")) {
        return JF;
      }
      if (JF.getName().endsWith(File.separator + ""String_Node_Str"")) {
        return JF;
      }
    }
  }
  return null;
}",0.771399798590131
100473,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAPhiInstruction(defs == null ? result : defs[0],uses == null ? params : uses);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses) throws IllegalArgumentException {
  if (defs != null && defs.length == 0) {
    throw new IllegalArgumentException();
  }
  return new SSAPhiInstruction(defs == null ? result : defs[0],uses == null ? params : uses);
}",0.7152941176470589
100474,"/** 
 * @see com.ibm.wala.ssa.SSAInstruction#getUse(int)
 */
public int getUse(int j){
  return params[j];
}","/** 
 * @see com.ibm.wala.ssa.SSAInstruction#getUse(int)
 */
public int getUse(int j) throws IllegalArgumentException {
  if (j >= params.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + j);
  }
  return params[j];
}",0.627906976744186
100475,"ArrayTypeSignature(String s){
  super(s);
  assert(s.charAt(0) == '[');
}","ArrayTypeSignature(String s) throws IllegalArgumentException {
  super(s);
  if (s.length() == 0) {
    throw new IllegalArgumentException();
  }
  if (s.charAt(0) != '[') {
    throw new IllegalArgumentException();
  }
}",0.4013605442176871
100476,"public static ArrayTypeSignature make(String s){
  return new ArrayTypeSignature(s);
}","public static ArrayTypeSignature make(String s) throws IllegalArgumentException {
  return new ArrayTypeSignature(s);
}",0.8390243902439024
100477,"public static ClassTypeSignature makeClassTypeSig(String s){
  return new ClassTypeSignature(s);
}","public static ClassTypeSignature makeClassTypeSig(String s) throws IllegalArgumentException {
  return new ClassTypeSignature(s);
}",0.8558951965065502
100478,"ClassTypeSignature(String s){
  super(s);
  assert(s.charAt(0) == 'L');
  assert(s.charAt(s.length() - 1) == ';');
}","ClassTypeSignature(String s) throws IllegalArgumentException {
  super(s);
  if (s.length() == 0) {
    throw new IllegalArgumentException();
  }
  if (s.charAt(0) != 'L') {
    throw new IllegalArgumentException(s);
  }
  if (s.charAt(s.length() - 1) != ';') {
    throw new IllegalArgumentException(s);
  }
}",0.4178403755868544
100479,"public FormalTypeParameter(String s){
  super(s);
  id=parseForId(s);
  classBound=parseForClassBound(s);
  interfaceBounds=parseForInterfaceBounds(s);
}","public FormalTypeParameter(String s) throws IllegalArgumentException {
  super(s);
  id=parseForId(s);
  classBound=parseForClassBound(s);
  interfaceBounds=parseForInterfaceBounds(s);
}",0.9026548672566372
100480,"private String parseForId(String s){
  return s.substring(0,s.indexOf(':'));
}","private String parseForId(String s) throws IllegalArgumentException {
  if (s.indexOf(':') == -1) {
    throw new IllegalArgumentException(s);
  }
  return s.substring(0,s.indexOf(':'));
}",0.5864661654135338
100481,"public static FormalTypeParameter make(String string){
  return new FormalTypeParameter(string);
}","public static FormalTypeParameter make(String string) throws IllegalArgumentException {
  return new FormalTypeParameter(string);
}",0.8558951965065502
100482,"public MethodTypeSignature(String s){
  super(s);
}","private MethodTypeSignature(String s){
  super(s);
}",0.912621359223301
100483,"public static MethodTypeSignature make(String genericsSignature){
  return new MethodTypeSignature(genericsSignature);
}","public static MethodTypeSignature make(String genericsSignature) throws IllegalArgumentException {
  if (genericsSignature.length() == 0) {
    throw new IllegalArgumentException();
  }
  return new MethodTypeSignature(genericsSignature);
}",0.6666666666666666
100484,"public static TypeArgument[] make(String s){
  assert(s.charAt(0) == '<');
  assert(s.charAt(s.length() - 1) == '>');
  String[] args=parseForTypeArguments(s);
  TypeArgument[] result=new TypeArgument[args.length];
  for (int i=0; i < result.length; i++) {
    result[i]=makeTypeArgument(args[i]);
  }
  return result;
}","public static TypeArgument[] make(String s) throws IllegalArgumentException {
  if (s.length() == 0 || s.charAt(0) != '<') {
    throw new IllegalArgumentException(s);
  }
  if (s.charAt(s.length() - 1) != '>') {
    throw new IllegalArgumentException(s);
  }
  String[] args=parseForTypeArguments(s);
  TypeArgument[] result=new TypeArgument[args.length];
  for (int i=0; i < result.length; i++) {
    result[i]=makeTypeArgument(args[i]);
  }
  return result;
}",0.7391304347826086
100485,"private TypeVariableSignature(String s){
  super(s);
  assert(s.charAt(s.length() - 1) == ';');
}","private TypeVariableSignature(String s) throws IllegalArgumentException {
  super(s);
  if (s.length() == 0) {
    throw new IllegalArgumentException();
  }
  if (s.charAt(s.length() - 1) != ';') {
    throw new IllegalArgumentException(s);
  }
}",0.3965014577259475
100486,"public static TypeVariableSignature make(String s){
  return new TypeVariableSignature(s);
}","public static TypeVariableSignature make(String s) throws IllegalArgumentException {
  return new TypeVariableSignature(s);
}",0.847926267281106
100487,"/** 
 * Add this edge, unconditionally setting it as the next successor.
 * @see com.ibm.wala.util.graph.EdgeManager#addEdge(java.lang.Object,java.lang.Object)
 */
public void addEdge(T src,T dst){
  delegate.addEdge(src,dst);
  SimpleVector<T> s=successorEdges.get(src);
  if (s == null) {
    s=new SimpleVector<T>();
    successorEdges.put(src,s);
  }
  s.set(s.getMaxIndex() + 1,dst);
}","public void addEdge(int i,T src,T dst){
  delegate.addEdge(src,dst);
  SimpleVector<T> s=successorEdges.get(src);
  if (s == null) {
    s=new SimpleVector<T>();
    successorEdges.put(src,s);
  }
  s.set(i,dst);
}",0.2350993377483443
100488,"public void remove(){
  Assertions.UNREACHABLE();
}","public void remove() throws UnsupportedOperationException {
  throw new UnsupportedOperationException();
}",0.4713375796178344
100489,"/** 
 * Remove an object from this bit set.
 * @param o the object to remove
 */
public void clear(T o){
  int n=map.getMappedIndex(o);
  vector.clear(n);
}","/** 
 * Remove an object from this bit set.
 * @param o the object to remove
 */
public void clear(T o){
  int n=map.getMappedIndex(o);
  if (n == -1) {
    return;
  }
  vector.clear(n);
}",0.9043478260869564
100490,"/** 
 * Does this set contain a certain object?
 */
public boolean contains(T o){
  int n=map.getMappedIndex(o);
  return vector.get(n);
}","/** 
 * Does this set contain a certain object?
 */
public boolean contains(T o){
  int n=map.getMappedIndex(o);
  if (n == -1) {
    return false;
  }
  return vector.get(n);
}",0.8761904761904762
100491,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public IStructuredSelection getSelection(){
  GraphViewer viewer=(GraphViewer)getApplicationWindow();
  return (IStructuredSelection)viewer.viewer.getSelection();
}","/** 
 * @return
 * @throws IllegalStateException
 */
public IStructuredSelection getSelection() throws IllegalStateException {
  GraphViewer viewer=(GraphViewer)getApplicationWindow();
  if (viewer == null || viewer.viewer == null) {
    throw new IllegalStateException();
  }
  return (IStructuredSelection)viewer.viewer.getSelection();
}",0.0621761658031088
100492,"public void launch() throws WalaException {
  Process p=spawnProcess(getCmd());
  Thread d1=drainStdErr(p);
  Thread d2=isCaptureOutput() ? captureStdOut(p) : drainStdOut(p);
  try {
    d1.join();
    d2.join();
  }
 catch (  InterruptedException e) {
    throw new WalaException(""String_Node_Str"",e);
  }
  if (isCaptureOutput()) {
    Drainer d=(Drainer)d2;
    setOutput(d.getCapture().toByteArray());
  }
}","public void launch() throws WalaException, IllegalArgumentException {
  Process p=spawnProcess(getCmd());
  Thread d1=drainStdErr(p);
  Thread d2=isCaptureOutput() ? captureStdOut(p) : drainStdOut(p);
  try {
    d1.join();
    d2.join();
  }
 catch (  InterruptedException e) {
    throw new WalaException(""String_Node_Str"",e);
  }
  if (isCaptureOutput()) {
    Drainer d=(Drainer)d2;
    setOutput(d.getCapture().toByteArray());
  }
}",0.9693396226415094
100493,"public AbstractStatement takeStatement(){
  AbstractStatement result=(AbstractStatement)super.take();
  contents.remove(result);
  return result;
}","public AbstractStatement takeStatement() throws NoSuchElementException {
  AbstractStatement result=(AbstractStatement)super.take();
  contents.remove(result);
  return result;
}",0.9046153846153846
100494,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAArrayLengthInstruction(defs == null ? result : defs[0],uses == null ? arrayref : uses[0]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses) throws IllegalArgumentException {
  if (defs != null && defs.length != 1) {
    throw new IllegalArgumentException();
  }
  if (uses != null && uses.length != 1) {
    throw new IllegalArgumentException();
  }
  return new SSAArrayLengthInstruction(defs == null ? result : defs[0],uses == null ? arrayref : uses[0]);
}",0.6122448979591837
100495,"public SSAInstruction copyForSSA(int[] defs,int[] uses){
  return new SSAThrowInstruction(uses == null ? getException() : uses[0]);
}","public SSAInstruction copyForSSA(int[] defs,int[] uses) throws IllegalArgumentException {
  if (uses != null && uses.length != 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new SSAThrowInstruction(uses == null ? getException() : uses[0]);
}",0.6584158415841584
100496,"/** 
 * @param b a byte array holding the string representation of this descriptor
 * @return the canonical representative for this descriptor value
 */
public static Descriptor findOrCreate(ImmutableByteArray b){
  TypeName returnType=StringStuff.parseForReturnTypeName(b);
  TypeName[] parameters=StringStuff.parseForParameterNames(b);
  Key k=new Key(returnType,parameters);
  Descriptor result=map.get(k);
  if (result == null) {
    result=new Descriptor(k);
    map.put(k,result);
  }
  return result;
}","/** 
 * @param b a byte array holding the string representation of this descriptor
 * @return the canonical representative for this descriptor value
 */
public static Descriptor findOrCreate(ImmutableByteArray b) throws IllegalArgumentException {
  TypeName returnType=StringStuff.parseForReturnTypeName(b);
  TypeName[] parameters=StringStuff.parseForParameterNames(b);
  Key k=new Key(returnType,parameters);
  Descriptor result=map.get(k);
  if (result == null) {
    result=new Descriptor(k);
    map.put(k,result);
  }
  return result;
}",0.9686013320647004
100497,"/** 
 * @param s string representation of this descriptor
 * @return the canonical representative for this descriptor value
 */
public static Descriptor findOrCreateUTF8(String s){
  byte[] b=UTF8Convert.toUTF8(s);
  return findOrCreate(new ImmutableByteArray(b));
}","/** 
 * @param s string representation of this descriptor
 * @return the canonical representative for this descriptor value
 */
public static Descriptor findOrCreateUTF8(String s) throws IllegalArgumentException {
  byte[] b=UTF8Convert.toUTF8(s);
  return findOrCreate(new ImmutableByteArray(b));
}",0.9415929203539825
100498,"public static TypeArgument make(String string){
  if (string.equals(""String_Node_Str"")) {
    return WILDCARD;
  }
 else {
    Assertions.UNREACHABLE();
    return null;
  }
}","public static TypeArgument make(String string) throws UnimplementedError {
  if (string.equals(""String_Node_Str"")) {
    return WILDCARD;
  }
 else {
    Assertions.UNREACHABLE(""String_Node_Str"");
    return null;
  }
}",0.8883248730964467
100499,"/** 
 * Parse an array descriptor to obtain number of dimensions in corresponding array type. b: descriptor - something like ""[Ljava/lang/String;"" or ""[[I""
 * @return dimensionality - something like ""1"" or ""2""
 */
public static short parseForArrayDimensionality(ImmutableByteArray b,int start,int length){
  for (int i=start; i < start + length; ++i) {
    if (b.b[i] != '[') {
      return (short)(i - start);
    }
  }
  Assertions.UNREACHABLE();
  return -1;
}","/** 
 * Parse an array descriptor to obtain number of dimensions in corresponding array type. b: descriptor - something like ""[Ljava/lang/String;"" or ""[[I""
 * @return dimensionality - something like ""1"" or ""2""
 */
public static short parseForArrayDimensionality(ImmutableByteArray b,int start,int length) throws IllegalArgumentException {
  for (int i=start; i < start + length; ++i) {
    if (b.b[i] != '[') {
      return (short)(i - start);
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + b);
}",0.8764044943820225
100500,"/** 
 * Parse method descriptor to obtain description of method's return type. TODO: tune this .. probably combine with parseForParameters.
 * @param b method descriptor - something like ""(III)V""
 * @return type description
 */
public static final TypeName parseForReturnTypeName(ImmutableByteArray b){
  if (Assertions.verifyAssertions) {
    if (b.get(0) != '(') {
      Assertions._assert(b.get(0) == '(',""String_Node_Str"" + b);
    }
  }
  int i=0;
  while (b.get(i++) != ')')   ;
switch (b.get(i)) {
case TypeReference.VoidTypeCode:
    return TypeReference.Void.getName();
case TypeReference.BooleanTypeCode:
  return TypeReference.Boolean.getName();
case TypeReference.ByteTypeCode:
return TypeReference.Byte.getName();
case TypeReference.ShortTypeCode:
return TypeReference.Short.getName();
case TypeReference.IntTypeCode:
return TypeReference.Int.getName();
case TypeReference.LongTypeCode:
return TypeReference.Long.getName();
case TypeReference.FloatTypeCode:
return TypeReference.Float.getName();
case TypeReference.DoubleTypeCode:
return TypeReference.Double.getName();
case TypeReference.CharTypeCode:
return TypeReference.Char.getName();
case TypeReference.ClassTypeCode:
case TypeReference.ArrayTypeCode:
if (b.get(b.length() - 1) == ';') {
return TypeName.findOrCreate(b,i,b.length() - i - 1);
}
 else {
return TypeName.findOrCreate(b,i,b.length() - i);
}
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + b);
}
return null;
}
}","/** 
 * Parse method descriptor to obtain description of method's return type. TODO: tune this .. probably combine with parseForParameters.
 * @param b method descriptor - something like ""(III)V""
 * @return type description
 */
public static final TypeName parseForReturnTypeName(ImmutableByteArray b) throws IllegalArgumentException {
  if (b.length() <= 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + b);
  }
  if (b.get(0) != '(') {
    throw new IllegalArgumentException(""String_Node_Str"" + b);
  }
  int i=0;
  while (b.get(i++) != ')')   ;
switch (b.get(i)) {
case TypeReference.VoidTypeCode:
    return TypeReference.Void.getName();
case TypeReference.BooleanTypeCode:
  return TypeReference.Boolean.getName();
case TypeReference.ByteTypeCode:
return TypeReference.Byte.getName();
case TypeReference.ShortTypeCode:
return TypeReference.Short.getName();
case TypeReference.IntTypeCode:
return TypeReference.Int.getName();
case TypeReference.LongTypeCode:
return TypeReference.Long.getName();
case TypeReference.FloatTypeCode:
return TypeReference.Float.getName();
case TypeReference.DoubleTypeCode:
return TypeReference.Double.getName();
case TypeReference.CharTypeCode:
return TypeReference.Char.getName();
case TypeReference.ClassTypeCode:
case TypeReference.ArrayTypeCode:
if (b.get(b.length() - 1) == ';') {
return TypeName.findOrCreate(b,i,b.length() - i - 1);
}
 else {
return TypeName.findOrCreate(b,i,b.length() - i);
}
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + b);
}
return null;
}
}",0.2486876640419947
100501,"/** 
 * Given that name[start:start+length] is a Type name in JVM format, strip the package and return the ""package-free"" class name
 * @return an ImmutableByteArray that represents the package, or null if it'sthe unnamed package
 */
public static ImmutableByteArray parseForClass(ImmutableByteArray name){
  return parseForClass(name,0,name.length());
}","/** 
 * Given that name[start:start+length] is a Type name in JVM format, strip the package and return the ""package-free"" class name
 * @return an ImmutableByteArray that represents the package, or null if it'sthe unnamed package
 */
public static ImmutableByteArray parseForClass(ImmutableByteArray name) throws IllegalArgumentException {
  return parseForClass(name,0,name.length());
}",0.9554655870445344
100502,"/** 
 * @param name
 * @param start
 * @param length
 * @return true iff the class returned by parseForClass is primitive
 */
public static boolean classIsPrimitive(ImmutableByteArray name,int start,int length){
  while (length > 0 && name.b[start] == '[') {
    start++;
    length--;
  }
  return name.b[start] != 'L';
}","/** 
 * @param name
 * @param start
 * @param length
 * @return true iff the class returned by parseForClass is primitive
 */
public static boolean classIsPrimitive(ImmutableByteArray name,int start,int length) throws IllegalArgumentException {
  while (length > 0 && name.b[start] == '[') {
    start++;
    length--;
  }
  if (start >= name.b.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + name);
  }
  return name.b[start] != 'L';
}",0.8267008985879333
100503,"/** 
 * @param methodSig something like ""java_cup.lexer.advance()V""
 */
public static MethodReference makeMethodReference(String methodSig){
  String type=methodSig.substring(0,methodSig.lastIndexOf('.'));
  type=deployment2CanonicalTypeString(type);
  TypeReference t=TypeReference.findOrCreate(ClassLoaderReference.Application,type);
  String methodName=methodSig.substring(methodSig.lastIndexOf('.') + 1,methodSig.indexOf('('));
  String desc=methodSig.substring(methodSig.indexOf('('));
  return MethodReference.findOrCreate(t,methodName,desc);
}","/** 
 * @param methodSig something like ""java_cup.lexer.advance()V""
 */
public static MethodReference makeMethodReference(String methodSig) throws IllegalArgumentException {
  if (methodSig.lastIndexOf('.') < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + methodSig);
  }
  String type=methodSig.substring(0,methodSig.lastIndexOf('.'));
  type=deployment2CanonicalTypeString(type);
  TypeReference t=TypeReference.findOrCreate(ClassLoaderReference.Application,type);
  String methodName=methodSig.substring(methodSig.lastIndexOf('.') + 1,methodSig.indexOf('('));
  String desc=methodSig.substring(methodSig.indexOf('('));
  return MethodReference.findOrCreate(t,methodName,desc);
}",0.8814102564102564
100504,"/** 
 * Parse method descriptor to obtain descriptions of method's parameters.
 * @return parameter descriptions, or null if there are no parameters
 */
public static final TypeName[] parseForParameterNames(ImmutableByteArray b){
  if (Assertions.verifyAssertions) {
    if (b.get(0) != '(') {
      Assertions._assert(b.get(0) == '(',""String_Node_Str"" + b);
    }
  }
  ArrayList<TypeName> sigs=new ArrayList<TypeName>(10);
  int i=1;
  while (true) {
switch (b.get(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName);
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName);
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName);
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName);
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName);
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName);
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName);
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName);
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName);
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
while (b.get(i++) != ';') ;
sigs.add(TypeName.findOrCreate(b,off,i - off - 1));
continue;
}
case TypeReference.ArrayTypeCode:
{
int off=i - 1;
while (b.get(i) == TypeReference.ArrayTypeCode) {
++i;
}
TypeName T=null;
if (b.get(i++) == TypeReference.ClassTypeCode) {
while (b.get(i++) != ';') ;
T=TypeName.findOrCreate(b,off,i - off - 1);
}
 else {
T=TypeName.findOrCreate(b,off,i - off);
}
sigs.add(T);
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<TypeName> it=sigs.iterator();
TypeName[] result=new TypeName[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + b);
}
}
}
}","/** 
 * Parse method descriptor to obtain descriptions of method's parameters.
 * @return parameter descriptions, or null if there are no parameters
 */
public static final TypeName[] parseForParameterNames(ImmutableByteArray b) throws IllegalArgumentException {
  if (b.length() <= 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + b);
  }
  if (b.get(0) != '(') {
    throw new IllegalArgumentException(""String_Node_Str"" + b);
  }
  ArrayList<TypeName> sigs=new ArrayList<TypeName>(10);
  int i=1;
  while (true) {
switch (b.get(i++)) {
case TypeReference.VoidTypeCode:
      sigs.add(TypeReference.VoidName);
    continue;
case TypeReference.BooleanTypeCode:
  sigs.add(TypeReference.BooleanName);
continue;
case TypeReference.ByteTypeCode:
sigs.add(TypeReference.ByteName);
continue;
case TypeReference.ShortTypeCode:
sigs.add(TypeReference.ShortName);
continue;
case TypeReference.IntTypeCode:
sigs.add(TypeReference.IntName);
continue;
case TypeReference.LongTypeCode:
sigs.add(TypeReference.LongName);
continue;
case TypeReference.FloatTypeCode:
sigs.add(TypeReference.FloatName);
continue;
case TypeReference.DoubleTypeCode:
sigs.add(TypeReference.DoubleName);
continue;
case TypeReference.CharTypeCode:
sigs.add(TypeReference.CharName);
continue;
case TypeReference.ClassTypeCode:
{
int off=i - 1;
while (b.get(i++) != ';') ;
sigs.add(TypeName.findOrCreate(b,off,i - off - 1));
continue;
}
case TypeReference.ArrayTypeCode:
{
int off=i - 1;
while (b.get(i) == TypeReference.ArrayTypeCode) {
++i;
}
TypeName T=null;
if (b.get(i++) == TypeReference.ClassTypeCode) {
while (b.get(i++) != ';') ;
T=TypeName.findOrCreate(b,off,i - off - 1);
}
 else {
T=TypeName.findOrCreate(b,off,i - off);
}
sigs.add(T);
continue;
}
case (byte)')':
int size=sigs.size();
if (size == 0) {
return null;
}
Iterator<TypeName> it=sigs.iterator();
TypeName[] result=new TypeName[size];
for (int j=0; j < size; j++) {
result[j]=it.next();
}
return result;
default :
if (Assertions.verifyAssertions) {
Assertions._assert(false,""String_Node_Str"" + b);
}
}
}
}",0.1578947368421052
100505,"/** 
 * Convert a JVM encoded type name to a readable type name.
 * @param jvmType a String containing a type name in JVM internal format.
 * @return the same type name in readable (source code) format.
 */
public static String jvmToReadableType(String jvmType){
  StringBuffer readable=new StringBuffer();
  int numberOfDimensions=0;
  char prefix=jvmType.charAt(0);
  while (prefix == '[') {
    numberOfDimensions++;
    prefix=jvmType.charAt(numberOfDimensions);
  }
  if (prefix == 'V') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'B') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'C') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'D') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'F') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'I') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'J') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'S') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'Z') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'L') {
    readable.append(jvmType.substring(numberOfDimensions + 1,jvmType.length()));
    readable=new StringBuffer(slashToDot(readable.toString()));
    readable=new StringBuffer(dollarToDot(readable.toString()));
  }
  for (int i=0; i < numberOfDimensions; ++i) {
    readable.append(""String_Node_Str"");
  }
  return readable.toString();
}","/** 
 * Convert a JVM encoded type name to a readable type name.
 * @param jvmType a String containing a type name in JVM internal format.
 * @return the same type name in readable (source code) format.
 */
public static String jvmToReadableType(String jvmType) throws IllegalArgumentException {
  StringBuffer readable=new StringBuffer();
  int numberOfDimensions=0;
  if (jvmType.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + jvmType);
  }
  char prefix=jvmType.charAt(0);
  while (prefix == '[') {
    numberOfDimensions++;
    prefix=jvmType.charAt(numberOfDimensions);
  }
  if (prefix == 'V') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'B') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'C') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'D') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'F') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'I') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'J') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'S') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'Z') {
    readable.append(""String_Node_Str"");
  }
 else   if (prefix == 'L') {
    readable.append(jvmType.substring(numberOfDimensions + 1,jvmType.length()));
    readable=new StringBuffer(slashToDot(readable.toString()));
    readable=new StringBuffer(dollarToDot(readable.toString()));
  }
  for (int i=0; i < numberOfDimensions; ++i) {
    readable.append(""String_Node_Str"");
  }
  return readable.toString();
}",0.955962712954034
100506,"public void testSlice2() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  WarningSet warnings=new WarningSet();
  ClassHierarchy cha=ClassHierarchy.make(scope,warnings);
  Entrypoints entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope,warnings);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(22,slice.size());
}","public void testSlice2() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  WarningSet warnings=new WarningSet();
  ClassHierarchy cha=ClassHierarchy.make(scope,warnings);
  Entrypoints entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope,warnings);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(30,slice.size());
}",0.9978517722878624
100507,"public void testSlice1() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  WarningSet warnings=new WarningSet();
  ClassHierarchy cha=ClassHierarchy.make(scope,warnings);
  Entrypoints entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE1_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope,warnings);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMainMethod(cg);
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(18,slice.size());
}","public void testSlice1() throws ClassHierarchyException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA);
  WarningSet warnings=new WarningSet();
  ClassHierarchy cha=ClassHierarchy.make(scope,warnings);
  Entrypoints entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE1_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,cha,scope,warnings);
  CallGraph cg=builder.makeCallGraph(options);
  CGNode main=findMainMethod(cg);
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  dumpSlice(slice);
  assertEquals(26,slice.size());
}",0.9978189749182116
100508,"/** 
 * Add an integer value to this set.
 * @param i
 * @return true iff the value of this changes.
 */
public boolean add(int i){
  boolean pr=primaryImpl.add(i);
  boolean sr=secondaryImpl.add(i);
  Assertions._assert(pr == sr);
  return pr;
}","/** 
 * Add an integer value to this set.
 * @param i
 * @return true iff the value of this changes.
 */
public boolean add(int i){
  boolean pr=primaryImpl.add(i);
  boolean sr=secondaryImpl.add(i);
  if (pr != sr) {
    Assertions._assert(pr == sr,""String_Node_Str"" + i + ""String_Node_Str""+ primaryImpl+ ""String_Node_Str""+ pr+ ""String_Node_Str""+ i+ ""String_Node_Str""+ secondaryImpl+ ""String_Node_Str""+ sr);
  }
  return pr;
}",0.7310549777117384
100509,"/** 
 */
public int size(){
  Assertions._assert(primaryImpl.size() == secondaryImpl.size());
  return primaryImpl.size();
}","/** 
 */
public int size(){
  if (primaryImpl.size() != secondaryImpl.size()) {
    Assertions._assert(primaryImpl.size() == secondaryImpl.size(),""String_Node_Str"" + primaryImpl.size() + ""String_Node_Str""+ primaryImpl+ ""String_Node_Str""+ ""String_Node_Str""+ secondaryImpl.size()+ ""String_Node_Str""+ secondaryImpl);
  }
  return primaryImpl.size();
}",0.5254237288135594
100510,"void growCapacity(float fraction){
  expand(offset,(int)fraction * (bits.length << LOG_BITS_PER_UNIT));
}","void growCapacity(float fraction){
  expand(offset,(int)(fraction * (bits.length << LOG_BITS_PER_UNIT)));
}",0.9905660377358492
100511,"/** 
 * Add an integer value to this set.
 * @param i integer to add
 * @return true iff the value of this changes.
 */
public boolean add(int i){
  if (!contains(i)) {
    if (densePart != null && densePart.getOffset() <= i && densePart.length() > i) {
      densePart.set(i);
    }
 else {
      sparsePart.add(i);
      fixAfterSparseInsert();
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Add an integer value to this set.
 * @param i integer to add
 * @return true iff the value of this changes.
 */
public boolean add(int i){
  if (densePart != null && inDenseRange(i)) {
    if (!densePart.get(i)) {
      densePart.set(i);
      assertDisjoint();
      return true;
    }
  }
 else   if (!sparsePart.contains(i)) {
    sparsePart.add(i);
    assertDisjoint();
    fixAfterSparseInsert();
    return true;
  }
  return false;
}",0.585480093676815
100512,"/** 
 * @param i
 * @return true iff this set contains integer i
 */
public boolean contains(int i){
  return sparsePart.contains(i) || (densePart != null && densePart.contains(i));
}","/** 
 * @param i
 * @return true iff this set contains integer i
 */
public boolean contains(int i){
  if (densePart != null && inDenseRange(i)) {
    return densePart.contains(i);
  }
 else {
    return sparsePart.contains(i);
  }
}",0.7211538461538461
100513,"/** 
 * Add all members of set to this.
 * @param set
 * @return true iff the value of this changes.
 */
public boolean addAll(IntSet set){
  boolean change=false;
  if (set instanceof SemiSparseMutableIntSet) {
    SemiSparseMutableIntSet that=(SemiSparseMutableIntSet)set;
    if (densePart == null) {
      if (that.densePart != null) {
        densePart=new OffsetBitVector(that.densePart);
        for (int b=densePart.nextSetBit(0); b != -1; b=densePart.nextSetBit(b + 1)) {
          if (sparsePart.contains(b)) {
            sparsePart.remove(b);
          }
 else {
            change=true;
          }
        }
        for (IntIterator bits=that.sparsePart.intIterator(); bits.hasNext(); ) {
          change|=sparsePart.add(bits.next());
        }
      }
 else {
        for (IntIterator bs=that.sparsePart.intIterator(); bs.hasNext(); ) {
          change|=add(bs.next());
        }
      }
    }
 else {
      int oldSize=size();
      if (that.densePart != null) {
        densePart.or(that.densePart);
        for (IntIterator bs=that.sparsePart.intIterator(); bs.hasNext(); ) {
          add(bs.next());
        }
        for (IntIterator bs=sparsePart.intIterator(); bs.hasNext(); ) {
          int b=bs.next();
          if (densePart.get(b)) {
            sparsePart.remove(b);
          }
        }
        change=(size() != oldSize);
      }
 else {
        for (IntIterator bs=that.sparsePart.intIterator(); bs.hasNext(); ) {
          change|=add(bs.next());
        }
      }
    }
  }
 else {
    for (IntIterator bs=set.intIterator(); bs.hasNext(); ) {
      change|=add(bs.next());
    }
  }
  return change;
}","/** 
 * Add all members of set to this.
 * @param set
 * @return true iff the value of this changes.
 */
public boolean addAll(IntSet set){
  boolean change=false;
  if (set instanceof SemiSparseMutableIntSet) {
    SemiSparseMutableIntSet that=(SemiSparseMutableIntSet)set;
    if (densePart == null) {
      if (that.densePart != null) {
        int oldSize=size();
        densePart=new OffsetBitVector(that.densePart);
        for (IntIterator bits=sparsePart.intIterator(); bits.hasNext(); ) {
          int bit=bits.next();
          if (inDenseRange(bit)) {
            densePart.set(bit);
          }
        }
        sparsePart.removeAll(densePart);
        sparsePart.addAll(that.sparsePart);
        change=size() != oldSize;
      }
 else {
        change=sparsePart.addAll(that.sparsePart);
        fixAfterSparseInsert();
      }
    }
 else {
      if (that.densePart != null) {
        int oldSize=size();
        densePart.or(that.densePart);
        sparsePart.addAll(that.sparsePart);
        for (IntIterator bits=sparsePart.intIterator(); bits.hasNext(); ) {
          int bit=bits.next();
          if (inDenseRange(bit)) {
            densePart.set(bit);
          }
        }
        sparsePart.removeAll(densePart);
        change=size() != oldSize;
      }
 else {
        for (IntIterator bs=that.sparsePart.intIterator(); bs.hasNext(); ) {
          change|=add(bs.next());
        }
      }
    }
  }
 else {
    for (IntIterator bs=set.intIterator(); bs.hasNext(); ) {
      change|=add(bs.next());
    }
  }
  assertDisjoint();
  return change;
}",0.2822505439850792
100514,"/** 
 */
public void init(){
  fakeRoot=makeFakeRootNode();
  Key k=new Key(fakeRoot.getMethod(),fakeRoot.getContext());
  registerNode(k,fakeRoot);
  fakeWorldClinit=makeFakeWorldClinitNode();
  k=new Key(fakeWorldClinit.getMethod(),fakeWorldClinit.getContext());
  registerNode(k,fakeWorldClinit);
  CallSiteReference site=CallSiteReference.make(1,fakeWorldClinit.getMethod().getReference(),IInvokeInstruction.Dispatch.STATIC);
  ((FakeRootMethod)fakeRoot.getMethod()).addInvocation(null,site);
  fakeRoot.addTarget(site,fakeWorldClinit);
}","/** 
 */
public void init(){
  fakeRoot=makeFakeRootNode();
  Key k=new Key(fakeRoot.getMethod(),fakeRoot.getContext());
  registerNode(k,fakeRoot);
  fakeWorldClinit=makeFakeWorldClinitNode();
  k=new Key(fakeWorldClinit.getMethod(),fakeWorldClinit.getContext());
  registerNode(k,fakeWorldClinit);
  CallSiteReference site=CallSiteReference.make(1,fakeWorldClinit.getMethod().getReference(),IInvokeInstruction.Dispatch.STATIC);
  site=((FakeRootMethod)fakeRoot.getMethod()).addInvocation(null,site).getCallSite();
  fakeRoot.addTarget(site,fakeWorldClinit);
}",0.9827742520398912
100515,"/** 
 * Allocate a fresh label. This must be called during a pass and not during code emission.
 */
public int allocateLabel(){
  verifyState(DURING_PASS);
  return nextLabel++;
}","/** 
 * Allocate a fresh label. This must be called during a pass and not during code emission.
 */
public int allocateLabel() throws IllegalArgumentException {
  verifyState(DURING_PASS);
  return nextLabel++;
}",0.9156010230179028
100516,"/** 
 * This method finishes a pass. All code is updated; instructions are reordered and old labels may not be valid. If no patches were issued, we don't need to do anything at all; this case is detected quickly and no updates are made.
 * @return true iff non-trivial patches were applied
 */
public boolean applyPatches(){
  verifyState(DURING_PASS);
  state=EMITTING_CODE;
  if (patchCount == 0) {
    state=BEFORE_END_PASS;
    return false;
  }
  Output w=new Output(nextLabel);
  int[] oldInstructionsToNew=new int[instructions.length];
  w.additionalHandlers=noHandlers;
  w.originalBytecode=0;
  for (Patch p=methodStartPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  ExceptionHandler[] methodHandlers=makeExceptionArray(methodHandlerPatches);
  if (methodHandlers.length > 0) {
    w.codeChanged=true;
  }
  for (int i=0; i < instructions.length; i++) {
    ExceptionHandler[] basicHandlers=mergeHandlers(handlers[i],methodHandlers);
    HandlerPatch hp=instructionHandlerPatches[i];
    w.emitLabel(i);
    w.originalBytecode=instructionsToBytecodes[i];
    w.additionalHandlers=basicHandlers;
    for (Patch p=beforePatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    w.additionalHandlers=mergeHandlers(makeExceptionArray(hp),basicHandlers);
    Patch replace=replacementPatches[i];
    if (replace == null) {
      oldInstructionsToNew[i]=w.newInstructions.size();
      w.internalEmitInstruction(instructions[i]);
    }
 else {
      w.codeChanged=true;
      oldInstructionsToNew[i]=-1;
      replace.emitTo(w);
    }
    w.additionalHandlers=basicHandlers;
    for (Patch p=afterPatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    if (hp != null) {
      w.codeChanged=true;
      GotoInstruction branchOver=GotoInstruction.make(i + 1);
      w.internalEmitInstruction(branchOver);
      for (HandlerPatch hpIterator=hp; hpIterator != null; hpIterator=hpIterator.next) {
        w.additionalHandlers=mergeHandlers(makeExceptionArray(hpIterator.next),basicHandlers);
        w.emitLabel(hpIterator.label);
        hpIterator.patch.emitTo(w);
        w.internalEmitInstruction(branchOver);
      }
    }
  }
  w.originalBytecode=0;
  for (HandlerPatch hpIterator=methodHandlerPatches; hpIterator != null; hpIterator=hpIterator.next) {
    w.additionalHandlers=makeExceptionArray(hpIterator.next);
    w.emitLabel(hpIterator.label);
    hpIterator.patch.emitTo(w);
  }
  w.additionalHandlers=noHandlers;
  for (Patch p=afterMethodPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  state=BEFORE_END_PASS;
  if (!w.codeChanged) {
    return false;
  }
  instructions=new Instruction[w.newInstructions.size()];
  handlers=new ExceptionHandler[instructions.length][];
  instructionsToBytecodes=new int[instructions.length];
  w.newInstructions.toArray(instructions);
  w.newInstructionHandlers.toArray(handlers);
  System.arraycopy(w.instructionsToBytecodes,0,instructionsToBytecodes,0,instructionsToBytecodes.length);
  int[] labelDefs=w.labelDefs;
  int[] newInstructionsToOld=new int[instructions.length];
  for (int i=0; i < instructions.length; i++) {
    instructions[i]=instructions[i].redirectTargets(labelDefs);
    newInstructionsToOld[i]=-1;
  }
  HashSet<ExceptionHandler> adjustedHandlers=null;
  for (int i=0; i < handlers.length; i++) {
    ExceptionHandler[] hs=handlers[i];
    if (hs.length > 0 && (i == 0 || hs != handlers[i - 1])) {
      if (adjustedHandlers == null) {
        adjustedHandlers=new HashSet<ExceptionHandler>();
      }
      for (int j=0; j < hs.length; j++) {
        ExceptionHandler h=hs[j];
        if (!adjustedHandlers.contains(h)) {
          adjustedHandlers.add(h);
          h.handler=labelDefs[h.handler];
        }
      }
    }
  }
  if (methodInfo != null) {
    for (int i=0; i < oldInstructionsToNew.length; i++) {
      if (oldInstructionsToNew[i] != -1) {
        newInstructionsToOld[oldInstructionsToNew[i]]=i;
      }
    }
    methodInfo.update(instructions,handlers,newInstructionsToOld,instructionsToBytecodes);
  }
  return true;
}","/** 
 * This method finishes a pass. All code is updated; instructions are reordered and old labels may not be valid. If no patches were issued, we don't need to do anything at all; this case is detected quickly and no updates are made.
 * @return true iff non-trivial patches were applied
 */
public boolean applyPatches() throws IllegalArgumentException {
  verifyState(DURING_PASS);
  state=EMITTING_CODE;
  if (patchCount == 0) {
    state=BEFORE_END_PASS;
    return false;
  }
  Output w=new Output(nextLabel);
  int[] oldInstructionsToNew=new int[instructions.length];
  w.additionalHandlers=noHandlers;
  w.originalBytecode=0;
  for (Patch p=methodStartPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  ExceptionHandler[] methodHandlers=makeExceptionArray(methodHandlerPatches);
  if (methodHandlers.length > 0) {
    w.codeChanged=true;
  }
  for (int i=0; i < instructions.length; i++) {
    ExceptionHandler[] basicHandlers=mergeHandlers(handlers[i],methodHandlers);
    HandlerPatch hp=instructionHandlerPatches[i];
    w.emitLabel(i);
    w.originalBytecode=instructionsToBytecodes[i];
    w.additionalHandlers=basicHandlers;
    for (Patch p=beforePatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    w.additionalHandlers=mergeHandlers(makeExceptionArray(hp),basicHandlers);
    Patch replace=replacementPatches[i];
    if (replace == null) {
      oldInstructionsToNew[i]=w.newInstructions.size();
      w.internalEmitInstruction(instructions[i]);
    }
 else {
      w.codeChanged=true;
      oldInstructionsToNew[i]=-1;
      replace.emitTo(w);
    }
    w.additionalHandlers=basicHandlers;
    for (Patch p=afterPatches[i]; p != null; p=p.next) {
      p.emitTo(w);
    }
    if (hp != null) {
      w.codeChanged=true;
      GotoInstruction branchOver=GotoInstruction.make(i + 1);
      w.internalEmitInstruction(branchOver);
      for (HandlerPatch hpIterator=hp; hpIterator != null; hpIterator=hpIterator.next) {
        w.additionalHandlers=mergeHandlers(makeExceptionArray(hpIterator.next),basicHandlers);
        w.emitLabel(hpIterator.label);
        hpIterator.patch.emitTo(w);
        w.internalEmitInstruction(branchOver);
      }
    }
  }
  w.originalBytecode=0;
  for (HandlerPatch hpIterator=methodHandlerPatches; hpIterator != null; hpIterator=hpIterator.next) {
    w.additionalHandlers=makeExceptionArray(hpIterator.next);
    w.emitLabel(hpIterator.label);
    hpIterator.patch.emitTo(w);
  }
  w.additionalHandlers=noHandlers;
  for (Patch p=afterMethodPatches; p != null; p=p.next) {
    p.emitTo(w);
  }
  state=BEFORE_END_PASS;
  if (!w.codeChanged) {
    return false;
  }
  instructions=new Instruction[w.newInstructions.size()];
  handlers=new ExceptionHandler[instructions.length][];
  instructionsToBytecodes=new int[instructions.length];
  w.newInstructions.toArray(instructions);
  w.newInstructionHandlers.toArray(handlers);
  System.arraycopy(w.instructionsToBytecodes,0,instructionsToBytecodes,0,instructionsToBytecodes.length);
  int[] labelDefs=w.labelDefs;
  int[] newInstructionsToOld=new int[instructions.length];
  for (int i=0; i < instructions.length; i++) {
    instructions[i]=instructions[i].redirectTargets(labelDefs);
    newInstructionsToOld[i]=-1;
  }
  HashSet<ExceptionHandler> adjustedHandlers=null;
  for (int i=0; i < handlers.length; i++) {
    ExceptionHandler[] hs=handlers[i];
    if (hs.length > 0 && (i == 0 || hs != handlers[i - 1])) {
      if (adjustedHandlers == null) {
        adjustedHandlers=new HashSet<ExceptionHandler>();
      }
      for (int j=0; j < hs.length; j++) {
        ExceptionHandler h=hs[j];
        if (!adjustedHandlers.contains(h)) {
          adjustedHandlers.add(h);
          h.handler=labelDefs[h.handler];
        }
      }
    }
  }
  if (methodInfo != null) {
    for (int i=0; i < oldInstructionsToNew.length; i++) {
      if (oldInstructionsToNew[i] != -1) {
        newInstructionsToOld[oldInstructionsToNew[i]]=i;
      }
    }
    methodInfo.update(instructions,handlers,newInstructionsToOld,instructionsToBytecodes);
  }
  return true;
}",0.9959294436906376
100517,"/** 
 * @return the value of the Utf8 string at constant pool item i
 */
public String getCPUtf8(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Utf8) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    int count=getUShort(offset + 1);
    int end=count + offset + 3;
    StringBuffer buf=new StringBuffer(count);
    offset+=3;
    while (offset < end) {
      byte x=getByte(offset);
      if ((x & 0x80) == 0) {
        if (x == 0) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)x);
        offset++;
      }
 else       if ((x & 0xE0) == 0xC0) {
        if (offset + 1 >= end) {
          throw invalidUtf8(i,offset);
        }
        byte y=getByte(offset + 1);
        if ((y & 0xC0) != 0x80) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)(((x & 0x1F) << 6) + (y & 0x3F)));
        offset+=2;
      }
 else       if ((x & 0xF0) == 0xE0) {
        if (offset + 2 >= end) {
          throw invalidUtf8(i,offset);
        }
        byte y=getByte(offset + 1);
        byte z=getByte(offset + 2);
        if ((y & 0xC0) != 0x80 || (z & 0xC0) != 0x80) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)(((x & 0x0F) << 12) + ((y & 0x3F) << 6) + (z & 0x3F)));
        offset+=3;
      }
 else {
        throw invalidUtf8(i,offset);
      }
    }
    s=buf.toString().intern();
    cpItems[i]=s;
  }
  return s;
}","/** 
 * @return the value of the Utf8 string at constant pool item i
 */
public String getCPUtf8(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Utf8) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    int count=getUShort(offset + 1);
    int end=count + offset + 3;
    StringBuffer buf=new StringBuffer(count);
    offset+=3;
    while (offset < end) {
      byte x=getByte(offset);
      if ((x & 0x80) == 0) {
        if (x == 0) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)x);
        offset++;
      }
 else       if ((x & 0xE0) == 0xC0) {
        if (offset + 1 >= end) {
          throw invalidUtf8(i,offset);
        }
        byte y=getByte(offset + 1);
        if ((y & 0xC0) != 0x80) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)(((x & 0x1F) << 6) + (y & 0x3F)));
        offset+=2;
      }
 else       if ((x & 0xF0) == 0xE0) {
        if (offset + 2 >= end) {
          throw invalidUtf8(i,offset);
        }
        byte y=getByte(offset + 1);
        byte z=getByte(offset + 2);
        if ((y & 0xC0) != 0x80 || (z & 0xC0) != 0x80) {
          throw invalidUtf8(i,offset);
        }
        buf.append((char)(((x & 0x0F) << 12) + ((y & 0x3F) << 6) + (z & 0x3F)));
        offset+=3;
      }
 else {
        throw invalidUtf8(i,offset);
      }
    }
    s=buf.toString().intern();
    cpItems[i]=s;
  }
  return s;
}",0.992298578199052
100518,"/** 
 * @return the name of the Class at constant pool item i, in JVM format (e.g.,java/lang/Object)
 */
public String getCPClass(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Class) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    try {
      s=getCPUtf8(getUShort(offset + 1));
    }
 catch (    IllegalArgumentException ex) {
      throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
    }
    cpItems[i]=s;
  }
  return s;
}","/** 
 * @return the name of the Class at constant pool item i, in JVM format (e.g.,java/lang/Object)
 */
public String getCPClass(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Class) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    try {
      s=getCPUtf8(getUShort(offset + 1));
    }
 catch (    IllegalArgumentException ex) {
      throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
    }
    cpItems[i]=s;
  }
  return s;
}",0.9832474226804124
100519,"/** 
 * @return the value of the Double at constant pool item i
 */
public double getCPDouble(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Double) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getDouble(offset + 1);
}","/** 
 * @return the value of the Double at constant pool item i
 */
public double getCPDouble(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Double) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getDouble(offset + 1);
}",0.9729166666666668
100520,"/** 
 * @return the type part of the FieldRef, MethodRef, or InterfaceMethodRef atconstant pool item i, in JVM format (e.g., I, Z, or Ljava/lang/Object;)
 */
public String getCPRefType(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPNATType(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the type part of the FieldRef, MethodRef, or InterfaceMethodRef atconstant pool item i, in JVM format (e.g., I, Z, or Ljava/lang/Object;)
 */
public String getCPRefType(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPNATType(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9824561403508772
100521,"/** 
 * @return the value of the Long at constant pool item i
 */
public long getCPLong(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Long) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getLong(offset + 1);
}","/** 
 * @return the value of the Long at constant pool item i
 */
public long getCPLong(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Long) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getLong(offset + 1);
}",0.9723404255319148
100522,"/** 
 * @return the name part of the NameAndType at constant pool item i
 */
public String getCPNATName(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_NameAndType) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPUtf8(getUShort(offset + 1));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the name part of the NameAndType at constant pool item i
 */
public String getCPNATName(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_NameAndType) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPUtf8(getUShort(offset + 1));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9806835066864784
100523,"/** 
 * @return the value of the Integer at constant pool item i
 */
public int getCPInt(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Integer) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getInt(offset + 1);
}","/** 
 * @return the value of the Integer at constant pool item i
 */
public int getCPInt(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Integer) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getInt(offset + 1);
}",0.9725158562367864
100524,"/** 
 * @return the size of the constant pool data in the raw class file buffer
 */
public int getRawSize(){
  return cpOffsets[cpOffsets.length - 1] - cpOffsets[1];
}","/** 
 * @return the size of the constant pool data in the raw class file buffer
 */
public int getRawSize() throws IllegalStateException {
  if (cpOffsets.length < 2) {
    throw new IllegalStateException();
  }
  return cpOffsets[cpOffsets.length - 1] - cpOffsets[1];
}",0.7643020594965675
100525,"/** 
 * @return the type part of the NameAndType at constant pool item i, in JVMformat (e.g., I, Z, or Ljava/lang/Object;)
 */
public String getCPNATType(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_NameAndType) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPUtf8(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the type part of the NameAndType at constant pool item i, in JVMformat (e.g., I, Z, or Ljava/lang/Object;)
 */
public String getCPNATType(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_NameAndType) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPUtf8(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9820193637621024
100526,"/** 
 * @return the name part of the FieldRef, MethodRef, or InterfaceMethodRef atconstant pool item i
 */
public String getCPRefName(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPNATName(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the name part of the FieldRef, MethodRef, or InterfaceMethodRef atconstant pool item i
 */
public String getCPRefName(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPNATName(getUShort(offset + 3));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.981159420289855
100527,"/** 
 * @return the type of constant pool item i, or 0 if i is an unused constantpool item
 */
public byte getItemType(int i){
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0) {
    return 0;
  }
 else {
    return getByte(offset);
  }
}","/** 
 * @return the type of constant pool item i, or 0 if i is an unused constantpool item
 */
public byte getItemType(int i) throws IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0) {
    return 0;
  }
 else {
    return getByte(offset);
  }
}",0.9560585885486018
100528,"/** 
 * @return the String at constant pool item i
 */
public String getCPString(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_String) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    try {
      s=getCPUtf8(getUShort(offset + 1));
    }
 catch (    IllegalArgumentException ex) {
      throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
    }
    cpItems[i]=s;
  }
  return s;
}","/** 
 * @return the String at constant pool item i
 */
public String getCPString(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_String) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  String s=cpItems[i];
  if (s == null) {
    try {
      s=getCPUtf8(getUShort(offset + 1));
    }
 catch (    IllegalArgumentException ex) {
      throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
    }
    cpItems[i]=s;
  }
  return s;
}",0.9821428571428572
100529,"/** 
 * @return the name of the class part of the FieldRef, MethodRef, orInterfaceMethodRef at constant pool item i
 */
public String getCPRefClass(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPClass(getUShort(offset + 1));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}","/** 
 * @return the name of the class part of the FieldRef, MethodRef, orInterfaceMethodRef at constant pool item i
 */
public String getCPRefClass(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || !isRef(getByte(offset))) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  try {
    return getCPClass(getUShort(offset + 1));
  }
 catch (  IllegalArgumentException ex) {
    throw new InvalidClassFileException(offset,""String_Node_Str"" + i + ""String_Node_Str""+ ex.getMessage());
  }
}",0.9814814814814816
100530,"/** 
 * @return the value of the Float at constant pool item i
 */
public float getCPFloat(int i) throws InvalidClassFileException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Float) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getFloat(offset + 1);
}","/** 
 * @return the value of the Float at constant pool item i
 */
public float getCPFloat(int i) throws InvalidClassFileException, IllegalArgumentException {
  if (i < 1 || i >= cpItems.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  int offset=cpOffsets[i];
  if (offset == 0 || getByte(offset) != CONSTANT_Float) {
    throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
  }
  return getFloat(offset + 1);
}",0.9726315789473684
100531,"/** 
 * @return the offset of the constant pool data in the raw class file buffer
 */
public int getRawOffset(){
  return cpOffsets[1];
}","/** 
 * @return the offset of the constant pool data in the raw class file buffer
 */
public int getRawOffset() throws IllegalStateException {
  if (cpOffsets.length < 2) {
    throw new IllegalStateException();
  }
  return cpOffsets[1];
}",0.726790450928382
100532,"public int copyInto(byte[] buf,int offset){
  verify();
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2);
  ClassWriter.setUShort(buf,offset + 6,index);
  return offset + 8;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  verify();
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2);
  ClassWriter.setUShort(buf,offset + 6,index);
  return offset + 8;
}",0.926829268292683
100533,"/** 
 * Set the index of the constant pool item holding the constant value.
 */
public void setValueCPIndex(int index){
  if (index < 1 || index > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  this.index=index;
}","/** 
 * Set the index of the constant pool item holding the constant value.
 */
public void setValueCPIndex(int index) throws IllegalArgumentException {
  if (index < 1 || index > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  this.index=index;
}",0.9378531073446328
100534,"public void set(int x,Object value){
  if (Assertions.verifyAssertions) {
    Assertions._assert(x >= 0);
  }
  maxIndex=Math.max(maxIndex,x);
  if (value == null) {
    if (x >= store.length) {
      return;
    }
 else {
      store[x]=value;
    }
  }
 else {
    ensureCapacity(x);
    store[x]=value;
  }
}","public void set(int x,T value){
  if (Assertions.verifyAssertions) {
    Assertions._assert(x >= 0);
  }
  maxIndex=Math.max(maxIndex,x);
  if (value == null) {
    if (x >= store.length) {
      return;
    }
 else {
      store[x]=value;
    }
  }
 else {
    ensureCapacity(x);
    store[x]=value;
  }
}",0.9886547811993516
100535,"/** 
 * Convert a JVM type name (either for a primitive or a class name) into a Java type name.
 */
public static String makeClassAll(String t){
  String alias=classAliases.get(t);
  if (alias != null) {
    return alias;
  }
 else {
    return makeClass(t);
  }
}","/** 
 * Convert a JVM type name (either for a primitive or a class name) into a Java type name.
 */
static String makeClassAll(String t){
  String alias=classAliases.get(t);
  if (alias != null) {
    return alias;
  }
 else {
    return makeClass(t);
  }
}",0.9865642994241842
100536,"/** 
 * Compute the total number of JVM ""stack words"" occupied by the method parameters for method signature ""type"". Any ""this"" parameter is not included.
 */
public static int getParamsWordSize(String type){
  int index=1;
  int count=0;
  if (type.indexOf(')',1) < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  while (type.charAt(index) != ')') {
    count+=getWordSize(type,index);
    index+=getTypeLength(type,index);
  }
  return count;
}","/** 
 * Compute the total number of JVM ""stack words"" occupied by the method parameters for method signature ""type"". Any ""this"" parameter is not included.
 */
public static int getParamsWordSize(String type) throws IllegalArgumentException {
  int index=1;
  int count=0;
  if (type.indexOf(')',1) < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  while (type.charAt(index) != ')') {
    count+=getWordSize(type,index);
    index+=getTypeLength(type,index);
  }
  return count;
}",0.9664292980671414
100537,"/** 
 * Computes the character length of the internal JVM type given by s.substring(i).
 */
public static int getTypeLength(String s,int i){
switch (s.charAt(i)) {
case 'L':
    return s.indexOf(';',i) - i + 1;
case '[':
  return getTypeLength(s,i + 1) + 1;
default :
return 1;
}
}","/** 
 * Computes the character length of the internal JVM type given by s.substring(i).
 */
private static int getTypeLength(String s,int i){
switch (s.charAt(i)) {
case 'L':
    return s.indexOf(';',i) - i + 1;
case '[':
  return getTypeLength(s,i + 1) + 1;
default :
return 1;
}
}",0.9804618117229128
100538,"/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 */
public static int getParamsCount(String type){
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}","/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 */
static int getParamsCount(String type){
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}",0.9883527454242927
100539,"/** 
 * @return true iff t is an array type
 */
public static boolean isArrayType(String t){
  if (t == null) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case '[':
      return true;
default :
    return false;
}
}
}","/** 
 * @return true iff t is an array type
 */
public static boolean isArrayType(String t){
  if (t == null || t.length() == 0) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case '[':
      return true;
default :
    return false;
}
}
}",0.959830866807611
100540,"/** 
 * @return the JVM ""stack word size"" for the given JVM type, looking at index'index'
 */
public static byte getWordSize(String s,int index){
switch (s.charAt(index)) {
case 'V':
    return 0;
case 'J':
case 'D':
  return 2;
default :
return 1;
}
}","/** 
 * @return the JVM ""stack word size"" for the given JVM type, looking at index'index'
 */
static byte getWordSize(String s,int index){
switch (s.charAt(index)) {
case 'V':
    return 0;
case 'J':
case 'D':
  return 2;
default :
return 1;
}
}",0.9859154929577464
100541,"final void makeOutputJar() throws IOException {
  if (outputJar == null) {
    if (outputFile == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    outputJar=new JarOutputStream(new FileOutputStream(outputFile));
  }
}","final void makeOutputJar() throws IOException, IllegalStateException {
  if (outputJar == null) {
    if (outputFile == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    outputJar=new JarOutputStream(new FileOutputStream(outputFile));
  }
}",0.63671875
100542,"/** 
 * Complete and flush the entry initiated by addOutputJarEntry.
 */
final public void endOutputJarEntry() throws IOException {
  outputJar.closeEntry();
}","/** 
 * Complete and flush the entry initiated by addOutputJarEntry.
 */
final public void endOutputJarEntry() throws IOException, IllegalStateException {
  if (outputJar == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  outputJar.closeEntry();
}",0.7429906542056075
100543,"/** 
 * Skip the last class returned in every future traversal of the class list.
 */
final public void setIgnore(boolean ignore){
  if (inputIndex == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ignoringInputs.set(inputIndex - 1);
}","/** 
 * Skip the last class returned in every future traversal of the class list.
 */
final public void setIgnore(boolean ignore) throws IllegalArgumentException {
  if (inputIndex == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ignoringInputs.set(inputIndex - 1);
}",0.9398907103825136
100544,"private void putNextEntry(ZipEntry newEntry) throws IOException {
  outputJar.putNextEntry(newEntry);
  entryNames.add(newEntry.getName());
  if (manifestBuilder != null) {
    manifestBuilder.addEntry(newEntry);
  }
}","private void putNextEntry(ZipEntry newEntry) throws IOException, IllegalStateException {
  if (outputJar == null) {
    throw new IllegalStateException();
  }
  outputJar.putNextEntry(newEntry);
  entryNames.add(newEntry.getName());
  if (manifestBuilder != null) {
    manifestBuilder.addEntry(newEntry);
  }
}",0.8241965973534972
100545,"/** 
 * Add a raw ZipEntry to the output JAR. Call endOutputJarEntry() when you're done.
 * @return the OutputStream to be used to write the entry contents
 */
final public OutputStream addOutputJarEntry(ZipEntry ze) throws IOException {
  putNextEntry(ze);
  return outputJar;
}","/** 
 * Add a raw ZipEntry to the output JAR. Call endOutputJarEntry() when you're done.
 * @return the OutputStream to be used to write the entry contents
 */
final public OutputStream addOutputJarEntry(ZipEntry ze) throws IOException, IllegalStateException {
  if (outputJar == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  putNextEntry(ze);
  return outputJar;
}",0.8263473053892215
100546,"/** 
 * Set the JAR Comment for the output JAR.
 */
final public void setJARComment(String comment) throws IOException, IllegalArgumentException {
  makeOutputJar();
  outputJar.setComment(comment);
}","/** 
 * Set the JAR Comment for the output JAR.
 */
final public void setJARComment(String comment) throws IOException, IllegalStateException {
  makeOutputJar();
  outputJar.setComment(comment);
}",0.9722921914357684
100547,"/** 
 * Call this to copy any unmodified classes to the output. This is called automatically by close(); you should only call this if you want to write an entry to the JAR file *after* the unmodified classes. This will only ever be called once per output JAR.
 */
final public void writeUnmodifiedClasses() throws IOException {
  passUnmodifiedClasses=false;
  makeOutputJar();
  for (int i=0; i < inputs.size(); i++) {
    Input in=inputs.get(i);
    if (!in.isClass()) {
      if (in instanceof JarInput) {
        JarInput jin=(JarInput)in;
        ZipEntry entry=jin.getEntry();
        InputStream s=jin.open();
        try {
          ZipEntry newEntry=new ZipEntry(entry.getName());
          newEntry.setComment(entry.getComment());
          newEntry.setExtra(entry.getExtra());
          newEntry.setTime(entry.getTime());
          putNextEntry(newEntry);
          copyStream(s,outputJar);
          outputJar.closeEntry();
        }
  finally {
          s.close();
        }
      }
 else {
        throw new Error(""String_Node_Str"" + in);
      }
    }
 else {
      String name=in.getClassName();
      if (name == null) {
        BufferedInputStream s=new BufferedInputStream(in.open(),65536);
        try {
          Object cl=makeClassFromStream(s);
          String entryName=toEntryName(getClassName(cl));
          if (!entryNames.contains(entryName)) {
            putNextEntry(new ZipEntry(entryName));
            BufferedOutputStream clOut=new BufferedOutputStream(outputJar);
            writeClassTo(cl,null,clOut);
            clOut.flush();
            outputJar.closeEntry();
          }
        }
  finally {
          s.close();
        }
      }
 else {
        String entryName=toEntryName(name);
        if (!entryNames.contains(entryName)) {
          BufferedInputStream s=new BufferedInputStream(in.open());
          try {
            putNextEntry(new ZipEntry(entryName));
            BufferedOutputStream clOut=new BufferedOutputStream(outputJar);
            copyStream(s,clOut);
            clOut.flush();
            outputJar.closeEntry();
          }
  finally {
            s.close();
          }
        }
      }
    }
  }
}","/** 
 * Call this to copy any unmodified classes to the output. This is called automatically by close(); you should only call this if you want to write an entry to the JAR file *after* the unmodified classes. This will only ever be called once per output JAR.
 */
final public void writeUnmodifiedClasses() throws IOException, IllegalStateException {
  passUnmodifiedClasses=false;
  makeOutputJar();
  for (int i=0; i < inputs.size(); i++) {
    Input in=inputs.get(i);
    if (!in.isClass()) {
      if (in instanceof JarInput) {
        JarInput jin=(JarInput)in;
        ZipEntry entry=jin.getEntry();
        InputStream s=jin.open();
        try {
          ZipEntry newEntry=new ZipEntry(entry.getName());
          newEntry.setComment(entry.getComment());
          newEntry.setExtra(entry.getExtra());
          newEntry.setTime(entry.getTime());
          putNextEntry(newEntry);
          copyStream(s,outputJar);
          outputJar.closeEntry();
        }
  finally {
          s.close();
        }
      }
 else {
        throw new Error(""String_Node_Str"" + in);
      }
    }
 else {
      String name=in.getClassName();
      if (name == null) {
        BufferedInputStream s=new BufferedInputStream(in.open(),65536);
        try {
          Object cl=makeClassFromStream(s);
          String entryName=toEntryName(getClassName(cl));
          if (!entryNames.contains(entryName)) {
            putNextEntry(new ZipEntry(entryName));
            BufferedOutputStream clOut=new BufferedOutputStream(outputJar);
            writeClassTo(cl,null,clOut);
            clOut.flush();
            outputJar.closeEntry();
          }
        }
  finally {
          s.close();
        }
      }
 else {
        String entryName=toEntryName(name);
        if (!entryNames.contains(entryName)) {
          BufferedInputStream s=new BufferedInputStream(in.open());
          try {
            putNextEntry(new ZipEntry(entryName));
            BufferedOutputStream clOut=new BufferedOutputStream(outputJar);
            copyStream(s,clOut);
            clOut.flush();
            outputJar.closeEntry();
          }
  finally {
            s.close();
          }
        }
      }
    }
  }
}",0.9947380462136812
100548,"/** 
 * Set the bytecodes for this Code attribute.
 */
public void setCode(byte[] code){
  if (code.length > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + code.length);
  }
  if (code.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.code=code;
}","/** 
 * Set the bytecodes for this Code attribute.
 */
public void setCode(byte[] code) throws IllegalArgumentException {
  if (code.length > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + code.length);
  }
  if (code.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.code=code;
}",0.9485179407176288
100549,"public int getCodeLength(){
  return code.length;
}","public int getCodeLength() throws IllegalStateException {
  if (code == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return code.length;
}",0.4766355140186916
100550,"public int copyInto(byte[] buf,int offset){
  verify();
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2);
  ClassWriter.setUShort(buf,offset + 6,index);
  return offset + 8;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  verify();
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2);
  ClassWriter.setUShort(buf,offset + 6,index);
  return offset + 8;
}",0.926829268292683
100551,"/** 
 * Set the index of the constant pool item holding the source file name.
 */
public void setSourceFileCPIndex(int index){
  if (index < 1 || index > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  this.index=index;
}","/** 
 * Set the index of the constant pool item holding the source file name.
 */
public void setSourceFileCPIndex(int index) throws IllegalArgumentException {
  if (index < 1 || index > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  this.index=index;
}",0.9394495412844036
100552,"private final void assertDisjoint(){
  if (DEBUG) {
    if (densePart != null) {
      for (IntIterator sparseBits=sparsePart.intIterator(); sparseBits.hasNext(); ) {
        int bit=sparseBits.next();
        if (densePart.contains(bit)) {
          Assertions._assert(!densePart.contains(bit),this.toString());
        }
        if (inDenseRange(bit)) {
          Assertions._assert(!inDenseRange(bit),this.toString());
        }
      }
    }
  }
}","private final boolean assertDisjoint(){
  if (DEBUG) {
    if (densePart != null) {
      for (IntIterator sparseBits=sparsePart.intIterator(); sparseBits.hasNext(); ) {
        int bit=sparseBits.next();
        if (densePart.contains(bit)) {
          return false;
        }
        if (inDenseRange(bit)) {
          return false;
        }
      }
    }
  }
  return true;
}",0.6072289156626506
100553,"/** 
 * Add an integer value to this set.
 * @param i integer to add
 * @return true iff the value of this changes.
 */
public boolean add(int i){
  if (densePart != null && inDenseRange(i)) {
    if (!densePart.get(i)) {
      densePart.set(i);
      assertDisjoint();
      return true;
    }
  }
 else   if (!sparsePart.contains(i)) {
    sparsePart.add(i);
    assertDisjoint();
    fixAfterSparseInsert();
    return true;
  }
  return false;
}","/** 
 * Add an integer value to this set.
 * @param i integer to add
 * @return true iff the value of this changes.
 */
public boolean add(int i){
}",0.4958123953098827
100554,"/** 
 * Add all members of set to this.
 * @param set
 * @return true iff the value of this changes.
 */
public boolean addAll(IntSet set){
  boolean change=false;
  if (set instanceof SemiSparseMutableIntSet) {
    SemiSparseMutableIntSet that=(SemiSparseMutableIntSet)set;
    if (densePart == null) {
      if (that.densePart != null) {
        int oldSize=size();
        densePart=new OffsetBitVector(that.densePart);
        for (IntIterator bits=sparsePart.intIterator(); bits.hasNext(); ) {
          int bit=bits.next();
          if (inDenseRange(bit)) {
            densePart.set(bit);
          }
        }
        sparsePart.removeAll(densePart);
        sparsePart.addAll(that.sparsePart);
        change=size() != oldSize;
      }
 else {
        change=sparsePart.addAll(that.sparsePart);
        fixAfterSparseInsert();
      }
    }
 else {
      if (that.densePart != null) {
        int oldSize=size();
        densePart.or(that.densePart);
        sparsePart.addAll(that.sparsePart);
        for (IntIterator bits=sparsePart.intIterator(); bits.hasNext(); ) {
          int bit=bits.next();
          if (inDenseRange(bit)) {
            densePart.set(bit);
          }
        }
        sparsePart.removeAll(densePart);
        change=size() != oldSize;
      }
 else {
        for (IntIterator bs=that.sparsePart.intIterator(); bs.hasNext(); ) {
          change|=add(bs.next());
        }
      }
    }
  }
 else {
    for (IntIterator bs=set.intIterator(); bs.hasNext(); ) {
      change|=add(bs.next());
    }
  }
  assertDisjoint();
  return change;
}","/** 
 * Add all members of set to this.
 * @param set
 * @return true iff the value of this changes.
 */
public boolean addAll(IntSet set){
}",0.1640488656195462
100555,"/** 
 * Compute the asymmetric difference of two sets, a \ b.
 * @param A
 * @param B
 */
public static IntSet diff(IntSet A,IntSet B,MutableIntSetFactory factory){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + A + ""String_Node_Str""+ B);
  }
  if (A instanceof SparseIntSet && B instanceof SparseIntSet) {
    if (DEBUG) {
      Trace.println(""String_Node_Str"");
    }
    return SparseIntSet.diff((SparseIntSet)A,(SparseIntSet)B);
  }
 else   if (A instanceof SemiSparseMutableIntSet && B instanceof SemiSparseMutableIntSet) {
    if (DEBUG) {
      Trace.println(""String_Node_Str"");
    }
    return SemiSparseMutableIntSet.diff((SemiSparseMutableIntSet)A,(SemiSparseMutableIntSet)B);
  }
 else {
    MutableIntSet result=factory.makeCopy(A);
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + result + ""String_Node_Str""+ result.getClass());
    }
    for (IntIterator it=B.intIterator(); it.hasNext(); ) {
      int I=it.next();
      result.remove(I);
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + I + ""String_Node_Str""+ result);
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + result);
    }
    return result;
  }
}","/** 
 * Compute the asymmetric difference of two sets, a \ b.
 * @param A
 * @param B
 */
public static IntSet diff(IntSet A,IntSet B,MutableIntSetFactory factory){
  if (DEBUG) {
    Trace.println(""String_Node_Str"" + A + ""String_Node_Str""+ B);
  }
  if (A instanceof SparseIntSet && B instanceof SparseIntSet) {
    if (DEBUG) {
      Trace.println(""String_Node_Str"");
    }
    return SparseIntSet.diff((SparseIntSet)A,(SparseIntSet)B);
  }
 else   if (A instanceof SemiSparseMutableIntSet && B instanceof SemiSparseMutableIntSet) {
    if (DEBUG) {
      Trace.println(""String_Node_Str"");
    }
    IntSet d=SemiSparseMutableIntSet.diff((SemiSparseMutableIntSet)A,(SemiSparseMutableIntSet)B);
    if (DEBUG) {
      Assertions._assert(d.sameValue(defaultSlowDiff(A,B,factory)));
    }
    return d;
  }
 else {
    return defaultSlowDiff(A,B,factory);
  }
}",0.7234251968503937
100556,"/** 
 * @param other
 * @return true iff this is a subset of other
 */
public boolean isSubset(OffsetBitVector other){
  if (this == other) {
    return true;
  }
  int wordDiff=wordDiff(offset,other.offset);
  int i=0;
  for (; i < -wordDiff; i++) {
    if (other.bits[i] != 0) {
      return false;
    }
  }
  int min=Math.min(bits.length,other.bits.length + wordDiff);
  for (; i < min; i++) {
    if ((bits[i] & ~other.bits[i - wordDiff]) != 0) {
      return false;
    }
  }
  for (; i < bits.length; i++) {
    if (bits[i] != 0) {
      return false;
    }
  }
  return true;
}","public boolean isSubset(OffsetBitVector other){
  if (this == other) {
    return true;
  }
  int wordDiff=wordDiff(offset,other.offset);
  int maxWord=Math.min(bits.length,other.bits.length - wordDiff);
  int i=0;
  for (; i < -wordDiff; i++) {
    if (bits[i] != 0) {
      return false;
    }
  }
  for (; i < maxWord; i++) {
    if ((bits[i] & ~other.bits[i + wordDiff]) != 0) {
      return false;
    }
  }
  for (; i < bits.length; i++) {
    if (bits[i] != 0) {
      return false;
    }
  }
  return true;
}",0.3160762942779291
100557,"/** 
 * Creates a copy of a Bit String
 * @param s the string to copy
 */
public OffsetBitVector(OffsetBitVector s){
  offset=s.offset;
  bits=new int[s.bits.length];
  copyBits(s);
}","/** 
 * Creates a copy of a Bit String
 * @param s the string to copy
 */
public OffsetBitVector(OffsetBitVector s){
  offset=s.offset;
  bits=new int[s.bits.length];
  System.arraycopy(s.bits,0,bits,0,s.bits.length);
}",0.8706467661691543
100558,"/** 
 * Compares this object against the specified object.
 * @param B the object to compare with
 * @return true if the objects are the same; false otherwise.
 */
public final boolean sameBits(OffsetBitVector B){
  if (this == B) {
    return true;
  }
  int n=Math.min(bits.length,B.bits.length);
  if (bits.length > B.bits.length) {
    for (int i=n; i < bits.length; i++) {
      if (bits[i] != 0)       return false;
    }
  }
 else   if (B.bits.length > bits.length) {
    for (int i=n; i < B.bits.length; i++) {
      if (B.bits[i] != 0)       return false;
    }
  }
  for (int i=n - 1; i >= 0; ) {
    if (bits[i] != B.bits[i]) {
      return false;
    }
    i--;
  }
  return true;
}","/** 
 * Compares this object against the specified object.
 * @param set the object to compare with
 * @return true if the objects are the same; false otherwise.
 */
public final boolean sameBits(OffsetBitVector set){
  if (this == set) {
    return true;
  }
  int wordDiff=wordDiff(offset,set.offset);
  int maxWord=Math.min(bits.length,set.bits.length - wordDiff);
  int i=0;
  if (wordDiff < 0) {
    for (; i < -wordDiff; i++) {
      if (bits[i] != 0) {
        return false;
      }
    }
  }
 else {
    for (int j=0; j < wordDiff; j++) {
      if (set.bits[j] != 0) {
        return false;
      }
    }
  }
  for (; i < maxWord; i++) {
    if (bits[i] != set.bits[i + wordDiff]) {
      return false;
    }
  }
  for (int j=maxWord + wordDiff; j < set.bits.length; j++) {
    if (set.bits[j] != 0) {
      return false;
    }
  }
  for (; i < bits.length; i++) {
    if (bits[i] != 0) {
      return false;
    }
  }
  return true;
}",0.3506414172266341
100559,"public static int[] diffInternal(SparseIntSet A,SparseIntSet B){
  if (Assertions.verifyAssertions) {
    Assertions._assert(A != null);
    Assertions._assert(B != null);
  }
  if (A.isEmpty()) {
    return new int[0];
  }
 else   if (B.isEmpty()) {
    int[] newElts=new int[A.elements.length];
    System.arraycopy(A.elements,0,newElts,0,A.elements.length);
    return newElts;
  }
 else   if (A.equals(B)) {
    return new int[0];
  }
 else   if (A.sameValue(B)) {
    return new int[0];
  }
  int[] ar=A.elements;
  int ai=0;
  int al=A.size;
  int[] br=B.elements;
  int bi=0;
  int bl=B.size;
  int[] cr=new int[al];
  int ci=0;
  while (ai < al && bi < bl) {
    int cmp=(ar[ai] - br[bi]);
    if (cmp > 0) {
      bi++;
    }
 else     if (cmp < 0) {
      cr[ci++]=ar[ai];
      ai++;
    }
 else {
      ai++;
      bi++;
    }
  }
  if (ai < al) {
    int tail=al - ai;
    System.arraycopy(ar,ai,cr,ci,tail);
    ci+=tail;
  }
  ar=new int[ci];
  System.arraycopy(cr,0,ar,0,ci);
  return ar;
}","public static int[] diffInternal(SparseIntSet A,SparseIntSet B){
  if (Assertions.verifyAssertions) {
    Assertions._assert(A != null);
    Assertions._assert(B != null);
  }
  if (A.isEmpty()) {
    return new int[0];
  }
 else   if (B.isEmpty()) {
    int[] newElts=new int[A.size];
    System.arraycopy(A.elements,0,newElts,0,A.size);
    return newElts;
  }
 else   if (A.equals(B)) {
    return new int[0];
  }
 else   if (A.sameValue(B)) {
    return new int[0];
  }
  int[] ar=A.elements;
  int ai=0;
  int al=A.size;
  int[] br=B.elements;
  int bi=0;
  int bl=B.size;
  int[] cr=new int[al];
  int ci=0;
  while (ai < al && bi < bl) {
    int cmp=(ar[ai] - br[bi]);
    if (cmp > 0) {
      bi++;
    }
 else     if (cmp < 0) {
      cr[ci++]=ar[ai];
      ai++;
    }
 else {
      ai++;
      bi++;
    }
  }
  if (ai < al) {
    int tail=al - ai;
    System.arraycopy(ar,ai,cr,ci,tail);
    ci+=tail;
  }
  ar=new int[ci];
  System.arraycopy(cr,0,ar,0,ci);
  return ar;
}",0.9809045226130654
100560,"public PointsToSetVariable(){
  super();
  this.pointerKey=null;
}","public PointsToSetVariable(PointerKey key){
  super();
  if (Assertions.verifyAssertions) {
    Assertions._assert(key != null);
  }
  this.pointerKey=key;
}",0.5560538116591929
100561,"/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(DataDependenceOptions dOptions){
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return;
  }
  IR ir=node.getIR(new WarningSet());
  if (ir == null) {
    return;
  }
  DefUse DU=node.getCallGraph().getInterpreter(node).getDU(node,new WarningSet());
  SSAInstruction[] instructions=ir.getInstructions();
  for (Iterator<? extends Statement> it=iterateNodes(); it.hasNext(); ) {
    Statement s=it.next();
switch (s.getKind()) {
case NORMAL:
case CATCH:
case PI:
case PHI:
{
        SSAInstruction statement=statement2SSAInstruction(instructions,s);
        if (!(statement instanceof SSAInvokeInstruction)) {
          if (dOptions.isTerminateAtCast() && (statement instanceof SSACheckCastInstruction)) {
            break;
          }
          if (dOptions.isTerminateAtCast() && (statement instanceof SSAInstanceofInstruction)) {
            break;
          }
          for (int i=0; i < statement.getNumberOfDefs(); i++) {
            int def=statement.getDef(i);
            for (Iterator<SSAInstruction> it2=DU.getUses(def); it2.hasNext(); ) {
              SSAInstruction use=it2.next();
              if (dOptions.isIgnoreBasePtrs()) {
                if (use instanceof SSANewInstruction) {
                  continue;
                }
                if (hasBasePointer(use)) {
                  int base=getBasePointer(use);
                  if (def == base) {
                    continue;
                  }
                  if (use instanceof SSAArrayReferenceInstruction) {
                    SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
                    if (def == arr.getIndex()) {
                      continue;
                    }
                  }
                }
              }
              Statement u=ssaInstruction2Statement(use);
              addEdge(s,u);
            }
          }
        }
        break;
      }
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
{
      if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
        Assertions._assert(!s.getKind().equals(Kind.EXC_RET_CALLER));
      }
      ValueNumberCarrier a=(ValueNumberCarrier)s;
      for (Iterator<SSAInstruction> it2=DU.getUses(a.getValueNumber()); it2.hasNext(); ) {
        SSAInstruction use=it2.next();
        if (dOptions.isIgnoreBasePtrs()) {
          if (use instanceof SSANewInstruction) {
            continue;
          }
          if (hasBasePointer(use)) {
            int base=getBasePointer(use);
            if (a.getValueNumber() == base) {
              continue;
            }
            if (use instanceof SSAArrayReferenceInstruction) {
              SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
              if (a.getValueNumber() == arr.getIndex()) {
                continue;
              }
            }
          }
        }
        Statement u=ssaInstruction2Statement(use);
        addEdge(s,u);
      }
      break;
    }
case NORMAL_RET_CALLEE:
  for (  NormalStatement ret : computeReturnStatements(ir)) {
    addEdge(ret,s);
  }
break;
case EXC_RET_CALLEE:
if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
Assertions.UNREACHABLE();
}
for (NormalStatement pei : getPEIs(ir)) {
if (dOptions.isTerminateAtCast() && (pei.getInstruction() instanceof SSACheckCastInstruction)) {
continue;
}
if (pei.getInstruction() instanceof SSAInvokeInstruction) {
SSAInvokeInstruction call=(SSAInvokeInstruction)pei.getInstruction();
Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
addEdge(st,s);
}
 else {
addEdge(pei,s);
}
}
break;
case PARAM_CALLER:
{
ParamStatement.ParamCaller pac=(ParamStatement.ParamCaller)s;
int vn=pac.getValueNumber();
if (ir.getSymbolTable().isParameter(vn)) {
Statement a=new ParamStatement.ParamCallee(node,vn);
addEdge(a,pac);
}
 else {
SSAInstruction d=DU.getDef(vn);
if (dOptions.isTerminateAtCast() && (d instanceof SSACheckCastInstruction)) {
break;
}
if (d != null) {
if (d instanceof SSAInvokeInstruction) {
SSAInvokeInstruction call=(SSAInvokeInstruction)d;
if (vn == call.getException()) {
  Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
  addEdge(st,pac);
}
 else {
  Statement st=new ParamStatement.NormalReturnCaller(node,call);
  addEdge(st,pac);
}
}
 else {
Statement ds=ssaInstruction2Statement(d);
addEdge(ds,pac);
}
}
}
}
break;
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
break;
default :
Assertions.UNREACHABLE(s.toString());
break;
}
}
}","/** 
 * Create all data dependence edges in this PDG. Scalar dependences are taken from SSA def-use information. Heap dependences are computed by a reaching defs analysis.
 * @param pa
 * @param mod
 */
private void createScalarDataDependenceEdges(DataDependenceOptions dOptions){
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return;
  }
  IR ir=node.getIR(new WarningSet());
  if (ir == null) {
    return;
  }
  DefUse DU=node.getCallGraph().getInterpreter(node).getDU(node,new WarningSet());
  SSAInstruction[] instructions=ir.getInstructions();
  for (Iterator<? extends Statement> it=iterateNodes(); it.hasNext(); ) {
    Statement s=it.next();
switch (s.getKind()) {
case NORMAL:
case CATCH:
case PI:
case PHI:
{
        SSAInstruction statement=statement2SSAInstruction(instructions,s);
        if (!(statement instanceof SSAInvokeInstruction)) {
          if (dOptions.isTerminateAtCast() && (statement instanceof SSACheckCastInstruction)) {
            break;
          }
          if (dOptions.isTerminateAtCast() && (statement instanceof SSAInstanceofInstruction)) {
            break;
          }
          for (int i=0; i < statement.getNumberOfDefs(); i++) {
            int def=statement.getDef(i);
            for (Iterator<SSAInstruction> it2=DU.getUses(def); it2.hasNext(); ) {
              SSAInstruction use=it2.next();
              if (dOptions.isIgnoreBasePtrs()) {
                if (use instanceof SSANewInstruction) {
                  continue;
                }
                if (hasBasePointer(use)) {
                  int base=getBasePointer(use);
                  if (def == base) {
                    continue;
                  }
                  if (use instanceof SSAArrayReferenceInstruction) {
                    SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
                    if (def == arr.getIndex()) {
                      continue;
                    }
                  }
                }
              }
              Statement u=ssaInstruction2Statement(use);
              addEdge(s,u);
            }
          }
        }
        break;
      }
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
{
      if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
        Assertions._assert(!s.getKind().equals(Kind.EXC_RET_CALLER));
      }
      ValueNumberCarrier a=(ValueNumberCarrier)s;
      for (Iterator<SSAInstruction> it2=DU.getUses(a.getValueNumber()); it2.hasNext(); ) {
        SSAInstruction use=it2.next();
        if (dOptions.isIgnoreBasePtrs()) {
          if (use instanceof SSANewInstruction) {
            continue;
          }
          if (hasBasePointer(use)) {
            int base=getBasePointer(use);
            if (a.getValueNumber() == base) {
              continue;
            }
            if (use instanceof SSAArrayReferenceInstruction) {
              SSAArrayReferenceInstruction arr=(SSAArrayReferenceInstruction)use;
              if (a.getValueNumber() == arr.getIndex()) {
                continue;
              }
            }
          }
        }
        Statement u=ssaInstruction2Statement(use);
        addEdge(s,u);
      }
      break;
    }
case NORMAL_RET_CALLEE:
  for (  NormalStatement ret : computeReturnStatements(ir)) {
    addEdge(ret,s);
  }
break;
case EXC_RET_CALLEE:
if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
Assertions.UNREACHABLE();
}
for (NormalStatement pei : getPEIs(ir)) {
if (dOptions.isTerminateAtCast() && (pei.getInstruction() instanceof SSACheckCastInstruction)) {
continue;
}
if (pei.getInstruction() instanceof SSAInvokeInstruction) {
SSAInvokeInstruction call=(SSAInvokeInstruction)pei.getInstruction();
Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
addEdge(st,s);
}
 else {
addEdge(pei,s);
}
}
break;
case PARAM_CALLER:
{
ParamStatement.ParamCaller pac=(ParamStatement.ParamCaller)s;
int vn=pac.getValueNumber();
if (vn > -1) {
if (ir.getSymbolTable().isParameter(vn)) {
Statement a=new ParamStatement.ParamCallee(node,vn);
addEdge(a,pac);
}
 else {
SSAInstruction d=DU.getDef(vn);
if (dOptions.isTerminateAtCast() && (d instanceof SSACheckCastInstruction)) {
break;
}
if (d != null) {
if (d instanceof SSAInvokeInstruction) {
  SSAInvokeInstruction call=(SSAInvokeInstruction)d;
  if (vn == call.getException()) {
    Statement st=new ParamStatement.ExceptionalReturnCaller(node,call);
    addEdge(st,pac);
  }
 else {
    Statement st=new ParamStatement.NormalReturnCaller(node,call);
    addEdge(st,pac);
  }
}
 else {
  Statement ds=ssaInstruction2Statement(d);
  addEdge(ds,pac);
}
}
}
}
}
break;
case HEAP_RET_CALLEE:
case HEAP_RET_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_PARAM_CALLEE:
case METHOD_ENTRY:
break;
default :
Assertions.UNREACHABLE(s.toString());
break;
}
}
}",0.996149443230305
100562,"public int getDef(int i){
  Assertions.UNREACHABLE();
  return -1;
}","public int getDef(int i){
  return -1;
}",0.7407407407407407
100563,"public byte get(int i){
  return b[i];
}","public byte get(int i) throws IllegalArgumentException {
  if (i >= b.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + b.length + ""String_Node_Str""+ i);
  }
  return b[i];
}",0.3433476394849785
100564,"/** 
 * Remove the next Object from the queue and return it to the caller. Throws <code>IllegalStateException</code> if the queue is empty when this method is called.
 * @return the next Object in the queue.
 */
public T pop(){
  if (isEmpty())   throw new IllegalStateException(""String_Node_Str"");
  T element=qItems.get(0);
  qItems.remove(0);
  inQueue.remove(element);
  return element;
}","/** 
 * Remove the next Object from the queue and return it to the caller. Throws <code>IllegalStateException</code> if the queue is empty when this method is called.
 * @return the next Object in the queue.
 */
public T pop() throws IllegalStateException {
  if (isEmpty())   throw new IllegalStateException(""String_Node_Str"");
  T element=qItems.get(0);
  qItems.remove(0);
  inQueue.remove(element);
  return element;
}",0.9631449631449632
100565,"/** 
 * Returns the next Object in the queue, but leaves it in the queue. Throws <code>IllegalStateException</code> if the queue is empty when this method is called.
 * @return the next Object in the queue.
 */
public T peek(){
  if (isEmpty())   throw new IllegalStateException(""String_Node_Str"");
  return qItems.get(0);
}","/** 
 * Returns the next Object in the queue, but leaves it in the queue. Throws <code>IllegalStateException</code> if the queue is empty when this method is called.
 * @return the next Object in the queue.
 */
public T peek() throws IllegalStateException {
  if (isEmpty())   throw new IllegalStateException(""String_Node_Str"");
  return qItems.get(0);
}",0.9557522123893806
100566,"public void remove(){
  Assertions.UNREACHABLE();
}","public void remove() throws UnsupportedOperationException {
  throw new UnsupportedOperationException();
}",0.4713375796178344
100567,"/** 
 * Method UNREACHABLE.
 * @param string
 */
public static void UNREACHABLE(String string){
  throw new UnimplementedError(string);
}","/** 
 * Method UNREACHABLE.
 * @param string
 */
@Internal public static void UNREACHABLE(String string){
  throw new UnimplementedError(string);
}",0.9647887323943662
100568,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static JarFileModule getFromPlugin(String fileName) throws IOException {
  URL url=FileLocator.find(CorePlugin.getDefault().getBundle(),new Path(fileName),null);
  if (url == null) {
    fileName=""String_Node_Str"" + fileName;
    url=FileLocator.find(CorePlugin.getDefault().getBundle(),new Path(fileName),null);
    if (url == null) {
      return null;
    }
  }
  url=FileLocator.toFileURL(url);
  return new JarFileModule(new JarFile(filePathFromURL(url)));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static JarFileModule getFromPlugin(String fileName) throws IOException {
  URL url=getFileURLFromPlugin(fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}",0.6180631120783461
100569,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href=""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"">bug report</a>).  For now, fails with an assertion if the url is malformed.
 * @param url 
 * @return the path name for the url
 */
public static String filePathFromURL(URL url){
  URI uri=null;
  try {
    uri=new URI(url.toString());
  }
 catch (  URISyntaxException e) {
    Assertions.UNREACHABLE();
  }
  String filePath=uri.getPath();
  return filePath;
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href=""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"">bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 */
public static String filePathFromURL(URL url){
  URI uri=null;
  try {
    uri=new URI(url.toString());
  }
 catch (  URISyntaxException e) {
    Assertions.UNREACHABLE();
  }
  String filePath=uri.getPath();
  return filePath;
}",0.9984962406015038
100570,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static File getFileFromPlugin(String fileName) throws IOException {
  URL url=FileLocator.find(CorePlugin.getDefault().getBundle(),new Path(fileName),null);
  if (url == null) {
    fileName=""String_Node_Str"" + fileName;
    url=FileLocator.find(CorePlugin.getDefault().getBundle(),new Path(fileName),null);
    if (url == null) {
      throw new FileNotFoundException(fileName);
    }
  }
  url=FileLocator.toFileURL(url);
  return new File(filePathFromURL(url));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static File getFileFromPlugin(String fileName) throws IOException {
  URL url=getFileURLFromPlugin(fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}",0.635593220338983
100571,"public Statement[] getExitsForProcedure(PDG procedure){
  if (procedure.equals(getMain())) {
    Statement[] normal=procedure.getReturnStatements();
    Statement[] result=new Statement[normal.length + 1];
    result[0]=getMainExit();
    System.arraycopy(normal,0,result,1,normal.length);
    return result;
  }
 else {
    return procedure.getReturnStatements();
  }
}","public Statement[] getExitsForProcedure(PDG procedure){
  if (procedure.equals(getMain()) && backward) {
    Statement[] normal=procedure.getReturnStatements();
    Statement[] result=new Statement[normal.length + 1];
    result[0]=getMainExit();
    System.arraycopy(normal,0,result,1,normal.length);
    return result;
  }
 else {
    return procedure.getReturnStatements();
  }
}",0.9840425531914894
100572,"public static void main(String[] args) throws Exception {
  String in=args[0];
  String out=args[1];
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=(JarEntry)e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}","public static void main(String[] args) throws Exception, IllegalArgumentException {
  if (args.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String in=args[0];
  String out=args[1];
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=(JarEntry)e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}",0.9352272727272728
100573,"public static ArrayStoreInstruction make(String type){
  int i=Util.getTypeIndex(type);
  if (i < 0 || i > TYPE_boolean_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  return preallocated[i];
}","public static ArrayStoreInstruction make(String type) throws IllegalArgumentException {
  int i=Util.getTypeIndex(type);
  if (i < 0 || i > TYPE_boolean_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str"");
  }
  return preallocated[i];
}",0.9371428571428572
100574,"public static ConversionInstruction make(String fromType,String toType){
  int from=Util.getTypeIndex(fromType);
  int to=Util.getTypeIndex(toType);
  if (from < 0 || from > TYPE_double_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + fromType);
  }
  if (from == TYPE_int_index && (to >= TYPE_byte_index && to <= TYPE_short_index)) {
    return preallocated[(OP_i2b - OP_i2l) + (to - TYPE_byte_index)];
  }
 else {
    if (to < 0 || to > TYPE_double_index) {
      throw new IllegalArgumentException(""String_Node_Str"" + fromType + ""String_Node_Str""+ toType);
    }
    if (to == from) {
      throw new IllegalArgumentException(""String_Node_Str"" + fromType + ""String_Node_Str"");
    }
    return preallocated[from * 3 + (to > from ? to - 1 : to)];
  }
}","public static ConversionInstruction make(String fromType,String toType) throws IllegalArgumentException {
  int from=Util.getTypeIndex(fromType);
  int to=Util.getTypeIndex(toType);
  if (from < 0 || from > TYPE_double_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + fromType);
  }
  if (from == TYPE_int_index && (to >= TYPE_byte_index && to <= TYPE_short_index)) {
    return preallocated[(OP_i2b - OP_i2l) + (to - TYPE_byte_index)];
  }
 else {
    if (to < 0 || to > TYPE_double_index) {
      throw new IllegalArgumentException(""String_Node_Str"" + fromType + ""String_Node_Str""+ toType);
    }
    if (to == from) {
      throw new IllegalArgumentException(""String_Node_Str"" + fromType + ""String_Node_Str"");
    }
    return preallocated[from * 3 + (to > from ? to - 1 : to)];
  }
}",0.9791006966434452
100575,"public static LoadInstruction make(String type,int index){
  int t=Util.getTypeIndex(type);
  if (t < 0 || t > TYPE_Object_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if (index < 16) {
    return preallocated[t * 16 + index];
  }
 else {
    return new LoadInstruction((short)(OP_iload + t),index);
  }
}","public static LoadInstruction make(String type,int index) throws IllegalArgumentException {
  int t=Util.getTypeIndex(type);
  if (t < 0 || t > TYPE_Object_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if (index < 16) {
    return preallocated[t * 16 + index];
  }
 else {
    return new LoadInstruction((short)(OP_iload + t),index);
  }
}",0.953846153846154
100576,"/** 
 * @param type the type of the object that will be returned (in JVM format, e.g., [Ljava/lang/String;)
 * @param arrayBoundsCount the number of array dimensions to preconstruct (equal to the number of integer parameters this instruction expects)
 */
public static NewInstruction make(String type,int arrayBoundsCount){
  if (arrayBoundsCount < 0 || arrayBoundsCount > 255) {
    throw new IllegalArgumentException(""String_Node_Str"" + arrayBoundsCount);
  }
 else {
    if (type.length() < arrayBoundsCount + 1) {
      throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ arrayBoundsCount);
    }
    for (int i=0; i < arrayBoundsCount; i++) {
      if (type.charAt(i) != '[') {
        throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ arrayBoundsCount);
      }
    }
    short opcode;
    if (arrayBoundsCount == 0) {
      opcode=OP_new;
    }
 else     if (arrayBoundsCount == 1) {
      char ch=type.charAt(1);
      if (ch != 'L' && ch != '[') {
        opcode=OP_newarray;
      }
 else {
        opcode=OP_anewarray;
      }
    }
 else {
      opcode=OP_multianewarray;
    }
    return new NewInstruction(opcode,type,(short)arrayBoundsCount);
  }
}","/** 
 * @param type the type of the object that will be returned (in JVM format, e.g., [Ljava/lang/String;)
 * @param arrayBoundsCount the number of array dimensions to preconstruct (equal to the number of integer parameters this instruction expects)
 */
public static NewInstruction make(String type,int arrayBoundsCount) throws IllegalArgumentException {
  if (arrayBoundsCount < 0 || arrayBoundsCount > 255) {
    throw new IllegalArgumentException(""String_Node_Str"" + arrayBoundsCount);
  }
 else {
    if (type.length() < arrayBoundsCount + 1) {
      throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ arrayBoundsCount);
    }
    for (int i=0; i < arrayBoundsCount; i++) {
      if (type.charAt(i) != '[') {
        throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ arrayBoundsCount);
      }
    }
    short opcode;
    if (arrayBoundsCount == 0) {
      opcode=OP_new;
    }
 else     if (arrayBoundsCount == 1) {
      char ch=type.charAt(1);
      if (ch != 'L' && ch != '[') {
        opcode=OP_newarray;
      }
 else {
        opcode=OP_anewarray;
      }
    }
 else {
      opcode=OP_multianewarray;
    }
    return new NewInstruction(opcode,type,(short)arrayBoundsCount);
  }
}",0.9866881807180314
100577,"public static ReturnInstruction make(String type){
  if (type.equals(TYPE_void)) {
    return preallocatedVoid;
  }
 else {
    int t=Util.getTypeIndex(type);
    if (t < 0 || t > TYPE_Object_index) {
      throw new IllegalArgumentException(""String_Node_Str"" + type);
    }
    return preallocated[t];
  }
}","public static ReturnInstruction make(String type) throws IllegalArgumentException {
  if (type.equals(TYPE_void)) {
    return preallocatedVoid;
  }
 else {
    int t=Util.getTypeIndex(type);
    if (t < 0 || t > TYPE_Object_index) {
      throw new IllegalArgumentException(""String_Node_Str"" + type);
    }
    return preallocated[t];
  }
}",0.9491525423728814
100578,"public static StoreInstruction make(String type,int index){
  int t=Util.getTypeIndex(type);
  if (t < 0 || t > TYPE_Object_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if (index < 16) {
    return preallocated[t * 16 + index];
  }
 else {
    return new StoreInstruction((short)(OP_istore + t),index);
  }
}","public static StoreInstruction make(String type,int index) throws IllegalArgumentException {
  int t=Util.getTypeIndex(type);
  if (t < 0 || t > TYPE_Object_index) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  if (index < 16) {
    return preallocated[t * 16 + index];
  }
 else {
    return new StoreInstruction((short)(OP_istore + t),index);
  }
}",0.954230235783634
100579,"/** 
 * Convert a JVM type name back into a Java class name.
 */
public static String makeClass(String t){
  if (t.startsWith(""String_Node_Str"")) {
    return t;
  }
 else   if (!t.startsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(t + ""String_Node_Str"");
  }
 else {
    return t.substring(1,t.length() - 1).replace('/','.');
  }
}","/** 
 * Convert a JVM type name back into a Java class name.
 */
public static String makeClass(String t) throws IllegalArgumentException {
  if (t.startsWith(""String_Node_Str"")) {
    return t;
  }
 else   if (!t.startsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(t + ""String_Node_Str"");
  }
 else {
    return t.substring(1,t.length() - 1).replace('/','.');
  }
}",0.9553450608930988
100580,"/** 
 * Append some class information to the store.
 * @param cl the JVM type of the class being added (e.g., Ljava/lang/Object;)
 * @param isInterface true iff it's an interface
 * @param isFinal true iff it's final
 * @param superClass the JVM type of the superclass, or null if this is Object
 * @param superInterfaces the JVM types of its implemented interfaces
 */
public void setClassInfo(String cl,boolean isInterface,boolean isFinal,String superClass,String[] superInterfaces){
  if (superClass != null && superClass.equals(cl)) {
    throw new Error(""String_Node_Str"" + cl + ""String_Node_Str"");
  }
  contents.put(cl,new ClassInfo(isInterface,isFinal,superClass,superInterfaces));
}","/** 
 * Append some class information to the store.
 * @param cl the JVM type of the class being added (e.g., Ljava/lang/Object;)
 * @param isInterface true iff it's an interface
 * @param isFinal true iff it's final
 * @param superClass the JVM type of the superclass, or null if this is Object
 * @param superInterfaces the JVM types of its implemented interfaces
 */
public void setClassInfo(String cl,boolean isInterface,boolean isFinal,String superClass,String[] superInterfaces) throws IllegalArgumentException {
  if (superClass != null && superClass.equals(cl)) {
    throw new IllegalArgumentException(""String_Node_Str"" + cl + ""String_Node_Str"");
  }
  contents.put(cl,new ClassInfo(isInterface,isFinal,superClass,superInterfaces));
}",0.9581589958158996
100581,"/** 
 * Set the JAR Comment for the output JAR.
 */
final public void setJARComment(String comment) throws IOException {
  makeOutputJar();
  outputJar.setComment(comment);
}","/** 
 * Set the JAR Comment for the output JAR.
 */
final public void setJARComment(String comment) throws IOException, IllegalArgumentException {
  makeOutputJar();
  outputJar.setComment(comment);
}",0.93048128342246
100582,"/** 
 * Set the 8 bytes at offset 'offset' in 'buf' to the double value in v.
 */
public static void setDouble(byte[] buf,int offset,double v){
  setLong(buf,offset,Double.doubleToRawLongBits(v));
}","/** 
 * Set the 8 bytes at offset 'offset' in 'buf' to the double value in v.
 */
public static void setDouble(byte[] buf,int offset,double v) throws IllegalArgumentException {
  setLong(buf,offset,Double.doubleToRawLongBits(v));
}",0.9230769230769232
100583,"/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 */
public static void setInt(byte[] buf,int offset,int v){
  buf[offset]=(byte)(v >> 24);
  buf[offset + 1]=(byte)(v >> 16);
  buf[offset + 2]=(byte)(v >> 8);
  buf[offset + 3]=(byte)v;
}","/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 */
public static void setInt(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (offset >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  buf[offset]=(byte)(v >> 24);
  buf[offset + 1]=(byte)(v >> 16);
  buf[offset + 2]=(byte)(v >> 8);
  buf[offset + 3]=(byte)v;
}",0.801762114537445
100584,"/** 
 * Set the 8 bytes at offset 'offset' in 'buf' to the signed 64-bit value in v.
 */
public static void setLong(byte[] buf,int offset,long v){
  setInt(buf,offset,(int)(v >> 32));
  setInt(buf,offset + 4,(int)v);
}","/** 
 * Set the 8 bytes at offset 'offset' in 'buf' to the signed 64-bit value in v.
 */
public static void setLong(byte[] buf,int offset,long v) throws IllegalArgumentException {
  setInt(buf,offset,(int)(v >> 32));
  setInt(buf,offset + 4,(int)v);
}",0.929637526652452
100585,"/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 */
public static void setUShort(byte[] buf,int offset,int v){
  if (offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  buf[offset]=(byte)(v >> 8);
  buf[offset + 1]=(byte)v;
}","/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 */
public static void setUShort(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  buf[offset]=(byte)(v >> 8);
  buf[offset + 1]=(byte)v;
}",0.8358620689655173
100586,"/** 
 * Set the constant pool index for the name of the class.
 */
public void setNameIndex(int c){
  if (c < 1 || c > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + c);
  }
  thisClass=c;
}","/** 
 * Set the constant pool index for the name of the class.
 */
public void setNameIndex(int c) throws IllegalArgumentException {
  if (c < 1 || c > 0xFFFF) {
    throw new IllegalArgumentException(""String_Node_Str"" + c);
  }
  thisClass=c;
}",0.9277899343544858
100587,"/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the float value in v.
 */
public static void setFloat(byte[] buf,int offset,float v){
  setInt(buf,offset,Float.floatToIntBits(v));
}","/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the float value in v.
 */
public static void setFloat(byte[] buf,int offset,float v) throws IllegalArgumentException {
  setInt(buf,offset,Float.floatToIntBits(v));
}",0.9193154034229828
100588,"/** 
 * Set the byte at offset 'offset' in 'buf' to the unsigned 8-bit value in v.
 */
public static void setUByte(byte[] buf,int offset,int v){
  buf[offset]=(byte)v;
}","/** 
 * Set the byte at offset 'offset' in 'buf' to the unsigned 8-bit value in v.
 */
public static void setUByte(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (offset >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  buf[offset]=(byte)v;
}",0.7145877378435518
100589,"/** 
 * After you've added everything you need to the class, call this method to generate the actual class file data. This can only be called once.
 */
public byte[] makeBytes(){
  if (buf != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (thisClass == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  reserveBuf(10);
  setInt(buf,0,MAGIC);
  setUShort(buf,4,minorVersion);
  setUShort(buf,6,majorVersion);
  emitConstantPool();
  setUShort(buf,8,nextCPIndex);
  cachedCPEntries=null;
  int offset=reserveBuf(8);
  setUShort(buf,offset,accessFlags);
  setUShort(buf,offset + 2,thisClass);
  setUShort(buf,offset + 4,superClass);
  if (superInterfaces != null) {
    setUShort(buf,offset + 6,superInterfaces.length);
    reserveBuf(superInterfaces.length * 2);
    for (int i=0; i < superInterfaces.length; i++) {
      setUShort(buf,offset + 8 + i * 2,superInterfaces[i]);
    }
  }
 else {
    setUShort(buf,offset + 6,0);
  }
  offset=reserveBuf(2);
  int numFields=fields.size();
  setUShort(buf,offset,numFields);
  for (int i=0; i < numFields; i++) {
    emitElement(fields.get(i));
  }
  offset=reserveBuf(2);
  int numMethods=methods.size();
  setUShort(buf,offset,numMethods);
  for (int i=0; i < numMethods; i++) {
    emitElement(methods.get(i));
  }
  offset=reserveBuf(2);
  int numAttrs=classAttributes.size();
  setUShort(buf,offset,numAttrs);
  for (int i=0; i < numAttrs; i++) {
    emitElement(classAttributes.get(i));
  }
  if (buf.length == bufLen) {
    return buf;
  }
 else {
    byte[] b=new byte[bufLen];
    System.arraycopy(buf,0,b,0,bufLen);
    return b;
  }
}","/** 
 * After you've added everything you need to the class, call this method to generate the actual class file data. This can only be called once.
 */
public byte[] makeBytes() throws IllegalArgumentException {
  if (buf != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (thisClass == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  reserveBuf(10);
  setInt(buf,0,MAGIC);
  setUShort(buf,4,minorVersion);
  setUShort(buf,6,majorVersion);
  emitConstantPool();
  setUShort(buf,8,nextCPIndex);
  cachedCPEntries=null;
  int offset=reserveBuf(8);
  setUShort(buf,offset,accessFlags);
  setUShort(buf,offset + 2,thisClass);
  setUShort(buf,offset + 4,superClass);
  if (superInterfaces != null) {
    setUShort(buf,offset + 6,superInterfaces.length);
    reserveBuf(superInterfaces.length * 2);
    for (int i=0; i < superInterfaces.length; i++) {
      setUShort(buf,offset + 8 + i * 2,superInterfaces[i]);
    }
  }
 else {
    setUShort(buf,offset + 6,0);
  }
  offset=reserveBuf(2);
  int numFields=fields.size();
  setUShort(buf,offset,numFields);
  for (int i=0; i < numFields; i++) {
    emitElement(fields.get(i));
  }
  offset=reserveBuf(2);
  int numMethods=methods.size();
  setUShort(buf,offset,numMethods);
  for (int i=0; i < numMethods; i++) {
    emitElement(methods.get(i));
  }
  offset=reserveBuf(2);
  int numAttrs=classAttributes.size();
  setUShort(buf,offset,numAttrs);
  for (int i=0; i < numAttrs; i++) {
    emitElement(classAttributes.get(i));
  }
  if (buf.length == bufLen) {
    return buf;
  }
 else {
    byte[] b=new byte[bufLen];
    System.arraycopy(buf,0,b,0,bufLen);
    return b;
  }
}",0.9900271985494108
100590,"public int getSize(){
  verify();
  int size=14 + code.length + 2+ (exnHandlers == null ? 0 : exnHandlers.length) * 2 + 2;
  if (attributes != null) {
    for (int i=0; i < attributes.length; i++) {
      size+=attributes[i].getSize();
    }
  }
  return size;
}","public int getSize() throws IllegalArgumentException {
  verify();
  int size=14 + code.length + 2+ (exnHandlers == null ? 0 : exnHandlers.length) * 2 + 2;
  if (attributes != null) {
    for (int i=0; i < attributes.length; i++) {
      size+=attributes[i].getSize();
    }
  }
  return size;
}",0.940754039497307
100591,"public int copyInto(byte[] buf,int offset){
  verify();
  int start=offset;
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setUShort(buf,offset + 6,maxStack);
  ClassWriter.setUShort(buf,offset + 8,maxLocals);
  ClassWriter.setInt(buf,offset + 10,code.length);
  offset+=14;
  System.arraycopy(code,0,buf,offset,code.length);
  offset+=code.length;
  ClassWriter.setUShort(buf,offset,(exnHandlers == null ? 0 : exnHandlers.length) / 4);
  offset+=2;
  if (exnHandlers != null) {
    for (int i=0; i < exnHandlers.length; i++) {
      ClassWriter.setUShort(buf,offset,exnHandlers[i]);
      offset+=2;
    }
  }
  ClassWriter.setUShort(buf,offset,(attributes == null ? 0 : attributes.length));
  offset+=2;
  if (attributes != null) {
    for (int i=0; i < attributes.length; i++) {
      offset=attributes[i].copyInto(buf,offset);
    }
  }
  ClassWriter.setInt(buf,start + 2,offset - start - 6);
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  verify();
  int start=offset;
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setUShort(buf,offset + 6,maxStack);
  ClassWriter.setUShort(buf,offset + 8,maxLocals);
  ClassWriter.setInt(buf,offset + 10,code.length);
  offset+=14;
  System.arraycopy(code,0,buf,offset,code.length);
  offset+=code.length;
  ClassWriter.setUShort(buf,offset,(exnHandlers == null ? 0 : exnHandlers.length) / 4);
  offset+=2;
  if (exnHandlers != null) {
    for (int i=0; i < exnHandlers.length; i++) {
      ClassWriter.setUShort(buf,offset,exnHandlers[i]);
      offset+=2;
    }
  }
  ClassWriter.setUShort(buf,offset,(attributes == null ? 0 : attributes.length));
  offset+=2;
  if (attributes != null) {
    for (int i=0; i < attributes.length; i++) {
      offset=attributes[i].copyInto(buf,offset);
    }
  }
  ClassWriter.setInt(buf,start + 2,offset - start - 6);
  return offset;
}",0.9824933687002652
100592,"public int copyInto(byte[] buf,int offset){
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,getSize() - 6);
  ClassWriter.setUShort(buf,offset + 6,table == null ? 0 : table.length);
  offset+=8;
  if (table != null) {
    for (int i=0; i < table.length; i++) {
      ClassWriter.setUShort(buf,offset,table[i]);
      offset+=2;
    }
  }
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,getSize() - 6);
  ClassWriter.setUShort(buf,offset + 6,table == null ? 0 : table.length);
  offset+=8;
  if (table != null) {
    for (int i=0; i < table.length; i++) {
      ClassWriter.setUShort(buf,offset,table[i]);
      offset+=2;
    }
  }
  return offset;
}",0.9592088998763906
100593,"public int copyInto(byte[] buf,int offset){
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2 + rawTable.length * 2);
  ClassWriter.setUShort(buf,offset + 6,rawTable.length / 2);
  offset+=8;
  for (int i=0; i < rawTable.length; i++) {
    ClassWriter.setUShort(buf,offset,rawTable[i]);
    offset+=2;
  }
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2 + rawTable.length * 2);
  ClassWriter.setUShort(buf,offset + 6,rawTable.length / 2);
  offset+=8;
  for (int i=0; i < rawTable.length; i++) {
    ClassWriter.setUShort(buf,offset,rawTable[i]);
    offset+=2;
  }
  return offset;
}",0.9557046979865772
100594,"public int copyInto(byte[] buf,int offset){
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2 + rawTable.length * 2);
  ClassWriter.setUShort(buf,offset + 6,rawTable.length / 5);
  offset+=8;
  for (int i=0; i < rawTable.length; i++) {
    ClassWriter.setUShort(buf,offset,rawTable[i]);
    offset+=2;
  }
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,2 + rawTable.length * 2);
  ClassWriter.setUShort(buf,offset + 6,rawTable.length / 5);
  offset+=8;
  for (int i=0; i < rawTable.length; i++) {
    ClassWriter.setUShort(buf,offset,rawTable[i]);
    offset+=2;
  }
  return offset;
}",0.9557046979865772
100595,"public int copyInto(byte[] buf,int offset){
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,getSize() - 6);
  offset+=6;
  if (table != null) {
    for (int i=0; i < table.length; i++) {
      ClassWriter.setUByte(buf,offset,table[i]);
      offset++;
    }
  }
  return offset;
}","public int copyInto(byte[] buf,int offset) throws IllegalArgumentException {
  ClassWriter.setUShort(buf,offset,attrID);
  ClassWriter.setInt(buf,offset + 2,getSize() - 6);
  offset+=6;
  if (table != null) {
    for (int i=0; i < table.length; i++) {
      ClassWriter.setUByte(buf,offset,table[i]);
      offset++;
    }
  }
  return offset;
}",0.9497716894977168
100596,"public int getSize(){
  verify();
  return 8;
}","public int getSize() throws IllegalArgumentException {
  verify();
  return 8;
}",0.7401574803149606
100597,"public Module asModule(){
  Assertions.UNREACHABLE();
  return null;
}","public Module asModule() throws UnimplementedError {
  Assertions.UNREACHABLE(""String_Node_Str"");
  return null;
}",0.7608695652173914
100598,"/** 
 * @param gen the intset of facts which are gen'ned by this flow function
 */
private VectorGenFlowFunction(SparseIntSet gen){
  this.gen=gen;
  if (Assertions.verifyAssertions) {
    Assertions._assert(gen.contains(0));
  }
}","/** 
 * @param gen the intset of facts which are gen'ned by this flow function
 */
private VectorGenFlowFunction(SparseIntSet gen){
  this.gen=gen;
}",0.7842105263157895
100599,"/** 
 * @param cmd
 * @throws WalaException
 */
protected Process spawnProcess(String cmd) throws WalaException {
  System.out.println(""String_Node_Str"" + cmd);
  String[] env=getEnv() == null ? null : buildEnv(getEnv());
  try {
    Process p=Runtime.getRuntime().exec(cmd,env,getWorkingDir());
    return p;
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new WalaException(""String_Node_Str"" + getClass());
  }
}","/** 
 * @param cmd
 * @throws WalaException
 */
protected Process spawnProcess(String cmd) throws WalaException, IllegalArgumentException {
  if (cmd == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + cmd);
  String[] env=getEnv() == null ? null : buildEnv(getEnv());
  try {
    Process p=Runtime.getRuntime().exec(cmd,env,getWorkingDir());
    return p;
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new WalaException(""String_Node_Str"" + getClass());
  }
}",0.8521560574948666
100600,"public TypeReference getConstantType(Object S){
  Class<? extends Object> key=(S == null) ? null : S.getClass();
  if (Assertions.verifyAssertions && !constantTypes.containsKey(key)) {
    Assertions._assert(constantTypes.containsKey(key),""String_Node_Str"" + S + ""String_Node_Str""+ key);
  }
  return constantTypes.get(key);
}","/** 
 * TODO: what is this and why is it here?
 */
public TypeReference getConstantType(Object S){
  Class<? extends Object> key=(S == null) ? null : S.getClass();
  if (Assertions.verifyAssertions && !constantTypes.containsKey(key)) {
    Assertions._assert(constantTypes.containsKey(key),""String_Node_Str"" + S + ""String_Node_Str""+ key);
  }
  return constantTypes.get(key);
}",0.9274537695590328
100601,"/** 
 * create a Properties object representing the properties set by the command line args. if args[i] is ""-foo"" and args[i+1] is ""bar"", then the result will define a property with key ""foo"" and value ""bar""
 * @throws WalaException
 */
public static Properties parse(String[] args) throws WalaException {
  Properties result=new Properties();
  for (int i=0; i < args.length - 1; i++) {
    String key=parseForKey(args[i]);
    if (key != null) {
      if (args[i].contains(""String_Node_Str"")) {
        result.put(key,args[i].substring(args[i].indexOf('=') + 1));
      }
 else {
        if (args[i + 1].charAt(0) == '-') {
          throw new WalaException(""String_Node_Str"");
        }
        result.put(key,args[i + 1]);
        i++;
      }
    }
  }
  return result;
}","/** 
 * create a Properties object representing the properties set by the command line args. if args[i] is ""-foo"" and args[i+1] is ""bar"", then the result will define a property with key ""foo"" and value ""bar""
 * @throws WalaException
 */
public static Properties parse(String[] args) throws WalaException {
  Properties result=new Properties();
  for (int i=0; i < args.length; i++) {
    String key=parseForKey(args[i]);
    if (key != null) {
      if (args[i].contains(""String_Node_Str"")) {
        result.put(key,args[i].substring(args[i].indexOf('=') + 1));
      }
 else {
        if ((i + 1) >= args.length || args[i + 1].charAt(0) == '-') {
          throw new WalaException(""String_Node_Str"");
        }
        result.put(key,args[i + 1]);
        i++;
      }
    }
  }
  return result;
}",0.9809402795425668
100602,"private void runBitsetTest(MutableIntSetFactory p,MutableIntSetFactory s) throws ClassHierarchyException {
  MutableIntSetFactory save=IntSetUtil.getDefaultIntSetFactory();
  IntSetUtil.setDefaultIntSetFactory(new DebuggingMutableIntSetFactory(p,s));
  graphTest.testJLex();
  IntSetUtil.setDefaultIntSetFactory(save);
}","private void runBitsetTest(MutableIntSetFactory p,MutableIntSetFactory s) throws ClassHierarchyException {
  MutableIntSetFactory save=IntSetUtil.getDefaultIntSetFactory();
  try {
    IntSetUtil.setDefaultIntSetFactory(new DebuggingMutableIntSetFactory(p,s));
    graphTest.testJLex();
  }
  finally {
    IntSetUtil.setDefaultIntSetFactory(save);
  }
}",0.9495548961424332
100603,"private void fixAfterSparseInsert(){
  if (sparseInsertCount++ > SPARSE_INSERT_THRESHOLD) {
    sparseInsertCount=0;
    IntIterator sparseBits=sparsePart.intIterator();
    int thisBit=sparseBits.next();
    if (densePart == null) {
      int maxOffset=-1;
      int maxCount=-1;
      int maxMax=-1;
      int offset=thisBit;
      int bits=32;
      int count=1;
      while (sparseBits.hasNext()) {
        int nextBit=sparseBits.next();
        int newBits=bits + (nextBit - thisBit);
        int newCount=count + 1;
        if (newBits > (32 * newCount)) {
          count=newCount;
          bits=newBits;
        }
 else         if (bits > 32 * count) {
          if (count > maxCount) {
            maxOffset=offset;
            maxMax=thisBit;
            maxCount=count;
          }
          offset=nextBit;
          count=1;
          bits=32;
        }
        thisBit=nextBit;
      }
      if (maxOffset != -1) {
        densePart=new OffsetBitVector(maxOffset,maxMax - maxOffset);
        sparseBits=sparsePart.intIterator();
        while ((sparseBits.next()) != maxOffset)         ;
        for (int i=0; i < maxCount; i++) {
          densePart.set(sparseBits.next());
        }
        for (int bit1=densePart.nextSetBit(0); bit1 != -1; bit1=densePart.nextSetBit(bit1 + 1)) {
          sparsePart.remove(bit1);
        }
      }
    }
 else {
      int moveCount=0;
      int newOffset=-1;
      int newLength=-1;
      if (thisBit < densePart.getOffset()) {
        newOffset=thisBit;
        int bits=32;
        int count=1;
        while (sparseBits.hasNext()) {
          int nextBit=sparseBits.next();
          if (nextBit >= densePart.getOffset()) {
            if (bits > (32 * count)) {
              moveCount+=count;
              break;
            }
 else {
              newOffset=-1;
            }
          }
 else {
            bits+=(nextBit - thisBit);
            count++;
            if (bits > (32 * count)) {
              newOffset=nextBit;
              count=1;
              bits=32;
            }
          }
        }
      }
      if (thisBit >= densePart.length()) {
        int count=1;
        int bits=(thisBit + 1 - densePart.length());
        if (32 * count > bits) {
          newLength=thisBit;
        }
        while (sparseBits.hasNext()) {
          thisBit=sparseBits.next();
          count++;
          bits=(thisBit + 1 - densePart.length());
          newLength=(32 * count > bits) ? thisBit : newLength;
        }
        if (newLength > -1) {
          moveCount+=count;
        }
      }
      if (newOffset != -1 || newLength != -1) {
        int index=0;
        int[] bits=new int[moveCount];
        for (sparseBits=sparsePart.intIterator(); sparseBits.hasNext(); ) {
          int bit=sparseBits.next();
          if (newOffset != -1 && bit >= newOffset && bit <= densePart.getOffset()) {
            bits[index++]=bit;
          }
          if (newLength != -1 && bit >= densePart.length() && bit <= newLength) {
            bits[index++]=bit;
          }
        }
        for (int i=0; i < moveCount; i++) {
          sparsePart.remove(bits[i]);
          densePart.set(bits[i]);
        }
      }
    }
  }
}","private void fixAfterSparseInsert(){
  if (sparseInsertCount++ > SPARSE_INSERT_THRESHOLD) {
    sparseInsertCount=0;
    IntIterator sparseBits=sparsePart.intIterator();
    int thisBit=sparseBits.next();
    if (densePart == null) {
      int maxOffset=-1;
      int maxCount=-1;
      int maxMax=-1;
      int offset=thisBit;
      int bits=32;
      int count=1;
      while (sparseBits.hasNext()) {
        int nextBit=sparseBits.next();
        int newBits=bits + (nextBit - thisBit);
        int newCount=count + 1;
        if (newBits < (32 * newCount)) {
          count=newCount;
          bits=newBits;
          if (count > maxCount) {
            maxOffset=offset;
            maxMax=nextBit;
            maxCount=count;
          }
        }
 else         if (bits < 32 * count) {
          offset=nextBit;
          count=1;
          bits=32;
        }
        thisBit=nextBit;
      }
      if (maxOffset != -1) {
        densePart=new OffsetBitVector(maxOffset,maxMax - maxOffset);
        sparseBits=sparsePart.intIterator();
        int bit;
        while ((bit=sparseBits.next()) != maxOffset)         ;
        densePart.set(bit);
        for (int i=1; i < maxCount; i++) {
          densePart.set(sparseBits.next());
        }
        for (int bit1=densePart.nextSetBit(0); bit1 != -1; bit1=densePart.nextSetBit(bit1 + 1)) {
          sparsePart.remove(bit1);
        }
      }
    }
 else {
      int moveCount=0;
      int newOffset=-1;
      int newCount=-1;
      int newLength=-1;
      if (thisBit < densePart.getOffset()) {
        newOffset=thisBit;
        int bits=32;
        int count=1;
        while (sparseBits.hasNext()) {
          int nextBit=sparseBits.next();
          if (nextBit >= densePart.getOffset() || !sparseBits.hasNext()) {
            if (!sparseBits.hasNext())             count++;
            if (densePart.getOffset() - newOffset < (32 * count)) {
              moveCount+=count;
            }
 else {
              newOffset=-1;
            }
            thisBit=nextBit;
            break;
          }
 else {
            bits+=(nextBit - thisBit);
            count++;
            if (bits > (32 * count)) {
              newOffset=nextBit;
              count=1;
              bits=32;
            }
            thisBit=nextBit;
          }
        }
      }
      while (thisBit < densePart.length() && sparseBits.hasNext()) {
        thisBit=sparseBits.next();
      }
      if (thisBit >= densePart.length()) {
        int count=1;
        int bits=(thisBit + 1 - densePart.length());
        if (32 * count > bits) {
          newLength=thisBit;
          newCount=1;
        }
        while (sparseBits.hasNext()) {
          thisBit=sparseBits.next();
          count++;
          bits=(thisBit + 1 - densePart.length());
          newLength=((32 * count) > bits) ? thisBit : newLength;
          newCount=((32 * count) > bits) ? count : newCount;
        }
        if (newLength > -1) {
          moveCount+=newCount;
        }
      }
      if (newOffset != -1 || newLength != -1) {
        int index=0;
        int[] bits=new int[moveCount];
        for (sparseBits=sparsePart.intIterator(); sparseBits.hasNext(); ) {
          int bit=sparseBits.next();
          if (newOffset != -1 && bit >= newOffset && bit < densePart.getOffset()) {
            bits[index++]=bit;
          }
          if (newLength != -1 && bit >= densePart.length() && bit <= newLength) {
            bits[index++]=bit;
          }
        }
        for (int i=0; i < moveCount; i++) {
          sparsePart.remove(bits[i]);
          densePart.set(bits[i]);
        }
      }
    }
  }
}",0.8653085153158435
100604,"/** 
 * Remove an integer from this set.
 * @param i integer to remove
 * @return true iff the value of this changes.
 */
public boolean remove(int i){
  if (densePart != null && densePart.get(i)) {
    densePart.clear(i);
    return true;
  }
 else   if (sparsePart.contains(i)) {
    sparsePart.remove(i);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Remove an integer from this set.
 * @param i integer to remove
 * @return true iff the value of this changes.
 */
public boolean remove(int i){
  if (densePart != null && densePart.get(i)) {
    densePart.clear(i);
    if (densePart.populationCount() == 0) {
      densePart=null;
    }
    return true;
  }
 else   if (sparsePart.contains(i)) {
    sparsePart.remove(i);
    return true;
  }
 else {
    return false;
  }
}",0.8762626262626263
100605,"public Iterator<? extends Statement> getPredNodes(Statement N){
  if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
    Assertions._assert(!N.getKind().equals(Kind.EXC_RET_CALLEE));
    Assertions._assert(!N.getKind().equals(Kind.EXC_RET_CALLER));
  }
switch (N.getKind()) {
case NORMAL:
case PHI:
case PI:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
case PARAM_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case CATCH:
    return getPDG(N.getNode()).getPredNodes(N);
case EXC_RET_CALLER:
{
    ParamStatement.ExceptionalReturnCaller nrc=(ParamStatement.ExceptionalReturnCaller)N;
    SSAInvokeInstruction call=nrc.getCall();
    Collection<Statement> result=HashSetFactory.make(5);
    if (!dOptions.equals(DataDependenceOptions.NONE)) {
      for (      CGNode t : N.getNode().getPossibleTargets(call.getCallSite())) {
        Statement s=new ParamStatement.ExceptionalReturnCallee(t);
        addNode(s);
        result.add(s);
      }
    }
    return result.iterator();
  }
case NORMAL_RET_CALLER:
{
  ParamStatement.NormalReturnCaller nrc=(ParamStatement.NormalReturnCaller)N;
  SSAInvokeInstruction call=nrc.getCall();
  Collection<Statement> result=HashSetFactory.make(5);
  if (!dOptions.equals(DataDependenceOptions.NONE)) {
    for (    CGNode t : N.getNode().getPossibleTargets(call.getCallSite())) {
      Statement s=new ParamStatement.NormalReturnCallee(t);
      addNode(s);
      result.add(s);
    }
  }
  return result.iterator();
}
case HEAP_RET_CALLER:
{
HeapStatement.ReturnCaller r=(HeapStatement.ReturnCaller)N;
SSAInvokeInstruction call=r.getCall();
Collection<Statement> result=new Iterator2Collection<Statement>(getPDG(N.getNode()).getPredNodes(N));
if (!dOptions.equals(DataDependenceOptions.NONE)) {
  for (  CGNode t : N.getNode().getPossibleTargets(call.getCallSite())) {
    if (mod.get(t).contains(r.getLocation())) {
      Statement s=new HeapStatement.ReturnCallee(t,r.getLocation());
      addNode(s);
      result.add(s);
    }
  }
}
return result.iterator();
}
case PARAM_CALLEE:
{
ParamStatement.ParamCallee pac=(ParamStatement.ParamCallee)N;
int parameterIndex=pac.getValueNumber() - 1;
Collection<Statement> result=HashSetFactory.make(5);
if (!dOptions.equals(DataDependenceOptions.NONE)) {
for (Iterator<? extends CGNode> it=cg.getPredNodes(N.getNode()); it.hasNext(); ) {
  CGNode caller=it.next();
  for (Iterator<CallSiteReference> it2=caller.getPossibleSites(N.getNode()); it2.hasNext(); ) {
    CallSiteReference site=it2.next();
    IR ir=caller.getIR(new WarningSet());
    IntSet indices=ir.getCallInstructionIndices(site);
    for (IntIterator ii=indices.intIterator(); ii.hasNext(); ) {
      int i=ii.next();
      SSAInvokeInstruction call=(SSAInvokeInstruction)ir.getInstructions()[i];
      int p=call.getUse(parameterIndex);
      Statement s=new ParamStatement.ParamCaller(caller,call,p);
      addNode(s);
      result.add(s);
    }
  }
}
}
if (!cOptions.equals(ControlDependenceOptions.NONE)) {
Statement s=new MethodEntryStatement(N.getNode());
addNode(s);
result.add(s);
}
return result.iterator();
}
case HEAP_PARAM_CALLEE:
{
HeapStatement.ParamCallee hpc=(HeapStatement.ParamCallee)N;
Collection<Statement> result=HashSetFactory.make(5);
if (!dOptions.equals(DataDependenceOptions.NONE)) {
for (Iterator<? extends CGNode> it=cg.getPredNodes(N.getNode()); it.hasNext(); ) {
CGNode caller=it.next();
for (Iterator<CallSiteReference> it2=caller.getPossibleSites(N.getNode()); it2.hasNext(); ) {
  CallSiteReference site=it2.next();
  IR ir=caller.getIR(new WarningSet());
  IntSet indices=ir.getCallInstructionIndices(site);
  for (IntIterator ii=indices.intIterator(); ii.hasNext(); ) {
    int i=ii.next();
    SSAInvokeInstruction call=(SSAInvokeInstruction)ir.getInstructions()[i];
    Statement s=new HeapStatement.ParamCaller(caller,call,hpc.getLocation());
    addNode(s);
    result.add(s);
  }
}
}
}
if (!cOptions.equals(ControlDependenceOptions.NONE)) {
Statement s=new MethodEntryStatement(N.getNode());
addNode(s);
result.add(s);
}
return result.iterator();
}
case METHOD_ENTRY:
Collection<Statement> result=HashSetFactory.make(5);
if (!cOptions.equals(ControlDependenceOptions.NONE)) {
for (Iterator<? extends CGNode> it=cg.getPredNodes(N.getNode()); it.hasNext(); ) {
CGNode caller=it.next();
PDG pdg=getPDG(caller);
for (Iterator<CallSiteReference> it2=caller.getPossibleSites(N.getNode()); it2.hasNext(); ) {
CallSiteReference site=it2.next();
IR ir=caller.getIR(new WarningSet());
IntSet indices=ir.getCallInstructionIndices(site);
for (IntIterator ii=indices.intIterator(); ii.hasNext(); ) {
int i=ii.next();
SSAInvokeInstruction call=(SSAInvokeInstruction)ir.getInstructions()[i];
Statement s=pdg.ssaInstruction2Statement(call);
addNode(s);
result.add(s);
}
}
}
}
return result.iterator();
default :
Assertions.UNREACHABLE(N.getKind().toString());
return null;
}
}","public Iterator<? extends Statement> getPredNodes(Statement N){
  if (Assertions.verifyAssertions && dOptions.isIgnoreExceptions()) {
    Assertions._assert(!N.getKind().equals(Kind.EXC_RET_CALLEE));
    Assertions._assert(!N.getKind().equals(Kind.EXC_RET_CALLER));
  }
switch (N.getKind()) {
case NORMAL:
case PHI:
case PI:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
case PARAM_CALLER:
case HEAP_PARAM_CALLER:
case HEAP_RET_CALLEE:
case CATCH:
    return getPDG(N.getNode()).getPredNodes(N);
case EXC_RET_CALLER:
{
    ParamStatement.ExceptionalReturnCaller nrc=(ParamStatement.ExceptionalReturnCaller)N;
    SSAInvokeInstruction call=nrc.getCall();
    Collection<Statement> result=new Iterator2Collection<Statement>(getPDG(N.getNode()).getPredNodes(N));
    if (!dOptions.equals(DataDependenceOptions.NONE)) {
      for (      CGNode t : N.getNode().getPossibleTargets(call.getCallSite())) {
        Statement s=new ParamStatement.ExceptionalReturnCallee(t);
        addNode(s);
        result.add(s);
      }
    }
    return result.iterator();
  }
case NORMAL_RET_CALLER:
{
  ParamStatement.NormalReturnCaller nrc=(ParamStatement.NormalReturnCaller)N;
  SSAInvokeInstruction call=nrc.getCall();
  Collection<Statement> result=new Iterator2Collection<Statement>(getPDG(N.getNode()).getPredNodes(N));
  if (!dOptions.equals(DataDependenceOptions.NONE)) {
    for (    CGNode t : N.getNode().getPossibleTargets(call.getCallSite())) {
      Statement s=new ParamStatement.NormalReturnCallee(t);
      addNode(s);
      result.add(s);
    }
  }
  return result.iterator();
}
case HEAP_RET_CALLER:
{
HeapStatement.ReturnCaller r=(HeapStatement.ReturnCaller)N;
SSAInvokeInstruction call=r.getCall();
Collection<Statement> result=new Iterator2Collection<Statement>(getPDG(N.getNode()).getPredNodes(N));
if (!dOptions.equals(DataDependenceOptions.NONE)) {
  for (  CGNode t : N.getNode().getPossibleTargets(call.getCallSite())) {
    if (mod.get(t).contains(r.getLocation())) {
      Statement s=new HeapStatement.ReturnCallee(t,r.getLocation());
      addNode(s);
      result.add(s);
    }
  }
}
return result.iterator();
}
case PARAM_CALLEE:
{
ParamStatement.ParamCallee pac=(ParamStatement.ParamCallee)N;
int parameterIndex=pac.getValueNumber() - 1;
Collection<Statement> result=HashSetFactory.make(5);
if (!dOptions.equals(DataDependenceOptions.NONE)) {
for (Iterator<? extends CGNode> it=cg.getPredNodes(N.getNode()); it.hasNext(); ) {
  CGNode caller=it.next();
  for (Iterator<CallSiteReference> it2=caller.getPossibleSites(N.getNode()); it2.hasNext(); ) {
    CallSiteReference site=it2.next();
    IR ir=caller.getIR(new WarningSet());
    IntSet indices=ir.getCallInstructionIndices(site);
    for (IntIterator ii=indices.intIterator(); ii.hasNext(); ) {
      int i=ii.next();
      SSAInvokeInstruction call=(SSAInvokeInstruction)ir.getInstructions()[i];
      int p=call.getUse(parameterIndex);
      Statement s=new ParamStatement.ParamCaller(caller,call,p);
      addNode(s);
      result.add(s);
    }
  }
}
}
if (!cOptions.equals(ControlDependenceOptions.NONE)) {
Statement s=new MethodEntryStatement(N.getNode());
addNode(s);
result.add(s);
}
return result.iterator();
}
case HEAP_PARAM_CALLEE:
{
HeapStatement.ParamCallee hpc=(HeapStatement.ParamCallee)N;
Collection<Statement> result=HashSetFactory.make(5);
if (!dOptions.equals(DataDependenceOptions.NONE)) {
for (Iterator<? extends CGNode> it=cg.getPredNodes(N.getNode()); it.hasNext(); ) {
CGNode caller=it.next();
for (Iterator<CallSiteReference> it2=caller.getPossibleSites(N.getNode()); it2.hasNext(); ) {
  CallSiteReference site=it2.next();
  IR ir=caller.getIR(new WarningSet());
  IntSet indices=ir.getCallInstructionIndices(site);
  for (IntIterator ii=indices.intIterator(); ii.hasNext(); ) {
    int i=ii.next();
    SSAInvokeInstruction call=(SSAInvokeInstruction)ir.getInstructions()[i];
    Statement s=new HeapStatement.ParamCaller(caller,call,hpc.getLocation());
    addNode(s);
    result.add(s);
  }
}
}
}
if (!cOptions.equals(ControlDependenceOptions.NONE)) {
Statement s=new MethodEntryStatement(N.getNode());
addNode(s);
result.add(s);
}
return result.iterator();
}
case METHOD_ENTRY:
Collection<Statement> result=HashSetFactory.make(5);
if (!cOptions.equals(ControlDependenceOptions.NONE)) {
for (Iterator<? extends CGNode> it=cg.getPredNodes(N.getNode()); it.hasNext(); ) {
CGNode caller=it.next();
PDG pdg=getPDG(caller);
for (Iterator<CallSiteReference> it2=caller.getPossibleSites(N.getNode()); it2.hasNext(); ) {
CallSiteReference site=it2.next();
IR ir=caller.getIR(new WarningSet());
IntSet indices=ir.getCallInstructionIndices(site);
for (IntIterator ii=indices.intIterator(); ii.hasNext(); ) {
int i=ii.next();
SSAInvokeInstruction call=(SSAInvokeInstruction)ir.getInstructions()[i];
Statement s=pdg.ssaInstruction2Statement(call);
addNode(s);
result.add(s);
}
}
}
}
return result.iterator();
default :
Assertions.UNREACHABLE(N.getKind().toString());
return null;
}
}",0.9815040650406504
100606,"public String toString(){
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"");
  for (int i=0; i < getMaxNumber(); i++) {
    Object node=getNode(i);
    if (node != null) {
      result.append(i).append(""String_Node_Str"").append(node).append(""String_Node_Str"");
    }
  }
  result.append(""String_Node_Str"");
  for (int i=0; i < getMaxNumber(); i++) {
    Object node=getNode(i);
    if (node != null) {
      result.append(i).append(""String_Node_Str"");
      for (Iterator it=getSuccNodes(node); it.hasNext(); ) {
        Object s=it.next();
        result.append(getNumber(s)).append(""String_Node_Str"");
      }
      result.append(""String_Node_Str"");
    }
  }
  return result.toString();
}","public String toString(){
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"");
  for (int i=0; i <= getMaxNumber(); i++) {
    Object node=getNode(i);
    if (node != null) {
      result.append(i).append(""String_Node_Str"").append(node).append(""String_Node_Str"");
    }
  }
  result.append(""String_Node_Str"");
  for (int i=0; i <= getMaxNumber(); i++) {
    Object node=getNode(i);
    if (node != null) {
      result.append(i).append(""String_Node_Str"");
      for (Iterator it=getSuccNodes(node); it.hasNext(); ) {
        Object s=it.next();
        result.append(getNumber(s)).append(""String_Node_Str"");
      }
      result.append(""String_Node_Str"");
    }
  }
  return result.toString();
}",0.9986091794158554
100607,"/** 
 * Process attributes
 * @param qName element name
 * @param atts input attributes
 * @param res attributes to write to
 */
private void processAttributes(final String qName,final Attributes atts,final AttributesImpl res){
  final int attsLen=atts.getLength();
  for (int i=0; i < attsLen; i++) {
    final QName attQName=new QName(atts.getURI(i),atts.getLocalName(i));
    final String origValue=atts.getValue(i);
    String attValue=origValue;
    if (ATTRIBUTE_NAME_CONREF.equals(attQName)) {
      attValue=replaceHREF(QName.valueOf(ATTRIBUTE_NAME_CONREF),atts).toString();
    }
 else     if (ATTRIBUTE_NAME_HREF.equals(attQName) || ATTRIBUTE_NAME_COPY_TO.equals(attQName)) {
      if (atts.getValue(ATTRIBUTE_NAME_SCOPE) == null || atts.getValue(ATTRIBUTE_NAME_SCOPE).equals(ATTR_SCOPE_VALUE_LOCAL)) {
        attValue=replaceHREF(attQName,atts).toString();
      }
    }
 else     if (ATTRIBUTE_NAME_FORMAT.equals(attQName)) {
      final String format=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if (isFormatDita(format)) {
        attValue=ATTR_FORMAT_VALUE_DITA;
      }
    }
 else {
      attValue=getAttributeValue(qName,attQName,attValue);
    }
    XMLUtils.addOrSetAttribute(res,atts.getURI(i),atts.getLocalName(i),atts.getQName(i),atts.getType(i),attValue);
  }
}","/** 
 * Process attributes
 * @param qName element name
 * @param atts input attributes
 * @param res attributes to write to
 */
private void processAttributes(final String qName,final Attributes atts,final AttributesImpl res){
  final int attsLen=atts.getLength();
  for (int i=0; i < attsLen; i++) {
    final QName attQName=new QName(atts.getURI(i),atts.getLocalName(i));
    final String origValue=atts.getValue(i);
    String attValue=origValue;
    if (ATTRIBUTE_NAME_CONREF.equals(attQName.getLocalPart())) {
      attValue=replaceHREF(QName.valueOf(ATTRIBUTE_NAME_CONREF),atts).toString();
    }
 else     if (ATTRIBUTE_NAME_HREF.equals(attQName.getLocalPart()) || ATTRIBUTE_NAME_COPY_TO.equals(attQName.getLocalPart())) {
      if (atts.getValue(ATTRIBUTE_NAME_SCOPE) == null || atts.getValue(ATTRIBUTE_NAME_SCOPE).equals(ATTR_SCOPE_VALUE_LOCAL)) {
        attValue=replaceHREF(attQName,atts).toString();
      }
    }
 else     if (ATTRIBUTE_NAME_FORMAT.equals(attQName.getLocalPart())) {
      final String format=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if (isFormatDita(format)) {
        attValue=ATTR_FORMAT_VALUE_DITA;
      }
    }
 else {
      attValue=getAttributeValue(qName,attQName,attValue);
    }
    XMLUtils.addOrSetAttribute(res,atts.getURI(i),atts.getLocalName(i),atts.getQName(i),atts.getType(i),attValue);
  }
}",0.9771863117870724
100608,"public void readProp(final Element elem){
  final String attAction=elem.getAttribute(ELEMENT_NAME_ACTION);
  Action action;
switch (attAction) {
case ""String_Node_Str"":
    action=Action.INCLUDE;
  break;
case ""String_Node_Str"":
action=Action.EXCLUDE;
break;
case ""String_Node_Str"":
action=Action.PASSTHROUGH;
break;
case ""String_Node_Str"":
action=readFlag(elem);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + attAction);
}
if (action != null) {
final QName attName;
if (elem.getTagName().equals(ELEMENT_NAME_REVPROP)) {
attName=REV;
}
 else {
final String attValue=getValue(elem,ATTRIBUTE_NAME_ATT);
if (attValue != null) {
if (attValue.contains(""String_Node_Str"")) {
final String[] parts=attValue.split(""String_Node_Str"");
final String uri;
if (parts[0].equals(XML_NS_PREFIX)) {
uri=XML_NS_URI;
}
 else {
uri=elem.lookupNamespaceURI(parts[0]);
}
attName=new QName(uri,parts[1],parts[0]);
}
 else {
attName=QName.valueOf(attValue);
}
}
 else {
attName=null;
}
}
if (attName != null && attName.equals(REV) && !filterAttributes.isEmpty() && !filterAttributes.contains(REV)) {
logger.warn(MessageUtils.getMessage(""String_Node_Str"").toString());
return;
}
final String attValue=getValue(elem,ATTRIBUTE_NAME_VAL);
final FilterKey key=attName != null ? new FilterKey(attName,attValue) : DEFAULT;
insertAction(action,key);
}
}","public void readProp(final Element elem){
  final String attAction=elem.getAttribute(ELEMENT_NAME_ACTION);
  Action action;
switch (attAction) {
case ""String_Node_Str"":
    action=Action.INCLUDE;
  break;
case ""String_Node_Str"":
action=Action.EXCLUDE;
break;
case ""String_Node_Str"":
action=Action.PASSTHROUGH;
break;
case ""String_Node_Str"":
action=readFlag(elem);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + attAction);
}
if (action != null) {
final QName attName;
if (elem.getTagName().equals(ELEMENT_NAME_REVPROP)) {
attName=REV;
}
 else {
final String attValue=getValue(elem,ATTRIBUTE_NAME_ATT);
if (attValue != null) {
if (attValue.contains(""String_Node_Str"")) {
final String[] parts=attValue.split(""String_Node_Str"");
final String uri;
if (parts[0].equals(XML_NS_PREFIX)) {
uri=XML_NS_URI;
}
 else {
uri=elem.lookupNamespaceURI(parts[0]);
}
attName=new QName(uri,parts[1],parts[0]);
}
 else {
attName=QName.valueOf(attValue);
}
}
 else {
attName=null;
}
if (attName != null && attName.equals(REV) && !filterAttributes.isEmpty() && !filterAttributes.contains(REV)) {
logger.warn(MessageUtils.getMessage(""String_Node_Str"").toString());
return;
}
}
final String attValue=getValue(elem,ATTRIBUTE_NAME_VAL);
final FilterKey key=attName != null ? new FilterKey(attName,attValue) : DEFAULT;
insertAction(action,key);
}
}",0.99851411589896
100609,"/** 
 * Get the first topic id from the given dita file.
 * @param absolutePathToFile The absolute path to a dita file.
 * @return The first topic id from the given dita file if success, otherwise{@code null} string is returned.
 */
String getFirstTopicId(final String absolutePathToFile){
}","/** 
 * Get the first topic id from the given dita file.
 * @param ditaTopicFile a dita file.
 * @return The first topic id from the given dita file if success, otherwise{@code null} string is returned.
 */
String getFirstTopicId(final File ditaTopicFile){
}",0.8415300546448088
100610,"private void processChunk(final Element topicref,final URI outputFile){
  final URI hrefValue=toURI(getValue(topicref,ATTRIBUTE_NAME_HREF));
  final Collection<String> chunkValue=split(getValue(topicref,ATTRIBUTE_NAME_CHUNK));
  final URI copytoValue=toURI(getValue(topicref,ATTRIBUTE_NAME_COPY_TO));
  final String scopeValue=getCascadeValue(topicref,ATTRIBUTE_NAME_SCOPE);
  final String classValue=getValue(topicref,ATTRIBUTE_NAME_CLASS);
  final String processRoleValue=getCascadeValue(topicref,ATTRIBUTE_NAME_PROCESSING_ROLE);
  URI outputFileName=outputFile;
  Writer tempWriter=null;
  Set<String> tempTopicID=null;
  targetTopicId=null;
  selectMethod=CHUNK_SELECT_DOCUMENT;
  include=false;
  boolean needWriteDitaTag=true;
  try {
    URI parseFilePath;
    if (copytoValue != null && !chunkValue.contains(CHUNK_TO_CONTENT)) {
      if (hrefValue.getFragment() != null) {
        parseFilePath=setFragment(copytoValue,hrefValue.getFragment());
      }
 else {
        parseFilePath=copytoValue;
      }
    }
 else {
      parseFilePath=hrefValue;
    }
    if (parseFilePath != null && !ATTR_SCOPE_VALUE_EXTERNAL.equals(scopeValue)) {
      if (chunkValue.contains(CHUNK_TO_CONTENT)) {
        tempWriter=output;
        tempTopicID=topicID;
        output=new StringWriter();
        topicID=new HashSet<>();
        if (MAP_MAP.matches(classValue)) {
          outputFileName=currentFile.resolve(parseFilePath);
          needWriteDitaTag=false;
        }
 else         if (copytoValue != null) {
          outputFileName=currentFile.resolve(copytoValue);
        }
 else         if (hrefValue != null) {
          if (chunkValue.contains(CHUNK_SELECT_TOPIC) || chunkValue.contains(CHUNK_SELECT_BRANCH)) {
            if (hrefValue.getFragment() != null) {
              outputFileName=currentFile.resolve(hrefValue.getFragment() + FILE_EXTENSION_DITA);
            }
 else {
              final String firstTopic=getFirstTopicId(currentFile.resolve(hrefValue).getPath());
              if (firstTopic != null) {
                outputFileName=currentFile.resolve(firstTopic + FILE_EXTENSION_DITA);
              }
 else {
                outputFileName=currentFile.resolve(hrefValue);
              }
            }
          }
 else {
            outputFileName=currentFile.resolve(hrefValue);
          }
        }
 else {
          outputFileName=generateOutputFile(currentFile);
        }
        if (new File(outputFileName).exists() && !MAP_MAP.matches(classValue)) {
          final URI t=outputFileName;
          outputFileName=generateOutputFile(currentFile);
          conflictTable.put(outputFileName,t);
        }
        changeTable.put(outputFileName,outputFileName);
        final FileInfo fi=generateFileInfo(outputFileName);
        job.add(fi);
      }
      this.outputFile=outputFileName;
      final URI path=currentFile.resolve(parseFilePath);
      URI newpath;
      if (path.getFragment() != null) {
        newpath=setFragment(outputFileName,path.getFragment());
      }
 else {
        final String firstTopicID=getFirstTopicId(new File(path).getAbsolutePath());
        if (firstTopicID != null) {
          newpath=setFragment(outputFileName,firstTopicID);
        }
 else {
          newpath=outputFileName;
        }
      }
      changeTable.put(path,newpath);
      topicref.setAttribute(ATTRIBUTE_NAME_HREF,getRelativePath(currentFile.resolve(FILE_NAME_STUB_DITAMAP),newpath).toString());
      if (parseFilePath.getFragment() != null) {
        targetTopicId=parseFilePath.getFragment();
      }
      final String s=getChunkByToken(chunkValue,""String_Node_Str"",null);
      if (s != null) {
        selectMethod=s;
        if (targetTopicId == null) {
          selectMethod=CHUNK_SELECT_DOCUMENT;
        }
      }
      final URI tempPath=currentParsingFile;
      currentParsingFile=currentFile.resolve(parseFilePath);
      if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleValue)) {
        currentParsingFileTopicIDChangeTable=new HashMap<>();
        logger.info(""String_Node_Str"" + currentParsingFile);
        reader.parse(currentParsingFile.toString());
        if (currentParsingFileTopicIDChangeTable.size() > 0) {
          final URI href=toURI(topicref.getAttribute(ATTRIBUTE_NAME_HREF));
          final String pathtoElem=href.getFragment() != null ? href.getFragment() : ""String_Node_Str"";
          final String old_elementid=pathtoElem.contains(SLASH) ? pathtoElem.substring(0,pathtoElem.indexOf(SLASH)) : pathtoElem;
          if (!old_elementid.isEmpty()) {
            final String new_elementid=currentParsingFileTopicIDChangeTable.get(old_elementid);
            if (new_elementid != null && !new_elementid.isEmpty()) {
              topicref.setAttribute(ATTRIBUTE_NAME_HREF,setFragment(href,new_elementid).toString());
            }
          }
        }
        currentParsingFileTopicIDChangeTable=null;
      }
      currentParsingFile=tempPath;
    }
    if (topicref.hasChildNodes()) {
      final StringWriter tempOutput=(StringWriter)output;
      output=new StringWriter();
      final NodeList children=topicref.getChildNodes();
      for (int i=0; i < children.getLength(); i++) {
        final Node current=children.item(i);
        if (MAP_TOPICREF.matches(current)) {
          processChunk((Element)current,outputFileName);
        }
      }
      final StringBuffer parentResult=tempOutput.getBuffer();
      final CharSequence tmpContent=((StringWriter)output).getBuffer();
      if (parentResult.length() > 0 && parseFilePath != null && !ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleValue)) {
        insertAfter(hrefValue,parentResult,tmpContent);
      }
 else {
        parentResult.append(tmpContent);
      }
      output=tempOutput;
    }
    if (chunkValue.contains(CHUNK_TO_CONTENT)) {
      final String tmpContent=output.toString();
      writeToContentChunk(tmpContent,outputFileName,needWriteDitaTag);
      output=tempWriter;
      topicID=tempTopicID;
    }
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
}","private void processChunk(final Element topicref,final URI outputFile){
  final URI hrefValue=toURI(getValue(topicref,ATTRIBUTE_NAME_HREF));
  final Collection<String> chunkValue=split(getValue(topicref,ATTRIBUTE_NAME_CHUNK));
  final URI copytoValue=toURI(getValue(topicref,ATTRIBUTE_NAME_COPY_TO));
  final String scopeValue=getCascadeValue(topicref,ATTRIBUTE_NAME_SCOPE);
  final String classValue=getValue(topicref,ATTRIBUTE_NAME_CLASS);
  final String processRoleValue=getCascadeValue(topicref,ATTRIBUTE_NAME_PROCESSING_ROLE);
  URI outputFileName=outputFile;
  Writer tempWriter=null;
  Set<String> tempTopicID=null;
  targetTopicId=null;
  selectMethod=CHUNK_SELECT_DOCUMENT;
  include=false;
  boolean needWriteDitaTag=true;
  try {
    URI parseFilePath;
    if (copytoValue != null && !chunkValue.contains(CHUNK_TO_CONTENT)) {
      if (hrefValue.getFragment() != null) {
        parseFilePath=setFragment(copytoValue,hrefValue.getFragment());
      }
 else {
        parseFilePath=copytoValue;
      }
    }
 else {
      parseFilePath=hrefValue;
    }
    if (parseFilePath != null && !ATTR_SCOPE_VALUE_EXTERNAL.equals(scopeValue)) {
      if (chunkValue.contains(CHUNK_TO_CONTENT)) {
        tempWriter=output;
        tempTopicID=topicID;
        output=new StringWriter();
        topicID=new HashSet<>();
        if (MAP_MAP.matches(classValue)) {
          outputFileName=currentFile.resolve(parseFilePath);
          needWriteDitaTag=false;
        }
 else         if (copytoValue != null) {
          outputFileName=currentFile.resolve(copytoValue);
        }
 else         if (hrefValue != null) {
          if (chunkValue.contains(CHUNK_SELECT_TOPIC) || chunkValue.contains(CHUNK_SELECT_BRANCH)) {
            if (hrefValue.getFragment() != null) {
              outputFileName=currentFile.resolve(hrefValue.getFragment() + FILE_EXTENSION_DITA);
            }
 else {
              final String firstTopic=getFirstTopicId(new File(stripFragment(currentFile.resolve(hrefValue))));
              if (firstTopic != null) {
                outputFileName=currentFile.resolve(firstTopic + FILE_EXTENSION_DITA);
              }
 else {
                outputFileName=currentFile.resolve(hrefValue);
              }
            }
          }
 else {
            outputFileName=currentFile.resolve(hrefValue);
          }
        }
 else {
          outputFileName=generateOutputFile(currentFile);
        }
        if (new File(outputFileName).exists() && !MAP_MAP.matches(classValue)) {
          final URI t=outputFileName;
          outputFileName=generateOutputFile(currentFile);
          conflictTable.put(outputFileName,t);
        }
        changeTable.put(outputFileName,outputFileName);
        final FileInfo fi=generateFileInfo(outputFileName);
        job.add(fi);
      }
      this.outputFile=outputFileName;
      final URI path=currentFile.resolve(parseFilePath);
      URI newpath;
      if (path.getFragment() != null) {
        newpath=setFragment(outputFileName,path.getFragment());
      }
 else {
        final String firstTopicID=getFirstTopicId(new File(path));
        if (firstTopicID != null) {
          newpath=setFragment(outputFileName,firstTopicID);
        }
 else {
          newpath=outputFileName;
        }
      }
      changeTable.put(path,newpath);
      topicref.setAttribute(ATTRIBUTE_NAME_HREF,getRelativePath(currentFile.resolve(FILE_NAME_STUB_DITAMAP),newpath).toString());
      if (parseFilePath.getFragment() != null) {
        targetTopicId=parseFilePath.getFragment();
      }
      final String s=getChunkByToken(chunkValue,""String_Node_Str"",null);
      if (s != null) {
        selectMethod=s;
        if (targetTopicId == null) {
          selectMethod=CHUNK_SELECT_DOCUMENT;
        }
      }
      final URI tempPath=currentParsingFile;
      currentParsingFile=currentFile.resolve(parseFilePath);
      if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleValue)) {
        currentParsingFileTopicIDChangeTable=new HashMap<>();
        logger.info(""String_Node_Str"" + currentParsingFile);
        reader.parse(currentParsingFile.toString());
        if (currentParsingFileTopicIDChangeTable.size() > 0) {
          final URI href=toURI(topicref.getAttribute(ATTRIBUTE_NAME_HREF));
          final String pathtoElem=href.getFragment() != null ? href.getFragment() : ""String_Node_Str"";
          final String old_elementid=pathtoElem.contains(SLASH) ? pathtoElem.substring(0,pathtoElem.indexOf(SLASH)) : pathtoElem;
          if (!old_elementid.isEmpty()) {
            final String new_elementid=currentParsingFileTopicIDChangeTable.get(old_elementid);
            if (new_elementid != null && !new_elementid.isEmpty()) {
              topicref.setAttribute(ATTRIBUTE_NAME_HREF,setFragment(href,new_elementid).toString());
            }
          }
        }
        currentParsingFileTopicIDChangeTable=null;
      }
      currentParsingFile=tempPath;
    }
    if (topicref.hasChildNodes()) {
      final StringWriter tempOutput=(StringWriter)output;
      output=new StringWriter();
      final NodeList children=topicref.getChildNodes();
      for (int i=0; i < children.getLength(); i++) {
        final Node current=children.item(i);
        if (MAP_TOPICREF.matches(current)) {
          processChunk((Element)current,outputFileName);
        }
      }
      final StringBuffer parentResult=tempOutput.getBuffer();
      final CharSequence tmpContent=((StringWriter)output).getBuffer();
      if (parentResult.length() > 0 && parseFilePath != null && !ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleValue)) {
        insertAfter(hrefValue,parentResult,tmpContent);
      }
 else {
        parentResult.append(tmpContent);
      }
      output=tempOutput;
    }
    if (chunkValue.contains(CHUNK_TO_CONTENT)) {
      final String tmpContent=output.toString();
      writeToContentChunk(tmpContent,outputFileName,needWriteDitaTag);
      output=tempWriter;
      topicID=tempTopicID;
    }
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
}",0.9958336737194674
100611,"@Override public void write(final URI currentFile) throws DITAOTException {
  this.currentFile=currentFile;
  final URI hrefValue=toURI(getValue(rootTopicref,ATTRIBUTE_NAME_HREF));
  final URI copytoValue=toURI(getValue(rootTopicref,ATTRIBUTE_NAME_COPY_TO));
  final String scopeValue=getCascadeValue(rootTopicref,ATTRIBUTE_NAME_SCOPE);
  URI parseFilePath;
  final Collection<String> chunkValue=split(getValue(rootTopicref,ATTRIBUTE_NAME_CHUNK));
  final String processRoleValue=getCascadeValue(rootTopicref,ATTRIBUTE_NAME_PROCESSING_ROLE);
  boolean dotchunk=false;
  if (copytoValue != null) {
    if (hrefValue != null && hrefValue.getFragment() != null) {
      parseFilePath=setFragment(copytoValue,hrefValue.getFragment());
    }
 else {
      parseFilePath=copytoValue;
    }
  }
 else {
    parseFilePath=hrefValue;
  }
  try {
    currentParsingFile=currentFile.resolve(parseFilePath);
    URI outputFileName;
    String id=null;
    String firstTopicID=null;
    if (parseFilePath.getFragment() != null) {
      id=parseFilePath.getFragment();
      if (chunkValue.contains(CHUNK_SELECT_BRANCH)) {
        outputFileName=resolve(currentFile,id + FILE_EXTENSION_DITA);
        targetTopicId=id;
        startFromFirstTopic=false;
        selectMethod=CHUNK_SELECT_BRANCH;
      }
 else       if (chunkValue.contains(CHUNK_SELECT_DOCUMENT)) {
        firstTopicID=getFirstTopicId(currentFile.resolve(parseFilePath).getPath());
        topicDoc=getTopicDoc(currentFile.resolve(parseFilePath));
        if (firstTopicID != null) {
          outputFileName=resolve(currentFile,firstTopicID + FILE_EXTENSION_DITA);
          targetTopicId=firstTopicID;
        }
 else {
          outputFileName=resolve(currentParsingFile,null);
          dotchunk=true;
          targetTopicId=null;
        }
        selectMethod=CHUNK_SELECT_DOCUMENT;
      }
 else {
        outputFileName=resolve(currentFile,id + FILE_EXTENSION_DITA);
        targetTopicId=id;
        startFromFirstTopic=false;
        selectMethod=CHUNK_SELECT_TOPIC;
      }
    }
 else {
      firstTopicID=getFirstTopicId(currentFile.resolve(parseFilePath).getPath());
      topicDoc=getTopicDoc(currentFile.resolve(parseFilePath));
      if (firstTopicID != null) {
        outputFileName=resolve(currentFile,firstTopicID + FILE_EXTENSION_DITA);
        targetTopicId=firstTopicID;
      }
 else {
        outputFileName=resolve(currentParsingFile,null);
        dotchunk=true;
        targetTopicId=null;
      }
      selectMethod=CHUNK_SELECT_DOCUMENT;
    }
    if (copytoValue != null) {
      outputFileName=resolve(currentFile,copytoValue.toString());
    }
    if (new File(outputFileName).exists()) {
      final URI t=outputFileName;
      outputFileName=resolve(currentFile,generateFilename());
      conflictTable.put(outputFileName,t);
      dotchunk=false;
    }
    output=new OutputStreamWriter(new FileOutputStream(new File(outputFileName)),UTF8);
    outputFile=outputFileName;
    if (!dotchunk) {
      final FileInfo fi=generateFileInfo(outputFile);
      job.add(fi);
      changeTable.put(currentFile.resolve(parseFilePath),setFragment(outputFileName,id));
      changeTable.put(outputFileName,outputFileName);
    }
    final URI newHref=setFragment(getRelativePath(currentFile.resolve(FILE_NAME_STUB_DITAMAP),outputFileName),firstTopicID != null ? firstTopicID : id);
    rootTopicref.setAttribute(ATTRIBUTE_NAME_HREF,newHref.toString());
    include=false;
    addStubElements();
    if (rootTopicref.getNextSibling() != null) {
      rootTopicref.getParentNode().insertBefore(siblingStub,rootTopicref.getNextSibling());
    }
 else {
      rootTopicref.getParentNode().appendChild(siblingStub);
    }
    reader.setErrorHandler(new DITAOTXMLErrorHandler(currentParsingFile.getPath(),logger));
    logger.info(""String_Node_Str"" + currentParsingFile);
    reader.parse(currentParsingFile.toString());
    output.flush();
    removeStubElements();
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    try {
      if (output != null) {
        output.close();
        output=null;
        if (dotchunk) {
          final File dst=new File(currentParsingFile);
          final File src=new File(outputFile);
          logger.debug(""String_Node_Str"" + currentParsingFile);
          deleteQuietly(dst);
          logger.debug(""String_Node_Str"" + outputFile + ""String_Node_Str""+ currentParsingFile);
          moveFile(src,dst);
          final FileInfo fi=job.getFileInfo(outputFile);
          if (fi != null) {
            job.remove(fi);
          }
        }
      }
    }
 catch (    final Exception ex) {
      logger.error(ex.getMessage(),ex);
    }
  }
}","@Override public void write(final URI currentFile) throws DITAOTException {
  this.currentFile=currentFile;
  final URI hrefValue=toURI(getValue(rootTopicref,ATTRIBUTE_NAME_HREF));
  final URI copytoValue=toURI(getValue(rootTopicref,ATTRIBUTE_NAME_COPY_TO));
  final String scopeValue=getCascadeValue(rootTopicref,ATTRIBUTE_NAME_SCOPE);
  URI parseFilePath;
  final Collection<String> chunkValue=split(getValue(rootTopicref,ATTRIBUTE_NAME_CHUNK));
  final String processRoleValue=getCascadeValue(rootTopicref,ATTRIBUTE_NAME_PROCESSING_ROLE);
  boolean dotchunk=false;
  if (copytoValue != null) {
    if (hrefValue != null && hrefValue.getFragment() != null) {
      parseFilePath=setFragment(copytoValue,hrefValue.getFragment());
    }
 else {
      parseFilePath=copytoValue;
    }
  }
 else {
    parseFilePath=hrefValue;
  }
  try {
    currentParsingFile=currentFile.resolve(parseFilePath);
    URI outputFileName;
    String id=null;
    String firstTopicID=null;
    if (parseFilePath.getFragment() != null) {
      id=parseFilePath.getFragment();
      if (chunkValue.contains(CHUNK_SELECT_BRANCH)) {
        outputFileName=resolve(currentFile,id + FILE_EXTENSION_DITA);
        targetTopicId=id;
        startFromFirstTopic=false;
        selectMethod=CHUNK_SELECT_BRANCH;
      }
 else       if (chunkValue.contains(CHUNK_SELECT_DOCUMENT)) {
        firstTopicID=getFirstTopicId(new File(stripFragment(currentFile.resolve(parseFilePath))));
        topicDoc=getTopicDoc(currentFile.resolve(parseFilePath));
        if (firstTopicID != null) {
          outputFileName=resolve(currentFile,firstTopicID + FILE_EXTENSION_DITA);
          targetTopicId=firstTopicID;
        }
 else {
          outputFileName=resolve(currentParsingFile,null);
          dotchunk=true;
          targetTopicId=null;
        }
        selectMethod=CHUNK_SELECT_DOCUMENT;
      }
 else {
        outputFileName=resolve(currentFile,id + FILE_EXTENSION_DITA);
        targetTopicId=id;
        startFromFirstTopic=false;
        selectMethod=CHUNK_SELECT_TOPIC;
      }
    }
 else {
      firstTopicID=getFirstTopicId(new File(stripFragment(currentFile.resolve(parseFilePath))));
      topicDoc=getTopicDoc(currentFile.resolve(parseFilePath));
      if (firstTopicID != null) {
        outputFileName=resolve(currentFile,firstTopicID + FILE_EXTENSION_DITA);
        targetTopicId=firstTopicID;
      }
 else {
        outputFileName=resolve(currentParsingFile,null);
        dotchunk=true;
        targetTopicId=null;
      }
      selectMethod=CHUNK_SELECT_DOCUMENT;
    }
    if (copytoValue != null) {
      outputFileName=resolve(currentFile,copytoValue.toString());
    }
    if (new File(outputFileName).exists()) {
      final URI t=outputFileName;
      outputFileName=resolve(currentFile,generateFilename());
      conflictTable.put(outputFileName,t);
      dotchunk=false;
    }
    output=new OutputStreamWriter(new FileOutputStream(new File(outputFileName)),UTF8);
    outputFile=outputFileName;
    if (!dotchunk) {
      final FileInfo fi=generateFileInfo(outputFile);
      job.add(fi);
      changeTable.put(currentFile.resolve(parseFilePath),setFragment(outputFileName,id));
      changeTable.put(outputFileName,outputFileName);
    }
    final URI newHref=setFragment(getRelativePath(currentFile.resolve(FILE_NAME_STUB_DITAMAP),outputFileName),firstTopicID != null ? firstTopicID : id);
    rootTopicref.setAttribute(ATTRIBUTE_NAME_HREF,newHref.toString());
    include=false;
    addStubElements();
    if (rootTopicref.getNextSibling() != null) {
      rootTopicref.getParentNode().insertBefore(siblingStub,rootTopicref.getNextSibling());
    }
 else {
      rootTopicref.getParentNode().appendChild(siblingStub);
    }
    reader.setErrorHandler(new DITAOTXMLErrorHandler(currentParsingFile.getPath(),logger));
    logger.info(""String_Node_Str"" + currentParsingFile);
    reader.parse(currentParsingFile.toString());
    output.flush();
    removeStubElements();
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    try {
      if (output != null) {
        output.close();
        output=null;
        if (dotchunk) {
          final File dst=new File(currentParsingFile);
          final File src=new File(outputFile);
          logger.debug(""String_Node_Str"" + currentParsingFile);
          deleteQuietly(dst);
          logger.debug(""String_Node_Str"" + outputFile + ""String_Node_Str""+ currentParsingFile);
          moveFile(src,dst);
          final FileInfo fi=job.getFileInfo(outputFile);
          if (fi != null) {
            job.remove(fi);
          }
        }
      }
    }
 catch (    final Exception ex) {
      logger.error(ex.getMessage(),ex);
    }
  }
}",0.9930628547403826
100612,"/** 
 * Checks if the closest DITA ancestor <foreign> or <unknown>
 * @param classes stack of class attributes for open elements
 * @return true if closest DITA ancestor is <foreign> or <unknown>, otherwise false
 */
public static boolean nonDitaContext(final Deque<DitaClass> classes){
  final Iterator<DitaClass> it=classes.iterator();
  it.next();
  while (it.hasNext()) {
    final DitaClass cls=it.next();
    if (cls != null && cls.isValid() && (TOPIC_FOREIGN.matches(cls) || TOPIC_UNKNOWN.matches(cls))) {
      return true;
    }
 else     if (cls != null && cls.isValid()) {
      return false;
    }
  }
  return false;
}","/** 
 * Checks if the closest DITA ancestor   {@code <foreign>} or {@code <unknown>}
 * @param classes stack of class attributes for open elements
 * @return true if closest DITA ancestor is {@code <foreign>} or {@code <unknown>}, otherwise false
 */
public static boolean nonDitaContext(final Deque<DitaClass> classes){
  final Iterator<DitaClass> it=classes.iterator();
  it.next();
  while (it.hasNext()) {
    final DitaClass cls=it.next();
    if (cls != null && cls.isValid() && (TOPIC_FOREIGN.matches(cls) || TOPIC_UNKNOWN.matches(cls))) {
      return true;
    }
 else     if (cls != null && cls.isValid()) {
      return false;
    }
  }
  return false;
}",0.964506172839506
100613,"/** 
 * Determines whether the parent directory contains the child element (a file or directory)
 * @param directory the file to consider as the parent
 * @param child the file to consider as the child
 * @return true is the candidate leaf is under by the specified composite, otherwise false
 * @throws IOException
 */
public static boolean directoryContains(final File directory,final File child){
  final File d=new File(normalize(directory.getAbsolutePath()));
  final File c=new File(normalize(child.getAbsolutePath()));
  if (d.equals(c)) {
    return false;
  }
 else {
    return c.getPath().startsWith(d.getPath());
  }
}","/** 
 * Determines whether the parent directory contains the child element (a file or directory)
 * @param directory the file to consider as the parent
 * @param child the file to consider as the child
 * @return true is the candidate leaf is under by the specified composite, otherwise false
 */
public static boolean directoryContains(final File directory,final File child){
  final File d=new File(normalize(directory.getAbsolutePath()));
  final File c=new File(normalize(child.getAbsolutePath()));
  if (d.equals(c)) {
    return false;
  }
 else {
    return c.getPath().startsWith(d.getPath());
  }
}",0.9814066289409864
100614,"/** 
 * Determines whether the parent directory contains the child element (a file or directory)
 * @param directory the file to consider as the parent
 * @param child the file to consider as the child
 * @return true is the candidate leaf is under by the specified composite, otherwise false
 * @throws IOException
 */
public static boolean directoryContains(final URI directory,final URI child){
  final String d=directory.normalize().toString();
  final String c=child.normalize().toString();
  if (d.equals(c)) {
    return false;
  }
 else {
    return c.startsWith(d);
  }
}","/** 
 * Determines whether the parent directory contains the child element (a file or directory)
 * @param directory the file to consider as the parent
 * @param child the file to consider as the child
 * @return true is the candidate leaf is under by the specified composite, otherwise false
 */
public static boolean directoryContains(final URI directory,final URI child){
  final String d=directory.normalize().toString();
  final String c=child.normalize().toString();
  if (d.equals(c)) {
    return false;
  }
 else {
    return c.startsWith(d);
  }
}",0.9797713280562884
100615,"/** 
 * Write namepace prefix.
 * @param prefix namespace prefix
 * @param uri namespace URI
 * @throws SAXException if processing the event failed
 * @throws IllegalStateException if start element is not open
 * @throws IllegalArgumentException if prefix is already bound
 */
public void writeNamespace(final String prefix,final String uri){
  if (!openStartElement) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final QName qName=elementStack.getFirst();
  for (  final NamespaceMapping p : qName.mappings) {
    if (p.prefix.equals(prefix) && p.uri.equals(uri)) {
      return;
    }
 else     if (p.prefix.equals(prefix)) {
      throw new IllegalArgumentException(""String_Node_Str"" + prefix + ""String_Node_Str""+ uri);
    }
  }
  qName.mappings.add(new NamespaceMapping(prefix,uri,true));
}","/** 
 * Write namepace prefix.
 * @param prefix namespace prefix
 * @param uri namespace URI
 * @throws IllegalStateException if start element is not open
 * @throws IllegalArgumentException if prefix is already bound
 */
public void writeNamespace(final String prefix,final String uri){
  if (!openStartElement) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final QName qName=elementStack.getFirst();
  for (  final NamespaceMapping p : qName.mappings) {
    if (p.prefix.equals(prefix) && p.uri.equals(uri)) {
      return;
    }
 else     if (p.prefix.equals(prefix)) {
      throw new IllegalArgumentException(""String_Node_Str"" + prefix + ""String_Node_Str""+ uri);
    }
  }
  qName.mappings.add(new NamespaceMapping(prefix,uri,true));
}",0.9649904519414386
100616,"/** 
 * Write attribute
 * @param uri namespace URI
 * @param qName attribute name
 * @param value attribute value
 * @throws SAXException if processing the event failed
 * @throws IllegalStateException if start element is not open
 */
public void writeAttribute(final String uri,final String qName,final String value){
  if (!openStartElement) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (openAttributes == null) {
    openAttributes=new AttributesImpl();
  }
  final QName att=new QName(uri,qName);
  addNamespace(uri,att.prefix,elementStack.getFirst());
  openAttributes.addAttribute(uri,att.localName,qName,""String_Node_Str"",value);
}","/** 
 * Write attribute
 * @param uri namespace URI
 * @param qName attribute name
 * @param value attribute value
 * @throws IllegalStateException if start element is not open
 */
public void writeAttribute(final String uri,final String qName,final String value){
  if (!openStartElement) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (openAttributes == null) {
    openAttributes=new AttributesImpl();
  }
  final QName att=new QName(uri,qName);
  addNamespace(uri,att.prefix,elementStack.getFirst());
  openAttributes.addAttribute(uri,att.localName,qName,""String_Node_Str"",value);
}",0.7056037884767167
100617,"/** 
 * List child elements elements.
 * @param elem root element
 * @param deep {@code true} to read descendants, {@code false} to read only direct children
 * @raturn list of matching elements
 */
public static List<Element> getChildElements(final Element elem,final boolean deep){
  final NodeList children=deep ? elem.getElementsByTagName(""String_Node_Str"") : elem.getChildNodes();
  final List<Element> res=new ArrayList<>(children.getLength());
  for (int i=0; i < children.getLength(); i++) {
    final Node child=children.item(i);
    if (child.getNodeType() == Node.ELEMENT_NODE) {
      res.add((Element)child);
    }
  }
  return res;
}","/** 
 * List child elements elements.
 * @param elem root element
 * @param deep {@code true} to read descendants, {@code false} to read only direct children
 * @return list of matching elements
 */
public static List<Element> getChildElements(final Element elem,final boolean deep){
  final NodeList children=deep ? elem.getElementsByTagName(""String_Node_Str"") : elem.getChildNodes();
  final List<Element> res=new ArrayList<>(children.getLength());
  for (int i=0; i < children.getLength(); i++) {
    final Node child=children.item(i);
    if (child.getNodeType() == Node.ELEMENT_NODE) {
      res.add((Element)child);
    }
  }
  return res;
}",0.9984544049459042
100618,"/** 
 * Default Constructor.
 */
public MergeMapParser(){
  processStack=new Stack<>();
  processLevel=0;
  util=new MergeUtils();
  topicParser=new MergeTopicParser(util);
  topicBuffer=new ByteArrayOutputStream();
  try {
    reader=XMLUtils.getXMLReader();
    reader.setContentHandler(this);
    reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
    final TransformerFactory tf=TransformerFactory.newInstance();
    if (!tf.getFeature(SAXTransformerFactory.FEATURE)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    stf=(SAXTransformerFactory)tf;
    final TransformerHandler s=stf.newTransformerHandler();
    s.getTransformer().setOutputProperty(OMIT_XML_DECLARATION,""String_Node_Str"");
    s.setResult(new StreamResult(topicBuffer));
    topicParser.setContentHandler(s);
  }
 catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Default Constructor.
 */
public MergeMapParser(){
  processStack=new Stack<>();
  processLevel=0;
  util=new MergeUtils();
  topicParser=new MergeTopicParser(util);
  topicBuffer=new ByteArrayOutputStream();
  try {
    reader=XMLUtils.getXMLReader();
    reader.setContentHandler(this);
    reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
    final TransformerFactory tf=TransformerFactory.newInstance();
    if (!tf.getFeature(SAXTransformerFactory.FEATURE)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    stf=(SAXTransformerFactory)tf;
    final TransformerHandler s=stf.newTransformerHandler();
    s.getTransformer().setOutputProperty(OMIT_XML_DECLARATION,""String_Node_Str"");
    s.setResult(new StreamResult(topicBuffer));
    topicParser.setContentHandler(s);
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.971030042918455
100619,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    URI attValue=toURI(attributes.getValue(ATTRIBUTE_NAME_HREF));
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equals(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equals(formatValue))) {
        final URI ohref=attValue;
        final URI copyToValue=toURI(atts.getValue(ATTRIBUTE_NAME_COPY_TO));
        if (copyToValue != null && !copyToValue.toString().isEmpty()) {
          attValue=copyToValue;
        }
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref.toString());
        if (util.isVisited(attValue)) {
          attValue=toURI(SHARP + util.getIdValue(attValue));
        }
 else {
          final URI p=stripFragment(attValue).normalize();
          util.visit(p);
          final File f=new File(dirPath,toFile(p).getPath());
          if (f.exists()) {
            topicParser.parse(toFile(p).getPath(),dirPath);
            final String fileId=topicParser.getFirstTopicId();
            util.addId(attValue,fileId);
            if (attValue.getFragment() != null) {
              util.addId(stripFragment(attValue),fileId);
            }
            final URI firstTopicId=toURI(SHARP + fileId);
            if (util.getIdValue(attValue) != null) {
              attValue=toURI(SHARP + util.getIdValue(attValue));
            }
 else {
              attValue=firstTopicId;
            }
            XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId.toString());
          }
 else {
            final URI fileName=dirPath.toURI().resolve(attValue);
            logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",fileName.toString()).toString());
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue.toString());
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    URI attValue=toURI(attributes.getValue(ATTRIBUTE_NAME_HREF));
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equals(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equals(formatValue))) {
        final URI ohref=attValue;
        final URI copyToValue=toURI(atts.getValue(ATTRIBUTE_NAME_COPY_TO));
        if (copyToValue != null && !copyToValue.toString().isEmpty()) {
          attValue=copyToValue;
        }
        final URI absTarget=dirPath.toURI().resolve(attValue);
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref.toString());
        if (util.isVisited(absTarget)) {
          attValue=toURI(SHARP + util.getIdValue(absTarget));
        }
 else {
          final URI p=stripFragment(attValue).normalize();
          util.visit(absTarget);
          final File f=new File(stripFragment(absTarget));
          if (f.exists()) {
            topicParser.parse(toFile(p).getPath(),dirPath);
            final String fileId=topicParser.getFirstTopicId();
            util.addId(absTarget,fileId);
            if (attValue.getFragment() != null) {
              util.addId(stripFragment(absTarget),fileId);
            }
            final URI firstTopicId=toURI(SHARP + fileId);
            if (util.getIdValue(absTarget) != null) {
              attValue=toURI(SHARP + util.getIdValue(absTarget));
            }
 else {
              attValue=firstTopicId;
            }
            XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId.toString());
          }
 else {
            final URI fileName=dirPath.toURI().resolve(attValue);
            logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",fileName.toString()).toString());
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue.toString());
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}",0.9615102639296188
100620,"@Override public void endDocument() throws SAXException {
  try {
    for (    final FileInfo f : job.getFileInfo()) {
      if (f.isTarget) {
        String element=f.file.getPath();
        if (!dirPath.equals(tempdir)) {
          element=FileUtils.getRelativeUnixPath(new File(dirPath,""String_Node_Str"").getAbsolutePath(),new File(tempdir,element).getAbsolutePath());
        }
        if (!util.isVisited(toURI(element))) {
          util.visit(toURI(element));
          if (!f.isResourceOnly) {
            final File file=new File(dirPath,element);
            if (file.exists()) {
              topicParser.parse(element,dirPath);
            }
 else {
              final String fileName=file.getAbsolutePath();
              logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",fileName).toString());
            }
          }
        }
      }
    }
  }
 catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
  getContentHandler().endDocument();
}","@Override public void endDocument() throws SAXException {
  try {
    for (    final FileInfo f : job.getFileInfo()) {
      if (f.isTarget) {
        String element=f.file.getPath();
        if (!dirPath.equals(tempdir)) {
          element=FileUtils.getRelativeUnixPath(new File(dirPath,""String_Node_Str"").getAbsolutePath(),new File(tempdir,element).getAbsolutePath());
        }
        final URI abs=job.tempDirURI.resolve(f.uri);
        if (!util.isVisited(abs)) {
          util.visit(abs);
          if (!f.isResourceOnly) {
            final File file=new File(dirPath,element);
            if (file.exists()) {
              topicParser.parse(element,dirPath);
            }
 else {
              final String fileName=file.getAbsolutePath();
              logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",fileName).toString());
            }
          }
        }
      }
    }
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
  getContentHandler().endDocument();
}",0.8930817610062893
100621,"/** 
 * Parse the file to update id.
 * @param filename relative topic system path, may contain a fragment part
 * @param dir topic directory system path
 */
public void parse(final String filename,final File dir){
  filePath=stripFragment(filename);
  dirPath=dir;
  try {
    final File f=new File(dir,filePath);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(f.getAbsolutePath(),logger));
    logger.info(""String_Node_Str"" + f.getAbsolutePath());
    reader.parse(f.toURI().toString());
  }
 catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + filename + ""String_Node_Str""+ e.getMessage(),e);
  }
}","/** 
 * Parse the file to update id.
 * @param filename relative topic system path, may contain a fragment part
 * @param dir topic directory system path
 */
public void parse(final String filename,final File dir){
  filePath=stripFragment(filename);
  dirPath=dir;
  try {
    final File f=new File(dir,filePath);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(f.getAbsolutePath(),logger));
    logger.info(""String_Node_Str"" + f.getAbsolutePath());
    reader.parse(f.toURI().toString());
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + filename + ""String_Node_Str""+ e.getMessage(),e);
  }
}",0.9592760180995475
100622,"/** 
 * Rewrite local DITA href value.
 * @param href href attribute value
 * @return rewritten href value
 */
private URI handleLocalDita(final URI href,final AttributesImpl atts){
  final URI attValue=href;
  final int sharpIndex=attValue.toString().indexOf(SHARP);
  URI pathFromMap;
  URI retAttValue;
  if (sharpIndex != -1) {
    if (sharpIndex == 0) {
      pathFromMap=toURI(filePath);
    }
 else {
      pathFromMap=toURI(filePath).resolve(attValue.toString().substring(0,sharpIndex));
    }
    XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,toURI(pathFromMap + attValue.toString().substring(sharpIndex)).toString());
    final String topicID=getTopicID(attValue.getFragment());
    final int index=attValue.toString().indexOf(SLASH,sharpIndex);
    final String elementId=index != -1 ? attValue.toString().substring(index) : ""String_Node_Str"";
    final URI pathWithTopicID=setFragment(dirPath.toURI().resolve(pathFromMap),topicID);
    if (util.findId(pathWithTopicID)) {
      retAttValue=toURI(SHARP + util.getIdValue(pathWithTopicID) + elementId);
    }
 else {
      retAttValue=toURI(SHARP + util.addId(pathWithTopicID) + elementId);
    }
  }
 else {
    pathFromMap=toURI(filePath).resolve(attValue.toString());
    URI absolutePath=dirPath.toURI().resolve(pathFromMap);
    XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,pathFromMap.toString());
    if (util.findId(absolutePath)) {
      retAttValue=toURI(SHARP + util.getIdValue(pathFromMap));
    }
 else {
      final String fileId=MergeUtils.getFirstTopicId(absolutePath,dirPath,false);
      final URI key=setFragment(absolutePath,fileId);
      if (util.findId(key)) {
        util.addId(absolutePath,util.getIdValue(key));
        retAttValue=toURI(SHARP + util.getIdValue(key));
      }
 else {
        retAttValue=toURI(SHARP + util.addId(absolutePath));
        util.addId(key,util.getIdValue(absolutePath));
      }
    }
  }
  return retAttValue;
}","/** 
 * Rewrite local DITA href value.
 * @param href href attribute value
 * @return rewritten href value
 */
private URI handleLocalDita(final URI href,final AttributesImpl atts){
  final URI attValue=href;
  final int sharpIndex=attValue.toString().indexOf(SHARP);
  URI pathFromMap;
  URI retAttValue;
  if (sharpIndex != -1) {
    if (sharpIndex == 0) {
      pathFromMap=toURI(filePath);
    }
 else {
      pathFromMap=toURI(filePath).resolve(attValue.toString().substring(0,sharpIndex));
    }
    XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,toURI(pathFromMap + attValue.toString().substring(sharpIndex)).toString());
    final String topicID=getTopicID(attValue.getFragment());
    final int index=attValue.toString().indexOf(SLASH,sharpIndex);
    final String elementId=index != -1 ? attValue.toString().substring(index) : ""String_Node_Str"";
    final URI pathWithTopicID=setFragment(dirPath.toURI().resolve(pathFromMap),topicID);
    if (util.findId(pathWithTopicID)) {
      retAttValue=toURI(SHARP + util.getIdValue(pathWithTopicID) + elementId);
    }
 else {
      retAttValue=toURI(SHARP + util.addId(pathWithTopicID) + elementId);
    }
  }
 else {
    pathFromMap=toURI(filePath).resolve(attValue.toString());
    URI absolutePath=dirPath.toURI().resolve(pathFromMap);
    XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,pathFromMap.toString());
    if (util.findId(absolutePath)) {
      retAttValue=toURI(SHARP + util.getIdValue(absolutePath));
    }
 else {
      final String fileId=MergeUtils.getFirstTopicId(absolutePath,dirPath,false);
      final URI key=setFragment(absolutePath,fileId);
      if (util.findId(key)) {
        util.addId(absolutePath,util.getIdValue(key));
        retAttValue=toURI(SHARP + util.getIdValue(key));
      }
 else {
        retAttValue=toURI(SHARP + util.addId(absolutePath));
        util.addId(key,util.getIdValue(absolutePath));
      }
    }
  }
  return retAttValue;
}",0.9940858832604784
100623,"/** 
 * Default Constructor.
 * @param util merge utility
 */
public MergeTopicParser(final MergeUtils util){
  this.util=util;
  try {
    reader=XMLUtils.getXMLReader();
    reader.setContentHandler(this);
    reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
  }
 catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Default Constructor.
 * @param util merge utility
 */
public MergeTopicParser(final MergeUtils util){
  this.util=util;
  try {
    reader=XMLUtils.getXMLReader();
    reader.setContentHandler(this);
    reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.9323308270676692
100624,"/** 
 * Get copy-to map based on map processing.
 * @return target to source map of URIs relative to temporary directory
 */
private Map<URI,URI> getCopyToMap(){
  final Map<URI,URI> copyToMap=new HashMap<>();
  if (forceUnique) {
    copyToMap.putAll(forceUniqueFilter.copyToMap);
  }
  for (  final Map.Entry<URI,URI> e : reader.getCopyToMap().entrySet()) {
    final URI target=job.tempDir.toURI().relativize(e.getKey());
    final URI source=job.tempDir.toURI().relativize(e.getValue());
    if (job.getFileInfo(target) != null) {
      continue;
    }
    copyToMap.put(target,source);
  }
  return copyToMap;
}","/** 
 * Get copy-to map based on map processing.
 * @return target to source map of URIs relative to temporary directory
 */
private Map<URI,URI> getCopyToMap(){
  final Map<URI,URI> copyToMap=new HashMap<>();
  if (forceUnique) {
    copyToMap.putAll(forceUniqueFilter.copyToMap);
  }
  for (  final Map.Entry<URI,URI> e : reader.getCopyToMap().entrySet()) {
    final URI target=job.tempDir.toURI().relativize(e.getKey());
    final URI source=job.tempDir.toURI().relativize(e.getValue());
    final FileInfo fileInfo=job.getFileInfo(target);
    if (fileInfo != null && fileInfo.src != null) {
      continue;
    }
    copyToMap.put(target,source);
  }
  return copyToMap;
}",0.945904173106646
100625,"/** 
 * Sort term list extracted from dita files base on Locale.
 */
public void sort(){
  final int termListSize=termList.size();
  if (IndexTerm.getTermLocale() == null || IndexTerm.getTermLocale().getLanguage().trim().length() == 0) {
    IndexTerm.setTermLocale(new Locale(LANGUAGE_EN,COUNTRY_US));
  }
  for (  final IndexTerm term : termList) {
    term.sortSubTerms();
  }
  Collections.sort(termList);
}","/** 
 * Sort term list extracted from dita files base on Locale.
 */
public void sort(){
  if (IndexTerm.getTermLocale() == null || IndexTerm.getTermLocale().getLanguage().trim().length() == 0) {
    IndexTerm.setTermLocale(new Locale(LANGUAGE_EN,COUNTRY_US));
  }
  for (  final IndexTerm term : termList) {
    term.sortSubTerms();
  }
  Collections.sort(termList);
}",0.946153846153846
100626,"private void initialize() throws BuildException {
  if (tempDir == null) {
    tempDir=new File(this.getProject().getProperty(ANT_TEMP_DIR)).getAbsoluteFile();
  }
  if (tempDir == null) {
    throw new BuildException(""String_Node_Str"");
  }
  if (modules.isEmpty()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (attrs.get(ANT_INVOKER_PARAM_BASEDIR) == null) {
    attrs.put(ANT_INVOKER_PARAM_BASEDIR,getProject().getBaseDir().getAbsolutePath());
  }
  for (  final Param p : pipelineParams) {
    if (!p.isValid()) {
      throw new BuildException(""String_Node_Str"");
    }
    final String ifProperty=p.getIf();
    final String unlessProperty=p.getUnless();
    if ((ifProperty == null || getProject().getProperties().containsKey(ifProperty)) && (unlessProperty == null || !getProject().getProperties().containsKey(unlessProperty))) {
      attrs.put(p.getName(),p.getValue());
    }
  }
}","private void initialize() throws BuildException {
  if (tempDir == null) {
    tempDir=new File(this.getProject().getProperty(ANT_TEMP_DIR)).getAbsoluteFile();
  }
  if (modules.isEmpty()) {
    throw new BuildException(""String_Node_Str"");
  }
  if (attrs.get(ANT_INVOKER_PARAM_BASEDIR) == null) {
    attrs.put(ANT_INVOKER_PARAM_BASEDIR,getProject().getBaseDir().getAbsolutePath());
  }
  for (  final Param p : pipelineParams) {
    if (!p.isValid()) {
      throw new BuildException(""String_Node_Str"");
    }
    final String ifProperty=p.getIf();
    final String unlessProperty=p.getUnless();
    if ((ifProperty == null || getProject().getProperties().containsKey(ifProperty)) && (unlessProperty == null || !getProject().getProperties().containsKey(unlessProperty))) {
      attrs.put(p.getName(),p.getValue());
    }
  }
}",0.9550691244239632
100627,"private void extractIndexTerm() throws SAXException {
  final int topicNum=topicList.size();
  final int ditamapNum=ditamapList.size();
  FileInputStream inputStream=null;
  XMLReader xmlReader=null;
  final IndexTermReader handler=new IndexTermReader(indexTermCollection);
  handler.setLogger(logger);
  final DitamapIndexTermReader ditamapIndexTermReader=new DitamapIndexTermReader(indexTermCollection,true);
  ditamapIndexTermReader.setLogger(logger);
  xmlReader=XMLUtils.getXMLReader();
  try {
    xmlReader.setContentHandler(handler);
    for (    String aTopicList : topicList) {
      String target;
      String targetPathFromMap;
      String targetPathFromMapWithoutExt;
      handler.reset();
      target=aTopicList;
      targetPathFromMap=FileUtils.getRelativeUnixPath(inputMap,target);
      targetPathFromMapWithoutExt=targetPathFromMap.substring(0,targetPathFromMap.lastIndexOf(""String_Node_Str""));
      handler.setTargetFile(targetPathFromMapWithoutExt + targetExt);
      try {
        inputStream=new FileInputStream(new File(job.tempDir,target));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      final Exception e) {
        final StringBuilder buff=new StringBuilder();
        String msg=null;
        msg=MessageUtils.getInstance().getMessage(""String_Node_Str"",target).toString();
        logger.error(buff.append(msg).append(e.getMessage()).toString());
      }
    }
    xmlReader.setContentHandler(ditamapIndexTermReader);
    for (    final String ditamap : ditamapList) {
      final String currentMapPathName=FileUtils.getRelativeUnixPath(inputMap,ditamap);
      String mapPathFromInputMap=""String_Node_Str"";
      if (currentMapPathName.lastIndexOf(SLASH) != -1) {
        mapPathFromInputMap=currentMapPathName.substring(0,currentMapPathName.lastIndexOf(SLASH));
      }
      ditamapIndexTermReader.setMapPath(mapPathFromInputMap);
      try {
        inputStream=new FileInputStream(new File(job.tempDir,ditamap));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      final Exception e) {
        String msg=null;
        msg=MessageUtils.getInstance().getMessage(""String_Node_Str"",ditamap).toString();
        logger.error(msg,e);
      }
    }
  }
  finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}","private void extractIndexTerm() throws SAXException {
  FileInputStream inputStream=null;
  XMLReader xmlReader=null;
  final IndexTermReader handler=new IndexTermReader(indexTermCollection);
  handler.setLogger(logger);
  final DitamapIndexTermReader ditamapIndexTermReader=new DitamapIndexTermReader(indexTermCollection,true);
  ditamapIndexTermReader.setLogger(logger);
  xmlReader=XMLUtils.getXMLReader();
  try {
    xmlReader.setContentHandler(handler);
    for (    String aTopicList : topicList) {
      String target;
      String targetPathFromMap;
      String targetPathFromMapWithoutExt;
      handler.reset();
      target=aTopicList;
      targetPathFromMap=FileUtils.getRelativeUnixPath(inputMap,target);
      targetPathFromMapWithoutExt=targetPathFromMap.substring(0,targetPathFromMap.lastIndexOf(""String_Node_Str""));
      handler.setTargetFile(targetPathFromMapWithoutExt + targetExt);
      try {
        inputStream=new FileInputStream(new File(job.tempDir,target));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      final Exception e) {
        final StringBuilder buff=new StringBuilder();
        String msg=null;
        msg=MessageUtils.getInstance().getMessage(""String_Node_Str"",target).toString();
        logger.error(buff.append(msg).append(e.getMessage()).toString());
      }
    }
    xmlReader.setContentHandler(ditamapIndexTermReader);
    for (    final String ditamap : ditamapList) {
      final String currentMapPathName=FileUtils.getRelativeUnixPath(inputMap,ditamap);
      String mapPathFromInputMap=""String_Node_Str"";
      if (currentMapPathName.lastIndexOf(SLASH) != -1) {
        mapPathFromInputMap=currentMapPathName.substring(0,currentMapPathName.lastIndexOf(SLASH));
      }
      ditamapIndexTermReader.setMapPath(mapPathFromInputMap);
      try {
        inputStream=new FileInputStream(new File(job.tempDir,ditamap));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      final Exception e) {
        String msg=null;
        msg=MessageUtils.getInstance().getMessage(""String_Node_Str"",ditamap).toString();
        logger.error(msg,e);
      }
    }
  }
  finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}",0.9832310838445808
100628,"@Override public void endDocument() throws SAXException {
  final int size=indexTermList.size();
  updateIndexTermTargetName();
  for (  final IndexTerm indexterm : indexTermList) {
    result.addTerm(indexterm);
  }
}","@Override public void endDocument() throws SAXException {
  updateIndexTermTargetName();
  for (  final IndexTerm indexterm : indexTermList) {
    result.addTerm(indexterm);
  }
}",0.9017632241813602
100629,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  if (SVG_NS.equals(SVG_NS) && (SVG_ELEM.equals(localName) || SVG_ELEM.equals(qName) || (qName != null && qName.startsWith(SVG_ELEM + ""String_Node_Str"")))) {
    dimensions.width=atts.getValue(WIDTH_ATTR);
    dimensions.height=atts.getValue(HEIGHT_ATTR);
  }
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  if (SVG_NS.equals(uri) && (SVG_ELEM.equals(localName) || SVG_ELEM.equals(qName) || (qName != null && qName.startsWith(SVG_ELEM + ""String_Node_Str"")))) {
    dimensions.width=atts.getValue(WIDTH_ATTR);
    dimensions.height=atts.getValue(HEIGHT_ATTR);
  }
}",0.98870765370138
100630,"/** 
 * Get base path from a path.
 * @param aURLString UNIX or URI path
 * @return base path
 */
public static String getFullPathNoEndSeparator(final String aURLString){
  final int pathnameStartIndex=aURLString.indexOf(UNIX_SEPARATOR);
  final int pathnameEndIndex=aURLString.lastIndexOf(UNIX_SEPARATOR);
  String aPath=aURLString.substring(pathnameStartIndex,pathnameEndIndex);
  aPath=aURLString.substring(0,pathnameEndIndex);
  return aPath;
}","/** 
 * Get base path from a path.
 * @param aURLString UNIX or URI path
 * @return base path
 */
public static String getFullPathNoEndSeparator(final String aURLString){
  final int pathnameStartIndex=aURLString.indexOf(UNIX_SEPARATOR);
  final int pathnameEndIndex=aURLString.lastIndexOf(UNIX_SEPARATOR);
  String aPath=aURLString.substring(0,pathnameEndIndex);
  return aPath;
}",0.887816646562123
100631,"@Override public void write(final File filename) throws DITAOTException {
  OutputStream out=null;
  try {
    out=new FileOutputStream(filename);
    final XMLSerializer serializer=XMLSerializer.newInstance(out);
    final Transformer transformer=serializer.getTransformerHandler().getTransformer();
    transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
    transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
    transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
    transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT,""String_Node_Str"");
    serializer.writeStartDocument();
    serializer.writeStartElement(""String_Node_Str"");
    serializer.writeStartElement(""String_Node_Str"");
    serializer.writeStartElement(""String_Node_Str"");
    serializer.writeAttribute(""String_Node_Str"",""String_Node_Str"");
    serializer.writeAttribute(""String_Node_Str"",""String_Node_Str"");
    serializer.writeEndElement();
    serializer.writeComment(""String_Node_Str"");
    serializer.writeEndElement();
    serializer.writeStartElement(""String_Node_Str"");
    serializer.writeStartElement(""String_Node_Str"");
    final int termNum=termList.size();
    for (    final IndexTerm term : termList) {
      outputIndexTerm(term,serializer);
    }
    serializer.writeEndElement();
    serializer.writeEndElement();
    serializer.writeEndElement();
    serializer.writeEndDocument();
  }
 catch (  final Exception e) {
    throw new DITAOTException(e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}","@Override public void write(final File filename) throws DITAOTException {
  OutputStream out=null;
  try {
    out=new FileOutputStream(filename);
    final XMLSerializer serializer=XMLSerializer.newInstance(out);
    final Transformer transformer=serializer.getTransformerHandler().getTransformer();
    transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
    transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
    transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
    transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT,""String_Node_Str"");
    serializer.writeStartDocument();
    serializer.writeStartElement(""String_Node_Str"");
    serializer.writeStartElement(""String_Node_Str"");
    serializer.writeStartElement(""String_Node_Str"");
    serializer.writeAttribute(""String_Node_Str"",""String_Node_Str"");
    serializer.writeAttribute(""String_Node_Str"",""String_Node_Str"");
    serializer.writeEndElement();
    serializer.writeComment(""String_Node_Str"");
    serializer.writeEndElement();
    serializer.writeStartElement(""String_Node_Str"");
    serializer.writeStartElement(""String_Node_Str"");
    for (    final IndexTerm term : termList) {
      outputIndexTerm(term,serializer);
    }
    serializer.writeEndElement();
    serializer.writeEndElement();
    serializer.writeEndElement();
    serializer.writeEndDocument();
  }
 catch (  final Exception e) {
    throw new DITAOTException(e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}",0.9882352941176472
100632,"@Override public void startElement(final String uri,final String localName,final String name,final Attributes atts) throws SAXException {
  if (ignoreDepth > 0) {
    ignoreDepth++;
    return;
  }
  if (PR_D_CODEREF.matches(atts)) {
    ignoreDepth++;
    try {
      final URI hrefValue=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
      if (hrefValue != null) {
        File codeFile=toFile(stripFragment(currentFile.resolve(hrefValue))).getAbsoluteFile();
        if (!codeFile.exists()) {
          final URI rel=job.tempDir.toURI().relativize(codeFile.toURI());
          final Job.FileInfo fi=job.getFileInfo(rel);
          if (fi != null && fi.src.getScheme().equals(""String_Node_Str"")) {
            codeFile=new File(fi.src);
          }
        }
        if (codeFile.exists()) {
          logger.debug(""String_Node_Str"" + codeFile);
          final Charset charset=getCharset(atts.getValue(ATTRIBUTE_NAME_FORMAT));
          try (BufferedReader codeReader=new BufferedReader(new InputStreamReader(new FileInputStream(codeFile),charset))){
            copyLines(codeReader,new Range(hrefValue));
          }
 catch (          final Exception e) {
            logger.error(""String_Node_Str"" + codeFile,e);
          }
        }
 else {
          logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",hrefValue.toString()).setLocation(atts).toString());
        }
      }
 else {
      }
    }
 catch (    final Exception e) {
      logger.error(e.getMessage(),e);
    }
  }
 else {
    super.startElement(uri,localName,name,atts);
  }
}","@Override public void startElement(final String uri,final String localName,final String name,final Attributes atts) throws SAXException {
  if (ignoreDepth > 0) {
    ignoreDepth++;
    return;
  }
  if (PR_D_CODEREF.matches(atts)) {
    ignoreDepth++;
    try {
      final URI hrefValue=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
      if (hrefValue != null) {
        File codeFile=toFile(stripFragment(currentFile.resolve(hrefValue))).getAbsoluteFile();
        if (!codeFile.exists()) {
          final URI rel=job.tempDir.toURI().relativize(codeFile.toURI());
          final Job.FileInfo fi=job.getFileInfo(rel);
          if (fi != null && ""String_Node_Str"".equals(fi.src.getScheme())) {
            codeFile=new File(fi.src);
          }
        }
        if (codeFile.exists()) {
          logger.debug(""String_Node_Str"" + codeFile);
          final Charset charset=getCharset(atts.getValue(ATTRIBUTE_NAME_FORMAT));
          try (BufferedReader codeReader=new BufferedReader(new InputStreamReader(new FileInputStream(codeFile),charset))){
            copyLines(codeReader,new Range(hrefValue));
          }
 catch (          final Exception e) {
            logger.error(""String_Node_Str"" + codeFile,e);
          }
        }
 else {
          logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",hrefValue.toString()).setLocation(atts).toString());
        }
      }
 else {
      }
    }
 catch (    final Exception e) {
      logger.error(e.getMessage(),e);
    }
  }
 else {
    super.startElement(uri,localName,name,atts);
  }
}",0.9833226427196922
100633,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final int attsLen=atts.getLength();
  try {
    if (topicLevel != -1) {
      if (!hasProlog(atts) && startTopic && !hasWritten) {
        writeStartElement(TOPIC_PROLOG.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_PROLOG.toString()).build());
        writeStartElement(TOPIC_METADATA.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_METADATA.toString()).build());
        output.write(indexEntries);
        writeEndElement(TOPIC_METADATA.localName);
        writeEndElement(TOPIC_PROLOG.localName);
        hasPrologTillNow=true;
        hasWritten=true;
      }
    }
    if (!startTopic && !ELEMENT_NAME_DITA.equals(qName)) {
      if (atts.getValue(ATTRIBUTE_NAME_ID) != null) {
        topicIdList.add(atts.getValue(ATTRIBUTE_NAME_ID));
      }
 else {
        topicIdList.add(""String_Node_Str"");
      }
      if (topicIdList.size() >= matchList.size()) {
        startTopic=checkMatch();
      }
    }
    if (!hasMetadata(qName) && startTopic && !hasWritten) {
      writeStartElement(TOPIC_METADATA.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_METADATA.toString()).build());
      output.write(indexEntries);
      writeEndElement(TOPIC_METADATA.localName);
      hasMetadataTillNow=true;
      hasWritten=true;
    }
    writeStartElement(qName,atts);
    if (atts.getValue(ATTRIBUTE_NAME_CLASS) != null) {
      if (atts.getValue(ATTRIBUTE_NAME_CLASS).contains(TOPIC_METADATA.matcher) && startTopic && !hasWritten) {
        hasMetadataTillNow=true;
        output.write(indexEntries);
        hasWritten=true;
      }
      if (atts.getValue(ATTRIBUTE_NAME_CLASS).contains(TOPIC_PROLOG.matcher)) {
        hasPrologTillNow=true;
      }
    }
  }
 catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  try {
    if (topicLevel != -1) {
      if (!hasProlog(atts) && startTopic && !hasWritten) {
        writeStartElement(TOPIC_PROLOG.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_PROLOG.toString()).build());
        writeStartElement(TOPIC_METADATA.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_METADATA.toString()).build());
        output.write(indexEntries);
        writeEndElement(TOPIC_METADATA.localName);
        writeEndElement(TOPIC_PROLOG.localName);
        hasPrologTillNow=true;
        hasWritten=true;
      }
    }
    if (!startTopic && !ELEMENT_NAME_DITA.equals(qName)) {
      if (atts.getValue(ATTRIBUTE_NAME_ID) != null) {
        topicIdList.add(atts.getValue(ATTRIBUTE_NAME_ID));
      }
 else {
        topicIdList.add(""String_Node_Str"");
      }
      if (topicIdList.size() >= matchList.size()) {
        startTopic=checkMatch();
      }
    }
    if (!hasMetadata(qName) && startTopic && !hasWritten) {
      writeStartElement(TOPIC_METADATA.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_METADATA.toString()).build());
      output.write(indexEntries);
      writeEndElement(TOPIC_METADATA.localName);
      hasMetadataTillNow=true;
      hasWritten=true;
    }
    writeStartElement(qName,atts);
    if (atts.getValue(ATTRIBUTE_NAME_CLASS) != null) {
      if (atts.getValue(ATTRIBUTE_NAME_CLASS).contains(TOPIC_METADATA.matcher) && startTopic && !hasWritten) {
        hasMetadataTillNow=true;
        output.write(indexEntries);
        hasWritten=true;
      }
      if (atts.getValue(ATTRIBUTE_NAME_CLASS).contains(TOPIC_PROLOG.matcher)) {
        hasPrologTillNow=true;
      }
    }
  }
 catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
}",0.9900523560209424
100634,"private void outputIndexEntry(final IndexTerm term,final XMLStreamWriter serializer) throws XMLStreamException {
  final List<IndexTermTarget> targets=term.getTargetList();
  final int targetNum=targets.size();
  boolean foundIndexTerm=false;
  boolean foundIndexsee=false;
  String indexSeeRefTerm=null;
  final int termCloneNum=termCloneList.size();
  if (!targets.isEmpty()) {
    for (    final IndexTermTarget target : targets) {
      final String targetUri=target.getTargetURI();
      final String targetName=target.getTargetName();
      if (targetUri == null) {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        serializer.writeEndElement();
      }
 else       if (targetName != null && targetName.trim().length() > 0) {
        if (term.getTermPrefix() != null || inIndexsee) {
          indexSeeRefTerm=term.getTermName();
          inIndexsee=true;
          foundIndexsee=true;
          for (int j=0; j < termCloneNum; j++) {
            final IndexTerm termClone=termCloneList.get(j);
            if (term.getTermName().equals(termClone.getTermName())) {
              foundIndexTerm=true;
              if (termClone.getTargetList().size() > 0) {
                serializer.writeStartElement(""String_Node_Str"");
                serializer.writeAttribute(""String_Node_Str"",replaceExtName(termClone.getTargetList().get(0).getTargetURI()));
                if (targetName.trim().length() > 0) {
                  serializer.writeAttribute(""String_Node_Str"",termClone.getTargetList().get(0).getTargetName());
                }
                serializer.writeEndElement();
              }
              termCloneList=termClone.getSubTerms();
              break;
            }
          }
          if (term.getSubTerms().size() == 0) {
            inIndexsee=false;
          }
        }
 else {
          serializer.writeStartElement(""String_Node_Str"");
          serializer.writeAttribute(""String_Node_Str"",replaceExtName(targetUri));
          if (targetName.trim().length() > 0) {
            serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
          }
          serializer.writeEndElement();
        }
      }
    }
    if (!foundIndexTerm && foundIndexsee && indexSeeRefTerm != null && !indexSeeRefTerm.equals(""String_Node_Str"")) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",indexSeeRefTerm.trim()).toString());
    }
  }
}","private void outputIndexEntry(final IndexTerm term,final XMLStreamWriter serializer) throws XMLStreamException {
  final List<IndexTermTarget> targets=term.getTargetList();
  boolean foundIndexTerm=false;
  boolean foundIndexsee=false;
  String indexSeeRefTerm=null;
  final int termCloneNum=termCloneList.size();
  if (!targets.isEmpty()) {
    for (    final IndexTermTarget target : targets) {
      final String targetUri=target.getTargetURI();
      final String targetName=target.getTargetName();
      if (targetUri == null) {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        serializer.writeEndElement();
      }
 else       if (targetName != null && targetName.trim().length() > 0) {
        if (term.getTermPrefix() != null || inIndexsee) {
          indexSeeRefTerm=term.getTermName();
          inIndexsee=true;
          foundIndexsee=true;
          for (int j=0; j < termCloneNum; j++) {
            final IndexTerm termClone=termCloneList.get(j);
            if (term.getTermName().equals(termClone.getTermName())) {
              foundIndexTerm=true;
              if (termClone.getTargetList().size() > 0) {
                serializer.writeStartElement(""String_Node_Str"");
                serializer.writeAttribute(""String_Node_Str"",replaceExtName(termClone.getTargetList().get(0).getTargetURI()));
                if (targetName.trim().length() > 0) {
                  serializer.writeAttribute(""String_Node_Str"",termClone.getTargetList().get(0).getTargetName());
                }
                serializer.writeEndElement();
              }
              termCloneList=termClone.getSubTerms();
              break;
            }
          }
          if (term.getSubTerms().size() == 0) {
            inIndexsee=false;
          }
        }
 else {
          serializer.writeStartElement(""String_Node_Str"");
          serializer.writeAttribute(""String_Node_Str"",replaceExtName(targetUri));
          if (targetName.trim().length() > 0) {
            serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
          }
          serializer.writeEndElement();
        }
      }
    }
    if (!foundIndexTerm && foundIndexsee && indexSeeRefTerm != null && !indexSeeRefTerm.equals(""String_Node_Str"")) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",indexSeeRefTerm.trim()).toString());
    }
  }
}",0.9923045767517212
100635,"@Override public void write(final File filename) throws DITAOTException {
  OutputStream out=null;
  XMLStreamWriter serializer=null;
  try {
    out=new FileOutputStream(filename);
    boolean indexsee=false;
    if (this.getPipelineHashIO() != null) {
      indexsee=Boolean.valueOf(this.getPipelineHashIO().getAttribute(""String_Node_Str""));
      targetExt=this.getPipelineHashIO().getAttribute(ANT_INVOKER_EXT_PARAM_TARGETEXT);
    }
    serializer=XMLOutputFactory.newInstance().createXMLStreamWriter(out,""String_Node_Str"");
    serializer.writeStartDocument();
    serializer.writeStartElement(""String_Node_Str"");
    termCloneList=cloneIndextermList(termList);
    final int termNum=termList.size();
    for (    final IndexTerm term : termList) {
      outputIndexTerm(term,serializer,indexsee);
    }
    serializer.writeEndElement();
    serializer.writeEndDocument();
  }
 catch (  final Exception e) {
    throw new DITAOTException(e);
  }
 finally {
    if (serializer != null) {
      try {
        serializer.close();
      }
 catch (      final XMLStreamException e) {
        logger.error(e.getMessage(),e);
      }
    }
    if (out != null) {
      try {
        out.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}","@Override public void write(final File filename) throws DITAOTException {
  OutputStream out=null;
  XMLStreamWriter serializer=null;
  try {
    out=new FileOutputStream(filename);
    boolean indexsee=false;
    if (this.getPipelineHashIO() != null) {
      indexsee=Boolean.valueOf(this.getPipelineHashIO().getAttribute(""String_Node_Str""));
      targetExt=this.getPipelineHashIO().getAttribute(ANT_INVOKER_EXT_PARAM_TARGETEXT);
    }
    serializer=XMLOutputFactory.newInstance().createXMLStreamWriter(out,""String_Node_Str"");
    serializer.writeStartDocument();
    serializer.writeStartElement(""String_Node_Str"");
    termCloneList=cloneIndextermList(termList);
    for (    final IndexTerm term : termList) {
      outputIndexTerm(term,serializer,indexsee);
    }
    serializer.writeEndElement();
    serializer.writeEndDocument();
  }
 catch (  final Exception e) {
    throw new DITAOTException(e);
  }
 finally {
    if (serializer != null) {
      try {
        serializer.close();
      }
 catch (      final XMLStreamException e) {
        logger.error(e.getMessage(),e);
      }
    }
    if (out != null) {
      try {
        out.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}",0.984759671746776
100636,"private void outputIndexEntryEclipseIndexsee(final IndexTerm term,final XMLStreamWriter serializer) throws XMLStreamException {
  final List<IndexTermTarget> targets=term.getTargetList();
  final int targetNum=targets.size();
  if (!targets.isEmpty()) {
    for (    final IndexTermTarget target : targets) {
      final String targetUri=target.getTargetURI();
      final String targetName=target.getTargetName();
      if (targetUri == null) {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        serializer.writeEndElement();
      }
 else {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",replaceExtName(targetUri));
        if (targetName.trim().length() > 0) {
          serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        }
        serializer.writeEndElement();
      }
    }
  }
}","private void outputIndexEntryEclipseIndexsee(final IndexTerm term,final XMLStreamWriter serializer) throws XMLStreamException {
  final List<IndexTermTarget> targets=term.getTargetList();
  if (!targets.isEmpty()) {
    for (    final IndexTermTarget target : targets) {
      final String targetUri=target.getTargetURI();
      final String targetName=target.getTargetName();
      if (targetUri == null) {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        serializer.writeEndElement();
      }
 else {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",replaceExtName(targetUri));
        if (targetName.trim().length() > 0) {
          serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        }
        serializer.writeEndElement();
      }
    }
  }
}",0.9798728813559322
100637,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  if (rootClass == null) {
    rootClass=new DitaClass(classValue);
  }
  final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
  if (TOPIC_TOPIC.matches(classValue)) {
    topicId=atts.getValue(ATTRIBUTE_NAME_ID);
    final String filename=currentFile.toString() + QUESTION;
    for (    final ExportAnchor e : exportAnchors) {
      if (e.topicids.contains(filename)) {
        e.topicids.add(topicId);
        e.topicids.remove(filename);
      }
    }
  }
 else   if (MAP_TOPICREF.matches(classValue)) {
    parseAttribute(atts);
  }
 else   if (MAP_MAP.matches(classValue)) {
    if (rootFilePath.equals(currentFile)) {
      String pluginId=atts.getValue(ATTRIBUTE_NAME_ID);
      if (pluginId == null) {
        pluginId=""String_Node_Str"";
      }
      final Set<String> set=StringUtils.restoreSet(pluginId,COMMA);
      pluginMap.put(""String_Node_Str"",set);
    }
  }
 else   if (MAP_TOPICMETA.matches(classValue) || TOPIC_PROLOG.matches(classValue)) {
    topicMetaSet.add(qName);
  }
 else   if (DELAY_D_EXPORTANCHORS.matches(classValue)) {
    hasExport=true;
    if (rootClass != null && rootClass.matches(MAP_MAP)) {
      currentExportAnchor=new ExportAnchor(topicHref);
      currentExportAnchor.topicids.add(topicId);
    }
 else     if (rootClass == null || rootClass.matches(TOPIC_TOPIC)) {
      currentExportAnchor=new ExportAnchor(currentFile);
      currentExportAnchor.topicids.add(topicId);
      shouldAppendEndTag=true;
    }
  }
 else   if (DELAY_D_ANCHORKEY.matches(classValue)) {
    final String keyref=atts.getValue(ATTRIBUTE_NAME_KEYREF);
    currentExportAnchor.keys.add(keyref);
  }
 else   if (DELAY_D_ANCHORID.matches(classValue)) {
    final String id=atts.getValue(ATTRIBUTE_NAME_ID);
    if (rootClass != null && rootClass.matches(MAP_MAP)) {
      if (!topicId.equals(id)) {
        currentExportAnchor.ids.add(id);
      }
    }
 else     if (rootClass == null || rootClass.matches(TOPIC_TOPIC)) {
      if (!topicId.equals(id)) {
        currentExportAnchor.ids.add(id);
      }
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  if (rootClass == null) {
    rootClass=new DitaClass(classValue);
  }
  if (TOPIC_TOPIC.matches(classValue)) {
    topicId=atts.getValue(ATTRIBUTE_NAME_ID);
    final String filename=currentFile.toString() + QUESTION;
    for (    final ExportAnchor e : exportAnchors) {
      if (e.topicids.contains(filename)) {
        e.topicids.add(topicId);
        e.topicids.remove(filename);
      }
    }
  }
 else   if (MAP_TOPICREF.matches(classValue)) {
    parseAttribute(atts);
  }
 else   if (MAP_MAP.matches(classValue)) {
    if (rootFilePath.equals(currentFile)) {
      String pluginId=atts.getValue(ATTRIBUTE_NAME_ID);
      if (pluginId == null) {
        pluginId=""String_Node_Str"";
      }
      final Set<String> set=StringUtils.restoreSet(pluginId,COMMA);
      pluginMap.put(""String_Node_Str"",set);
    }
  }
 else   if (MAP_TOPICMETA.matches(classValue) || TOPIC_PROLOG.matches(classValue)) {
    topicMetaSet.add(qName);
  }
 else   if (DELAY_D_EXPORTANCHORS.matches(classValue)) {
    hasExport=true;
    if (rootClass != null && rootClass.matches(MAP_MAP)) {
      currentExportAnchor=new ExportAnchor(topicHref);
      currentExportAnchor.topicids.add(topicId);
    }
 else     if (rootClass == null || rootClass.matches(TOPIC_TOPIC)) {
      currentExportAnchor=new ExportAnchor(currentFile);
      currentExportAnchor.topicids.add(topicId);
      shouldAppendEndTag=true;
    }
  }
 else   if (DELAY_D_ANCHORKEY.matches(classValue)) {
    final String keyref=atts.getValue(ATTRIBUTE_NAME_KEYREF);
    currentExportAnchor.keys.add(keyref);
  }
 else   if (DELAY_D_ANCHORID.matches(classValue)) {
    final String id=atts.getValue(ATTRIBUTE_NAME_ID);
    if (rootClass != null && rootClass.matches(MAP_MAP)) {
      if (!topicId.equals(id)) {
        currentExportAnchor.ids.add(id);
      }
    }
 else     if (rootClass == null || rootClass.matches(TOPIC_TOPIC)) {
      if (!topicId.equals(id)) {
        currentExportAnchor.ids.add(id);
      }
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts);
}",0.9857048603474818
100638,"@Override public void startElement(final String uri,final String localName,final String name,final Attributes atts) throws SAXException {
  if (TOPIC_IMAGE.matches(atts)) {
    final XMLUtils.AttributesBuilder a=new XMLUtils.AttributesBuilder(atts);
    if (atts.getValue(ATTRIBUTE_NAME_HREF) != null) {
      final URI imgInput=getImageFile(toURI(atts.getValue(ATTRIBUTE_NAME_HREF)));
      if (imgInput != null) {
        Attributes m=cache.get(imgInput);
        if (m == null) {
          m=readMetadata(imgInput);
          cache.put(imgInput,m);
        }
        a.addAll(m);
      }
 else {
        logger.error(""String_Node_Str"" + imgInput + ""String_Node_Str"");
      }
    }
    depth=1;
    super.startPrefixMapping(DITA_OT_PREFIX,DITA_OT_NS);
    super.startElement(uri,localName,name,a.build());
  }
 else {
    if (depth > 0) {
      depth++;
    }
    super.startElement(uri,localName,name,atts);
  }
}","@Override public void startElement(final String uri,final String localName,final String name,final Attributes atts) throws SAXException {
  if (TOPIC_IMAGE.matches(atts)) {
    final XMLUtils.AttributesBuilder a=new XMLUtils.AttributesBuilder(atts);
    final String href=atts.getValue(ATTRIBUTE_NAME_HREF);
    if (href != null) {
      final URI imgInput=getImageFile(toURI(href));
      if (imgInput != null) {
        Attributes m=cache.get(imgInput);
        if (m == null) {
          m=readMetadata(imgInput);
          cache.put(imgInput,m);
        }
        a.addAll(m);
      }
 else {
        logger.error(""String_Node_Str"" + href + ""String_Node_Str"");
      }
    }
    depth=1;
    super.startPrefixMapping(DITA_OT_PREFIX,DITA_OT_NS);
    super.startElement(uri,localName,name,a.build());
  }
 else {
    if (depth > 0) {
      depth++;
    }
    super.startElement(uri,localName,name,atts);
  }
}",0.9529540481400438
100639,"private void processTopicref(final Element topicref){
  final String xtrfValue=getValue(topicref,ATTRIBUTE_NAME_XTRF);
  if (xtrfValue != null && xtrfValue.contains(ATTR_XTRF_VALUE_GENERATED)) {
    return;
  }
  final Collection<String> chunkValue=split(getValue(topicref,ATTRIBUTE_NAME_CHUNK));
  if (topicref.getAttributeNode(ATTRIBUTE_NAME_HREF) == null && chunkValue.contains(CHUNK_TO_CONTENT)) {
    generateStumpTopic(topicref);
  }
  final URI hrefValue=toURI(getValue(topicref,ATTRIBUTE_NAME_HREF));
  final URI copytoValue=toURI(getValue(topicref,ATTRIBUTE_NAME_COPY_TO));
  final String scopeValue=getCascadeValue(topicref,ATTRIBUTE_NAME_SCOPE);
  final String chunkByToken=getChunkByToken(chunkValue,""String_Node_Str"",defaultChunkByToken);
  if (ATTR_SCOPE_VALUE_EXTERNAL.equals(scopeValue) || (hrefValue != null && !new File(inputFile.resolve(hrefValue.toString())).exists()) || (chunkValue.isEmpty() && hrefValue == null)) {
    processChildTopicref(topicref);
  }
 else   if (chunkValue.contains(CHUNK_TO_CONTENT) && (hrefValue != null || copytoValue != null || topicref.hasChildNodes())) {
    if (chunkValue.contains(CHUNK_BY_TOPIC)) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"").setLocation(topicref).toString());
    }
    processChunk(topicref,false);
  }
 else   if (chunkValue.contains(CHUNK_TO_NAVIGATION) && supportToNavigation) {
    processChildTopicref(topicref);
    processNavitation(topicref);
  }
 else   if (chunkByToken.equals(CHUNK_BY_TOPIC)) {
    processChunk(topicref,true);
    processChildTopicref(topicref);
  }
 else {
    URI currentPath=null;
    if (copytoValue != null) {
      currentPath=inputFile.resolve(copytoValue);
    }
 else     if (hrefValue != null) {
      currentPath=inputFile.resolve(hrefValue);
    }
    if (currentPath != null) {
      if (changeTable.containsKey(currentPath)) {
        changeTable.remove(currentPath);
      }
      final String processingRole=getCascadeValue(topicref,ATTRIBUTE_NAME_PROCESSING_ROLE);
      if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {
        changeTable.put(currentPath,currentPath);
      }
    }
    processChildTopicref(topicref);
  }
}","private void processTopicref(final Element topicref){
  final String xtrfValue=getValue(topicref,ATTRIBUTE_NAME_XTRF);
  if (xtrfValue != null && xtrfValue.contains(ATTR_XTRF_VALUE_GENERATED)) {
    return;
  }
  final Collection<String> chunkValue=split(getValue(topicref,ATTRIBUTE_NAME_CHUNK));
  if (topicref.getAttributeNode(ATTRIBUTE_NAME_HREF) == null && chunkValue.contains(CHUNK_TO_CONTENT)) {
    generateStumpTopic(topicref);
  }
  final URI hrefValue=toURI(getValue(topicref,ATTRIBUTE_NAME_HREF));
  final URI copytoValue=toURI(getValue(topicref,ATTRIBUTE_NAME_COPY_TO));
  final String scopeValue=getCascadeValue(topicref,ATTRIBUTE_NAME_SCOPE);
  final String chunkByToken=getChunkByToken(chunkValue,""String_Node_Str"",defaultChunkByToken);
  if (ATTR_SCOPE_VALUE_EXTERNAL.equals(scopeValue) || (hrefValue != null && !toFile(inputFile.resolve(hrefValue.toString())).exists()) || (chunkValue.isEmpty() && hrefValue == null)) {
    processChildTopicref(topicref);
  }
 else   if (chunkValue.contains(CHUNK_TO_CONTENT) && (hrefValue != null || copytoValue != null || topicref.hasChildNodes())) {
    if (chunkValue.contains(CHUNK_BY_TOPIC)) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"").setLocation(topicref).toString());
    }
    processChunk(topicref,false);
  }
 else   if (chunkValue.contains(CHUNK_TO_NAVIGATION) && supportToNavigation) {
    processChildTopicref(topicref);
    processNavitation(topicref);
  }
 else   if (chunkByToken.equals(CHUNK_BY_TOPIC)) {
    processChunk(topicref,true);
    processChildTopicref(topicref);
  }
 else {
    URI currentPath=null;
    if (copytoValue != null) {
      currentPath=inputFile.resolve(copytoValue);
    }
 else     if (hrefValue != null) {
      currentPath=inputFile.resolve(hrefValue);
    }
    if (currentPath != null) {
      if (changeTable.containsKey(currentPath)) {
        changeTable.remove(currentPath);
      }
      final String processingRole=getCascadeValue(topicref,ATTRIBUTE_NAME_PROCESSING_ROLE);
      if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {
        changeTable.put(currentPath,currentPath);
      }
    }
    processChildTopicref(topicref);
  }
}",0.9986345015930814
100640,"/** 
 * Duplicate branches so that each   {@code ditavalref} will in a separate branch.
 */
private void splitBranches(final Element elem,final Branch filter){
  final List<Element> ditavalRefs=getChildElements(elem,DITAVAREF_D_DITAVALREF);
  if (ditavalRefs.size() > 0) {
    for (    final Element branch : ditavalRefs) {
      elem.removeChild(branch);
    }
    final List<Element> branches=new ArrayList<>(ditavalRefs.size());
    branches.add(elem);
    final Node next=elem.getNextSibling();
    for (int i=1; i < ditavalRefs.size(); i++) {
      final Element clone=(Element)elem.cloneNode(true);
      if (next != null) {
        elem.getParentNode().insertBefore(clone,next);
      }
 else {
        elem.getParentNode().appendChild(clone);
      }
      branches.add(clone);
    }
    for (int i=0; i < branches.size(); i++) {
      final Element branch=branches.get(i);
      final Element ditavalref=ditavalRefs.get(i);
      branch.insertBefore(ditavalref,branch.getFirstChild());
      final Branch currentFilter=filter.merge(ditavalref);
      processAttributes(branch,currentFilter);
      for (      final Element child : getChildElements(branch,MAP_TOPICREF)) {
        if (DITAVAREF_D_DITAVALREF.matches(child)) {
          continue;
        }
        splitBranches(child,currentFilter);
      }
    }
  }
 else {
    processAttributes(elem,filter);
    for (    final Element child : getChildElements(elem,MAP_TOPICREF)) {
      splitBranches(child,filter);
    }
  }
}","/** 
 * Duplicate branches so that each   {@code ditavalref} will in a separate branch.
 */
private void splitBranches(final Element elem,final Branch filter){
  final List<Element> ditavalRefs=getChildElements(elem,DITAVAREF_D_DITAVALREF);
  if (ditavalRefs.size() > 0) {
    for (    final Element branch : ditavalRefs) {
      elem.removeChild(branch);
    }
    final List<Element> branches=new ArrayList<>(ditavalRefs.size());
    branches.add(elem);
    final Node next=elem.getNextSibling();
    for (int i=1; i < ditavalRefs.size(); i++) {
      final Element clone=(Element)elem.cloneNode(true);
      if (next != null) {
        elem.getParentNode().insertBefore(clone,next);
      }
 else {
        elem.getParentNode().appendChild(clone);
      }
      branches.add(clone);
    }
    for (int i=0; i < branches.size(); i++) {
      final Element branch=branches.get(i);
      final Element ditavalref=ditavalRefs.get(i);
      branch.insertBefore(ditavalref,branch.getFirstChild());
      final Branch currentFilter=filter.merge(ditavalref);
      processAttributes(branch,currentFilter);
      final Branch childFilter=new Branch(currentFilter.resourcePrefix,currentFilter.resourceSuffix,null,null);
      for (      final Element child : getChildElements(branch,MAP_TOPICREF)) {
        if (DITAVAREF_D_DITAVALREF.matches(child)) {
          continue;
        }
        splitBranches(child,childFilter);
      }
    }
  }
 else {
    processAttributes(elem,filter);
    for (    final Element child : getChildElements(elem,MAP_TOPICREF)) {
      splitBranches(child,filter);
    }
  }
}",0.9605177993527508
100641,"private void processAttributes(final Element elem,final Branch filter){
  if (filter.resourcePrefix != null || filter.resourceSuffix != null) {
    final String href=elem.getAttribute(ATTRIBUTE_NAME_HREF);
    final String copyTo=elem.getAttribute(ATTRIBUTE_NAME_COPY_TO);
    final String scope=elem.getAttribute(ATTRIBUTE_NAME_SCOPE);
    if ((!href.isEmpty() || !copyTo.isEmpty()) && !scope.equals(ATTR_SCOPE_VALUE_EXTERNAL)) {
      elem.setAttribute(BRANCH_COPY_TO,generateCopyTo(copyTo.isEmpty() ? href : copyTo,filter).toString());
      if (!copyTo.isEmpty()) {
        elem.removeAttribute(ATTRIBUTE_NAME_COPY_TO);
      }
    }
  }
  if ((filter.keyscopePrefix != null || filter.keyscopeSuffix != null)) {
    final String keyscope=elem.getAttribute(ATTRIBUTE_NAME_KEYSCOPE);
    if (!keyscope.isEmpty()) {
      final StringBuilder buf=new StringBuilder();
      for (      final String key : keyscope.trim().split(""String_Node_Str"")) {
        if (filter.keyscopePrefix != null) {
          buf.append(filter.keyscopePrefix);
        }
        buf.append(key);
        if (filter.keyscopeSuffix != null) {
          buf.append(filter.keyscopeSuffix);
        }
        buf.append(' ');
      }
      elem.setAttribute(ATTRIBUTE_NAME_KEYSCOPE,buf.toString().trim());
    }
  }
}","private void processAttributes(final Element elem,final Branch filter){
  if (filter.resourcePrefix != null || filter.resourceSuffix != null) {
    final String href=elem.getAttribute(ATTRIBUTE_NAME_HREF);
    final String copyTo=elem.getAttribute(ATTRIBUTE_NAME_COPY_TO);
    final String scope=elem.getAttribute(ATTRIBUTE_NAME_SCOPE);
    if ((!href.isEmpty() || !copyTo.isEmpty()) && !scope.equals(ATTR_SCOPE_VALUE_EXTERNAL)) {
      elem.setAttribute(BRANCH_COPY_TO,generateCopyTo(copyTo.isEmpty() ? href : copyTo,filter).toString());
      if (!copyTo.isEmpty()) {
        elem.removeAttribute(ATTRIBUTE_NAME_COPY_TO);
      }
    }
  }
  if (filter.keyscopePrefix != null || filter.keyscopeSuffix != null) {
    final StringBuilder buf=new StringBuilder();
    final String keyscope=elem.getAttribute(ATTRIBUTE_NAME_KEYSCOPE);
    if (!keyscope.isEmpty()) {
      for (      final String key : keyscope.trim().split(""String_Node_Str"")) {
        if (filter.keyscopePrefix != null) {
          buf.append(filter.keyscopePrefix);
        }
        buf.append(key);
        if (filter.keyscopeSuffix != null) {
          buf.append(filter.keyscopeSuffix);
        }
        buf.append(' ');
      }
    }
 else {
      if (filter.keyscopePrefix != null) {
        buf.append(filter.keyscopePrefix);
      }
      if (filter.keyscopeSuffix != null) {
        buf.append(filter.keyscopeSuffix);
      }
    }
    elem.setAttribute(ATTRIBUTE_NAME_KEYSCOPE,buf.toString().trim());
  }
}",0.8868060562364816
100642,"/** 
 * Read key definitions
 * @param filename absolute URI to DITA map with key definitions
 */
public void read(final URI filename,final Document doc) throws DITAOTException {
  rootScope=null;
  KeyScope keyScope=readScopes(doc);
  keyScope=cascadeChildKeys(keyScope);
  keyScope=inheritParentKeys(keyScope);
  rootScope=resolveIntermediate(keyScope);
}","/** 
 * Read key definitions
 * @param filename absolute URI to DITA map with key definitions
 */
public void read(final URI filename,final Document doc) throws DITAOTException {
  currentFile=filename;
  rootScope=null;
  KeyScope keyScope=readScopes(doc);
  keyScope=cascadeChildKeys(keyScope);
  keyScope=inheritParentKeys(keyScope);
  rootScope=resolveIntermediate(keyScope);
}",0.967479674796748
100643,"private void readKeyDefinition(final Element elem,final Map<String,KeyDef> keyDefs){
  final String keyName=elem.getAttribute(ATTRIBUTE_NAME_KEYS);
  if (!keyName.isEmpty()) {
    for (    final String key : keyName.trim().split(""String_Node_Str"")) {
      if (!keyDefs.containsKey(key)) {
        final Document d=builder.newDocument();
        final Element copy=(Element)d.importNode(elem,true);
        d.appendChild(copy);
        final String h=copy.getAttribute(ATTRIBUTE_NAME_HREF);
        final URI href=h.isEmpty() ? null : toURI(h);
        final String s=copy.getAttribute(ATTRIBUTE_NAME_SCOPE);
        final String scope=s.isEmpty() ? null : s;
        final KeyDef keyDef=new KeyDef(key,href,scope,null,copy);
        keyDefs.put(key,keyDef);
      }
    }
  }
}","private void readKeyDefinition(final Element elem,final Map<String,KeyDef> keyDefs){
  final String keyName=elem.getAttribute(ATTRIBUTE_NAME_KEYS);
  if (!keyName.isEmpty()) {
    for (    final String key : keyName.trim().split(""String_Node_Str"")) {
      if (!keyDefs.containsKey(key)) {
        final Document d=builder.newDocument();
        final Element copy=(Element)d.importNode(elem,true);
        d.appendChild(copy);
        final String h=copy.getAttribute(ATTRIBUTE_NAME_HREF);
        final URI href=h.isEmpty() ? null : toURI(h);
        final String s=copy.getAttribute(ATTRIBUTE_NAME_SCOPE);
        final String scope=s.isEmpty() ? null : s;
        final KeyDef keyDef=new KeyDef(key,href,scope,currentFile,copy);
        keyDefs.put(key,keyDef);
      }
    }
  }
}",0.9904030710172744
100644,"private Attributes processElement(final Attributes atts){
  final AttributesImpl resAtts=new AttributesImpl(atts);
  boolean valid=false;
  for (  final Map.Entry<String,String> attrPair : currentElement.attrs.entrySet()) {
    final String keyrefAttr=attrPair.getKey();
    final String refAttr=attrPair.getValue();
    final String keyrefValue=atts.getValue(keyrefAttr);
    if (keyrefValue != null) {
      final int slashIndex=keyrefValue.indexOf(SLASH);
      String keyName=keyrefValue;
      String elementId=""String_Node_Str"";
      if (slashIndex != -1) {
        keyName=keyrefValue.substring(0,slashIndex);
        elementId=keyrefValue.substring(slashIndex);
      }
      keyDef=definitionMap.get(keyName);
      final Element elem=keyDef != null ? keyDef.element : null;
      if (keyDef != null) {
        if (currentElement != null) {
          final NamedNodeMap attrs=elem.getAttributes();
          final URI target=keyDef != null ? keyDef.href : null;
          if (target != null && !target.toString().isEmpty()) {
            if (TOPIC_IMAGE.matches(currentElement.type)) {
              valid=true;
              final URI targetOutput=normalizeHrefValue(URLUtils.getRelativePath(currentFile,job.tempDir.toURI().resolve(target)),elementId);
              XMLUtils.addOrSetAttribute(resAtts,refAttr,targetOutput.toString());
            }
 else             if (isLocalDita(elem)) {
              final File topicFile=toFile(job.tempDir.toURI().resolve(stripFragment(target)));
              valid=true;
              final String topicId=getFirstTopicId(topicFile);
              final URI targetOutput=normalizeHrefValue(URLUtils.getRelativePath(currentFile,job.tempDir.toURI().resolve(target)),elementId,topicId);
              XMLUtils.addOrSetAttribute(resAtts,refAttr,targetOutput.toString());
              if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(atts.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE))) {
                final URI f=currentFile.resolve(targetOutput);
                normalProcessingRoleTargets.add(f);
              }
            }
 else {
              valid=true;
              final URI targetOutput=normalizeHrefValue(target,elementId);
              XMLUtils.addOrSetAttribute(resAtts,refAttr,targetOutput.toString());
            }
          }
 else           if (target == null || target.toString().isEmpty()) {
            valid=true;
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
          }
 else {
            final MessageBean m=definitionMap.name == null ? MessageUtils.getInstance().getMessage(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF)) : MessageUtils.getInstance().getMessage(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF),definitionMap.name);
            logger.info(m.setLocation(atts).toString());
          }
          if (valid) {
            if (MAP_TOPICREF.matches(currentElement.type)) {
              for (int index=0; index < attrs.getLength(); index++) {
                final Attr attr=(Attr)attrs.item(index);
                if (!no_copy.contains(attr.getNodeName())) {
                  XMLUtils.removeAttribute(resAtts,attr.getNodeName());
                  XMLUtils.addOrSetAttribute(resAtts,attr);
                }
              }
            }
 else {
              for (int index=0; index < attrs.getLength(); index++) {
                final Attr attr=(Attr)attrs.item(index);
                if (!no_copy_topic.contains(attr.getNodeName()) && (attr.getNodeName().equals(refAttr) || resAtts.getIndex(attr.getNodeName()) == -1)) {
                  XMLUtils.removeAttribute(resAtts,attr.getNodeName());
                  XMLUtils.addOrSetAttribute(resAtts,attr);
                }
              }
            }
          }
        }
      }
 else {
        final MessageBean m=definitionMap.name == null ? MessageUtils.getInstance().getMessage(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF)) : MessageUtils.getInstance().getMessage(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF),definitionMap.name);
        logger.info(m.setLocation(atts).toString());
      }
      validKeyref.push(valid);
    }
  }
  return resAtts;
}","private Attributes processElement(final Attributes atts){
  final AttributesImpl resAtts=new AttributesImpl(atts);
  boolean valid=false;
  for (  final Map.Entry<String,String> attrPair : currentElement.attrs.entrySet()) {
    final String keyrefAttr=attrPair.getKey();
    final String refAttr=attrPair.getValue();
    final String keyrefValue=atts.getValue(keyrefAttr);
    if (keyrefValue != null) {
      final int slashIndex=keyrefValue.indexOf(SLASH);
      String keyName=keyrefValue;
      String elementId=""String_Node_Str"";
      if (slashIndex != -1) {
        keyName=keyrefValue.substring(0,slashIndex);
        elementId=keyrefValue.substring(slashIndex);
      }
      keyDef=definitionMap.get(keyName);
      final Element elem=keyDef != null ? keyDef.element : null;
      if (keyDef != null) {
        if (currentElement != null) {
          final NamedNodeMap attrs=elem.getAttributes();
          final URI href=keyDef.href;
          if (href != null && !href.toString().isEmpty()) {
            if (TOPIC_IMAGE.matches(currentElement.type)) {
              valid=true;
              final URI targetOutput=normalizeHrefValue(URLUtils.getRelativePath(currentFile,job.tempDir.toURI().resolve(href)),elementId);
              XMLUtils.addOrSetAttribute(resAtts,refAttr,targetOutput.toString());
            }
 else             if (isLocalDita(elem) && keyDef.source != null) {
              final File topicFile=toFile(currentFile.resolve(stripFragment(keyDef.source.resolve(href))));
              valid=true;
              final String topicId=getFirstTopicId(topicFile);
              final URI targetOutput=normalizeHrefValue(URLUtils.getRelativePath(currentFile,topicFile.toURI()),elementId,topicId);
              XMLUtils.addOrSetAttribute(resAtts,refAttr,targetOutput.toString());
              if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(atts.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE))) {
                final URI f=currentFile.resolve(targetOutput);
                normalProcessingRoleTargets.add(f);
              }
            }
 else {
              valid=true;
              final URI targetOutput=normalizeHrefValue(href,elementId);
              XMLUtils.addOrSetAttribute(resAtts,refAttr,targetOutput.toString());
            }
          }
 else           if (href == null || href.toString().isEmpty()) {
            valid=true;
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
          }
 else {
            final MessageBean m=definitionMap.name == null ? MessageUtils.getInstance().getMessage(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF)) : MessageUtils.getInstance().getMessage(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF),definitionMap.name);
            logger.info(m.setLocation(atts).toString());
          }
          if (valid) {
            if (MAP_TOPICREF.matches(currentElement.type)) {
              for (int index=0; index < attrs.getLength(); index++) {
                final Attr attr=(Attr)attrs.item(index);
                if (!no_copy.contains(attr.getNodeName())) {
                  XMLUtils.removeAttribute(resAtts,attr.getNodeName());
                  XMLUtils.addOrSetAttribute(resAtts,attr);
                }
              }
            }
 else {
              for (int index=0; index < attrs.getLength(); index++) {
                final Attr attr=(Attr)attrs.item(index);
                if (!no_copy_topic.contains(attr.getNodeName()) && (attr.getNodeName().equals(refAttr) || resAtts.getIndex(attr.getNodeName()) == -1)) {
                  XMLUtils.removeAttribute(resAtts,attr.getNodeName());
                  XMLUtils.addOrSetAttribute(resAtts,attr);
                }
              }
            }
          }
        }
      }
 else {
        final MessageBean m=definitionMap.name == null ? MessageUtils.getInstance().getMessage(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF)) : MessageUtils.getInstance().getMessage(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF),definitionMap.name);
        logger.info(m.setLocation(atts).toString());
      }
      validKeyref.push(valid);
    }
  }
  return resAtts;
}",0.9715726730857404
100645,"/** 
 * Update Job configuration to include new generated files
 */
private void updateList(final Map<URI,URI> changeTable,final Map<URI,URI> conflictTable){
  final URI xmlDitalist=job.tempDir.toURI().resolve(""String_Node_Str"");
  final Set<URI> hrefTopics=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.uri);
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final URI s=f.uri;
      if (s.getFragment() == null) {
        final Iterator<URI> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final URI ent=hrefit.next();
          if (resolve(job.tempDir,ent).equals(resolve(job.tempDir,s))) {
            hrefit.remove();
          }
        }
      }
 else       if (hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<URI> topicList=new LinkedHashSet<>(128);
  final Set<URI> oldTopicList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.uri);
    }
  }
  for (  final URI hrefTopic : hrefTopics) {
    final URI t=getRelativePath(xmlDitalist,job.tempDir.toURI().resolve(stripFragment(hrefTopic.toString())));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<URI> chunkedTopicSet=new LinkedHashSet<>(128);
  final Set<URI> chunkedDitamapSet=new LinkedHashSet<>(128);
  final Set<URI> ditamapList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.uri);
    }
  }
  for (  final Map.Entry<URI,URI> entry : changeTable.entrySet()) {
    final URI oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      URI newChunkedFile=entry.getValue();
      newChunkedFile=getRelativePath(xmlDitalist,newChunkedFile);
      final String extName=getExtension(newChunkedFile.getPath());
      if (extName != null && !extName.equalsIgnoreCase(ATTR_FORMAT_VALUE_DITAMAP)) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final URI s : oldTopicList) {
    final File f=new File(job.tempDir.toURI().resolve(s));
    if (f.exists() && !f.delete()) {
      logger.error(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
  for (  final Map.Entry<URI,URI> entry : changeTable.entrySet()) {
    final URI oldFile=entry.getKey();
    final URI from=entry.getValue();
    if (from.equals(oldFile)) {
      final URI targetPath=conflictTable.get(oldFile);
      if (targetPath != null) {
        final URI target=targetPath;
        if (!new File(target).exists()) {
          URI relativePath=getRelativePath(xmlDitalist,from);
          final URI relativeTargetPath=getRelativePath(xmlDitalist,target);
          if (relativeTargetPath.getPath().indexOf(URI_SEPARATOR) != -1) {
            relativePath2fix.put(relativeTargetPath.getPath(),relativeTargetPath.getPath().substring(0,relativeTargetPath.getPath().lastIndexOf(URI_SEPARATOR) + 1));
          }
          try {
            deleteQuietly(new File(target));
            moveFile(new File(from),new File(target));
          }
 catch (          final IOException e) {
            logger.error(""String_Node_Str"" + e.getMessage(),e);
          }
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativePath(xmlDitalist,target);
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(oldFile);
        }
      }
    }
  }
  final Set<URI> all=new HashSet<>();
  all.addAll(topicList);
  all.addAll(ditamapList);
  all.addAll(chunkedDitamapSet);
  all.addAll(chunkedTopicSet);
  for (  final URI file : oldTopicList) {
    if (!all.contains(file)) {
      job.remove(job.getOrCreateFileInfo(file));
    }
  }
  for (  final URI file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
  }
  for (  final URI file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}","/** 
 * Update Job configuration to include new generated files
 */
private void updateList(final Map<URI,URI> changeTable,final Map<URI,URI> conflictTable){
  final URI xmlDitalist=job.tempDir.toURI().resolve(""String_Node_Str"");
  final Set<URI> hrefTopics=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.uri);
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final URI s=f.uri;
      if (s.getFragment() == null) {
        final Iterator<URI> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final URI ent=hrefit.next();
          if (job.tempDir.toURI().resolve(ent).equals(job.tempDir.toURI().resolve(s))) {
            hrefit.remove();
          }
        }
      }
 else       if (hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<URI> topicList=new LinkedHashSet<>(128);
  final Set<URI> oldTopicList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.uri);
    }
  }
  for (  final URI hrefTopic : hrefTopics) {
    final URI t=getRelativePath(xmlDitalist,job.tempDir.toURI().resolve(stripFragment(hrefTopic)));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<URI> chunkedTopicSet=new LinkedHashSet<>(128);
  final Set<URI> chunkedDitamapSet=new LinkedHashSet<>(128);
  final Set<URI> ditamapList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.uri);
    }
  }
  for (  final Map.Entry<URI,URI> entry : changeTable.entrySet()) {
    final URI oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      URI newChunkedFile=entry.getValue();
      newChunkedFile=getRelativePath(xmlDitalist,newChunkedFile);
      final String extName=getExtension(newChunkedFile.getPath());
      if (extName != null && !extName.equalsIgnoreCase(ATTR_FORMAT_VALUE_DITAMAP)) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final URI s : oldTopicList) {
    final File f=new File(job.tempDir.toURI().resolve(s));
    if (f.exists() && !f.delete()) {
      logger.error(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
  for (  final Map.Entry<URI,URI> entry : changeTable.entrySet()) {
    final URI oldFile=entry.getKey();
    final URI from=entry.getValue();
    if (from.equals(oldFile)) {
      final URI targetPath=conflictTable.get(oldFile);
      if (targetPath != null) {
        final URI target=targetPath;
        if (!new File(target).exists()) {
          URI relativePath=getRelativePath(xmlDitalist,from);
          final URI relativeTargetPath=getRelativePath(xmlDitalist,target);
          if (relativeTargetPath.getPath().contains(URI_SEPARATOR)) {
            relativePath2fix.put(relativeTargetPath.getPath(),relativeTargetPath.getPath().substring(0,relativeTargetPath.getPath().lastIndexOf(URI_SEPARATOR) + 1));
          }
          try {
            deleteQuietly(new File(target));
            moveFile(new File(from),new File(target));
          }
 catch (          final IOException e) {
            logger.error(""String_Node_Str"" + e.getMessage(),e);
          }
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativePath(xmlDitalist,target);
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(oldFile);
        }
      }
    }
  }
  final Set<URI> all=new HashSet<>();
  all.addAll(topicList);
  all.addAll(ditamapList);
  all.addAll(chunkedDitamapSet);
  all.addAll(chunkedTopicSet);
  for (  final URI file : oldTopicList) {
    if (!all.contains(file)) {
      job.remove(job.getOrCreateFileInfo(file));
    }
  }
  for (  final URI file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
  }
  for (  final URI file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9909519321394912
100646,"private void updateReltable(final Element elem){
  final String hrefValue=elem.getAttribute(ATTRIBUTE_NAME_HREF);
  if (hrefValue.length() != 0) {
    if (changeTable.containsKey(inputFile.resolve(hrefValue).getPath())) {
      URI resulthrefValue=getRelativePath(inputFile.resolve(FILE_NAME_STUB_DITAMAP),inputFile.resolve(hrefValue));
      final String fragment=getFragment(hrefValue);
      if (fragment != null) {
        resulthrefValue=setFragment(resulthrefValue,fragment);
      }
      elem.setAttribute(ATTRIBUTE_NAME_HREF,resulthrefValue.toString());
    }
  }
  final NodeList children=elem.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node current=children.item(i);
    if (current.getNodeType() == Node.ELEMENT_NODE) {
      final Element currentElem=(Element)current;
      final String classValue=currentElem.getAttribute(ATTRIBUTE_NAME_CLASS);
      if (MAP_TOPICREF.matches(classValue)) {
      }
    }
  }
}","private void updateReltable(final Element elem){
  final String hrefValue=elem.getAttribute(ATTRIBUTE_NAME_HREF);
  if (hrefValue.length() != 0) {
    if (changeTable.containsKey(inputFile.resolve(hrefValue))) {
      URI resulthrefValue=getRelativePath(inputFile.resolve(FILE_NAME_STUB_DITAMAP),inputFile.resolve(hrefValue));
      final String fragment=getFragment(hrefValue);
      if (fragment != null) {
        resulthrefValue=setFragment(resulthrefValue,fragment);
      }
      elem.setAttribute(ATTRIBUTE_NAME_HREF,resulthrefValue.toString());
    }
  }
  final NodeList children=elem.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node current=children.item(i);
    if (current.getNodeType() == Node.ELEMENT_NODE) {
      final Element currentElem=(Element)current;
      final String classValue=currentElem.getAttribute(ATTRIBUTE_NAME_CLASS);
      if (MAP_TOPICREF.matches(classValue)) {
      }
    }
  }
}",0.994753410283316
100647,"private void processChildTopicref(final Element node){
  final NodeList children=node.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node current=children.item(i);
    if (current.getNodeType() == Node.ELEMENT_NODE) {
      final Element currentElem=(Element)current;
      final String classValue=currentElem.getAttribute(ATTRIBUTE_NAME_CLASS);
      if (MAP_TOPICREF.matches(classValue)) {
        final String hrefValue=currentElem.getAttribute(ATTRIBUTE_NAME_HREF);
        final String xtrfValue=currentElem.getAttribute(ATTRIBUTE_NAME_XTRF);
        if (hrefValue.length() == 0) {
          processTopicref(currentElem);
        }
 else         if (!ATTR_XTRF_VALUE_GENERATED.equals(xtrfValue) && !inputFile.resolve(hrefValue).getPath().equals(changeTable.get(inputFile.resolve(hrefValue).getPath()))) {
          processTopicref(currentElem);
        }
      }
    }
  }
}","private void processChildTopicref(final Element node){
  final NodeList children=node.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node current=children.item(i);
    if (current.getNodeType() == Node.ELEMENT_NODE) {
      final Element currentElem=(Element)current;
      final String classValue=currentElem.getAttribute(ATTRIBUTE_NAME_CLASS);
      if (MAP_TOPICREF.matches(classValue)) {
        final String hrefValue=currentElem.getAttribute(ATTRIBUTE_NAME_HREF);
        final String xtrfValue=currentElem.getAttribute(ATTRIBUTE_NAME_XTRF);
        if (hrefValue.length() == 0) {
          processTopicref(currentElem);
        }
 else         if (!ATTR_XTRF_VALUE_GENERATED.equals(xtrfValue) && !inputFile.resolve(hrefValue).equals(changeTable.get(inputFile.resolve(hrefValue)))) {
          processTopicref(currentElem);
        }
      }
    }
  }
}",0.9888641425389756
100648,"private void processTopicref(final Element topicref){
  final String xtrfValue=getValue(topicref,ATTRIBUTE_NAME_XTRF);
  if (xtrfValue != null && xtrfValue.contains(ATTR_XTRF_VALUE_GENERATED)) {
    return;
  }
  final Collection<String> chunkValue=split(getValue(topicref,ATTRIBUTE_NAME_CHUNK));
  if (topicref.getAttributeNode(ATTRIBUTE_NAME_HREF) == null && chunkValue.contains(CHUNK_TO_CONTENT)) {
    generateStumpTopic(topicref);
  }
  final URI hrefValue=toURI(getValue(topicref,ATTRIBUTE_NAME_HREF));
  final URI copytoValue=toURI(getValue(topicref,ATTRIBUTE_NAME_COPY_TO));
  final String scopeValue=getCascadeValue(topicref,ATTRIBUTE_NAME_SCOPE);
  final String chunkByToken=getChunkByToken(chunkValue,""String_Node_Str"",defaultChunkByToken);
  if (ATTR_SCOPE_VALUE_EXTERNAL.equals(scopeValue) || (hrefValue != null && !new File(inputFile.resolve(hrefValue.toString())).exists()) || (chunkValue.isEmpty() && hrefValue == null)) {
    processChildTopicref(topicref);
  }
 else   if (chunkValue.contains(CHUNK_TO_CONTENT) && (hrefValue != null || copytoValue != null || topicref.hasChildNodes())) {
    if (chunkValue.contains(CHUNK_BY_TOPIC)) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"").setLocation(topicref).toString());
    }
    processChunk(topicref,false);
  }
 else   if (chunkValue.contains(CHUNK_TO_NAVIGATION) && supportToNavigation) {
    processChildTopicref(topicref);
    processNavitation(topicref);
  }
 else   if (chunkByToken.equals(CHUNK_BY_TOPIC)) {
    processChunk(topicref,true);
    processChildTopicref(topicref);
  }
 else {
    String currentPath=null;
    if (copytoValue != null) {
      currentPath=inputFile.resolve(copytoValue).getPath();
    }
 else     if (hrefValue != null) {
      currentPath=inputFile.resolve(hrefValue).getPath();
    }
    if (currentPath != null) {
      if (changeTable.containsKey(currentPath)) {
        changeTable.remove(currentPath);
      }
      final String processingRole=getCascadeValue(topicref,ATTRIBUTE_NAME_PROCESSING_ROLE);
      if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {
        changeTable.put(toURI(currentPath),toURI(currentPath));
      }
    }
    processChildTopicref(topicref);
  }
}","private void processTopicref(final Element topicref){
  final String xtrfValue=getValue(topicref,ATTRIBUTE_NAME_XTRF);
  if (xtrfValue != null && xtrfValue.contains(ATTR_XTRF_VALUE_GENERATED)) {
    return;
  }
  final Collection<String> chunkValue=split(getValue(topicref,ATTRIBUTE_NAME_CHUNK));
  if (topicref.getAttributeNode(ATTRIBUTE_NAME_HREF) == null && chunkValue.contains(CHUNK_TO_CONTENT)) {
    generateStumpTopic(topicref);
  }
  final URI hrefValue=toURI(getValue(topicref,ATTRIBUTE_NAME_HREF));
  final URI copytoValue=toURI(getValue(topicref,ATTRIBUTE_NAME_COPY_TO));
  final String scopeValue=getCascadeValue(topicref,ATTRIBUTE_NAME_SCOPE);
  final String chunkByToken=getChunkByToken(chunkValue,""String_Node_Str"",defaultChunkByToken);
  if (ATTR_SCOPE_VALUE_EXTERNAL.equals(scopeValue) || (hrefValue != null && !new File(inputFile.resolve(hrefValue.toString())).exists()) || (chunkValue.isEmpty() && hrefValue == null)) {
    processChildTopicref(topicref);
  }
 else   if (chunkValue.contains(CHUNK_TO_CONTENT) && (hrefValue != null || copytoValue != null || topicref.hasChildNodes())) {
    if (chunkValue.contains(CHUNK_BY_TOPIC)) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"").setLocation(topicref).toString());
    }
    processChunk(topicref,false);
  }
 else   if (chunkValue.contains(CHUNK_TO_NAVIGATION) && supportToNavigation) {
    processChildTopicref(topicref);
    processNavitation(topicref);
  }
 else   if (chunkByToken.equals(CHUNK_BY_TOPIC)) {
    processChunk(topicref,true);
    processChildTopicref(topicref);
  }
 else {
    URI currentPath=null;
    if (copytoValue != null) {
      currentPath=inputFile.resolve(copytoValue);
    }
 else     if (hrefValue != null) {
      currentPath=inputFile.resolve(hrefValue);
    }
    if (currentPath != null) {
      if (changeTable.containsKey(currentPath)) {
        changeTable.remove(currentPath);
      }
      final String processingRole=getCascadeValue(topicref,ATTRIBUTE_NAME_PROCESSING_ROLE);
      if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {
        changeTable.put(currentPath,currentPath);
      }
    }
    processChildTopicref(topicref);
  }
}",0.990300022558087
100649,"private Attributes processAttributes(final Attributes atts){
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final AttributesImpl resAtts=new AttributesImpl(atts);
  for (int i=0; i < resAtts.getLength(); i++) {
    final String attrName=resAtts.getQName(i);
    String attrValue=resAtts.getValue(i);
    if (ATTRIBUTE_NAME_ID.equals(attrName)) {
      final String idValue=attrValue;
      if (TOPIC_TOPIC.matches(classValue)) {
        if (topicID.contains(attrValue)) {
          final String oldAttrValue=attrValue;
          attrValue=chunkFilenameGenerator.generateID();
          topicID.add(attrValue);
          final URI tmpValId=changeTable.get(setFragment(currentParsingFile,idValue));
          if (tmpValId != null && tmpValId.equals(setFragment(outputFile,idValue))) {
            changeTable.put(setFragment(currentParsingFile,idValue),setFragment(outputFile,attrValue));
          }
          final URI tmpVal=changeTable.get(currentParsingFile);
          if (tmpVal != null && tmpVal.equals(setFragment(outputFile,idValue))) {
            changeTable.put(currentParsingFile,setFragment(outputFile,attrValue));
          }
          currentParsingFileTopicIDChangeTable.put(oldAttrValue,attrValue);
        }
 else {
          topicID.add(attrValue);
        }
      }
    }
 else     if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
      if (checkHREF(resAtts)) {
        URI relative=getRelativePath(outputFile,currentParsingFile);
        if (conflictTable.containsKey(outputFile.getPath())) {
          final URI realoutputfile=conflictTable.get(outputFile);
          relative=getRelativePath(realoutputfile,currentParsingFile);
        }
        if (attrValue.startsWith(SHARP)) {
          attrValue=relative + attrValue;
        }
 else         if (relative.toString().contains(SLASH)) {
          relative=setPath(relative,relative.getPath().substring(0,relative.getPath().lastIndexOf(SLASH)));
          attrValue=relative.resolve(attrValue).toString();
        }
      }
    }
    resAtts.setValue(i,attrValue);
  }
  if (TOPIC_TOPIC.matches(classValue) && resAtts.getValue(ATTRIBUTE_NAMESPACE_PREFIX_DITAARCHVERSION) == null) {
    addOrSetAttribute(resAtts,ATTRIBUTE_NAMESPACE_PREFIX_DITAARCHVERSION,DITA_NAMESPACE);
  }
  if (TOPIC_TOPIC.matches(classValue) && resAtts.getValue(XMLNS_ATTRIBUTE + ""String_Node_Str"" + DITA_OT_PREFIX) == null) {
    addOrSetAttribute(resAtts,XMLNS_ATTRIBUTE + ""String_Node_Str"" + DITA_OT_PREFIX,DITA_OT_NS);
  }
  return resAtts;
}","private Attributes processAttributes(final Attributes atts){
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final AttributesImpl resAtts=new AttributesImpl(atts);
  for (int i=0; i < resAtts.getLength(); i++) {
    final String attrName=resAtts.getQName(i);
    String attrValue=resAtts.getValue(i);
    if (ATTRIBUTE_NAME_ID.equals(attrName)) {
      final String idValue=attrValue;
      if (TOPIC_TOPIC.matches(classValue)) {
        if (topicID.contains(attrValue)) {
          final String oldAttrValue=attrValue;
          attrValue=chunkFilenameGenerator.generateID();
          topicID.add(attrValue);
          final URI tmpValId=changeTable.get(setFragment(currentParsingFile,idValue));
          if (tmpValId != null && tmpValId.equals(setFragment(outputFile,idValue))) {
            changeTable.put(setFragment(currentParsingFile,idValue),setFragment(outputFile,attrValue));
          }
          final URI tmpVal=changeTable.get(currentParsingFile);
          if (tmpVal != null && tmpVal.equals(setFragment(outputFile,idValue))) {
            changeTable.put(currentParsingFile,setFragment(outputFile,attrValue));
          }
          currentParsingFileTopicIDChangeTable.put(oldAttrValue,attrValue);
        }
 else {
          topicID.add(attrValue);
        }
      }
    }
 else     if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
      if (checkHREF(resAtts)) {
        URI relative=getRelativePath(outputFile,currentParsingFile);
        if (conflictTable.containsKey(outputFile)) {
          final URI realoutputfile=conflictTable.get(outputFile);
          relative=getRelativePath(realoutputfile,currentParsingFile);
        }
        if (attrValue.startsWith(SHARP)) {
          attrValue=relative + attrValue;
        }
 else         if (relative.toString().contains(SLASH)) {
          relative=setPath(relative,relative.getPath().substring(0,relative.getPath().lastIndexOf(SLASH)));
          attrValue=relative.resolve(attrValue).toString();
        }
      }
    }
    resAtts.setValue(i,attrValue);
  }
  if (TOPIC_TOPIC.matches(classValue) && resAtts.getValue(ATTRIBUTE_NAMESPACE_PREFIX_DITAARCHVERSION) == null) {
    addOrSetAttribute(resAtts,ATTRIBUTE_NAMESPACE_PREFIX_DITAARCHVERSION,DITA_NAMESPACE);
  }
  if (TOPIC_TOPIC.matches(classValue) && resAtts.getValue(XMLNS_ATTRIBUTE + ""String_Node_Str"" + DITA_OT_PREFIX) == null) {
    addOrSetAttribute(resAtts,XMLNS_ATTRIBUTE + ""String_Node_Str"" + DITA_OT_PREFIX,DITA_OT_NS);
  }
  return resAtts;
}",0.9980015987210232
100650,"private String updateHref(final Attributes atts){
  String hrefValue=atts.getValue(ATTRIBUTE_NAME_HREF);
  if (hrefValue == null) {
    return null;
  }
  if (fixpath != null && hrefValue.startsWith(fixpath)) {
    hrefValue=hrefValue.substring(fixpath.length());
  }
  if (changeTable == null || changeTable.isEmpty()) {
    return hrefValue;
  }
  if (isLocalDita(atts)) {
    final URI rootPathName=currentFile;
    String changeTargetkey=resolve(currentFileDir,hrefValue).getPath();
    URI changeTarget=changeTable.get(changeTargetkey);
    final String topicID=getTopicID(toURI(hrefValue));
    if (topicID != null) {
      changeTargetkey=setFragment(changeTargetkey,topicID);
      final URI changeTarget_with_elemt=changeTable.get(changeTargetkey);
      if (changeTarget_with_elemt != null) {
        changeTarget=changeTarget_with_elemt;
      }
    }
    final String elementID=getElementID(hrefValue);
    final String pathtoElem=getFragment(hrefValue,""String_Node_Str"");
    if (changeTarget == null || changeTarget.toString().isEmpty()) {
      URI absolutePath=toURI(resolveTopic(currentFileDir,hrefValue));
      absolutePath=setElementID(absolutePath,null);
      changeTarget=changeTable.get(absolutePath);
    }
    if (changeTarget == null) {
      return hrefValue;
    }
 else {
      final URI conTarget=conflictTable.get(stripFragment(changeTarget));
      if (conTarget != null && !conTarget.toString().isEmpty()) {
        final URI p=getRelativePath(rootPathName,conTarget);
        if (elementID == null) {
          return setFragment(p,getElementID(changeTarget.toString())).toString();
        }
 else {
          if (conTarget.getFragment() != null) {
            if (!pathtoElem.contains(SLASH)) {
              return p.toString();
            }
 else {
              return setElementID(p,elementID).toString();
            }
          }
 else {
            return setFragment(p,pathtoElem).toString();
          }
        }
      }
 else {
        final URI p=getRelativePath(rootPathName,changeTarget);
        if (elementID == null) {
          return p.toString();
        }
 else {
          if (changeTarget.getFragment() != null) {
            if (!pathtoElem.contains(SLASH)) {
              return p.toString();
            }
 else {
              return setElementID(p,elementID).toString();
            }
          }
 else {
            return setFragment(p,pathtoElem).toString();
          }
        }
      }
    }
  }
  return hrefValue;
}","private String updateHref(final Attributes atts){
  String hrefValue=atts.getValue(ATTRIBUTE_NAME_HREF);
  if (hrefValue == null) {
    return null;
  }
  if (fixpath != null && hrefValue.startsWith(fixpath)) {
    hrefValue=hrefValue.substring(fixpath.length());
  }
  if (changeTable == null || changeTable.isEmpty()) {
    return hrefValue;
  }
  if (isLocalDita(atts)) {
    final URI rootPathName=currentFile;
    URI changeTargetkey=currentFileDir.toURI().resolve(hrefValue);
    URI changeTarget=changeTable.get(changeTargetkey);
    final String topicID=getTopicID(toURI(hrefValue));
    if (topicID != null) {
      changeTargetkey=setFragment(changeTargetkey,topicID);
      final URI changeTarget_with_elemt=changeTable.get(changeTargetkey);
      if (changeTarget_with_elemt != null) {
        changeTarget=changeTarget_with_elemt;
      }
    }
    final String elementID=getElementID(hrefValue);
    final String pathtoElem=getFragment(hrefValue,""String_Node_Str"");
    if (changeTarget == null || changeTarget.toString().isEmpty()) {
      URI absolutePath=toURI(resolveTopic(currentFileDir,hrefValue));
      absolutePath=setElementID(absolutePath,null);
      changeTarget=changeTable.get(absolutePath);
    }
    if (changeTarget == null) {
      return hrefValue;
    }
 else {
      final URI conTarget=conflictTable.get(stripFragment(changeTarget));
      if (conTarget != null && !conTarget.toString().isEmpty()) {
        final URI p=getRelativePath(rootPathName,conTarget);
        if (elementID == null) {
          return setFragment(p,getElementID(changeTarget.toString())).toString();
        }
 else {
          if (conTarget.getFragment() != null) {
            if (!pathtoElem.contains(SLASH)) {
              return p.toString();
            }
 else {
              return setElementID(p,elementID).toString();
            }
          }
 else {
            return setFragment(p,pathtoElem).toString();
          }
        }
      }
 else {
        final URI p=getRelativePath(rootPathName,changeTarget);
        if (elementID == null) {
          return p.toString();
        }
 else {
          if (changeTarget.getFragment() != null) {
            if (!pathtoElem.contains(SLASH)) {
              return p.toString();
            }
 else {
              return setElementID(p,elementID).toString();
            }
          }
 else {
            return setFragment(p,pathtoElem).toString();
          }
        }
      }
    }
  }
  return hrefValue;
}",0.9885427135678392
100651,"/** 
 * Retrieve the element ID from the path. If there is no element ID, return topic ID.
 * @param relativePath
 * @return String
 */
private String getElementID(final String relativePath){
  String elementID=null;
  String topicWithelement=null;
  final String fragment=getFragment(relativePath);
  if (fragment != null) {
    topicWithelement=getFragment(relativePath);
    if (topicWithelement.lastIndexOf(SLASH) != -1) {
      elementID=topicWithelement.substring(topicWithelement.lastIndexOf(SLASH) + 1);
    }
 else {
      elementID=topicWithelement;
    }
  }
  return elementID;
}","/** 
 * Retrieve the element ID from the path. If there is no element ID, return topic ID.
 * @param relativePath
 * @return String
 */
private String getElementID(final String relativePath){
  final String fragment=getFragment(relativePath);
  if (fragment != null) {
    if (fragment.lastIndexOf(SLASH) != -1) {
      return fragment.substring(fragment.lastIndexOf(SLASH) + 1);
    }
 else {
      return fragment;
    }
  }
  return null;
}",0.7833655705996132
100652,"/** 
 * Update href attributes in ditamap and topic files.
 */
private void updateRefOfDita(final Map<URI,URI> changeTable,final Map<URI,URI> conflictTable){
  final TopicRefWriter topicRefWriter=new TopicRefWriter();
  topicRefWriter.setLogger(logger);
  topicRefWriter.setJob(job);
  topicRefWriter.setChangeTable(changeTable);
  topicRefWriter.setup(conflictTable);
  try {
    for (    final FileInfo f : job.getFileInfo()) {
      if (ATTR_FORMAT_VALUE_DITA.equals(f.format) || ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
        topicRefWriter.setFixpath(relativePath2fix.get(f.file.toString()));
        topicRefWriter.write(new File(job.tempDir.getAbsoluteFile(),f.file.getPath()).getAbsoluteFile());
      }
    }
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final DITAOTException ex) {
    logger.error(ex.getMessage(),ex);
  }
}","/** 
 * Update href attributes in ditamap and topic files.
 */
private void updateRefOfDita(final Map<URI,URI> changeTable,final Map<URI,URI> conflictTable){
  final TopicRefWriter topicRefWriter=new TopicRefWriter();
  topicRefWriter.setLogger(logger);
  topicRefWriter.setJob(job);
  topicRefWriter.setChangeTable(changeTable);
  topicRefWriter.setup(conflictTable);
  try {
    for (    final FileInfo f : job.getFileInfo()) {
      if (ATTR_FORMAT_VALUE_DITA.equals(f.format) || ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
        topicRefWriter.setFixpath(relativePath2fix.get(f.uri));
        topicRefWriter.write(new File(job.tempDir.getAbsoluteFile(),f.file.getPath()).getAbsoluteFile());
      }
    }
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final DITAOTException ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9895104895104896
100653,"/** 
 * Entry point of chunk module.
 * @param input Input parameters and resources.
 * @return null
 * @throws DITAOTException exception
 */
@Override public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  final String transtype=input.getAttribute(ANT_INVOKER_EXT_PARAM_TRANSTYPE);
  final ChunkMapReader mapReader=new ChunkMapReader();
  mapReader.setLogger(logger);
  mapReader.setJob(job);
  mapReader.supportToNavigation(INDEX_TYPE_ECLIPSEHELP.equals(transtype));
  if (input.getAttribute(ROOT_CHUNK_OVERRIDE) != null) {
    mapReader.setRootChunkOverride(input.getAttribute(ROOT_CHUNK_OVERRIDE));
  }
  try {
    final File mapFile=new File(job.tempDir.toURI().resolve(job.getInputMap()));
    if (transtype.equals(INDEX_TYPE_ECLIPSEHELP) && isEclipseMap(mapFile.toURI())) {
      for (      final FileInfo f : job.getFileInfo()) {
        if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
          mapReader.read(new File(job.tempDir,f.file.getPath()).getAbsoluteFile());
        }
      }
    }
 else {
      mapReader.read(mapFile);
    }
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
  final Map<URI,URI> changeTable=mapReader.getChangeTable();
  if (hasChanges(changeTable)) {
    final Map<URI,URI> conflicTable=mapReader.getConflicTable();
    updateList(changeTable,conflicTable);
    updateRefOfDita(changeTable,conflicTable);
  }
  return null;
}","/** 
 * Entry point of chunk module.
 * @param input Input parameters and resources.
 * @return null
 * @throws DITAOTException exception
 */
@Override public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  final String transtype=input.getAttribute(ANT_INVOKER_EXT_PARAM_TRANSTYPE);
  final ChunkMapReader mapReader=new ChunkMapReader();
  mapReader.setLogger(logger);
  mapReader.setJob(job);
  mapReader.supportToNavigation(INDEX_TYPE_ECLIPSEHELP.equals(transtype));
  if (input.getAttribute(ROOT_CHUNK_OVERRIDE) != null) {
    mapReader.setRootChunkOverride(input.getAttribute(ROOT_CHUNK_OVERRIDE));
  }
  try {
    final File mapFile=new File(job.tempDir.toURI().resolve(job.getInputMap()));
    if (transtype.equals(INDEX_TYPE_ECLIPSEHELP) && isEclipseMap(mapFile.toURI())) {
      for (      final FileInfo f : job.getFileInfo()) {
        if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
          mapReader.read(new File(job.tempDir,f.file.getPath()).getAbsoluteFile());
        }
      }
    }
 else {
      mapReader.read(mapFile);
    }
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
  final Map<URI,URI> changeTable=mapReader.getChangeTable();
  if (hasChanges(changeTable)) {
    final Map<URI,URI> conflicTable=mapReader.getConflicTable();
    updateList(changeTable,Collections.unmodifiableMap(conflicTable));
    updateRefOfDita(changeTable,Collections.unmodifiableMap(conflicTable));
  }
  return null;
}",0.9651315789473685
100654,"/** 
 * Update Job configuration to include new generated files
 */
private void updateList(final Map<URI,URI> changeTable,final Map<URI,URI> conflictTable){
  final URI xmlDitalist=job.tempDir.toURI().resolve(""String_Node_Str"");
  final Set<URI> hrefTopics=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.uri);
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final URI s=f.uri;
      if (s.getFragment() == null) {
        final Iterator<URI> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final URI ent=hrefit.next();
          if (job.tempDir.toURI().resolve(ent).equals(job.tempDir.toURI().resolve(s))) {
            hrefit.remove();
          }
        }
      }
 else       if (hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<URI> topicList=new LinkedHashSet<>(128);
  final Set<URI> oldTopicList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.uri);
    }
  }
  for (  final URI hrefTopic : hrefTopics) {
    final URI t=getRelativePath(xmlDitalist,job.tempDir.toURI().resolve(stripFragment(hrefTopic)));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<URI> chunkedTopicSet=new LinkedHashSet<>(128);
  final Set<URI> chunkedDitamapSet=new LinkedHashSet<>(128);
  final Set<URI> ditamapList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.uri);
    }
  }
  for (  final Map.Entry<URI,URI> entry : changeTable.entrySet()) {
    final URI oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      URI newChunkedFile=entry.getValue();
      newChunkedFile=getRelativePath(xmlDitalist,newChunkedFile);
      final String extName=getExtension(newChunkedFile.getPath());
      if (extName != null && !extName.equalsIgnoreCase(ATTR_FORMAT_VALUE_DITAMAP)) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final URI s : oldTopicList) {
    final File f=new File(job.tempDir.toURI().resolve(s));
    if (f.exists() && !f.delete()) {
      logger.error(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
  for (  final Map.Entry<URI,URI> entry : changeTable.entrySet()) {
    final URI oldFile=entry.getKey();
    final URI from=entry.getValue();
    if (from.equals(oldFile)) {
      final URI targetPath=conflictTable.get(oldFile);
      if (targetPath != null) {
        final URI target=targetPath;
        if (!new File(target).exists()) {
          URI relativePath=getRelativePath(xmlDitalist,from);
          final URI relativeTargetPath=getRelativePath(xmlDitalist,target);
          if (relativeTargetPath.getPath().contains(URI_SEPARATOR)) {
            relativePath2fix.put(relativeTargetPath.getPath(),relativeTargetPath.getPath().substring(0,relativeTargetPath.getPath().lastIndexOf(URI_SEPARATOR) + 1));
          }
          try {
            deleteQuietly(new File(target));
            moveFile(new File(from),new File(target));
          }
 catch (          final IOException e) {
            logger.error(""String_Node_Str"" + e.getMessage(),e);
          }
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativePath(xmlDitalist,target);
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(oldFile);
        }
      }
    }
  }
  final Set<URI> all=new HashSet<>();
  all.addAll(topicList);
  all.addAll(ditamapList);
  all.addAll(chunkedDitamapSet);
  all.addAll(chunkedTopicSet);
  for (  final URI file : oldTopicList) {
    if (!all.contains(file)) {
      job.remove(job.getOrCreateFileInfo(file));
    }
  }
  for (  final URI file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
  }
  for (  final URI file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}","/** 
 * Update Job configuration to include new generated files
 */
private void updateList(final Map<URI,URI> changeTable,final Map<URI,URI> conflictTable){
  final URI xmlDitalist=job.tempDir.toURI().resolve(""String_Node_Str"");
  final Set<URI> hrefTopics=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.uri);
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final URI s=f.uri;
      if (s.getFragment() == null) {
        final Iterator<URI> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final URI ent=hrefit.next();
          if (job.tempDir.toURI().resolve(ent).equals(job.tempDir.toURI().resolve(s))) {
            hrefit.remove();
          }
        }
      }
 else       if (hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<URI> topicList=new LinkedHashSet<>(128);
  final Set<URI> oldTopicList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.uri);
    }
  }
  for (  final URI hrefTopic : hrefTopics) {
    final URI t=getRelativePath(xmlDitalist,job.tempDir.toURI().resolve(stripFragment(hrefTopic)));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<URI> chunkedTopicSet=new LinkedHashSet<>(128);
  final Set<URI> chunkedDitamapSet=new LinkedHashSet<>(128);
  final Set<URI> ditamapList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.uri);
    }
  }
  for (  final Map.Entry<URI,URI> entry : changeTable.entrySet()) {
    final URI oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      URI newChunkedFile=entry.getValue();
      newChunkedFile=getRelativePath(xmlDitalist,newChunkedFile);
      final String extName=getExtension(newChunkedFile.getPath());
      if (extName != null && !extName.equalsIgnoreCase(ATTR_FORMAT_VALUE_DITAMAP)) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final URI s : oldTopicList) {
    final File f=new File(job.tempDir.toURI().resolve(s));
    logger.debug(""String_Node_Str"" + f.toURI());
    if (f.exists() && !f.delete()) {
      logger.error(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
  for (  final Map.Entry<URI,URI> entry : changeTable.entrySet()) {
    final URI oldFile=entry.getKey();
    final URI from=entry.getValue();
    if (from.equals(oldFile)) {
      final URI targetPath=conflictTable.get(oldFile);
      if (targetPath != null) {
        final URI target=targetPath;
        if (!new File(target).exists()) {
          URI relativePath=getRelativePath(xmlDitalist,from);
          final URI relativeTargetPath=getRelativePath(xmlDitalist,target);
          if (relativeTargetPath.getPath().contains(URI_SEPARATOR)) {
            relativePath2fix.put(relativeTargetPath,relativeTargetPath.getPath().substring(0,relativeTargetPath.getPath().lastIndexOf(URI_SEPARATOR) + 1));
          }
          try {
            logger.debug(""String_Node_Str"" + target);
            deleteQuietly(new File(target));
            logger.debug(""String_Node_Str"" + from + ""String_Node_Str""+ target);
            moveFile(new File(from),new File(target));
          }
 catch (          final IOException e) {
            logger.error(""String_Node_Str"" + e.getMessage(),e);
          }
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativePath(xmlDitalist,target);
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(oldFile);
        }
      }
    }
  }
  final Set<URI> all=new HashSet<>();
  all.addAll(topicList);
  all.addAll(ditamapList);
  all.addAll(chunkedDitamapSet);
  all.addAll(chunkedTopicSet);
  for (  final URI file : oldTopicList) {
    if (!all.contains(file)) {
      job.remove(job.getOrCreateFileInfo(file));
    }
  }
  for (  final URI file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
  }
  for (  final URI file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9821014559955484
100655,"/** 
 * Create the new topic stump.
 */
private void createTopicStump(final URI newFile){
  OutputStream newFileWriter=null;
  try {
    newFileWriter=new FileOutputStream(new File(newFile));
    final XMLStreamWriter o=XMLOutputFactory.newInstance().createXMLStreamWriter(newFileWriter,UTF8);
    o.writeStartDocument();
    o.writeProcessingInstruction(PI_WORKDIR_TARGET,UNIX_SEPARATOR + new File(newFile.resolve(""String_Node_Str"")).getAbsolutePath());
    o.writeProcessingInstruction(PI_WORKDIR_TARGET_URI,newFile.resolve(""String_Node_Str"").toString());
    o.writeStartElement(ELEMENT_NAME_DITA);
    o.writeEndElement();
    o.writeEndDocument();
    o.close();
    newFileWriter.flush();
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    try {
      if (newFileWriter != null) {
        newFileWriter.close();
      }
    }
 catch (    final IOException e) {
      logger.error(e.getMessage(),e);
    }
  }
}","/** 
 * Create the new topic stump.
 */
private void createTopicStump(final URI newFile){
  try (final OutputStream newFileWriter=new FileOutputStream(new File(newFile))){
    final XMLStreamWriter o=XMLOutputFactory.newInstance().createXMLStreamWriter(newFileWriter,UTF8);
    o.writeStartDocument();
    o.writeProcessingInstruction(PI_WORKDIR_TARGET,UNIX_SEPARATOR + new File(newFile.resolve(""String_Node_Str"")).getAbsolutePath());
    o.writeProcessingInstruction(PI_WORKDIR_TARGET_URI,newFile.resolve(""String_Node_Str"").toString());
    o.writeStartElement(ELEMENT_NAME_DITA);
    o.writeEndElement();
    o.writeEndDocument();
    o.close();
    newFileWriter.flush();
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
}",0.8324145534729879
100656,"/** 
 * Process map when ""to-content"" is specified on map element. TODO: Instead of reclassing map element to be a topicref, add a topicref into the map root and move all map content into that topicref.
 */
private void chunkMap(final Element root){
  String newFilename=replaceExtension(new File(inputFile).getName(),FILE_EXTENSION_DITA);
  URI newFile=inputFile.resolve(newFilename);
  if (new File(newFile).exists()) {
    newFilename=chunkFilenameGenerator.generateFilename(""String_Node_Str"",FILE_EXTENSION_DITA);
    newFile=inputFile.resolve(newFilename);
    conflictTable.put(newFile,newFile.normalize());
  }
  changeTable.put(newFile,newFile);
  final String originClassValue=root.getAttribute(ATTRIBUTE_NAME_CLASS);
  root.setAttribute(ATTRIBUTE_NAME_CLASS,originClassValue + MAP_TOPICREF.matcher);
  root.setAttribute(ATTRIBUTE_NAME_HREF,toURI(newFilename).toString());
  createTopicStump(newFile);
  processTopicref(root);
  if (originClassValue != null) {
    root.setAttribute(ATTRIBUTE_NAME_CLASS,originClassValue);
  }
  root.removeAttribute(ATTRIBUTE_NAME_HREF);
}","/** 
 * Process map when ""to-content"" is specified on map element. TODO: Instead of reclassing map element to be a topicref, add a topicref into the map root and move all map content into that topicref.
 */
private void chunkMap(final Element root){
  String newFilename=replaceExtension(new File(inputFile).getName(),FILE_EXTENSION_DITA);
  URI newFile=inputFile.resolve(newFilename);
  if (new File(newFile).exists()) {
    final URI oldFile=newFile;
    newFilename=chunkFilenameGenerator.generateFilename(""String_Node_Str"",FILE_EXTENSION_DITA);
    newFile=inputFile.resolve(newFilename);
    conflictTable.put(newFile,oldFile.normalize());
  }
  changeTable.put(newFile,newFile);
  final String originClassValue=root.getAttribute(ATTRIBUTE_NAME_CLASS);
  root.setAttribute(ATTRIBUTE_NAME_CLASS,originClassValue + MAP_TOPICREF.matcher);
  root.setAttribute(ATTRIBUTE_NAME_HREF,toURI(newFilename).toString());
  createTopicStump(newFile);
  processTopicref(root);
  if (originClassValue != null) {
    root.setAttribute(ATTRIBUTE_NAME_CLASS,originClassValue);
  }
  root.removeAttribute(ATTRIBUTE_NAME_HREF);
}",0.9831435079726653
100657,"public static Collection<String> split(final String value){
  if (value == null) {
    return Collections.EMPTY_LIST;
  }
  final String[] tokens=value.trim().split(""String_Node_Str"");
  return asList(tokens);
}","public static Collection<String> split(final String value){
  if (value == null) {
    return Collections.emptyList();
  }
  final String[] tokens=value.trim().split(""String_Node_Str"");
  return asList(tokens);
}",0.9550827423167848
100658,"private String updateHref(final Attributes atts){
  String hrefValue=atts.getValue(ATTRIBUTE_NAME_HREF);
  if (hrefValue == null) {
    return null;
  }
  if (fixpath != null && hrefValue.startsWith(fixpath)) {
    hrefValue=hrefValue.substring(fixpath.length());
  }
  if (changeTable == null || changeTable.isEmpty()) {
    return hrefValue;
  }
  if (isLocalDita(atts)) {
    final URI rootPathName=currentFile;
    URI changeTargetkey=currentFileDir.toURI().resolve(hrefValue);
    URI changeTarget=changeTable.get(changeTargetkey);
    final String topicID=getTopicID(toURI(hrefValue));
    if (topicID != null) {
      changeTargetkey=setFragment(changeTargetkey,topicID);
      final URI changeTarget_with_elemt=changeTable.get(changeTargetkey);
      if (changeTarget_with_elemt != null) {
        changeTarget=changeTarget_with_elemt;
      }
    }
    final String elementID=getElementID(hrefValue);
    final String pathtoElem=getFragment(hrefValue,""String_Node_Str"");
    if (changeTarget == null || changeTarget.toString().isEmpty()) {
      URI absolutePath=toURI(resolveTopic(currentFileDir,hrefValue));
      absolutePath=setElementID(absolutePath,null);
      changeTarget=changeTable.get(absolutePath);
    }
    if (changeTarget == null) {
      return hrefValue;
    }
 else {
      final URI conTarget=conflictTable.get(stripFragment(changeTarget));
      if (conTarget != null && !conTarget.toString().isEmpty()) {
        final URI p=getRelativePath(rootPathName,conTarget);
        if (elementID == null) {
          return setFragment(p,getElementID(changeTarget.toString())).toString();
        }
 else {
          if (conTarget.getFragment() != null) {
            if (!pathtoElem.contains(SLASH)) {
              return p.toString();
            }
 else {
              return setElementID(p,elementID).toString();
            }
          }
 else {
            return setFragment(p,pathtoElem).toString();
          }
        }
      }
 else {
        final URI p=getRelativePath(rootPathName,changeTarget);
        if (elementID == null) {
          return p.toString();
        }
 else {
          if (changeTarget.getFragment() != null) {
            if (!pathtoElem.contains(SLASH)) {
              return p.toString();
            }
 else {
              return setElementID(p,elementID).toString();
            }
          }
 else {
            return setFragment(p,pathtoElem).toString();
          }
        }
      }
    }
  }
  return hrefValue;
}","private String updateHref(final Attributes atts){
  String hrefValue=atts.getValue(ATTRIBUTE_NAME_HREF);
  if (hrefValue == null) {
    return null;
  }
  if (fixpath != null && hrefValue.startsWith(fixpath)) {
    hrefValue=hrefValue.substring(fixpath.length());
  }
  if (changeTable == null || changeTable.isEmpty()) {
    return hrefValue;
  }
  if (isLocalDita(atts)) {
    final URI rootPathName=currentFile;
    URI changeTargetkey=stripFragment(currentFileDir.toURI().resolve(hrefValue));
    URI changeTarget=changeTable.get(changeTargetkey);
    final String topicID=getTopicID(toURI(hrefValue));
    if (topicID != null) {
      changeTargetkey=setFragment(changeTargetkey,topicID);
      final URI changeTarget_with_elemt=changeTable.get(changeTargetkey);
      if (changeTarget_with_elemt != null) {
        changeTarget=changeTarget_with_elemt;
      }
    }
    final String elementID=getElementID(hrefValue);
    final String pathtoElem=getFragment(hrefValue,""String_Node_Str"");
    if (changeTarget == null || changeTarget.toString().isEmpty()) {
      URI absolutePath=toURI(resolveTopic(currentFileDir,hrefValue));
      absolutePath=setElementID(absolutePath,null);
      changeTarget=changeTable.get(absolutePath);
    }
    if (changeTarget == null) {
      return hrefValue;
    }
 else {
      final URI conTarget=conflictTable.get(stripFragment(changeTarget));
      logger.debug(""String_Node_Str"" + changeTarget + ""String_Node_Str""+ conTarget);
      if (conTarget != null && !conTarget.toString().isEmpty()) {
        final URI p=getRelativePath(rootPathName,conTarget);
        if (elementID == null) {
          return setFragment(p,getElementID(changeTarget.toString())).toString();
        }
 else {
          if (conTarget.getFragment() != null) {
            if (!pathtoElem.contains(SLASH)) {
              return p.toString();
            }
 else {
              return setElementID(p,elementID).toString();
            }
          }
 else {
            return setFragment(p,pathtoElem).toString();
          }
        }
      }
 else {
        final URI p=getRelativePath(rootPathName,changeTarget);
        if (elementID == null) {
          return p.toString();
        }
 else {
          if (changeTarget.getFragment() != null) {
            if (!pathtoElem.contains(SLASH)) {
              return p.toString();
            }
 else {
              return setElementID(p,elementID).toString();
            }
          }
 else {
            return setFragment(p,pathtoElem).toString();
          }
        }
      }
    }
  }
  return hrefValue;
}",0.980276134122288
100659,"/** 
 * Update Job configuration to include new generated files
 */
private void updateList(final Map<String,String> changeTable,final Map<String,String> conflictTable){
  final URI xmlDitalist=new File(job.tempDir,""String_Node_Str"").toURI();
  final Set<URI> hrefTopics=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.uri);
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final URI s=f.uri;
      if (s.getFragment() == null) {
        final Iterator<URI> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final URI ent=hrefit.next();
          if (resolve(job.tempDir,ent).equals(resolve(job.tempDir,s))) {
            hrefit.remove();
          }
        }
      }
 else       if (hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<URI> topicList=new LinkedHashSet<>(128);
  final Set<URI> oldTopicList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.uri);
    }
  }
  for (  final URI hrefTopic : hrefTopics) {
    final URI t=getRelativePath(xmlDitalist,job.tempDir.toURI().resolve(stripFragment(hrefTopic.toString())));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<URI> chunkedTopicSet=new LinkedHashSet<>(128);
  final Set<URI> chunkedDitamapSet=new LinkedHashSet<>(128);
  final Set<URI> ditamapList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.uri);
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      URI newChunkedFile=new File(entry.getValue()).toURI();
      newChunkedFile=getRelativePath(xmlDitalist,newChunkedFile);
      final String extName=getExtension(newChunkedFile.getPath());
      if (extName != null && !extName.equalsIgnoreCase(ATTR_FORMAT_VALUE_DITAMAP)) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final URI s : oldTopicList) {
    final File f=new File(job.tempDir.toURI().resolve(s));
    if (f.exists() && !f.delete()) {
      logger.error(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      final String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        final URI target=new File(targetPath).toURI();
        if (!new File(target).exists()) {
          final URI from=new File(entry.getValue()).toURI();
          URI relativePath=getRelativePath(xmlDitalist,from);
          final URI relativeTargetPath=getRelativePath(xmlDitalist,target);
          if (relativeTargetPath.getPath().lastIndexOf(File.separator) != -1) {
            relativePath2fix.put(relativeTargetPath.getPath(),relativeTargetPath.getPath().substring(0,relativeTargetPath.getPath().lastIndexOf(File.separator) + 1));
          }
          try {
            deleteQuietly(new File(target));
            moveFile(new File(from),new File(target));
          }
 catch (          final IOException e) {
            logger.error(""String_Node_Str"" + e.getMessage(),e);
          }
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativePath(xmlDitalist,target);
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  final Set<URI> all=new HashSet<>();
  all.addAll(topicList);
  all.addAll(ditamapList);
  all.addAll(chunkedDitamapSet);
  all.addAll(chunkedTopicSet);
  for (  final URI file : oldTopicList) {
    if (!all.contains(file)) {
      job.remove(job.getOrCreateFileInfo(file));
    }
  }
  for (  final URI file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
  }
  for (  final URI file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}","/** 
 * Update Job configuration to include new generated files
 */
private void updateList(final Map<String,String> changeTable,final Map<String,String> conflictTable){
  final URI xmlDitalist=new File(job.tempDir,""String_Node_Str"").toURI();
  final Set<URI> hrefTopics=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.uri);
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final URI s=f.uri;
      if (s.getFragment() == null) {
        final Iterator<URI> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final URI ent=hrefit.next();
          if (resolve(job.tempDir,ent).equals(resolve(job.tempDir,s))) {
            hrefit.remove();
          }
        }
      }
 else       if (hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<URI> topicList=new LinkedHashSet<>(128);
  final Set<URI> oldTopicList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.uri);
    }
  }
  for (  final URI hrefTopic : hrefTopics) {
    final URI t=getRelativePath(xmlDitalist,job.tempDir.toURI().resolve(stripFragment(hrefTopic.toString())));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<URI> chunkedTopicSet=new LinkedHashSet<>(128);
  final Set<URI> chunkedDitamapSet=new LinkedHashSet<>(128);
  final Set<URI> ditamapList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.uri);
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      URI newChunkedFile=new File(entry.getValue()).toURI();
      newChunkedFile=getRelativePath(xmlDitalist,newChunkedFile);
      final String extName=getExtension(newChunkedFile.getPath());
      if (extName != null && !extName.equalsIgnoreCase(ATTR_FORMAT_VALUE_DITAMAP)) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final URI s : oldTopicList) {
    final File f=new File(job.tempDir.toURI().resolve(s));
    if (f.exists() && !f.delete()) {
      logger.error(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      final String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        final URI target=new File(targetPath).toURI();
        if (!new File(target).exists()) {
          final URI from=new File(entry.getValue()).toURI();
          URI relativePath=getRelativePath(xmlDitalist,from);
          final URI relativeTargetPath=getRelativePath(xmlDitalist,target);
          if (relativeTargetPath.getPath().indexOf(URI_SEPARATOR) != -1) {
            relativePath2fix.put(relativeTargetPath.getPath(),relativeTargetPath.getPath().substring(0,relativeTargetPath.getPath().lastIndexOf(URI_SEPARATOR) + 1));
          }
          try {
            deleteQuietly(new File(target));
            moveFile(new File(from),new File(target));
          }
 catch (          final IOException e) {
            logger.error(""String_Node_Str"" + e.getMessage(),e);
          }
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativePath(xmlDitalist,target);
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  final Set<URI> all=new HashSet<>();
  all.addAll(topicList);
  all.addAll(ditamapList);
  all.addAll(chunkedDitamapSet);
  all.addAll(chunkedTopicSet);
  for (  final URI file : oldTopicList) {
    if (!all.contains(file)) {
      job.remove(job.getOrCreateFileInfo(file));
    }
  }
  for (  final URI file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
  }
  for (  final URI file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.994473102431835
100660,"/** 
 * Update Job configuration to include new generated files
 */
private void updateList(final Map<String,String> changeTable,final Map<String,String> conflictTable){
  final URI xmlDitalist=new File(job.tempDir,""String_Node_Str"").toURI();
  final Set<URI> hrefTopics=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.uri);
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final String s=f.file.getPath();
      if (!StringUtils.isEmptyString(s) && getFragment(s) == null) {
        final Iterator<URI> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final URI ent=hrefit.next();
          if (resolve(job.tempDir.getAbsoluteFile(),ent).equals(resolve(job.tempDir.getAbsolutePath(),s))) {
            hrefit.remove();
          }
        }
      }
 else       if (!StringUtils.isEmptyString(s) && hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<URI> topicList=new LinkedHashSet<>(128);
  final Set<URI> oldTopicList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.uri);
    }
  }
  for (  final URI hrefTopic : hrefTopics) {
    final URI t=getRelativePath(xmlDitalist,job.tempDir.toURI().resolve(stripFragment(hrefTopic.toString())));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<URI> chunkedTopicSet=new LinkedHashSet<>(128);
  final Set<URI> chunkedDitamapSet=new LinkedHashSet<>(128);
  final Set<URI> ditamapList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.uri);
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      URI newChunkedFile=new File(entry.getValue()).toURI();
      newChunkedFile=getRelativePath(xmlDitalist,newChunkedFile);
      final String extName=getExtension(newChunkedFile.getPath());
      if (extName != null && !extName.equalsIgnoreCase(ATTR_FORMAT_VALUE_DITAMAP)) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final URI s : oldTopicList) {
    final File f=new File(job.tempDir.toURI().resolve(s));
    if (f.exists() && !f.delete()) {
      logger.error(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      final String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        final URI target=new File(targetPath).toURI();
        if (!new File(target).exists()) {
          final URI from=new File(entry.getValue()).toURI();
          URI relativePath=getRelativePath(xmlDitalist,from);
          final URI relativeTargetPath=getRelativePath(xmlDitalist,target);
          if (relativeTargetPath.getPath().lastIndexOf(File.separator) != -1) {
            relativePath2fix.put(relativeTargetPath.getPath(),relativeTargetPath.getPath().substring(0,relativeTargetPath.getPath().lastIndexOf(File.separator) + 1));
          }
          try {
            deleteQuietly(new File(target));
            moveFile(new File(from),new File(target));
          }
 catch (          final IOException e) {
            logger.error(""String_Node_Str"" + e.getMessage(),e);
          }
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativePath(xmlDitalist,target);
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  final Set<URI> all=new HashSet<>();
  all.addAll(topicList);
  all.addAll(ditamapList);
  all.addAll(chunkedDitamapSet);
  all.addAll(chunkedTopicSet);
  for (  final URI file : oldTopicList) {
    if (!all.contains(file)) {
      job.remove(job.getOrCreateFileInfo(file));
    }
  }
  for (  final URI file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
  }
  for (  final URI file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}","/** 
 * Update Job configuration to include new generated files
 */
private void updateList(final Map<String,String> changeTable,final Map<String,String> conflictTable){
  final URI xmlDitalist=new File(job.tempDir,""String_Node_Str"").toURI();
  final Set<URI> hrefTopics=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.uri);
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final URI s=f.uri;
      if (s.getFragment() == null) {
        final Iterator<URI> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final URI ent=hrefit.next();
          if (resolve(job.tempDir,ent).equals(resolve(job.tempDir,s))) {
            hrefit.remove();
          }
        }
      }
 else       if (hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<URI> topicList=new LinkedHashSet<>(128);
  final Set<URI> oldTopicList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.uri);
    }
  }
  for (  final URI hrefTopic : hrefTopics) {
    final URI t=getRelativePath(xmlDitalist,job.tempDir.toURI().resolve(stripFragment(hrefTopic.toString())));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<URI> chunkedTopicSet=new LinkedHashSet<>(128);
  final Set<URI> chunkedDitamapSet=new LinkedHashSet<>(128);
  final Set<URI> ditamapList=new HashSet<>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.uri);
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      URI newChunkedFile=new File(entry.getValue()).toURI();
      newChunkedFile=getRelativePath(xmlDitalist,newChunkedFile);
      final String extName=getExtension(newChunkedFile.getPath());
      if (extName != null && !extName.equalsIgnoreCase(ATTR_FORMAT_VALUE_DITAMAP)) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final URI s : oldTopicList) {
    final File f=new File(job.tempDir.toURI().resolve(s));
    if (f.exists() && !f.delete()) {
      logger.error(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      final String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        final URI target=new File(targetPath).toURI();
        if (!new File(target).exists()) {
          final URI from=new File(entry.getValue()).toURI();
          URI relativePath=getRelativePath(xmlDitalist,from);
          final URI relativeTargetPath=getRelativePath(xmlDitalist,target);
          if (relativeTargetPath.getPath().lastIndexOf(File.separator) != -1) {
            relativePath2fix.put(relativeTargetPath.getPath(),relativeTargetPath.getPath().substring(0,relativeTargetPath.getPath().lastIndexOf(File.separator) + 1));
          }
          try {
            deleteQuietly(new File(target));
            moveFile(new File(from),new File(target));
          }
 catch (          final IOException e) {
            logger.error(""String_Node_Str"" + e.getMessage(),e);
          }
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativePath(xmlDitalist,target);
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  final Set<URI> all=new HashSet<>();
  all.addAll(topicList);
  all.addAll(ditamapList);
  all.addAll(chunkedDitamapSet);
  all.addAll(chunkedTopicSet);
  for (  final URI file : oldTopicList) {
    if (!all.contains(file)) {
      job.remove(job.getOrCreateFileInfo(file));
    }
  }
  for (  final URI file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
  }
  for (  final URI file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.error(ex.getMessage(),ex);
  }
}",0.9838753757857338
100661,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  handleRootElement(atts);
  String processingRole=atts.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (processingRole == null) {
    processingRole=processRoleStack.peek();
  }
  processRoleStack.push(processingRole);
  final URI href=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
  final String scope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  if (href != null && !ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)) {
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {
      resourceOnlySet.add(currentDir.resolve(href));
    }
 else {
      normalProcessingRoleSet.add(currentDir.resolve(href));
    }
  }
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  if (SUBJECTSCHEME_SUBJECTSCHEME.matches(classValue)) {
    final URI key=ROOT_URI;
    final Set<URI> children=schemeRelationGraph.containsKey(key) ? schemeRelationGraph.get(key) : new LinkedHashSet<URI>();
    children.add(currentFile);
    schemeRelationGraph.put(key,children);
    schemeRefSet.add(currentFile);
  }
 else   if (SUBJECTSCHEME_SCHEMEREF.matches(classValue)) {
    if (href != null) {
      final URI key=currentFile;
      final Set<URI> children=schemeRelationGraph.containsKey(key) ? schemeRelationGraph.get(key) : new LinkedHashSet<URI>();
      final URI child=currentFile.resolve(href);
      children.add(child);
      schemeRelationGraph.put(key,children);
    }
  }
  if (foreignLevel > 0) {
    foreignLevel++;
    return;
  }
 else   if (TOPIC_FOREIGN.matches(classValue) || TOPIC_UNKNOWN.matches(classValue)) {
    foreignLevel++;
  }
  if (chunkLevel > 0) {
    chunkLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null) {
    chunkLevel++;
  }
  if (relTableLevel > 0) {
    relTableLevel++;
  }
 else   if (MAP_RELTABLE.matches(classValue)) {
    relTableLevel++;
  }
  if (chunkToNavLevel > 0) {
    chunkToNavLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(CHUNK_TO_NAVIGATION)) {
    chunkToNavLevel++;
  }
  if (topicGroupLevel > 0) {
    topicGroupLevel++;
  }
 else   if (MAPGROUP_D_TOPICGROUP.matches(classValue)) {
    topicGroupLevel++;
  }
  if (classValue == null && !ELEMENT_NAME_DITA.equals(localName)) {
    logger.info(MessageUtils.getInstance().getMessage(""String_Node_Str"",localName).toString());
  }
  if (TOPIC_TOPIC.matches(classValue)) {
    final String domains=atts.getValue(ATTRIBUTE_NAME_DOMAINS);
    if (domains == null) {
      logger.info(MessageUtils.getInstance().getMessage(""String_Node_Str"",localName).toString());
    }
  }
  if ((MAP_MAP.matches(classValue)) || (TOPIC_TITLE.matches(classValue))) {
    isValidInput=true;
  }
  parseConrefAttr(atts);
  parseAttribute(atts,ATTRIBUTE_NAME_HREF);
  parseAttribute(atts,ATTRIBUTE_NAME_COPY_TO);
  parseAttribute(atts,ATTRIBUTE_NAME_DATA);
  parseConactionAttr(atts);
  parseConkeyrefAttr(atts);
  parseKeyrefAttr(atts);
  getContentHandler().startElement(uri,localName,qName,atts);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  handleRootElement(atts);
  String processingRole=atts.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (processingRole == null) {
    processingRole=processRoleStack.peek();
  }
  processRoleStack.push(processingRole);
  final URI href=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
  final String scope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  if (href != null && !ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)) {
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {
      resourceOnlySet.add(stripFragment(currentDir.resolve(href)));
    }
 else {
      normalProcessingRoleSet.add(stripFragment(currentDir.resolve(href)));
    }
  }
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  if (SUBJECTSCHEME_SUBJECTSCHEME.matches(classValue)) {
    final URI key=ROOT_URI;
    final Set<URI> children=schemeRelationGraph.containsKey(key) ? schemeRelationGraph.get(key) : new LinkedHashSet<URI>();
    children.add(currentFile);
    schemeRelationGraph.put(key,children);
    schemeRefSet.add(currentFile);
  }
 else   if (SUBJECTSCHEME_SCHEMEREF.matches(classValue)) {
    if (href != null) {
      final URI key=currentFile;
      final Set<URI> children=schemeRelationGraph.containsKey(key) ? schemeRelationGraph.get(key) : new LinkedHashSet<URI>();
      final URI child=currentFile.resolve(href);
      children.add(child);
      schemeRelationGraph.put(key,children);
    }
  }
  if (foreignLevel > 0) {
    foreignLevel++;
    return;
  }
 else   if (TOPIC_FOREIGN.matches(classValue) || TOPIC_UNKNOWN.matches(classValue)) {
    foreignLevel++;
  }
  if (chunkLevel > 0) {
    chunkLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null) {
    chunkLevel++;
  }
  if (relTableLevel > 0) {
    relTableLevel++;
  }
 else   if (MAP_RELTABLE.matches(classValue)) {
    relTableLevel++;
  }
  if (chunkToNavLevel > 0) {
    chunkToNavLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(CHUNK_TO_NAVIGATION)) {
    chunkToNavLevel++;
  }
  if (topicGroupLevel > 0) {
    topicGroupLevel++;
  }
 else   if (MAPGROUP_D_TOPICGROUP.matches(classValue)) {
    topicGroupLevel++;
  }
  if (classValue == null && !ELEMENT_NAME_DITA.equals(localName)) {
    logger.info(MessageUtils.getInstance().getMessage(""String_Node_Str"",localName).toString());
  }
  if (TOPIC_TOPIC.matches(classValue)) {
    final String domains=atts.getValue(ATTRIBUTE_NAME_DOMAINS);
    if (domains == null) {
      logger.info(MessageUtils.getInstance().getMessage(""String_Node_Str"",localName).toString());
    }
  }
  if ((MAP_MAP.matches(classValue)) || (TOPIC_TITLE.matches(classValue))) {
    isValidInput=true;
  }
  parseConrefAttr(atts);
  parseAttribute(atts,ATTRIBUTE_NAME_HREF);
  parseAttribute(atts,ATTRIBUTE_NAME_COPY_TO);
  parseAttribute(atts,ATTRIBUTE_NAME_DATA);
  parseConactionAttr(atts);
  parseConkeyrefAttr(atts);
  parseKeyrefAttr(atts);
  getContentHandler().startElement(uri,localName,qName,atts);
}",0.9951892238614496
100662,"private void processFile(final FileInfo f){
  currentFile=new File(f.src);
  if (!currentFile.exists()) {
    logger.debug(""String_Node_Str"" + f.file);
    return;
  }
  outputFile=new File(job.tempDir,f.file.getPath());
  final File outputDir=outputFile.getParentFile();
  if (!outputDir.exists() && !outputDir.mkdirs()) {
    logger.error(""String_Node_Str"" + outputDir.getAbsolutePath());
    return;
  }
  logger.info(""String_Node_Str"" + f.src);
  final Set<URI> schemaSet=dic.get(f.uri);
  if (schemaSet != null && !schemaSet.isEmpty()) {
    logger.debug(""String_Node_Str"");
    subjectSchemeReader.reset();
    for (    final URI schema : schemaSet) {
      subjectSchemeReader.loadSubjectScheme(new File(job.tempDir.toURI().resolve(schema.getPath() + SUBJECT_SCHEME_EXTENSION)));
    }
    validateMap=subjectSchemeReader.getValidValuesMap();
    defaultValueMap=subjectSchemeReader.getDefaultValueMap();
  }
 else {
    validateMap=Collections.EMPTY_MAP;
    defaultValueMap=Collections.EMPTY_MAP;
  }
  if (profilingEnabled) {
    filterUtils=baseFilterUtils.refine(subjectSchemeReader.getSubjectSchemeMap());
  }
  OutputStream out=null;
  try {
    out=new FileOutputStream(outputFile);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(currentFile.getAbsolutePath(),logger));
    final TransformerFactory tf=TransformerFactory.newInstance();
    final Transformer serializer=tf.newTransformer();
    XMLReader xmlSource=getXmlReader(f.format);
    for (    final XMLFilter filter : getProcessingPipe(currentFile.toURI())) {
      filter.setParent(xmlSource);
      xmlSource=filter;
    }
    xmlSource.setContentHandler(null);
    final Source source=new SAXSource(xmlSource,new InputSource(f.src.toString()));
    final Result result=new StreamResult(out);
    serializer.transform(source,result);
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final Exception e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
  if (isFormatDita(f.format)) {
    f.format=ATTR_FORMAT_VALUE_DITA;
  }
}","private void processFile(final FileInfo f){
  currentFile=f.src;
  if (!exists(currentFile)) {
    logger.debug(""String_Node_Str"" + f.file);
    return;
  }
  outputFile=new File(job.tempDir,f.file.getPath());
  final File outputDir=outputFile.getParentFile();
  if (!outputDir.exists() && !outputDir.mkdirs()) {
    logger.error(""String_Node_Str"" + outputDir.getAbsolutePath());
    return;
  }
  logger.info(""String_Node_Str"" + f.src);
  final Set<URI> schemaSet=dic.get(f.uri);
  if (schemaSet != null && !schemaSet.isEmpty()) {
    logger.debug(""String_Node_Str"");
    subjectSchemeReader.reset();
    for (    final URI schema : schemaSet) {
      subjectSchemeReader.loadSubjectScheme(new File(job.tempDir.toURI().resolve(schema.getPath() + SUBJECT_SCHEME_EXTENSION)));
    }
    validateMap=subjectSchemeReader.getValidValuesMap();
    defaultValueMap=subjectSchemeReader.getDefaultValueMap();
  }
 else {
    validateMap=Collections.EMPTY_MAP;
    defaultValueMap=Collections.EMPTY_MAP;
  }
  if (profilingEnabled) {
    filterUtils=baseFilterUtils.refine(subjectSchemeReader.getSubjectSchemeMap());
  }
  OutputStream out=null;
  try {
    out=new FileOutputStream(outputFile);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(currentFile.toString(),logger));
    final TransformerFactory tf=TransformerFactory.newInstance();
    final Transformer serializer=tf.newTransformer();
    XMLReader xmlSource=getXmlReader(f.format);
    for (    final XMLFilter filter : getProcessingPipe(currentFile)) {
      filter.setParent(xmlSource);
      xmlSource=filter;
    }
    xmlSource.setContentHandler(null);
    final Source source=new SAXSource(xmlSource,new InputSource(f.src.toString()));
    final Result result=new StreamResult(out);
    serializer.transform(source,result);
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final Exception e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
  if (isFormatDita(f.format)) {
    f.format=ATTR_FORMAT_VALUE_DITA;
  }
}",0.9774505292222734
100663,"/** 
 * Execute copy-to task, generate copy-to targets base on sources
 */
private void performCopytoTask(){
  final Map<File,File> copytoMap=new HashMap<File,File>();
  for (  final Map.Entry<URI,URI> e : job.getCopytoMap().entrySet()) {
    copytoMap.put(toFile(e.getKey()),toFile(e.getValue()));
  }
  if (forceUniqueFilter != null) {
    copytoMap.putAll(forceUniqueFilter.copyToMap);
  }
  for (  final Map.Entry<File,File> entry : copytoMap.entrySet()) {
    final File copytoTarget=entry.getKey();
    final File copytoSource=entry.getValue();
    final File srcFile=new File(job.tempDir,copytoSource.getPath());
    final File targetFile=new File(job.tempDir,copytoTarget.getPath());
    if (targetFile.exists()) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",copytoTarget.getPath()).toString());
    }
 else {
      final File inputMapInTemp=new File(job.tempDir,job.getInputMap().getPath()).getAbsoluteFile();
      copyFileWithPIReplaced(srcFile,targetFile,copytoTarget,inputMapInTemp);
      final FileInfo src=job.getFileInfo(toURI(copytoSource));
      final FileInfo.Builder b=src != null ? new FileInfo.Builder(src) : new FileInfo.Builder();
      final FileInfo dst=b.uri(toURI(copytoTarget)).isCopyToSource(false).build();
      job.add(dst);
    }
  }
}","/** 
 * Execute copy-to task, generate copy-to targets base on sources
 */
private void performCopytoTask(){
  final Map<File,File> copytoMap=new HashMap<File,File>();
  for (  final Map.Entry<URI,URI> e : job.getCopytoMap().entrySet()) {
    copytoMap.put(toFile(e.getKey()),toFile(e.getValue()));
  }
  if (forceUniqueFilter != null) {
    for (    final Map.Entry<URI,URI> e : forceUniqueFilter.copyToMap.entrySet()) {
      copytoMap.put(toFile(e.getKey()),toFile(e.getValue()));
    }
  }
  for (  final Map.Entry<File,File> entry : copytoMap.entrySet()) {
    final File copytoTarget=entry.getKey();
    final File copytoSource=entry.getValue();
    final File srcFile=new File(job.tempDir,copytoSource.getPath());
    final File targetFile=new File(job.tempDir,copytoTarget.getPath());
    if (targetFile.exists()) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",copytoTarget.getPath()).toString());
    }
 else {
      final File inputMapInTemp=new File(job.tempDir,job.getInputMap().getPath()).getAbsoluteFile();
      copyFileWithPIReplaced(srcFile,targetFile,copytoTarget,inputMapInTemp);
      final FileInfo src=job.getFileInfo(toURI(copytoSource));
      final FileInfo.Builder b=src != null ? new FileInfo.Builder(src) : new FileInfo.Builder();
      final FileInfo dst=b.uri(toURI(copytoTarget)).isCopyToSource(false).build();
      job.add(dst);
    }
  }
}",0.9463559008509064
100664,"/** 
 * Relativize absolute references if possible.
 * @param attName attribute name
 * @param atts attributes
 * @return attribute value, may be {@code null}
 */
private URI replaceHREF(final String attName,final Attributes atts){
  URI attValue=toURI(atts.getValue(attName));
  if (attValue != null) {
    final String fragment=attValue.getFragment();
    if (fragment != null) {
      attValue=stripFragment(attValue);
    }
    if (attValue.toString().length() != 0) {
      final URI current=currentFile.toURI().resolve(attValue);
      final FileInfo f=fileInfoMap.get(current);
      if (f != null) {
        final FileInfo cfi=fileInfoMap.get(currentFile.toURI());
        final URI currrentFileTemp=job.tempDir.toURI().resolve(cfi.uri);
        final URI targetTemp=job.tempDir.toURI().resolve(f.uri);
        attValue=getRelativePath(currrentFileTemp,targetTemp);
      }
 else {
        attValue=getRelativePath(currentFile.toURI(),current);
      }
    }
    if (fragment != null) {
      attValue=setFragment(attValue,fragment);
    }
  }
 else {
    return null;
  }
  return attValue;
}","/** 
 * Relativize absolute references if possible.
 * @param attName attribute name
 * @param atts attributes
 * @return attribute value, may be {@code null}
 */
private URI replaceHREF(final String attName,final Attributes atts){
  URI attValue=toURI(atts.getValue(attName));
  if (attValue != null) {
    final String fragment=attValue.getFragment();
    if (fragment != null) {
      attValue=stripFragment(attValue);
    }
    if (attValue.toString().length() != 0) {
      final URI current=currentFile.resolve(attValue);
      final FileInfo f=fileInfoMap.get(current);
      if (f != null) {
        final FileInfo cfi=fileInfoMap.get(currentFile);
        final URI currrentFileTemp=job.tempDir.toURI().resolve(cfi.uri);
        final URI targetTemp=job.tempDir.toURI().resolve(f.uri);
        attValue=getRelativePath(currrentFileTemp,targetTemp);
      }
 else {
        attValue=getRelativePath(currentFile,current);
      }
    }
    if (fragment != null) {
      attValue=setFragment(attValue,fragment);
    }
  }
 else {
    return null;
  }
  return attValue;
}",0.5252525252525253
100665,"public void setCurrentFile(final File currentFile){
  this.currentFile=currentFile;
}","public void setCurrentFile(final URI currentFile){
  this.currentFile=currentFile;
}",0.9585798816568049
100666,"@Override public void startDocument() throws SAXException {
  final File path2Project=DebugAndFilterModule.getPathtoProject(getRelativePath(new File(job.getInputDir(),""String_Node_Str""),currentFile),currentFile,job.getInputFile(),job);
  getContentHandler().startDocument();
  if (!OS_NAME.toLowerCase().contains(OS_NAME_WINDOWS)) {
    getContentHandler().processingInstruction(PI_WORKDIR_TARGET,outputFile.getParentFile().getAbsolutePath());
  }
 else {
    getContentHandler().processingInstruction(PI_WORKDIR_TARGET,UNIX_SEPARATOR + outputFile.getParentFile().getAbsolutePath());
  }
  getContentHandler().ignorableWhitespace(new char[]{'\n'},0,1);
  getContentHandler().processingInstruction(PI_WORKDIR_TARGET_URI,outputFile.getParentFile().toURI().toASCIIString());
  getContentHandler().ignorableWhitespace(new char[]{'\n'},0,1);
  if (path2Project != null) {
    getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET,path2Project.getPath() + File.separator);
    getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI,toURI(path2Project).toString() + URI_SEPARATOR);
  }
 else {
    getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET,""String_Node_Str"");
    getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI,""String_Node_Str"" + URI_SEPARATOR);
  }
  getContentHandler().ignorableWhitespace(new char[]{'\n'},0,1);
}","@Override public void startDocument() throws SAXException {
  final File path2Project=DebugAndFilterModule.getPathtoProject(getRelativePath(new File(job.getInputDir(),""String_Node_Str""),toFile(currentFile)),toFile(currentFile),job.getInputFile(),job);
  getContentHandler().startDocument();
  if (!OS_NAME.toLowerCase().contains(OS_NAME_WINDOWS)) {
    getContentHandler().processingInstruction(PI_WORKDIR_TARGET,outputFile.getParentFile().getAbsolutePath());
  }
 else {
    getContentHandler().processingInstruction(PI_WORKDIR_TARGET,UNIX_SEPARATOR + outputFile.getParentFile().getAbsolutePath());
  }
  getContentHandler().ignorableWhitespace(new char[]{'\n'},0,1);
  getContentHandler().processingInstruction(PI_WORKDIR_TARGET_URI,outputFile.getParentFile().toURI().toASCIIString());
  getContentHandler().ignorableWhitespace(new char[]{'\n'},0,1);
  if (path2Project != null) {
    getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET,path2Project.getPath() + File.separator);
    getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI,toURI(path2Project).toString() + URI_SEPARATOR);
  }
 else {
    getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET,""String_Node_Str"");
    getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI,""String_Node_Str"" + URI_SEPARATOR);
  }
  getContentHandler().ignorableWhitespace(new char[]{'\n'},0,1);
}",0.9767441860465116
100667,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  Attributes res=atts;
  if (MAP_TOPICREF.matches(res)) {
    final URI href=toURI(res.getValue(ATTRIBUTE_NAME_HREF));
    final String scope=res.getValue(ATTRIBUTE_NAME_SCOPE);
    final String format=res.getValue(ATTRIBUTE_NAME_FORMAT);
    final String processingRole=res.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
    if (href != null && (scope == null || scope.equals(ATTR_SCOPE_VALUE_LOCAL)) && (format == null || format.equals(ATTR_FORMAT_VALUE_DITA)) && (processingRole == null || processingRole.equals(ATTR_PROCESSING_ROLE_VALUE_NORMAL))) {
      final URI file=stripFragment(href);
      Integer count=topicrefCount.containsKey(file) ? topicrefCount.get(file) : 0;
      count++;
      topicrefCount.put(file,count);
      if (count > 1) {
        final String copyTo=res.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (copyTo == null) {
          final URI generatedCopyTo=generateCopyToTarget(href,count);
          final File source=resolve(currentFile.getParentFile(),toFile(file));
          final File target=resolve(currentFile.getParentFile(),toFile(stripFragment(generatedCopyTo)));
          final File relSource=getRelativePath(new File(job.getInputDir(),""String_Node_Str""),source);
          final File relTarget=getRelativePath(new File(job.getInputDir(),""String_Node_Str""),target);
          copyToMap.put(relTarget,relSource);
          final AttributesImpl buf=new AttributesImpl(atts);
          XMLUtils.addOrSetAttribute(buf,ATTRIBUTE_NAME_COPY_TO,generatedCopyTo.toString());
          res=buf;
        }
      }
    }
  }
  getContentHandler().startElement(uri,localName,qName,res);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  Attributes res=atts;
  if (MAP_TOPICREF.matches(res)) {
    final URI href=toURI(res.getValue(ATTRIBUTE_NAME_HREF));
    final String scope=res.getValue(ATTRIBUTE_NAME_SCOPE);
    final String format=res.getValue(ATTRIBUTE_NAME_FORMAT);
    final String processingRole=res.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
    if (href != null && (scope == null || scope.equals(ATTR_SCOPE_VALUE_LOCAL)) && (format == null || format.equals(ATTR_FORMAT_VALUE_DITA)) && (processingRole == null || processingRole.equals(ATTR_PROCESSING_ROLE_VALUE_NORMAL))) {
      final URI file=stripFragment(href);
      Integer count=topicrefCount.containsKey(file) ? topicrefCount.get(file) : 0;
      count++;
      topicrefCount.put(file,count);
      if (count > 1) {
        final String copyTo=res.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (copyTo == null) {
          final URI generatedCopyTo=generateCopyToTarget(href,count);
          final URI source=currentFile.resolve(file);
          final URI target=currentFile.resolve(stripFragment(generatedCopyTo));
          final URI relSource=getRelativePath(job.getInputDir().toURI(),source);
          final URI relTarget=getRelativePath(job.getInputDir().toURI(),target);
          copyToMap.put(relTarget,relSource);
          final AttributesImpl buf=new AttributesImpl(atts);
          XMLUtils.addOrSetAttribute(buf,ATTRIBUTE_NAME_COPY_TO,generatedCopyTo.toString());
          res=buf;
        }
      }
    }
  }
  getContentHandler().startElement(uri,localName,qName,res);
}",0.9043988269794722
100668,"public void setCurrentFile(final File currentFile){
  this.currentFile=currentFile;
}","public void setCurrentFile(final URI currentFile){
  this.currentFile=currentFile;
}",0.9585798816568049
100669,"private URI generateCopyToTarget(final URI src,final int count){
  final URI path=stripFragment(src);
  final String fragment=src.getFragment();
  for (int i=0; ; i++) {
    final StringBuilder ext=new StringBuilder();
    ext.append('_');
    ext.append(Integer.toString(count));
    if (i > 0) {
      ext.append('_');
      ext.append(Integer.toString(i));
    }
    ext.append('.');
    ext.append(getExtension(path.toString()));
    final URI dst=toURI(replaceExtension(path.toString(),ext.toString()));
    final URI target=URLUtils.getRelativePath(new File(job.getInputDir(),""String_Node_Str"").toURI(),currentFile.toURI().resolve(dst));
    if (job.getFileInfo(target) == null) {
      return setFragment(dst,fragment);
    }
  }
}","private URI generateCopyToTarget(final URI src,final int count){
  final URI path=stripFragment(src);
  final String fragment=src.getFragment();
  for (int i=0; ; i++) {
    final StringBuilder ext=new StringBuilder();
    ext.append('_');
    ext.append(Integer.toString(count));
    if (i > 0) {
      ext.append('_');
      ext.append(Integer.toString(i));
    }
    ext.append('.');
    ext.append(getExtension(path.toString()));
    final URI dst=toURI(replaceExtension(path.toString(),ext.toString()));
    final URI target=URLUtils.getRelativePath(new File(job.getInputDir(),""String_Node_Str"").toURI(),currentFile.resolve(dst));
    if (job.getFileInfo(target) == null) {
      return setFragment(dst,fragment);
    }
  }
}",0.994550408719346
100670,"public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final String xtrf=atts.getValue(""String_Node_Str"");
  assertNotNull(xtrf);
  assertEquals(source.getAbsolutePath(),xtrf);
  final String xtrc=atts.getValue(""String_Node_Str"");
  assertNotNull(xtrc);
  Integer c=counter.get(localName);
  c=c == null ? 1 : c + 1;
  counter.put(localName,c);
  assertTrue(xtrc.startsWith(localName + ""String_Node_Str"" + c+ ""String_Node_Str""));
}","public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final String xtrf=atts.getValue(""String_Node_Str"");
  assertNotNull(xtrf);
  assertEquals(source.getAbsoluteFile().toURI().toString(),xtrf);
  final String xtrc=atts.getValue(""String_Node_Str"");
  assertNotNull(xtrc);
  Integer c=counter.get(localName);
  c=c == null ? 1 : c + 1;
  counter.put(localName,c);
  assertTrue(xtrc.startsWith(localName + ""String_Node_Str"" + c+ ""String_Node_Str""));
}",0.9738625363020328
100671,"/** 
 * Validate table   {@code cols} attribute.
 * @param atts attributes
 */
private void validateCols(final Attributes atts) throws SAXException {
  if (TOPIC_TGROUP.matches(atts)) {
    colsLocator=new LocatorImpl(locator);
    final String c=atts.getValue(ATTRIBUTE_NAME_COLS);
    try {
      cols=Integer.parseInt(c.trim());
    }
 catch (    final NumberFormatException e) {
      if (processingMode == Mode.STRICT) {
        throw new SAXException(messageUtils.getMessage(""String_Node_Str"",ATTRIBUTE_NAME_COLS,c).setLocation(locator).toString());
      }
 else {
        logger.error(messageUtils.getMessage(""String_Node_Str"",ATTRIBUTE_NAME_COLS,c).setLocation(locator).toString());
      }
      cols=-1;
    }
  }
 else   if (TOPIC_COLSPEC.matches(atts)) {
    columnNumber++;
  }
 else   if (TOPIC_THEAD.matches(atts) || TOPIC_TBODY.matches(atts)) {
    if (cols != -1 && columnNumber > cols) {
      if (processingMode == Mode.STRICT) {
        throw new SAXException(messageUtils.getMessage(""String_Node_Str"",Integer.toString(cols),Integer.toString(columnNumber)).setLocation(colsLocator).toString());
      }
 else {
        logger.error(messageUtils.getMessage(""String_Node_Str"",Integer.toString(cols),Integer.toString(columnNumber)).setLocation(colsLocator).toString());
      }
    }
    columnNumber=0;
  }
}","/** 
 * Validate table   {@code cols} attribute.
 * @param atts attributes
 */
private void validateCols(final Attributes atts) throws SAXException {
  if (TOPIC_TGROUP.matches(atts)) {
    colsLocator=locator != null ? new LocatorImpl(locator) : null;
    final String c=atts.getValue(ATTRIBUTE_NAME_COLS);
    try {
      cols=Integer.parseInt(c.trim());
    }
 catch (    final NumberFormatException e) {
      if (processingMode == Mode.STRICT) {
        throw new SAXException(messageUtils.getMessage(""String_Node_Str"",ATTRIBUTE_NAME_COLS,c).setLocation(locator).toString());
      }
 else {
        logger.error(messageUtils.getMessage(""String_Node_Str"",ATTRIBUTE_NAME_COLS,c).setLocation(locator).toString());
      }
      cols=-1;
    }
  }
 else   if (TOPIC_COLSPEC.matches(atts)) {
    columnNumber++;
  }
 else   if (TOPIC_THEAD.matches(atts) || TOPIC_TBODY.matches(atts)) {
    if (cols != -1 && columnNumber > cols) {
      if (processingMode == Mode.STRICT) {
        throw new SAXException(messageUtils.getMessage(""String_Node_Str"",Integer.toString(cols),Integer.toString(columnNumber)).setLocation(colsLocator).toString());
      }
 else {
        logger.error(messageUtils.getMessage(""String_Node_Str"",Integer.toString(cols),Integer.toString(columnNumber)).setLocation(colsLocator).toString());
      }
    }
    columnNumber=0;
  }
}",0.9906681597611048
100672,"/** 
 * Just for the overflowing files.
 * @param overflowingFile overflowingFile
 * @return relative path to out
 */
public static String getRelativePathFromOut(final File overflowingFile,final Job job){
  final File relativePath=getRelativePath(job.getInputFile(),overflowingFile);
  final File outputDir=job.getOutputDir().getAbsoluteFile();
  final File outputPathName=new File(outputDir,""String_Node_Str"");
  final File finalOutFilePathName=resolve(outputDir,relativePath.getPath());
  final File finalRelativePathName=getRelativePath(finalOutFilePathName,outputPathName);
  File parentDir=finalRelativePathName.getParentFile();
  if (parentDir == null || parentDir.getPath().isEmpty()) {
    parentDir=new File(""String_Node_Str"");
  }
  return parentDir.getPath() + File.separator;
}","/** 
 * Just for the overflowing files.
 * @param overflowingFile overflowingFile
 * @return relative system path to out which ends in {@link java.io.File#separator File.separator}
 */
public static String getRelativePathFromOut(final File overflowingFile,final Job job){
  final File relativePath=getRelativePath(job.getInputFile(),overflowingFile);
  final File outputDir=job.getOutputDir().getAbsoluteFile();
  final File outputPathName=new File(outputDir,""String_Node_Str"");
  final File finalOutFilePathName=resolve(outputDir,relativePath.getPath());
  final File finalRelativePathName=getRelativePath(finalOutFilePathName,outputPathName);
  File parentDir=finalRelativePathName.getParentFile();
  if (parentDir == null || parentDir.getPath().isEmpty()) {
    parentDir=new File(""String_Node_Str"");
  }
  return parentDir.getPath() + File.separator;
}",0.9458966565349544
100673,"/** 
 * Get map of valid attribute values based on subject scheme. The contents of the map is in pseudo-code  {@code Map<AttName, Map<ElemName, <Set<Value>>>}. For default element mapping, the value is   {@code *}.
 * @return valid attribute values
 */
public Map<String,Map<String,Set<String>>> getValidValuesMap(){
  return validValuesMap;
}","/** 
 * Get map of valid attribute values based on subject scheme. The contents of the map is in pseudo-code  {@code Map<AttName, Map<ElemName, <Set<Value>>>}. For default element mapping, the value is   {@code *}.
 * @return valid attribute values or empty map
 */
public Map<String,Map<String,Set<String>>> getValidValuesMap(){
  return validValuesMap;
}",0.9814020028612304
100674,"/** 
 * Get map of default values based on subject scheme. The contents of the map is in pseudo-code  {@code Map<AttName, Map<ElemName, Default>>}. For default element mapping, the value is   {@code *}.
 * @return default values
 */
public Map<String,Map<String,String>> getDefaultValueMap(){
  return defaultValueMap;
}","/** 
 * Get map of default values based on subject scheme. The contents of the map is in pseudo-code  {@code Map<AttName, Map<ElemName, Default>>}. For default element mapping, the value is   {@code *}.
 * @return default values or empty map
 */
public Map<String,Map<String,String>> getDefaultValueMap(){
  return defaultValueMap;
}",0.9800918836140888
100675,"/** 
 * Populate valid values map
 * @param subtree subject scheme definition element
 * @param elementName element name
 * @param attName attribute name
 */
private void putValuePairsIntoMap(final Element subtree,final String elementName,final String attName){
  if (subtree == null || attName == null) {
    return;
  }
  Map<String,Set<String>> valueMap=validValuesMap.get(attName);
  if (valueMap == null) {
    valueMap=new HashMap<String,Set<String>>();
  }
  Set<String> valueSet=valueMap.get(elementName);
  if (valueSet == null) {
    valueSet=new HashSet<String>();
  }
  final LinkedList<Element> queue=new LinkedList<Element>();
  queue.offer(subtree);
  while (!queue.isEmpty()) {
    final Element node=queue.poll();
    final NodeList children=node.getChildNodes();
    for (int i=0; i < children.getLength(); i++) {
      if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {
        queue.offer((Element)children.item(i));
      }
    }
    if (SUBJECTSCHEME_SUBJECTDEF.matches(node)) {
      final String key=node.getAttribute(ATTRIBUTE_NAME_KEYS);
      if (!StringUtils.isEmptyString(key)) {
        valueSet.add(key);
      }
    }
  }
  valueMap.put(elementName,valueSet);
  validValuesMap.put(attName,valueMap);
}","/** 
 * Populate valid values map
 * @param subtree subject scheme definition element
 * @param elementName element name
 * @param attName attribute name
 * @param category enumeration category name
 */
private void putValuePairsIntoMap(final Element subtree,final String elementName,final String attName,final String category){
  if (subtree == null || attName == null) {
    return;
  }
  Map<String,Set<String>> valueMap=validValuesMap.get(attName);
  if (valueMap == null) {
    valueMap=new HashMap<String,Set<String>>();
  }
  Set<String> valueSet=valueMap.get(elementName);
  if (valueSet == null) {
    valueSet=new HashSet<String>();
  }
  final LinkedList<Element> queue=new LinkedList<Element>();
  queue.offer(subtree);
  while (!queue.isEmpty()) {
    final Element node=queue.poll();
    final NodeList children=node.getChildNodes();
    for (int i=0; i < children.getLength(); i++) {
      if (children.item(i).getNodeType() == Node.ELEMENT_NODE) {
        queue.offer((Element)children.item(i));
      }
    }
    if (SUBJECTSCHEME_SUBJECTDEF.matches(node)) {
      final String key=node.getAttribute(ATTRIBUTE_NAME_KEYS);
      if (!(key == null || key.trim().isEmpty() || key.equals(category))) {
        valueSet.add(key);
      }
    }
  }
  valueMap.put(elementName,valueSet);
  validValuesMap.put(attName,valueMap);
}",0.9426356589147288
100676,"/** 
 * Construct filter utility.
 * @param isPrintType transformation output is print-oriented
 */
public FilterUtils(final boolean isPrintType,final Map<FilterKey,Action> filterMap){
  final Map<FilterKey,Action> dfm=new HashMap<FilterKey,Action>();
  dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_YES),Action.INCLUDE);
  if (isPrintType) {
    dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_PRINT_ONLY),Action.INCLUDE);
    dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_NO),Action.EXCLUDE);
  }
 else {
    dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_PRINT_ONLY),Action.EXCLUDE);
    dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_NO),Action.INCLUDE);
  }
  dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,null),Action.INCLUDE);
  dfm.putAll(filterMap);
  this.filterMap=dfm;
}","/** 
 * Construct filter utility.
 * @param isPrintType transformation output is print-oriented
 */
public FilterUtils(final boolean isPrintType,final Map<FilterKey,Action> filterMap){
  final Map<FilterKey,Action> dfm=new HashMap<FilterKey,Action>();
  dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_YES),Action.INCLUDE);
  if (isPrintType) {
    dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_PRINT_ONLY),Action.INCLUDE);
    dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_NO),Action.EXCLUDE);
  }
 else {
    dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_PRINT_ONLY),Action.EXCLUDE);
    dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,ATTR_PRINT_VALUE_NO),Action.INCLUDE);
  }
  dfm.put(new FilterKey(ATTRIBUTE_NAME_PRINT,null),Action.INCLUDE);
  dfm.putAll(filterMap);
  this.logMissingAction=!filterMap.isEmpty();
  this.filterMap=dfm;
}",0.9631336405529954
100677,"/** 
 * Refine filter with subject scheme.
 * @param bindingMap subject scheme bindings
 * @return new filter with subject scheme information
 */
public FilterUtils refine(final Map<String,Map<String,Set<Element>>> bindingMap){
  if (bindingMap != null && !bindingMap.isEmpty()) {
    final Map<FilterKey,Action> buf=new HashMap<FilterKey,Action>(filterMap);
    for (    final Map.Entry<FilterKey,Action> e : filterMap.entrySet()) {
      refineAction(e.getValue(),e.getKey(),bindingMap,buf);
    }
    final FilterUtils filterUtils=new FilterUtils(buf);
    filterUtils.setLogger(logger);
    return filterUtils;
  }
 else {
    return this;
  }
}","/** 
 * Refine filter with subject scheme.
 * @param bindingMap subject scheme bindings
 * @return new filter with subject scheme information
 */
public FilterUtils refine(final Map<String,Map<String,Set<Element>>> bindingMap){
  if (bindingMap != null && !bindingMap.isEmpty()) {
    final Map<FilterKey,Action> buf=new HashMap<FilterKey,Action>(filterMap);
    for (    final Map.Entry<FilterKey,Action> e : filterMap.entrySet()) {
      refineAction(e.getValue(),e.getKey(),bindingMap,buf);
    }
    final FilterUtils filterUtils=new FilterUtils(buf);
    filterUtils.setLogger(logger);
    filterUtils.logMissingAction=logMissingAction;
    return filterUtils;
  }
 else {
    return this;
  }
}",0.9518161601186064
100678,"/** 
 * Check if attribute value has mapping in filter configuration and throw messages.
 * @param attName attribute name
 * @param attValue attribute value
 */
private void checkRuleMapping(final String attName,final List<String> attValue){
  if (attValue == null || attValue.isEmpty()) {
    return;
  }
  for (  final String attSubValue : attValue) {
    final FilterKey filterKey=new FilterKey(attName,attSubValue);
    final Action filterAction=filterMap.get(filterKey);
    if (filterAction == null) {
      if (!alreadyShowed(filterKey)) {
        logger.info(MessageUtils.getInstance().getMessage(""String_Node_Str"",filterKey.toString()).toString());
      }
    }
  }
}","/** 
 * Check if attribute value has mapping in filter configuration and throw messages.
 * @param attName attribute name
 * @param attValue attribute value
 */
private void checkRuleMapping(final String attName,final List<String> attValue){
  if (attValue == null || attValue.isEmpty()) {
    return;
  }
  for (  final String attSubValue : attValue) {
    final FilterKey filterKey=new FilterKey(attName,attSubValue);
    final Action filterAction=filterMap.get(filterKey);
    if (filterAction == null && logMissingAction) {
      if (!alreadyShowed(filterKey)) {
        logger.info(MessageUtils.getInstance().getMessage(""String_Node_Str"",filterKey.toString()).toString());
      }
    }
  }
}",0.985443959243086
100679,"/** 
 * Get attribute value or default if attribute is not defined
 * @param elemQName element QName
 * @param attQName attribute QName
 * @param value attribute value
 * @return attribute value or default
 */
private String getAttributeValue(final String elemQName,final String attQName,final String value){
  if (StringUtils.isEmptyString(value) && defaultValueMap != null && !defaultValueMap.isEmpty()) {
    final Map<String,String> defaultMap=defaultValueMap.get(attQName);
    if (defaultMap != null) {
      final String defaultValue=defaultMap.get(elemQName);
      if (defaultValue != null) {
        return defaultValue;
      }
    }
  }
  return value;
}","/** 
 * Get attribute value or default if attribute is not defined
 * @param elemQName element QName
 * @param attQName attribute QName
 * @param value attribute value
 * @return attribute value or default
 */
private String getAttributeValue(final String elemQName,final String attQName,final String value){
  if (StringUtils.isEmptyString(value) && !defaultValueMap.isEmpty()) {
    final Map<String,String> defaultMap=defaultValueMap.get(attQName);
    if (defaultMap != null) {
      final String defaultValue=defaultMap.get(elemQName);
      if (defaultValue != null) {
        return defaultValue;
      }
    }
  }
  return value;
}",0.6865900383141762
100680,"/** 
 * Set default value map.
 * @param defaultMap default value map, may be {@code null}
 */
public void setDefaultValueMap(final Map<String,Map<String,String>> defaultMap){
  defaultValueMap=defaultMap;
}","/** 
 * Set default value map.
 * @param defaultMap default value map
 */
public void setDefaultValueMap(final Map<String,Map<String,String>> defaultMap){
  defaultValueMap=defaultMap;
}",0.9465648854961832
100681,"/** 
 * Validate attribute values
 * @param qName element name
 * @param atts attributes
 */
private void validateAttributeValues(final String qName,final Attributes atts){
  if (validateMap == null || validateMap.isEmpty()) {
    return;
  }
  for (int i=0; i < atts.getLength(); i++) {
    final String attrName=atts.getQName(i);
    final Map<String,Set<String>> valueMap=validateMap.get(attrName);
    if (valueMap != null) {
      Set<String> valueSet=valueMap.get(qName);
      if (valueSet == null) {
        valueSet=valueMap.get(""String_Node_Str"");
      }
      if (valueSet != null) {
        final String attrValue=atts.getValue(i);
        final String[] keylist=attrValue.trim().split(""String_Node_Str"");
        for (        final String s : keylist) {
          if (!StringUtils.isEmptyString(s) && !valueSet.contains(s)) {
            logger.warn(messageUtils.getMessage(""String_Node_Str"",attrName,qName,attrValue,StringUtils.join(valueSet,COMMA)).toString());
          }
        }
      }
    }
  }
}","/** 
 * Validate attribute values
 * @param qName element name
 * @param atts attributes
 */
private void validateAttributeValues(final String qName,final Attributes atts){
  if (validateMap.isEmpty()) {
    return;
  }
  for (int i=0; i < atts.getLength(); i++) {
    final String attrName=atts.getQName(i);
    final Map<String,Set<String>> valueMap=validateMap.get(attrName);
    if (valueMap != null) {
      Set<String> valueSet=valueMap.get(qName);
      if (valueSet == null) {
        valueSet=valueMap.get(""String_Node_Str"");
      }
      if (valueSet != null) {
        final String attrValue=atts.getValue(i);
        final String[] keylist=attrValue.trim().split(""String_Node_Str"");
        for (        final String s : keylist) {
          if (!StringUtils.isEmptyString(s) && !valueSet.contains(s)) {
            logger.warn(messageUtils.getMessage(""String_Node_Str"",attrName,qName,attrValue,StringUtils.join(valueSet,COMMA)).toString());
          }
        }
      }
    }
  }
}",0.9885856079404468
100682,"@Test public void testNeedExcludeGroup(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}","@Test public void testNeedExcludeGroup(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(false,fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}",0.996470588235294
100683,"@Test public void testNeedExcludeLabel(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}}));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
}","@Test public void testNeedExcludeLabel(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(false,fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}}));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
}",0.9970238095238096
100684,"@Test public void testNeedExcludeDefaultExclude(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>(filterMap);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(new AttributesImpl(),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}","@Test public void testNeedExcludeDefaultExclude(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>(filterMap);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(false,fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(new AttributesImpl(),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}",0.9951377633711508
100685,"@Test public void testNeedExcludeNoAttribute(){
  final FilterUtils f=new FilterUtils(filterMap);
  assertFalse(f.needExclude(new AttributesImpl(),new String[0][0]));
}","@Test public void testNeedExcludeNoAttribute(){
  final FilterUtils f=new FilterUtils(false,filterMap);
  assertFalse(f.needExclude(new AttributesImpl(),new String[0][0]));
}",0.9824561403508772
100686,"@Test public void testNeedExclude(){
  final FilterUtils f=new FilterUtils(filterMap);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}","@Test public void testNeedExclude(){
  final FilterUtils f=new FilterUtils(false,filterMap);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}",0.9925558312655088
100687,"@Test public void testNeedExcludeDefaultInclude(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>(filterMap);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.INCLUDE);
  final FilterUtils f=new FilterUtils(fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}","@Test public void testNeedExcludeDefaultInclude(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>(filterMap);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.INCLUDE);
  final FilterUtils f=new FilterUtils(false,fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}",0.994535519125683
100688,"@Test public void testNeedExcludeMultipleAttributes(){
  final FilterUtils f=new FilterUtils(filterMap);
  f.setLogger(new TestUtils.TestLogger());
  final AttributesImpl amigaUnix=new AttributesImpl();
  XMLUtils.addOrSetAttribute(amigaUnix,""String_Node_Str"",""String_Node_Str"");
  XMLUtils.addOrSetAttribute(amigaUnix,""String_Node_Str"",""String_Node_Str"");
  assertFalse(f.needExclude(amigaUnix,new String[0][0]));
  final AttributesImpl amiga=new AttributesImpl();
  XMLUtils.addOrSetAttribute(amiga,""String_Node_Str"",""String_Node_Str"");
  XMLUtils.addOrSetAttribute(amiga,""String_Node_Str"",""String_Node_Str"");
  assertFalse(f.needExclude(amiga,new String[0][0]));
  final AttributesImpl windows=new AttributesImpl();
  XMLUtils.addOrSetAttribute(windows,""String_Node_Str"",""String_Node_Str"");
  XMLUtils.addOrSetAttribute(windows,""String_Node_Str"",""String_Node_Str"");
  assertTrue(f.needExclude(windows,new String[0][0]));
}","@Test public void testNeedExcludeMultipleAttributes(){
  final FilterUtils f=new FilterUtils(false,filterMap);
  f.setLogger(new TestUtils.TestLogger());
  final AttributesImpl amigaUnix=new AttributesImpl();
  XMLUtils.addOrSetAttribute(amigaUnix,""String_Node_Str"",""String_Node_Str"");
  XMLUtils.addOrSetAttribute(amigaUnix,""String_Node_Str"",""String_Node_Str"");
  assertFalse(f.needExclude(amigaUnix,new String[0][0]));
  final AttributesImpl amiga=new AttributesImpl();
  XMLUtils.addOrSetAttribute(amiga,""String_Node_Str"",""String_Node_Str"");
  XMLUtils.addOrSetAttribute(amiga,""String_Node_Str"",""String_Node_Str"");
  assertFalse(f.needExclude(amiga,new String[0][0]));
  final AttributesImpl windows=new AttributesImpl();
  XMLUtils.addOrSetAttribute(windows,""String_Node_Str"",""String_Node_Str"");
  XMLUtils.addOrSetAttribute(windows,""String_Node_Str"",""String_Node_Str"");
  assertTrue(f.needExclude(windows,new String[0][0]));
}",0.9967672413793104
100689,"@Test public void testNeedExcludeDomainAttribute(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}}));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
}","@Test public void testNeedExcludeDomainAttribute(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(false,fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}}));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}}));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[][]{{""String_Node_Str"",""String_Node_Str""}}));
}",0.9970559371933267
100690,"@Test public void testNeedExcludeGroupMultiple(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.INCLUDE);
  final FilterUtils f=new FilterUtils(fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}","@Test public void testNeedExcludeGroupMultiple(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.INCLUDE);
  final FilterUtils f=new FilterUtils(false,fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}",0.9967914438502674
100691,"@Test public void testNeedExcludeMixedGroups(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.INCLUDE);
  final FilterUtils f=new FilterUtils(fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}","@Test public void testNeedExcludeMixedGroups(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.EXCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.INCLUDE);
  final FilterUtils f=new FilterUtils(false,fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}",0.9956521739130436
100692,"@Test public void testGetUngroupedValue(){
  final FilterUtils f=new FilterUtils(Collections.EMPTY_MAP);
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str"",""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
}","@Test public void testGetUngroupedValue(){
  final FilterUtils f=new FilterUtils(false,Collections.EMPTY_MAP);
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str"",""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(null,Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
{
    final Map<String,List<String>> exp=new HashMap<String,List<String>>();
    exp.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(exp,f.getGroups(""String_Node_Str""));
  }
}",0.9984
100693,"@Test public void testNeedExcludeOtherpropsLabel(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}","@Test public void testNeedExcludeOtherpropsLabel(){
  final Map<FilterKey,Action> fm=new HashMap<FilterKey,Action>();
  fm.put(new FilterKey(""String_Node_Str"",""String_Node_Str""),Action.INCLUDE);
  fm.put(new FilterKey(""String_Node_Str"",null),Action.EXCLUDE);
  final FilterUtils f=new FilterUtils(false,fm);
  f.setLogger(new TestUtils.TestLogger());
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertFalse(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
  assertTrue(f.needExclude(attr(""String_Node_Str"",""String_Node_Str""),new String[0][0]));
}",0.9951456310679612
100694,"@Test public void testNoFilter() throws Exception {
  test(new FilterUtils(Collections.EMPTY_MAP),""String_Node_Str"",""String_Node_Str"");
  final DitaValReader filterReader=new DitaValReader();
  filterReader.read(new File(getClass().getClassLoader().getResource(""String_Node_Str"").toURI()).getAbsoluteFile());
  final FilterUtils filterUtils=new FilterUtils(filterReader.getFilterMap());
  filterUtils.setLogger(new TestUtils.TestLogger());
  test(filterUtils,""String_Node_Str"",""String_Node_Str"");
  test(new FilterUtils(false,Collections.EMPTY_MAP),""String_Node_Str"",""String_Node_Str"");
  test(new FilterUtils(true,Collections.EMPTY_MAP),""String_Node_Str"",""String_Node_Str"");
}","@Test public void testNoFilter() throws Exception {
  test(new FilterUtils(false,Collections.EMPTY_MAP),""String_Node_Str"",""String_Node_Str"");
  final DitaValReader filterReader=new DitaValReader();
  filterReader.read(new File(getClass().getClassLoader().getResource(""String_Node_Str"").toURI()).getAbsoluteFile());
  final FilterUtils filterUtils=new FilterUtils(false,filterReader.getFilterMap());
  filterUtils.setLogger(new TestUtils.TestLogger());
  test(filterUtils,""String_Node_Str"",""String_Node_Str"");
  test(new FilterUtils(false,Collections.EMPTY_MAP),""String_Node_Str"",""String_Node_Str"");
  test(new FilterUtils(true,Collections.EMPTY_MAP),""String_Node_Str"",""String_Node_Str"");
}",0.9912152269399708
100695,"@Test public void testKeyscope() throws SAXException, URISyntaxException {
  final ValidationFilter f=new ValidationFilter();
  f.setContentHandler(new DefaultHandler());
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  assertEquals(0,l.getMessages().size());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  assertEquals(2,l.getMessages().size());
  for (  final Message m : l.getMessages()) {
    assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,m.level);
  }
}","@Test public void testKeyscope() throws SAXException, URISyntaxException {
  final ValidationFilter f=new ValidationFilter();
  f.setValidateMap(Collections.EMPTY_MAP);
  f.setContentHandler(new DefaultHandler());
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  assertEquals(0,l.getMessages().size());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYSCOPE,""String_Node_Str"").build());
  assertEquals(2,l.getMessages().size());
  for (  final Message m : l.getMessages()) {
    assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,m.level);
  }
}",0.982253404869996
100696,"@Test public void testKeys() throws SAXException, URISyntaxException {
  final ValidationFilter f=new ValidationFilter();
  f.setContentHandler(new DefaultHandler());
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  assertEquals(0,l.getMessages().size());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  assertEquals(2,l.getMessages().size());
  for (  final Message m : l.getMessages()) {
    assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,m.level);
  }
}","@Test public void testKeys() throws SAXException, URISyntaxException {
  final ValidationFilter f=new ValidationFilter();
  f.setValidateMap(Collections.EMPTY_MAP);
  f.setContentHandler(new DefaultHandler());
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  assertEquals(0,l.getMessages().size());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_KEYS,""String_Node_Str"").build());
  assertEquals(2,l.getMessages().size());
  for (  final Message m : l.getMessages()) {
    assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,m.level);
  }
}",0.9818947368421052
100697,"@Test public void testId() throws SAXException, URISyntaxException {
  final ValidationFilter f=new ValidationFilter();
  f.setContentHandler(new DefaultHandler());
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,TOPIC_TOPIC.localName,TOPIC_TOPIC.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_TOPIC.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_P.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_P.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_P.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  f.startElement(NULL_NS_URI,TOPIC_TOPIC.localName,TOPIC_TOPIC.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_TOPIC.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_P.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  assertEquals(TestUtils.CachingLogger.Message.Level.WARN,l.getMessages().get(0).level);
}","@Test public void testId() throws SAXException, URISyntaxException {
  final ValidationFilter f=new ValidationFilter();
  f.setValidateMap(Collections.EMPTY_MAP);
  f.setContentHandler(new DefaultHandler());
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,TOPIC_TOPIC.localName,TOPIC_TOPIC.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_TOPIC.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_P.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_P.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_P.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  f.startElement(NULL_NS_URI,TOPIC_TOPIC.localName,TOPIC_TOPIC.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_TOPIC.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_P.localName,TOPIC_P.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_CLASS,TOPIC_P.toString()).add(ATTRIBUTE_NAME_ID,""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  assertEquals(TestUtils.CachingLogger.Message.Level.WARN,l.getMessages().get(0).level);
}",0.9863708399366086
100698,"@Test public void testHref() throws SAXException, URISyntaxException {
  final List<String> res=new ArrayList<String>();
  final ValidationFilter f=new ValidationFilter();
  f.setProcessingMode(Configuration.Mode.LAX);
  f.setContentHandler(new DefaultHandler(){
    @Override public void startElement(    final String uri,    final String localName,    final String qName,    final Attributes atts) throws SAXException {
      res.add(atts.getValue(ATTRIBUTE_NAME_HREF));
    }
  }
);
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,TOPIC_XREF.localName,TOPIC_XREF.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_HREF,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_XREF.localName,TOPIC_XREF.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_HREF,""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,l.getMessages().get(0).level);
  assertEquals(""String_Node_Str"",res.get(0));
  assertEquals(""String_Node_Str"",res.get(1));
}","@Test public void testHref() throws SAXException, URISyntaxException {
  final List<String> res=new ArrayList<String>();
  final ValidationFilter f=new ValidationFilter();
  f.setValidateMap(Collections.EMPTY_MAP);
  f.setProcessingMode(Configuration.Mode.LAX);
  f.setContentHandler(new DefaultHandler(){
    @Override public void startElement(    final String uri,    final String localName,    final String qName,    final Attributes atts) throws SAXException {
      res.add(atts.getValue(ATTRIBUTE_NAME_HREF));
    }
  }
);
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,TOPIC_XREF.localName,TOPIC_XREF.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_HREF,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,TOPIC_XREF.localName,TOPIC_XREF.localName,new AttributesBuilder().add(ATTRIBUTE_NAME_HREF,""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,l.getMessages().get(0).level);
  assertEquals(""String_Node_Str"",res.get(0));
  assertEquals(""String_Node_Str"",res.get(1));
}",0.9806567701304544
100699,"@Test public void testXMLLang() throws SAXException {
  final List<String> res=new ArrayList<String>();
  final ValidationFilter f=new ValidationFilter();
  f.setProcessingMode(Configuration.Mode.LAX);
  f.setContentHandler(new DefaultHandler(){
    @Override public void startElement(    final String uri,    final String localName,    final String qName,    final Attributes atts) throws SAXException {
      res.add(atts.getValue(XML_NS_URI,""String_Node_Str""));
    }
  }
);
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,l.getMessages().get(0).level);
  assertEquals(""String_Node_Str"",res.get(0));
  assertEquals(""String_Node_Str"",res.get(1));
}","@Test public void testXMLLang() throws SAXException {
  final List<String> res=new ArrayList<String>();
  final ValidationFilter f=new ValidationFilter();
  f.setValidateMap(Collections.EMPTY_MAP);
  f.setProcessingMode(Configuration.Mode.LAX);
  f.setContentHandler(new DefaultHandler(){
    @Override public void startElement(    final String uri,    final String localName,    final String qName,    final Attributes atts) throws SAXException {
      res.add(atts.getValue(XML_NS_URI,""String_Node_Str""));
    }
  }
);
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,l.getMessages().get(0).level);
  assertEquals(""String_Node_Str"",res.get(0));
  assertEquals(""String_Node_Str"",res.get(1));
}",0.9806219017575484
100700,"@Test public void testAttributeGeneralization() throws SAXException {
  final ValidationFilter f=new ValidationFilter();
  f.setContentHandler(new DefaultHandler());
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,ATTRIBUTE_NAME_DOMAINS,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,l.getMessages().get(0).level);
}","@Test public void testAttributeGeneralization() throws SAXException {
  final ValidationFilter f=new ValidationFilter();
  f.setValidateMap(Collections.EMPTY_MAP);
  f.setContentHandler(new DefaultHandler());
  final TestUtils.CachingLogger l=new TestUtils.CachingLogger();
  f.setLogger(l);
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,ATTRIBUTE_NAME_DOMAINS,""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  f.startElement(NULL_NS_URI,""String_Node_Str"",""String_Node_Str"",new AttributesBuilder().add(XML_NS_URI,""String_Node_Str"",""String_Node_Str"").build());
  assertEquals(1,l.getMessages().size());
  assertEquals(TestUtils.CachingLogger.Message.Level.ERROR,l.getMessages().get(0).level);
}",0.9798027242837012
100701,"/** 
 * Check if path falls outside start document directory
 * @param filePathName absolute path to test
 * @param inputMap absolute input map path
 * @return {@code true} if outside start directory, otherwise {@code false}
 */
private static boolean isOutFile(final File filePathName,final File inputMap){
  final File relativePath=getRelativePath(inputMap.getAbsoluteFile(),filePathName.getAbsoluteFile());
  return !(relativePath == null || relativePath.getPath().length() == 0 || !relativePath.getPath().startsWith(""String_Node_Str""));
}","/** 
 * Check if path falls outside start document directory
 * @param filePathName absolute path to test
 * @param inputMap absolute input map path
 * @return {@code true} if outside start directory, otherwise {@code false}
 */
private static boolean isOutFile(final File filePathName,final File inputMap){
  final File relativePath=getRelativePath(inputMap.getAbsoluteFile(),filePathName.getAbsoluteFile());
  return !(relativePath.getPath().length() == 0 || !relativePath.getPath().startsWith(""String_Node_Str""));
}",0.939622641509434
100702,"/** 
 * Write result files.
 * @throws DITAOTException if writing result files failed
 */
private void outputResult() throws DITAOTException {
  if (!job.tempDir.exists()) {
    job.tempDir.mkdirs();
  }
  final File relativeRootFile=getRelativePath(new File(baseInputDir,""String_Node_Str""),rootFile);
  job.setProperty(INPUT_DIR,baseInputDir.getAbsolutePath());
  job.setProperty(INPUT_DITAMAP,relativeRootFile.toString());
  job.setProperty(INPUT_DITAMAP_LIST_FILE_LIST,USER_INPUT_FILE_LIST_FILE);
  final File inputfile=new File(job.tempDir,USER_INPUT_FILE_LIST_FILE);
  Writer bufferedWriter=null;
  try {
    bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(inputfile)));
    bufferedWriter.write(relativeRootFile.toString());
    bufferedWriter.flush();
  }
 catch (  final FileNotFoundException e) {
    logger.error(e.getMessage(),e);
  }
catch (  final IOException e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    if (bufferedWriter != null) {
      try {
        bufferedWriter.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
  job.setProperty(""String_Node_Str"",escapeRegExp(prefix));
  job.setProperty(""String_Node_Str"",getLevelsPath());
  for (  final URI file : addFilePrefix(outDitaFilesSet)) {
    job.getOrCreateFileInfo(file).isOutDita=true;
  }
  for (  final URI file : addFilePrefix(fullTopicSet)) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : addFilePrefix(fullMapSet)) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : addFilePrefix(hrefTopicSet)) {
    job.getOrCreateFileInfo(file).hasLink=true;
  }
  for (  final URI file : addFilePrefix(conrefSet)) {
    job.getOrCreateFileInfo(file).hasConref=true;
  }
  for (  final URI file : addFilePrefix(imageSet)) {
    job.getOrCreateFileInfo(file).format=""String_Node_Str"";
  }
  for (  final URI file : addFilePrefix(flagImageSet)) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.isFlagImage=true;
    f.format=""String_Node_Str"";
  }
  for (  final URI file : addFilePrefix(htmlSet)) {
    job.getOrCreateFileInfo(file).format=""String_Node_Str"";
  }
  for (  final URI file : addFilePrefix(hrefTargetSet)) {
    job.getOrCreateFileInfo(file).isTarget=true;
  }
  for (  final URI file : addFilePrefix(hrefWithIDSet)) {
    job.getOrCreateFileInfo(file).isNonConrefTarget=true;
  }
  for (  final URI file : addFilePrefix(chunkTopicSet)) {
    job.getOrCreateFileInfo(file).isSkipChunk=true;
  }
  for (  final URI file : addFilePrefix(schemeSet)) {
    job.getOrCreateFileInfo(file).isSubjectScheme=true;
  }
  for (  final URI file : addFilePrefix(conrefTargetSet)) {
    job.getOrCreateFileInfo(file).isConrefTarget=true;
  }
  for (  final URI file : addFilePrefix(copytoSourceSet)) {
    job.getOrCreateFileInfo(file).isCopyToSource=true;
  }
  for (  final URI file : addFilePrefix(subsidiarySet)) {
    job.getOrCreateFileInfo(file).isSubtarget=true;
  }
  for (  final URI file : addFilePrefix(conrefpushSet)) {
    job.getOrCreateFileInfo(file).isConrefPush=true;
  }
  for (  final URI file : addFilePrefix(keyrefSet)) {
    job.getOrCreateFileInfo(file).hasKeyref=true;
  }
  for (  final URI file : addFilePrefix(coderefSet)) {
    job.getOrCreateFileInfo(file).hasCoderef=true;
  }
  for (  final URI file : addFilePrefix(resourceOnlySet)) {
    job.getOrCreateFileInfo(file).isResourceOnly=true;
  }
  addFlagImagesSetToProperties(job,relFlagImagesSet);
  job.setCopytoMap(addFilePrefix(copytoMap));
  addKeyDefSetToProperties(job,keysDefMap);
  try {
    logger.info(""String_Node_Str"");
    job.write();
  }
 catch (  final IOException e) {
    throw new DITAOTException(""String_Node_Str"" + e.getMessage(),e);
  }
  try {
    SubjectSchemeReader.writeMapToXML(addMapFilePrefix(listFilter.getRelationshipGrap()),new File(job.tempDir,FILE_NAME_SUBJECT_RELATION));
    SubjectSchemeReader.writeMapToXML(addMapFilePrefix(schemeDictionary),new File(job.tempDir,FILE_NAME_SUBJECT_DICTIONARY));
  }
 catch (  final IOException e) {
    throw new DITAOTException(e);
  }
  writeExportAnchors();
  KeyDef.writeKeydef(new File(job.tempDir,SUBJECT_SCHEME_KEYDEF_LIST_FILE),addFilePrefix(schemekeydefMap.values()));
}","/** 
 * Write result files.
 * @throws DITAOTException if writing result files failed
 */
private void outputResult() throws DITAOTException {
  if (!job.tempDir.exists()) {
    job.tempDir.mkdirs();
  }
  final File relativeRootFile=getRelativePath(new File(baseInputDir,""String_Node_Str""),new File(rootFile));
  job.setProperty(INPUT_DIR,baseInputDir.getAbsolutePath());
  job.setProperty(INPUT_DITAMAP,relativeRootFile.toString());
  job.setProperty(INPUT_DITAMAP_LIST_FILE_LIST,USER_INPUT_FILE_LIST_FILE);
  final File inputfile=new File(job.tempDir,USER_INPUT_FILE_LIST_FILE);
  Writer bufferedWriter=null;
  try {
    bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(inputfile)));
    bufferedWriter.write(relativeRootFile.toString());
    bufferedWriter.flush();
  }
 catch (  final FileNotFoundException e) {
    logger.error(e.getMessage(),e);
  }
catch (  final IOException e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    if (bufferedWriter != null) {
      try {
        bufferedWriter.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
  job.setProperty(""String_Node_Str"",escapeRegExp(prefix));
  job.setProperty(""String_Node_Str"",getLevelsPath());
  for (  final URI file : addFilePrefix(outDitaFilesSet)) {
    job.getOrCreateFileInfo(file).isOutDita=true;
  }
  for (  final URI file : addFilePrefix(fullTopicSet)) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
  }
  for (  final URI file : addFilePrefix(fullMapSet)) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
  }
  for (  final URI file : addFilePrefix(hrefTopicSet)) {
    job.getOrCreateFileInfo(file).hasLink=true;
  }
  for (  final URI file : addFilePrefix(conrefSet)) {
    job.getOrCreateFileInfo(file).hasConref=true;
  }
  for (  final URI file : addFilePrefix(imageSet)) {
    job.getOrCreateFileInfo(file).format=""String_Node_Str"";
  }
  for (  final URI file : addFilePrefix(flagImageSet)) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.isFlagImage=true;
    f.format=""String_Node_Str"";
  }
  for (  final URI file : addFilePrefix(htmlSet)) {
    job.getOrCreateFileInfo(file).format=""String_Node_Str"";
  }
  for (  final URI file : addFilePrefix(hrefTargetSet)) {
    job.getOrCreateFileInfo(file).isTarget=true;
  }
  for (  final URI file : addFilePrefix(hrefWithIDSet)) {
    job.getOrCreateFileInfo(file).isNonConrefTarget=true;
  }
  for (  final URI file : addFilePrefix(chunkTopicSet)) {
    job.getOrCreateFileInfo(file).isSkipChunk=true;
  }
  for (  final URI file : addFilePrefix(schemeSet)) {
    job.getOrCreateFileInfo(file).isSubjectScheme=true;
  }
  for (  final URI file : addFilePrefix(conrefTargetSet)) {
    job.getOrCreateFileInfo(file).isConrefTarget=true;
  }
  for (  final URI file : addFilePrefix(copytoSourceSet)) {
    job.getOrCreateFileInfo(file).isCopyToSource=true;
  }
  for (  final URI file : addFilePrefix(subsidiarySet)) {
    job.getOrCreateFileInfo(file).isSubtarget=true;
  }
  for (  final URI file : addFilePrefix(conrefpushSet)) {
    job.getOrCreateFileInfo(file).isConrefPush=true;
  }
  for (  final URI file : addFilePrefix(keyrefSet)) {
    job.getOrCreateFileInfo(file).hasKeyref=true;
  }
  for (  final URI file : addFilePrefix(coderefSet)) {
    job.getOrCreateFileInfo(file).hasCoderef=true;
  }
  for (  final URI file : addFilePrefix(resourceOnlySet)) {
    job.getOrCreateFileInfo(file).isResourceOnly=true;
  }
  addFlagImagesSetToProperties(job,relFlagImagesSet);
  job.setCopytoMap(addFilePrefix(copytoMap));
  addKeyDefSetToProperties(job,keysDefMap);
  try {
    logger.info(""String_Node_Str"");
    job.write();
  }
 catch (  final IOException e) {
    throw new DITAOTException(""String_Node_Str"" + e.getMessage(),e);
  }
  try {
    SubjectSchemeReader.writeMapToXML(addMapFilePrefix(listFilter.getRelationshipGrap()),new File(job.tempDir,FILE_NAME_SUBJECT_RELATION));
    SubjectSchemeReader.writeMapToXML(addMapFilePrefix(schemeDictionary),new File(job.tempDir,FILE_NAME_SUBJECT_DICTIONARY));
  }
 catch (  final IOException e) {
    throw new DITAOTException(e);
  }
  writeExportAnchors();
  KeyDef.writeKeydef(new File(job.tempDir,SUBJECT_SCHEME_KEYDEF_LIST_FILE),addFilePrefix(schemekeydefMap.values()));
}",0.9970217640320732
100703,"@Override public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  if (logger == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    parseInputParameters(input);
    initFilters();
    initXMLReader(ditaDir,xmlValidate);
    addToWaitList(rootFile.toURI());
    processWaitList();
    updateBaseDirectory();
    refactoringResult();
    outputResult();
  }
 catch (  final DITAOTException e) {
    throw e;
  }
catch (  final SAXException e) {
    throw new DITAOTException(e.getMessage(),e);
  }
catch (  final Exception e) {
    throw new DITAOTException(e.getMessage(),e);
  }
  return null;
}","@Override public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  if (logger == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    parseInputParameters(input);
    initFilters();
    initXMLReader(ditaDir,xmlValidate);
    addToWaitList(rootFile);
    processWaitList();
    updateBaseDirectory();
    refactoringResult();
    outputResult();
  }
 catch (  final DITAOTException e) {
    throw e;
  }
catch (  final SAXException e) {
    throw new DITAOTException(e.getMessage(),e);
  }
catch (  final Exception e) {
    throw new DITAOTException(e.getMessage(),e);
  }
  return null;
}",0.9939668174962292
100704,"/** 
 * Initialize reusable filters.
 */
private void initFilters(){
  listFilter=new GenListModuleReader();
  listFilter.setLogger(logger);
  listFilter.setInputFile(rootFile.toURI());
  listFilter.setInputDir(rootFile.getParentFile().toURI());
  listFilter.setPrimaryDitamap(rootFile.getPath());
  listFilter.setJob(job);
  if (profilingEnabled) {
    filterUtils=parseFilterFile();
  }
  exportAnchorsFilter=new ExportAnchorsFilter();
  exportAnchorsFilter.setInputFile(rootFile.toURI());
  keydefFilter=new KeydefFilter();
  keydefFilter.setLogger(logger);
  keydefFilter.setInputFile(rootFile.toURI());
  keydefFilter.setJob(job);
  nullHandler=new DefaultHandler();
}","/** 
 * Initialize reusable filters.
 */
private void initFilters(){
  listFilter=new GenListModuleReader();
  listFilter.setLogger(logger);
  listFilter.setInputFile(rootFile);
  listFilter.setInputDir(rootFile.resolve(""String_Node_Str""));
  listFilter.setPrimaryDitamap(rootFile);
  listFilter.setJob(job);
  if (profilingEnabled) {
    filterUtils=parseFilterFile();
  }
  exportAnchorsFilter=new ExportAnchorsFilter();
  exportAnchorsFilter.setInputFile(rootFile);
  keydefFilter=new KeydefFilter();
  keydefFilter.setLogger(logger);
  keydefFilter.setInputFile(rootFile);
  keydefFilter.setJob(job);
  nullHandler=new DefaultHandler();
}",0.6950570342205323
100705,"/** 
 * Add key definition to job configuration
 * @param prop job configuration
 * @param keydefs key defintions to add
 */
private void addKeyDefSetToProperties(final Job prop,final Map<String,KeyDef> keydefs){
  final URI b=baseInputDir.toURI();
  final Collection<KeyDef> updated=new ArrayList<KeyDef>(keydefs.size());
  for (  final KeyDef file : keydefs.values()) {
    final String keys=file.keys;
    if (file.href != null && ATTR_SCOPE_VALUE_LOCAL.equals(file.scope)) {
      assert(file.href == null || file.href.isAbsolute() || toFile(file.href).isAbsolute());
    }
    final URI href=(file.href != null && ATTR_SCOPE_VALUE_LOCAL.equals(file.scope)) ? b.relativize(file.href) : file.href;
    final URI source=b.relativize(file.source);
    final KeyDef keyDef=new KeyDef(keys,href,file.scope,source);
    updated.add(keyDef);
  }
  try {
    KeyDef.writeKeydef(new File(job.tempDir,KEYDEF_LIST_FILE),updated);
  }
 catch (  final DITAOTException e) {
    logger.error(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Add key definition to job configuration
 * @param prop job configuration
 * @param keydefs key defintions to add
 */
private void addKeyDefSetToProperties(final Job prop,final Map<String,KeyDef> keydefs){
  final URI b=baseInputDir.toURI();
  final Collection<KeyDef> updated=new ArrayList<KeyDef>(keydefs.size());
  for (  final KeyDef file : keydefs.values()) {
    final String keys=file.keys;
    final URI href=(file.href != null && ATTR_SCOPE_VALUE_LOCAL.equals(file.scope)) ? b.relativize(file.href) : file.href;
    final URI source=b.relativize(file.source);
    final KeyDef keyDef=new KeyDef(keys,href,file.scope,source);
    updated.add(keyDef);
  }
  try {
    KeyDef.writeKeydef(new File(job.tempDir,KEYDEF_LIST_FILE),updated);
  }
 catch (  final DITAOTException e) {
    logger.error(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.891848694725626
100706,"private void parseInputParameters(final AbstractPipelineInput input) throws IOException {
  ditaDir=new File(input.getAttribute(ANT_INVOKER_EXT_PARAM_DITADIR));
  if (input.getAttribute(ANT_INVOKER_PARAM_DITAVAL) != null) {
    ditavalFile=new File(input.getAttribute(ANT_INVOKER_PARAM_DITAVAL));
  }
  xmlValidate=Boolean.valueOf(input.getAttribute(ANT_INVOKER_EXT_PARAM_VALIDATE));
  transtype=input.getAttribute(ANT_INVOKER_EXT_PARAM_TRANSTYPE);
  gramcache=""String_Node_Str"".equalsIgnoreCase(input.getAttribute(ANT_INVOKER_EXT_PARAM_GRAMCACHE));
  setSystemid=""String_Node_Str"".equalsIgnoreCase(input.getAttribute(ANT_INVOKER_EXT_PARAN_SETSYSTEMID));
  job.setGeneratecopyouter(input.getAttribute(ANT_INVOKER_EXT_PARAM_GENERATECOPYOUTTER));
  job.setOutterControl(input.getAttribute(ANT_INVOKER_EXT_PARAM_OUTTERCONTROL));
  job.setOnlyTopicInMap(input.getAttribute(ANT_INVOKER_EXT_PARAM_ONLYTOPICINMAP));
  final File path=new File(input.getAttribute(ANT_INVOKER_EXT_PARAM_OUTPUTDIR));
  if (path.isAbsolute()) {
    job.setOutputDir(path);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + path + ""String_Node_Str"");
  }
  final String basedir=input.getAttribute(ANT_INVOKER_PARAM_BASEDIR);
  final String ditaInputDir=input.getAttribute(ANT_INVOKER_EXT_PARAM_INPUTDIR);
  if (ditaInputDir != null) {
    File inDir=new File(ditaInputDir);
    if (!inDir.isAbsolute()) {
      inDir=new File(basedir,ditaInputDir);
    }
    baseInputDir=inDir.getCanonicalFile();
  }
  final String ditaInput=input.getAttribute(ANT_INVOKER_PARAM_INPUTMAP);
  File inFile=new File(ditaInput);
  if (!inFile.isAbsolute()) {
    if (baseInputDir != null) {
      inFile=new File(baseInputDir,ditaInput);
    }
 else {
      inFile=new File(basedir,ditaInput);
    }
  }
  inFile=inFile.getCanonicalFile();
  if (baseInputDir == null) {
    baseInputDir=inFile.getParentFile().getCanonicalFile();
  }
  if (!ditaDir.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ditaDir + ""String_Node_Str"");
  }
 else {
    ditaDir=ditaDir.getCanonicalFile();
  }
  profilingEnabled=true;
  if (input.getAttribute(ANT_INVOKER_PARAM_PROFILING_ENABLED) != null) {
    profilingEnabled=Boolean.parseBoolean(input.getAttribute(ANT_INVOKER_PARAM_PROFILING_ENABLED));
  }
  if (profilingEnabled) {
    if (ditavalFile != null && !ditavalFile.isAbsolute()) {
      ditavalFile=new File(basedir,ditavalFile.getPath()).getAbsoluteFile();
    }
  }
  rootFile=inFile.getCanonicalFile().getAbsoluteFile();
  schemekeydefMap=new HashMap<String,KeyDef>();
  job.setInputFile(inFile);
}","private void parseInputParameters(final AbstractPipelineInput input) throws IOException {
  ditaDir=new File(input.getAttribute(ANT_INVOKER_EXT_PARAM_DITADIR));
  if (input.getAttribute(ANT_INVOKER_PARAM_DITAVAL) != null) {
    ditavalFile=new File(input.getAttribute(ANT_INVOKER_PARAM_DITAVAL));
  }
  xmlValidate=Boolean.valueOf(input.getAttribute(ANT_INVOKER_EXT_PARAM_VALIDATE));
  transtype=input.getAttribute(ANT_INVOKER_EXT_PARAM_TRANSTYPE);
  gramcache=""String_Node_Str"".equalsIgnoreCase(input.getAttribute(ANT_INVOKER_EXT_PARAM_GRAMCACHE));
  setSystemid=""String_Node_Str"".equalsIgnoreCase(input.getAttribute(ANT_INVOKER_EXT_PARAN_SETSYSTEMID));
  job.setGeneratecopyouter(input.getAttribute(ANT_INVOKER_EXT_PARAM_GENERATECOPYOUTTER));
  job.setOutterControl(input.getAttribute(ANT_INVOKER_EXT_PARAM_OUTTERCONTROL));
  job.setOnlyTopicInMap(input.getAttribute(ANT_INVOKER_EXT_PARAM_ONLYTOPICINMAP));
  final File path=new File(input.getAttribute(ANT_INVOKER_EXT_PARAM_OUTPUTDIR));
  if (path.isAbsolute()) {
    job.setOutputDir(path);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + path + ""String_Node_Str"");
  }
  final String basedir=input.getAttribute(ANT_INVOKER_PARAM_BASEDIR);
  final String ditaInputDir=input.getAttribute(ANT_INVOKER_EXT_PARAM_INPUTDIR);
  if (ditaInputDir != null) {
    File inDir=new File(ditaInputDir);
    if (!inDir.isAbsolute()) {
      inDir=new File(basedir,ditaInputDir);
    }
    baseInputDir=inDir.getCanonicalFile();
  }
  final String ditaInput=input.getAttribute(ANT_INVOKER_PARAM_INPUTMAP);
  File inFile=new File(ditaInput);
  if (!inFile.isAbsolute()) {
    if (baseInputDir != null) {
      inFile=new File(baseInputDir,ditaInput);
    }
 else {
      inFile=new File(basedir,ditaInput);
    }
  }
  inFile=inFile.getCanonicalFile();
  if (baseInputDir == null) {
    baseInputDir=inFile.getParentFile().getCanonicalFile();
  }
  if (!ditaDir.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ditaDir + ""String_Node_Str"");
  }
 else {
    ditaDir=ditaDir.getCanonicalFile();
  }
  profilingEnabled=true;
  if (input.getAttribute(ANT_INVOKER_PARAM_PROFILING_ENABLED) != null) {
    profilingEnabled=Boolean.parseBoolean(input.getAttribute(ANT_INVOKER_PARAM_PROFILING_ENABLED));
  }
  if (profilingEnabled) {
    if (ditavalFile != null && !ditavalFile.isAbsolute()) {
      ditavalFile=new File(basedir,ditavalFile.getPath()).getAbsoluteFile();
    }
  }
  rootFile=inFile.getAbsoluteFile().toURI();
  schemekeydefMap=new HashMap<String,KeyDef>();
  job.setInputFile(inFile);
}",0.9901373041964804
100707,"/** 
 * Refine action key with information from subject schemes.
 */
private void refineAction(final Action action,final FilterKey key){
  if (key.attribute != null && key.value != null && bindingMap != null && !bindingMap.isEmpty()) {
    final Map<String,Set<Element>> schemeMap=bindingMap.get(key.attribute);
    if (schemeMap != null && !schemeMap.isEmpty()) {
      for (      final Set<Element> submap : schemeMap.values()) {
        for (        final Element e : submap) {
          final Element subRoot=searchForKey(e,key.value);
          if (subRoot != null) {
            insertAction(subRoot,key.attribute,action);
          }
        }
      }
    }
  }
}","/** 
 * Refine action key with information from subject schemes.
 */
private void refineAction(final Action action,final FilterKey key){
  if (key.value != null && bindingMap != null && !bindingMap.isEmpty()) {
    final Map<String,Set<Element>> schemeMap=bindingMap.get(key.attribute);
    if (schemeMap != null && !schemeMap.isEmpty()) {
      for (      final Set<Element> submap : schemeMap.values()) {
        for (        final Element e : submap) {
          final Element subRoot=searchForKey(e,key.value);
          if (subRoot != null) {
            insertAction(subRoot,key.attribute,action);
          }
        }
      }
    }
  }
}",0.9809885931558936
100708,"public void setPrimaryDitamap(final String primaryDitamap){
  this.primaryDitamap=primaryDitamap;
}","public void setPrimaryDitamap(final URI primaryDitamap){
}",0.7006369426751592
100709,"/** 
 * Set current file absolute path
 * @param currentFile absolute path to current file
 */
public void setCurrentFile(final URI currentFile){
  this.currentFile=currentFile;
}","/** 
 * Set current file absolute path
 * @param currentFile absolute path to current file
 */
public void setCurrentFile(final URI currentFile){
}",0.901840490797546
100710,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((stringValue == null) ? 0 : stringValue.hashCode());
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + (stringValue.hashCode());
  return result;
}",0.9096774193548388
100711,"@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final DitaClass other=(DitaClass)obj;
  if (stringValue == null) {
    if (other.stringValue != null) {
      return false;
    }
  }
 else   if (!stringValue.equals(other.stringValue)) {
    return false;
  }
  return true;
}","@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final DitaClass other=(DitaClass)obj;
  if (!stringValue.equals(other.stringValue)) {
    return false;
  }
  return true;
}",0.7265415549597856
100712,"/** 
 * Check if the given Attributes need to be excluded.
 * @param atts attributes
 * @param extProps {@code props} attribute specializations
 * @return true if any one of attributes 'audience', 'platform', 'product','otherprops', 'props', or 'print' was excluded.
 */
public boolean needExclude(final Attributes atts,final String[][] extProps){
  if (filterMap == null || filterMap.isEmpty()) {
    return false;
  }
  for (  final String attr : PROFILE_ATTRIBUTES) {
    final String value=atts.getValue(attr);
    if (value != null) {
      final Map<String,List<String>> groups=getGroups(value);
      for (      Map.Entry<String,List<String>> group : groups.entrySet()) {
        if (group.getKey() != null) {
          if (extCheckExclude(new String[]{attr,group.getKey()},group.getValue())) {
            return true;
          }
        }
 else {
          if (extCheckExclude(new String[]{attr},group.getValue())) {
            return true;
          }
        }
      }
    }
  }
  if (extProps != null && extProps.length != 0) {
    for (    final String[] propList : extProps) {
      int propListIndex=propList.length - 1;
      final String propName=propList[propListIndex];
      String propValue=atts.getValue(propName);
      while (propValue == null && propListIndex > 0) {
        propListIndex--;
        propValue=getLabelValue(propName,atts.getValue(propList[propListIndex]));
      }
      if (propValue != null && extCheckExclude(propList,Arrays.asList(propValue.split(""String_Node_Str"")))) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Check if the given Attributes need to be excluded.
 * @param atts attributes
 * @param extProps {@code props} attribute specializations
 * @return true if any one of attributes 'audience', 'platform', 'product','otherprops', 'props', or 'print' was excluded.
 */
public boolean needExclude(final Attributes atts,final String[][] extProps){
  if (filterMap.isEmpty()) {
    return false;
  }
  for (  final String attr : PROFILE_ATTRIBUTES) {
    final String value=atts.getValue(attr);
    if (value != null) {
      final Map<String,List<String>> groups=getGroups(value);
      for (      Map.Entry<String,List<String>> group : groups.entrySet()) {
        if (group.getKey() != null) {
          if (extCheckExclude(new String[]{attr,group.getKey()},group.getValue())) {
            return true;
          }
        }
 else {
          if (extCheckExclude(new String[]{attr},group.getValue())) {
            return true;
          }
        }
      }
    }
  }
  if (extProps != null && extProps.length != 0) {
    for (    final String[] propList : extProps) {
      int propListIndex=propList.length - 1;
      final String propName=propList[propListIndex];
      String propValue=atts.getValue(propName);
      while (propValue == null && propListIndex > 0) {
        propListIndex--;
        propValue=getLabelValue(propName,atts.getValue(propList[propListIndex]));
      }
      if (propValue != null && extCheckExclude(propList,Arrays.asList(propValue.split(""String_Node_Str"")))) {
        return true;
      }
    }
  }
  return false;
}",0.9932885906040269
100713,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((attribute == null) ? 0 : attribute.hashCode());
  result=prime * result + ((value == null) ? 0 : value.hashCode());
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + (attribute.hashCode());
  result=prime * result + ((value == null) ? 0 : value.hashCode());
  return result;
}",0.9409090909090908
100714,"/** 
 * Refine action key with information from subject schemes.
 */
private void refineAction(final Action action,final FilterKey key,final Map<String,Map<String,Set<Element>>> bindingMap,final Map<FilterKey,Action> destFilterMap){
  if (key.attribute != null && key.value != null) {
    final Map<String,Set<Element>> schemeMap=bindingMap.get(key.attribute);
    if (schemeMap != null && !schemeMap.isEmpty()) {
      for (      final Set<Element> submap : schemeMap.values()) {
        for (        final Element e : submap) {
          final Element subRoot=searchForKey(e,key.value);
          if (subRoot != null) {
            insertAction(subRoot,key.attribute,action,destFilterMap);
          }
        }
      }
    }
  }
}","/** 
 * Refine action key with information from subject schemes.
 */
private void refineAction(final Action action,final FilterKey key,final Map<String,Map<String,Set<Element>>> bindingMap,final Map<FilterKey,Action> destFilterMap){
  if (key.value != null) {
    final Map<String,Set<Element>> schemeMap=bindingMap.get(key.attribute);
    if (schemeMap != null && !schemeMap.isEmpty()) {
      for (      final Set<Element> submap : schemeMap.values()) {
        for (        final Element e : submap) {
          final Element subRoot=searchForKey(e,key.value);
          if (subRoot != null) {
            insertAction(subRoot,key.attribute,action,destFilterMap);
          }
        }
      }
    }
  }
}",0.4482997918112422
100715,"@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (!(obj instanceof FilterKey)) {
    final Throwable t=new RuntimeException(""String_Node_Str"");
    t.printStackTrace();
    return false;
  }
  final FilterKey other=(FilterKey)obj;
  if (attribute == null) {
    if (other.attribute != null) {
      return false;
    }
  }
 else   if (!attribute.equals(other.attribute)) {
    return false;
  }
  if (value == null) {
    if (other.value != null) {
      return false;
    }
  }
 else   if (!value.equals(other.value)) {
    return false;
  }
  return true;
}","@Override public boolean equals(final Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (!(obj instanceof FilterKey)) {
    final Throwable t=new RuntimeException(""String_Node_Str"");
    t.printStackTrace();
    return false;
  }
  final FilterKey other=(FilterKey)obj;
  if (!attribute.equals(other.attribute)) {
    return false;
  }
  if (value == null) {
    if (other.value != null) {
      return false;
    }
  }
 else   if (!value.equals(other.value)) {
    return false;
  }
  return true;
}",0.9186046511627908
100716,"public Map<String,List<String>> getGroups(final String value){
  final Map<String,List<String>> res=new HashMap<String,List<String>>();
  final StringBuilder buf=new StringBuilder();
  int previousEnd=0;
  final Matcher m=groupPattern.matcher(value);
  if (m != null) {
    while (m.find()) {
      buf.append(value.subSequence(previousEnd,m.start()));
      final String v=m.group(2);
      if (!v.trim().isEmpty()) {
        final String k=m.group(1);
        if (res.containsKey(k)) {
          final List<String> l=new ArrayList<String>(res.get(k));
          l.addAll(Arrays.asList(v.trim().split(""String_Node_Str"")));
          res.put(k,l);
        }
 else {
          res.put(k,Arrays.asList(v.trim().split(""String_Node_Str"")));
        }
      }
      previousEnd=m.end();
    }
    buf.append(value.substring(previousEnd));
    if (!buf.toString().trim().isEmpty()) {
      res.put(null,Arrays.asList(buf.toString().trim().split(""String_Node_Str"")));
    }
  }
 else {
    res.put(null,Arrays.asList(value.trim().split(""String_Node_Str"")));
  }
  return res;
}","public Map<String,List<String>> getGroups(final String value){
  final Map<String,List<String>> res=new HashMap<String,List<String>>();
  final StringBuilder buf=new StringBuilder();
  int previousEnd=0;
  final Matcher m=groupPattern.matcher(value);
  while (m.find()) {
    buf.append(value.subSequence(previousEnd,m.start()));
    final String v=m.group(2);
    if (!v.trim().isEmpty()) {
      final String k=m.group(1);
      if (res.containsKey(k)) {
        final List<String> l=new ArrayList<String>(res.get(k));
        l.addAll(Arrays.asList(v.trim().split(""String_Node_Str"")));
        res.put(k,l);
      }
 else {
        res.put(k,Arrays.asList(v.trim().split(""String_Node_Str"")));
      }
    }
    previousEnd=m.end();
  }
  buf.append(value.substring(previousEnd));
  if (!buf.toString().trim().isEmpty()) {
    res.put(null,Arrays.asList(buf.toString().trim().split(""String_Node_Str"")));
  }
  return res;
}",0.9152882205513784
100717,"/** 
 * Normalize and validate href attribute.
 * @param attName attribute name
 * @param atts attributes
 * @return attribute value
 */
private URI replaceHREF(final String attName,final Attributes atts){
  if (attName == null) {
    return null;
  }
  URI attValue=toURI(atts.getValue(attName));
  if (attValue != null) {
    final String fragment=attValue.getFragment();
    if (fragment != null) {
      URI path=stripFragment(attValue);
      if (path.toString().length() != 0) {
        final File target=toFile(path);
        if (target.isAbsolute()) {
          final URI relativePath=getRelativePath(job.getInputFile().toURI(),path);
          attValue=setFragment(relativePath,fragment);
        }
      }
    }
 else {
      final File target=toFile(attValue);
      if (target.isAbsolute()) {
        attValue=getRelativePath(job.getInputFile().toURI(),attValue);
      }
    }
  }
 else {
    return null;
  }
  return attValue;
}","/** 
 * Normalize and validate href attribute.
 * @param attName attribute name
 * @param atts attributes
 * @return attribute value, may be {@code null}
 */
private URI replaceHREF(final String attName,final Attributes atts){
  URI attValue=toURI(atts.getValue(attName));
  if (attValue != null) {
    final String fragment=attValue.getFragment();
    if (fragment != null) {
      URI path=stripFragment(attValue);
      if (path.toString().length() != 0) {
        final File target=toFile(path);
        if (target.isAbsolute()) {
          final URI relativePath=getRelativePath(job.getInputFile().toURI(),path);
          attValue=setFragment(relativePath,fragment);
        }
      }
    }
 else {
      final File target=toFile(attValue);
      if (target.isAbsolute()) {
        attValue=getRelativePath(job.getInputFile().toURI(),attValue);
      }
    }
  }
 else {
    return null;
  }
  return attValue;
}",0.9639978506179472
100718,"/** 
 * Write output
 * @param baseDir absolute base directory path
 * @param inFile relative file path
 */
public void write(final File baseDir,final File inFile){
  inputFile=inFile;
  OutputStream out=null;
  try {
    currentFile=new File(baseDir,inputFile.getPath());
    outputFile=new File(tempDir,inputFile.getPath());
    final File outputDir=outputFile.getParentFile();
    if (!outputDir.exists()) {
      outputDir.mkdirs();
    }
    out=new FileOutputStream(outputFile);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(currentFile.getAbsolutePath(),logger));
    final InputSource is=new InputSource(currentFile.toURI().toString());
    if (setSystemid) {
      is.setSystemId(currentFile.toURI().toString());
    }
    final TransformerFactory tf=TransformerFactory.newInstance();
    final Transformer serializer=tf.newTransformer();
    XMLReader xmlSource=reader;
    for (    final XMLFilter f : getProcessingPipe(currentFile,inFile)) {
      f.setParent(xmlSource);
      xmlSource=f;
    }
    xmlSource.setContentHandler(null);
    final Source source=new SAXSource(xmlSource,is);
    final Result result=new StreamResult(out);
    serializer.transform(source,result);
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    e.printStackTrace();
    logger.error(e.getMessage(),e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final Exception e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}","/** 
 * Write output
 * @param baseDir absolute base directory path
 * @param inFile relative file path
 */
public void write(final File baseDir,final File inFile){
  inputFile=inFile;
  OutputStream out=null;
  try {
    currentFile=new File(baseDir,inFile.getPath());
    outputFile=new File(tempDir,inFile.getPath());
    final File outputDir=outputFile.getParentFile();
    if (!outputDir.exists()) {
      outputDir.mkdirs();
    }
    out=new FileOutputStream(outputFile);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(currentFile.getAbsolutePath(),logger));
    final InputSource is=new InputSource(currentFile.toURI().toString());
    if (setSystemid) {
      is.setSystemId(currentFile.toURI().toString());
    }
    final TransformerFactory tf=TransformerFactory.newInstance();
    final Transformer serializer=tf.newTransformer();
    XMLReader xmlSource=reader;
    for (    final XMLFilter f : getProcessingPipe(currentFile,inFile)) {
      f.setParent(xmlSource);
      xmlSource=f;
    }
    xmlSource.setContentHandler(null);
    final Source source=new SAXSource(xmlSource,is);
    final Result result=new StreamResult(out);
    serializer.transform(source,result);
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    e.printStackTrace();
    logger.error(e.getMessage(),e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final Exception e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}",0.9980211081794196
100719,"@Test public void testReplaceConref() throws Exception {
  final Invoker w=new Invoker(""String_Node_Str"",ATTRIBUTE_NAME_CONREF,Attributes.class){
    @Override public String invoke(    final String value) throws Exception {
      final AttributesImpl atts=new AttributesImpl();
      XMLUtils.addOrSetAttribute(atts,attrName,value);
      return ((URI)method.invoke(writer,atts)).toString();
    }
  }
;
  assertEquals(""String_Node_Str"",w.invoke(""String_Node_Str""));
  assertEquals(""String_Node_Str"",w.invoke(""String_Node_Str""));
  assertEquals(""String_Node_Str"",w.invoke(new File(srcDir,""String_Node_Str"").getAbsoluteFile().toURI().toString()));
  assertEquals(""String_Node_Str"",w.invoke(new File(srcDir,""String_Node_Str"").getAbsoluteFile().toURI().toString() + ""String_Node_Str""));
  final File sub=new File(srcDir,""String_Node_Str"" + File.separator + ""String_Node_Str"").getAbsoluteFile();
  assertEquals(""String_Node_Str"",w.invoke(sub.toURI().toString()));
  assertEquals(""String_Node_Str"",w.invoke(sub.toURI().toString() + ""String_Node_Str""));
  assertEquals(""String_Node_Str"",w.invoke(sub.getAbsoluteFile().toURI().toString()));
  assertEquals(""String_Node_Str"",w.invoke(sub.getAbsoluteFile().toURI().toString() + ""String_Node_Str""));
  assertEquals(""String_Node_Str"",w.invoke(""String_Node_Str""));
}","@Test public void testReplaceConref() throws Exception {
  final Invoker w=new Invoker(""String_Node_Str"",ATTRIBUTE_NAME_CONREF,String.class,Attributes.class){
    @Override public String invoke(    final String value) throws Exception {
      final AttributesImpl atts=new AttributesImpl();
      XMLUtils.addOrSetAttribute(atts,attrName,value);
      return ((URI)method.invoke(writer,ATTRIBUTE_NAME_CONREF,atts)).toString();
    }
  }
;
  assertEquals(""String_Node_Str"",w.invoke(""String_Node_Str""));
  assertEquals(""String_Node_Str"",w.invoke(""String_Node_Str""));
  assertEquals(""String_Node_Str"",w.invoke(new File(srcDir,""String_Node_Str"").getAbsoluteFile().toURI().toString()));
  assertEquals(""String_Node_Str"",w.invoke(new File(srcDir,""String_Node_Str"").getAbsoluteFile().toURI().toString() + ""String_Node_Str""));
  final File sub=new File(srcDir,""String_Node_Str"" + File.separator + ""String_Node_Str"").getAbsoluteFile();
  assertEquals(""String_Node_Str"",w.invoke(sub.toURI().toString()));
  assertEquals(""String_Node_Str"",w.invoke(sub.toURI().toString() + ""String_Node_Str""));
  assertEquals(""String_Node_Str"",w.invoke(sub.getAbsoluteFile().toURI().toString()));
  assertEquals(""String_Node_Str"",w.invoke(sub.getAbsoluteFile().toURI().toString() + ""String_Node_Str""));
  assertEquals(""String_Node_Str"",w.invoke(""String_Node_Str""));
}",0.9867574725690504
100720,"/** 
 * Parse the input attributes for needed information.
 * @param atts all attributes
 * @param attrName attributes to process
 */
private void parseAttribute(final Attributes atts,final String attrName) throws SAXException {
  String attrValue=atts.getValue(attrName);
  final String attrClass=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  String attrFormat=atts.getValue(ATTRIBUTE_NAME_FORMAT);
  final String attrType=atts.getValue(ATTRIBUTE_NAME_TYPE);
  final String codebase=atts.getValue(ATTRIBUTE_NAME_CODEBASE);
  if (attrValue == null) {
    return;
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) || ATTRIBUTE_NAME_CONKEYREF.equals(attrName)) {
    hasConRef=true;
  }
 else   if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
    if (attrClass != null && PR_D_CODEREF.matches(attrClass)) {
      hasCodeRef=true;
    }
 else {
      hasHref=true;
    }
  }
 else   if (ATTRIBUTE_NAME_KEYREF.equals(attrName)) {
    hasKeyRef=true;
  }
  if (ATTR_SCOPE_VALUE_EXTERNAL.equals(attrScope) || ATTR_SCOPE_VALUE_PEER.equals(attrScope) || attrValue.contains(COLON_DOUBLE_SLASH)|| attrValue.startsWith(SHARP)) {
    return;
  }
  final URI target=toURI(attrValue);
  String filename=null;
  if (isAbsolute(target) && !ATTRIBUTE_NAME_DATA.equals(attrName)) {
    filename=getRelativeUnixPath(rootFilePath.getAbsoluteFile().toURI().getPath(),target.getPath());
  }
 else   if (ATTRIBUTE_NAME_DATA.equals(attrName)) {
    if (!isEmptyString(codebase)) {
      filename=resolve(codebase,attrValue).getPath();
    }
 else {
      filename=resolve(currentDir,attrValue).getPath();
    }
  }
 else {
    filename=resolve(currentDir,attrValue).getPath();
  }
  filename=toFile(filename).getPath();
  if (MAP_TOPICREF.matches(attrClass)) {
    if (ATTR_TYPE_VALUE_SUBJECT_SCHEME.equalsIgnoreCase(attrType)) {
      schemeSet.add(new File(filename));
    }
  }
 else   if (TOPIC_IMAGE.matches(attrClass)) {
    if (attrFormat == null) {
      attrFormat=""String_Node_Str"";
    }
  }
  if ((""String_Node_Str"".equals(attrType) && ATTRIBUTE_NAME_DATA.equals(attrName)) || attrClass != null && PR_D_CODEREF.matches(attrClass)) {
    subsidiarySet.add(new File(filename));
    return;
  }
  if ((ATTRIBUTE_NAME_HREF.equals(attrName) || ATTRIBUTE_NAME_DATA.equals(attrName)) && (atts.getValue(ATTRIBUTE_NAME_COPY_TO) == null || (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) && (canResolved() || isSupportedImageFile(filename.toLowerCase()))) {
    nonConrefCopytoTargets.add(new Reference(filename,attrFormat));
  }
  if (attrFormat != null && !ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {
    return;
  }
  if (ATTRIBUTE_NAME_HREF.equals(attrName) && isFormatDita(attrFormat) && canResolved()) {
    hrefTargets.add(new File(filename));
    toOutFile(new File(filename));
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0 && relTableLevel == 0) {
      chunkTopicSet.add(new File(filename));
    }
 else {
      hrefTopicSet.add(new File(filename));
    }
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName)) {
    conrefTargets.add(new File(filename));
    toOutFile(new File(filename));
  }
  if (ATTRIBUTE_NAME_COPY_TO.equals(attrName) && isFormatDita(attrFormat)) {
    final URI href=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
    if (href != null) {
      final File value=resolve(currentDir,toFile(href).getPath());
      if (href.toString().isEmpty()) {
        logger.warn(""String_Node_Str"" + filename + ""String_Node_Str"");
      }
 else       if (copytoMap.get(new File(filename)) != null) {
        if (!value.equals(copytoMap.get(new File(filename)))) {
          logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",href.toString(),filename).toString());
        }
        ignoredCopytoSourceSet.add(toFile(href));
      }
 else       if (!(atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) {
        copytoMap.put(new File(filename),value);
      }
    }
    final File pathWithoutID=resolve(currentDir,toFile(attrValue).getPath());
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0) {
      chunkTopicSet.add(pathWithoutID);
    }
 else {
      hrefTopicSet.add(pathWithoutID);
    }
  }
  if (ATTRIBUTE_NAME_CONACTION.equals(attrName)) {
    if (attrValue.equals(""String_Node_Str"") || attrValue.equals(""String_Node_Str"")) {
      hasconaction=true;
    }
  }
}","/** 
 * Parse the input attributes for needed information.
 * @param atts all attributes
 * @param attrName attributes to process
 */
private void parseAttribute(final Attributes atts,final String attrName) throws SAXException {
  String attrValue=atts.getValue(attrName);
  final String attrClass=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  String attrFormat=atts.getValue(ATTRIBUTE_NAME_FORMAT);
  final String attrType=atts.getValue(ATTRIBUTE_NAME_TYPE);
  final String codebase=atts.getValue(ATTRIBUTE_NAME_CODEBASE);
  if (attrValue == null) {
    return;
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) || ATTRIBUTE_NAME_CONKEYREF.equals(attrName)) {
    hasConRef=true;
  }
 else   if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
    if (PR_D_CODEREF.matches(attrClass)) {
      hasCodeRef=true;
    }
 else {
      hasHref=true;
    }
  }
 else   if (ATTRIBUTE_NAME_KEYREF.equals(attrName)) {
    hasKeyRef=true;
  }
  if (ATTR_SCOPE_VALUE_EXTERNAL.equals(attrScope) || ATTR_SCOPE_VALUE_PEER.equals(attrScope) || attrValue.contains(COLON_DOUBLE_SLASH)|| attrValue.startsWith(SHARP)) {
    return;
  }
  final URI target=toURI(attrValue);
  String filename=null;
  if (isAbsolute(target) && !ATTRIBUTE_NAME_DATA.equals(attrName)) {
    filename=getRelativeUnixPath(rootFilePath.getAbsoluteFile().toURI().getPath(),target.getPath());
  }
 else   if (ATTRIBUTE_NAME_DATA.equals(attrName)) {
    if (!isEmptyString(codebase)) {
      filename=resolve(codebase,attrValue).getPath();
    }
 else {
      filename=resolve(currentDir,attrValue).getPath();
    }
  }
 else {
    filename=resolve(currentDir,attrValue).getPath();
  }
  filename=toFile(filename).getPath();
  if (MAP_TOPICREF.matches(attrClass)) {
    if (ATTR_TYPE_VALUE_SUBJECT_SCHEME.equalsIgnoreCase(attrType)) {
      schemeSet.add(new File(filename));
    }
  }
 else   if (TOPIC_IMAGE.matches(attrClass)) {
    if (attrFormat == null) {
      attrFormat=""String_Node_Str"";
    }
  }
  if ((""String_Node_Str"".equals(attrType) && ATTRIBUTE_NAME_DATA.equals(attrName)) || PR_D_CODEREF.matches(attrClass)) {
    subsidiarySet.add(new File(filename));
    return;
  }
  if ((ATTRIBUTE_NAME_HREF.equals(attrName) || ATTRIBUTE_NAME_DATA.equals(attrName)) && (atts.getValue(ATTRIBUTE_NAME_COPY_TO) == null || (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) && (canResolved() || isSupportedImageFile(filename.toLowerCase()))) {
    nonConrefCopytoTargets.add(new Reference(filename,attrFormat));
  }
  if (attrFormat != null && !ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {
    return;
  }
  if (ATTRIBUTE_NAME_HREF.equals(attrName) && isFormatDita(attrFormat) && canResolved()) {
    hrefTargets.add(new File(filename));
    toOutFile(new File(filename));
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0 && relTableLevel == 0) {
      chunkTopicSet.add(new File(filename));
    }
 else {
      hrefTopicSet.add(new File(filename));
    }
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName)) {
    conrefTargets.add(new File(filename));
    toOutFile(new File(filename));
  }
  if (ATTRIBUTE_NAME_COPY_TO.equals(attrName) && isFormatDita(attrFormat)) {
    final URI href=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
    if (href != null) {
      final File value=resolve(currentDir,toFile(href).getPath());
      if (href.toString().isEmpty()) {
        logger.warn(""String_Node_Str"" + filename + ""String_Node_Str"");
      }
 else       if (copytoMap.get(new File(filename)) != null) {
        if (!value.equals(copytoMap.get(new File(filename)))) {
          logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",href.toString(),filename).toString());
        }
        ignoredCopytoSourceSet.add(toFile(href));
      }
 else       if (!(atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) {
        copytoMap.put(new File(filename),value);
      }
    }
    final File pathWithoutID=resolve(currentDir,toFile(attrValue).getPath());
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0) {
      chunkTopicSet.add(pathWithoutID);
    }
 else {
      hrefTopicSet.add(pathWithoutID);
    }
  }
  if (ATTRIBUTE_NAME_CONACTION.equals(attrName)) {
    if (attrValue.equals(""String_Node_Str"") || attrValue.equals(""String_Node_Str"")) {
      hasconaction=true;
    }
  }
}",0.9953135460834636
100721,"/** 
 * Normalize and validate href attribute.
 * @param attName attribute name
 * @param atts attributes
 * @return attribute value, may be {@code null}
 */
private URI replaceHREF(final String attName,final Attributes atts){
  URI attValue=toURI(atts.getValue(attName));
  if (attValue != null) {
    final String fragment=attValue.getFragment();
    if (fragment != null) {
      final URI path=stripFragment(attValue);
      if (path.toString().length() != 0) {
        final File target=toFile(path);
        if (target.isAbsolute()) {
          final URI relativePath=getRelativePath(job.getInputFile().toURI(),path);
          attValue=setFragment(relativePath,fragment);
        }
      }
    }
 else {
      final File target=toFile(attValue);
      if (target.isAbsolute()) {
        attValue=getRelativePath(job.getInputFile().toURI(),attValue);
      }
    }
  }
 else {
    return null;
  }
  return attValue;
}","/** 
 * Relativize absolute references if possible.
 * @param attName attribute name
 * @param atts attributes
 * @return attribute value, may be {@code null}
 */
private URI replaceHREF(final String attName,final Attributes atts){
  URI attValue=toURI(atts.getValue(attName));
  if (attValue != null) {
    final String fragment=attValue.getFragment();
    if (fragment != null) {
      attValue=stripFragment(attValue);
    }
    if (attValue.toString().length() != 0) {
      final URI current=currentFile.toURI().resolve(attValue);
      attValue=getRelativePath(currentFile.toURI(),current);
    }
    if (fragment != null) {
      attValue=setFragment(attValue,fragment);
    }
  }
 else {
    return null;
  }
  return attValue;
}",0.6128838049367851
100722,"/** 
 * Process attributes
 * @param qName element name
 * @param atts input attributes
 * @param res attributes to write to
 * @throws java.io.IOException if writing to output failed
 */
private void processAttributes(final String qName,final Attributes atts,final AttributesImpl res){
  final int attsLen=atts.getLength();
  for (int i=0; i < attsLen; i++) {
    final String attQName=atts.getQName(i);
    String attValue=getAttributeValue(qName,attQName,atts.getValue(i));
    if (ATTRIBUTE_NAME_CONREF.equals(attQName)) {
      XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_CONREF,replaceHREF(ATTRIBUTE_NAME_CONREF,atts).toString());
    }
 else     if (ATTRIBUTE_NAME_HREF.equals(attQName) || ATTRIBUTE_NAME_COPY_TO.equals(attQName)) {
      if (atts.getValue(ATTRIBUTE_NAME_SCOPE) == null || atts.getValue(ATTRIBUTE_NAME_SCOPE).equals(ATTR_SCOPE_VALUE_LOCAL)) {
        attValue=replaceHREF(attQName,atts).toString();
      }
      XMLUtils.addOrSetAttribute(res,attQName,attValue);
    }
 else {
      XMLUtils.addOrSetAttribute(res,atts.getURI(i),atts.getLocalName(i),attQName,atts.getType(i),attValue);
    }
  }
}","/** 
 * Process attributes
 * @param qName element name
 * @param atts input attributes
 * @param res attributes to write to
 * @throws java.io.IOException if writing to output failed
 */
private void processAttributes(final String qName,final Attributes atts,final AttributesImpl res){
  final int attsLen=atts.getLength();
  for (int i=0; i < attsLen; i++) {
    final String attQName=atts.getQName(i);
    String attValue=getAttributeValue(qName,attQName,atts.getValue(i));
    if (ATTRIBUTE_NAME_CONREF.equals(attQName)) {
      attValue=replaceHREF(ATTRIBUTE_NAME_CONREF,atts).toString();
    }
 else     if (ATTRIBUTE_NAME_HREF.equals(attQName) || ATTRIBUTE_NAME_COPY_TO.equals(attQName)) {
      if (atts.getValue(ATTRIBUTE_NAME_SCOPE) == null || atts.getValue(ATTRIBUTE_NAME_SCOPE).equals(ATTR_SCOPE_VALUE_LOCAL)) {
        attValue=replaceHREF(attQName,atts).toString();
      }
    }
    XMLUtils.addOrSetAttribute(res,atts.getURI(i),atts.getLocalName(i),attQName,atts.getType(i),attValue);
  }
}",0.5446009389671361
100723,"/** 
 * Create new URI with a given fragment.
 * @param path URI to set fragment on
 * @param fragment new fragment, {@code null} for no fragment
 * @return new URI instance with given fragment 
 */
public static URI setFragment(final URI path,final String fragment){
  try {
    return new URI(path.getScheme(),path.getUserInfo(),path.getHost(),path.getPort(),path.getPath(),path.getQuery(),fragment);
  }
 catch (  final URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
}","/** 
 * Create new URI with a given fragment.
 * @param path URI to set fragment on
 * @param fragment new fragment, {@code null} for no fragment
 * @return new URI instance with given fragment 
 */
public static URI setFragment(final URI path,final String fragment){
  try {
    if (path.getPath() != null) {
      return new URI(path.getScheme(),path.getUserInfo(),path.getHost(),path.getPort(),path.getPath(),path.getQuery(),fragment);
    }
 else {
      return new URI(path.getScheme(),path.getSchemeSpecificPart(),fragment);
    }
  }
 catch (  final URISyntaxException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
}",0.8822495606326889
100724,"@Test public void testSetFragment() throws URISyntaxException {
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
}","@Test public void testSetFragment() throws URISyntaxException {
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),""String_Node_Str""));
  assertEquals(new URI(""String_Node_Str""),URLUtils.setFragment(new URI(""String_Node_Str""),null));
}",0.7418690819267189
100725,"/** 
 * Get pipe line filters
 * @param fileToParse absolute path to current file being processed
 * @param inFile relative file path
 */
private List<XMLFilter> getProcessingPipe(final File fileToParse,final File inFile){
  final List<XMLFilter> pipe=new ArrayList<XMLFilter>();
  if (genDebugInfo) {
    final DebugFilter debugFilter=new DebugFilter();
    debugFilter.setLogger(logger);
    debugFilter.setInputFile(fileToParse);
    pipe.add(debugFilter);
  }
  if (filterUtils != null) {
    final ProfilingFilter profilingFilter=new ProfilingFilter();
    profilingFilter.setLogger(logger);
    profilingFilter.setFilterUtils(filterUtils);
    pipe.add(profilingFilter);
  }
{
    final ValidationFilter validationFilter=new ValidationFilter();
    validationFilter.setLogger(logger);
    validationFilter.setValidateMap(validateMap);
    pipe.add(validationFilter);
  }
{
    final NormalizeFilter normalizeFilter=new NormalizeFilter();
    normalizeFilter.setLogger(logger);
    normalizeFilter.setCurrentFile(inFile);
    normalizeFilter.setJob(job);
    pipe.add(normalizeFilter);
  }
{
    final ConkeyrefFilter conkeyrefFilter=new ConkeyrefFilter();
    conkeyrefFilter.setLogger(logger);
    conkeyrefFilter.setKeyDefinitions(keys.values());
    conkeyrefFilter.setTempDir(job.tempDir);
    conkeyrefFilter.setCurrentFile(inFile);
    conkeyrefFilter.setDelayConrefUtils(delayConrefUtils);
    pipe.add(conkeyrefFilter);
  }
{
    pipe.add(this);
  }
  return pipe;
}","/** 
 * Get pipe line filters
 * @param fileToParse absolute path to current file being processed
 * @param inFile relative file path
 */
private List<XMLFilter> getProcessingPipe(final File fileToParse,final File inFile){
  final List<XMLFilter> pipe=new ArrayList<XMLFilter>();
  if (genDebugInfo) {
    final DebugFilter debugFilter=new DebugFilter();
    debugFilter.setLogger(logger);
    debugFilter.setInputFile(fileToParse);
    pipe.add(debugFilter);
  }
  if (filterUtils != null) {
    final ProfilingFilter profilingFilter=new ProfilingFilter();
    profilingFilter.setLogger(logger);
    profilingFilter.setFilterUtils(filterUtils);
    pipe.add(profilingFilter);
  }
{
    final ValidationFilter validationFilter=new ValidationFilter();
    validationFilter.setLogger(logger);
    validationFilter.setValidateMap(validateMap);
    validationFilter.setCurrentFile(toURI(inFile));
    validationFilter.setJob(job);
    pipe.add(validationFilter);
  }
{
    final NormalizeFilter normalizeFilter=new NormalizeFilter();
    normalizeFilter.setLogger(logger);
    pipe.add(normalizeFilter);
  }
{
    final ConkeyrefFilter conkeyrefFilter=new ConkeyrefFilter();
    conkeyrefFilter.setLogger(logger);
    conkeyrefFilter.setKeyDefinitions(keys.values());
    conkeyrefFilter.setTempDir(job.tempDir);
    conkeyrefFilter.setCurrentFile(inFile);
    conkeyrefFilter.setDelayConrefUtils(delayConrefUtils);
    pipe.add(conkeyrefFilter);
  }
{
    pipe.add(this);
  }
  return pipe;
}",0.8851465139777703
100726,"/** 
 * Sets the grammar pool on the parser. Note that this is a Xerces-specific feature.
 * @param reader
 * @param grammarPool
 */
public void setGrammarPool(final XMLReader reader){
  try {
    reader.setProperty(""String_Node_Str"",GrammarPoolManager.getGrammarPool());
    logger.info(""String_Node_Str"");
  }
 catch (  final NoClassDefFoundError e) {
    logger.debug(""String_Node_Str"");
  }
catch (  final SAXNotRecognizedException e) {
    e.printStackTrace();
    logger.warn(""String_Node_Str"" + e.getMessage());
  }
catch (  final SAXNotSupportedException e) {
    e.printStackTrace();
    logger.warn(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Sets the grammar pool on the parser. Note that this is a Xerces-specific feature.
 * @param reader
 */
public void setGrammarPool(final XMLReader reader){
  try {
    reader.setProperty(""String_Node_Str"",GrammarPoolManager.getGrammarPool());
    logger.info(""String_Node_Str"");
  }
 catch (  final NoClassDefFoundError e) {
    logger.debug(""String_Node_Str"");
  }
catch (  final SAXNotRecognizedException e) {
    e.printStackTrace();
    logger.warn(""String_Node_Str"" + e.getMessage());
  }
catch (  final SAXNotSupportedException e) {
    e.printStackTrace();
    logger.warn(""String_Node_Str"" + e.getMessage());
  }
}",0.9828125
100727,"/** 
 * Write output
 * @param baseDir absolute base directory path
 * @param inFile relative file path
 */
public void write(final File baseDir,final File inFile){
  inputFile=inFile;
  OutputStream out=null;
  try {
    currentFile=new File(baseDir,inputFile.getPath());
    outputFile=new File(tempDir,inputFile.getPath());
    final File outputDir=outputFile.getParentFile();
    if (!outputDir.exists()) {
      outputDir.mkdirs();
    }
    out=new FileOutputStream(outputFile);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(currentFile.getAbsolutePath(),logger));
    final InputSource is=new InputSource(currentFile.toURI().toString());
    if (setSystemid) {
      is.setSystemId(currentFile.toURI().toString());
    }
    final TransformerFactory tf=TransformerFactory.newInstance();
    final Transformer serializer=tf.newTransformer();
    XMLReader xmlSource=reader;
    for (    final XMLFilter f : getProcessingPipe(currentFile,inFile)) {
      f.setParent(xmlSource);
      xmlSource=f;
    }
    xmlSource.setContentHandler(null);
    final Source source=new SAXSource(xmlSource,is);
    final Result result=new StreamResult(out);
    serializer.transform(source,result);
  }
 catch (  final Exception e) {
    e.printStackTrace();
    logger.error(e.getMessage(),e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final Exception e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}","/** 
 * Write output
 * @param baseDir absolute base directory path
 * @param inFile relative file path
 */
public void write(final File baseDir,final File inFile){
  inputFile=inFile;
  OutputStream out=null;
  try {
    currentFile=new File(baseDir,inputFile.getPath());
    outputFile=new File(tempDir,inputFile.getPath());
    final File outputDir=outputFile.getParentFile();
    if (!outputDir.exists()) {
      outputDir.mkdirs();
    }
    out=new FileOutputStream(outputFile);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(currentFile.getAbsolutePath(),logger));
    final InputSource is=new InputSource(currentFile.toURI().toString());
    if (setSystemid) {
      is.setSystemId(currentFile.toURI().toString());
    }
    final TransformerFactory tf=TransformerFactory.newInstance();
    final Transformer serializer=tf.newTransformer();
    XMLReader xmlSource=reader;
    for (    final XMLFilter f : getProcessingPipe(currentFile,inFile)) {
      f.setParent(xmlSource);
      xmlSource=f;
    }
    xmlSource.setContentHandler(null);
    final Source source=new SAXSource(xmlSource,is);
    final Result result=new StreamResult(out);
    serializer.transform(source,result);
  }
 catch (  final RuntimeException e) {
    throw e;
  }
catch (  final Exception e) {
    e.printStackTrace();
    logger.error(e.getMessage(),e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final Exception e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}",0.9819034852546916
100728,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final AttributesImpl res=new AttributesImpl(atts);
  final String cls=atts.getValue(ATTRIBUTE_NAME_CLASS);
  classStack.addFirst(cls);
  if (TOPIC_TGROUP.matches(cls)) {
    if (colSpec != null) {
      colSpecStack.addFirst(colSpec);
      rowNumStack.addFirst(rowNumber);
      columnNumberStack.addFirst(columnNumber);
      columnNumberEndStack.addFirst(columnNumberEnd);
      rowsMapStack.addFirst(rowsMap);
      colSpanMapStack.addFirst(colSpanMap);
    }
    columnNumber=1;
    columnNumberEnd=0;
    rowsMap=new HashMap<String,Integer>();
    colSpanMap=new HashMap<String,Integer>();
    colSpec=new ArrayList<String>(16);
    rowNumber=0;
  }
 else   if (TOPIC_ROW.matches(cls)) {
    columnNumber=1;
    columnNumberEnd=0;
    rowNumber++;
  }
 else   if (TOPIC_COLSPEC.matches(cls)) {
    columnNumber=columnNumberEnd + 1;
    if (atts.getValue(ATTRIBUTE_NAME_COLNAME) != null) {
      colSpec.add(atts.getValue(ATTRIBUTE_NAME_COLNAME));
    }
 else {
      colSpec.add(COLUMN_NAME_COL + columnNumber);
    }
    columnNumberEnd=columnNumber;
    XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_COLNAME,COLUMN_NAME_COL + columnNumber);
    totalColumns=columnNumberEnd;
  }
 else   if (TOPIC_ENTRY.matches(cls)) {
    columnNumber=getStartNumber(atts,columnNumberEnd);
    if (columnNumber > columnNumberEnd) {
      if (rowNumber == 1) {
        XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_COLNAME,COLUMN_NAME_COL + columnNumber);
        if (atts.getValue(ATTRIBUTE_NAME_NAMEST) != null) {
          XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_NAMEST,COLUMN_NAME_COL + columnNumber);
        }
        if (atts.getValue(ATTRIBUTE_NAME_NAMEEND) != null) {
          XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_NAMEEND,COLUMN_NAME_COL + getEndNumber(atts,columnNumber));
        }
      }
 else {
        int offset=0;
        int currentCol=columnNumber;
        while (currentCol <= totalColumns) {
          int previous_offset=offset;
          for (int row=1; row < rowNumber; row++) {
            final String pos=Integer.toString(row) + ""String_Node_Str"" + Integer.toString(currentCol);
            if (rowsMap.containsKey(pos)) {
              final int totalSpanRows=rowsMap.get(pos);
              if (rowNumber <= totalSpanRows) {
                offset+=colSpanMap.get(pos);
              }
            }
          }
          if (offset > previous_offset) {
            currentCol=columnNumber + offset;
            previous_offset=offset;
          }
 else {
            break;
          }
        }
        columnNumber=columnNumber + offset;
        if (atts.getValue(ATTRIBUTE_NAME_MOREROWS) != null) {
          final String pos=Integer.toString(rowNumber) + ""String_Node_Str"" + Integer.toString(columnNumber);
          rowsMap.put(pos,Integer.parseInt(atts.getValue(ATTRIBUTE_NAME_MOREROWS)) + rowNumber);
          colSpanMap.put(pos,getColumnSpan(atts));
        }
        XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_COLNAME,COLUMN_NAME_COL + columnNumber);
        if (atts.getValue(ATTRIBUTE_NAME_NAMEST) != null) {
          XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_NAMEST,COLUMN_NAME_COL + columnNumber);
        }
        if (atts.getValue(ATTRIBUTE_NAME_NAMEEND) != null) {
          XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_NAMEEND,COLUMN_NAME_COL + getEndNumber(atts,columnNumber));
        }
      }
    }
    columnNumberEnd=getEndNumber(atts,columnNumber);
  }
 else   if (MAP_MAP.matches(cls)) {
    if (res.getIndex(ATTRIBUTE_NAME_CASCADE) == -1) {
      XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_CASCADE,configuration.containsKey(""String_Node_Str"") ? configuration.get(""String_Node_Str"") : ATTRIBUTE_CASCADE_VALUE_MERGE);
    }
  }
  if (MAP_TOPICREF.matches(cls)) {
    final String format=res.getValue(ATTRIBUTE_NAME_FORMAT);
    final String scope=res.getValue(ATTRIBUTE_NAME_SCOPE);
    final URI href=toURI(res.getValue(ATTRIBUTE_NAME_HREF));
    if (format == null && (scope == null || scope.equals(ATTR_SCOPE_VALUE_LOCAL)) && href != null) {
      final URI target=toURI(currentFile).resolve(href);
      final Job.FileInfo fi=job.getFileInfo(target);
      if (fi != null && ATTR_FORMAT_VALUE_DITAMAP.equals(fi.format)) {
        XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_FORMAT,fi.format);
      }
    }
  }
  getContentHandler().startElement(uri,localName,qName,res);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final AttributesImpl res=new AttributesImpl(atts);
  final String cls=atts.getValue(ATTRIBUTE_NAME_CLASS);
  classStack.addFirst(cls);
  if (TOPIC_TGROUP.matches(cls)) {
    if (colSpec != null) {
      colSpecStack.addFirst(colSpec);
      rowNumStack.addFirst(rowNumber);
      columnNumberStack.addFirst(columnNumber);
      columnNumberEndStack.addFirst(columnNumberEnd);
      rowsMapStack.addFirst(rowsMap);
      colSpanMapStack.addFirst(colSpanMap);
    }
    columnNumber=1;
    columnNumberEnd=0;
    rowsMap=new HashMap<String,Integer>();
    colSpanMap=new HashMap<String,Integer>();
    colSpec=new ArrayList<String>(16);
    rowNumber=0;
  }
 else   if (TOPIC_ROW.matches(cls)) {
    columnNumber=1;
    columnNumberEnd=0;
    rowNumber++;
  }
 else   if (TOPIC_COLSPEC.matches(cls)) {
    columnNumber=columnNumberEnd + 1;
    if (atts.getValue(ATTRIBUTE_NAME_COLNAME) != null) {
      colSpec.add(atts.getValue(ATTRIBUTE_NAME_COLNAME));
    }
 else {
      colSpec.add(COLUMN_NAME_COL + columnNumber);
    }
    columnNumberEnd=columnNumber;
    XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_COLNAME,COLUMN_NAME_COL + columnNumber);
    totalColumns=columnNumberEnd;
  }
 else   if (TOPIC_ENTRY.matches(cls)) {
    columnNumber=getStartNumber(atts,columnNumberEnd);
    if (columnNumber > columnNumberEnd) {
      if (rowNumber == 1) {
        XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_COLNAME,COLUMN_NAME_COL + columnNumber);
        if (atts.getValue(ATTRIBUTE_NAME_NAMEST) != null) {
          XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_NAMEST,COLUMN_NAME_COL + columnNumber);
        }
        if (atts.getValue(ATTRIBUTE_NAME_NAMEEND) != null) {
          XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_NAMEEND,COLUMN_NAME_COL + getEndNumber(atts,columnNumber));
        }
      }
 else {
        int offset=0;
        int currentCol=columnNumber;
        while (currentCol <= totalColumns) {
          int previous_offset=offset;
          for (int row=1; row < rowNumber; row++) {
            final String pos=Integer.toString(row) + ""String_Node_Str"" + Integer.toString(currentCol);
            if (rowsMap.containsKey(pos)) {
              final int totalSpanRows=rowsMap.get(pos);
              if (rowNumber <= totalSpanRows) {
                offset+=colSpanMap.get(pos);
              }
            }
          }
          if (offset > previous_offset) {
            currentCol=columnNumber + offset;
            previous_offset=offset;
          }
 else {
            break;
          }
        }
        columnNumber=columnNumber + offset;
        if (atts.getValue(ATTRIBUTE_NAME_MOREROWS) != null) {
          final String pos=Integer.toString(rowNumber) + ""String_Node_Str"" + Integer.toString(columnNumber);
          rowsMap.put(pos,Integer.parseInt(atts.getValue(ATTRIBUTE_NAME_MOREROWS)) + rowNumber);
          colSpanMap.put(pos,getColumnSpan(atts));
        }
        XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_COLNAME,COLUMN_NAME_COL + columnNumber);
        if (atts.getValue(ATTRIBUTE_NAME_NAMEST) != null) {
          XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_NAMEST,COLUMN_NAME_COL + columnNumber);
        }
        if (atts.getValue(ATTRIBUTE_NAME_NAMEEND) != null) {
          XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_NAMEEND,COLUMN_NAME_COL + getEndNumber(atts,columnNumber));
        }
      }
    }
    columnNumberEnd=getEndNumber(atts,columnNumber);
  }
 else   if (MAP_MAP.matches(cls)) {
    if (res.getIndex(ATTRIBUTE_NAME_CASCADE) == -1) {
      XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_CASCADE,configuration.containsKey(""String_Node_Str"") ? configuration.get(""String_Node_Str"") : ATTRIBUTE_CASCADE_VALUE_MERGE);
    }
  }
  getContentHandler().startElement(uri,localName,qName,res);
}",0.9298892988929888
100729,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  String d=atts.getValue(ATTRIBUTE_NAME_DOMAINS);
  if (d != null) {
    domains.addFirst(StringUtils.getExtProps(d));
  }
 else {
    domains.addFirst(domains.peekFirst());
  }
  AttributesImpl modified=null;
  modified=validateLang(atts,modified);
  validateId(atts);
  modified=validateHref(atts,modified);
  validateKeys(atts);
  validateKeyscope(atts);
  validateAttributeValues(qName,atts);
  validateAttributeGeneralization(atts);
  getContentHandler().startElement(uri,localName,qName,modified != null ? modified : atts);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  String d=atts.getValue(ATTRIBUTE_NAME_DOMAINS);
  if (d != null) {
    domains.addFirst(StringUtils.getExtProps(d));
  }
 else {
    domains.addFirst(domains.peekFirst());
  }
  AttributesImpl modified=null;
  modified=validateLang(atts,modified);
  validateId(atts);
  modified=validateHref(atts,modified);
  modified=processFormatDitamap(atts,modified);
  validateKeys(atts);
  validateKeyscope(atts);
  validateAttributeValues(qName,atts);
  validateAttributeGeneralization(atts);
  getContentHandler().startElement(uri,localName,qName,modified != null ? modified : atts);
}",0.9654178674351584
100730,"/** 
 * Sort all the subterms iteratively.
 */
public void sortSubTerms(){
  final int subTermNum=subTerms.size();
  if (subTerms != null && subTermNum > 0) {
    Collections.sort(subTerms);
    for (int i=0; i < subTermNum; i++) {
      final IndexTerm subTerm=subTerms.get(i);
      subTerm.sortSubTerms();
    }
  }
}","/** 
 * Sort all the subterms iteratively.
 */
public void sortSubTerms(){
  final int subTermNum=subTerms.size();
  if (subTerms != null && subTermNum > 0) {
    Collections.sort(subTerms);
    for (    final IndexTerm subTerm : subTerms) {
      subTerm.sortSubTerms();
    }
  }
}",0.7064676616915423
100731,"/** 
 * Get Ant executable.
 * @return Ant executable file name
 */
private String getCommandRunner(){
  return (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) != -1) ? ""String_Node_Str"" : ""String_Node_Str"";
}","/** 
 * Get Ant executable.
 * @return Ant executable file name
 */
private String getCommandRunner(){
  return (OS_NAME.toLowerCase().contains(OS_NAME_WINDOWS)) ? ""String_Node_Str"" : ""String_Node_Str"";
}",0.9491525423728814
100732,"/** 
 * Get the current time.
 * @return the current time as a formatted string.
 * @since Ant1.7.1
 */
protected String getTimestamp(){
  final Date date=new Date(System.currentTimeMillis());
  final DateFormat formatter=DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.SHORT);
  final String finishTime=formatter.format(date);
  return finishTime;
}","/** 
 * Get the current time.
 * @return the current time as a formatted string.
 * @since Ant1.7.1
 */
protected String getTimestamp(){
  final Date date=new Date(System.currentTimeMillis());
  final DateFormat formatter=DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.SHORT);
  return formatter.format(date);
}",0.9239766081871345
100733,"/** 
 * Get job configuration from Ant project reference or create new.
 * @param tempDir configuration directory 
 * @param project Ant project
 * @return job configuration
 */
public static Job getJob(final File tempDir,final Project project){
  Job job=(Job)project.getReference(ANT_REFERENCE_JOB);
  if (job != null && job.isStale(tempDir)) {
    project.log(""String_Node_Str"",Project.MSG_VERBOSE);
    job=null;
  }
  if (job == null) {
    try {
      job=new Job(tempDir);
    }
 catch (    final IOException ioe) {
      throw new BuildException(ioe);
    }
    project.addReference(ANT_REFERENCE_JOB,job);
  }
  return job;
}","/** 
 * Get job configuration from Ant project reference or create new.
 * @param tempDir configuration directory 
 * @param project Ant project
 * @return job configuration
 */
public static Job getJob(final File tempDir,final Project project){
  Job job=project.getReference(ANT_REFERENCE_JOB);
  if (job != null && job.isStale(tempDir)) {
    project.log(""String_Node_Str"",Project.MSG_VERBOSE);
    job=null;
  }
  if (job == null) {
    try {
      job=new Job(tempDir);
    }
 catch (    final IOException ioe) {
      throw new BuildException(ioe);
    }
    project.addReference(ANT_REFERENCE_JOB,job);
  }
  return job;
}",0.9960411718131432
100734,"public void setIncludesfile(final File includesfile) throws IOException {
  final IncludesFile i=new IncludesFile();
  i.setName(includesfile);
  includes.add(i);
}","public void setIncludesfile(final File includesfile){
  final IncludesFile i=new IncludesFile();
  i.setName(includesfile);
  includes.add(i);
}",0.935064935064935
100735,"public void setExcludesfile(final File excludesfile) throws IOException {
  final IncludesFile i=new IncludesFile();
  i.setName(excludesfile);
  excludes.add(i);
}","public void setExcludesfile(final File excludesfile){
  final IncludesFile i=new IncludesFile();
  i.setName(excludesfile);
  excludes.add(i);
}",0.935064935064935
100736,"/** 
 * Writes a formatted list of target names to <code>System.out</code> with an optional description.
 * @param project the project instance.
 * @param names The names to be printed. Must not be <code>null</code>.
 * @param descriptions The associated target descriptions. May be<code>null</code>, in which case no descriptions are displayed. If non-<code>null</code>, this should have as many elements as <code>names</code>.
 * @param topDependencies The list of dependencies for each target. Thedependencies are listed as a non null enumeration of String.
 * @param heading The heading to display. Should not be <code>null</code>.
 * @param maxlen The maximum length of the names of the targets. Ifdescriptions are given, they are padded to this position so they line up (so long as the names really <i>are</i> shorter than this).
 */
private static void printTargets(final Project project,final Vector<String> names,final Vector<String> descriptions,final Vector<Enumeration<String>> dependencies,final String heading,final int maxlen){
  final String lSep=System.getProperty(""String_Node_Str"");
  String spaces=""String_Node_Str"";
  while (spaces.length() <= maxlen) {
    spaces+=spaces;
  }
  final StringBuffer msg=new StringBuffer();
  msg.append(heading + lSep + lSep);
  final int size=names.size();
  for (int i=0; i < size; i++) {
    msg.append(""String_Node_Str"");
    msg.append(names.elementAt(i));
    if (descriptions != null) {
      msg.append(spaces.substring(0,maxlen - names.elementAt(i).length() + 2));
      msg.append(descriptions.elementAt(i));
    }
    msg.append(lSep);
    if (!dependencies.isEmpty()) {
      final Enumeration<String> deps=dependencies.elementAt(i);
      if (deps.hasMoreElements()) {
        msg.append(""String_Node_Str"");
        while (deps.hasMoreElements()) {
          msg.append(deps.nextElement());
          if (deps.hasMoreElements()) {
            msg.append(""String_Node_Str"");
          }
        }
        msg.append(lSep);
      }
    }
  }
  project.log(msg.toString(),Project.MSG_WARN);
}","/** 
 * Writes a formatted list of target names to <code>System.out</code> with an optional description.
 * @param project the project instance.
 * @param names The names to be printed. Must not be <code>null</code>.
 * @param descriptions The associated target descriptions. May be<code>null</code>, in which case no descriptions are displayed. If non-<code>null</code>, this should have as many elements as <code>names</code>.
 * @param topDependencies The list of dependencies for each target. Thedependencies are listed as a non null enumeration of String.
 * @param heading The heading to display. Should not be <code>null</code>.
 * @param maxlen The maximum length of the names of the targets. Ifdescriptions are given, they are padded to this position so they line up (so long as the names really <i>are</i> shorter than this).
 */
private static void printTargets(final Project project,final Vector<String> names,final Vector<String> descriptions,final Vector<Enumeration<String>> dependencies,final String heading,final int maxlen){
  final String lSep=System.getProperty(""String_Node_Str"");
  String spaces=""String_Node_Str"";
  while (spaces.length() <= maxlen) {
    spaces+=spaces;
  }
  final StringBuilder msg=new StringBuilder();
  msg.append(heading + lSep + lSep);
  final int size=names.size();
  for (int i=0; i < size; i++) {
    msg.append(""String_Node_Str"");
    msg.append(names.elementAt(i));
    if (descriptions != null) {
      msg.append(spaces.substring(0,maxlen - names.elementAt(i).length() + 2));
      msg.append(descriptions.elementAt(i));
    }
    msg.append(lSep);
    if (!dependencies.isEmpty()) {
      final Enumeration<String> deps=dependencies.elementAt(i);
      if (deps.hasMoreElements()) {
        msg.append(""String_Node_Str"");
        while (deps.hasMoreElements()) {
          msg.append(deps.nextElement());
          if (deps.hasMoreElements()) {
            msg.append(""String_Node_Str"");
          }
        }
        msg.append(lSep);
      }
    }
  }
  project.log(msg.toString(),Project.MSG_WARN);
}",0.997569275644142
100737,"@Override public void processingInstruction(final String target,final String data) throws SAXException {
  String d=data;
  if (target.equals(PI_WORKDIR_TARGET)) {
    if (workdir != null) {
      try {
        if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
          d=workdir.getCanonicalPath();
        }
 else {
          d=UNIX_SEPARATOR + workdir.getCanonicalPath();
        }
      }
 catch (      final IOException e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
 else   if (target.equals(PI_WORKDIR_TARGET_URI)) {
    if (workdir != null) {
      d=workdir.toURI().toString();
    }
  }
 else   if (target.equals(PI_PATH2PROJ_TARGET)) {
    if (path2project != null) {
      d=path2project;
    }
  }
 else   if (target.equals(PI_PATH2PROJ_TARGET_URI)) {
    if (path2project != null) {
      d=URLUtils.correct(FileUtils.separatorsToUnix(path2project),true);
    }
  }
  getContentHandler().processingInstruction(target,d);
}","@Override public void processingInstruction(final String target,final String data) throws SAXException {
  String d=data;
  if (target.equals(PI_WORKDIR_TARGET)) {
    if (workdir != null) {
      try {
        if (!OS_NAME.toLowerCase().contains(OS_NAME_WINDOWS)) {
          d=workdir.getCanonicalPath();
        }
 else {
          d=UNIX_SEPARATOR + workdir.getCanonicalPath();
        }
      }
 catch (      final IOException e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
 else   if (target.equals(PI_WORKDIR_TARGET_URI)) {
    if (workdir != null) {
      d=workdir.toURI().toString();
    }
  }
 else   if (target.equals(PI_PATH2PROJ_TARGET)) {
    if (path2project != null) {
      d=path2project;
    }
  }
 else   if (target.equals(PI_PATH2PROJ_TARGET_URI)) {
    if (path2project != null) {
      d=URLUtils.correct(FileUtils.separatorsToUnix(path2project),true);
    }
  }
  getContentHandler().processingInstruction(target,d);
}",0.9889447236180904
100738,"/** 
 * Init xml reader used for pipeline parsing.
 * @param ditaDir absolute path to DITA-OT directory
 * @param validate whether validate input file
 * @param rootFile absolute path to input file
 * @throws SAXException parsing exception
 * @throws IOException if getting canonical file path fails
 */
private void initXMLReader(final File ditaDir,final boolean validate,final URI rootFile) throws SAXException, IOException {
  reader=StringUtils.getXMLReader();
  reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
  if (validate) {
    reader.setFeature(FEATURE_VALIDATION,true);
    try {
      reader.setFeature(FEATURE_VALIDATION_SCHEMA,true);
    }
 catch (    final SAXNotRecognizedException e) {
    }
  }
 else {
    final String msg=MessageUtils.getInstance().getMessage(""String_Node_Str"").toString();
    logger.warn(msg);
  }
  if (gramcache) {
    GrammarPoolManager.setGramCache(gramcache);
    final XMLGrammarPool grammarPool=GrammarPoolManager.getGrammarPool();
    try {
      reader.setProperty(""String_Node_Str"",grammarPool);
      logger.info(""String_Node_Str"");
    }
 catch (    final Exception e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  CatalogUtils.setDitaDir(ditaDir);
  reader.setEntityResolver(CatalogUtils.getCatalogResolver());
}","/** 
 * Init xml reader used for pipeline parsing.
 * @param ditaDir absolute path to DITA-OT directory
 * @param validate whether validate input file
 * @param rootFile absolute path to input file
 * @throws SAXException parsing exception
 * @throws IOException if getting canonical file path fails
 */
private void initXMLReader(final File ditaDir,final boolean validate,final URI rootFile) throws SAXException {
  reader=StringUtils.getXMLReader();
  reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
  if (validate) {
    reader.setFeature(FEATURE_VALIDATION,true);
    try {
      reader.setFeature(FEATURE_VALIDATION_SCHEMA,true);
    }
 catch (    final SAXNotRecognizedException e) {
    }
  }
 else {
    final String msg=MessageUtils.getInstance().getMessage(""String_Node_Str"").toString();
    logger.warn(msg);
  }
  if (gramcache) {
    GrammarPoolManager.setGramCache(gramcache);
    final XMLGrammarPool grammarPool=GrammarPoolManager.getGrammarPool();
    try {
      reader.setProperty(""String_Node_Str"",grammarPool);
      logger.info(""String_Node_Str"");
    }
 catch (    final Exception e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  CatalogUtils.setDitaDir(ditaDir);
  reader.setEntityResolver(CatalogUtils.getCatalogResolver());
}",0.9949317738791424
100739,"/** 
 * Init xml reader used for pipeline parsing.
 * @param ditaDir absolute path to DITA-OT directory
 * @param validate whether validate input file
 * @param rootFile absolute path to input file
 * @throws SAXException parsing exception
 * @throws IOException if getting canonical file path fails
 */
private void initXMLReader(final File ditaDir,final boolean validate,final File rootFile) throws SAXException, IOException {
  reader=StringUtils.getXMLReader();
  reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
  if (validate) {
    reader.setFeature(FEATURE_VALIDATION,true);
    try {
      reader.setFeature(FEATURE_VALIDATION_SCHEMA,true);
    }
 catch (    final SAXNotRecognizedException e) {
    }
  }
 else {
    final String msg=MessageUtils.getInstance().getMessage(""String_Node_Str"").toString();
    logger.warn(msg);
  }
  if (gramcache) {
    GrammarPoolManager.setGramCache(gramcache);
    final XMLGrammarPool grammarPool=GrammarPoolManager.getGrammarPool();
    try {
      reader.setProperty(""String_Node_Str"",grammarPool);
      logger.info(""String_Node_Str"");
    }
 catch (    final Exception e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  CatalogUtils.setDitaDir(ditaDir);
  reader.setEntityResolver(CatalogUtils.getCatalogResolver());
}","/** 
 * Init xml reader used for pipeline parsing.
 * @param ditaDir absolute path to DITA-OT directory
 * @param validate whether validate input file
 * @param rootFile absolute path to input file
 * @throws SAXException parsing exception
 * @throws IOException if getting canonical file path fails
 */
private void initXMLReader(final File ditaDir,final boolean validate,final File rootFile) throws SAXException {
  reader=StringUtils.getXMLReader();
  reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
  if (validate) {
    reader.setFeature(FEATURE_VALIDATION,true);
    try {
      reader.setFeature(FEATURE_VALIDATION_SCHEMA,true);
    }
 catch (    final SAXNotRecognizedException e) {
    }
  }
 else {
    final String msg=MessageUtils.getInstance().getMessage(""String_Node_Str"").toString();
    logger.warn(msg);
  }
  if (gramcache) {
    GrammarPoolManager.setGramCache(gramcache);
    final XMLGrammarPool grammarPool=GrammarPoolManager.getGrammarPool();
    try {
      reader.setProperty(""String_Node_Str"",grammarPool);
      logger.info(""String_Node_Str"");
    }
 catch (    final Exception e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  CatalogUtils.setDitaDir(ditaDir);
  reader.setEntityResolver(CatalogUtils.getCatalogResolver());
}",0.9949357226334242
100740,"/** 
 * Initialize reusable filters.
 * @throws IOException 
 * @throws SAXException 
 */
private void initFilters() throws SAXException, IOException {
  listFilter=new GenListModuleReader();
  listFilter.setLogger(logger);
  filterUtils=parseFilterFile();
  listFilter.setInputFile(rootFile.getAbsoluteFile());
  listFilter.setInputDir(rootFile.getAbsoluteFile().getParentFile());
  listFilter.setJob(job);
  exportAnchorsFilter=new ExportAnchorsFilter();
  exportAnchorsFilter.setInputFile(rootFile.getAbsoluteFile());
  keydefFilter=new KeydefFilter();
  keydefFilter.setLogger(logger);
  keydefFilter.setInputFile(rootFile.getAbsoluteFile().toURI());
  keydefFilter.setJob(job);
  nullHandler=new DefaultHandler();
}","/** 
 * Initialize reusable filters.
 * @throws IOException 
 * @throws SAXException 
 */
private void initFilters(){
  listFilter=new GenListModuleReader();
  listFilter.setLogger(logger);
  filterUtils=parseFilterFile();
  listFilter.setInputFile(rootFile.getAbsoluteFile());
  listFilter.setInputDir(rootFile.getAbsoluteFile().getParentFile());
  listFilter.setJob(job);
  exportAnchorsFilter=new ExportAnchorsFilter();
  exportAnchorsFilter.setInputFile(rootFile.getAbsoluteFile());
  keydefFilter=new KeydefFilter();
  keydefFilter.setLogger(logger);
  keydefFilter.setInputFile(rootFile.getAbsoluteFile().toURI());
  keydefFilter.setJob(job);
  nullHandler=new DefaultHandler();
}",0.9758179231863442
100741,"private void extractIndexTerm() throws SAXException {
  final int topicNum=topicList.size();
  final int ditamapNum=ditamapList.size();
  FileInputStream inputStream=null;
  XMLReader xmlReader=null;
  final IndexTermReader handler=new IndexTermReader(indexTermCollection);
  handler.setLogger(logger);
  final DitamapIndexTermReader ditamapIndexTermReader=new DitamapIndexTermReader(indexTermCollection,true);
  ditamapIndexTermReader.setLogger(logger);
  xmlReader=StringUtils.getXMLReader();
  try {
    xmlReader.setContentHandler(handler);
    for (    String aTopicList : topicList) {
      String target;
      String targetPathFromMap;
      String targetPathFromMapWithoutExt;
      handler.reset();
      target=aTopicList;
      targetPathFromMap=FileUtils.getRelativeUnixPath(inputMap,target);
      targetPathFromMapWithoutExt=targetPathFromMap.substring(0,targetPathFromMap.lastIndexOf(""String_Node_Str""));
      handler.setTargetFile(targetPathFromMapWithoutExt + targetExt);
      try {
        inputStream=new FileInputStream(new File(job.tempDir,target));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      final Exception e) {
        final StringBuffer buff=new StringBuffer();
        String msg=null;
        msg=MessageUtils.getInstance().getMessage(""String_Node_Str"",target).toString();
        logger.error(buff.append(msg).append(e.getMessage()).toString());
      }
    }
    xmlReader.setContentHandler(ditamapIndexTermReader);
    for (    final String ditamap : ditamapList) {
      final String currentMapPathName=FileUtils.getRelativeUnixPath(inputMap,ditamap);
      String mapPathFromInputMap=""String_Node_Str"";
      if (currentMapPathName.lastIndexOf(SLASH) != -1) {
        mapPathFromInputMap=currentMapPathName.substring(0,currentMapPathName.lastIndexOf(SLASH));
      }
      ditamapIndexTermReader.setMapPath(mapPathFromInputMap);
      try {
        inputStream=new FileInputStream(new File(job.tempDir,ditamap));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      final Exception e) {
        String msg=null;
        msg=MessageUtils.getInstance().getMessage(""String_Node_Str"",ditamap).toString();
        logger.error(msg,e);
      }
    }
  }
  finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}","private void extractIndexTerm() throws SAXException {
  final int topicNum=topicList.size();
  final int ditamapNum=ditamapList.size();
  FileInputStream inputStream=null;
  XMLReader xmlReader=null;
  final IndexTermReader handler=new IndexTermReader(indexTermCollection);
  handler.setLogger(logger);
  final DitamapIndexTermReader ditamapIndexTermReader=new DitamapIndexTermReader(indexTermCollection,true);
  ditamapIndexTermReader.setLogger(logger);
  xmlReader=StringUtils.getXMLReader();
  try {
    xmlReader.setContentHandler(handler);
    for (    String aTopicList : topicList) {
      String target;
      String targetPathFromMap;
      String targetPathFromMapWithoutExt;
      handler.reset();
      target=aTopicList;
      targetPathFromMap=FileUtils.getRelativeUnixPath(inputMap,target);
      targetPathFromMapWithoutExt=targetPathFromMap.substring(0,targetPathFromMap.lastIndexOf(""String_Node_Str""));
      handler.setTargetFile(targetPathFromMapWithoutExt + targetExt);
      try {
        inputStream=new FileInputStream(new File(job.tempDir,target));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      final Exception e) {
        final StringBuilder buff=new StringBuilder();
        String msg=null;
        msg=MessageUtils.getInstance().getMessage(""String_Node_Str"",target).toString();
        logger.error(buff.append(msg).append(e.getMessage()).toString());
      }
    }
    xmlReader.setContentHandler(ditamapIndexTermReader);
    for (    final String ditamap : ditamapList) {
      final String currentMapPathName=FileUtils.getRelativeUnixPath(inputMap,ditamap);
      String mapPathFromInputMap=""String_Node_Str"";
      if (currentMapPathName.lastIndexOf(SLASH) != -1) {
        mapPathFromInputMap=currentMapPathName.substring(0,currentMapPathName.lastIndexOf(SLASH));
      }
      ditamapIndexTermReader.setMapPath(mapPathFromInputMap);
      try {
        inputStream=new FileInputStream(new File(job.tempDir,ditamap));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      final Exception e) {
        String msg=null;
        msg=MessageUtils.getInstance().getMessage(""String_Node_Str"",ditamap).toString();
        logger.error(msg,e);
      }
    }
  }
  finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      final IOException e) {
        logger.error(e.getMessage(),e);
      }
    }
  }
}",0.9979903536977492
100742,"private void parseAndValidateInput(final AbstractPipelineInput input) throws DITAOTException {
  final String baseDir=input.getAttribute(ANT_INVOKER_PARAM_BASEDIR);
  String output=input.getAttribute(ANT_INVOKER_EXT_PARAM_OUTPUT);
  if (!new File(output).isAbsolute()) {
    output=new File(baseDir,output).getAbsolutePath();
  }
  final String encoding=input.getAttribute(ANT_INVOKER_EXT_PARAM_ENCODING);
  final String indextype=input.getAttribute(ANT_INVOKER_EXT_PARAM_INDEXTYPE);
  final String indexclass=input.getAttribute(ANT_INVOKER_EXT_PARAM_INDEXCLASS);
  inputMap=input.getAttribute(ANT_INVOKER_PARAM_INPUTMAP);
  targetExt=input.getAttribute(ANT_INVOKER_EXT_PARAM_TARGETEXT);
  topicList=new ArrayList<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format) && !f.isResourceOnly) {
      topicList.add(f.file.getPath());
    }
  }
  ditamapList=new ArrayList<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format) && !f.isResourceOnly) {
      ditamapList.add(f.file.getPath());
    }
  }
  final int lastIndexOfDot=output.lastIndexOf(""String_Node_Str"");
  final String outputRoot=(lastIndexOfDot == -1) ? output : output.substring(0,lastIndexOfDot);
  indexTermCollection.setOutputFileRoot(outputRoot);
  indexTermCollection.setIndexType(indextype);
  indexTermCollection.setIndexClass(indexclass);
  indexTermCollection.setPipelineHashIO((PipelineHashIO)input);
  if (encoding != null && encoding.trim().length() > 0) {
    IndexTerm.setTermLocale(StringUtils.getLocale(encoding));
  }
}","private void parseAndValidateInput(final AbstractPipelineInput input){
  final String baseDir=input.getAttribute(ANT_INVOKER_PARAM_BASEDIR);
  String output=input.getAttribute(ANT_INVOKER_EXT_PARAM_OUTPUT);
  if (!new File(output).isAbsolute()) {
    output=new File(baseDir,output).getAbsolutePath();
  }
  final String encoding=input.getAttribute(ANT_INVOKER_EXT_PARAM_ENCODING);
  final String indextype=input.getAttribute(ANT_INVOKER_EXT_PARAM_INDEXTYPE);
  final String indexclass=input.getAttribute(ANT_INVOKER_EXT_PARAM_INDEXCLASS);
  inputMap=input.getAttribute(ANT_INVOKER_PARAM_INPUTMAP);
  targetExt=input.getAttribute(ANT_INVOKER_EXT_PARAM_TARGETEXT);
  topicList=new ArrayList<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format) && !f.isResourceOnly) {
      topicList.add(f.file.getPath());
    }
  }
  ditamapList=new ArrayList<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITAMAP.equals(f.format) && !f.isResourceOnly) {
      ditamapList.add(f.file.getPath());
    }
  }
  final int lastIndexOfDot=output.lastIndexOf(""String_Node_Str"");
  final String outputRoot=(lastIndexOfDot == -1) ? output : output.substring(0,lastIndexOfDot);
  indexTermCollection.setOutputFileRoot(outputRoot);
  indexTermCollection.setIndexType(indextype);
  indexTermCollection.setIndexClass(indexclass);
  indexTermCollection.setPipelineHashIO((PipelineHashIO)input);
  if (encoding != null && encoding.trim().length() > 0) {
    IndexTerm.setTermLocale(StringUtils.getLocale(encoding));
  }
}",0.9924859110832812
100743,"/** 
 * Write start element.
 * @param elemName element name
 * @param atts attribute
 * @param removeConref whether remeove conref info
 * @throws SAXException if writing element failed
 */
private void putElement(final String elemName,final Attributes atts,final boolean removeConref) throws SAXException {
  try {
    pushcontentWriter.writeStartElement(elemName);
    for (int index=0; index < atts.getLength(); index++) {
      final String name=atts.getQName(index);
      if (!removeConref || !ATTRIBUTE_NAME_CONREF.equals(name) && !ATTRIBUTE_NAME_CONACTION.equals(name)) {
        String value=atts.getValue(index);
        if (ATTRIBUTE_NAME_HREF.equals(name) || ATTRIBUTE_NAME_CONREF.equals(name)) {
          value=replaceURL(value);
        }
        pushcontentWriter.writeAttribute(name,value);
      }
    }
    if (ATTR_CONACTION_VALUE_PUSHREPLACE.equals(pushType) && atts.getValue(ATTRIBUTE_NAME_ID) == null && level == 1) {
      final String fragment=target.getFragment();
      if (fragment == null) {
        logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",target.toString()).toString());
      }
 else {
        final String targetLoc=fragment;
        String id=""String_Node_Str"";
        if (targetLoc.contains(SLASH)) {
          id=targetLoc.substring(targetLoc.lastIndexOf(SLASH) + 1);
        }
 else {
          id=targetLoc;
        }
        pushcontentWriter.writeAttribute(ATTRIBUTE_NAME_ID,id);
      }
    }
  }
 catch (  final XMLStreamException e) {
    throw new SAXException(e);
  }
}","/** 
 * Write start element.
 * @param elemName element name
 * @param atts attribute
 * @param removeConref whether remeove conref info
 * @throws SAXException if writing element failed
 */
private void putElement(final String elemName,final Attributes atts,final boolean removeConref) throws SAXException {
  try {
    pushcontentWriter.writeStartElement(elemName);
    for (int index=0; index < atts.getLength(); index++) {
      final String name=atts.getQName(index);
      if (!removeConref || !ATTRIBUTE_NAME_CONREF.equals(name) && !ATTRIBUTE_NAME_CONACTION.equals(name)) {
        String value=atts.getValue(index);
        if (ATTRIBUTE_NAME_HREF.equals(name) || ATTRIBUTE_NAME_CONREF.equals(name)) {
          value=replaceURL(value);
        }
        pushcontentWriter.writeAttribute(name,value);
      }
    }
    if (ATTR_CONACTION_VALUE_PUSHREPLACE.equals(pushType) && atts.getValue(ATTRIBUTE_NAME_ID) == null && level == 1) {
      final String fragment=target.getFragment();
      if (fragment == null) {
        logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",target.toString()).toString());
      }
 else {
        String id=""String_Node_Str"";
        if (fragment.contains(SLASH)) {
          id=fragment.substring(fragment.lastIndexOf(SLASH) + 1);
        }
 else {
          id=fragment;
        }
        pushcontentWriter.writeAttribute(ATTRIBUTE_NAME_ID,id);
      }
    }
  }
 catch (  final XMLStreamException e) {
    throw new SAXException(e);
  }
}",0.964180085441998
100744,"private void genTargets(final IndexTerm indexTerm,final TopicrefElement obj){
  final TopicrefElement topicref=obj;
  final IndexTermTarget target=new IndexTermTarget();
  String targetURI=null;
  final String href=topicref.getHref();
  final StringBuilder buffer=new StringBuilder();
  if (!href.contains(COLON_DOUBLE_SLASH) && !FileUtils.isAbsolutePath(href)) {
    if (mapPath != null && mapPath.length() != 0) {
      buffer.append(mapPath);
      buffer.append(SLASH);
    }
    buffer.append(href);
    targetURI=FileUtils.normalize(buffer.toString()).getPath();
  }
 else {
    targetURI=href;
  }
  if (topicref.getNavTitle() != null) {
    target.setTargetName(topicref.getNavTitle());
  }
 else {
    target.setTargetName(href);
  }
  target.setTargetURI(targetURI);
  assignTarget(indexTerm,target);
}","private void genTargets(final IndexTerm indexTerm,final TopicrefElement obj){
  final IndexTermTarget target=new IndexTermTarget();
  String targetURI=null;
  final String href=obj.getHref();
  final StringBuilder buffer=new StringBuilder();
  if (!href.contains(COLON_DOUBLE_SLASH) && !FileUtils.isAbsolutePath(href)) {
    if (mapPath != null && mapPath.length() != 0) {
      buffer.append(mapPath);
      buffer.append(SLASH);
    }
    buffer.append(href);
    targetURI=FileUtils.normalize(buffer.toString()).getPath();
  }
 else {
    targetURI=href;
  }
  if (obj.getNavTitle() != null) {
    target.setTargetName(obj.getNavTitle());
  }
 else {
    target.setTargetName(href);
  }
  target.setTargetURI(targetURI);
  assignTarget(indexTerm,target);
}",0.9548058561425844
100745,"@Override public void endDocument() throws SAXException {
  final int size=indexTermList.size();
  updateIndexTermTargetName();
  for (int i=0; i < size; i++) {
    final IndexTerm indexterm=indexTermList.get(i);
    result.addTerm(indexterm);
  }
}","@Override public void endDocument() throws SAXException {
  final int size=indexTermList.size();
  updateIndexTermTargetName();
  for (  final IndexTerm indexterm : indexTermList) {
    result.addTerm(indexterm);
  }
}",0.6081370449678801
100746,"/** 
 * Initialization.
 * @param locale
 */
private void init(final Locale locale){
  Class<?> c=null;
  try {
    c=Class.forName(""String_Node_Str"");
  }
 catch (  final Exception e) {
    c=Collator.class;
  }
  try {
    final Method m=c.getDeclaredMethod(""String_Node_Str"",new Class[]{Locale.class});
    collatorInstance=m.invoke(null,new Object[]{locale});
    compareMethod=c.getDeclaredMethod(""String_Node_Str"",new Class[]{Object.class,Object.class});
  }
 catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Initialization.
 * @param locale
 */
private void init(final Locale locale){
  Class<?> c=null;
  try {
    c=Class.forName(""String_Node_Str"");
  }
 catch (  final Exception e) {
    c=Collator.class;
  }
  try {
    final Method m=c.getDeclaredMethod(""String_Node_Str"",new Class[]{Locale.class});
    collatorInstance=m.invoke(null,locale);
    compareMethod=c.getDeclaredMethod(""String_Node_Str"",new Class[]{Object.class,Object.class});
  }
 catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.9769503546099292
100747,"/** 
 * Comparing method required to compare.
 * @see java.util.Comparator#compare(java.lang.Object,java.lang.Object)
 */
@Override public int compare(final Object source,final Object target){
  try {
    return ((Integer)compareMethod.invoke(collatorInstance,new Object[]{source,target})).intValue();
  }
 catch (  final Exception e) {
    throw new RuntimeException(e.getMessage(),e);
  }
}","/** 
 * Comparing method required to compare.
 * @see java.util.Comparator#compare(java.lang.Object,java.lang.Object)
 */
@Override public int compare(final Object source,final Object target){
  try {
    return (Integer)compareMethod.invoke(collatorInstance,new Object[]{source,target});
  }
 catch (  final Exception e) {
    throw new RuntimeException(e.getMessage(),e);
  }
}",0.9831387808041504
100748,"/** 
 * To escape a file path to a URI, by using %HH to represent special ASCII characters: 0x00~0x1F, 0x7F, ' ', '<', '>', '#', '%' and '""' and non-ASCII characters (whose value >= 128).
 * @param path The path to be escaped.
 * @return The escaped path.
 */
public static String escapeSpecialAsciiAndNonAscii(final String path){
  int len=path.length(), ch;
  final StringBuffer buffer=new StringBuffer(len * 3);
  if (len >= 2 && path.charAt(1) == ':') {
    ch=Character.toUpperCase(path.charAt(0));
    if (ch >= 'A' && ch <= 'Z') {
      buffer.append('/');
    }
  }
  int i=0;
  for (; i < len; i++) {
    ch=path.charAt(i);
    if (ch >= 128) {
      break;
    }
    if (gNeedEscaping[ch]) {
      buffer.append('%');
      buffer.append(gAfterEscaping1[ch]);
      buffer.append(gAfterEscaping2[ch]);
    }
 else {
      buffer.append((char)ch);
    }
  }
  if (i < len) {
    byte[] bytes;
    byte b;
    try {
      bytes=path.substring(i).getBytes(""String_Node_Str"");
    }
 catch (    final java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    len=bytes.length;
    for (i=0; i < len; i++) {
      b=bytes[i];
      if (b < 0) {
        ch=b + 256;
        buffer.append('%');
        buffer.append(gHexChs[ch >> 4]);
        buffer.append(gHexChs[ch & 0xf]);
      }
 else       if (gNeedEscaping[b]) {
        buffer.append('%');
        buffer.append(gAfterEscaping1[b]);
        buffer.append(gAfterEscaping2[b]);
      }
 else {
        buffer.append((char)b);
      }
    }
  }
  return buffer.toString();
}","/** 
 * To escape a file path to a URI, by using %HH to represent special ASCII characters: 0x00~0x1F, 0x7F, ' ', '<', '>', '#', '%' and '""' and non-ASCII characters (whose value >= 128).
 * @param path The path to be escaped.
 * @return The escaped path.
 */
public static String escapeSpecialAsciiAndNonAscii(final String path){
  int len=path.length(), ch;
  final StringBuilder buffer=new StringBuilder(len * 3);
  if (len >= 2 && path.charAt(1) == ':') {
    ch=Character.toUpperCase(path.charAt(0));
    if (ch >= 'A' && ch <= 'Z') {
      buffer.append('/');
    }
  }
  int i=0;
  for (; i < len; i++) {
    ch=path.charAt(i);
    if (ch >= 128) {
      break;
    }
    if (gNeedEscaping[ch]) {
      buffer.append('%');
      buffer.append(gAfterEscaping1[ch]);
      buffer.append(gAfterEscaping2[ch]);
    }
 else {
      buffer.append((char)ch);
    }
  }
  if (i < len) {
    byte[] bytes;
    byte b;
    try {
      bytes=path.substring(i).getBytes(""String_Node_Str"");
    }
 catch (    final java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    len=bytes.length;
    for (i=0; i < len; i++) {
      b=bytes[i];
      if (b < 0) {
        ch=b + 256;
        buffer.append('%');
        buffer.append(gHexChs[ch >> 4]);
        buffer.append(gHexChs[ch & 0xf]);
      }
 else       if (gNeedEscaping[b]) {
        buffer.append('%');
        buffer.append(gAfterEscaping1[b]);
        buffer.append(gAfterEscaping2[b]);
      }
 else {
        buffer.append((char)b);
      }
    }
  }
  return buffer.toString();
}",0.9968071519795658
100749,"/** 
 * Check whether a file exists on the local file systmem.
 * @param filename platform path, may contain a hash fragment
 * @return boolean  true if the file exists, false otherwise
 */
public static boolean fileExists(String filename){
  filename=filename.indexOf(SHARP) != -1 ? filename.substring(0,filename.indexOf(SHARP)) : filename;
  return new File(filename).exists();
}","/** 
 * Check whether a file exists on the local file systmem.
 * @param filename platform path, may contain a hash fragment
 * @return boolean  true if the file exists, false otherwise
 */
public static boolean fileExists(String filename){
  filename=filename.contains(SHARP) ? filename.substring(0,filename.indexOf(SHARP)) : filename;
  return new File(filename).exists();
}",0.9722589167767504
100750,"/** 
 * Get Base64 encoding content. For ODT transformation
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return base64 encoded binary data.
 */
public static String getBASE64(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  final URI imgInputURI=toURI(fileName);
  final File imgInput=imgInputURI.isAbsolute() ? new File(imgInputURI) : new File(dirName,toFile(imgInputURI).getPath());
  final Base64 encoder=new Base64();
  final byte buff[]=new byte[(int)imgInput.length()];
  FileInputStream file=null;
  try {
    file=new FileInputStream(imgInput);
    file.read(buff);
    final String ret=encoder.encodeToString(buff);
    return ret;
  }
 catch (  final FileNotFoundException e) {
    logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"").toString());
    logger.error(e.getMessage(),e);
    return null;
  }
catch (  final IOException e) {
    logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"").toString());
    logger.error(e.getMessage(),e);
    return null;
  }
 finally {
    if (file != null) {
      try {
        file.close();
      }
 catch (      final IOException ioe) {
        logger.error(ioe.getMessage(),ioe);
      }
    }
  }
}","/** 
 * Get Base64 encoding content. For ODT transformation
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return base64 encoded binary data.
 */
public static String getBASE64(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  final URI imgInputURI=toURI(fileName);
  final File imgInput=imgInputURI.isAbsolute() ? new File(imgInputURI) : new File(dirName,toFile(imgInputURI).getPath());
  final Base64 encoder=new Base64();
  final byte buff[]=new byte[(int)imgInput.length()];
  FileInputStream file=null;
  try {
    file=new FileInputStream(imgInput);
    file.read(buff);
    return encoder.encodeToString(buff);
  }
 catch (  final FileNotFoundException e) {
    logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"").toString());
    logger.error(e.getMessage(),e);
    return null;
  }
catch (  final IOException e) {
    logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"").toString());
    logger.error(e.getMessage(),e);
    return null;
  }
 finally {
    if (file != null) {
      try {
        file.close();
      }
 catch (      final IOException ioe) {
        logger.error(ioe.getMessage(),ioe);
      }
    }
  }
}",0.9728915662650602
100751,"/** 
 * Try to clean an invalid URI.
 * @param path URI to be escaped.
 * @param ascii encode non-ASCII characters to ASCII
 * @return cleaned URI
 */
public static String clean(final String path,final boolean ascii){
  int len=path.length(), ch;
  final StringBuffer buffer=new StringBuffer(len * 3);
  if (len >= 2 && path.charAt(1) == ':') {
    ch=Character.toUpperCase(path.charAt(0));
    if (ch >= 'A' && ch <= 'Z') {
      buffer.append('/');
    }
  }
  int i=0;
  for (; i < len; i++) {
    ch=path.charAt(i);
    if (ch >= 128 && ascii) {
      break;
    }
    if (ch < gNeedEscaping.length && gNeedEscaping[ch]) {
      buffer.append('%');
      buffer.append(gAfterEscaping1[ch]);
      buffer.append(gAfterEscaping2[ch]);
    }
 else {
      buffer.append((char)ch);
    }
  }
  if (i < len && ascii) {
    byte[] bytes;
    byte b;
    try {
      bytes=path.substring(i).getBytes(""String_Node_Str"");
    }
 catch (    final java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    len=bytes.length;
    for (i=0; i < len; i++) {
      b=bytes[i];
      if (b < 0) {
        ch=b + 256;
        buffer.append('%');
        buffer.append(gHexChs[ch >> 4]);
        buffer.append(gHexChs[ch & 0xf]);
      }
 else       if (gNeedEscaping[b]) {
        buffer.append('%');
        buffer.append(gAfterEscaping1[b]);
        buffer.append(gAfterEscaping2[b]);
      }
 else {
        buffer.append((char)b);
      }
    }
  }
  return buffer.toString();
}","/** 
 * Try to clean an invalid URI.
 * @param path URI to be escaped.
 * @param ascii encode non-ASCII characters to ASCII
 * @return cleaned URI
 */
public static String clean(final String path,final boolean ascii){
  int len=path.length(), ch;
  final StringBuilder buffer=new StringBuilder(len * 3);
  if (len >= 2 && path.charAt(1) == ':') {
    ch=Character.toUpperCase(path.charAt(0));
    if (ch >= 'A' && ch <= 'Z') {
      buffer.append('/');
    }
  }
  int i=0;
  for (; i < len; i++) {
    ch=path.charAt(i);
    if (ch >= 128 && ascii) {
      break;
    }
    if (ch < gNeedEscaping.length && gNeedEscaping[ch]) {
      buffer.append('%');
      buffer.append(gAfterEscaping1[ch]);
      buffer.append(gAfterEscaping2[ch]);
    }
 else {
      buffer.append((char)ch);
    }
  }
  if (i < len && ascii) {
    byte[] bytes;
    byte b;
    try {
      bytes=path.substring(i).getBytes(""String_Node_Str"");
    }
 catch (    final java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    len=bytes.length;
    for (i=0; i < len; i++) {
      b=bytes[i];
      if (b < 0) {
        ch=b + 256;
        buffer.append('%');
        buffer.append(gHexChs[ch >> 4]);
        buffer.append(gHexChs[ch & 0xf]);
      }
 else       if (gNeedEscaping[b]) {
        buffer.append('%');
        buffer.append(gAfterEscaping1[b]);
        buffer.append(gAfterEscaping2[b]);
      }
 else {
        buffer.append((char)b);
      }
    }
  }
  return buffer.toString();
}",0.9966666666666668
100752,"/** 
 * Get relative path to base path. <p>For   {@code foo/bar/baz.txt} return {@code ../../}</p>
 * @param relativePath relative URI
 * @return relative URI to base path, {@code null} if reference path was a single file
 */
public static URI getRelativePath(final URI relativePath){
  final StringTokenizer tokenizer=new StringTokenizer(relativePath.toString(),URI_SEPARATOR);
  final StringBuffer buffer=new StringBuffer();
  if (tokenizer.countTokens() == 1) {
    return null;
  }
 else {
    while (tokenizer.countTokens() > 1) {
      tokenizer.nextToken();
      buffer.append(""String_Node_Str"");
      buffer.append(URI_SEPARATOR);
    }
    return toURI(buffer.toString());
  }
}","/** 
 * Get relative path to base path. <p>For   {@code foo/bar/baz.txt} return {@code ../../}</p>
 * @param relativePath relative URI
 * @return relative URI to base path, {@code null} if reference path was a single file
 */
public static URI getRelativePath(final URI relativePath){
  final StringTokenizer tokenizer=new StringTokenizer(relativePath.toString(),URI_SEPARATOR);
  final StringBuilder buffer=new StringBuilder();
  if (tokenizer.countTokens() == 1) {
    return null;
  }
 else {
    while (tokenizer.countTokens() > 1) {
      tokenizer.nextToken();
      buffer.append(""String_Node_Str"");
      buffer.append(URI_SEPARATOR);
    }
    return toURI(buffer.toString());
  }
}",0.9927536231884058
100753,"/** 
 * get the document node of a topic file.
 * @param absolutePathToFile topic file
 * @return element.
 */
private Element getTopicDoc(final String absolutePathToFile){
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  DocumentBuilder builder;
  try {
    builder=factory.newDocumentBuilder();
    final Document doc=builder.parse(absolutePathToFile);
    final Element root=doc.getDocumentElement();
    return root;
  }
 catch (  final ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  final SAXException e) {
    e.printStackTrace();
  }
catch (  final IOException e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * get the document node of a topic file.
 * @param absolutePathToFile topic file
 * @return element.
 */
private Element getTopicDoc(final String absolutePathToFile){
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  DocumentBuilder builder;
  try {
    builder=factory.newDocumentBuilder();
    final Document doc=builder.parse(absolutePathToFile);
    return doc.getDocumentElement();
  }
 catch (  final ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  final SAXException e) {
    e.printStackTrace();
  }
catch (  final IOException e) {
    e.printStackTrace();
  }
  return null;
}",0.9415337889141988
100754,"@Override public void write(final File filename){
  if (filename == null || !filename.exists()) {
    return;
  }
  curMatchTopic=topicSet.contains(SHARP) ? SHARP : null;
  topicIdStack=new ArrayDeque<String>();
  final File inputFile=filename;
  final File outputFile=new File(filename.getPath() + FILE_EXTENSION_TEMP);
  FileOutputStream fileOutput=null;
  try {
    fileOutput=new FileOutputStream(outputFile);
    output=new OutputStreamWriter(fileOutput,UTF8);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(filename.getPath(),logger));
    reader.parse(inputFile.toURI().toString());
  }
 catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    try {
      if (fileOutput != null) {
        fileOutput.close();
      }
    }
 catch (    final Exception e) {
      logger.error(e.getMessage(),e);
    }
    try {
      if (output != null) {
        output.close();
      }
    }
 catch (    final Exception e) {
      logger.error(e.getMessage(),e);
    }
  }
  try {
    FileUtils.moveFile(outputFile,inputFile);
  }
 catch (  final Exception e) {
    logger.error(""String_Node_Str"" + inputFile + ""String_Node_Str""+ e.getMessage());
  }
}","@Override public void write(final File filename){
  if (filename == null || !filename.exists()) {
    return;
  }
  curMatchTopic=topicSet.contains(SHARP) ? SHARP : null;
  topicIdStack=new ArrayDeque<String>();
  final File outputFile=new File(filename.getPath() + FILE_EXTENSION_TEMP);
  FileOutputStream fileOutput=null;
  try {
    fileOutput=new FileOutputStream(outputFile);
    output=new OutputStreamWriter(fileOutput,UTF8);
    reader.setErrorHandler(new DITAOTXMLErrorHandler(filename.getPath(),logger));
    reader.parse(filename.toURI().toString());
  }
 catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
 finally {
    try {
      if (fileOutput != null) {
        fileOutput.close();
      }
    }
 catch (    final Exception e) {
      logger.error(e.getMessage(),e);
    }
    try {
      if (output != null) {
        output.close();
      }
    }
 catch (    final Exception e) {
      logger.error(e.getMessage(),e);
    }
  }
  try {
    FileUtils.moveFile(outputFile,filename);
  }
 catch (  final Exception e) {
    logger.error(""String_Node_Str"" + filename + ""String_Node_Str""+ e.getMessage());
  }
}",0.96640826873385
100755,"private void moveMeta(final Entry<String,Element> entry,final Element root){
  final List<String> metaPath=moveTable.get(entry.getKey());
  if (metaPath == null) {
    return;
  }
  final Iterator<String> token=metaPath.iterator();
  Node parent=null;
  Node child=root;
  Node current=null;
  Node item=null;
  NodeList childElements;
  boolean createChild=false;
  while (token.hasNext()) {
    final String next=token.next();
    parent=child;
    final Integer nextIndex=compareTable.get(next);
    Integer currentIndex=null;
    childElements=parent.getChildNodes();
    for (int i=0; i < childElements.getLength(); i++) {
      String name=null;
      String classValue=null;
      current=childElements.item(i);
      if (current.getNodeType() == Node.ELEMENT_NODE) {
        name=current.getNodeName();
        classValue=((Element)current).getAttribute(ATTRIBUTE_NAME_CLASS);
      }
      if ((name != null && current.getNodeName().equals(next)) || (classValue != null && (classValue.contains(next)))) {
        child=current;
        break;
      }
 else       if (name != null) {
        currentIndex=compareTable.get(name);
        if (currentIndex == null) {
          String generalizedName=classValue.substring(classValue.indexOf(SLASH) + 1);
          generalizedName=generalizedName.substring(0,generalizedName.indexOf(STRING_BLANK));
          currentIndex=compareTable.get(generalizedName);
        }
        if (currentIndex == null) {
          logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",name).toString());
          break;
        }
        if (currentIndex.compareTo(nextIndex) > 0) {
          break;
        }
      }
    }
    if (child == parent) {
      child=parent.getOwnerDocument().createElement(next);
      final DitaClass cls=new DitaClass(""String_Node_Str"" + next + ""String_Node_Str"");
      ((Element)child).setAttribute(ATTRIBUTE_NAME_CLASS,cls.toString());
      if (current == null || currentIndex == null || nextIndex.compareTo(currentIndex) >= 0) {
        parent.appendChild(child);
        current=null;
      }
 else {
        parent.insertBefore(child,current);
        current=null;
      }
      createChild=true;
    }
  }
  final NodeList list=entry.getValue().getChildNodes();
  for (int i=0; i < list.getLength(); i++) {
    item=list.item(i);
    if ((i == 0 && createChild) || MapMetaReader.uniqueSet.contains(entry.getKey())) {
      item=parent.getOwnerDocument().importNode(item,true);
      parent.replaceChild(item,child);
      child=item;
    }
 else {
      item=parent.getOwnerDocument().importNode(item,true);
      ((Element)parent).insertBefore(item,child);
    }
  }
}","private void moveMeta(final Entry<String,Element> entry,final Element root){
  final List<String> metaPath=moveTable.get(entry.getKey());
  if (metaPath == null) {
    return;
  }
  final Iterator<String> token=metaPath.iterator();
  Node parent=null;
  Node child=root;
  Node current=null;
  Node item=null;
  NodeList childElements;
  boolean createChild=false;
  while (token.hasNext()) {
    final String next=token.next();
    parent=child;
    final Integer nextIndex=compareTable.get(next);
    Integer currentIndex=null;
    childElements=parent.getChildNodes();
    for (int i=0; i < childElements.getLength(); i++) {
      String name=null;
      String classValue=null;
      current=childElements.item(i);
      if (current.getNodeType() == Node.ELEMENT_NODE) {
        name=current.getNodeName();
        classValue=((Element)current).getAttribute(ATTRIBUTE_NAME_CLASS);
      }
      if ((name != null && current.getNodeName().equals(next)) || (classValue != null && (classValue.contains(next)))) {
        child=current;
        break;
      }
 else       if (name != null) {
        currentIndex=compareTable.get(name);
        if (currentIndex == null) {
          String generalizedName=classValue.substring(classValue.indexOf(SLASH) + 1);
          generalizedName=generalizedName.substring(0,generalizedName.indexOf(STRING_BLANK));
          currentIndex=compareTable.get(generalizedName);
        }
        if (currentIndex == null) {
          logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",name).toString());
          break;
        }
        if (currentIndex.compareTo(nextIndex) > 0) {
          break;
        }
      }
    }
    if (child == parent) {
      child=parent.getOwnerDocument().createElement(next);
      final DitaClass cls=new DitaClass(""String_Node_Str"" + next + ""String_Node_Str"");
      ((Element)child).setAttribute(ATTRIBUTE_NAME_CLASS,cls.toString());
      if (current == null || currentIndex == null || nextIndex.compareTo(currentIndex) >= 0) {
        parent.appendChild(child);
        current=null;
      }
 else {
        parent.insertBefore(child,current);
        current=null;
      }
      createChild=true;
    }
  }
  final NodeList list=entry.getValue().getChildNodes();
  for (int i=0; i < list.getLength(); i++) {
    item=list.item(i);
    if ((i == 0 && createChild) || MapMetaReader.uniqueSet.contains(entry.getKey())) {
      item=parent.getOwnerDocument().importNode(item,true);
      parent.replaceChild(item,child);
      child=item;
    }
 else {
      item=parent.getOwnerDocument().importNode(item,true);
      parent.insertBefore(item,child);
    }
  }
}",0.9979296066252588
100756,"private void moveMeta(final Entry<String,Element> entry,final Element root){
  final List<String> metaPath=moveTable.get(entry.getKey());
  if (metaPath == null) {
    return;
  }
  final Iterator<String> token=metaPath.iterator();
  Node parent=null;
  Node child=root;
  Node current=null;
  NodeList childElements;
  boolean createChild=false;
  while (token.hasNext()) {
    final String next=token.next();
    parent=child;
    final Integer nextIndex=compareTable.get(next);
    Integer currentIndex=null;
    childElements=parent.getChildNodes();
    for (int i=0; i < childElements.getLength(); i++) {
      String name=null;
      current=childElements.item(i);
      if (current.getNodeType() == Node.ELEMENT_NODE) {
        name=current.getNodeName();
      }
      if (name != null && current.getNodeName().equals(next)) {
        child=current;
        break;
      }
 else       if (name != null) {
        currentIndex=compareTable.get(name);
        if (currentIndex == null) {
          final String classValue=((Element)current).getAttribute(ATTRIBUTE_NAME_CLASS);
          String generalizedName=classValue.substring(classValue.indexOf(SLASH) + 1);
          generalizedName=generalizedName.substring(0,generalizedName.indexOf(STRING_BLANK));
          currentIndex=compareTable.get(generalizedName);
        }
        if (currentIndex == null) {
          logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",name).toString());
          break;
        }
        if (currentIndex.compareTo(nextIndex) > 0) {
          break;
        }
      }
    }
    if (child == parent) {
      child=parent.getOwnerDocument().createElement(next);
      final DitaClass cls=new DitaClass(""String_Node_Str"" + next + ""String_Node_Str"");
      ((Element)child).setAttribute(ATTRIBUTE_NAME_CLASS,cls.toString());
      if (current == null || currentIndex == null || nextIndex.compareTo(currentIndex) >= 0) {
        parent.appendChild(child);
        current=null;
      }
 else {
        parent.insertBefore(child,current);
        current=null;
      }
      createChild=true;
    }
  }
  final NodeList list=entry.getValue().getChildNodes();
  for (int i=0; i < list.getLength(); i++) {
    Node item=list.item(i);
    if ((i == 0 && createChild) || MapMetaReader.uniqueSet.contains(entry.getKey())) {
      item=parent.getOwnerDocument().importNode(item,true);
      parent.replaceChild(item,child);
      child=item;
    }
 else {
      item=parent.getOwnerDocument().importNode(item,true);
      ((Element)parent).insertBefore(item,child);
    }
  }
}","private void moveMeta(final Entry<String,Element> entry,final Element root){
  final List<String> metaPath=moveTable.get(entry.getKey());
  if (metaPath == null) {
    return;
  }
  final Iterator<String> token=metaPath.iterator();
  Node parent=null;
  Node child=root;
  Node current=null;
  NodeList childElements;
  boolean createChild=false;
  while (token.hasNext()) {
    final String next=token.next();
    parent=child;
    final Integer nextIndex=compareTable.get(next);
    Integer currentIndex=null;
    childElements=parent.getChildNodes();
    for (int i=0; i < childElements.getLength(); i++) {
      String name=null;
      current=childElements.item(i);
      if (current.getNodeType() == Node.ELEMENT_NODE) {
        name=current.getNodeName();
      }
      if (name != null && current.getNodeName().equals(next)) {
        child=current;
        break;
      }
 else       if (name != null) {
        currentIndex=compareTable.get(name);
        if (currentIndex == null) {
          final String classValue=((Element)current).getAttribute(ATTRIBUTE_NAME_CLASS);
          String generalizedName=classValue.substring(classValue.indexOf(SLASH) + 1);
          generalizedName=generalizedName.substring(0,generalizedName.indexOf(STRING_BLANK));
          currentIndex=compareTable.get(generalizedName);
        }
        if (currentIndex == null) {
          logger.error(MessageUtils.getInstance().getMessage(""String_Node_Str"",name).toString());
          break;
        }
        if (currentIndex.compareTo(nextIndex) > 0) {
          break;
        }
      }
    }
    if (child == parent) {
      child=parent.getOwnerDocument().createElement(next);
      final DitaClass cls=new DitaClass(""String_Node_Str"" + next + ""String_Node_Str"");
      ((Element)child).setAttribute(ATTRIBUTE_NAME_CLASS,cls.toString());
      if (current == null || currentIndex == null || nextIndex.compareTo(currentIndex) >= 0) {
        parent.appendChild(child);
        current=null;
      }
 else {
        parent.insertBefore(child,current);
        current=null;
      }
      createChild=true;
    }
  }
  final NodeList list=entry.getValue().getChildNodes();
  for (int i=0; i < list.getLength(); i++) {
    Node item=list.item(i);
    if ((i == 0 && createChild) || MapMetaReader.uniqueSet.contains(entry.getKey())) {
      item=parent.getOwnerDocument().importNode(item,true);
      parent.replaceChild(item,child);
      child=item;
    }
 else {
      item=parent.getOwnerDocument().importNode(item,true);
      parent.insertBefore(item,child);
    }
  }
}",0.997861170523041
100757,"/** 
 * Update href URI.
 * @param href href URI
 * @return updated href URI
 */
private URI updateHref(final URI href){
  final URI tempDirUri=tempDir.toURI();
  final URI filePath=tempDirUri.resolve(toURI(inputFile));
  final URI keyValue=tempDirUri.resolve(href);
  final URI updatedHref=URLUtils.getRelativePath(filePath,keyValue);
  return updatedHref;
}","/** 
 * Update href URI.
 * @param href href URI
 * @return updated href URI
 */
private URI updateHref(final URI href){
  final URI tempDirUri=tempDir.toURI();
  final URI filePath=tempDirUri.resolve(toURI(inputFile));
  final URI keyValue=tempDirUri.resolve(href);
  return URLUtils.getRelativePath(filePath,keyValue);
}",0.9251101321585904
100758,"/** 
 * Process attributes
 * @param qName element name
 * @param atts input attributes
 * @param res attributes to write to
 * @throws IOException if writing to output failed
 */
private void processAttributes(final String qName,final Attributes atts,final AttributesImpl res) throws IOException {
  final int attsLen=atts.getLength();
  for (int i=0; i < attsLen; i++) {
    final String attQName=atts.getQName(i);
    String attValue=getAttributeValue(qName,attQName,atts.getValue(i));
    if (ATTRIBUTE_NAME_CONREF.equals(attQName)) {
      XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_CONREF,replaceCONREF(atts).toString());
    }
 else     if (ATTRIBUTE_NAME_HREF.equals(attQName) || ATTRIBUTE_NAME_COPY_TO.equals(attQName)) {
      if (atts.getValue(ATTRIBUTE_NAME_SCOPE) == null || atts.getValue(ATTRIBUTE_NAME_SCOPE).equals(ATTR_SCOPE_VALUE_LOCAL)) {
        attValue=replaceHREF(attQName,atts).toString();
      }
      XMLUtils.addOrSetAttribute(res,attQName,attValue);
    }
 else {
      XMLUtils.addOrSetAttribute(res,atts.getURI(i),atts.getLocalName(i),attQName,atts.getType(i),attValue);
    }
  }
}","/** 
 * Process attributes
 * @param qName element name
 * @param atts input attributes
 * @param res attributes to write to
 * @throws IOException if writing to output failed
 */
private void processAttributes(final String qName,final Attributes atts,final AttributesImpl res){
  final int attsLen=atts.getLength();
  for (int i=0; i < attsLen; i++) {
    final String attQName=atts.getQName(i);
    String attValue=getAttributeValue(qName,attQName,atts.getValue(i));
    if (ATTRIBUTE_NAME_CONREF.equals(attQName)) {
      XMLUtils.addOrSetAttribute(res,ATTRIBUTE_NAME_CONREF,replaceCONREF(atts).toString());
    }
 else     if (ATTRIBUTE_NAME_HREF.equals(attQName) || ATTRIBUTE_NAME_COPY_TO.equals(attQName)) {
      if (atts.getValue(ATTRIBUTE_NAME_SCOPE) == null || atts.getValue(ATTRIBUTE_NAME_SCOPE).equals(ATTR_SCOPE_VALUE_LOCAL)) {
        attValue=replaceHREF(attQName,atts).toString();
      }
      XMLUtils.addOrSetAttribute(res,attQName,attValue);
    }
 else {
      XMLUtils.addOrSetAttribute(res,atts.getURI(i),atts.getLocalName(i),attQName,atts.getType(i),attValue);
    }
  }
}",0.9909584086799276
100759,"private List<IndexTerm> cloneIndextermList(final List<IndexTerm> termList){
  final List<IndexTerm> termListClone=new ArrayList<IndexTerm>(termList.size());
  if (termList != null && !termList.isEmpty()) {
    for (int i=0; i < termList.size(); i++) {
      termListClone.add(termList.get(i));
    }
  }
  return termListClone;
}","private List<IndexTerm> cloneIndextermList(final List<IndexTerm> termList){
  final List<IndexTerm> termListClone=new ArrayList<IndexTerm>(termList.size());
  if (termList != null && !termList.isEmpty()) {
    for (    IndexTerm aTermList : termList) {
      termListClone.add(aTermList);
    }
  }
  return termListClone;
}",0.667687595712098
100760,"private void outputIndexEntry(final IndexTerm term,final XMLStreamWriter serializer) throws XMLStreamException {
  final List<IndexTermTarget> targets=term.getTargetList();
  final int targetNum=targets.size();
  boolean foundIndexTerm=false;
  boolean foundIndexsee=false;
  String indexSeeRefTerm=null;
  final int termCloneNum=termCloneList.size();
  if (targets != null && !targets.isEmpty()) {
    for (int i=0; i < targetNum; i++) {
      final IndexTermTarget target=targets.get(i);
      final String targetUri=target.getTargetURI();
      final String targetName=target.getTargetName();
      if (targetUri == null) {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        serializer.writeEndElement();
      }
 else       if (targetName != null && targetName.trim().length() > 0) {
        if (term.getTermPrefix() != null || inIndexsee) {
          indexSeeRefTerm=term.getTermName();
          inIndexsee=true;
          foundIndexsee=true;
          for (int j=0; j < termCloneNum; j++) {
            final IndexTerm termClone=termCloneList.get(j);
            if (term.getTermName().equals(termClone.getTermName())) {
              foundIndexTerm=true;
              if (termClone.getTargetList().size() > 0) {
                serializer.writeStartElement(""String_Node_Str"");
                serializer.writeAttribute(""String_Node_Str"",replaceExtName(termClone.getTargetList().get(0).getTargetURI()));
                if (targetName.trim().length() > 0) {
                  serializer.writeAttribute(""String_Node_Str"",termClone.getTargetList().get(0).getTargetName());
                }
                serializer.writeEndElement();
              }
              termCloneList=termClone.getSubTerms();
              break;
            }
          }
          if (term.getSubTerms().size() == 0) {
            inIndexsee=false;
          }
        }
 else {
          serializer.writeStartElement(""String_Node_Str"");
          serializer.writeAttribute(""String_Node_Str"",replaceExtName(targetUri));
          if (targetName.trim().length() > 0) {
            serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
          }
          serializer.writeEndElement();
        }
      }
    }
    if (!foundIndexTerm && foundIndexsee && indexSeeRefTerm != null && !indexSeeRefTerm.equals(""String_Node_Str"")) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",indexSeeRefTerm.trim()).toString());
    }
  }
}","private void outputIndexEntry(final IndexTerm term,final XMLStreamWriter serializer) throws XMLStreamException {
  final List<IndexTermTarget> targets=term.getTargetList();
  final int targetNum=targets.size();
  boolean foundIndexTerm=false;
  boolean foundIndexsee=false;
  String indexSeeRefTerm=null;
  final int termCloneNum=termCloneList.size();
  if (targets != null && !targets.isEmpty()) {
    for (    final IndexTermTarget target : targets) {
      final String targetUri=target.getTargetURI();
      final String targetName=target.getTargetName();
      if (targetUri == null) {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        serializer.writeEndElement();
      }
 else       if (targetName != null && targetName.trim().length() > 0) {
        if (term.getTermPrefix() != null || inIndexsee) {
          indexSeeRefTerm=term.getTermName();
          inIndexsee=true;
          foundIndexsee=true;
          for (int j=0; j < termCloneNum; j++) {
            final IndexTerm termClone=termCloneList.get(j);
            if (term.getTermName().equals(termClone.getTermName())) {
              foundIndexTerm=true;
              if (termClone.getTargetList().size() > 0) {
                serializer.writeStartElement(""String_Node_Str"");
                serializer.writeAttribute(""String_Node_Str"",replaceExtName(termClone.getTargetList().get(0).getTargetURI()));
                if (targetName.trim().length() > 0) {
                  serializer.writeAttribute(""String_Node_Str"",termClone.getTargetList().get(0).getTargetName());
                }
                serializer.writeEndElement();
              }
              termCloneList=termClone.getSubTerms();
              break;
            }
          }
          if (term.getSubTerms().size() == 0) {
            inIndexsee=false;
          }
        }
 else {
          serializer.writeStartElement(""String_Node_Str"");
          serializer.writeAttribute(""String_Node_Str"",replaceExtName(targetUri));
          if (targetName.trim().length() > 0) {
            serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
          }
          serializer.writeEndElement();
        }
      }
    }
    if (!foundIndexTerm && foundIndexsee && indexSeeRefTerm != null && !indexSeeRefTerm.equals(""String_Node_Str"")) {
      logger.warn(MessageUtils.getInstance().getMessage(""String_Node_Str"",indexSeeRefTerm.trim()).toString());
    }
  }
}",0.9762376237623762
100761,"private void outputIndexEntryEclipseIndexsee(final IndexTerm term,final XMLStreamWriter serializer) throws XMLStreamException {
  final List<IndexTermTarget> targets=term.getTargetList();
  final int targetNum=targets.size();
  if (targets != null && !targets.isEmpty()) {
    for (int i=0; i < targetNum; i++) {
      final IndexTermTarget target=targets.get(i);
      final String targetUri=target.getTargetURI();
      final String targetName=target.getTargetName();
      if (targetUri == null) {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        serializer.writeEndElement();
      }
 else {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",replaceExtName(targetUri));
        if (targetName.trim().length() > 0) {
          serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        }
        serializer.writeEndElement();
      }
    }
  }
}","private void outputIndexEntryEclipseIndexsee(final IndexTerm term,final XMLStreamWriter serializer) throws XMLStreamException {
  final List<IndexTermTarget> targets=term.getTargetList();
  final int targetNum=targets.size();
  if (targets != null && !targets.isEmpty()) {
    for (    final IndexTermTarget target : targets) {
      final String targetUri=target.getTargetURI();
      final String targetName=target.getTargetName();
      if (targetUri == null) {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        serializer.writeEndElement();
      }
 else {
        serializer.writeStartElement(""String_Node_Str"");
        serializer.writeAttribute(""String_Node_Str"",replaceExtName(targetUri));
        if (targetName.trim().length() > 0) {
          serializer.writeAttribute(""String_Node_Str"",target.getTargetName());
        }
        serializer.writeEndElement();
      }
    }
  }
}",0.969
100762,"@Override public void processingInstruction(final String target,final String data) throws SAXException {
  String d=data;
  if (target.equals(PI_WORKDIR_TARGET)) {
    if (workdir != null) {
      try {
        if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
          d=workdir.getCanonicalPath();
        }
 else {
          d=UNIX_SEPARATOR + workdir.getCanonicalPath();
        }
      }
 catch (      final IOException e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
 else   if (target.equals(PI_WORKDIR_TARGET_URI)) {
    if (workdir != null) {
      d=workdir.toURI().toString();
    }
  }
 else   if (target.equals(PI_PATH2PROJ_TARGET)) {
    if (path2project != null) {
      d=path2project;
    }
  }
 else   if (target.equals(PI_PATH2PROJ_TARGET_URI)) {
    if (path2project != null) {
      d=URLUtils.correct(path2project,true);
    }
  }
  getContentHandler().processingInstruction(target,d);
}","@Override public void processingInstruction(final String target,final String data) throws SAXException {
  String d=data;
  if (target.equals(PI_WORKDIR_TARGET)) {
    if (workdir != null) {
      try {
        if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
          d=workdir.getCanonicalPath();
        }
 else {
          d=UNIX_SEPARATOR + workdir.getCanonicalPath();
        }
      }
 catch (      final IOException e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
 else   if (target.equals(PI_WORKDIR_TARGET_URI)) {
    if (workdir != null) {
      d=workdir.toURI().toString();
    }
  }
 else   if (target.equals(PI_PATH2PROJ_TARGET)) {
    if (path2project != null) {
      d=path2project;
    }
  }
 else   if (target.equals(PI_PATH2PROJ_TARGET_URI)) {
    if (path2project != null) {
      d=URLUtils.correct(FileUtils.separatorsToUnix(path2project),true);
    }
  }
  getContentHandler().processingInstruction(target,d);
}",0.9857578840284842
100763,"/** 
 * Get job configuration from Ant project reference or create new.
 * @param tempDir configuration directory 
 * @param project Ant project
 * @return job configuration
 */
public static Job getJob(final File tempDir,final Project project){
  Job job=project.getReference(ANT_REFERENCE_JOB);
  if (job != null && job.isStale(tempDir)) {
    project.log(""String_Node_Str"",Project.MSG_VERBOSE);
    job=null;
  }
  if (job == null) {
    try {
      job=new Job(tempDir);
    }
 catch (    final IOException ioe) {
      throw new BuildException(ioe);
    }
    project.addReference(ANT_REFERENCE_JOB,job);
  }
  return job;
}","/** 
 * Get job configuration from Ant project reference or create new.
 * @param tempDir configuration directory 
 * @param project Ant project
 * @return job configuration
 */
public static Job getJob(final File tempDir,final Project project){
  Job job=(Job)project.getReference(ANT_REFERENCE_JOB);
  if (job != null && job.isStale(tempDir)) {
    project.log(""String_Node_Str"",Project.MSG_VERBOSE);
    job=null;
  }
  if (job == null) {
    try {
      job=new Job(tempDir);
    }
 catch (    final IOException ioe) {
      throw new BuildException(ioe);
    }
    project.addReference(ANT_REFERENCE_JOB,job);
  }
  return job;
}",0.9960411718131432
100764,"/** 
 * @param event event
 * @see org.apache.tools.ant.BuildListener#messageLogged(org.apache.tools.ant.BuildEvent)
 */
@Override public void messageLogged(final BuildEvent event){
  final int priority=event.getPriority();
  if (priority > msgOutputLevel) {
    return;
  }
  final StringBuffer message=new StringBuffer();
  final Task eventTask=event.getTask();
  if (eventTask != null) {
    final String label=new StringBuffer().append(""String_Node_Str"").append(eventTask.getTaskName()).append(""String_Node_Str"").toString();
    BufferedReader r=null;
    try {
      String line;
      boolean first=true;
      r=new BufferedReader(new StringReader(event.getMessage()));
      line=r.readLine();
      while (line != null) {
        if (!first) {
          message.append(StringUtils.LINE_SEP);
        }
        first=false;
        message.append(label).append(line);
        line=r.readLine();
      }
    }
 catch (    final IOException e) {
      message.append(label).append(event.getMessage());
    }
 finally {
      try {
        r.close();
      }
 catch (      final IOException ioe) {
      }
    }
  }
 else {
    message.append(event.getMessage());
  }
  final String msg=message.toString();
  catchHHCError(msg);
  if (priority != Project.MSG_ERR) {
    boolean flag=false;
    if (eventTask != null && ""String_Node_Str"".equals(eventTask.getTaskName()) && msg.indexOf(""String_Node_Str"") == -1) {
      flag=true;
    }
    if (eventTask != null && ""String_Node_Str"".equals(eventTask.getTaskName())) {
      flag=true;
    }
    if (!flag) {
      printMessage(msg,out,priority);
    }
    logger.logInfo(msg);
  }
 else {
    if (eventTask != null && ""String_Node_Str"".equals(eventTask.getTaskName()) && msg.indexOf(""String_Node_Str"") == -1) {
      logger.logError(msg);
    }
 else {
      printMessage(msg,err,priority);
      logger.logError(msg);
    }
  }
}","/** 
 * @param event event
 * @see org.apache.tools.ant.BuildListener#messageLogged(org.apache.tools.ant.BuildEvent)
 */
@Override public void messageLogged(final BuildEvent event){
  final int priority=event.getPriority();
  if (priority > msgOutputLevel) {
    return;
  }
  final StringBuffer message=new StringBuffer();
  final Task eventTask=event.getTask();
  if (eventTask != null) {
    final String label=new StringBuffer().append(""String_Node_Str"").append(eventTask.getTaskName()).append(""String_Node_Str"").toString();
    BufferedReader r=null;
    try {
      String line;
      boolean first=true;
      r=new BufferedReader(new StringReader(event.getMessage()));
      line=r.readLine();
      while (line != null) {
        if (!first) {
          message.append(StringUtils.LINE_SEP);
        }
        first=false;
        message.append(label).append(line);
        line=r.readLine();
      }
    }
 catch (    final IOException e) {
      message.append(label).append(event.getMessage());
    }
 finally {
      if (r != null) {
        try {
          r.close();
        }
 catch (        final IOException ioe) {
        }
      }
    }
  }
 else {
    message.append(event.getMessage());
  }
  final String msg=message.toString();
  catchHHCError(msg);
  if (priority != Project.MSG_ERR) {
    boolean flag=false;
    if (eventTask != null && ""String_Node_Str"".equals(eventTask.getTaskName()) && msg.indexOf(""String_Node_Str"") == -1) {
      flag=true;
    }
    if (eventTask != null && ""String_Node_Str"".equals(eventTask.getTaskName())) {
      flag=true;
    }
    if (!flag) {
      printMessage(msg,out,priority);
    }
    logger.logInfo(msg);
  }
 else {
    if (eventTask != null && ""String_Node_Str"".equals(eventTask.getTaskName()) && msg.indexOf(""String_Node_Str"") == -1) {
      logger.logError(msg);
    }
 else {
      printMessage(msg,err,priority);
      logger.logError(msg);
    }
  }
}",0.9892360199527436
100765,"/** 
 * Parse filter file. From GenMapAndTopicListModule.
 * @return configured filter utility
 */
private FilterUtils parseFilterFile(final String ditavalFile){
  final FilterUtils filterUtils=new FilterUtils();
  filterUtils.setLogger(logger);
  if (ditavalFile != null) {
    final DitaValReader ditaValReader=new DitaValReader();
    ditaValReader.setLogger(logger);
    ditaValReader.initXMLReader(true);
    ditaValReader.read(new File(ditavalFile).getAbsoluteFile());
    filterUtils.setFilterMap(ditaValReader.getFilterMap());
  }
 else {
    filterUtils.setFilterMap(null);
  }
  return filterUtils;
}","/** 
 * Parse filter file. From GenMapAndTopicListModule.
 * @return configured filter utility
 */
private FilterUtils parseFilterFile(final String ditavalFile){
  final FilterUtils filterUtils=new FilterUtils();
  filterUtils.setLogger(logger);
  if (ditavalFile != null) {
    final DitaValReader ditaValReader=new DitaValReader();
    ditaValReader.setLogger(logger);
    ditaValReader.initXMLReader(true);
    ditaValReader.read(new File(ditavalFile).getAbsoluteFile());
    filterUtils.setFilterMap(ditaValReader.getFilterMap());
  }
 else {
    filterUtils.setFilterMap(Collections.EMPTY_MAP);
  }
  return filterUtils;
}",0.9797898140662894
100766,"/** 
 * Handle copy-to topics.
 */
private void handleCopyto(){
  final Map<File,File> tempMap=new HashMap<File,File>();
  for (  final File dst : copytoMap.keySet()) {
    final File src=copytoMap.get(dst);
    if (job.getFileInfoMap().containsKey(dst)) {
      tempMap.put(dst,src);
      final FileInfo orig=job.getFileInfoMap().get(src);
      final FileInfo.Builder b=new FileInfo.Builder(orig);
      b.uri(toURI(dst));
      final FileInfo f=b.build();
      job.add(f);
    }
  }
  copytoMap=tempMap;
  ditaSet.addAll(copytoMap.keySet());
  fullTopicSet.addAll(copytoMap.keySet());
  final Set<File> totalCopytoSources=new HashSet<File>(128);
  totalCopytoSources.addAll(copytoMap.values());
  totalCopytoSources.addAll(ignoredCopytoSourceSet);
  final Set<File> pureCopytoSources=new HashSet<File>(128);
  for (  final File src : totalCopytoSources) {
    if (!nonConrefCopytoTargetSet.contains(src) && !copytoMap.keySet().contains(src)) {
      pureCopytoSources.add(src);
    }
  }
  copytoSourceSet=pureCopytoSources;
  ditaSet.removeAll(pureCopytoSources);
  fullTopicSet.removeAll(pureCopytoSources);
}","/** 
 * Handle copy-to topics.
 */
private void handleCopyto(){
  final Map<File,File> tempMap=new HashMap<File,File>();
  for (  final File dst : copytoMap.keySet()) {
    final File src=copytoMap.get(dst);
    if (job.getFileInfoMap().containsKey(dst.getPath())) {
      tempMap.put(dst,src);
      final FileInfo orig=job.getFileInfoMap().get(src.getPath());
      final FileInfo.Builder b=new FileInfo.Builder(orig);
      b.uri(toURI(dst));
      final FileInfo f=b.build();
      job.add(f);
    }
  }
  copytoMap=tempMap;
  ditaSet.addAll(copytoMap.keySet());
  fullTopicSet.addAll(copytoMap.keySet());
  final Set<File> totalCopytoSources=new HashSet<File>(128);
  totalCopytoSources.addAll(copytoMap.values());
  totalCopytoSources.addAll(ignoredCopytoSourceSet);
  final Set<File> pureCopytoSources=new HashSet<File>(128);
  for (  final File src : totalCopytoSources) {
    if (!nonConrefCopytoTargetSet.contains(src) && !copytoMap.keySet().contains(src)) {
      pureCopytoSources.add(src);
    }
  }
  copytoSourceSet=pureCopytoSources;
  ditaSet.removeAll(pureCopytoSources);
  fullTopicSet.removeAll(pureCopytoSources);
}",0.9911190053285968
100767,"/** 
 * Categorize file. If   {@code file} parameter contains a pipe character, the pipe character is followedby the format of the file. TODO: Pass format as separate DITA class parameter.
 * @param file file system path with optional format
 */
private void categorizeResultFile(final Reference file){
  final String lcasefn=file.filename.toLowerCase();
  if (subsidiarySet.contains(lcasefn)) {
    return;
  }
  if (FileUtils.isDITAFile(lcasefn) && (file.format == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(file.format) || ATTR_FORMAT_VALUE_DITAMAP.equalsIgnoreCase(file.format))) {
    addToWaitList(new File(file.filename));
  }
 else   if (!FileUtils.isSupportedImageFile(lcasefn)) {
    htmlSet.add(new File(file.filename));
  }
  if (FileUtils.isSupportedImageFile(lcasefn)) {
    imageSet.add(new File(file.filename));
    try {
      final File image=new File(baseInputDir,file.filename).getCanonicalFile();
      if (!image.exists()) {
        logger.logWarn(MessageUtils.getInstance().getMessage(""String_Node_Str"",image.getAbsolutePath()).toString());
      }
    }
 catch (    final IOException e) {
      logger.logError(e.getMessage());
    }
  }
  if (FileUtils.isHTMLFile(lcasefn) || FileUtils.isResourceFile(lcasefn)) {
    htmlSet.add(new File(file.filename));
  }
}","/** 
 * Categorize file. If   {@code file} parameter contains a pipe character, the pipe character is followedby the format of the file. TODO: Pass format as separate DITA class parameter.
 * @param file file system path with optional format
 */
private void categorizeResultFile(final Reference file){
  final String lcasefn=file.filename.toLowerCase();
  if (subsidiarySet.contains(toFile(file.filename))) {
    return;
  }
  if (FileUtils.isDITAFile(lcasefn) && (file.format == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(file.format) || ATTR_FORMAT_VALUE_DITAMAP.equalsIgnoreCase(file.format))) {
    addToWaitList(new File(file.filename));
  }
 else   if (!FileUtils.isSupportedImageFile(lcasefn)) {
    htmlSet.add(new File(file.filename));
  }
  if (FileUtils.isSupportedImageFile(lcasefn)) {
    imageSet.add(new File(file.filename));
    try {
      final File image=new File(baseInputDir,file.filename).getCanonicalFile();
      if (!image.exists()) {
        logger.logWarn(MessageUtils.getInstance().getMessage(""String_Node_Str"",image.getAbsolutePath()).toString());
      }
    }
 catch (    final IOException e) {
      logger.logError(e.getMessage());
    }
  }
  if (FileUtils.isHTMLFile(lcasefn) || FileUtils.isResourceFile(lcasefn)) {
    htmlSet.add(new File(file.filename));
  }
}",0.9892058596761758
100768,"private void updateReltable(final Element elem){
  final String hrefValue=elem.getAttribute(ATTRIBUTE_NAME_HREF);
  if (hrefValue.length() != 0) {
    if (changeTable.containsKey(resolveFile(filePath,hrefValue))) {
      String resulthrefValue=null;
      final String fragment=getFragment(hrefValue);
      if (fragment != null) {
        resulthrefValue=getRelativeUnixPath(filePath + UNIX_SEPARATOR + FILE_NAME_STUB_DITAMAP,resolveFile(filePath,hrefValue).getPath()) + fragment;
      }
 else {
        resulthrefValue=getRelativeUnixPath(filePath + UNIX_SEPARATOR + FILE_NAME_STUB_DITAMAP,resolveFile(filePath,hrefValue).getPath());
      }
      elem.setAttribute(ATTRIBUTE_NAME_HREF,resulthrefValue);
    }
  }
  final NodeList children=elem.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node current=children.item(i);
    if (current.getNodeType() == Node.ELEMENT_NODE) {
      final Element currentElem=(Element)current;
      final String classValue=currentElem.getAttribute(ATTRIBUTE_NAME_CLASS);
      if (MAP_TOPICREF.matches(classValue)) {
      }
    }
  }
}","private void updateReltable(final Element elem){
  final String hrefValue=elem.getAttribute(ATTRIBUTE_NAME_HREF);
  if (hrefValue.length() != 0) {
    if (changeTable.containsKey(resolveFile(filePath,hrefValue).getPath())) {
      String resulthrefValue=null;
      final String fragment=getFragment(hrefValue);
      if (fragment != null) {
        resulthrefValue=getRelativeUnixPath(filePath + UNIX_SEPARATOR + FILE_NAME_STUB_DITAMAP,resolveFile(filePath,hrefValue).getPath()) + fragment;
      }
 else {
        resulthrefValue=getRelativeUnixPath(filePath + UNIX_SEPARATOR + FILE_NAME_STUB_DITAMAP,resolveFile(filePath,hrefValue).getPath());
      }
      elem.setAttribute(ATTRIBUTE_NAME_HREF,resulthrefValue);
    }
  }
  final NodeList children=elem.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node current=children.item(i);
    if (current.getNodeType() == Node.ELEMENT_NODE) {
      final Element currentElem=(Element)current;
      final String classValue=currentElem.getAttribute(ATTRIBUTE_NAME_CLASS);
      if (MAP_TOPICREF.matches(classValue)) {
      }
    }
  }
}",0.995483288166215
100769,"private void processChildTopicref(final Node node){
  final NodeList children=node.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node current=children.item(i);
    if (current.getNodeType() == Node.ELEMENT_NODE) {
      final Element currentElem=(Element)current;
      final String classValue=currentElem.getAttribute(ATTRIBUTE_NAME_CLASS);
      final String hrefValue=currentElem.getAttribute(ATTRIBUTE_NAME_HREF);
      final String xtrfValue=currentElem.getAttribute(ATTRIBUTE_NAME_XTRF);
      if (MAP_TOPICREF.matches(classValue)) {
        if ((hrefValue.length() != 0 && !ATTR_XTRF_VALUE_GENERATED.equals(xtrfValue) && !resolveFile(filePath,hrefValue).equals(changeTable.get(resolveFile(filePath,hrefValue)))) || MAPGROUP_D_TOPICHEAD.matches(classValue)) {
          processTopicref(currentElem);
        }
 else         if (hrefValue.length() == 0) {
          processTopicref(currentElem);
        }
      }
    }
  }
}","private void processChildTopicref(final Node node){
  final NodeList children=node.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node current=children.item(i);
    if (current.getNodeType() == Node.ELEMENT_NODE) {
      final Element currentElem=(Element)current;
      final String classValue=currentElem.getAttribute(ATTRIBUTE_NAME_CLASS);
      final String hrefValue=currentElem.getAttribute(ATTRIBUTE_NAME_HREF);
      final String xtrfValue=currentElem.getAttribute(ATTRIBUTE_NAME_XTRF);
      if (MAP_TOPICREF.matches(classValue)) {
        if ((hrefValue.length() != 0 && !ATTR_XTRF_VALUE_GENERATED.equals(xtrfValue) && !resolveFile(filePath,hrefValue).getPath().equals(changeTable.get(resolveFile(filePath,hrefValue).getPath()))) || MAPGROUP_D_TOPICHEAD.matches(classValue)) {
          processTopicref(currentElem);
        }
 else         if (hrefValue.length() == 0) {
          processTopicref(currentElem);
        }
      }
    }
  }
}",0.9896907216494846
100770,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  String domains=null;
  final Properties params=new Properties();
  final String printValue=atts.getValue(ATTRIBUTE_NAME_PRINT);
  final String processingRole=atts.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  final URI href=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
  final String scope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  if (processingRole != null) {
    processRoleStack.push(processingRole);
    processRoleLevel++;
    if (ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)) {
    }
 else     if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {
      if (href != null) {
        resourceOnlySet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
      }
    }
 else     if (ATTR_PROCESSING_ROLE_VALUE_NORMAL.equals(processingRole)) {
      if (href != null) {
        crossSet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
      }
    }
  }
 else   if (processRoleLevel > 0) {
    processRoleLevel++;
    if (ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)) {
    }
 else     if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleStack.peek())) {
      if (href != null) {
        resourceOnlySet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
      }
    }
 else     if (ATTR_PROCESSING_ROLE_VALUE_NORMAL.equals(processRoleStack.peek())) {
      if (href != null) {
        crossSet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
      }
    }
  }
 else {
    if (href != null) {
      crossSet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
    }
  }
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  if (classValue != null) {
    if (TOPIC_TOPIC.matches(classValue)) {
      topicId=atts.getValue(ATTRIBUTE_NAME_ID);
      final String filename=FileUtils.getRelativeUnixPath(rootFilePath.getAbsolutePath(),currentFile.getAbsolutePath());
      for (      final ExportAnchor e : resultList) {
        if (e.topicids.contains(filename + QUESTION)) {
          e.topicids.add(topicId);
          e.topicids.remove(filename + QUESTION);
        }
      }
    }
    if (FileUtils.isDITAMapFile(currentFile.getName()) && rootFilePath.equals(currentFile) && MAP_MAP.matches(classValue)&& INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
      String pluginId=atts.getValue(ATTRIBUTE_NAME_ID);
      if (pluginId == null) {
        pluginId=""String_Node_Str"";
      }
      final Set<String> set=StringUtils.restoreSet(pluginId);
      pluginMap.put(""String_Node_Str"",set);
    }
    if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
      if (MAP_TOPICMETA.matches(classValue) || TOPIC_PROLOG.matches(classValue)) {
        topicMetaSet.add(qName);
      }
      if (DELAY_D_EXPORTANCHORS.matches(classValue)) {
        hasExport=true;
        if (FileUtils.isDITAMapFile(currentFile.getName())) {
          URI editedHref=null;
          if (topicHref != null && topicHref.getPath().endsWith(FILE_EXTENSION_XML)) {
            editedHref=toURI(topicHref.toString().replace(FILE_EXTENSION_XML,FILE_EXTENSION_DITA));
          }
 else {
            editedHref=topicHref;
          }
          currentExportAnchor=new ExportAnchor(editedHref);
          currentExportAnchor.topicids.add(topicId);
        }
 else         if (FileUtils.isDITATopicFile(currentFile.getName())) {
          URI filename=toURI(FileUtils.getRelativeUnixPath(rootFilePath.getAbsolutePath(),currentFile.getAbsolutePath()));
          if (filename.toString().endsWith(FILE_EXTENSION_XML)) {
            filename=toURI(filename.toString().replace(FILE_EXTENSION_XML,FILE_EXTENSION_DITA));
          }
          currentExportAnchor=new ExportAnchor(filename);
          currentExportAnchor.topicids.add(topicId);
          shouldAppendEndTag=true;
        }
      }
 else       if (DELAY_D_ANCHORKEY.matches(classValue)) {
        final String keyref=atts.getValue(ATTRIBUTE_NAME_KEYREF);
        currentExportAnchor.keys.add(keyref);
      }
 else       if (DELAY_D_ANCHORID.matches(classValue)) {
        final String id=atts.getValue(ATTRIBUTE_NAME_ID);
        if (FileUtils.isDITAMapFile(currentFile.getName())) {
          if (!topicId.equals(id)) {
            currentExportAnchor.ids.add(id);
          }
        }
 else         if (FileUtils.isDITATopicFile(currentFile.getName())) {
          if (!topicId.equals(id)) {
            currentExportAnchor.ids.add(id);
          }
        }
      }
    }
  }
  if (SUBJECTSCHEME_SUBJECTSCHEME.matches(classValue)) {
    if (schemeRelationGraph == null) {
      schemeRelationGraph=new LinkedHashMap<File,Set<File>>();
    }
    Set<File> children=schemeRelationGraph.get(new File(""String_Node_Str""));
    if (children == null || children.isEmpty()) {
      children=new LinkedHashSet<File>();
    }
    children.add(currentFile.getAbsoluteFile());
    schemeRelationGraph.put(new File(""String_Node_Str""),children);
    schemeRefSet.add(FileUtils.getRelativePath(rootFilePath.getAbsoluteFile(),currentFile.getAbsoluteFile()));
  }
 else   if (SUBJECTSCHEME_SCHEMEREF.matches(classValue)) {
    Set<File> children=schemeRelationGraph.get(currentFile.getAbsoluteFile());
    if (children == null) {
      children=new LinkedHashSet<File>();
      schemeRelationGraph.put(currentFile.getAbsoluteFile(),children);
    }
    if (href != null) {
      children.add(FileUtils.resolveFile(rootDir.getAbsoluteFile(),toFile(href).getPath()));
    }
  }
  if (foreignLevel > 0) {
    foreignLevel++;
    return;
  }
 else   if (classValue != null && (TOPIC_FOREIGN.matches(classValue) || TOPIC_UNKNOWN.matches(classValue))) {
    foreignLevel++;
  }
  if (chunkLevel > 0) {
    chunkLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null) {
    chunkLevel++;
  }
  if (relTableLevel > 0) {
    relTableLevel++;
  }
 else   if (classValue != null && MAP_RELTABLE.matches(classValue)) {
    relTableLevel++;
  }
  if (chunkToNavLevel > 0) {
    chunkToNavLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).indexOf(""String_Node_Str"") != -1) {
    chunkToNavLevel++;
  }
  if (topicGroupLevel > 0) {
    topicGroupLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CLASS) != null && atts.getValue(ATTRIBUTE_NAME_CLASS).contains(MAPGROUP_D_TOPICGROUP.matcher)) {
    topicGroupLevel++;
  }
  if (classValue == null && !ELEMENT_NAME_DITA.equals(localName)) {
    logger.logInfo(MessageUtils.getInstance().getMessage(""String_Node_Str"",localName).toString());
  }
  if (classValue != null && TOPIC_TOPIC.matches(classValue)) {
    domains=atts.getValue(ATTRIBUTE_NAME_DOMAINS);
    if (domains == null) {
      logger.logInfo(MessageUtils.getInstance().getMessage(""String_Node_Str"",localName).toString());
    }
 else {
      props=StringUtils.getExtProps(domains);
    }
  }
  if (insideExcludedElement) {
    ++excludedLevel;
    return;
  }
  if (filterUtils.needExclude(atts,props)) {
    insideExcludedElement=true;
    ++excludedLevel;
    return;
  }
  if (classValue != null) {
    if ((MAP_MAP.matches(classValue)) || (TOPIC_TITLE.matches(classValue))) {
      isValidInput=true;
    }
 else     if (TOPIC_OBJECT.matches(classValue)) {
      parseAttribute(atts,ATTRIBUTE_NAME_DATA);
    }
  }
  topicref:   if (job.getOnlyTopicInMap() && this.canResolved()) {
    if (MAP_TOPICREF.matches(classValue)) {
      final URI hrefValue=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
      final URI conrefValue=toURI(atts.getValue(ATTRIBUTE_NAME_CONREF));
      if (hrefValue != null && !hrefValue.toString().isEmpty()) {
        final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
        if (ATTR_SCOPE_VALUE_EXTERNAL.equals(attrScope) || ATTR_SCOPE_VALUE_PEER.equals(attrScope) || hrefValue.toString().indexOf(COLON_DOUBLE_SLASH) != -1 || hrefValue.toString().startsWith(SHARP)) {
          break topicref;
        }
        final File target=toFile(hrefValue);
        String fileName=null;
        if (target.isAbsolute()) {
          fileName=FileUtils.getRelativeUnixPath(rootFilePath.getAbsolutePath(),toFile(hrefValue).getPath());
        }
        fileName=FileUtils.normalizeDirectory(currentDir,toFile(hrefValue).getPath()).getPath();
        fileName=FileUtils.separatorsToUnix(fileName);
        final boolean canParse=parseBranch(atts,hrefValue,fileName);
        if (!canParse) {
          break topicref;
        }
 else {
          topicrefStack.push(localName);
        }
      }
 else       if (conrefValue != null && !conrefValue.toString().isEmpty()) {
        final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
        if (ATTR_SCOPE_VALUE_EXTERNAL.equals(attrScope) || ATTR_SCOPE_VALUE_PEER.equals(attrScope) || conrefValue.toString().indexOf(COLON_DOUBLE_SLASH) != -1 || conrefValue.toString().startsWith(SHARP)) {
          break topicref;
        }
        final File target=new File(conrefValue);
        String fileName=null;
        if (target.isAbsolute()) {
          fileName=FileUtils.getRelativeUnixPath(rootFilePath.getAbsolutePath(),toFile(conrefValue).getPath());
        }
        fileName=FileUtils.normalizeDirectory(currentDir,toFile(conrefValue).getPath()).getPath();
        fileName=FileUtils.separatorsToUnix(fileName);
        final boolean canParse=parseBranch(atts,conrefValue,fileName);
        if (!canParse) {
          break topicref;
        }
 else {
          topicrefStack.push(localName);
        }
      }
    }
  }
  parseAttribute(atts,ATTRIBUTE_NAME_CONREF);
  parseAttribute(atts,ATTRIBUTE_NAME_HREF);
  parseAttribute(atts,ATTRIBUTE_NAME_COPY_TO);
  parseAttribute(atts,ATTRIBUTE_NAME_IMG);
  parseAttribute(atts,ATTRIBUTE_NAME_CONACTION);
  parseAttribute(atts,ATTRIBUTE_NAME_KEYS);
  parseAttribute(atts,ATTRIBUTE_NAME_CONKEYREF);
  parseAttribute(atts,ATTRIBUTE_NAME_KEYREF);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  String domains=null;
  final String processingRole=atts.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  final URI href=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
  final String scope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  if (processingRole != null) {
    processRoleStack.push(processingRole);
    processRoleLevel++;
    if (ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)) {
    }
 else     if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {
      if (href != null) {
        resourceOnlySet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
      }
    }
 else     if (ATTR_PROCESSING_ROLE_VALUE_NORMAL.equals(processingRole)) {
      if (href != null) {
        crossSet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
      }
    }
  }
 else   if (processRoleLevel > 0) {
    processRoleLevel++;
    if (ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)) {
    }
 else     if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleStack.peek())) {
      if (href != null) {
        resourceOnlySet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
      }
    }
 else     if (ATTR_PROCESSING_ROLE_VALUE_NORMAL.equals(processRoleStack.peek())) {
      if (href != null) {
        crossSet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
      }
    }
  }
 else {
    if (href != null) {
      crossSet.add(FileUtils.resolveFile(currentDir,toFile(href).getPath()));
    }
  }
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  if (classValue != null) {
    if (TOPIC_TOPIC.matches(classValue)) {
      topicId=atts.getValue(ATTRIBUTE_NAME_ID);
      final String filename=FileUtils.getRelativeUnixPath(rootFilePath.getAbsolutePath(),currentFile.getAbsolutePath());
      for (      final ExportAnchor e : resultList) {
        if (e.topicids.contains(filename + QUESTION)) {
          e.topicids.add(topicId);
          e.topicids.remove(filename + QUESTION);
        }
      }
    }
    if (FileUtils.isDITAMapFile(currentFile.getName()) && rootFilePath.equals(currentFile) && MAP_MAP.matches(classValue)&& INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
      String pluginId=atts.getValue(ATTRIBUTE_NAME_ID);
      if (pluginId == null) {
        pluginId=""String_Node_Str"";
      }
      final Set<String> set=StringUtils.restoreSet(pluginId);
      pluginMap.put(""String_Node_Str"",set);
    }
    if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
      if (MAP_TOPICMETA.matches(classValue) || TOPIC_PROLOG.matches(classValue)) {
        topicMetaSet.add(qName);
      }
      if (DELAY_D_EXPORTANCHORS.matches(classValue)) {
        hasExport=true;
        if (FileUtils.isDITAMapFile(currentFile.getName())) {
          URI editedHref=null;
          if (topicHref != null && topicHref.getPath().endsWith(FILE_EXTENSION_XML)) {
            editedHref=toURI(topicHref.toString().replace(FILE_EXTENSION_XML,FILE_EXTENSION_DITA));
          }
 else {
            editedHref=topicHref;
          }
          currentExportAnchor=new ExportAnchor(editedHref);
          currentExportAnchor.topicids.add(topicId);
        }
 else         if (FileUtils.isDITATopicFile(currentFile.getName())) {
          URI filename=toURI(FileUtils.getRelativeUnixPath(rootFilePath.getAbsolutePath(),currentFile.getAbsolutePath()));
          if (filename.toString().endsWith(FILE_EXTENSION_XML)) {
            filename=toURI(filename.toString().replace(FILE_EXTENSION_XML,FILE_EXTENSION_DITA));
          }
          currentExportAnchor=new ExportAnchor(filename);
          currentExportAnchor.topicids.add(topicId);
          shouldAppendEndTag=true;
        }
      }
 else       if (DELAY_D_ANCHORKEY.matches(classValue)) {
        final String keyref=atts.getValue(ATTRIBUTE_NAME_KEYREF);
        currentExportAnchor.keys.add(keyref);
      }
 else       if (DELAY_D_ANCHORID.matches(classValue)) {
        final String id=atts.getValue(ATTRIBUTE_NAME_ID);
        if (FileUtils.isDITAMapFile(currentFile.getName())) {
          if (!topicId.equals(id)) {
            currentExportAnchor.ids.add(id);
          }
        }
 else         if (FileUtils.isDITATopicFile(currentFile.getName())) {
          if (!topicId.equals(id)) {
            currentExportAnchor.ids.add(id);
          }
        }
      }
    }
  }
  if (SUBJECTSCHEME_SUBJECTSCHEME.matches(classValue)) {
    if (schemeRelationGraph == null) {
      schemeRelationGraph=new LinkedHashMap<File,Set<File>>();
    }
    Set<File> children=schemeRelationGraph.get(new File(""String_Node_Str""));
    if (children == null || children.isEmpty()) {
      children=new LinkedHashSet<File>();
    }
    children.add(currentFile.getAbsoluteFile());
    schemeRelationGraph.put(new File(""String_Node_Str""),children);
    schemeRefSet.add(FileUtils.getRelativePath(rootFilePath.getAbsoluteFile(),currentFile.getAbsoluteFile()));
  }
 else   if (SUBJECTSCHEME_SCHEMEREF.matches(classValue)) {
    Set<File> children=schemeRelationGraph.get(currentFile.getAbsoluteFile());
    if (children == null) {
      children=new LinkedHashSet<File>();
      schemeRelationGraph.put(currentFile.getAbsoluteFile(),children);
    }
    if (href != null) {
      children.add(FileUtils.resolveFile(rootDir.getAbsoluteFile(),toFile(href).getPath()));
    }
  }
  if (foreignLevel > 0) {
    foreignLevel++;
    return;
  }
 else   if (classValue != null && (TOPIC_FOREIGN.matches(classValue) || TOPIC_UNKNOWN.matches(classValue))) {
    foreignLevel++;
  }
  if (chunkLevel > 0) {
    chunkLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null) {
    chunkLevel++;
  }
  if (relTableLevel > 0) {
    relTableLevel++;
  }
 else   if (classValue != null && MAP_RELTABLE.matches(classValue)) {
    relTableLevel++;
  }
  if (chunkToNavLevel > 0) {
    chunkToNavLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).indexOf(""String_Node_Str"") != -1) {
    chunkToNavLevel++;
  }
  if (topicGroupLevel > 0) {
    topicGroupLevel++;
  }
 else   if (atts.getValue(ATTRIBUTE_NAME_CLASS) != null && atts.getValue(ATTRIBUTE_NAME_CLASS).contains(MAPGROUP_D_TOPICGROUP.matcher)) {
    topicGroupLevel++;
  }
  if (classValue == null && !ELEMENT_NAME_DITA.equals(localName)) {
    logger.logInfo(MessageUtils.getInstance().getMessage(""String_Node_Str"",localName).toString());
  }
  if (classValue != null && TOPIC_TOPIC.matches(classValue)) {
    domains=atts.getValue(ATTRIBUTE_NAME_DOMAINS);
    if (domains == null) {
      logger.logInfo(MessageUtils.getInstance().getMessage(""String_Node_Str"",localName).toString());
    }
 else {
      props=StringUtils.getExtProps(domains);
    }
  }
  if (insideExcludedElement) {
    ++excludedLevel;
    return;
  }
  if (filterUtils.needExclude(atts,props)) {
    insideExcludedElement=true;
    ++excludedLevel;
    return;
  }
  if (classValue != null) {
    if ((MAP_MAP.matches(classValue)) || (TOPIC_TITLE.matches(classValue))) {
      isValidInput=true;
    }
 else     if (TOPIC_OBJECT.matches(classValue)) {
      parseAttribute(atts,ATTRIBUTE_NAME_DATA);
    }
  }
  topicref:   if (job.getOnlyTopicInMap() && this.canResolved()) {
    if (MAP_TOPICREF.matches(classValue)) {
      final URI hrefValue=toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
      final URI conrefValue=toURI(atts.getValue(ATTRIBUTE_NAME_CONREF));
      if (hrefValue != null && !hrefValue.toString().isEmpty()) {
        final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
        if (ATTR_SCOPE_VALUE_EXTERNAL.equals(attrScope) || ATTR_SCOPE_VALUE_PEER.equals(attrScope) || hrefValue.toString().indexOf(COLON_DOUBLE_SLASH) != -1 || hrefValue.toString().startsWith(SHARP)) {
          break topicref;
        }
        final File target=toFile(hrefValue);
        String fileName=null;
        if (target.isAbsolute()) {
          fileName=FileUtils.getRelativeUnixPath(rootFilePath.getAbsolutePath(),toFile(hrefValue).getPath());
        }
        fileName=FileUtils.normalizeDirectory(currentDir,toFile(hrefValue).getPath()).getPath();
        fileName=FileUtils.separatorsToUnix(fileName);
        final boolean canParse=parseBranch(atts,hrefValue,fileName);
        if (!canParse) {
          break topicref;
        }
 else {
          topicrefStack.push(localName);
        }
      }
 else       if (conrefValue != null && !conrefValue.toString().isEmpty()) {
        final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
        if (ATTR_SCOPE_VALUE_EXTERNAL.equals(attrScope) || ATTR_SCOPE_VALUE_PEER.equals(attrScope) || conrefValue.toString().indexOf(COLON_DOUBLE_SLASH) != -1 || conrefValue.toString().startsWith(SHARP)) {
          break topicref;
        }
        final File target=new File(conrefValue);
        String fileName=null;
        if (target.isAbsolute()) {
          fileName=FileUtils.getRelativeUnixPath(rootFilePath.getAbsolutePath(),toFile(conrefValue).getPath());
        }
        fileName=FileUtils.normalizeDirectory(currentDir,toFile(conrefValue).getPath()).getPath();
        fileName=FileUtils.separatorsToUnix(fileName);
        final boolean canParse=parseBranch(atts,conrefValue,fileName);
        if (!canParse) {
          break topicref;
        }
 else {
          topicrefStack.push(localName);
        }
      }
    }
  }
  parseAttribute(atts,ATTRIBUTE_NAME_CONREF);
  parseAttribute(atts,ATTRIBUTE_NAME_HREF);
  parseAttribute(atts,ATTRIBUTE_NAME_COPY_TO);
  parseAttribute(atts,ATTRIBUTE_NAME_IMG);
  parseAttribute(atts,ATTRIBUTE_NAME_CONACTION);
  parseAttribute(atts,ATTRIBUTE_NAME_KEYS);
  parseAttribute(atts,ATTRIBUTE_NAME_CONKEYREF);
  parseAttribute(atts,ATTRIBUTE_NAME_KEYREF);
}",0.9945555385946168
100771,"@Override public void endElement(final String uri,final String localName,final String qName) throws SAXException {
  if (processRoleLevel > 0) {
    String role=processRoleStack.peek();
    if (processRoleLevel == processRoleStack.size()) {
      role=processRoleStack.pop();
    }
    processRoleLevel--;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(role)) {
      return;
    }
  }
  if (indexTermSpecList.contains(localName)) {
    final IndexTerm term=termStack.pop();
    if (term.getTermName() == null || term.getTermName().trim().equals(""String_Node_Str"")) {
      if (term.getEndAttribute() != null && !term.hasSubTerms()) {
        return;
      }
 else {
        term.setTermName(""String_Node_Str"");
        logger.logWarn(MessageUtils.getInstance().getMessage(""String_Node_Str"").toString());
      }
    }
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermName());
    }
    if (term.isLeaf()) {
      final IndexTermTarget target=genTarget();
      term.addTarget(target);
    }
    if (termStack.empty()) {
      indexTermList.add(term);
    }
 else {
      final IndexTerm parentTerm=termStack.peek();
      parentTerm.addSubTerm(term);
    }
  }
  if (indexSeeSpecList.contains(localName) || indexSeeAlsoSpecList.contains(localName)) {
    final IndexTerm term=termStack.pop();
    final IndexTerm parentTerm=termStack.peek();
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermFullName());
    }
    term.addTarget(genTarget());
    parentTerm.addSubTerm(term);
  }
  if (titleSpecList.contains(localName)) {
    inTitleElement=false;
    if (!topicIdStack.empty() && !titleMap.containsKey(topicIdStack.empty())) {
      if (titleMap.size() == 0) {
        defaultTitle=title;
      }
      titleMap.put(topicIdStack.peek(),title);
    }
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=false;
  }
  if (topicSpecList.contains(localName)) {
    topicIdStack.pop();
  }
}","@Override public void endElement(final String uri,final String localName,final String qName) throws SAXException {
  if (processRoleLevel > 0) {
    String role=processRoleStack.peek();
    if (processRoleLevel == processRoleStack.size()) {
      role=processRoleStack.pop();
    }
    processRoleLevel--;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(role)) {
      return;
    }
  }
  if (indexTermSpecList.contains(localName)) {
    final IndexTerm term=termStack.pop();
    if (term.getTermName() == null || term.getTermName().trim().equals(""String_Node_Str"")) {
      if (term.getEndAttribute() != null && !term.hasSubTerms()) {
        return;
      }
 else {
        term.setTermName(""String_Node_Str"");
        logger.logWarn(MessageUtils.getInstance().getMessage(""String_Node_Str"").toString());
      }
    }
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermName());
    }
    if (term.isLeaf()) {
      final IndexTermTarget target=genTarget();
      term.addTarget(target);
    }
    if (termStack.empty()) {
      indexTermList.add(term);
    }
 else {
      final IndexTerm parentTerm=termStack.peek();
      parentTerm.addSubTerm(term);
    }
  }
  if (indexSeeSpecList.contains(localName) || indexSeeAlsoSpecList.contains(localName)) {
    final IndexTerm term=termStack.pop();
    final IndexTerm parentTerm=termStack.peek();
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermFullName());
    }
    term.addTarget(genTarget());
    parentTerm.addSubTerm(term);
  }
  if (titleSpecList.contains(localName)) {
    inTitleElement=false;
    if (!topicIdStack.empty() && !titleMap.containsKey(topicIdStack.peek())) {
      if (titleMap.size() == 0) {
        defaultTitle=title;
      }
      titleMap.put(topicIdStack.peek(),title);
    }
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=false;
  }
  if (topicSpecList.contains(localName)) {
    topicIdStack.pop();
  }
}",0.99770583736936
100772,"private void addNamespace(final String uri,final String prefix,final QName current){
  if (uri.equals(NULL_NS_URI) && !prefix.equals(DEFAULT_NS_PREFIX)) {
    throw new IllegalArgumentException(""String_Node_Str"" + prefix + ""String_Node_Str"");
  }
  if (uri != null) {
    boolean found=false;
    stack:     for (    final QName e : elementStack) {
      for (      final NamespaceMapping m : e.mappings) {
        if (m.uri.equals(uri) && m.prefix.equals(prefix)) {
          found=true;
          break stack;
        }
 else         if (m.prefix.equals(prefix)) {
          break stack;
        }
      }
    }
    if (!found && uri.equals(NULL_NS_URI) && prefix.equals(DEFAULT_NS_PREFIX)) {
      return;
    }
    current.mappings.add(new NamespaceMapping(prefix,uri,!found));
  }
}","private void addNamespace(final String uri,final String prefix,final QName current){
  if (uri != null && uri.equals(NULL_NS_URI) && !prefix.equals(DEFAULT_NS_PREFIX)) {
    throw new IllegalArgumentException(""String_Node_Str"" + prefix + ""String_Node_Str"");
  }
  if (uri != null) {
    boolean found=false;
    stack:     for (    final QName e : elementStack) {
      for (      final NamespaceMapping m : e.mappings) {
        if (m.uri.equals(uri) && m.prefix.equals(prefix)) {
          found=true;
          break stack;
        }
 else         if (m.prefix.equals(prefix)) {
          break stack;
        }
      }
    }
    if (!found && uri.equals(NULL_NS_URI) && prefix.equals(DEFAULT_NS_PREFIX)) {
      return;
    }
    current.mappings.add(new NamespaceMapping(prefix,uri,!found));
  }
}",0.9905601006922592
100773,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final String idValue=atts.getValue(ATTRIBUTE_NAME_ID);
  if (skip && skipLevel > 0) {
    skipLevel++;
  }
  try {
    if (classValue != null && TOPIC_TOPIC.matches(classValue)) {
      topicSpecSet.add(qName);
      final String id=atts.getValue(ATTRIBUTE_NAME_ID);
      final Element element=DITAAttrUtils.getInstance().searchForNode(topicDoc,id,ATTRIBUTE_NAME_ID,TOPIC_TOPIC.matcher);
      if (separate && include && !ATTR_CHUNK_VALUE_SELECT_TOPIC.equals(selectMethod)) {
        fileWriterStack.push(output);
        outputFileNameStack.push(outputFile);
        File newFileName=FileUtils.resolveFile(filePath,idValue + FILE_EXTENSION_DITA);
        if (StringUtils.isEmptyString(idValue) || newFileName.exists()) {
          final File t=newFileName;
          newFileName=FileUtils.resolveFile(filePath,generateFilename());
          conflictTable.put(newFileName.getPath(),t.getPath());
        }
        outputFile=newFileName;
        output=new OutputStreamWriter(new FileOutputStream(newFileName),UTF8);
        writeStartDocument(output);
        if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
          writeProcessingInstruction(output,PI_WORKDIR_TARGET,filePath.getAbsolutePath());
        }
 else {
          writeProcessingInstruction(output,PI_WORKDIR_TARGET,UNIX_SEPARATOR + filePath);
        }
        writeProcessingInstruction(output,PI_WORKDIR_TARGET_URI,filePath.toURI().toString());
        changeTable.put(newFileName.getPath(),newFileName.getPath());
        if (idValue != null) {
          changeTable.put(setFragment(currentParsingFile.getPath(),idValue),setFragment(newFileName.getPath(),idValue));
        }
 else {
          changeTable.put(currentParsingFile.getPath(),newFileName.getPath());
        }
        final Element newChild=elem.getOwnerDocument().createElement(MAP_TOPICREF.localName);
        newChild.setAttribute(ATTRIBUTE_NAME_HREF,toURI(FileUtils.getRelativePath(new File(filePath,FILE_NAME_STUB_DITAMAP),newFileName)).toString());
        newChild.setAttribute(ATTRIBUTE_NAME_CLASS,MAP_TOPICREF.toString());
        newChild.setAttribute(ATTRIBUTE_NAME_XTRF,ATTR_XTRF_VALUE_GENERATED);
        createTopicMeta(element,newChild);
        if (stub != null) {
          if (includelevel == 0 && siblingStub != null) {
            siblingStub.getParentNode().insertBefore(newChild,siblingStub);
          }
 else {
            stub.getParentNode().insertBefore(newChild,stub);
          }
          stubStack.push(stub);
          stub=(Element)stub.cloneNode(false);
          newChild.appendChild(stub);
        }
      }
      if (include && ATTR_CHUNK_VALUE_SELECT_TOPIC.equals(selectMethod)) {
        include=false;
        skipLevel=1;
        skip=true;
      }
 else       if (include) {
        if (!currentParsingFile.equals(outputFile)) {
          if (idValue != null) {
            changeTable.put(setFragment(currentParsingFile.getPath(),idValue),setFragment(outputFile.getPath(),idValue));
          }
 else {
            changeTable.put(currentParsingFile.getPath(),outputFile.getPath());
          }
        }
      }
 else       if (skip) {
        skipLevel=1;
      }
 else       if (!include && idValue != null && (idValue.equals(targetTopicId) || startFromFirstTopic)) {
        include=true;
        includelevel=0;
        skip=false;
        skipLevel=0;
        startFromFirstTopic=false;
        if (!currentParsingFile.equals(outputFile)) {
          changeTable.put(setFragment(currentParsingFile.getPath(),idValue),setFragment(outputFile.getPath(),idValue));
        }
      }
    }
    if (include) {
      includelevel++;
      final AttributesImpl resAtts=new AttributesImpl(atts);
      for (int i=0; i < resAtts.getLength(); i++) {
        final String attrName=resAtts.getQName(i);
        String attrValue=resAtts.getValue(i);
        if (ATTRIBUTE_NAME_ID.equals(attrName) && TOPIC_TOPIC.matches(classValue)) {
          if (topicID.contains(attrValue)) {
            final String oldAttrValue=attrValue;
            attrValue=chunkFilenameGenerator.generateID();
            topicID.add(attrValue);
            String tmpVal=changeTable.get(setFragment(currentParsingFile.getPath(),idValue));
            if (tmpVal != null && tmpVal.equalsIgnoreCase(setFragment(outputFile.getPath(),idValue))) {
              changeTable.put(setFragment(currentParsingFile.getPath(),idValue),setFragment(outputFile.getPath(),attrValue));
            }
            tmpVal=changeTable.get(currentParsingFile);
            if (tmpVal != null && tmpVal.equalsIgnoreCase(setFragment(outputFile.getPath(),idValue))) {
              changeTable.put(currentParsingFile.getPath(),setFragment(outputFile.getPath(),attrValue));
            }
            currentParsingFileTopicIDChangeTable.put(oldAttrValue,attrValue);
          }
 else {
            topicID.add(attrValue);
          }
        }
        String value=attrValue;
        if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
          if (checkHREF(resAtts)) {
            String relative=FileUtils.getRelativeUnixPath(outputFile,currentParsingFile.getPath());
            if (conflictTable.containsKey(outputFile)) {
              final String realoutputfile=conflictTable.get(outputFile);
              relative=FileUtils.getRelativeUnixPath(realoutputfile,currentParsingFile.getPath());
            }
            if (attrValue.startsWith(SHARP)) {
              value=relative + attrValue;
            }
 else             if (relative.indexOf(SLASH) != -1) {
              relative=relative.substring(0,relative.lastIndexOf(SLASH));
              value=FileUtils.resolveTopic(relative,attrValue);
            }
 else {
            }
          }
 else {
          }
        }
        resAtts.setValue(i,value);
      }
      if (classValue != null && TOPIC_TOPIC.matches(classValue) && resAtts.getValue(""String_Node_Str"") == null) {
        XMLUtils.addOrSetAttribute(resAtts,ATTRIBUTE_NAMESPACE_PREFIX_DITAARCHVERSION,ditaarchNSValue);
      }
      writeStartElement(output,qName,resAtts);
    }
  }
 catch (  final Exception e) {
    logger.logError(e.getMessage(),e);
  }
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final String idValue=atts.getValue(ATTRIBUTE_NAME_ID);
  if (skip && skipLevel > 0) {
    skipLevel++;
  }
  try {
    if (classValue != null && TOPIC_TOPIC.matches(classValue)) {
      topicSpecSet.add(qName);
      final String id=atts.getValue(ATTRIBUTE_NAME_ID);
      final Element element=DITAAttrUtils.getInstance().searchForNode(topicDoc,id,ATTRIBUTE_NAME_ID,TOPIC_TOPIC.matcher);
      if (separate && include && !ATTR_CHUNK_VALUE_SELECT_TOPIC.equals(selectMethod)) {
        fileWriterStack.push(output);
        outputFileNameStack.push(outputFile);
        File newFileName=FileUtils.resolveFile(filePath,idValue + FILE_EXTENSION_DITA);
        if (StringUtils.isEmptyString(idValue) || newFileName.exists()) {
          final File t=newFileName;
          newFileName=FileUtils.resolveFile(filePath,generateFilename());
          conflictTable.put(newFileName.getPath(),t.getPath());
        }
        outputFile=newFileName;
        output=new OutputStreamWriter(new FileOutputStream(newFileName),UTF8);
        writeStartDocument(output);
        if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
          writeProcessingInstruction(output,PI_WORKDIR_TARGET,filePath.getAbsolutePath());
        }
 else {
          writeProcessingInstruction(output,PI_WORKDIR_TARGET,UNIX_SEPARATOR + filePath);
        }
        writeProcessingInstruction(output,PI_WORKDIR_TARGET_URI,filePath.toURI().toString());
        changeTable.put(newFileName.getPath(),newFileName.getPath());
        if (idValue != null) {
          changeTable.put(setFragment(currentParsingFile.getPath(),idValue),setFragment(newFileName.getPath(),idValue));
        }
 else {
          changeTable.put(currentParsingFile.getPath(),newFileName.getPath());
        }
        final Element newChild=elem.getOwnerDocument().createElement(MAP_TOPICREF.localName);
        newChild.setAttribute(ATTRIBUTE_NAME_HREF,toURI(FileUtils.getRelativePath(new File(filePath,FILE_NAME_STUB_DITAMAP),newFileName)).toString());
        newChild.setAttribute(ATTRIBUTE_NAME_CLASS,MAP_TOPICREF.toString());
        newChild.setAttribute(ATTRIBUTE_NAME_XTRF,ATTR_XTRF_VALUE_GENERATED);
        createTopicMeta(element,newChild);
        if (stub != null) {
          if (includelevel == 0 && siblingStub != null) {
            siblingStub.getParentNode().insertBefore(newChild,siblingStub);
          }
 else {
            stub.getParentNode().insertBefore(newChild,stub);
          }
          stubStack.push(stub);
          stub=(Element)stub.cloneNode(false);
          newChild.appendChild(stub);
        }
      }
      if (include && ATTR_CHUNK_VALUE_SELECT_TOPIC.equals(selectMethod)) {
        include=false;
        skipLevel=1;
        skip=true;
      }
 else       if (include) {
        if (!currentParsingFile.equals(outputFile)) {
          if (idValue != null) {
            changeTable.put(setFragment(currentParsingFile.getPath(),idValue),setFragment(outputFile.getPath(),idValue));
          }
 else {
            changeTable.put(currentParsingFile.getPath(),outputFile.getPath());
          }
        }
      }
 else       if (skip) {
        skipLevel=1;
      }
 else       if (!include && idValue != null && (idValue.equals(targetTopicId) || startFromFirstTopic)) {
        include=true;
        includelevel=0;
        skip=false;
        skipLevel=0;
        startFromFirstTopic=false;
        if (!currentParsingFile.equals(outputFile)) {
          changeTable.put(setFragment(currentParsingFile.getPath(),idValue),setFragment(outputFile.getPath(),idValue));
        }
      }
    }
    if (include) {
      includelevel++;
      final AttributesImpl resAtts=new AttributesImpl(atts);
      for (int i=0; i < resAtts.getLength(); i++) {
        final String attrName=resAtts.getQName(i);
        String attrValue=resAtts.getValue(i);
        if (ATTRIBUTE_NAME_ID.equals(attrName) && TOPIC_TOPIC.matches(classValue)) {
          if (topicID.contains(attrValue)) {
            final String oldAttrValue=attrValue;
            attrValue=chunkFilenameGenerator.generateID();
            topicID.add(attrValue);
            String tmpVal=changeTable.get(setFragment(currentParsingFile.getPath(),idValue));
            if (tmpVal != null && tmpVal.equalsIgnoreCase(setFragment(outputFile.getPath(),idValue))) {
              changeTable.put(setFragment(currentParsingFile.getPath(),idValue),setFragment(outputFile.getPath(),attrValue));
            }
            tmpVal=changeTable.get(currentParsingFile.getPath());
            if (tmpVal != null && tmpVal.equalsIgnoreCase(setFragment(outputFile.getPath(),idValue))) {
              changeTable.put(currentParsingFile.getPath(),setFragment(outputFile.getPath(),attrValue));
            }
            currentParsingFileTopicIDChangeTable.put(oldAttrValue,attrValue);
          }
 else {
            topicID.add(attrValue);
          }
        }
        String value=attrValue;
        if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
          if (checkHREF(resAtts)) {
            String relative=FileUtils.getRelativeUnixPath(outputFile,currentParsingFile.getPath());
            if (conflictTable.containsKey(outputFile.getPath())) {
              final String realoutputfile=conflictTable.get(outputFile.getPath());
              relative=FileUtils.getRelativeUnixPath(realoutputfile,currentParsingFile.getPath());
            }
            if (attrValue.startsWith(SHARP)) {
              value=relative + attrValue;
            }
 else             if (relative.indexOf(SLASH) != -1) {
              relative=relative.substring(0,relative.lastIndexOf(SLASH));
              value=FileUtils.resolveTopic(relative,attrValue);
            }
 else {
            }
          }
 else {
          }
        }
        resAtts.setValue(i,value);
      }
      if (classValue != null && TOPIC_TOPIC.matches(classValue) && resAtts.getValue(""String_Node_Str"") == null) {
        XMLUtils.addOrSetAttribute(resAtts,ATTRIBUTE_NAMESPACE_PREFIX_DITAARCHVERSION,ditaarchNSValue);
      }
      writeStartElement(output,qName,resAtts);
    }
  }
 catch (  final Exception e) {
    logger.logError(e.getMessage(),e);
  }
}",0.9976314542870678
100774,"private void processChunk(final Element element,final File outputFile){
  final String hrefValue=element.getAttribute(ATTRIBUTE_NAME_HREF);
  final String chunkValue=element.getAttribute(ATTRIBUTE_NAME_CHUNK);
  final String copytoValue=element.getAttribute(ATTRIBUTE_NAME_COPY_TO);
  final String scopeValue=element.getAttribute(ATTRIBUTE_NAME_SCOPE);
  final String classValue=element.getAttribute(ATTRIBUTE_NAME_CLASS);
  final String processRoleValue=element.getAttribute(ATTRIBUTE_NAME_PROCESSING_ROLE);
  final String id=element.getAttribute(ATTRIBUTE_NAME_ID);
  final String navtitle=element.getAttribute(ATTRIBUTE_NAME_NAVTITLE);
  String parseFilePath=null;
  File outputFileName=outputFile;
  Writer tempWriter=new StringWriter();
  Set<String> tempTopicID=new HashSet<String>();
  targetTopicId=null;
  selectMethod=ATTR_CHUNK_VALUE_SELECT_DOCUMENT;
  include=false;
  boolean needWriteDitaTag=true;
  try {
    if (copytoValue.length() != 0 && !chunkValue.contains(ATTR_CHUNK_VALUE_TO_CONTENT)) {
      if (getFragment(hrefValue) != null) {
        parseFilePath=setFragment(copytoValue,getFragment(hrefValue));
      }
 else {
        parseFilePath=copytoValue;
      }
    }
 else {
      parseFilePath=hrefValue;
    }
    if (copytoValue.length() != 0 && chunkValue.contains(ATTR_CHUNK_VALUE_TO_CONTENT) && hrefValue.length() != 0) {
      copyto.add(copytoValue);
      if (getFragment(hrefValue) != null) {
        copytoSource.add(stripFragment(hrefValue));
        copytotarget2source.put(toFile(copytoValue),toFile(stripFragment(hrefValue)));
      }
 else {
        copytoSource.add(hrefValue);
        copytotarget2source.put(toFile(copytoValue),toFile(hrefValue));
      }
    }
    if (!StringUtils.isEmptyString(classValue)) {
      if ((!MAPGROUP_D_TOPICGROUP.matches(classValue)) && (!StringUtils.isEmptyString(parseFilePath)) && (!ATTR_SCOPE_VALUE_EXTERNAL.equals(scopeValue))) {
        if (chunkValue.indexOf(ATTR_CHUNK_VALUE_TO_CONTENT) != -1) {
          tempWriter=output;
          tempTopicID=topicID;
          output=new StringWriter();
          topicID=new HashSet<String>();
          if (MAP_MAP.matches(classValue)) {
            outputFileName=FileUtils.resolveFile(filePath,parseFilePath);
            needWriteDitaTag=false;
          }
 else           if (copytoValue.length() != 0) {
            outputFileName=FileUtils.resolveFile(filePath,copytoValue);
          }
 else           if (hrefValue.length() != 0) {
            if (chunkValue.contains(ATTR_CHUNK_VALUE_SELECT_TOPIC) || chunkValue.contains(ATTR_CHUNK_VALUE_SELECT_BRANCH)) {
              if (getFragment(hrefValue) != null) {
                outputFileName=FileUtils.resolveFile(filePath,getFragment(hrefValue) + FILE_EXTENSION_DITA);
              }
 else {
                final String firstTopic=this.getFirstTopicId(FileUtils.resolveFile(filePath,hrefValue).getPath());
                if (!StringUtils.isEmptyString(firstTopic)) {
                  outputFileName=FileUtils.resolveFile(filePath,firstTopic + FILE_EXTENSION_DITA);
                }
 else {
                  outputFileName=FileUtils.resolveFile(filePath,hrefValue);
                }
              }
            }
 else {
              outputFileName=FileUtils.resolveFile(filePath,hrefValue);
            }
          }
 else {
            outputFileName=FileUtils.resolveFile(filePath,generateFilename());
          }
          if (outputFileName.exists() && !MAP_MAP.matches(classValue)) {
            final File t=outputFileName;
            outputFileName=FileUtils.resolveFile(filePath,generateFilename());
            conflictTable.put(outputFileName.getPath(),t.getPath());
          }
          changeTable.put(outputFileName.getPath(),outputFileName.getPath());
        }
        this.outputFile=outputFileName;
{
          final String path=FileUtils.resolveTopic(filePath,parseFilePath);
          String newpath=null;
          if (getFragment(path) != null) {
            newpath=setFragment(outputFileName.getPath(),getFragment(path));
          }
 else {
            final String firstTopicID=this.getFirstTopicId(path);
            if (!StringUtils.isEmptyString(firstTopicID)) {
              newpath=setFragment(outputFileName.getPath(),firstTopicID);
            }
 else {
              newpath=outputFileName.getPath();
            }
          }
          changeTable.put(path,newpath);
          element.setAttribute(ATTRIBUTE_NAME_HREF,FileUtils.getRelativeUnixPath(filePath + UNIX_SEPARATOR + FILE_NAME_STUB_DITAMAP,newpath));
        }
        if (getFragment(parseFilePath) != null) {
          targetTopicId=getFragment(parseFilePath);
        }
        if (chunkValue.indexOf(""String_Node_Str"") != -1) {
          final int endIndex=chunkValue.indexOf(STRING_BLANK,chunkValue.indexOf(""String_Node_Str""));
          if (endIndex == -1) {
            selectMethod=chunkValue.substring(chunkValue.indexOf(""String_Node_Str""));
          }
 else {
            selectMethod=chunkValue.substring(chunkValue.indexOf(""String_Node_Str""),endIndex);
          }
          if (ATTR_CHUNK_VALUE_SELECT_TOPIC.equals(selectMethod) || ATTR_CHUNK_VALUE_SELECT_BRANCH.equals(selectMethod)) {
            if (targetTopicId == null) {
              selectMethod=ATTR_CHUNK_VALUE_SELECT_DOCUMENT;
            }
          }
        }
        final File tempPath=currentParsingFile;
        currentParsingFile=FileUtils.resolveFile(filePath,parseFilePath);
        if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleValue)) {
          currentParsingFileTopicIDChangeTable=new HashMap<String,String>();
          reader.parse(currentParsingFile.toURI().toString());
          if (currentParsingFileTopicIDChangeTable.size() > 0) {
            String href=element.getAttribute(ATTRIBUTE_NAME_HREF);
            href=FileUtils.separatorsToUnix(href);
            final String pathtoElem=getFragment(href) != null ? getFragment(href) : ""String_Node_Str"";
            final String old_elementid=pathtoElem.contains(SLASH) ? pathtoElem.substring(0,pathtoElem.indexOf(SLASH)) : pathtoElem;
            if (old_elementid.length() > 0) {
              final String new_elementid=currentParsingFileTopicIDChangeTable.get(old_elementid);
              if (new_elementid != null && new_elementid.length() > 0) {
                href=setFragment(href,new_elementid);
                element.setAttribute(ATTRIBUTE_NAME_HREF,href);
              }
            }
          }
          currentParsingFileTopicIDChangeTable=null;
        }
        currentParsingFile=tempPath;
      }
      if (outputFileName == null) {
        if (!StringUtils.isEmptyString(copytoValue)) {
          outputFileName=FileUtils.resolveFile(filePath,copytoValue);
        }
 else         if (!StringUtils.isEmptyString(id)) {
          outputFileName=FileUtils.resolveFile(filePath,id + FILE_EXTENSION_DITA);
        }
 else {
          outputFileName=FileUtils.resolveFile(filePath,generateFilename());
          if (outputFileName.exists() && !MAP_MAP.matches(classValue)) {
            final File t=outputFileName;
            outputFileName=FileUtils.resolveFile(filePath,generateFilename());
            conflictTable.put(outputFileName.getPath(),t.getPath());
          }
        }
        if (element.hasChildNodes() || !StringUtils.isEmptyString(navtitle)) {
          final DITAAttrUtils utils=DITAAttrUtils.getInstance();
          String navtitleValue=null;
          String shortDescValue=null;
          navtitleValue=utils.getChildElementValueOfTopicmeta(element,TOPIC_NAVTITLE.matcher);
          shortDescValue=utils.getChildElementValueOfTopicmeta(element,MAP_SHORTDESC.matcher);
          if (navtitleValue == null) {
            navtitleValue=navtitle;
          }
          changeTable.put(outputFileName.getPath(),outputFileName.getPath());
          if (!StringUtils.isEmptyString(navtitleValue)) {
            element.setAttribute(ATTRIBUTE_NAME_HREF,toURI(FileUtils.getRelativePath(new File(filePath,FILE_NAME_STUB_DITAMAP),outputFileName)).toString());
            final StringBuffer buffer=new StringBuffer();
            buffer.append(""String_Node_Str"").append(""String_Node_Str"").append(navtitleValue).append(""String_Node_Str"");
            if (shortDescValue != null) {
              buffer.append(""String_Node_Str"").append(shortDescValue).append(""String_Node_Str"");
            }
            buffer.append(""String_Node_Str"");
            final StringReader rder=new StringReader(buffer.toString());
            final InputSource source=new InputSource(rder);
            final File tempPath=currentParsingFile;
            currentParsingFile=outputFileName;
            parseFilePath=outputFileName.getPath();
            reader.parse(source);
            currentParsingFile=tempPath;
          }
        }
      }
      if (element.hasChildNodes()) {
        final StringWriter temp=(StringWriter)output;
        output=new StringWriter();
        final NodeList children=element.getChildNodes();
        for (int i=0; i < children.getLength(); i++) {
          final Node current=children.item(i);
          if (current.getNodeType() == Node.ELEMENT_NODE && ((Element)current).getAttribute(ATTRIBUTE_NAME_CLASS).indexOf(MAP_TOPICREF.matcher) != -1) {
            processChunk((Element)current,outputFileName);
          }
        }
        final StringBuffer parentResult=temp.getBuffer();
        if (parentResult.length() > 0 && !StringUtils.isEmptyString(parseFilePath) && !ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleValue)) {
          int insertpoint=parentResult.lastIndexOf(""String_Node_Str"");
          final int end=parentResult.indexOf(""String_Node_Str"",insertpoint);
          if (insertpoint == -1 || end == -1) {
            logger.logError(MessageUtils.getInstance().getMessage(""String_Node_Str"",hrefValue).toString());
          }
 else {
            if (ELEMENT_NAME_DITA.equals(parentResult.substring(insertpoint,end).trim())) {
              insertpoint=parentResult.lastIndexOf(""String_Node_Str"",insertpoint);
            }
            parentResult.insert(insertpoint,((StringWriter)output).getBuffer());
          }
        }
 else {
          parentResult.append(((StringWriter)output).getBuffer());
        }
        output=temp;
      }
      if (chunkValue.indexOf(ATTR_CHUNK_VALUE_TO_CONTENT) != -1) {
        final FileOutputStream fileOutput=new FileOutputStream(outputFileName);
        OutputStreamWriter ditaFileOutput=null;
        try {
          ditaFileOutput=new OutputStreamWriter(fileOutput,UTF8);
          if (outputFileName.equals(changeTable.get(outputFileName))) {
            writeStartDocument(ditaFileOutput);
            final File workDir=outputFileName.getParentFile().getAbsoluteFile();
            if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
              writeProcessingInstruction(ditaFileOutput,PI_WORKDIR_TARGET,workDir.getAbsolutePath());
            }
 else {
              writeProcessingInstruction(ditaFileOutput,PI_WORKDIR_TARGET,UNIX_SEPARATOR + workDir.getAbsolutePath());
            }
            writeProcessingInstruction(ditaFileOutput,PI_WORKDIR_TARGET_URI,workDir.toURI().toString());
            if ((conflictTable.get(outputFileName) != null)) {
              final String relativePath=FileUtils.getRelativeUnixPath(filePath + UNIX_SEPARATOR + FILE_NAME_STUB_DITAMAP,conflictTable.get(outputFileName));
              String path2project=FileUtils.getRelativeUnixPath(relativePath);
              if (null == path2project) {
                path2project=""String_Node_Str"";
              }
              writeProcessingInstruction(ditaFileOutput,PI_PATH2PROJ_TARGET,path2project);
            }
          }
          if (needWriteDitaTag) {
            final AttributesImpl atts=new AttributesImpl();
            XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAMESPACE_PREFIX_DITAARCHVERSION,ditaarchNSValue);
            XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_PREFIX_DITAARCHVERSION + COLON + ATTRIBUTE_NAME_DITAARCHVERSION,""String_Node_Str"");
            writeStartElement(ditaFileOutput,ELEMENT_NAME_DITA,atts);
          }
          ditaFileOutput.write(((StringWriter)output).getBuffer().toString());
          if (needWriteDitaTag) {
            writeEndElement(ditaFileOutput,ELEMENT_NAME_DITA);
          }
          ditaFileOutput.flush();
        }
  finally {
          ditaFileOutput.close();
        }
        output=tempWriter;
        topicID=tempTopicID;
      }
    }
  }
 catch (  final Exception e) {
    logger.logError(e.getMessage(),e);
  }
}","private void processChunk(final Element element,final File outputFile){
  final String hrefValue=element.getAttribute(ATTRIBUTE_NAME_HREF);
  final String chunkValue=element.getAttribute(ATTRIBUTE_NAME_CHUNK);
  final String copytoValue=element.getAttribute(ATTRIBUTE_NAME_COPY_TO);
  final String scopeValue=element.getAttribute(ATTRIBUTE_NAME_SCOPE);
  final String classValue=element.getAttribute(ATTRIBUTE_NAME_CLASS);
  final String processRoleValue=element.getAttribute(ATTRIBUTE_NAME_PROCESSING_ROLE);
  final String id=element.getAttribute(ATTRIBUTE_NAME_ID);
  final String navtitle=element.getAttribute(ATTRIBUTE_NAME_NAVTITLE);
  String parseFilePath=null;
  File outputFileName=outputFile;
  Writer tempWriter=new StringWriter();
  Set<String> tempTopicID=new HashSet<String>();
  targetTopicId=null;
  selectMethod=ATTR_CHUNK_VALUE_SELECT_DOCUMENT;
  include=false;
  boolean needWriteDitaTag=true;
  try {
    if (copytoValue.length() != 0 && !chunkValue.contains(ATTR_CHUNK_VALUE_TO_CONTENT)) {
      if (getFragment(hrefValue) != null) {
        parseFilePath=setFragment(copytoValue,getFragment(hrefValue));
      }
 else {
        parseFilePath=copytoValue;
      }
    }
 else {
      parseFilePath=hrefValue;
    }
    if (copytoValue.length() != 0 && chunkValue.contains(ATTR_CHUNK_VALUE_TO_CONTENT) && hrefValue.length() != 0) {
      copyto.add(copytoValue);
      if (getFragment(hrefValue) != null) {
        copytoSource.add(stripFragment(hrefValue));
        copytotarget2source.put(toFile(copytoValue),toFile(stripFragment(hrefValue)));
      }
 else {
        copytoSource.add(hrefValue);
        copytotarget2source.put(toFile(copytoValue),toFile(hrefValue));
      }
    }
    if (!StringUtils.isEmptyString(classValue)) {
      if ((!MAPGROUP_D_TOPICGROUP.matches(classValue)) && (!StringUtils.isEmptyString(parseFilePath)) && (!ATTR_SCOPE_VALUE_EXTERNAL.equals(scopeValue))) {
        if (chunkValue.indexOf(ATTR_CHUNK_VALUE_TO_CONTENT) != -1) {
          tempWriter=output;
          tempTopicID=topicID;
          output=new StringWriter();
          topicID=new HashSet<String>();
          if (MAP_MAP.matches(classValue)) {
            outputFileName=FileUtils.resolveFile(filePath,parseFilePath);
            needWriteDitaTag=false;
          }
 else           if (copytoValue.length() != 0) {
            outputFileName=FileUtils.resolveFile(filePath,copytoValue);
          }
 else           if (hrefValue.length() != 0) {
            if (chunkValue.contains(ATTR_CHUNK_VALUE_SELECT_TOPIC) || chunkValue.contains(ATTR_CHUNK_VALUE_SELECT_BRANCH)) {
              if (getFragment(hrefValue) != null) {
                outputFileName=FileUtils.resolveFile(filePath,getFragment(hrefValue) + FILE_EXTENSION_DITA);
              }
 else {
                final String firstTopic=this.getFirstTopicId(FileUtils.resolveFile(filePath,hrefValue).getPath());
                if (!StringUtils.isEmptyString(firstTopic)) {
                  outputFileName=FileUtils.resolveFile(filePath,firstTopic + FILE_EXTENSION_DITA);
                }
 else {
                  outputFileName=FileUtils.resolveFile(filePath,hrefValue);
                }
              }
            }
 else {
              outputFileName=FileUtils.resolveFile(filePath,hrefValue);
            }
          }
 else {
            outputFileName=FileUtils.resolveFile(filePath,generateFilename());
          }
          if (outputFileName.exists() && !MAP_MAP.matches(classValue)) {
            final File t=outputFileName;
            outputFileName=FileUtils.resolveFile(filePath,generateFilename());
            conflictTable.put(outputFileName.getPath(),t.getPath());
          }
          changeTable.put(outputFileName.getPath(),outputFileName.getPath());
        }
        this.outputFile=outputFileName;
{
          final String path=FileUtils.resolveTopic(filePath,parseFilePath);
          String newpath=null;
          if (getFragment(path) != null) {
            newpath=setFragment(outputFileName.getPath(),getFragment(path));
          }
 else {
            final String firstTopicID=this.getFirstTopicId(path);
            if (!StringUtils.isEmptyString(firstTopicID)) {
              newpath=setFragment(outputFileName.getPath(),firstTopicID);
            }
 else {
              newpath=outputFileName.getPath();
            }
          }
          changeTable.put(path,newpath);
          element.setAttribute(ATTRIBUTE_NAME_HREF,FileUtils.getRelativeUnixPath(filePath + UNIX_SEPARATOR + FILE_NAME_STUB_DITAMAP,newpath));
        }
        if (getFragment(parseFilePath) != null) {
          targetTopicId=getFragment(parseFilePath);
        }
        if (chunkValue.indexOf(""String_Node_Str"") != -1) {
          final int endIndex=chunkValue.indexOf(STRING_BLANK,chunkValue.indexOf(""String_Node_Str""));
          if (endIndex == -1) {
            selectMethod=chunkValue.substring(chunkValue.indexOf(""String_Node_Str""));
          }
 else {
            selectMethod=chunkValue.substring(chunkValue.indexOf(""String_Node_Str""),endIndex);
          }
          if (ATTR_CHUNK_VALUE_SELECT_TOPIC.equals(selectMethod) || ATTR_CHUNK_VALUE_SELECT_BRANCH.equals(selectMethod)) {
            if (targetTopicId == null) {
              selectMethod=ATTR_CHUNK_VALUE_SELECT_DOCUMENT;
            }
          }
        }
        final File tempPath=currentParsingFile;
        currentParsingFile=FileUtils.resolveFile(filePath,parseFilePath);
        if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleValue)) {
          currentParsingFileTopicIDChangeTable=new HashMap<String,String>();
          reader.parse(currentParsingFile.toURI().toString());
          if (currentParsingFileTopicIDChangeTable.size() > 0) {
            String href=element.getAttribute(ATTRIBUTE_NAME_HREF);
            href=FileUtils.separatorsToUnix(href);
            final String pathtoElem=getFragment(href) != null ? getFragment(href) : ""String_Node_Str"";
            final String old_elementid=pathtoElem.contains(SLASH) ? pathtoElem.substring(0,pathtoElem.indexOf(SLASH)) : pathtoElem;
            if (old_elementid.length() > 0) {
              final String new_elementid=currentParsingFileTopicIDChangeTable.get(old_elementid);
              if (new_elementid != null && new_elementid.length() > 0) {
                href=setFragment(href,new_elementid);
                element.setAttribute(ATTRIBUTE_NAME_HREF,href);
              }
            }
          }
          currentParsingFileTopicIDChangeTable=null;
        }
        currentParsingFile=tempPath;
      }
      if (outputFileName == null) {
        if (!StringUtils.isEmptyString(copytoValue)) {
          outputFileName=FileUtils.resolveFile(filePath,copytoValue);
        }
 else         if (!StringUtils.isEmptyString(id)) {
          outputFileName=FileUtils.resolveFile(filePath,id + FILE_EXTENSION_DITA);
        }
 else {
          outputFileName=FileUtils.resolveFile(filePath,generateFilename());
          if (outputFileName.exists() && !MAP_MAP.matches(classValue)) {
            final File t=outputFileName;
            outputFileName=FileUtils.resolveFile(filePath,generateFilename());
            conflictTable.put(outputFileName.getPath(),t.getPath());
          }
        }
        if (element.hasChildNodes() || !StringUtils.isEmptyString(navtitle)) {
          final DITAAttrUtils utils=DITAAttrUtils.getInstance();
          String navtitleValue=null;
          String shortDescValue=null;
          navtitleValue=utils.getChildElementValueOfTopicmeta(element,TOPIC_NAVTITLE.matcher);
          shortDescValue=utils.getChildElementValueOfTopicmeta(element,MAP_SHORTDESC.matcher);
          if (navtitleValue == null) {
            navtitleValue=navtitle;
          }
          changeTable.put(outputFileName.getPath(),outputFileName.getPath());
          if (!StringUtils.isEmptyString(navtitleValue)) {
            element.setAttribute(ATTRIBUTE_NAME_HREF,toURI(FileUtils.getRelativePath(new File(filePath,FILE_NAME_STUB_DITAMAP),outputFileName)).toString());
            final StringBuffer buffer=new StringBuffer();
            buffer.append(""String_Node_Str"").append(""String_Node_Str"").append(navtitleValue).append(""String_Node_Str"");
            if (shortDescValue != null) {
              buffer.append(""String_Node_Str"").append(shortDescValue).append(""String_Node_Str"");
            }
            buffer.append(""String_Node_Str"");
            final StringReader rder=new StringReader(buffer.toString());
            final InputSource source=new InputSource(rder);
            final File tempPath=currentParsingFile;
            currentParsingFile=outputFileName;
            parseFilePath=outputFileName.getPath();
            reader.parse(source);
            currentParsingFile=tempPath;
          }
        }
      }
      if (element.hasChildNodes()) {
        final StringWriter temp=(StringWriter)output;
        output=new StringWriter();
        final NodeList children=element.getChildNodes();
        for (int i=0; i < children.getLength(); i++) {
          final Node current=children.item(i);
          if (current.getNodeType() == Node.ELEMENT_NODE && ((Element)current).getAttribute(ATTRIBUTE_NAME_CLASS).indexOf(MAP_TOPICREF.matcher) != -1) {
            processChunk((Element)current,outputFileName);
          }
        }
        final StringBuffer parentResult=temp.getBuffer();
        if (parentResult.length() > 0 && !StringUtils.isEmptyString(parseFilePath) && !ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleValue)) {
          int insertpoint=parentResult.lastIndexOf(""String_Node_Str"");
          final int end=parentResult.indexOf(""String_Node_Str"",insertpoint);
          if (insertpoint == -1 || end == -1) {
            logger.logError(MessageUtils.getInstance().getMessage(""String_Node_Str"",hrefValue).toString());
          }
 else {
            if (ELEMENT_NAME_DITA.equals(parentResult.substring(insertpoint,end).trim())) {
              insertpoint=parentResult.lastIndexOf(""String_Node_Str"",insertpoint);
            }
            parentResult.insert(insertpoint,((StringWriter)output).getBuffer());
          }
        }
 else {
          parentResult.append(((StringWriter)output).getBuffer());
        }
        output=temp;
      }
      if (chunkValue.indexOf(ATTR_CHUNK_VALUE_TO_CONTENT) != -1) {
        final FileOutputStream fileOutput=new FileOutputStream(outputFileName);
        OutputStreamWriter ditaFileOutput=null;
        try {
          ditaFileOutput=new OutputStreamWriter(fileOutput,UTF8);
          if (outputFileName.getPath().equals(changeTable.get(outputFileName.getPath()))) {
            writeStartDocument(ditaFileOutput);
            final File workDir=outputFileName.getParentFile().getAbsoluteFile();
            if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
              writeProcessingInstruction(ditaFileOutput,PI_WORKDIR_TARGET,workDir.getAbsolutePath());
            }
 else {
              writeProcessingInstruction(ditaFileOutput,PI_WORKDIR_TARGET,UNIX_SEPARATOR + workDir.getAbsolutePath());
            }
            writeProcessingInstruction(ditaFileOutput,PI_WORKDIR_TARGET_URI,workDir.toURI().toString());
            if ((conflictTable.get(outputFileName.getPath()) != null)) {
              final String relativePath=FileUtils.getRelativeUnixPath(filePath + UNIX_SEPARATOR + FILE_NAME_STUB_DITAMAP,conflictTable.get(outputFileName.getPath()));
              String path2project=FileUtils.getRelativeUnixPath(relativePath);
              if (null == path2project) {
                path2project=""String_Node_Str"";
              }
              writeProcessingInstruction(ditaFileOutput,PI_PATH2PROJ_TARGET,path2project);
            }
          }
          if (needWriteDitaTag) {
            final AttributesImpl atts=new AttributesImpl();
            XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAMESPACE_PREFIX_DITAARCHVERSION,ditaarchNSValue);
            XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_PREFIX_DITAARCHVERSION + COLON + ATTRIBUTE_NAME_DITAARCHVERSION,""String_Node_Str"");
            writeStartElement(ditaFileOutput,ELEMENT_NAME_DITA,atts);
          }
          ditaFileOutput.write(((StringWriter)output).getBuffer().toString());
          if (needWriteDitaTag) {
            writeEndElement(ditaFileOutput,ELEMENT_NAME_DITA);
          }
          ditaFileOutput.flush();
        }
  finally {
          ditaFileOutput.close();
        }
        output=tempWriter;
        topicID=tempTopicID;
      }
    }
  }
 catch (  final Exception e) {
    logger.logError(e.getMessage(),e);
  }
}",0.9984105539219582
100775,"/** 
 * Search braches map with branch id and current file name.
 * @param id String branch id.
 * @return boolean true if found and false otherwise.
 */
private boolean searchBrachesMap(final String id){
  if (validBranches.containsKey(currentFileRelative)) {
    final List<String> branchIdList=validBranches.get(currentFileRelative);
    if (branchIdList.contains(id)) {
      return true;
    }
 else     if (branchIdList.size() == 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","/** 
 * Search braches map with branch id and current file name.
 * @param id String branch id.
 * @return boolean true if found and false otherwise.
 */
private boolean searchBrachesMap(final String id){
  if (validBranches.containsKey(currentFileRelative.getPath())) {
    final List<String> branchIdList=validBranches.get(currentFileRelative.getPath());
    if (branchIdList.contains(id)) {
      return true;
    }
 else     if (branchIdList.size() == 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}",0.981651376146789
100776,"@Before public void setUp() throws Exception {
  tempDir=TestUtils.createTempDir(getClass());
  job=new Job(tempDir);
  final PipelineFacade facade=new PipelineFacade();
  facade.setLogger(new TestUtils.TestLogger());
  facade.setJob(job);
  pipelineInput=new PipelineHashIO();
  pipelineInput.setAttribute(""String_Node_Str"",inputMap.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",baseDir.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",outDir.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",tempDir.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",new File(""String_Node_Str"" + File.separator + ""String_Node_Str"").getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",new File(tempDir,""String_Node_Str"").getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",new File(tempDir,""String_Node_Str"").getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",ditavalFile.getPath());
  pipelineInput.setAttribute(Constants.ANT_INVOKER_EXT_PARAN_SETSYSTEMID,""String_Node_Str"");
  facade.execute(""String_Node_Str"",pipelineInput);
  writer=new DitaWriter();
  writer.setLogger(new TestUtils.TestLogger());
  writer.initXMLReader(new File(""String_Node_Str"" + File.separator + ""String_Node_Str"").getAbsoluteFile(),false,true);
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  factory.setValidating(false);
  factory.setFeature(""String_Node_Str"",false);
  factory.setFeature(""String_Node_Str"",false);
  builder=factory.newDocumentBuilder();
}","@Before public void setUp() throws Exception {
  tempDir=TestUtils.createTempDir(getClass());
  outDir=new File(tempDir,""String_Node_Str"");
  job=new Job(tempDir);
  final PipelineFacade facade=new PipelineFacade();
  facade.setLogger(new TestUtils.TestLogger());
  facade.setJob(job);
  pipelineInput=new PipelineHashIO();
  pipelineInput.setAttribute(""String_Node_Str"",inputMap.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",baseDir.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",outDir.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",tempDir.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",new File(""String_Node_Str"" + File.separator + ""String_Node_Str"").getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",new File(tempDir,""String_Node_Str"").getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",new File(tempDir,""String_Node_Str"").getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",ditavalFile.getPath());
  pipelineInput.setAttribute(Constants.ANT_INVOKER_EXT_PARAN_SETSYSTEMID,""String_Node_Str"");
  facade.execute(""String_Node_Str"",pipelineInput);
  writer=new DitaWriter();
  writer.setLogger(new TestUtils.TestLogger());
  writer.initXMLReader(new File(""String_Node_Str"" + File.separator + ""String_Node_Str"").getAbsoluteFile(),false,true);
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  factory.setValidating(false);
  factory.setFeature(""String_Node_Str"",false);
  factory.setFeature(""String_Node_Str"",false);
  builder=factory.newDocumentBuilder();
}",0.9891917293233082
100777,"/** 
 * Set copy-to map.
 */
public void setCopytoMap(final Map<File,File> value){
  prop.put(COPYTO_TARGET_TO_SOURCE_MAP_LIST,new HashMap<File,File>(value));
}","/** 
 * Set copy-to map.
 */
public void setCopytoMap(final Map<File,File> value){
  final Map<String,String> res=new HashMap<String,String>();
  for (  final Map.Entry<File,File> e : value.entrySet()) {
    res.put(e.getKey().toString(),e.getValue().toString());
  }
  prop.put(COPYTO_TARGET_TO_SOURCE_MAP_LIST,res);
}",0.5469728601252609
100778,"private void updateList(final Map<String,String> changeTable,final Hashtable<String,String> conflictTable,final AbstractPipelineInput input){
  final File tempDir=new File(input.getAttribute(ANT_INVOKER_PARAM_TEMPDIR));
  if (!tempDir.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"" + tempDir + ""String_Node_Str"");
  }
  final File xmlDitalist=new File(tempDir,""String_Node_Str"");
  Job job=null;
  try {
    job=new Job(tempDir);
  }
 catch (  final IOException ex) {
    logger.logError(ex.getMessage(),ex);
  }
  final Set<String> hrefTopics=new HashSet<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.file.getPath());
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final String s=f.file.getPath();
      if (!StringUtils.isEmptyString(s) && getFragment(s) == null) {
        final Iterator<String> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final String ent=hrefit.next();
          if (resolveFile(tempDir.getAbsolutePath(),ent).getPath().equals(resolveFile(tempDir.getAbsolutePath(),s).getPath())) {
            hrefit.remove();
          }
        }
      }
 else       if (!StringUtils.isEmptyString(s) && hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<String> topicList=new LinkedHashSet<String>(INT_128);
  final Set<String> oldTopicList=new HashSet<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isActive && ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.file.getPath());
    }
  }
  for (  String t : hrefTopics) {
    t=stripFragment(t);
    t=getRelativeUnixPath(xmlDitalist.getAbsolutePath(),resolveFile(tempDir.getAbsolutePath(),t).getPath());
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<String> chunkedTopicSet=new LinkedHashSet<String>(INT_128);
  final Set<String> chunkedDitamapSet=new LinkedHashSet<String>(INT_128);
  final Set<String> ditamapList=new HashSet<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isActive && ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.file.getPath());
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      String newChunkedFile=entry.getValue();
      newChunkedFile=getRelativeUnixPath(xmlDitalist.getAbsolutePath(),newChunkedFile);
      final String extName=getExtension(newChunkedFile);
      if (extName != null && !extName.equalsIgnoreCase(""String_Node_Str"")) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final String s : oldTopicList) {
    if (!StringUtils.isEmptyString(s)) {
      final File f=new File(tempDir,s);
      if (f.exists()) {
        f.delete();
      }
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      final String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        final File target=new File(targetPath);
        if (!fileExists(target.getAbsolutePath())) {
          final File from=new File(entry.getValue());
          String relativePath=getRelativeUnixPath(xmlDitalist.getAbsolutePath(),from.getAbsolutePath());
          final String relativeTargetPath=getRelativeUnixPath(xmlDitalist.getAbsolutePath(),target.getAbsolutePath());
          if (relativeTargetPath.lastIndexOf(SLASH) != -1) {
            relativePath2fix.put(relativeTargetPath,relativeTargetPath.substring(0,relativeTargetPath.lastIndexOf(SLASH) + 1));
          }
          target.delete();
          from.renameTo(target);
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativeUnixPath(xmlDitalist.getAbsolutePath(),target.getAbsolutePath());
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format) || ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      f.isActive=false;
    }
  }
  for (  final String file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
    ff.isActive=true;
  }
  for (  final String file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
    ff.isActive=true;
  }
  for (  final String file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
    f.isActive=true;
  }
  for (  final String file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
    f.isActive=true;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.logError(ex.getMessage(),ex);
  }
}","private void updateList(final Map<String,String> changeTable,final Hashtable<String,String> conflictTable,final AbstractPipelineInput input){
  final File tempDir=new File(input.getAttribute(ANT_INVOKER_PARAM_TEMPDIR));
  if (!tempDir.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"" + tempDir + ""String_Node_Str"");
  }
  final File xmlDitalist=new File(tempDir,""String_Node_Str"");
  Job job=null;
  try {
    job=new Job(tempDir);
  }
 catch (  final IOException ex) {
    logger.logError(ex.getMessage(),ex);
  }
  final Set<String> hrefTopics=new HashSet<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isNonConrefTarget) {
      hrefTopics.add(f.file.getPath());
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isSkipChunk) {
      final String s=f.file.getPath();
      if (!StringUtils.isEmptyString(s) && getFragment(s) == null) {
        final Iterator<String> hrefit=hrefTopics.iterator();
        while (hrefit.hasNext()) {
          final String ent=hrefit.next();
          if (resolveFile(tempDir.getAbsolutePath(),ent).getPath().equals(resolveFile(tempDir.getAbsolutePath(),s).getPath())) {
            hrefit.remove();
          }
        }
      }
 else       if (!StringUtils.isEmptyString(s) && hrefTopics.contains(s)) {
        hrefTopics.remove(s);
      }
    }
  }
  final Set<String> topicList=new LinkedHashSet<String>(INT_128);
  final Set<String> oldTopicList=new HashSet<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isActive && ATTR_FORMAT_VALUE_DITA.equals(f.format)) {
      oldTopicList.add(f.file.getPath());
    }
  }
  for (  String t : hrefTopics) {
    t=stripFragment(t);
    t=getRelativePath(xmlDitalist.getAbsolutePath(),resolveFile(tempDir.getAbsolutePath(),t).getPath(),File.separator);
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<String> chunkedTopicSet=new LinkedHashSet<String>(INT_128);
  final Set<String> chunkedDitamapSet=new LinkedHashSet<String>(INT_128);
  final Set<String> ditamapList=new HashSet<String>();
  for (  final FileInfo f : job.getFileInfo()) {
    if (f.isActive && ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      ditamapList.add(f.file.getPath());
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      String newChunkedFile=entry.getValue();
      newChunkedFile=getRelativePath(xmlDitalist.getAbsolutePath(),newChunkedFile,File.separator);
      final String extName=getExtension(newChunkedFile);
      if (extName != null && !extName.equalsIgnoreCase(""String_Node_Str"")) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final String s : oldTopicList) {
    if (!StringUtils.isEmptyString(s)) {
      final File f=new File(tempDir,s);
      if (f.exists()) {
        f.delete();
      }
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      final String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        final File target=new File(targetPath);
        if (!fileExists(target.getAbsolutePath())) {
          final File from=new File(entry.getValue());
          String relativePath=getRelativePath(xmlDitalist.getAbsolutePath(),from.getAbsolutePath(),File.separator);
          final String relativeTargetPath=getRelativePath(xmlDitalist.getAbsolutePath(),target.getAbsolutePath(),File.separator);
          if (relativeTargetPath.lastIndexOf(SLASH) != -1) {
            relativePath2fix.put(relativeTargetPath,relativeTargetPath.substring(0,relativeTargetPath.lastIndexOf(SLASH) + 1));
          }
          target.delete();
          from.renameTo(target);
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=getRelativePath(xmlDitalist.getAbsolutePath(),target.getAbsolutePath(),File.separator);
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  for (  final FileInfo f : job.getFileInfo()) {
    if (ATTR_FORMAT_VALUE_DITA.equals(f.format) || ATTR_FORMAT_VALUE_DITAMAP.equals(f.format)) {
      f.isActive=false;
    }
  }
  for (  final String file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITA;
    ff.isActive=true;
  }
  for (  final String file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=ATTR_FORMAT_VALUE_DITAMAP;
    ff.isActive=true;
  }
  for (  final String file : chunkedDitamapSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITAMAP;
    f.isResourceOnly=false;
    f.isActive=true;
  }
  for (  final String file : chunkedTopicSet) {
    final FileInfo f=job.getOrCreateFileInfo(file);
    f.format=ATTR_FORMAT_VALUE_DITA;
    f.isResourceOnly=false;
    f.isActive=true;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.logError(ex.getMessage(),ex);
  }
}",0.9919169573725856
100779,"private void updateList(final Map<String,String> changeTable,final Hashtable<String,String> conflictTable,final AbstractPipelineInput input){
  final File tempDir=new File(input.getAttribute(ANT_INVOKER_PARAM_TEMPDIR));
  if (!tempDir.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"" + tempDir + ""String_Node_Str"");
  }
  final File xmlDitalist=new File(tempDir,""String_Node_Str"");
  Job job=null;
  try {
    job=new Job(tempDir);
  }
 catch (  final IOException ex) {
    logger.logError(ex.getMessage(),ex);
  }
  final Set<String> hrefTopics=job.getSet(HREF_TOPIC_LIST);
  final Set<String> chunkTopics=job.getSet(CHUNK_TOPIC_LIST);
  for (  final String s : chunkTopics) {
    if (!StringUtils.isEmptyString(s) && getFragment(s) == null) {
      final Iterator<String> hrefit=hrefTopics.iterator();
      while (hrefit.hasNext()) {
        final String ent=hrefit.next();
        if (FileUtils.resolveFile(tempDir.getAbsolutePath(),ent).equalsIgnoreCase(FileUtils.resolveFile(tempDir.getAbsolutePath(),s))) {
          hrefit.remove();
        }
      }
    }
 else     if (!StringUtils.isEmptyString(s) && hrefTopics.contains(s)) {
      hrefTopics.remove(s);
    }
  }
  final Set<String> topicList=new LinkedHashSet<String>(INT_128);
  final Set<String> oldTopicList=job.getSet(FULL_DITA_TOPIC_LIST);
  for (  String t : hrefTopics) {
    if (t.lastIndexOf(SHARP) != -1) {
      t=t.substring(0,t.lastIndexOf(SHARP));
    }
    t=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),FileUtils.resolveFile(tempDir.getAbsolutePath(),t));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<String> chunkedTopicSet=new LinkedHashSet<String>(INT_128);
  final Set<String> chunkedDitamapSet=new LinkedHashSet<String>(INT_128);
  final Set<String> ditamapList=job.getSet(FULL_DITAMAP_LIST);
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      String newChunkedFile=entry.getValue();
      newChunkedFile=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),newChunkedFile);
      final String extName=FileUtils.getExtension(newChunkedFile);
      if (extName != null && !extName.equalsIgnoreCase(""String_Node_Str"")) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final String s : oldTopicList) {
    if (!StringUtils.isEmptyString(s)) {
      final File f=new File(tempDir,s);
      if (f.exists()) {
        f.delete();
      }
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      final String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        final File target=new File(targetPath);
        if (!FileUtils.fileExists(target.getAbsolutePath())) {
          final File from=new File(entry.getValue());
          String relativePath=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),from.getAbsolutePath());
          final String relativeTargetPath=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),target.getAbsolutePath());
          if (relativeTargetPath.lastIndexOf(SLASH) != -1) {
            relativePath2fix.put(relativeTargetPath,relativeTargetPath.substring(0,relativeTargetPath.lastIndexOf(SLASH) + 1));
          }
          target.delete();
          from.renameTo(target);
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),target.getAbsolutePath());
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  for (  final String file : chunkedTopicSet) {
    job.getOrCreateFileInfo(file).isResourceOnly=false;
  }
  for (  final String file : chunkedDitamapSet) {
    job.getOrCreateFileInfo(file).isResourceOnly=false;
  }
  for (  FileInfo f : job.getFileInfo().values()) {
    if (""String_Node_Str"".equals(f.format) || ""String_Node_Str"".equals(f.format)) {
      f.isActive=false;
    }
  }
  for (  final String file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=""String_Node_Str"";
    ff.isActive=true;
  }
  for (  final String file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=""String_Node_Str"";
    ff.isActive=true;
  }
  job.setProperty(""String_Node_Str"",CHUNKED_DITAMAP_LIST_FILE);
  job.setProperty(""String_Node_Str"",CHUNKED_TOPIC_LIST_FILE);
  job.setProperty(""String_Node_Str"",RESOURCE_ONLY_LIST_FILE);
  for (  final String file : chunkedDitamapSet) {
    job.getOrCreateFileInfo(file).isChunkedDitaMap=true;
  }
  for (  final String file : chunkedDitamapSet) {
    job.getOrCreateFileInfo(file).isChunked=true;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.logError(ex.getMessage(),ex);
  }
}","private void updateList(final Map<String,String> changeTable,final Hashtable<String,String> conflictTable,final AbstractPipelineInput input){
  final File tempDir=new File(input.getAttribute(ANT_INVOKER_PARAM_TEMPDIR));
  if (!tempDir.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"" + tempDir + ""String_Node_Str"");
  }
  final File xmlDitalist=new File(tempDir,""String_Node_Str"");
  Job job=null;
  try {
    job=new Job(tempDir);
  }
 catch (  final IOException ex) {
    logger.logError(ex.getMessage(),ex);
  }
  final Set<String> hrefTopics=job.getSet(HREF_TOPIC_LIST);
  final Set<String> chunkTopics=job.getSet(CHUNK_TOPIC_LIST);
  for (  final String s : chunkTopics) {
    if (!StringUtils.isEmptyString(s) && getFragment(s) == null) {
      final Iterator<String> hrefit=hrefTopics.iterator();
      while (hrefit.hasNext()) {
        final String ent=hrefit.next();
        if (FileUtils.resolveFile(tempDir.getAbsolutePath(),ent).equalsIgnoreCase(FileUtils.resolveFile(tempDir.getAbsolutePath(),s))) {
          hrefit.remove();
        }
      }
    }
 else     if (!StringUtils.isEmptyString(s) && hrefTopics.contains(s)) {
      hrefTopics.remove(s);
    }
  }
  final Set<String> topicList=new LinkedHashSet<String>(INT_128);
  final Set<String> oldTopicList=job.getSet(FULL_DITA_TOPIC_LIST);
  for (  String t : hrefTopics) {
    if (t.lastIndexOf(SHARP) != -1) {
      t=t.substring(0,t.lastIndexOf(SHARP));
    }
    t=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),FileUtils.resolveFile(tempDir.getAbsolutePath(),t));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  final Set<String> chunkedTopicSet=new LinkedHashSet<String>(INT_128);
  final Set<String> chunkedDitamapSet=new LinkedHashSet<String>(INT_128);
  final Set<String> ditamapList=job.getSet(FULL_DITAMAP_LIST);
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      String newChunkedFile=entry.getValue();
      newChunkedFile=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),newChunkedFile);
      final String extName=FileUtils.getExtension(newChunkedFile);
      if (extName != null && !extName.equalsIgnoreCase(""String_Node_Str"")) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  final String s : oldTopicList) {
    if (!StringUtils.isEmptyString(s)) {
      final File f=new File(tempDir,s);
      if (f.exists()) {
        f.delete();
      }
    }
  }
  for (  final Map.Entry<String,String> entry : changeTable.entrySet()) {
    final String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      final String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        final File target=new File(targetPath);
        if (!FileUtils.fileExists(target.getAbsolutePath())) {
          final File from=new File(entry.getValue());
          String relativePath=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),from.getAbsolutePath());
          final String relativeTargetPath=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),target.getAbsolutePath());
          if (relativeTargetPath.lastIndexOf(SLASH) != -1) {
            relativePath2fix.put(relativeTargetPath,relativeTargetPath.substring(0,relativeTargetPath.lastIndexOf(SLASH) + 1));
          }
          target.delete();
          from.renameTo(target);
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=FileUtils.getRelativePath(xmlDitalist.getAbsolutePath(),target.getAbsolutePath());
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  for (  final String file : chunkedTopicSet) {
    job.getOrCreateFileInfo(file).isResourceOnly=false;
  }
  for (  final String file : chunkedDitamapSet) {
    job.getOrCreateFileInfo(file).isResourceOnly=false;
  }
  for (  FileInfo f : job.getFileInfo().values()) {
    if (""String_Node_Str"".equals(f.format) || ""String_Node_Str"".equals(f.format)) {
      f.isActive=false;
    }
  }
  for (  final String file : topicList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=""String_Node_Str"";
    ff.isActive=true;
  }
  for (  final String file : ditamapList) {
    final FileInfo ff=job.getOrCreateFileInfo(file);
    ff.format=""String_Node_Str"";
    ff.isActive=true;
  }
  job.setProperty(""String_Node_Str"",CHUNKED_DITAMAP_LIST_FILE);
  job.setProperty(""String_Node_Str"",CHUNKED_TOPIC_LIST_FILE);
  job.setProperty(""String_Node_Str"",RESOURCE_ONLY_LIST_FILE);
  for (  final String file : chunkedDitamapSet) {
    job.getOrCreateFileInfo(file).isChunkedDitaMap=true;
  }
  for (  final String file : chunkedTopicSet) {
    job.getOrCreateFileInfo(file).isChunked=true;
  }
  try {
    job.write();
  }
 catch (  final IOException ex) {
    logger.logError(ex.getMessage(),ex);
  }
}",0.9989486595409148
100780,"/** 
 * Add set of values of job configuration
 * @param prop job configuration
 * @param key list name
 * @param set values to add
 */
private void addSetToProperties(final Job prop,final String key,final Set<String> set){
  final Set<String> newSet=new LinkedHashSet<String>(INT_128);
  for (  final String file : set) {
    if (new File(file).isAbsolute()) {
      newSet.add(FileUtils.normalize(file));
    }
 else {
      newSet.add(FileUtils.separatorsToUnix(FileUtils.normalize(prefix + file)));
    }
  }
  prop.setSet(key,newSet);
}","/** 
 * Add set of values of job configuration
 * @param prop job configuration
 * @param key list name
 * @param set values to add
 */
private void addSetToProperties(final Job prop,final String key,final Set<String> set){
  final Set<String> newSet=new LinkedHashSet<String>(INT_128);
  for (  final String file : set) {
    if (new File(file).isAbsolute()) {
      newSet.add(FileUtils.normalize(file));
    }
 else {
      newSet.add(FileUtils.normalize(prefix + file));
    }
  }
  prop.setSet(key,newSet);
}",0.9468690702087288
100781,"/** 
 * Normalize the input file path, by replacing all the '\\', '/' with File.seperator, and removing '..' from the directory. <p>Note: the substring behind ""#"" will be removed.</p>
 * @param basedir base dir
 * @param filepath file path
 * @return normalized path
 */
public static String normalizeDirectory(final String basedir,final String filepath){
  final String pathname=stripFragment(filepath);
  if (basedir == null || basedir.length() == 0) {
    return pathname;
  }
  final String normilizedPath=new File(basedir,pathname).getPath();
  return FileUtils.normalize(normilizedPath);
}","/** 
 * Normalize the input file path, by replacing all the '\\', '/' with File.seperator, and removing '..' from the directory. <p>Note: the substring behind ""#"" will be removed.</p> TODO: Return File
 * @param basedir base dir
 * @param filepath file path
 * @return normalized path
 */
public static String normalizeDirectory(final String basedir,final String filepath){
  final String pathname=FileUtils.normalize(stripFragment(filepath));
  if (basedir == null || basedir.length() == 0) {
    return pathname;
  }
  final String normilizedPath=new File(basedir,pathname).getPath();
  return FileUtils.normalize(normilizedPath);
}",0.934092758340114
100782,"/** 
 * Remove redundant names "".."" and ""."" from the given path.
 * @param path input path
 * @param separator directory separator
 * @return processed path
 */
public static String normalize(final String path,final String separator){
  final List<String> dirs=new LinkedList<String>();
  final StringTokenizer tokenizer=new StringTokenizer(path,separator);
  while (tokenizer.hasMoreTokens()) {
    final String token=tokenizer.nextToken();
    if (!(""String_Node_Str"".equals(token))) {
      dirs.add(token);
    }
  }
  int dirNum=dirs.size();
  int i=0;
  while (i < dirNum) {
    if (i > 0) {
      final String lastDir=dirs.get(i - 1);
      final String dir=dirs.get(i);
      if (""String_Node_Str"".equals(dir) && !(""String_Node_Str"".equals(lastDir))) {
        dirs.remove(i);
        dirs.remove(i - 1);
        dirNum=dirs.size();
        i=i - 1;
        continue;
      }
    }
    i++;
  }
  final StringBuffer buff=new StringBuffer(path.length());
  if (path.startsWith(separator + separator)) {
    buff.append(separator).append(separator);
  }
 else   if (path.startsWith(separator)) {
    buff.append(separator);
  }
  final Iterator<String> iter=dirs.iterator();
  while (iter.hasNext()) {
    buff.append(iter.next());
    if (iter.hasNext()) {
      buff.append(separator);
    }
  }
  if (path.endsWith(separator)) {
    buff.append(separator);
  }
  return buff.toString();
}","/** 
 * Remove redundant names "".."" and ""."" from the given path and replace directory separators.
 * @param path input path
 * @param separator directory separator
 * @return processed path
 */
public static String normalize(final String path,final String separator){
  final String p=path.replace(WINDOWS_SEPARATOR,separator).replace(UNIX_SEPARATOR,separator);
  final List<String> dirs=new LinkedList<String>();
  final StringTokenizer tokenizer=new StringTokenizer(p,separator);
  while (tokenizer.hasMoreTokens()) {
    final String token=tokenizer.nextToken();
    if (!(""String_Node_Str"".equals(token))) {
      dirs.add(token);
    }
  }
  int dirNum=dirs.size();
  int i=0;
  while (i < dirNum) {
    if (i > 0) {
      final String lastDir=dirs.get(i - 1);
      final String dir=dirs.get(i);
      if (""String_Node_Str"".equals(dir) && !(""String_Node_Str"".equals(lastDir))) {
        dirs.remove(i);
        dirs.remove(i - 1);
        dirNum=dirs.size();
        i=i - 1;
        continue;
      }
    }
    i++;
  }
  final StringBuffer buff=new StringBuffer(p.length());
  if (p.startsWith(separator + separator)) {
    buff.append(separator).append(separator);
  }
 else   if (p.startsWith(separator)) {
    buff.append(separator);
  }
  final Iterator<String> iter=dirs.iterator();
  while (iter.hasNext()) {
    buff.append(iter.next());
    if (iter.hasNext()) {
      buff.append(separator);
    }
  }
  if (p.endsWith(separator)) {
    buff.append(separator);
  }
  return buff.toString();
}",0.93805918788713
100783,"FileInfo(final String file){
  this.uri=toURI(new File(file));
  this.file=file;
}","FileInfo(final String file){
  if (file == null)   throw new IllegalArgumentException(new NullPointerException());
  this.uri=toURI(new File(file));
  this.file=file;
}",0.656
100784,"private FileInfo getOrAdd(final String f){
  FileInfo i=files.get(f);
  if (i == null) {
    i=new FileInfo(f);
    files.put(f,i);
  }
  return i;
}","/** 
 * Get or create FileInfo for given path.
 * @param file system path
 */
private FileInfo getOrAdd(final String file){
  final String f=FileUtils.normalize(file);
  FileInfo i=files.get(f);
  if (i == null) {
    i=new FileInfo(f);
    files.put(f,i);
  }
  return i;
}",0.7044917257683215
100785,"public FileInfo build(){
  if (uri == null && file == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final FileInfo fi=uri != null ? new FileInfo(uri) : new FileInfo(file);
  fi.format=format;
  fi.hasConref=hasConref;
  fi.isChunked=isChunked;
  fi.hasLink=hasLink;
  fi.isResourceOnly=isResourceOnly;
  fi.isTarget=isTarget;
  fi.isConrefTarget=isConrefTarget;
  fi.isNonConrefTarget=isNonConrefTarget;
  fi.isConrefPush=isConrefPush;
  fi.hasKeyref=hasKeyref;
  fi.hasCoderef=hasCoderef;
  fi.isSubjectScheme=isSubjectScheme;
  fi.isSkipChunk=isSkipChunk;
  fi.isSubtarget=isSubtarget;
  fi.isFlagImage=isFlagImage;
  fi.isChunkedDitaMap=isChunkedDitaMap;
  fi.isOutDita=isOutDita;
  fi.isCopyToSource=isCopyToSource;
  fi.isActive=isActive;
  return fi;
}","public FileInfo build(){
  if (uri == null && file == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final FileInfo fi=uri != null ? new FileInfo(uri) : new FileInfo(file);
  fi.format=format;
  fi.hasConref=hasConref;
  fi.isChunked=isChunked;
  fi.hasLink=hasLink;
  fi.isResourceOnly=isResourceOnly;
  fi.isTarget=isTarget;
  fi.isConrefTarget=isConrefTarget;
  fi.isNonConrefTarget=isNonConrefTarget;
  fi.isConrefPush=isConrefPush;
  fi.hasKeyref=hasKeyref;
  fi.hasCoderef=hasCoderef;
  fi.isSubjectScheme=isSubjectScheme;
  fi.isSkipChunk=isSkipChunk;
  fi.isSubtarget=isSubtarget;
  fi.isFlagImage=isFlagImage;
  fi.isChunkedDitaMap=isChunkedDitaMap;
  fi.isOutDita=isOutDita;
  fi.isCopyToSource=isCopyToSource;
  fi.isActive=isActive;
  return fi;
}",0.9917038927887684
100786,"/** 
 * Convert URI references to file paths.
 * @param filename file reference
 * @return file path
 */
private static File toFile(final String filename){
  if (filename == null) {
    return null;
  }
  String f=filename;
  try {
    f=URLDecoder.decode(filename,UTF8);
  }
 catch (  final UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
  if (processingMode == Mode.LAX) {
    f=f.replace(WINDOWS_SEPARATOR,File.separator);
  }
  f=f.replace(URI_SEPARATOR,File.separator);
  return new File(f);
}","/** 
 * Convert URI or chimera references to file paths.
 * @param filename file reference
 * @return file path
 */
private static File toFile(final String filename){
  if (filename == null) {
    return null;
  }
  String f=filename;
  try {
    f=URLDecoder.decode(filename,UTF8);
  }
 catch (  final UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
  f=f.replace(WINDOWS_SEPARATOR,File.separator).replace(UNIX_SEPARATOR,File.separator);
  return new File(f);
}",0.9376854599406528
100787,"@Test public void testFileContentAbove() throws Exception {
  final File e=new File(expDir,""String_Node_Str"");
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  final Properties ditaProps=readProperties(new File(tempDirAbove,FILE_NAME_DITA_LIST));
  assertEquals(""String_Node_Str"",ditaProps.getProperty(""String_Node_Str""));
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  final DocumentBuilder builder=factory.newDocumentBuilder();
  final Document document=builder.parse(new File(tempDirAbove + File.separator + KEYDEF_LIST_FILE));
  final Element elem=document.getDocumentElement();
  final NodeList nodeList=elem.getElementsByTagName(""String_Node_Str"");
  final Map<String,List<String>> expKeyDef=new HashMap<String,List<String>>();
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str"",""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str"",""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str"",""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (int i=0; i < nodeList.getLength(); i++) {
    final Element el=(Element)nodeList.item(i);
    final List<String> exp=expKeyDef.get(el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(0),el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(1),el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(2),el.getAttribute(""String_Node_Str""));
  }
}","@Test public void testFileContentAbove() throws Exception {
  final File e=new File(expDir,""String_Node_Str"");
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  final Properties ditaProps=readProperties(new File(tempDirAbove,FILE_NAME_DITA_LIST));
  assertEquals(""String_Node_Str"",ditaProps.getProperty(""String_Node_Str""));
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  final DocumentBuilder builder=factory.newDocumentBuilder();
  final Document document=builder.parse(new File(tempDirAbove + File.separator + KEYDEF_LIST_FILE));
  final Element elem=document.getDocumentElement();
  final NodeList nodeList=elem.getElementsByTagName(""String_Node_Str"");
  final Map<String,List<String>> expKeyDef=new HashMap<String,List<String>>();
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str"",""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str"",""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str"",""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (int i=0; i < nodeList.getLength(); i++) {
    final Element el=(Element)nodeList.item(i);
    final List<String> exp=expKeyDef.get(el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(0),el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(1),el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(2),el.getAttribute(""String_Node_Str""));
  }
}",0.9896060567175672
100788,"@Test public void testFileContentParallel() throws Exception {
  final File e=new File(expDir,""String_Node_Str"");
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  final Properties ditaProps=readProperties(new File(tempDirParallel,FILE_NAME_DITA_LIST));
  assertEquals(""String_Node_Str"" + File.separator,ditaProps.getProperty(""String_Node_Str""));
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  final DocumentBuilder builder=factory.newDocumentBuilder();
  final Document document=builder.parse(new File(tempDirParallel + File.separator + KEYDEF_LIST_FILE));
  final Element elem=document.getDocumentElement();
  final NodeList nodeList=elem.getElementsByTagName(""String_Node_Str"");
  final Map<String,List<String>> expKeyDef=new HashMap<String,List<String>>();
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  for (int i=0; i < nodeList.getLength(); i++) {
    final Element el=(Element)nodeList.item(i);
    final List<String> exp=expKeyDef.get(el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(0),el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(1),el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(2),el.getAttribute(""String_Node_Str""));
  }
}","@Test public void testFileContentParallel() throws Exception {
  final File e=new File(expDir,""String_Node_Str"");
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(Collections.emptySet(),readLines(new File(e,""String_Node_Str"")));
  assertEquals(new HashSet<String>(Arrays.asList(""String_Node_Str"")),readLines(new File(e,""String_Node_Str"")));
  final Properties ditaProps=readProperties(new File(tempDirParallel,FILE_NAME_DITA_LIST));
  assertEquals(""String_Node_Str"" + File.separator,ditaProps.getProperty(""String_Node_Str""));
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  final DocumentBuilder builder=factory.newDocumentBuilder();
  final Document document=builder.parse(new File(tempDirParallel + File.separator + KEYDEF_LIST_FILE));
  final Element elem=document.getDocumentElement();
  final NodeList nodeList=elem.getElementsByTagName(""String_Node_Str"");
  final Map<String,List<String>> expKeyDef=new HashMap<String,List<String>>();
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str""));
  expKeyDef.put(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + URI_SEPARATOR + ""String_Node_Str""));
  for (int i=0; i < nodeList.getLength(); i++) {
    final Element el=(Element)nodeList.item(i);
    final List<String> exp=expKeyDef.get(el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(0),el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(1),el.getAttribute(""String_Node_Str""));
    assertEquals(exp.get(2),el.getAttribute(""String_Node_Str""));
  }
}",0.9974610083424011
100789,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    String attValue=attributes.getValue(ATTRIBUTE_NAME_HREF);
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref);
        if (util.isVisited(attValue)) {
          attValue=SHARP + util.getIdValue(attValue);
        }
 else {
          String p=null;
          try {
            p=FileUtils.normalize(URLDecoder.decode(FileUtils.stripFragment(attValue),UTF8));
          }
 catch (          final UnsupportedEncodingException e) {
            throw new RuntimeException(e);
          }
          util.visit(p);
          if (p != null) {
            final File f=new File(dirPath,p);
            if (f.exists()) {
              topicParser.parse(p,dirPath);
              final String fileId=topicParser.getFirstTopicId();
              util.addId(attValue,fileId);
              final String firstTopicId=SHARP + fileId;
              if (util.getIdValue(attValue) != null) {
                attValue=SHARP + util.getIdValue(attValue);
              }
 else {
                attValue=firstTopicId;
              }
              XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId);
            }
 else {
              final String fileName=new File(dirPath,attValue).getAbsolutePath();
              logger.logError(MessageUtils.getInstance().getMessage(""String_Node_Str"",fileName).toString());
            }
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue);
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    String attValue=attributes.getValue(ATTRIBUTE_NAME_HREF);
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref);
        if (util.isVisited(attValue)) {
          attValue=SHARP + util.getIdValue(attValue);
        }
 else {
          String p=null;
          try {
            p=FileUtils.normalize(URLDecoder.decode(FileUtils.stripFragment(attValue),UTF8));
          }
 catch (          final UnsupportedEncodingException e) {
            throw new RuntimeException(e);
          }
          util.visit(p);
          if (p != null) {
            final File f=new File(dirPath,p);
            if (f.exists()) {
              topicParser.parse(p,dirPath);
              final String fileId=topicParser.getFirstTopicId();
              util.addId(attValue,fileId);
              if (FileUtils.getFragment(attValue) != null) {
                util.addId(FileUtils.stripFragment(attValue),fileId);
              }
              final String firstTopicId=SHARP + fileId;
              if (util.getIdValue(attValue) != null) {
                attValue=SHARP + util.getIdValue(attValue);
              }
 else {
                attValue=firstTopicId;
              }
              XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId);
            }
 else {
              final String fileName=new File(dirPath,attValue).getAbsolutePath();
              logger.logError(MessageUtils.getInstance().getMessage(""String_Node_Str"",fileName).toString());
            }
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue);
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}",0.9742240925828513
100790,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    String attValue=attributes.getValue(ATTRIBUTE_NAME_HREF);
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref);
        if (util.isVisited(attValue)) {
          attValue=SHARP + util.getIdValue(attValue);
        }
 else {
          String p=null;
          try {
            p=FileUtils.normalize(URLDecoder.decode(FileUtils.stripFragment(attValue),UTF8));
          }
 catch (          final UnsupportedEncodingException e) {
            throw new RuntimeException(e);
          }
          util.visit(p);
          if (p != null) {
            final File f=new File(dirPath,p);
            if (f.exists()) {
              topicParser.parse(p,dirPath);
              final String fileId=topicParser.getFirstTopicId();
              util.addId(attValue,fileId);
              final String firstTopicId=SHARP + fileId;
              if (util.getIdValue(attValue) != null) {
                attValue=SHARP + util.getIdValue(attValue);
              }
 else {
                attValue=firstTopicId;
              }
              XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId);
            }
 else {
              final String fileName=new File(dirPath,attValue).getAbsolutePath();
              logger.logError(MessageUtils.getInstance().getMessage(""String_Node_Str"",fileName).toString());
            }
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue);
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    String attValue=attributes.getValue(ATTRIBUTE_NAME_HREF);
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref);
        if (util.isVisited(attValue)) {
          attValue=SHARP + util.getIdValue(attValue);
        }
 else {
          String p=null;
          try {
            p=FileUtils.normalize(URLDecoder.decode(FileUtils.stripFragment(attValue),UTF8));
          }
 catch (          final UnsupportedEncodingException e) {
            throw new RuntimeException(e);
          }
          util.visit(p);
          if (p != null) {
            final File f=new File(dirPath,p);
            if (f.exists()) {
              topicParser.parse(p,dirPath);
              final String fileId=topicParser.getFirstTopicId();
              util.addId(attValue,fileId);
              if (FileUtils.getFragment(attValue) != null) {
                util.addId(FileUtils.stripFragment(attValue),fileId);
              }
              final String firstTopicId=SHARP + fileId;
              if (util.getIdValue(attValue) != null) {
                attValue=SHARP + util.getIdValue(attValue);
              }
 else {
                attValue=firstTopicId;
              }
              XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId);
            }
 else {
              final String fileName=new File(dirPath,attValue).getAbsolutePath();
              logger.logError(MessageUtils.getInstance().getMessage(""String_Node_Str"",fileName).toString());
            }
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue);
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}",0.9742240925828513
100791,"/** 
 * Task execute point.
 * @throws BuildException exception
 * @see org.apache.tools.ant.taskdefs.Echo#execute()
 */
@Override public void execute() throws BuildException {
  final ArrayList<String> prop=new ArrayList<String>();
  for (  final Param p : params) {
    if (!p.isValid()) {
      throw new BuildException(""String_Node_Str"");
    }
    final String ifProperty=p.getIf();
    final String unlessProperty=p.getUnless();
    if ((ifProperty == null || getProject().getProperties().containsKey(ifProperty)) && (unlessProperty == null || !getProject().getProperties().containsKey(unlessProperty))) {
      final int idx=Integer.parseInt(p.getName()) - 1;
      prop.set(idx,p.getValue());
    }
  }
  logger=new DITAOTAntLogger(getProject());
  final MessageBean msgBean=MessageUtils.getInstance().getMessage(id,prop.toArray(new String[prop.size()]));
  if (msgBean != null) {
    final String type=msgBean.getType();
    if (ERROR.equals(type)) {
      logger.logError(msgBean.toString());
    }
 else     if (WARN.equals(type)) {
      logger.logWarn(msgBean.toString());
    }
 else     if (INFO.equals(type)) {
      logger.logInfo(msgBean.toString());
    }
 else     if (DEBUG.equals(type)) {
      logger.logDebug(msgBean.toString());
    }
  }
}","/** 
 * Task execute point.
 * @throws BuildException exception
 * @see org.apache.tools.ant.taskdefs.Echo#execute()
 */
@Override public void execute() throws BuildException {
  logger=new DITAOTAntLogger(getProject());
  final MessageBean msgBean=MessageUtils.getInstance().getMessage(id,readParamValues());
  if (msgBean != null) {
    final String type=msgBean.getType();
    if (ERROR.equals(type)) {
      logger.logError(msgBean.toString());
    }
 else     if (WARN.equals(type)) {
      logger.logWarn(msgBean.toString());
    }
 else     if (INFO.equals(type)) {
      logger.logInfo(msgBean.toString());
    }
 else     if (DEBUG.equals(type)) {
      logger.logDebug(msgBean.toString());
    }
  }
}",0.7034412955465587
100792,"/** 
 * Task execute point.
 * @throws BuildException exception
 * @see org.apache.tools.ant.taskdefs.Exit#execute()
 */
@Override public void execute() throws BuildException {
  final boolean fail=nestedConditionPresent() ? testNestedCondition() : (testIfCondition() && testUnlessCondition());
  if (!fail) {
    return;
  }
  if (id == null) {
    throw new BuildException(""String_Node_Str"");
  }
  final ArrayList<String> prop=new ArrayList<String>();
  for (  final Param p : params) {
    if (!p.isValid()) {
      throw new BuildException(""String_Node_Str"");
    }
    final String ifProperty=p.getIf();
    final String unlessProperty=p.getUnless();
    if ((ifProperty == null || getProject().getProperties().containsKey(ifProperty)) && (unlessProperty == null || !getProject().getProperties().containsKey(unlessProperty))) {
      final int idx=Integer.parseInt(p.getName()) - 1;
      prop.set(idx,p.getValue());
    }
  }
  final MessageBean msgBean=MessageUtils.getInstance().getMessage(id,prop.toArray(new String[prop.size()]));
  final DITAOTLogger logger=new DITAOTAntLogger(getProject());
  if (msgBean != null) {
    final String type=msgBean.getType();
    if (FATAL.equals(type)) {
      setMessage(msgBean.toString());
      try {
        super.execute();
      }
 catch (      final BuildException ex) {
        throw new BuildException(msgBean.toString(),new DITAOTException(msgBean,ex,msgBean.toString()));
      }
    }
 else     if (ERROR.equals(type)) {
      logger.logError(msgBean.toString());
    }
 else     if (WARN.equals(type)) {
      logger.logWarn(msgBean.toString());
    }
 else     if (INFO.equals(type)) {
      logger.logInfo(msgBean.toString());
    }
 else     if (DEBUG.equals(type)) {
      logger.logDebug(msgBean.toString());
    }
  }
}","/** 
 * Task execute point.
 * @throws BuildException exception
 * @see org.apache.tools.ant.taskdefs.Exit#execute()
 */
@Override public void execute() throws BuildException {
  final boolean fail=nestedConditionPresent() ? testNestedCondition() : (testIfCondition() && testUnlessCondition());
  if (!fail) {
    return;
  }
  if (id == null) {
    throw new BuildException(""String_Node_Str"");
  }
  final MessageBean msgBean=MessageUtils.getInstance().getMessage(id,readParamValues());
  final DITAOTLogger logger=new DITAOTAntLogger(getProject());
  if (msgBean != null) {
    final String type=msgBean.getType();
    if (FATAL.equals(type)) {
      setMessage(msgBean.toString());
      try {
        super.execute();
      }
 catch (      final BuildException ex) {
        throw new BuildException(msgBean.toString(),new DITAOTException(msgBean,ex,msgBean.toString()));
      }
    }
 else     if (ERROR.equals(type)) {
      logger.logError(msgBean.toString());
    }
 else     if (WARN.equals(type)) {
      logger.logWarn(msgBean.toString());
    }
 else     if (INFO.equals(type)) {
      logger.logInfo(msgBean.toString());
    }
 else     if (DEBUG.equals(type)) {
      logger.logDebug(msgBean.toString());
    }
  }
}",0.8057029177718833
100793,"/** 
 * Read temporary configuration files. If configuration files are not found, assume an empty job object is being created.
 * @throws IOException if reading configuration files failed
 * @throws SAXException if XML parsing failed
 * @throws IllegalStateException if configuration files are missing
 */
private void read() throws IOException {
  final File jobFile=new File(tempDir,JOB_FILE);
  if (jobFile.exists()) {
    try {
      XMLReader parser=StringUtils.getXMLReader();
      parser.setContentHandler(new JobHandler(prop));
      parser.parse(jobFile.toURI().toString());
    }
 catch (    final SAXException e) {
      throw new IOException(""String_Node_Str"" + e.getMessage());
    }
    return;
  }
  final Properties p=new Properties();
  final File ditalist=new File(tempDir,FILE_NAME_DITA_LIST);
  final File xmlDitalist=new File(tempDir,FILE_NAME_DITA_LIST_XML);
  InputStream in=null;
  try {
    if (xmlDitalist.exists()) {
      in=new FileInputStream(xmlDitalist);
      p.loadFromXML(in);
    }
 else     if (ditalist.exists()) {
      in=new FileInputStream(ditalist);
      p.load(in);
    }
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  readProperties(p);
}","/** 
 * Read temporary configuration files. If configuration files are not found, assume an empty job object is being created.
 * @throws IOException if reading configuration files failed
 * @throws SAXException if XML parsing failed
 * @throws IllegalStateException if configuration files are missing
 */
private void read() throws IOException {
  final File jobFile=new File(tempDir,JOB_FILE);
  if (jobFile.exists()) {
    InputStream in=null;
    try {
      XMLReader parser=StringUtils.getXMLReader();
      parser.setContentHandler(new JobHandler(prop));
      in=new FileInputStream(jobFile);
      parser.parse(new InputSource(in));
    }
 catch (    final SAXException e) {
      throw new IOException(""String_Node_Str"" + e.getMessage());
    }
 finally {
      if (in != null) {
        in.close();
      }
    }
    return;
  }
  final Properties p=new Properties();
  final File ditalist=new File(tempDir,FILE_NAME_DITA_LIST);
  final File xmlDitalist=new File(tempDir,FILE_NAME_DITA_LIST_XML);
  InputStream in=null;
  try {
    if (xmlDitalist.exists()) {
      in=new FileInputStream(xmlDitalist);
      p.loadFromXML(in);
    }
 else     if (ditalist.exists()) {
      in=new FileInputStream(ditalist);
      p.load(in);
    }
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  readProperties(p);
}",0.9387483355525964
100794,"/** 
 * Store job into temporary configuration files.
 * @throws IOException if writing configuration files failed
 */
public void write() throws IOException {
  OutputStream outStream=null;
  XMLStreamWriter out=null;
  try {
    outStream=new FileOutputStream(new File(tempDir,JOB_FILE));
    out=XMLOutputFactory.newInstance().createXMLStreamWriter(outStream);
    out.writeStartDocument();
    out.writeStartElement(ELEMENT_JOB);
    for (    final Map.Entry<String,Object> e : prop.entrySet()) {
      out.writeStartElement(ELEMENT_PROPERTY);
      out.writeAttribute(ATTRIBUTE_NAME,e.getKey());
      if (e.getValue() instanceof String) {
        out.writeStartElement(ELEMENT_STRING);
        out.writeCharacters(e.getValue().toString());
        out.writeEndElement();
      }
 else       if (e.getValue() instanceof Set) {
        out.writeStartElement(ELEMENT_SET);
        final Set<?> s=(Set<?>)e.getValue();
        for (        final Object o : s) {
          out.writeStartElement(ELEMENT_STRING);
          out.writeCharacters(o.toString());
          out.writeEndElement();
        }
        out.writeEndElement();
      }
 else       if (e.getValue() instanceof Map) {
        out.writeStartElement(ELEMENT_MAP);
        final Map<?,?> s=(Map<?,?>)e.getValue();
        for (        final Map.Entry<?,?> o : s.entrySet()) {
          out.writeStartElement(ELEMENT_ENTRY);
          out.writeAttribute(ATTRIBUTE_KEY,o.getKey().toString());
          out.writeStartElement(ELEMENT_STRING);
          out.writeCharacters(o.getValue().toString());
          out.writeEndElement();
          out.writeEndElement();
        }
        out.writeEndElement();
      }
 else {
        out.writeStartElement(e.getValue().getClass().getName());
        out.writeCharacters(e.getValue().toString());
        out.writeEndElement();
      }
      out.writeEndElement();
    }
    out.writeEndElement();
    out.writeEndDocument();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
catch (  final XMLStreamException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final XMLStreamException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
    if (outStream != null) {
      try {
        outStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  final Properties p=new Properties();
  for (  final Map.Entry<String,Object> e : prop.entrySet()) {
    if (e.getValue() instanceof Set) {
      p.put(e.getKey(),StringUtils.assembleString((Collection)e.getValue(),COMMA));
    }
 else     if (e.getValue() instanceof Map) {
      p.put(e.getKey(),StringUtils.assembleString((Map)e.getValue(),COMMA));
    }
 else {
      p.put(e.getKey(),e.getValue());
    }
  }
  FileOutputStream propertiesOutputStream=null;
  try {
    propertiesOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST));
    p.store(propertiesOutputStream,null);
    propertiesOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (propertiesOutputStream != null) {
      try {
        propertiesOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  FileOutputStream xmlOutputStream=null;
  try {
    xmlOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST_XML));
    p.storeToXML(xmlOutputStream,null);
    xmlOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (xmlOutputStream != null) {
      try {
        xmlOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
}","/** 
 * Store job into temporary configuration files.
 * @throws IOException if writing configuration files failed
 */
public void write() throws IOException {
  OutputStream outStream=null;
  XMLStreamWriter out=null;
  try {
    outStream=new FileOutputStream(new File(tempDir,JOB_FILE));
    out=XMLOutputFactory.newInstance().createXMLStreamWriter(outStream,""String_Node_Str"");
    out.writeStartDocument();
    out.writeStartElement(ELEMENT_JOB);
    for (    final Map.Entry<String,Object> e : prop.entrySet()) {
      out.writeStartElement(ELEMENT_PROPERTY);
      out.writeAttribute(ATTRIBUTE_NAME,e.getKey());
      if (e.getValue() instanceof String) {
        out.writeStartElement(ELEMENT_STRING);
        out.writeCharacters(e.getValue().toString());
        out.writeEndElement();
      }
 else       if (e.getValue() instanceof Set) {
        out.writeStartElement(ELEMENT_SET);
        final Set<?> s=(Set<?>)e.getValue();
        for (        final Object o : s) {
          out.writeStartElement(ELEMENT_STRING);
          out.writeCharacters(o.toString());
          out.writeEndElement();
        }
        out.writeEndElement();
      }
 else       if (e.getValue() instanceof Map) {
        out.writeStartElement(ELEMENT_MAP);
        final Map<?,?> s=(Map<?,?>)e.getValue();
        for (        final Map.Entry<?,?> o : s.entrySet()) {
          out.writeStartElement(ELEMENT_ENTRY);
          out.writeAttribute(ATTRIBUTE_KEY,o.getKey().toString());
          out.writeStartElement(ELEMENT_STRING);
          out.writeCharacters(o.getValue().toString());
          out.writeEndElement();
          out.writeEndElement();
        }
        out.writeEndElement();
      }
 else {
        out.writeStartElement(e.getValue().getClass().getName());
        out.writeCharacters(e.getValue().toString());
        out.writeEndElement();
      }
      out.writeEndElement();
    }
    out.writeEndElement();
    out.writeEndDocument();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
catch (  final XMLStreamException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      final XMLStreamException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
    if (outStream != null) {
      try {
        outStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  final Properties p=new Properties();
  for (  final Map.Entry<String,Object> e : prop.entrySet()) {
    if (e.getValue() instanceof Set) {
      p.put(e.getKey(),StringUtils.assembleString((Collection)e.getValue(),COMMA));
    }
 else     if (e.getValue() instanceof Map) {
      p.put(e.getKey(),StringUtils.assembleString((Map)e.getValue(),COMMA));
    }
 else {
      p.put(e.getKey(),e.getValue());
    }
  }
  FileOutputStream propertiesOutputStream=null;
  try {
    propertiesOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST));
    p.store(propertiesOutputStream,null);
    propertiesOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (propertiesOutputStream != null) {
      try {
        propertiesOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  FileOutputStream xmlOutputStream=null;
  try {
    xmlOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST_XML));
    p.storeToXML(xmlOutputStream,null);
    xmlOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (xmlOutputStream != null) {
      try {
        xmlOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
}",0.9977810650887574
100795,"/** 
 * Parse the input attributes for needed information.
 * @param atts all attributes
 * @param attrName attributes to process
 */
private void parseAttribute(final Attributes atts,final String attrName) throws SAXException {
  String attrValue=atts.getValue(attrName);
  String filename=null;
  final String attrClass=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  final String attrFormat=atts.getValue(ATTRIBUTE_NAME_FORMAT);
  final String attrType=atts.getValue(ATTRIBUTE_NAME_TYPE);
  final String codebase=atts.getValue(ATTRIBUTE_NAME_CODEBASE);
  if (attrValue == null) {
    return;
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) || ATTRIBUTE_NAME_CONKEYREF.equals(attrName)) {
    hasConRef=true;
  }
 else   if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
    if (attrClass != null && PR_D_CODEREF.matches(attrClass)) {
      hasCodeRef=true;
    }
 else {
      hasHref=true;
    }
  }
 else   if (ATTRIBUTE_NAME_KEYREF.equals(attrName)) {
    hasKeyRef=true;
  }
  if (ATTRIBUTE_NAME_KEYS.equals(attrName) && attrValue.length() != 0) {
    String target=atts.getValue(ATTRIBUTE_NAME_HREF);
    if (target != null && (attrFormat == null || attrFormat.equals(ATTR_FORMAT_VALUE_DITA)) && extName != null) {
      target=FileUtils.replaceExtension(target,extName);
    }
    final String keyRef=atts.getValue(ATTRIBUTE_NAME_KEYREF);
    final String copy_to=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
    if (!StringUtils.isEmptyString(copy_to)) {
      target=copy_to;
    }
    if (target == null) {
      target=""String_Node_Str"";
    }
    final String temp=target;
    for (    final String key : attrValue.split(""String_Node_Str"")) {
      if (!isValidKeyName(key)) {
        logger.logError(MessageUtils.getMessage(""String_Node_Str"",key).toString());
        continue;
      }
      if (!keysDefMap.containsKey(key) && !key.equals(""String_Node_Str"")) {
        if (target != null && target.length() != 0) {
          if (attrScope != null && (attrScope.equals(""String_Node_Str"") || attrScope.equals(""String_Node_Str""))) {
            exKeysDefMap.put(key,target);
            keysDefMap.put(key,new KeyDef(key,target,null));
          }
 else {
            String tail=""String_Node_Str"";
            if (target.indexOf(SHARP) != -1) {
              tail=target.substring(target.indexOf(SHARP));
              target=target.substring(0,target.indexOf(SHARP));
            }
            if (new File(target).isAbsolute()) {
              target=FileUtils.getRelativePath(rootFilePath.getAbsolutePath(),target);
            }
            target=FileUtils.normalizeDirectory(currentDir,target);
            keysDefMap.put(key,new KeyDef(key,target + tail,null));
          }
        }
 else         if (!StringUtils.isEmptyString(keyRef)) {
          keysRefMap.put(key,keyRef);
        }
 else {
          keysDefMap.put(key,new KeyDef(key,null,null));
        }
      }
 else {
        final Properties prop=new Properties();
        prop.setProperty(""String_Node_Str"",key);
        prop.setProperty(""String_Node_Str"",target);
        logger.logInfo(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      }
      target=temp;
    }
  }
  if (""String_Node_Str"".equalsIgnoreCase(attrScope) || ""String_Node_Str"".equalsIgnoreCase(attrScope) || attrValue.indexOf(COLON_DOUBLE_SLASH) != -1 || attrValue.startsWith(SHARP)) {
    return;
  }
  if (attrValue.startsWith(""String_Node_Str"") && attrValue.indexOf(""String_Node_Str"") == -1) {
    attrValue=attrValue.substring(""String_Node_Str"".length());
    if (UNIX_SEPARATOR.equals(File.separator)) {
      attrValue=UNIX_SEPARATOR + attrValue;
    }
  }
 else   if (attrValue.startsWith(""String_Node_Str"") && !attrValue.startsWith(""String_Node_Str"")) {
    attrValue=attrValue.substring(""String_Node_Str"".length());
  }
  final File target=new File(attrValue);
  if (target.isAbsolute() && !ATTRIBUTE_NAME_DATA.equals(attrName)) {
    attrValue=FileUtils.getRelativePath(rootFilePath.getAbsolutePath(),attrValue);
  }
 else   if (ATTRIBUTE_NAME_DATA.equals(attrName)) {
    if (!StringUtils.isEmptyString(codebase)) {
      filename=FileUtils.normalizeDirectory(codebase,attrValue);
    }
 else {
      filename=FileUtils.normalizeDirectory(currentDir,attrValue);
    }
  }
 else {
    filename=FileUtils.normalizeDirectory(currentDir,attrValue);
  }
  if (filename != null) {
    try {
      filename=URLDecoder.decode(filename,UTF8);
    }
 catch (    final UnsupportedEncodingException e) {
      logger.logError(""String_Node_Str"" + filename + ""String_Node_Str""+ e.getMessage());
    }
    if (processingMode == Mode.LAX) {
      filename=filename.replace(WINDOWS_SEPARATOR,File.separator);
    }
  }
  if (MAP_TOPICREF.matches(attrClass)) {
    if (ATTR_TYPE_VALUE_SUBJECT_SCHEME.equalsIgnoreCase(attrType)) {
      schemeSet.add(filename);
    }
    if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
      if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(attrFormat)) {
        if (attrName.equals(ATTRIBUTE_NAME_HREF)) {
          topicHref=filename;
          topicHref=FileUtils.separatorsToUnix(topicHref);
          if (attrValue.lastIndexOf(SHARP) != -1) {
            final int position=attrValue.lastIndexOf(SHARP);
            topicId=attrValue.substring(position + 1);
          }
 else {
            if (FileUtils.isDITAFile(topicHref)) {
              topicId=topicHref + QUESTION;
            }
          }
        }
      }
 else {
        topicHref=""String_Node_Str"";
        topicId=""String_Node_Str"";
      }
    }
  }
  if ((""String_Node_Str"".equals(attrType) && ATTRIBUTE_NAME_DATA.equals(attrName)) || attrClass != null && PR_D_CODEREF.matches(attrClass)) {
    subsidiarySet.add(filename);
    return;
  }
  if (filename != null && FileUtils.isValidTarget(filename.toLowerCase()) && (StringUtils.isEmptyString(atts.getValue(ATTRIBUTE_NAME_COPY_TO)) || !FileUtils.isDITATopicFile(atts.getValue(ATTRIBUTE_NAME_COPY_TO).toLowerCase()) || (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) && !ATTRIBUTE_NAME_CONREF.equals(attrName) && !ATTRIBUTE_NAME_COPY_TO.equals(attrName) && (canResolved() || FileUtils.isSupportedImageFile(filename.toLowerCase()))) {
    nonConrefCopytoTargets.add(new Reference(filename,attrFormat));
  }
  if (attrFormat != null && !ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(attrFormat)) {
    return;
  }
  if (ATTRIBUTE_NAME_HREF.equals(attrName) && FileUtils.isDITATopicFile(filename) && canResolved()) {
    hrefTargets.add(new File(filename).getPath());
    toOutFile(new File(filename).getPath());
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0 && relTableLevel == 0) {
      chunkTopicSet.add(filename);
    }
 else {
      hrefTopicSet.add(filename);
    }
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) && FileUtils.isDITAFile(filename)) {
    conrefTargets.add(filename);
    toOutFile(new File(filename).getPath());
  }
  if (ATTRIBUTE_NAME_COPY_TO.equals(attrName) && FileUtils.isDITATopicFile(filename)) {
    final String href=atts.getValue(ATTRIBUTE_NAME_HREF);
    final String value=FileUtils.normalizeDirectory(currentDir,href);
    if (StringUtils.isEmptyString(href)) {
      final StringBuffer buff=new StringBuffer();
      buff.append(""String_Node_Str"");
      buff.append(filename);
      buff.append(""String_Node_Str"");
      logger.logWarn(buff.toString());
    }
 else     if (copytoMap.get(filename) != null) {
      final Properties prop=new Properties();
      prop.setProperty(""String_Node_Str"",href);
      prop.setProperty(""String_Node_Str"",filename);
      if (!value.equals(copytoMap.get(filename))) {
        logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      }
      ignoredCopytoSourceSet.add(href);
    }
 else     if (!(atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) {
      copytoMap.put(filename,value);
    }
    final String pathWithoutID=FileUtils.resolveFile(currentDir,attrValue);
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0) {
      chunkTopicSet.add(pathWithoutID);
    }
 else {
      hrefTopicSet.add(pathWithoutID);
    }
  }
  if (ATTRIBUTE_NAME_CONACTION.equals(attrName)) {
    if (attrValue.equals(""String_Node_Str"") || attrValue.equals(""String_Node_Str"")) {
      hasconaction=true;
    }
  }
}","/** 
 * Parse the input attributes for needed information.
 * @param atts all attributes
 * @param attrName attributes to process
 */
private void parseAttribute(final Attributes atts,final String attrName) throws SAXException {
  String attrValue=atts.getValue(attrName);
  String filename=null;
  final String attrClass=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  final String attrFormat=atts.getValue(ATTRIBUTE_NAME_FORMAT);
  final String attrType=atts.getValue(ATTRIBUTE_NAME_TYPE);
  final String codebase=atts.getValue(ATTRIBUTE_NAME_CODEBASE);
  if (attrValue == null) {
    return;
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) || ATTRIBUTE_NAME_CONKEYREF.equals(attrName)) {
    hasConRef=true;
  }
 else   if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
    if (attrClass != null && PR_D_CODEREF.matches(attrClass)) {
      hasCodeRef=true;
    }
 else {
      hasHref=true;
    }
  }
 else   if (ATTRIBUTE_NAME_KEYREF.equals(attrName)) {
    hasKeyRef=true;
  }
  if (ATTRIBUTE_NAME_KEYS.equals(attrName) && attrValue.length() != 0) {
    String target=atts.getValue(ATTRIBUTE_NAME_HREF);
    if (target != null && (attrFormat == null || attrFormat.equals(ATTR_FORMAT_VALUE_DITA)) && extName != null) {
      target=FileUtils.replaceExtension(target,extName);
    }
    final String keyRef=atts.getValue(ATTRIBUTE_NAME_KEYREF);
    final String copy_to=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
    if (!StringUtils.isEmptyString(copy_to)) {
      target=copy_to;
    }
    if (target == null) {
      target=""String_Node_Str"";
    }
    final String temp=target;
    for (    final String key : attrValue.split(""String_Node_Str"")) {
      if (!isValidKeyName(key)) {
        logger.logError(MessageUtils.getMessage(""String_Node_Str"",key).toString());
        continue;
      }
      if (!keysDefMap.containsKey(key) && !key.equals(""String_Node_Str"")) {
        if (target != null && target.length() != 0) {
          if (attrScope != null && (attrScope.equals(""String_Node_Str"") || attrScope.equals(""String_Node_Str""))) {
            exKeysDefMap.put(key,target);
            keysDefMap.put(key,new KeyDef(key,target,null));
          }
 else {
            String tail=""String_Node_Str"";
            if (target.indexOf(SHARP) != -1) {
              tail=target.substring(target.indexOf(SHARP));
              target=target.substring(0,target.indexOf(SHARP));
            }
            if (new File(target).isAbsolute()) {
              target=FileUtils.getRelativePath(rootFilePath.getAbsolutePath(),target);
            }
            target=FileUtils.normalizeDirectory(currentDir,target);
            keysDefMap.put(key,new KeyDef(key,target + tail,null));
          }
        }
 else         if (!StringUtils.isEmptyString(keyRef)) {
          keysRefMap.put(key,keyRef);
        }
 else {
          keysDefMap.put(key,new KeyDef(key,null,null));
        }
      }
 else {
        final Properties prop=new Properties();
        prop.setProperty(""String_Node_Str"",key);
        prop.setProperty(""String_Node_Str"",target);
        logger.logInfo(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      }
      target=temp;
    }
  }
  if (""String_Node_Str"".equalsIgnoreCase(attrScope) || ""String_Node_Str"".equalsIgnoreCase(attrScope) || attrValue.indexOf(COLON_DOUBLE_SLASH) != -1 || attrValue.startsWith(SHARP)) {
    return;
  }
  if (attrValue.startsWith(""String_Node_Str"") && attrValue.indexOf(""String_Node_Str"") == -1) {
    attrValue=attrValue.substring(""String_Node_Str"".length());
    if (UNIX_SEPARATOR.equals(File.separator)) {
      attrValue=UNIX_SEPARATOR + attrValue;
    }
  }
 else   if (attrValue.startsWith(""String_Node_Str"") && !attrValue.startsWith(""String_Node_Str"")) {
    attrValue=attrValue.substring(""String_Node_Str"".length());
  }
  final File target=new File(attrValue);
  if (target.isAbsolute() && !ATTRIBUTE_NAME_DATA.equals(attrName)) {
    attrValue=FileUtils.getRelativePath(rootFilePath.getAbsolutePath(),attrValue);
  }
 else   if (ATTRIBUTE_NAME_DATA.equals(attrName)) {
    if (!StringUtils.isEmptyString(codebase)) {
      filename=FileUtils.normalizeDirectory(codebase,attrValue);
    }
 else {
      filename=FileUtils.normalizeDirectory(currentDir,attrValue);
    }
  }
 else {
    filename=FileUtils.normalizeDirectory(currentDir,attrValue);
  }
  filename=toFile(filename);
  if (MAP_TOPICREF.matches(attrClass)) {
    if (ATTR_TYPE_VALUE_SUBJECT_SCHEME.equalsIgnoreCase(attrType)) {
      schemeSet.add(filename);
    }
    if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
      if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(attrFormat)) {
        if (attrName.equals(ATTRIBUTE_NAME_HREF)) {
          topicHref=filename;
          topicHref=FileUtils.separatorsToUnix(topicHref);
          if (attrValue.lastIndexOf(SHARP) != -1) {
            final int position=attrValue.lastIndexOf(SHARP);
            topicId=attrValue.substring(position + 1);
          }
 else {
            if (FileUtils.isDITAFile(topicHref)) {
              topicId=topicHref + QUESTION;
            }
          }
        }
      }
 else {
        topicHref=""String_Node_Str"";
        topicId=""String_Node_Str"";
      }
    }
  }
  if ((""String_Node_Str"".equals(attrType) && ATTRIBUTE_NAME_DATA.equals(attrName)) || attrClass != null && PR_D_CODEREF.matches(attrClass)) {
    subsidiarySet.add(filename);
    return;
  }
  if (filename != null && FileUtils.isValidTarget(filename.toLowerCase()) && (StringUtils.isEmptyString(atts.getValue(ATTRIBUTE_NAME_COPY_TO)) || !FileUtils.isDITATopicFile(atts.getValue(ATTRIBUTE_NAME_COPY_TO).toLowerCase()) || (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) && !ATTRIBUTE_NAME_CONREF.equals(attrName) && !ATTRIBUTE_NAME_COPY_TO.equals(attrName) && (canResolved() || FileUtils.isSupportedImageFile(filename.toLowerCase()))) {
    nonConrefCopytoTargets.add(new Reference(filename,attrFormat));
  }
  if (attrFormat != null && !ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(attrFormat)) {
    return;
  }
  if (ATTRIBUTE_NAME_HREF.equals(attrName) && FileUtils.isDITATopicFile(filename) && canResolved()) {
    hrefTargets.add(new File(filename).getPath());
    toOutFile(new File(filename).getPath());
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0 && relTableLevel == 0) {
      chunkTopicSet.add(filename);
    }
 else {
      hrefTopicSet.add(filename);
    }
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) && FileUtils.isDITAFile(filename)) {
    conrefTargets.add(filename);
    toOutFile(new File(filename).getPath());
  }
  if (ATTRIBUTE_NAME_COPY_TO.equals(attrName) && FileUtils.isDITATopicFile(filename)) {
    final String href=atts.getValue(ATTRIBUTE_NAME_HREF);
    final String value=toFile(FileUtils.normalizeDirectory(currentDir,href));
    if (StringUtils.isEmptyString(href)) {
      final StringBuffer buff=new StringBuffer();
      buff.append(""String_Node_Str"");
      buff.append(filename);
      buff.append(""String_Node_Str"");
      logger.logWarn(buff.toString());
    }
 else     if (copytoMap.get(filename) != null) {
      final Properties prop=new Properties();
      prop.setProperty(""String_Node_Str"",href);
      prop.setProperty(""String_Node_Str"",filename);
      if (!value.equals(copytoMap.get(filename))) {
        logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      }
      ignoredCopytoSourceSet.add(href);
    }
 else     if (!(atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) {
      copytoMap.put(filename,value);
    }
    final String pathWithoutID=FileUtils.resolveFile(currentDir,toFile(attrValue));
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0) {
      chunkTopicSet.add(pathWithoutID);
    }
 else {
      hrefTopicSet.add(pathWithoutID);
    }
  }
  if (ATTRIBUTE_NAME_CONACTION.equals(attrName)) {
    if (attrValue.equals(""String_Node_Str"") || attrValue.equals(""String_Node_Str"")) {
      hasconaction=true;
    }
  }
}",0.9785205743936286
100796,"/** 
 * Add the given file the wait list if it has not been parsed.
 * @param file relative system path
 */
private void addToWaitList(final File file){
  if (doneList.contains(file) || waitList.contains(file)) {
    return;
  }
  waitList.add(file);
}","/** 
 * Add the given file the wait list if it has not been parsed.
 * @param file relative system path
 */
private void addToWaitList(final File file){
  if (doneList.contains(file) || waitList.contains(file) || file.equals(currentFile)) {
    return;
  }
  waitList.add(file);
}",0.9473684210526316
100797,"private void processWaitList() throws DITAOTException {
  reader.setTranstype(transtype);
  if (FileUtils.isDITAMapFile(inputFile.getPath())) {
    reader.setPrimaryDitamap(inputFile.getPath());
  }
  while (!waitList.isEmpty()) {
    processFile(waitList.remove(0));
  }
}","private void processWaitList() throws DITAOTException {
  reader.setTranstype(transtype);
  if (FileUtils.isDITAMapFile(inputFile.getPath())) {
    reader.setPrimaryDitamap(inputFile.getPath());
  }
  while (!waitList.isEmpty()) {
    currentFile=waitList.remove(0);
    processFile(currentFile);
  }
}",0.9043478260869564
100798,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processRoleStack.push(attrValue);
    processRoleLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(attrValue)) {
      return;
    }
  }
 else   if (processRoleLevel > 0) {
    processRoleLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleStack.peek())) {
      return;
    }
  }
  final String classAttr=attributes.getValue(ATTRIBUTE_NAME_CLASS);
  handleSpecialization(localName,classAttr);
  parseTopic(localName,attributes.getValue(ATTRIBUTE_NAME_ID));
  parseIndexTerm(localName,attributes);
  parseIndexSee(localName);
  parseIndexSeeAlso(localName);
  if (IndexTerm.getTermLocale() == null) {
    final String xmlLang=attributes.getValue(ATTRIBUTE_NAME_XML_LANG);
    if (xmlLang != null) {
      IndexTerm.setTermLocale(StringUtils.getLocale(xmlLang));
    }
  }
  if (titleSpecList.contains(localName) && !titleMap.containsKey(topicIdStack.peek())) {
    inTitleElement=true;
    title=null;
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=true;
  }
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processRoleStack.push(attrValue);
    processRoleLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(attrValue)) {
      return;
    }
  }
 else   if (processRoleLevel > 0) {
    processRoleLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processRoleStack.peek())) {
      return;
    }
  }
  final String classAttr=attributes.getValue(ATTRIBUTE_NAME_CLASS);
  handleSpecialization(localName,classAttr);
  parseTopic(localName,attributes.getValue(ATTRIBUTE_NAME_ID));
  parseIndexTerm(localName,attributes);
  parseIndexSee(localName);
  parseIndexSeeAlso(localName);
  if (IndexTerm.getTermLocale() == null) {
    final String xmlLang=attributes.getValue(ATTRIBUTE_NAME_XML_LANG);
    if (xmlLang != null) {
      IndexTerm.setTermLocale(StringUtils.getLocale(xmlLang));
    }
  }
  if (titleSpecList.contains(localName) && !topicIdStack.empty() && !titleMap.containsKey(topicIdStack.peek())) {
    inTitleElement=true;
    title=null;
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=true;
  }
}",0.9903213317847464
100799,"@Override public void endElement(final String uri,final String localName,final String qName) throws SAXException {
  if (processRoleLevel > 0) {
    String role=processRoleStack.peek();
    if (processRoleLevel == processRoleStack.size()) {
      role=processRoleStack.pop();
    }
    processRoleLevel--;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(role)) {
      return;
    }
  }
  if (indexTermSpecList.contains(localName)) {
    final IndexTerm term=termStack.pop();
    if (term.getTermName() == null || term.getTermName().trim().equals(""String_Node_Str"")) {
      if (term.getEndAttribute() != null && !term.hasSubTerms()) {
        return;
      }
 else {
        term.setTermName(""String_Node_Str"");
        logger.logWarn(MessageUtils.getMessage(""String_Node_Str"").toString());
      }
    }
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermName());
    }
    if (term.isLeaf()) {
      final IndexTermTarget target=genTarget();
      term.addTarget(target);
    }
    if (termStack.empty()) {
      indexTermList.add(term);
    }
 else {
      final IndexTerm parentTerm=termStack.peek();
      parentTerm.addSubTerm(term);
    }
  }
  if (indexSeeSpecList.contains(localName) || indexSeeAlsoSpecList.contains(localName)) {
    final IndexTerm term=termStack.pop();
    final IndexTerm parentTerm=termStack.peek();
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermFullName());
    }
    term.addTarget(genTarget());
    parentTerm.addSubTerm(term);
  }
  if (titleSpecList.contains(localName)) {
    inTitleElement=false;
    if (!titleMap.containsKey(topicIdStack.peek())) {
      if (titleMap.size() == 0) {
        defaultTitle=title;
      }
      titleMap.put(topicIdStack.peek(),title);
    }
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=false;
  }
  if (topicSpecList.contains(localName)) {
    topicIdStack.pop();
  }
}","@Override public void endElement(final String uri,final String localName,final String qName) throws SAXException {
  if (processRoleLevel > 0) {
    String role=processRoleStack.peek();
    if (processRoleLevel == processRoleStack.size()) {
      role=processRoleStack.pop();
    }
    processRoleLevel--;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(role)) {
      return;
    }
  }
  if (indexTermSpecList.contains(localName)) {
    final IndexTerm term=termStack.pop();
    if (term.getTermName() == null || term.getTermName().trim().equals(""String_Node_Str"")) {
      if (term.getEndAttribute() != null && !term.hasSubTerms()) {
        return;
      }
 else {
        term.setTermName(""String_Node_Str"");
        logger.logWarn(MessageUtils.getMessage(""String_Node_Str"").toString());
      }
    }
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermName());
    }
    if (term.isLeaf()) {
      final IndexTermTarget target=genTarget();
      term.addTarget(target);
    }
    if (termStack.empty()) {
      indexTermList.add(term);
    }
 else {
      final IndexTerm parentTerm=termStack.peek();
      parentTerm.addSubTerm(term);
    }
  }
  if (indexSeeSpecList.contains(localName) || indexSeeAlsoSpecList.contains(localName)) {
    final IndexTerm term=termStack.pop();
    final IndexTerm parentTerm=termStack.peek();
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermFullName());
    }
    term.addTarget(genTarget());
    parentTerm.addSubTerm(term);
  }
  if (titleSpecList.contains(localName)) {
    inTitleElement=false;
    if (!topicIdStack.empty() && !titleMap.containsKey(topicIdStack.empty())) {
      if (titleMap.size() == 0) {
        defaultTitle=title;
      }
      titleMap.put(topicIdStack.peek(),title);
    }
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=false;
  }
  if (topicSpecList.contains(localName)) {
    topicIdStack.pop();
  }
}",0.8560411311053985
100800,"/** 
 * Rewrite local non-DITA href value. <p>TODO: return type should be   {@link java.util.URI}.</p>
 * @param attValue href attribute value
 * @return rewritten href value
 */
private String handleLocalHref(final String attValue){
  return FileUtils.resolveTopic(new File(filePath).getParent(),attValue);
}","/** 
 * Rewrite local non-DITA href value. <p>TODO: return type should be   {@link java.util.URI}.</p>
 * @param attValue href attribute value
 * @return rewritten href value
 */
private String handleLocalHref(final String attValue){
  final File parentFile=new File(filePath).getParentFile();
  if (parentFile != null) {
    final URI d=new File(dirPath).toURI();
    final URI p=new File(dirPath,filePath).getParentFile().toURI();
    final String b=d.relativize(p).toASCIIString();
    final StringBuilder ret=new StringBuilder(b);
    if (!b.endsWith(URI_SEPARATOR)) {
      ret.append(URI_SEPARATOR);
    }
    ret.append(attValue);
    return FileUtils.normalize(ret.toString(),URI_SEPARATOR);
  }
 else {
    return attValue;
  }
}",0.4737344794651384
100801,"@Test public void testParse() throws Exception {
  final MergeTopicParser parser=new MergeTopicParser(new MergeUtils());
  final ByteArrayOutputStream output=new ByteArrayOutputStream();
  final TransformerHandler s=stf.newTransformerHandler();
  s.getTransformer().setOutputProperty(OMIT_XML_DECLARATION,""String_Node_Str"");
  s.setResult(new StreamResult(output));
  parser.setContentHandler(s);
  parser.setLogger(new TestUtils.TestLogger());
  s.startDocument();
  parser.parse(""String_Node_Str"",srcDir.getAbsolutePath());
  s.endDocument();
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"").toURI().toString()),new InputSource(new ByteArrayInputStream(output.toByteArray())));
}","@Test public void testParse() throws Exception {
  final MergeTopicParser parser=new MergeTopicParser(new MergeUtils());
  final ByteArrayOutputStream output=new ByteArrayOutputStream();
  final TransformerHandler s=stf.newTransformerHandler();
  s.getTransformer().setOutputProperty(OMIT_XML_DECLARATION,""String_Node_Str"");
  s.setResult(new StreamResult(output));
  parser.setContentHandler(s);
  parser.setLogger(new TestUtils.TestLogger());
  s.startDocument();
  parser.parse(""String_Node_Str"",srcDir.getAbsolutePath());
  s.endDocument();
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"").toURI().toString()),new InputSource(new ByteArrayInputStream(output.toByteArray())));
  final Method method=MergeTopicParser.class.getDeclaredMethod(""String_Node_Str"",String.class);
  method.setAccessible(true);
  assertEquals(""String_Node_Str"",method.invoke(parser,""String_Node_Str""));
}",0.8744534665833854
100802,"@Override public void characters(final char[] ch,final int start,final int length) throws SAXException {
  final StringBuilder tempBuf=new StringBuilder(length);
  tempBuf.append(ch,start,length);
  normalizeAndCollapseWhitespace(tempBuf);
  String temp=tempBuf.toString();
  if (processRoleStack.isEmpty() || !ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processRoleStack.peek())) {
    if (!insideSortingAs && !termStack.empty()) {
      final IndexTerm indexTerm=termStack.peek();
      temp=StringUtils.escapeXML(temp);
      temp=trimSpaceAtStart(temp,indexTerm.getTermName());
      indexTerm.setTermName(StringUtils.setOrAppend(indexTerm.getTermName(),temp,false));
    }
 else     if (insideSortingAs && temp.length() > 0) {
      final IndexTerm indexTerm=termStack.peek();
      temp=StringUtils.escapeXML(temp);
      temp=trimSpaceAtStart(temp,indexTerm.getTermKey());
      indexTerm.setTermKey(StringUtils.setOrAppend(indexTerm.getTermKey(),temp,false));
    }
 else     if (inTitleElement) {
      temp=StringUtils.escapeXML(temp);
      temp=trimSpaceAtStart(temp,title);
      title=StringUtils.setOrAppend(title,temp,false);
    }
  }
}","@Override public void characters(final char[] ch,final int start,final int length) throws SAXException {
  final StringBuilder tempBuf=new StringBuilder(length);
  tempBuf.append(ch,start,length);
  normalizeAndCollapseWhitespace(tempBuf);
  String temp=tempBuf.toString();
  if (processRoleStack.isEmpty() || !ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processRoleStack.peek())) {
    if (!insideSortingAs && !termStack.empty()) {
      final IndexTerm indexTerm=termStack.peek();
      temp=trimSpaceAtStart(temp,indexTerm.getTermName());
      indexTerm.setTermName(StringUtils.setOrAppend(indexTerm.getTermName(),temp,false));
    }
 else     if (insideSortingAs && temp.length() > 0) {
      final IndexTerm indexTerm=termStack.peek();
      temp=trimSpaceAtStart(temp,indexTerm.getTermKey());
      indexTerm.setTermKey(StringUtils.setOrAppend(indexTerm.getTermKey(),temp,false));
    }
 else     if (inTitleElement) {
      temp=trimSpaceAtStart(temp,title);
      title=StringUtils.setOrAppend(title,temp,false);
    }
  }
}",0.7687443541102078
100803,"/** 
 * execution point of MoveLinksModule.
 * @param input input parameters and resources
 * @return always {@code null}
 * @throws DITAOTException if process fails
 */
public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  if (logger == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final File maplinksFile=new File(input.getAttribute(ANT_INVOKER_PARAM_MAPLINKS));
  final MapLinksReader indexReader=new MapLinksReader();
  indexReader.setLogger(logger);
  indexReader.setMatch(new StringBuffer(ELEMENT_NAME_MAPLINKS).append(SLASH).append(TOPIC_LINKPOOL.localName).append(SLASH).append(TOPIC_LINKLIST.localName).toString());
  indexReader.read(maplinksFile.getAbsolutePath());
  final Map<String,Map<String,String>> mapSet=(Map<String,Map<String,String>>)indexReader.getContent().getCollection();
  final DitaLinksWriter indexInserter=new DitaLinksWriter();
  indexInserter.setLogger(logger);
  for (  final Map.Entry<String,Map<String,String>> entry : mapSet.entrySet()) {
    logger.logInfo(""String_Node_Str"" + entry.getKey());
    final ContentImpl content=new ContentImpl();
    content.setValue(entry.getValue());
    indexInserter.setContent(content);
    indexInserter.write(entry.getKey());
  }
  return null;
}","/** 
 * execution point of MoveLinksModule.
 * @param input input parameters and resources
 * @return always {@code null}
 * @throws DITAOTException if process fails
 */
public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  if (logger == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final File maplinksFile=new File(input.getAttribute(ANT_INVOKER_PARAM_MAPLINKS));
  final MapLinksReader indexReader=new MapLinksReader();
  indexReader.setLogger(logger);
  indexReader.setMatch(new StringBuffer(ELEMENT_NAME_MAPLINKS).append(SLASH).append(TOPIC_LINKPOOL.localName).append(SLASH).append(TOPIC_LINKLIST.localName).toString());
  indexReader.read(maplinksFile.getAbsolutePath());
  final Map<String,Map<String,String>> mapSet=indexReader.getMapping();
  final DitaLinksWriter indexInserter=new DitaLinksWriter();
  indexInserter.setLogger(logger);
  for (  final Map.Entry<String,Map<String,String>> entry : mapSet.entrySet()) {
    logger.logInfo(""String_Node_Str"" + entry.getKey());
    final ContentImpl content=new ContentImpl();
    content.setValue(entry.getValue());
    indexInserter.setContent(content);
    indexInserter.write(entry.getKey());
  }
  return null;
}",0.8657187993680885
100804,"/** 
 * Entry point of MoveMetaModule.
 * @param input Input parameters and resources.
 * @return null
 * @throws DITAOTException exception
 */
public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  if (logger == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final File tempDir=new File(input.getAttribute(ANT_INVOKER_PARAM_TEMPDIR));
  if (!tempDir.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"" + tempDir + ""String_Node_Str"");
  }
  Job job=null;
  try {
    job=new Job(tempDir);
  }
 catch (  final IOException e) {
    throw new DITAOTException(e);
  }
  final MapMetaReader metaReader=new MapMetaReader();
  metaReader.setLogger(logger);
  final Set<String> fullditamaplist=job.getSet(FULL_DITAMAP_LIST);
  for (  String mapFile : fullditamaplist) {
    mapFile=new File(tempDir,mapFile).getAbsolutePath();
    logger.logInfo(""String_Node_Str"" + mapFile);
    metaReader.read(mapFile);
    final File oldMap=new File(mapFile);
    final File newMap=new File(mapFile + ""String_Node_Str"");
    if (newMap.exists()) {
      if (!oldMap.delete()) {
        final Properties p=new Properties();
        p.put(""String_Node_Str"",oldMap.getPath());
        p.put(""String_Node_Str"",newMap.getAbsolutePath() + ""String_Node_Str"");
        logger.logError(MessageUtils.getMessage(""String_Node_Str"",p).toString());
      }
      if (!newMap.renameTo(oldMap)) {
        final Properties p=new Properties();
        p.put(""String_Node_Str"",oldMap.getPath());
        p.put(""String_Node_Str"",newMap.getAbsolutePath() + ""String_Node_Str"");
        logger.logError(MessageUtils.getMessage(""String_Node_Str"",p).toString());
      }
    }
  }
  final Map<String,Hashtable<String,Element>> mapSet=metaReader.getMapping();
  ;
  final DitaMapMetaWriter mapInserter=new DitaMapMetaWriter();
  mapInserter.setLogger(logger);
  for (  final Entry<String,Hashtable<String,Element>> entry : mapSet.entrySet()) {
    String targetFileName=entry.getKey();
    targetFileName=targetFileName.indexOf(SHARP) != -1 ? targetFileName.substring(0,targetFileName.indexOf(SHARP)) : targetFileName;
    if (targetFileName.endsWith(FILE_EXTENSION_DITAMAP)) {
      content.setValue(entry.getValue());
      mapInserter.setContent(content);
      if (FileUtils.fileExists(entry.getKey())) {
        logger.logInfo(""String_Node_Str"" + entry.getKey());
        mapInserter.write(entry.getKey());
      }
 else {
        logger.logError(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
    }
  }
  final DitaMetaWriter topicInserter=new DitaMetaWriter();
  topicInserter.setLogger(logger);
  for (  final Map.Entry<String,Hashtable<String,Element>> entry : mapSet.entrySet()) {
    String targetFileName=entry.getKey();
    targetFileName=targetFileName.indexOf(SHARP) != -1 ? targetFileName.substring(0,targetFileName.indexOf(SHARP)) : targetFileName;
    if (targetFileName.endsWith(FILE_EXTENSION_DITA) || targetFileName.endsWith(FILE_EXTENSION_XML)) {
      content.setValue(entry.getValue());
      topicInserter.setContent(content);
      if (FileUtils.fileExists(entry.getKey())) {
        logger.logInfo(""String_Node_Str"" + entry.getKey());
        topicInserter.write(entry.getKey());
      }
 else {
        logger.logError(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
    }
  }
  return null;
}","/** 
 * Entry point of MoveMetaModule.
 * @param input Input parameters and resources.
 * @return null
 * @throws DITAOTException exception
 */
public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  if (logger == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final File tempDir=new File(input.getAttribute(ANT_INVOKER_PARAM_TEMPDIR));
  if (!tempDir.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"" + tempDir + ""String_Node_Str"");
  }
  Job job=null;
  try {
    job=new Job(tempDir);
  }
 catch (  final IOException e) {
    throw new DITAOTException(e);
  }
  final MapMetaReader metaReader=new MapMetaReader();
  metaReader.setLogger(logger);
  final Set<String> fullditamaplist=job.getSet(FULL_DITAMAP_LIST);
  for (  String mapFile : fullditamaplist) {
    mapFile=new File(tempDir,mapFile).getAbsolutePath();
    logger.logInfo(""String_Node_Str"" + mapFile);
    metaReader.read(mapFile);
    final File oldMap=new File(mapFile);
    final File newMap=new File(mapFile + ""String_Node_Str"");
    if (newMap.exists()) {
      if (!oldMap.delete()) {
        final Properties p=new Properties();
        p.put(""String_Node_Str"",oldMap.getPath());
        p.put(""String_Node_Str"",newMap.getAbsolutePath() + ""String_Node_Str"");
        logger.logError(MessageUtils.getMessage(""String_Node_Str"",p).toString());
      }
      if (!newMap.renameTo(oldMap)) {
        final Properties p=new Properties();
        p.put(""String_Node_Str"",oldMap.getPath());
        p.put(""String_Node_Str"",newMap.getAbsolutePath() + ""String_Node_Str"");
        logger.logError(MessageUtils.getMessage(""String_Node_Str"",p).toString());
      }
    }
  }
  final Map<String,Hashtable<String,Element>> mapSet=metaReader.getMapping();
  final DitaMapMetaWriter mapInserter=new DitaMapMetaWriter();
  mapInserter.setLogger(logger);
  for (  final Entry<String,Hashtable<String,Element>> entry : mapSet.entrySet()) {
    String targetFileName=entry.getKey();
    targetFileName=targetFileName.indexOf(SHARP) != -1 ? targetFileName.substring(0,targetFileName.indexOf(SHARP)) : targetFileName;
    if (targetFileName.endsWith(FILE_EXTENSION_DITAMAP)) {
      content.setValue(entry.getValue());
      mapInserter.setContent(content);
      if (FileUtils.fileExists(entry.getKey())) {
        logger.logInfo(""String_Node_Str"" + entry.getKey());
        mapInserter.write(entry.getKey());
      }
 else {
        logger.logError(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
    }
  }
  final DitaMetaWriter topicInserter=new DitaMetaWriter();
  topicInserter.setLogger(logger);
  for (  final Map.Entry<String,Hashtable<String,Element>> entry : mapSet.entrySet()) {
    String targetFileName=entry.getKey();
    targetFileName=targetFileName.indexOf(SHARP) != -1 ? targetFileName.substring(0,targetFileName.indexOf(SHARP)) : targetFileName;
    if (targetFileName.endsWith(FILE_EXTENSION_DITA) || targetFileName.endsWith(FILE_EXTENSION_XML)) {
      content.setValue(entry.getValue());
      topicInserter.setContent(content);
      if (FileUtils.fileExists(entry.getKey())) {
        logger.logInfo(""String_Node_Str"" + entry.getKey());
        topicInserter.write(entry.getKey());
      }
 else {
        logger.logError(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
    }
  }
  return null;
}",0.9994110718492344
100805,"/** 
 * Rewrite local DITA href value.
 * @param sharpIndex hash char index
 * @param attValue href attribute value
 * @return rewritten href value
 */
private String handleLocalDita(final int sharpIndex,final String attValue,final AttributesImpl atts){
  String pathFromMap;
  String retAttValue=attValue;
  if (sharpIndex != -1) {
    if (sharpIndex == 0) {
      pathFromMap=FileUtils.separatorsToUnix(filePath);
    }
 else {
      pathFromMap=FileUtils.separatorsToUnix(FileUtils.resolveTopic(new File(filePath).getParent(),attValue.substring(0,sharpIndex)));
    }
    XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,pathFromMap + attValue.substring(sharpIndex));
    String topicId=attValue.substring(sharpIndex);
    final int slashIndex=topicId.indexOf(SLASH);
    final int index=attValue.indexOf(SLASH,sharpIndex);
    topicId=slashIndex != -1 ? pathFromMap + topicId.substring(0,slashIndex) : pathFromMap + topicId;
    if (util.findId(topicId)) {
      final String prefix=SHARP + util.getIdValue(topicId);
      retAttValue=index != -1 ? prefix + attValue.substring(index) : prefix;
    }
 else {
      final String prefix=SHARP + util.addId(topicId);
      retAttValue=index != -1 ? prefix + attValue.substring(index) : prefix;
    }
  }
 else {
    pathFromMap=FileUtils.resolveTopic(new File(filePath).getParent(),attValue);
    XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,pathFromMap);
    if (util.findId(pathFromMap)) {
      retAttValue=SHARP + util.getIdValue(pathFromMap);
    }
 else {
      final String fileId=MergeUtils.getFirstTopicId(pathFromMap,dirPath,false);
      final String key=pathFromMap + SHARP + fileId;
      if (util.findId(key)) {
        util.addId(pathFromMap,util.getIdValue(key));
        retAttValue=SHARP + util.getIdValue(key);
      }
 else {
        retAttValue=SHARP + util.addId(pathFromMap);
        util.addId(key,util.getIdValue(pathFromMap));
      }
    }
  }
  return retAttValue;
}","/** 
 * Rewrite local DITA href value. <p>TODO: return type should be   {@link java.util.URI}.</p>
 * @param sharpIndex hash char index
 * @param attValue href attribute value
 * @return rewritten href value
 */
private String handleLocalDita(final int sharpIndex,final String attValue,final AttributesImpl atts){
  String pathFromMap;
  String retAttValue=attValue;
  if (sharpIndex != -1) {
    if (sharpIndex == 0) {
      pathFromMap=FileUtils.separatorsToUnix(filePath);
    }
 else {
      pathFromMap=FileUtils.separatorsToUnix(FileUtils.resolveTopic(new File(filePath).getParent(),attValue.substring(0,sharpIndex)));
    }
    pathFromMap=URLUtils.decode(pathFromMap);
    XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,URLUtils.clean(pathFromMap + attValue.substring(sharpIndex)));
    String topicId=attValue.substring(sharpIndex);
    final int slashIndex=topicId.indexOf(SLASH);
    final int index=attValue.indexOf(SLASH,sharpIndex);
    topicId=slashIndex != -1 ? pathFromMap + topicId.substring(0,slashIndex) : pathFromMap + topicId;
    if (util.findId(topicId)) {
      final String prefix=SHARP + util.getIdValue(topicId);
      retAttValue=index != -1 ? prefix + attValue.substring(index) : prefix;
    }
 else {
      final String prefix=SHARP + util.addId(topicId);
      retAttValue=index != -1 ? prefix + attValue.substring(index) : prefix;
    }
  }
 else {
    pathFromMap=FileUtils.resolveTopic(new File(filePath).getParent(),attValue);
    pathFromMap=URLUtils.decode(pathFromMap);
    XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,URLUtils.clean(pathFromMap));
    if (util.findId(pathFromMap)) {
      retAttValue=SHARP + util.getIdValue(pathFromMap);
    }
 else {
      final String fileId=MergeUtils.getFirstTopicId(pathFromMap,dirPath,false);
      final String key=pathFromMap + SHARP + fileId;
      if (util.findId(key)) {
        util.addId(pathFromMap,util.getIdValue(key));
        retAttValue=SHARP + util.getIdValue(key);
      }
 else {
        retAttValue=SHARP + util.addId(pathFromMap);
        util.addId(key,util.getIdValue(pathFromMap));
      }
    }
  }
  return URLUtils.clean(retAttValue);
}",0.95136186770428
100806,"/** 
 * Rewrite local non-DITA href value.
 * @param attValue href attribute value
 * @return rewritten href value
 */
private String handleLocalHref(final String attValue){
  return FileUtils.resolveTopic(new File(filePath).getParent(),attValue);
}","/** 
 * Rewrite local non-DITA href value. <p>TODO: return type should be   {@link java.util.URI}.</p>
 * @param attValue href attribute value
 * @return rewritten href value
 */
private String handleLocalHref(final String attValue){
  return FileUtils.resolveTopic(new File(filePath).getParent(),attValue);
}",0.8924731182795699
100807,"private void handleTopicref(final Node topicref,final Hashtable<String,Element> inheritance){
  final Node hrefAttr=topicref.getAttributes().getNamedItem(ATTRIBUTE_NAME_HREF);
  final Node copytoAttr=topicref.getAttributes().getNamedItem(ATTRIBUTE_NAME_COPY_TO);
  final Node scopeAttr=topicref.getAttributes().getNamedItem(ATTRIBUTE_NAME_SCOPE);
  final Node formatAttr=topicref.getAttributes().getNamedItem(ATTRIBUTE_NAME_FORMAT);
  Hashtable<String,Element> current=mergeMeta(null,inheritance,cascadeSet);
  String topicPath=null;
  Node metaNode=null;
  final NodeList children=topicref.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node node=children.item(i);
    Node classAttr=null;
    if (node.getNodeType() == Node.ELEMENT_NODE) {
      classAttr=node.getAttributes().getNamedItem(ATTRIBUTE_NAME_CLASS);
    }
    if (classAttr != null && hrefAttr != null && MAP_TOPICMETA.matches(classAttr.getNodeValue()) && hrefAttr != null && hrefAttr.getNodeValue().indexOf(INTERNET_LINK_MARK) == -1 && (scopeAttr == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeAttr.getNodeValue())) && ((formatAttr == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatAttr.getNodeValue())) || (formatAttr == null || ATTR_FORMAT_VALUE_DITAMAP.equalsIgnoreCase(formatAttr.getNodeValue())))) {
      metaNode=node;
      current=handleMeta(node,inheritance);
    }
 else     if (classAttr != null && MAP_TOPICREF.matches(classAttr.getNodeValue())) {
      handleTopicref(node,current);
    }
  }
  if (!current.isEmpty() && hrefAttr != null) {
    if (copytoAttr != null && new File(FileUtils.resolveFile(filePath,copytoAttr.getNodeValue())).exists()) {
      topicPath=FileUtils.resolveTopic(filePath,copytoAttr.getNodeValue());
    }
 else {
      topicPath=FileUtils.resolveTopic(filePath,hrefAttr.getNodeValue());
    }
    if (((formatAttr == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatAttr.getNodeValue())) || (formatAttr == null || ATTR_FORMAT_VALUE_DITAMAP.equalsIgnoreCase(formatAttr.getNodeValue()))) && (scopeAttr == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeAttr.getNodeValue())) && (hrefAttr.getNodeValue().indexOf(INTERNET_LINK_MARK) == -1)) {
      if (resultTable.containsKey(topicPath)) {
        final Hashtable<String,Element> previous=resultTable.get(topicPath);
        resultTable.put(topicPath,mergeMeta(previous,current,metaSet));
      }
 else {
        resultTable.put(topicPath,cloneElementMap(current));
      }
      final Hashtable<String,Element> metas=resultTable.get(topicPath);
      if (!metas.isEmpty()) {
        if (metaNode != null) {
          topicref.removeChild(metaNode);
        }
        final Element newMeta=doc.createElement(MAP_TOPICMETA.localName);
        newMeta.setAttribute(ATTRIBUTE_NAME_CLASS,""String_Node_Str"" + MAP_TOPICMETA.matcher);
        for (int i=0; i < metaPos.size(); i++) {
          final Node stub=metas.get(metaPos.get(i));
          if (stub != null) {
            final NodeList clist=stub.getChildNodes();
            for (int j=0; j < clist.getLength(); j++) {
              newMeta.appendChild(topicref.getOwnerDocument().importNode(clist.item(j),true));
            }
          }
        }
        topicref.insertBefore(newMeta,topicref.getFirstChild());
      }
    }
  }
}","private void handleTopicref(final Node topicref,final Hashtable<String,Element> inheritance){
  final Node hrefAttr=topicref.getAttributes().getNamedItem(ATTRIBUTE_NAME_HREF);
  final Node copytoAttr=topicref.getAttributes().getNamedItem(ATTRIBUTE_NAME_COPY_TO);
  final Node scopeAttr=topicref.getAttributes().getNamedItem(ATTRIBUTE_NAME_SCOPE);
  final Node formatAttr=topicref.getAttributes().getNamedItem(ATTRIBUTE_NAME_FORMAT);
  Hashtable<String,Element> current=mergeMeta(null,inheritance,cascadeSet);
  String topicPath=null;
  Node metaNode=null;
  final NodeList children=topicref.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    final Node node=children.item(i);
    Node classAttr=null;
    if (node.getNodeType() == Node.ELEMENT_NODE) {
      classAttr=node.getAttributes().getNamedItem(ATTRIBUTE_NAME_CLASS);
    }
    if (classAttr != null && hrefAttr != null && MAP_TOPICMETA.matches(classAttr.getNodeValue()) && hrefAttr != null && hrefAttr.getNodeValue().indexOf(INTERNET_LINK_MARK) == -1 && (scopeAttr == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeAttr.getNodeValue())) && ((formatAttr == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatAttr.getNodeValue())) || (formatAttr == null || ATTR_FORMAT_VALUE_DITAMAP.equalsIgnoreCase(formatAttr.getNodeValue())))) {
      metaNode=node;
      current=handleMeta(node,inheritance);
    }
 else     if (classAttr != null && MAP_TOPICREF.matches(classAttr.getNodeValue())) {
      handleTopicref(node,current);
    }
  }
  if (!current.isEmpty() && hrefAttr != null) {
    if (copytoAttr != null && new File(FileUtils.resolveFile(filePath,URLUtils.decode(copytoAttr.getNodeValue()))).exists()) {
      topicPath=FileUtils.resolveTopic(filePath,URLUtils.decode(copytoAttr.getNodeValue()));
    }
 else {
      topicPath=FileUtils.resolveTopic(filePath,URLUtils.decode(hrefAttr.getNodeValue()));
    }
    if (((formatAttr == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatAttr.getNodeValue())) || (formatAttr == null || ATTR_FORMAT_VALUE_DITAMAP.equalsIgnoreCase(formatAttr.getNodeValue()))) && (scopeAttr == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeAttr.getNodeValue())) && (hrefAttr.getNodeValue().indexOf(INTERNET_LINK_MARK) == -1)) {
      if (resultTable.containsKey(topicPath)) {
        final Hashtable<String,Element> previous=resultTable.get(topicPath);
        resultTable.put(topicPath,mergeMeta(previous,current,metaSet));
      }
 else {
        resultTable.put(topicPath,cloneElementMap(current));
      }
      final Hashtable<String,Element> metas=resultTable.get(topicPath);
      if (!metas.isEmpty()) {
        if (metaNode != null) {
          topicref.removeChild(metaNode);
        }
        final Element newMeta=doc.createElement(MAP_TOPICMETA.localName);
        newMeta.setAttribute(ATTRIBUTE_NAME_CLASS,""String_Node_Str"" + MAP_TOPICMETA.matcher);
        for (int i=0; i < metaPos.size(); i++) {
          final Node stub=metas.get(metaPos.get(i));
          if (stub != null) {
            final NodeList clist=stub.getChildNodes();
            for (int j=0; j < clist.getLength(); j++) {
              newMeta.appendChild(topicref.getOwnerDocument().importNode(clist.item(j),true));
            }
          }
        }
        topicref.insertBefore(newMeta,topicref.getFirstChild());
      }
    }
  }
}",0.9923227457474032
100808,"/** 
 * Default Constructor.
 */
public MergeMapParser(){
  processStack=new Stack<String>();
  processLevel=0;
  util=new MergeUtils();
  topicParser=new MergeTopicParser(util);
  topicParser.setLogger(logger);
  topicBuffer=new ByteArrayOutputStream();
  try {
    reader=StringUtils.getXMLReader();
    reader.setContentHandler(this);
    reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
    final TransformerFactory tf=TransformerFactory.newInstance();
    if (!tf.getFeature(SAXTransformerFactory.FEATURE)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    stf=(SAXTransformerFactory)tf;
    final TransformerHandler s=stf.newTransformerHandler();
    s.getTransformer().setOutputProperty(OMIT_XML_DECLARATION,""String_Node_Str"");
    s.setResult(new StreamResult(topicBuffer));
    topicParser.setContentHandler(s);
  }
 catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Default Constructor.
 */
public MergeMapParser(){
  processStack=new Stack<String>();
  processLevel=0;
  util=new MergeUtils();
  topicParser=new MergeTopicParser(util);
  topicBuffer=new ByteArrayOutputStream();
  try {
    reader=StringUtils.getXMLReader();
    reader.setContentHandler(this);
    reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
    final TransformerFactory tf=TransformerFactory.newInstance();
    if (!tf.getFeature(SAXTransformerFactory.FEATURE)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    stf=(SAXTransformerFactory)tf;
    final TransformerHandler s=stf.newTransformerHandler();
    s.getTransformer().setOutputProperty(OMIT_XML_DECLARATION,""String_Node_Str"");
    s.setResult(new StreamResult(topicBuffer));
    topicParser.setContentHandler(s);
  }
 catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.9822675980655562
100809,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    String attValue=attributes.getValue(ATTRIBUTE_NAME_HREF);
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref);
        if (util.isVisited(attValue)) {
          attValue=SHARP + util.getIdValue(attValue);
        }
 else {
          util.visit(attValue);
          String p=null;
          try {
            p=FileUtils.normalize(URLDecoder.decode(FileUtils.stripFragment(attValue),UTF8));
          }
 catch (          UnsupportedEncodingException e) {
            logger.logError(""String_Node_Str"" + attValue + ""String_Node_Str""+ e.getMessage(),e);
          }
          if (p != null) {
            final File f=new File(dirPath,p);
            if (f.exists()) {
              topicParser.parse(p,dirPath);
              final String fileId=topicParser.getFirstTopicId();
              util.addId(attValue,fileId);
              final String firstTopicId=SHARP + fileId;
              if (util.getIdValue(attValue) != null) {
                attValue=SHARP + util.getIdValue(attValue);
              }
 else {
                attValue=firstTopicId;
              }
              XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId);
            }
 else {
              final String fileName=new File(dirPath,attValue).getAbsolutePath();
              final Properties prop=new Properties();
              prop.put(""String_Node_Str"",fileName);
              logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
            }
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue);
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    String attValue=attributes.getValue(ATTRIBUTE_NAME_HREF);
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref);
        if (util.isVisited(attValue)) {
          attValue=SHARP + util.getIdValue(attValue);
        }
 else {
          String p=null;
          try {
            p=FileUtils.normalize(URLDecoder.decode(FileUtils.stripFragment(attValue),UTF8));
          }
 catch (          UnsupportedEncodingException e) {
            logger.logError(""String_Node_Str"" + attValue + ""String_Node_Str""+ e.getMessage(),e);
          }
          util.visit(p);
          if (p != null) {
            final File f=new File(dirPath,p);
            if (f.exists()) {
              topicParser.parse(p,dirPath);
              final String fileId=topicParser.getFirstTopicId();
              util.addId(attValue,fileId);
              final String firstTopicId=SHARP + fileId;
              if (util.getIdValue(attValue) != null) {
                attValue=SHARP + util.getIdValue(attValue);
              }
 else {
                attValue=firstTopicId;
              }
              XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId);
            }
 else {
              final String fileName=new File(dirPath,attValue).getAbsolutePath();
              final Properties prop=new Properties();
              prop.put(""String_Node_Str"",fileName);
              logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
            }
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue);
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}",0.9902313624678664
100810,"public final void setLogger(final DITAOTLogger logger){
  this.logger=logger;
}","public final void setLogger(final DITAOTLogger logger){
  this.logger=logger;
  topicParser.setLogger(logger);
}",0.8272251308900523
100811,"/** 
 * Default Constructor.
 */
public MergeMapParser(){
  processStack=new Stack<String>();
  processLevel=0;
  util=new MergeUtils();
  topicParser=new MergeTopicParser(util);
  topicParser.setLogger(logger);
  topicBuffer=new ByteArrayOutputStream();
  try {
    reader=StringUtils.getXMLReader();
    reader.setContentHandler(this);
    reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
    final TransformerFactory tf=TransformerFactory.newInstance();
    if (!tf.getFeature(SAXTransformerFactory.FEATURE)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    stf=(SAXTransformerFactory)tf;
    final TransformerHandler s=stf.newTransformerHandler();
    s.getTransformer().setOutputProperty(OMIT_XML_DECLARATION,""String_Node_Str"");
    s.setResult(new StreamResult(topicBuffer));
    topicParser.setContentHandler(s);
  }
 catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Default Constructor.
 */
public MergeMapParser(){
  processStack=new Stack<String>();
  processLevel=0;
  util=new MergeUtils();
  topicParser=new MergeTopicParser(util);
  topicBuffer=new ByteArrayOutputStream();
  try {
    reader=StringUtils.getXMLReader();
    reader.setContentHandler(this);
    reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
    final TransformerFactory tf=TransformerFactory.newInstance();
    if (!tf.getFeature(SAXTransformerFactory.FEATURE)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    stf=(SAXTransformerFactory)tf;
    final TransformerHandler s=stf.newTransformerHandler();
    s.getTransformer().setOutputProperty(OMIT_XML_DECLARATION,""String_Node_Str"");
    s.setResult(new StreamResult(topicBuffer));
    topicParser.setContentHandler(s);
  }
 catch (  final Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.9822675980655562
100812,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    String attValue=attributes.getValue(ATTRIBUTE_NAME_HREF);
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref);
        if (util.isVisited(attValue)) {
          attValue=SHARP + util.getIdValue(attValue);
        }
 else {
          util.visit(attValue);
          String p=null;
          try {
            p=FileUtils.normalize(URLDecoder.decode(FileUtils.stripFragment(attValue),UTF8));
          }
 catch (          UnsupportedEncodingException e) {
            logger.logError(""String_Node_Str"" + attValue + ""String_Node_Str""+ e.getMessage(),e);
          }
          if (p != null) {
            final File f=new File(dirPath,p);
            if (f.exists()) {
              topicParser.parse(p,dirPath);
              final String fileId=topicParser.getFirstTopicId();
              util.addId(attValue,fileId);
              final String firstTopicId=SHARP + fileId;
              if (util.getIdValue(attValue) != null) {
                attValue=SHARP + util.getIdValue(attValue);
              }
 else {
                attValue=firstTopicId;
              }
              XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId);
            }
 else {
              final String fileName=new File(dirPath,attValue).getAbsolutePath();
              final Properties prop=new Properties();
              prop.put(""String_Node_Str"",fileName);
              logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
            }
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue);
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes attributes) throws SAXException {
  final String attrValue=attributes.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  AttributesImpl atts=null;
  if (MAP_TOPICREF.matches(attributes)) {
    String attValue=attributes.getValue(ATTRIBUTE_NAME_HREF);
    if (attValue != null) {
      atts=new AttributesImpl(attributes);
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_OHREF,ohref);
        if (util.isVisited(attValue)) {
          attValue=SHARP + util.getIdValue(attValue);
        }
 else {
          String p=null;
          try {
            p=FileUtils.normalize(URLDecoder.decode(FileUtils.stripFragment(attValue),UTF8));
          }
 catch (          UnsupportedEncodingException e) {
            logger.logError(""String_Node_Str"" + attValue + ""String_Node_Str""+ e.getMessage(),e);
          }
          util.visit(p);
          if (p != null) {
            final File f=new File(dirPath,p);
            if (f.exists()) {
              topicParser.parse(p,dirPath);
              final String fileId=topicParser.getFirstTopicId();
              util.addId(attValue,fileId);
              final String firstTopicId=SHARP + fileId;
              if (util.getIdValue(attValue) != null) {
                attValue=SHARP + util.getIdValue(attValue);
              }
 else {
                attValue=firstTopicId;
              }
              XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_FIRST_TOPIC_ID,firstTopicId);
            }
 else {
              final String fileName=new File(dirPath,attValue).getAbsolutePath();
              final Properties prop=new Properties();
              prop.put(""String_Node_Str"",fileName);
              logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
            }
          }
        }
      }
      XMLUtils.addOrSetAttribute(atts,ATTRIBUTE_NAME_HREF,attValue);
    }
  }
  getContentHandler().startElement(uri,localName,qName,atts != null ? atts : attributes);
}",0.9902313624678664
100813,"public final void setLogger(final DITAOTLogger logger){
  this.logger=logger;
}","public final void setLogger(final DITAOTLogger logger){
  this.logger=logger;
  topicParser.setLogger(logger);
}",0.8272251308900523
100814,"@Override public void ignorableWhitespace(final char[] ch,final int start,final int length) throws SAXException {
  if (!exclude) {
    try {
      getContentHandler().ignorableWhitespace(ch,start,length);
    }
 catch (    final Exception e) {
      logger.logException(e);
    }
  }
}","@Override public void ignorableWhitespace(final char[] ch,final int start,final int length) throws SAXException {
  if (!exclude) {
    try {
      getContentHandler().characters(ch,start,length);
    }
 catch (    final Exception e) {
      logger.logException(e);
    }
  }
}",0.9484902309058616
100815,"private void processParseResult(String currentFile){
  final Map<String,String> cpMap=reader.getCopytoMap();
  final Map<String,KeyDef> kdMap=reader.getKeysDMap();
  final Map<String,String> exKdMap=reader.getExKeysDefMap();
  exKeyDefMap.putAll(exKdMap);
  for (  final String file : reader.getNonCopytoResult()) {
    categorizeResultFile(file);
    updateUplevels(file);
  }
  for (  final String key : cpMap.keySet()) {
    final String value=cpMap.get(key);
    if (copytoMap.containsKey(key)) {
      final Properties prop=new Properties();
      prop.setProperty(""String_Node_Str"",value);
      prop.setProperty(""String_Node_Str"",key);
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      ignoredCopytoSourceSet.add(value);
    }
 else {
      updateUplevels(key);
      copytoMap.put(key,value);
    }
  }
  schemeSet.addAll(reader.getSchemeRefSet());
  for (  final String key : kdMap.keySet()) {
    final KeyDef value=kdMap.get(key);
    if (keysDefMap.containsKey(key)) {
    }
 else {
      updateUplevels(key);
      keysDefMap.put(key,new KeyDef(value.keys,value.href,currentFile));
    }
    if (schemeSet.contains(currentFile)) {
      try {
        schemekeydef.writeStartElement(ELEMENT_KEYDEF);
        schemekeydef.writeAttribute(ATTRIBUTE_KEYS,key);
        if (value.href != null) {
          schemekeydef.writeAttribute(ATTRIBUTE_HREF,value.href);
        }
        schemekeydef.writeAttribute(ATTRIUBTE_SOURCE,currentFile);
        schemekeydef.writeEndElement();
      }
 catch (      final SAXException e) {
        logger.logException(e);
      }
    }
  }
  hrefTargetSet.addAll(reader.getHrefTargets());
  hrefWithIDSet.addAll(reader.getHrefTopicSet());
  chunkTopicSet.addAll(reader.getChunkTopicSet());
  conrefTargetSet.addAll(reader.getConrefTargets());
  nonConrefCopytoTargetSet.addAll(reader.getNonConrefCopytoTargets());
  ignoredCopytoSourceSet.addAll(reader.getIgnoredCopytoSourceSet());
  subsidiarySet.addAll(reader.getSubsidiaryTargets());
  outDitaFilesSet.addAll(reader.getOutFilesSet());
  resourceOnlySet.addAll(reader.getResourceOnlySet());
  if (reader.getSchemeSet() != null && reader.getSchemeSet().size() > 0) {
    Set<String> children=null;
    children=this.schemeDictionary.get(currentFile);
    if (children == null) {
      children=new HashSet<String>();
    }
    children.addAll(reader.getSchemeSet());
    currentFile=currentFile.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
    this.schemeDictionary.put(currentFile,children);
    final Set<String> hrfSet=reader.getHrefTargets();
    for (    String f : hrfSet) {
      final String filename=f.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
      children=this.schemeDictionary.get(filename);
      if (children == null) {
        children=new HashSet<String>();
      }
      children.addAll(reader.getSchemeSet());
      this.schemeDictionary.put(filename,children);
    }
  }
}","private void processParseResult(String currentFile){
  final Map<String,String> cpMap=reader.getCopytoMap();
  final Map<String,KeyDef> kdMap=reader.getKeysDMap();
  final Map<String,String> exKdMap=reader.getExKeysDefMap();
  exKeyDefMap.putAll(exKdMap);
  for (  final String file : reader.getNonCopytoResult()) {
    categorizeResultFile(file);
    updateUplevels(file);
  }
  for (  final String key : cpMap.keySet()) {
    final String value=cpMap.get(key);
    if (copytoMap.containsKey(key)) {
      final Properties prop=new Properties();
      prop.setProperty(""String_Node_Str"",value);
      prop.setProperty(""String_Node_Str"",key);
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      ignoredCopytoSourceSet.add(value);
    }
 else {
      updateUplevels(key);
      copytoMap.put(key,value);
    }
  }
  schemeSet.addAll(reader.getSchemeRefSet());
  for (  final String key : kdMap.keySet()) {
    final KeyDef value=kdMap.get(key);
    if (keysDefMap.containsKey(key)) {
    }
 else {
      updateUplevels(key);
      keysDefMap.put(key,new KeyDef(key,value.href,currentFile));
    }
    if (schemeSet.contains(currentFile)) {
      try {
        schemekeydef.writeStartElement(ELEMENT_KEYDEF);
        schemekeydef.writeAttribute(ATTRIBUTE_KEYS,key);
        if (value.href != null) {
          schemekeydef.writeAttribute(ATTRIBUTE_HREF,value.href);
        }
        schemekeydef.writeAttribute(ATTRIUBTE_SOURCE,currentFile);
        schemekeydef.writeEndElement();
      }
 catch (      final SAXException e) {
        logger.logException(e);
      }
    }
  }
  hrefTargetSet.addAll(reader.getHrefTargets());
  hrefWithIDSet.addAll(reader.getHrefTopicSet());
  chunkTopicSet.addAll(reader.getChunkTopicSet());
  conrefTargetSet.addAll(reader.getConrefTargets());
  nonConrefCopytoTargetSet.addAll(reader.getNonConrefCopytoTargets());
  ignoredCopytoSourceSet.addAll(reader.getIgnoredCopytoSourceSet());
  subsidiarySet.addAll(reader.getSubsidiaryTargets());
  outDitaFilesSet.addAll(reader.getOutFilesSet());
  resourceOnlySet.addAll(reader.getResourceOnlySet());
  if (reader.getSchemeSet() != null && reader.getSchemeSet().size() > 0) {
    Set<String> children=null;
    children=this.schemeDictionary.get(currentFile);
    if (children == null) {
      children=new HashSet<String>();
    }
    children.addAll(reader.getSchemeSet());
    currentFile=currentFile.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
    this.schemeDictionary.put(currentFile,children);
    final Set<String> hrfSet=reader.getHrefTargets();
    for (    String f : hrfSet) {
      final String filename=f.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
      children=this.schemeDictionary.get(filename);
      if (children == null) {
        children=new HashSet<String>();
      }
      children.addAll(reader.getSchemeSet());
      this.schemeDictionary.put(filename,children);
    }
  }
}",0.9988011645829764
100816,"@Override public void startElement(final String uri,final String localName,final String name,final Attributes atts) throws SAXException {
  currentElement=null;
  final String cls=atts.getValue(ATTRIBUTE_NAME_CLASS);
  for (  final KeyrefInfo k : keyrefInfos) {
    if (k.type.matches(cls)) {
      currentElement=k;
    }
  }
  final AttributesImpl resAtts=new AttributesImpl(atts);
  hasChecked=false;
  empty=true;
  boolean valid=false;
  if (atts.getIndex(ATTRIBUTE_NAME_KEYREF) == -1) {
    if (keyrefLeval != 0) {
      keyrefLeval++;
      hasSubElem.pop();
      hasSubElem.push(true);
    }
  }
 else {
    elemName.push(name);
    if (keyrefLeval != 0) {
      keyrefLevalStack.push(keyrefLeval);
      hasSubElem.pop();
      hasSubElem.push(true);
    }
    hasSubElem.push(false);
    keyrefLeval=0;
    keyrefLeval++;
    final String keyrefValue=atts.getValue(ATTRIBUTE_NAME_KEYREF);
    final int slashIndex=keyrefValue.indexOf(SLASH);
    String keyName=keyrefValue;
    String tail=""String_Node_Str"";
    if (slashIndex != -1) {
      keyName=keyrefValue.substring(0,slashIndex);
      tail=keyrefValue.substring(slashIndex);
    }
    final String definition=definitionMap.get(keyName);
    if (definition != null) {
      doc=keyDefToDoc(definition);
      final Element elem=doc.getDocumentElement();
      final NamedNodeMap namedNodeMap=elem.getAttributes();
      if (currentElement != null && currentElement.isRefType) {
        String target=keyMap.get(keyName);
        if (target != null && target.length() != 0) {
          String target_output=target;
          final String scopeValue=elem.getAttribute(ATTRIBUTE_NAME_SCOPE);
          if (TOPIC_IMAGE.matches(currentElement.type)) {
            valid=true;
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
            target_output=FileUtils.getRelativePathFromMap(fileName,target_output);
            target_output=normalizeHrefValue(target_output,tail);
            XMLUtils.addOrSetAttribute(resAtts,currentElement.refAttr,target_output);
          }
 else           if (""String_Node_Str"".equals(scopeValue) || ATTR_SCOPE_VALUE_LOCAL.equals(scopeValue)) {
            if (!(MAPGROUP_D_MAPREF.matches(cls) && FileUtils.isDITAMapFile(target.toLowerCase()))) {
              target=FileUtils.replaceExtName(target,extName);
            }
            final File topicFile=new File(FileUtils.resolveFile(tempDir,target));
            if (topicFile.exists()) {
              final String topicId=this.getFirstTopicId(topicFile);
              target_output=FileUtils.getRelativePathFromMap(filepath,new File(tempDir,target).getAbsolutePath());
              valid=true;
              XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
              XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
              XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
              XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
              target_output=normalizeHrefValue(target_output,tail,topicId);
              XMLUtils.addOrSetAttribute(resAtts,currentElement.refAttr,target_output);
            }
 else {
            }
          }
 else {
            valid=true;
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
            target_output=normalizeHrefValue(target_output,tail);
            XMLUtils.addOrSetAttribute(resAtts,ATTRIBUTE_NAME_HREF,target_output);
          }
        }
 else         if (target == null || target.length() == 0) {
          valid=true;
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
        }
 else {
          final Properties prop=new Properties();
          prop.put(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF));
          logger.logInfo(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
        }
      }
 else       if (currentElement != null && !currentElement.isRefType) {
        final String target=keyMap.get(keyName);
        if (target != null) {
          valid=true;
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
        }
 else {
        }
      }
      if (valid) {
        if (currentElement != null && MAP_TOPICREF.matches(currentElement.type)) {
          for (int index=0; index < namedNodeMap.getLength(); index++) {
            final Node node=namedNodeMap.item(index);
            if (node.getNodeType() == Node.ATTRIBUTE_NODE && !no_copy.contains(node.getNodeName())) {
              XMLUtils.removeAttribute(resAtts,node.getNodeName());
              XMLUtils.addOrSetAttribute(resAtts,node);
            }
          }
        }
 else {
          if (currentElement != null && currentElement.isRefType) {
            for (int index=0; index < namedNodeMap.getLength(); index++) {
              final Node node=namedNodeMap.item(index);
              if (node.getNodeType() == Node.ATTRIBUTE_NODE && !no_copy_topic.contains(node.getNodeName())) {
                XMLUtils.removeAttribute(resAtts,node.getNodeName());
                XMLUtils.addOrSetAttribute(resAtts,node);
              }
            }
          }
 else           if (currentElement != null && !currentElement.isRefType) {
            for (int index=0; index < namedNodeMap.getLength(); index++) {
              final Node node=namedNodeMap.item(index);
              if (node.getNodeType() == Node.ATTRIBUTE_NODE && !no_copy_topic.contains(node.getNodeName()) && !(node.getNodeName().equals(ATTRIBUTE_NAME_SCOPE) || node.getNodeName().equals(ATTRIBUTE_NAME_FORMAT) || node.getNodeName().equals(ATTRIBUTE_NAME_TYPE))) {
                XMLUtils.removeAttribute(resAtts,node.getNodeName());
                XMLUtils.addOrSetAttribute(resAtts,node);
              }
            }
          }
        }
      }
 else {
      }
    }
 else {
      final Properties prop=new Properties();
      prop.put(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF));
      logger.logInfo(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      ;
    }
    validKeyref.push(valid);
  }
  getContentHandler().startElement(uri,localName,name,resAtts);
}","@Override public void startElement(final String uri,final String localName,final String name,final Attributes atts) throws SAXException {
  currentElement=null;
  final String cls=atts.getValue(ATTRIBUTE_NAME_CLASS);
  for (  final KeyrefInfo k : keyrefInfos) {
    if (k.type.matches(cls)) {
      currentElement=k;
    }
  }
  final AttributesImpl resAtts=new AttributesImpl(atts);
  hasChecked=false;
  empty=true;
  boolean valid=false;
  if (atts.getIndex(ATTRIBUTE_NAME_KEYREF) == -1) {
    if (keyrefLeval != 0) {
      keyrefLeval++;
      hasSubElem.pop();
      hasSubElem.push(true);
    }
  }
 else {
    elemName.push(name);
    if (keyrefLeval != 0) {
      keyrefLevalStack.push(keyrefLeval);
      hasSubElem.pop();
      hasSubElem.push(true);
    }
    hasSubElem.push(false);
    keyrefLeval=0;
    keyrefLeval++;
    final String keyrefValue=atts.getValue(ATTRIBUTE_NAME_KEYREF);
    final int slashIndex=keyrefValue.indexOf(SLASH);
    String keyName=keyrefValue;
    String tail=""String_Node_Str"";
    if (slashIndex != -1) {
      keyName=keyrefValue.substring(0,slashIndex);
      tail=keyrefValue.substring(slashIndex);
    }
    final String definition=definitionMap.get(keyName);
    if (definition != null) {
      doc=keyDefToDoc(definition);
      final Element elem=doc.getDocumentElement();
      final NamedNodeMap namedNodeMap=elem.getAttributes();
      if (currentElement != null && currentElement.isRefType) {
        String target=keyMap.get(keyName);
        if (target != null && target.length() != 0) {
          String target_output=target;
          final String scopeValue=elem.getAttribute(ATTRIBUTE_NAME_SCOPE);
          if (TOPIC_IMAGE.matches(currentElement.type)) {
            valid=true;
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
            target_output=FileUtils.getRelativePathFromMap(fileName,target_output);
            target_output=normalizeHrefValue(target_output,tail);
            XMLUtils.addOrSetAttribute(resAtts,currentElement.refAttr,target_output);
          }
 else           if (""String_Node_Str"".equals(scopeValue) || ATTR_SCOPE_VALUE_LOCAL.equals(scopeValue)) {
            if (!(MAPGROUP_D_MAPREF.matches(cls) && FileUtils.isDITAMapFile(target.toLowerCase()))) {
              target=FileUtils.replaceExtName(target,extName);
            }
            final File topicFile=new File(FileUtils.resolveFile(tempDir,target));
            if (topicFile.exists()) {
              final String topicId=this.getFirstTopicId(topicFile);
              target_output=FileUtils.getRelativePathFromMap(filepath,new File(tempDir,target).getAbsolutePath());
              valid=true;
              XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
              XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
              XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
              XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
              target_output=normalizeHrefValue(target_output,tail,topicId);
              XMLUtils.addOrSetAttribute(resAtts,currentElement.refAttr,target_output);
            }
 else {
            }
          }
 else {
            valid=true;
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
            XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
            target_output=normalizeHrefValue(target_output,tail);
            XMLUtils.addOrSetAttribute(resAtts,ATTRIBUTE_NAME_HREF,target_output);
          }
        }
 else         if (target == null || target.length() == 0) {
          valid=true;
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
          XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
        }
 else {
          final Properties prop=new Properties();
          prop.put(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF));
          logger.logInfo(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
        }
      }
 else       if (currentElement != null && !currentElement.isRefType) {
        valid=true;
        XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_SCOPE);
        XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_HREF);
        XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_TYPE);
        XMLUtils.removeAttribute(resAtts,ATTRIBUTE_NAME_FORMAT);
      }
      if (valid) {
        if (currentElement != null && MAP_TOPICREF.matches(currentElement.type)) {
          for (int index=0; index < namedNodeMap.getLength(); index++) {
            final Node node=namedNodeMap.item(index);
            if (node.getNodeType() == Node.ATTRIBUTE_NODE && !no_copy.contains(node.getNodeName())) {
              XMLUtils.removeAttribute(resAtts,node.getNodeName());
              XMLUtils.addOrSetAttribute(resAtts,node);
            }
          }
        }
 else {
          if (currentElement != null && currentElement.isRefType) {
            for (int index=0; index < namedNodeMap.getLength(); index++) {
              final Node node=namedNodeMap.item(index);
              if (node.getNodeType() == Node.ATTRIBUTE_NODE && !no_copy_topic.contains(node.getNodeName())) {
                XMLUtils.removeAttribute(resAtts,node.getNodeName());
                XMLUtils.addOrSetAttribute(resAtts,node);
              }
            }
          }
 else           if (currentElement != null && !currentElement.isRefType) {
            for (int index=0; index < namedNodeMap.getLength(); index++) {
              final Node node=namedNodeMap.item(index);
              if (node.getNodeType() == Node.ATTRIBUTE_NODE && !no_copy_topic.contains(node.getNodeName()) && !(node.getNodeName().equals(ATTRIBUTE_NAME_SCOPE) || node.getNodeName().equals(ATTRIBUTE_NAME_FORMAT) || node.getNodeName().equals(ATTRIBUTE_NAME_TYPE))) {
                XMLUtils.removeAttribute(resAtts,node.getNodeName());
                XMLUtils.addOrSetAttribute(resAtts,node);
              }
            }
          }
        }
      }
 else {
      }
    }
 else {
      final Properties prop=new Properties();
      prop.put(""String_Node_Str"",atts.getValue(ATTRIBUTE_NAME_KEYREF));
      logger.logInfo(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      ;
    }
    validKeyref.push(valid);
  }
  getContentHandler().startElement(uri,localName,name,resAtts);
}",0.989813118358373
100817,"/** 
 * Write keydef into keydef.xml.
 * @param keyName key name.
 * @param result keydef.
 */
private void writeKeyDef(final KeyDef keyDef){
  try {
    keydef.writeStartElement(""String_Node_Str"");
    keydef.writeAttribute(""String_Node_Str"",keyDef.keys);
    keydef.writeAttribute(""String_Node_Str"",keyDef.href);
    if (keyDef.source != null) {
      keydef.writeAttribute(""String_Node_Str"",keyDef.source);
    }
    keydef.writeEndElement();
  }
 catch (  final SAXException e) {
    logger.logException(e);
  }
}","/** 
 * Write keydef into keydef.xml.
 * @param keyName key name.
 * @param result keydef.
 */
private void writeKeyDef(final KeyDef keyDef){
  try {
    keydef.writeStartElement(""String_Node_Str"");
    keydef.writeAttribute(""String_Node_Str"",keyDef.keys);
    if (keyDef.href != null) {
      keydef.writeAttribute(""String_Node_Str"",keyDef.href);
    }
    if (keyDef.source != null) {
      keydef.writeAttribute(""String_Node_Str"",keyDef.source);
    }
    keydef.writeEndElement();
  }
 catch (  final SAXException e) {
    logger.logException(e);
  }
}",0.9636533084808948
100818,"private void processParseResult(String currentFile){
  final Map<String,String> cpMap=reader.getCopytoMap();
  final Map<String,KeyDef> kdMap=reader.getKeysDMap();
  final Map<String,String> exKdMap=reader.getExKeysDefMap();
  exKeyDefMap.putAll(exKdMap);
  for (  final String file : reader.getNonCopytoResult()) {
    categorizeResultFile(file);
    updateUplevels(file);
  }
  for (  final String key : cpMap.keySet()) {
    final String value=cpMap.get(key);
    if (copytoMap.containsKey(key)) {
      final Properties prop=new Properties();
      prop.setProperty(""String_Node_Str"",value);
      prop.setProperty(""String_Node_Str"",key);
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      ignoredCopytoSourceSet.add(value);
    }
 else {
      updateUplevels(key);
      copytoMap.put(key,value);
    }
  }
  schemeSet.addAll(reader.getSchemeRefSet());
  for (  final String key : kdMap.keySet()) {
    final KeyDef value=kdMap.get(key);
    if (keysDefMap.containsKey(key)) {
    }
 else {
      updateUplevels(key);
      keysDefMap.put(key,new KeyDef(value.keys,value.href,currentFile));
    }
    if (schemeSet.contains(currentFile)) {
      try {
        schemekeydef.writeStartElement(""String_Node_Str"");
        schemekeydef.writeAttribute(""String_Node_Str"",key);
        schemekeydef.writeAttribute(""String_Node_Str"",value.href);
        schemekeydef.writeAttribute(""String_Node_Str"",currentFile);
        schemekeydef.writeEndElement();
      }
 catch (      final SAXException e) {
        logger.logException(e);
      }
    }
  }
  hrefTargetSet.addAll(reader.getHrefTargets());
  hrefWithIDSet.addAll(reader.getHrefTopicSet());
  chunkTopicSet.addAll(reader.getChunkTopicSet());
  conrefTargetSet.addAll(reader.getConrefTargets());
  nonConrefCopytoTargetSet.addAll(reader.getNonConrefCopytoTargets());
  ignoredCopytoSourceSet.addAll(reader.getIgnoredCopytoSourceSet());
  subsidiarySet.addAll(reader.getSubsidiaryTargets());
  outDitaFilesSet.addAll(reader.getOutFilesSet());
  resourceOnlySet.addAll(reader.getResourceOnlySet());
  if (reader.getSchemeSet() != null && reader.getSchemeSet().size() > 0) {
    Set<String> children=null;
    children=this.schemeDictionary.get(currentFile);
    if (children == null) {
      children=new HashSet<String>();
    }
    children.addAll(reader.getSchemeSet());
    currentFile=currentFile.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
    this.schemeDictionary.put(currentFile,children);
    final Set<String> hrfSet=reader.getHrefTargets();
    for (    String f : hrfSet) {
      final String filename=f.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
      children=this.schemeDictionary.get(filename);
      if (children == null) {
        children=new HashSet<String>();
      }
      children.addAll(reader.getSchemeSet());
      this.schemeDictionary.put(filename,children);
    }
  }
}","private void processParseResult(String currentFile){
  final Map<String,String> cpMap=reader.getCopytoMap();
  final Map<String,KeyDef> kdMap=reader.getKeysDMap();
  final Map<String,String> exKdMap=reader.getExKeysDefMap();
  exKeyDefMap.putAll(exKdMap);
  for (  final String file : reader.getNonCopytoResult()) {
    categorizeResultFile(file);
    updateUplevels(file);
  }
  for (  final String key : cpMap.keySet()) {
    final String value=cpMap.get(key);
    if (copytoMap.containsKey(key)) {
      final Properties prop=new Properties();
      prop.setProperty(""String_Node_Str"",value);
      prop.setProperty(""String_Node_Str"",key);
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      ignoredCopytoSourceSet.add(value);
    }
 else {
      updateUplevels(key);
      copytoMap.put(key,value);
    }
  }
  schemeSet.addAll(reader.getSchemeRefSet());
  for (  final String key : kdMap.keySet()) {
    final KeyDef value=kdMap.get(key);
    if (keysDefMap.containsKey(key)) {
    }
 else {
      updateUplevels(key);
      keysDefMap.put(key,new KeyDef(value.keys,value.href,currentFile));
    }
    if (schemeSet.contains(currentFile)) {
      try {
        schemekeydef.writeStartElement(""String_Node_Str"");
        schemekeydef.writeAttribute(""String_Node_Str"",key);
        if (value.href != null) {
          schemekeydef.writeAttribute(""String_Node_Str"",value.href);
        }
        schemekeydef.writeAttribute(""String_Node_Str"",currentFile);
        schemekeydef.writeEndElement();
      }
 catch (      final SAXException e) {
        logger.logException(e);
      }
    }
  }
  hrefTargetSet.addAll(reader.getHrefTargets());
  hrefWithIDSet.addAll(reader.getHrefTopicSet());
  chunkTopicSet.addAll(reader.getChunkTopicSet());
  conrefTargetSet.addAll(reader.getConrefTargets());
  nonConrefCopytoTargetSet.addAll(reader.getNonConrefCopytoTargets());
  ignoredCopytoSourceSet.addAll(reader.getIgnoredCopytoSourceSet());
  subsidiarySet.addAll(reader.getSubsidiaryTargets());
  outDitaFilesSet.addAll(reader.getOutFilesSet());
  resourceOnlySet.addAll(reader.getResourceOnlySet());
  if (reader.getSchemeSet() != null && reader.getSchemeSet().size() > 0) {
    Set<String> children=null;
    children=this.schemeDictionary.get(currentFile);
    if (children == null) {
      children=new HashSet<String>();
    }
    children.addAll(reader.getSchemeSet());
    currentFile=currentFile.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
    this.schemeDictionary.put(currentFile,children);
    final Set<String> hrfSet=reader.getHrefTargets();
    for (    String f : hrfSet) {
      final String filename=f.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
      children=this.schemeDictionary.get(filename);
      if (children == null) {
        children=new HashSet<String>();
      }
      children.addAll(reader.getSchemeSet());
      this.schemeDictionary.put(filename,children);
    }
  }
}",0.9920962199312716
100819,"/** 
 * Add or set attribute. Convenience method for   {@link #addOrSetAttribute(AttributesImpl,String,String,String,String,String)}.
 * @param atts attributes
 * @param att attribute node
 */
public static void addOrSetAttribute(final AttributesImpl atts,final Node att){
  if (att.getNodeType() != Node.ATTRIBUTE_NODE) {
    throw new IllegalArgumentException();
  }
  final Attr a=(Attr)att;
  addOrSetAttribute(atts,a.getNamespaceURI() != null ? a.getNamespaceURI() : NULL_NS_URI,a.getLocalName() != null ? a.getLocalName() : ""String_Node_Str"",a.getName() != null ? a.getName() : ""String_Node_Str"",a.isId() ? ""String_Node_Str"" : ""String_Node_Str"",a.getValue());
}","/** 
 * Add or set attribute. Convenience method for   {@link #addOrSetAttribute(AttributesImpl,String,String,String,String,String)}.
 * @param atts attributes
 * @param att attribute node
 */
public static void addOrSetAttribute(final AttributesImpl atts,final Node att){
  if (att.getNodeType() != Node.ATTRIBUTE_NODE) {
    throw new IllegalArgumentException();
  }
  final Attr a=(Attr)att;
  addOrSetAttribute(atts,a.getNamespaceURI() != null ? a.getNamespaceURI() : NULL_NS_URI,a.getLocalName() != null ? a.getLocalName() : (a.getName() != null ? a.getName() : ""String_Node_Str""),a.getName() != null ? a.getName() : ""String_Node_Str"",a.isId() ? ""String_Node_Str"" : ""String_Node_Str"",a.getValue());
}",0.9460641399416908
100820,"/** 
 * Add or set attribute. Convenience method for   {@link #addOrSetAttribute(AttributesImpl,String,String,String,String,String)}.
 * @param atts attributes
 * @param att attribute node
 */
public static void addOrSetAttribute(final AttributesImpl atts,final Node att){
  if (att.getNodeType() != Node.ATTRIBUTE_NODE) {
    throw new IllegalArgumentException();
  }
  final Attr a=(Attr)att;
  addOrSetAttribute(atts,a.getNamespaceURI() != null ? a.getNamespaceURI() : NULL_NS_URI,a.getLocalName() != null ? a.getLocalName() : (a.getName() != null ? a.getName() : ""String_Node_Str""),a.getName() != null ? a.getName() : ""String_Node_Str"",a.isId() ? ""String_Node_Str"" : ""String_Node_Str"",a.getValue());
}","/** 
 * Add or set attribute. Convenience method for   {@link #addOrSetAttribute(AttributesImpl,String,String,String,String,String)}.
 * @param atts attributes
 * @param att attribute node
 */
public static void addOrSetAttribute(final AttributesImpl atts,final Node att){
  if (att.getNodeType() != Node.ATTRIBUTE_NODE) {
    throw new IllegalArgumentException();
  }
  final Attr a=(Attr)att;
  String localName=a.getLocalName();
  if (localName == null) {
    localName=a.getName();
    final int i=localName.indexOf(':');
    if (i != -1) {
      localName=localName.substring(i + 1);
    }
  }
  addOrSetAttribute(atts,a.getNamespaceURI() != null ? a.getNamespaceURI() : NULL_NS_URI,localName,a.getName() != null ? a.getName() : localName,a.isId() ? ""String_Node_Str"" : ""String_Node_Str"",a.getValue());
}",0.7331571994715984
100821,"/** 
 * Parse the input attributes for needed information.
 */
private void parseAttribute(final Attributes atts,final String attrName) throws SAXException {
  String attrValue=atts.getValue(attrName);
  String filename=null;
  final String attrClass=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  final String attrFormat=atts.getValue(ATTRIBUTE_NAME_FORMAT);
  final String attrType=atts.getValue(ATTRIBUTE_NAME_TYPE);
  final String codebase=atts.getValue(ATTRIBUTE_NAME_CODEBASE);
  if (attrValue == null) {
    return;
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) || ATTRIBUTE_NAME_CONKEYREF.equals(attrName)) {
    hasConRef=true;
  }
 else   if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
    if (attrClass != null && PR_D_CODEREF.matches(attrClass)) {
      hasCodeRef=true;
    }
 else {
      hasHref=true;
    }
  }
 else   if (ATTRIBUTE_NAME_KEYREF.equals(attrName)) {
    hasKeyRef=true;
  }
  if (ATTRIBUTE_NAME_KEYS.equals(attrName) && attrValue.length() != 0) {
    String target=atts.getValue(ATTRIBUTE_NAME_HREF);
    final String keyRef=atts.getValue(ATTRIBUTE_NAME_KEYREF);
    final String copy_to=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
    if (!StringUtils.isEmptyString(copy_to)) {
      target=copy_to;
    }
    if (target == null) {
      target=""String_Node_Str"";
    }
    final String temp=target;
    for (    final String key : attrValue.split(""String_Node_Str"")) {
      if (!keysDefMap.containsKey(key) && !key.equals(""String_Node_Str"")) {
        if (target != null && target.length() != 0) {
          if (attrScope != null && (attrScope.equals(""String_Node_Str"") || attrScope.equals(""String_Node_Str""))) {
            exKeysDefMap.put(key,target);
            keysDefMap.put(key,new KeyDef(key,target,null));
          }
 else {
            String tail=""String_Node_Str"";
            if (target.indexOf(SHARP) != -1) {
              tail=target.substring(target.indexOf(SHARP));
              target=target.substring(0,target.indexOf(SHARP));
            }
            if (new File(target).isAbsolute()) {
              target=FileUtils.getRelativePathFromMap(rootFilePath,target);
            }
            target=FileUtils.normalizeDirectory(currentDir,target);
            keysDefMap.put(key,new KeyDef(key,target + tail,null));
          }
        }
 else         if (!StringUtils.isEmptyString(keyRef)) {
          keysRefMap.put(key,keyRef);
        }
 else {
          keysDefMap.put(key,new KeyDef(null,null,null));
        }
      }
 else {
        final Properties prop=new Properties();
        prop.setProperty(""String_Node_Str"",key);
        prop.setProperty(""String_Node_Str"",target);
        logger.logInfo(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      }
      target=temp;
    }
  }
  if (""String_Node_Str"".equalsIgnoreCase(attrScope) || ""String_Node_Str"".equalsIgnoreCase(attrScope) || attrValue.indexOf(COLON_DOUBLE_SLASH) != -1 || attrValue.startsWith(SHARP)) {
    return;
  }
  if (attrValue.startsWith(""String_Node_Str"") && attrValue.indexOf(""String_Node_Str"") == -1) {
    attrValue=attrValue.substring(""String_Node_Str"".length());
    if (UNIX_SEPARATOR.equals(File.separator)) {
      attrValue=UNIX_SEPARATOR + attrValue;
    }
  }
  final File target=new File(attrValue);
  if (target.isAbsolute() && !ATTRIBUTE_NAME_DATA.equals(attrName)) {
    attrValue=FileUtils.getRelativePathFromMap(rootFilePath,attrValue);
  }
 else   if (ATTRIBUTE_NAME_DATA.equals(attrName)) {
    if (!StringUtils.isEmptyString(codebase)) {
      filename=FileUtils.normalizeDirectory(codebase,attrValue);
    }
 else {
      filename=FileUtils.normalizeDirectory(currentDir,attrValue);
    }
  }
 else {
    filename=FileUtils.normalizeDirectory(currentDir,attrValue);
  }
  if (filename != null) {
    try {
      filename=URLDecoder.decode(filename,UTF8);
    }
 catch (    final UnsupportedEncodingException e) {
    }
  }
  if (MAP_TOPICREF.matches(attrClass)) {
    if (ATTR_TYPE_VALUE_SUBJECT_SCHEME.equalsIgnoreCase(attrType)) {
      schemeSet.add(filename);
    }
    if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
      if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(attrFormat)) {
        if (attrName.equals(ATTRIBUTE_NAME_HREF)) {
          topicHref=filename;
          topicHref=topicHref.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
          if (attrValue.lastIndexOf(SHARP) != -1) {
            final int position=attrValue.lastIndexOf(SHARP);
            topicId=attrValue.substring(position + 1);
          }
 else {
            if (FileUtils.isDITAFile(topicHref)) {
              topicId=topicHref + QUESTION;
            }
          }
        }
      }
 else {
        topicHref=""String_Node_Str"";
        topicId=""String_Node_Str"";
      }
    }
  }
  if ((""String_Node_Str"".equals(attrType) && ATTRIBUTE_NAME_DATA.equals(attrName)) || attrClass != null && PR_D_CODEREF.matches(attrClass)) {
    subsidiarySet.add(filename);
    return;
  }
  if (filename != null && FileUtils.isValidTarget(filename.toLowerCase()) && (StringUtils.isEmptyString(atts.getValue(ATTRIBUTE_NAME_COPY_TO)) || !FileUtils.isTopicFile(atts.getValue(ATTRIBUTE_NAME_COPY_TO).toLowerCase()) || (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) && !ATTRIBUTE_NAME_CONREF.equals(attrName) && !ATTRIBUTE_NAME_COPY_TO.equals(attrName) && (canResolved() || FileUtils.isSupportedImageFile(filename.toLowerCase()))) {
    if (attrFormat != null) {
      nonConrefCopytoTargets.add(filename + STICK + attrFormat);
    }
 else {
      nonConrefCopytoTargets.add(filename);
    }
  }
  if (attrFormat != null && !ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(attrFormat)) {
    return;
  }
  if (ATTRIBUTE_NAME_HREF.equals(attrName) && FileUtils.isTopicFile(filename) && canResolved()) {
    hrefTargets.add(new File(filename).getPath());
    toOutFile(new File(filename).getPath());
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0 && relTableLevel == 0) {
      chunkTopicSet.add(filename);
    }
 else {
      hrefTopicSet.add(filename);
    }
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) && FileUtils.isDITAFile(filename)) {
    conrefTargets.add(filename);
    toOutFile(new File(filename).getPath());
  }
  if (ATTRIBUTE_NAME_COPY_TO.equals(attrName) && FileUtils.isTopicFile(filename)) {
    final String href=atts.getValue(ATTRIBUTE_NAME_HREF);
    if (StringUtils.isEmptyString(href)) {
      final StringBuffer buff=new StringBuffer();
      buff.append(""String_Node_Str"");
      buff.append(filename);
      buff.append(""String_Node_Str"");
      logger.logWarn(buff.toString());
    }
 else     if (copytoMap.get(filename) != null) {
      final Properties prop=new Properties();
      prop.setProperty(""String_Node_Str"",href);
      prop.setProperty(""String_Node_Str"",filename);
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      ignoredCopytoSourceSet.add(href);
    }
 else     if (!(atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) {
      copytoMap.put(filename,FileUtils.normalizeDirectory(currentDir,href));
    }
    final String pathWithoutID=FileUtils.resolveFile(currentDir,attrValue);
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0) {
      chunkTopicSet.add(pathWithoutID);
    }
 else {
      hrefTopicSet.add(pathWithoutID);
    }
  }
  if (ATTRIBUTE_NAME_CONACTION.equals(attrName)) {
    if (attrValue.equals(""String_Node_Str"") || attrValue.equals(""String_Node_Str"")) {
      hasconaction=true;
    }
  }
}","/** 
 * Parse the input attributes for needed information.
 */
private void parseAttribute(final Attributes atts,final String attrName) throws SAXException {
  String attrValue=atts.getValue(attrName);
  String filename=null;
  final String attrClass=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final String attrScope=atts.getValue(ATTRIBUTE_NAME_SCOPE);
  final String attrFormat=atts.getValue(ATTRIBUTE_NAME_FORMAT);
  final String attrType=atts.getValue(ATTRIBUTE_NAME_TYPE);
  final String codebase=atts.getValue(ATTRIBUTE_NAME_CODEBASE);
  if (attrValue == null) {
    return;
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) || ATTRIBUTE_NAME_CONKEYREF.equals(attrName)) {
    hasConRef=true;
  }
 else   if (ATTRIBUTE_NAME_HREF.equals(attrName)) {
    if (attrClass != null && PR_D_CODEREF.matches(attrClass)) {
      hasCodeRef=true;
    }
 else {
      hasHref=true;
    }
  }
 else   if (ATTRIBUTE_NAME_KEYREF.equals(attrName)) {
    hasKeyRef=true;
  }
  if (ATTRIBUTE_NAME_KEYS.equals(attrName) && attrValue.length() != 0) {
    String target=atts.getValue(ATTRIBUTE_NAME_HREF);
    final String keyRef=atts.getValue(ATTRIBUTE_NAME_KEYREF);
    final String copy_to=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
    if (!StringUtils.isEmptyString(copy_to)) {
      target=copy_to;
    }
    if (target == null) {
      target=""String_Node_Str"";
    }
    final String temp=target;
    for (    final String key : attrValue.split(""String_Node_Str"")) {
      if (!keysDefMap.containsKey(key) && !key.equals(""String_Node_Str"")) {
        if (target != null && target.length() != 0) {
          if (attrScope != null && (attrScope.equals(""String_Node_Str"") || attrScope.equals(""String_Node_Str""))) {
            exKeysDefMap.put(key,target);
            keysDefMap.put(key,new KeyDef(key,target,null));
          }
 else {
            String tail=""String_Node_Str"";
            if (target.indexOf(SHARP) != -1) {
              tail=target.substring(target.indexOf(SHARP));
              target=target.substring(0,target.indexOf(SHARP));
            }
            if (new File(target).isAbsolute()) {
              target=FileUtils.getRelativePathFromMap(rootFilePath,target);
            }
            target=FileUtils.normalizeDirectory(currentDir,target);
            keysDefMap.put(key,new KeyDef(key,target + tail,null));
          }
        }
 else         if (!StringUtils.isEmptyString(keyRef)) {
          keysRefMap.put(key,keyRef);
        }
 else {
          keysDefMap.put(key,new KeyDef(key,null,null));
        }
      }
 else {
        final Properties prop=new Properties();
        prop.setProperty(""String_Node_Str"",key);
        prop.setProperty(""String_Node_Str"",target);
        logger.logInfo(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      }
      target=temp;
    }
  }
  if (""String_Node_Str"".equalsIgnoreCase(attrScope) || ""String_Node_Str"".equalsIgnoreCase(attrScope) || attrValue.indexOf(COLON_DOUBLE_SLASH) != -1 || attrValue.startsWith(SHARP)) {
    return;
  }
  if (attrValue.startsWith(""String_Node_Str"") && attrValue.indexOf(""String_Node_Str"") == -1) {
    attrValue=attrValue.substring(""String_Node_Str"".length());
    if (UNIX_SEPARATOR.equals(File.separator)) {
      attrValue=UNIX_SEPARATOR + attrValue;
    }
  }
  final File target=new File(attrValue);
  if (target.isAbsolute() && !ATTRIBUTE_NAME_DATA.equals(attrName)) {
    attrValue=FileUtils.getRelativePathFromMap(rootFilePath,attrValue);
  }
 else   if (ATTRIBUTE_NAME_DATA.equals(attrName)) {
    if (!StringUtils.isEmptyString(codebase)) {
      filename=FileUtils.normalizeDirectory(codebase,attrValue);
    }
 else {
      filename=FileUtils.normalizeDirectory(currentDir,attrValue);
    }
  }
 else {
    filename=FileUtils.normalizeDirectory(currentDir,attrValue);
  }
  if (filename != null) {
    try {
      filename=URLDecoder.decode(filename,UTF8);
    }
 catch (    final UnsupportedEncodingException e) {
    }
  }
  if (MAP_TOPICREF.matches(attrClass)) {
    if (ATTR_TYPE_VALUE_SUBJECT_SCHEME.equalsIgnoreCase(attrType)) {
      schemeSet.add(filename);
    }
    if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
      if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(attrFormat)) {
        if (attrName.equals(ATTRIBUTE_NAME_HREF)) {
          topicHref=filename;
          topicHref=topicHref.replace(WINDOWS_SEPARATOR,UNIX_SEPARATOR);
          if (attrValue.lastIndexOf(SHARP) != -1) {
            final int position=attrValue.lastIndexOf(SHARP);
            topicId=attrValue.substring(position + 1);
          }
 else {
            if (FileUtils.isDITAFile(topicHref)) {
              topicId=topicHref + QUESTION;
            }
          }
        }
      }
 else {
        topicHref=""String_Node_Str"";
        topicId=""String_Node_Str"";
      }
    }
  }
  if ((""String_Node_Str"".equals(attrType) && ATTRIBUTE_NAME_DATA.equals(attrName)) || attrClass != null && PR_D_CODEREF.matches(attrClass)) {
    subsidiarySet.add(filename);
    return;
  }
  if (filename != null && FileUtils.isValidTarget(filename.toLowerCase()) && (StringUtils.isEmptyString(atts.getValue(ATTRIBUTE_NAME_COPY_TO)) || !FileUtils.isTopicFile(atts.getValue(ATTRIBUTE_NAME_COPY_TO).toLowerCase()) || (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) && !ATTRIBUTE_NAME_CONREF.equals(attrName) && !ATTRIBUTE_NAME_COPY_TO.equals(attrName) && (canResolved() || FileUtils.isSupportedImageFile(filename.toLowerCase()))) {
    if (attrFormat != null) {
      nonConrefCopytoTargets.add(filename + STICK + attrFormat);
    }
 else {
      nonConrefCopytoTargets.add(filename);
    }
  }
  if (attrFormat != null && !ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(attrFormat)) {
    return;
  }
  if (ATTRIBUTE_NAME_HREF.equals(attrName) && FileUtils.isTopicFile(filename) && canResolved()) {
    hrefTargets.add(new File(filename).getPath());
    toOutFile(new File(filename).getPath());
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0 && relTableLevel == 0) {
      chunkTopicSet.add(filename);
    }
 else {
      hrefTopicSet.add(filename);
    }
  }
  if (ATTRIBUTE_NAME_CONREF.equals(attrName) && FileUtils.isDITAFile(filename)) {
    conrefTargets.add(filename);
    toOutFile(new File(filename).getPath());
  }
  if (ATTRIBUTE_NAME_COPY_TO.equals(attrName) && FileUtils.isTopicFile(filename)) {
    final String href=atts.getValue(ATTRIBUTE_NAME_HREF);
    if (StringUtils.isEmptyString(href)) {
      final StringBuffer buff=new StringBuffer();
      buff.append(""String_Node_Str"");
      buff.append(filename);
      buff.append(""String_Node_Str"");
      logger.logWarn(buff.toString());
    }
 else     if (copytoMap.get(filename) != null) {
      final Properties prop=new Properties();
      prop.setProperty(""String_Node_Str"",href);
      prop.setProperty(""String_Node_Str"",filename);
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
      ignoredCopytoSourceSet.add(href);
    }
 else     if (!(atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains(""String_Node_Str""))) {
      copytoMap.put(filename,FileUtils.normalizeDirectory(currentDir,href));
    }
    final String pathWithoutID=FileUtils.resolveFile(currentDir,attrValue);
    if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0) {
      chunkTopicSet.add(pathWithoutID);
    }
 else {
      hrefTopicSet.add(pathWithoutID);
    }
  }
  if (ATTRIBUTE_NAME_CONACTION.equals(attrName)) {
    if (attrValue.equals(""String_Node_Str"") || attrValue.equals(""String_Node_Str"")) {
      hasconaction=true;
    }
  }
}",0.9995432300163132
100822,"private void processFile(String currentFile) throws DITAOTException {
  File fileToParse;
  final File file=new File(currentFile);
  if (file.isAbsolute()) {
    fileToParse=file;
    currentFile=FileUtils.getRelativePathFromMap(rootFile,currentFile);
  }
 else {
    fileToParse=new File(baseInputDir,currentFile);
  }
  logger.logInfo(""String_Node_Str"" + fileToParse.getAbsolutePath());
  String msg=null;
  final Properties params=new Properties();
  params.put(""String_Node_Str"",currentFile);
  if (!fileToParse.exists()) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",params).toString());
    return;
  }
  try {
    fileToParse=fileToParse.getCanonicalFile();
    if (FileUtils.isValidTarget(currentFile.toLowerCase())) {
      reader.setTranstype(transtype);
      reader.setCurrentDir(new File(currentFile).getParent());
      reader.parse(fileToParse);
    }
 else {
      final Properties prop=new Properties();
      prop.put(""String_Node_Str"",fileToParse);
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",params).toString());
    }
    if (reader.isValidInput()) {
      processParseResult(currentFile);
      categorizeCurrentFile(currentFile);
    }
 else     if (!currentFile.equals(inputFile)) {
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",params).toString());
    }
  }
 catch (  final SAXParseException sax) {
    final Exception inner=sax.getException();
    if (inner != null && inner instanceof DITAOTException) {
      logger.logInfo(inner.getMessage());
      throw (DITAOTException)inner;
    }
    if (currentFile.equals(inputFile)) {
      final MessageBean msgBean=MessageUtils.getMessage(""String_Node_Str"",params);
      msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
      msg=new StringBuffer(msg).append(""String_Node_Str"").append(sax.getMessage()).toString();
      throw new DITAOTException(msgBean,sax,msg);
    }
    final StringBuffer buff=new StringBuffer();
    msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
    buff.append(msg).append(LINE_SEPARATOR).append(sax.getMessage());
    logger.logError(buff.toString());
  }
catch (  final Exception e) {
    if (currentFile.equals(inputFile)) {
      final MessageBean msgBean=MessageUtils.getMessage(""String_Node_Str"",params);
      msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
      msg=new StringBuffer(msg).append(""String_Node_Str"").append(e.getMessage()).toString();
      throw new DITAOTException(msgBean,e,msg);
    }
    final StringBuffer buff=new StringBuffer();
    msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
    buff.append(msg).append(LINE_SEPARATOR).append(e.getMessage());
    logger.logError(buff.toString());
  }
  if (!reader.isValidInput() && currentFile.equals(inputFile)) {
    if (xmlValidate == true) {
      msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
      throw new DITAOTException(msg);
    }
 else {
      msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
      throw new DITAOTException(msg);
    }
  }
  doneList.add(currentFile);
  reader.reset();
}","private void processFile(String currentFile) throws DITAOTException {
  File fileToParse;
  final File file=new File(currentFile);
  if (file.isAbsolute()) {
    fileToParse=file;
    currentFile=FileUtils.getRelativePathFromMap(rootFile,currentFile);
  }
 else {
    fileToParse=new File(baseInputDir,currentFile);
  }
  try {
    fileToParse=fileToParse.getCanonicalFile();
  }
 catch (  IOException e1) {
    logger.logError(e1.toString());
  }
  logger.logInfo(""String_Node_Str"" + fileToParse.getAbsolutePath());
  String msg=null;
  final Properties params=new Properties();
  params.put(""String_Node_Str"",currentFile);
  if (!fileToParse.exists()) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",params).toString());
    return;
  }
  try {
    if (FileUtils.isValidTarget(currentFile.toLowerCase())) {
      reader.setTranstype(transtype);
      reader.setCurrentDir(new File(currentFile).getParent());
      reader.parse(fileToParse);
    }
 else {
      final Properties prop=new Properties();
      prop.put(""String_Node_Str"",fileToParse);
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",params).toString());
    }
    if (reader.isValidInput()) {
      processParseResult(currentFile);
      categorizeCurrentFile(currentFile);
    }
 else     if (!currentFile.equals(inputFile)) {
      logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",params).toString());
    }
  }
 catch (  final SAXParseException sax) {
    final Exception inner=sax.getException();
    if (inner != null && inner instanceof DITAOTException) {
      logger.logInfo(inner.getMessage());
      throw (DITAOTException)inner;
    }
    if (currentFile.equals(inputFile)) {
      final MessageBean msgBean=MessageUtils.getMessage(""String_Node_Str"",params);
      msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
      msg=new StringBuffer(msg).append(""String_Node_Str"").append(sax.getMessage()).toString();
      throw new DITAOTException(msgBean,sax,msg);
    }
    final StringBuffer buff=new StringBuffer();
    msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
    buff.append(msg).append(LINE_SEPARATOR).append(sax.getMessage());
    logger.logError(buff.toString());
  }
catch (  final Exception e) {
    if (currentFile.equals(inputFile)) {
      final MessageBean msgBean=MessageUtils.getMessage(""String_Node_Str"",params);
      msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
      msg=new StringBuffer(msg).append(""String_Node_Str"").append(e.getMessage()).toString();
      throw new DITAOTException(msgBean,e,msg);
    }
    final StringBuffer buff=new StringBuffer();
    msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
    buff.append(msg).append(LINE_SEPARATOR).append(e.getMessage());
    logger.logError(buff.toString());
  }
  if (!reader.isValidInput() && currentFile.equals(inputFile)) {
    if (xmlValidate == true) {
      msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
      throw new DITAOTException(msg);
    }
 else {
      msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
      throw new DITAOTException(msg);
    }
  }
  doneList.add(currentFile);
  reader.reset();
}",0.9722921914357684
100823,"/** 
 * read map files.
 * @param filename filename
 */
public void read(final String filename){
  final File inputFile=new File(filename);
  filePath=inputFile.getParent();
  inputFile.getPath();
  globalMeta.clear();
  try {
    final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    final DocumentBuilder builder=factory.newDocumentBuilder();
    builder.setErrorHandler(new DITAOTXMLErrorHandler(filename));
    doc=builder.parse(inputFile);
    final Element root=doc.getDocumentElement();
    final NodeList list=root.getChildNodes();
    for (int i=0; i < list.getLength(); i++) {
      final Node node=list.item(i);
      Node classAttr=null;
      if (node.getNodeType() == Node.ELEMENT_NODE) {
        classAttr=node.getAttributes().getNamedItem(ATTRIBUTE_NAME_CLASS);
      }
      if (classAttr != null && MAP_TOPICMETA.matches(classAttr.getNodeValue())) {
        handleGlobalMeta(node);
      }
 else       if (classAttr != null && MAP_TOPICREF.matches(classAttr.getNodeValue())) {
        handleTopicref(node,globalMeta);
      }
    }
    for (    final Hashtable<String,Element> resultTableEntry : resultTable.values()) {
      for (      final Map.Entry<String,Element> mapEntry : resultTableEntry.entrySet()) {
        final String key=mapEntry.getKey();
        if (TOPIC_KEYWORDS.matcher.equals(key)) {
          removeIndexTermRecursive(mapEntry.getValue());
        }
      }
    }
    final FileOutputStream file=new FileOutputStream(inputFile.getCanonicalPath() + ""String_Node_Str"");
    final StreamResult res=new StreamResult(file);
    final DOMSource ds=new DOMSource(doc);
    final TransformerFactory tff=TransformerFactory.newInstance();
    final Transformer tf=tff.newTransformer();
    tf.transform(ds,res);
    if (res.getOutputStream() != null) {
      res.getOutputStream().close();
    }
    if (file != null) {
      file.close();
    }
  }
 catch (  final Exception e) {
    logger.logException(e);
  }
}","/** 
 * read map files.
 * @param filename filename
 */
public void read(final String filename){
  final File inputFile=new File(filename);
  filePath=inputFile.getParent();
  inputFile.getPath();
  globalMeta.clear();
  try {
    final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    final DocumentBuilder builder=factory.newDocumentBuilder();
    builder.setErrorHandler(new DITAOTXMLErrorHandler(filename));
    doc=builder.parse(inputFile);
    final Element root=doc.getDocumentElement();
    final NodeList list=root.getChildNodes();
    for (int i=0; i < list.getLength(); i++) {
      final Node node=list.item(i);
      Node classAttr=null;
      if (node.getNodeType() == Node.ELEMENT_NODE) {
        classAttr=node.getAttributes().getNamedItem(ATTRIBUTE_NAME_CLASS);
      }
      if (classAttr != null && MAP_TOPICMETA.matches(classAttr.getNodeValue())) {
        handleGlobalMeta(node);
      }
 else       if (classAttr != null && MAP_TOPICREF.matches(classAttr.getNodeValue())) {
        handleTopicref(node,globalMeta);
      }
    }
    for (    final Hashtable<String,Element> resultTableEntry : resultTable.values()) {
      for (      final Map.Entry<String,Element> mapEntry : resultTableEntry.entrySet()) {
        final String key=mapEntry.getKey();
        if (TOPIC_KEYWORDS.matcher.equals(key)) {
          removeIndexTermRecursive(mapEntry.getValue());
        }
      }
    }
    FileOutputStream file=null;
    try {
      file=new FileOutputStream(inputFile.getCanonicalPath() + ""String_Node_Str"");
      final StreamResult res=new StreamResult(file);
      final DOMSource ds=new DOMSource(doc);
      final TransformerFactory tff=TransformerFactory.newInstance();
      final Transformer tf=tff.newTransformer();
      tf.transform(ds,res);
    }
  finally {
      if (file != null) {
        file.close();
      }
    }
  }
 catch (  final Exception e) {
    logger.logException(e);
  }
}",0.909323116219668
100824,"@Before public void setUp() throws IOException, DITAOTException {
  tempDir=TestUtils.createTempDir(getClass());
  final File inputDir=new File(""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str"");
  final File inputMap=new File(inputDir,""String_Node_Str"");
  final File outDir=new File(tempDir,""String_Node_Str"");
  final PipelineHashIO pipelineInput=new PipelineHashIO();
  pipelineInput.setAttribute(""String_Node_Str"",inputMap.getPath());
  pipelineInput.setAttribute(""String_Node_Str"",baseDir.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",inputDir.getPath());
  pipelineInput.setAttribute(""String_Node_Str"",outDir.getPath());
  pipelineInput.setAttribute(""String_Node_Str"",tempDir.getPath());
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",new File(tempDir,""String_Node_Str"").getPath());
  pipelineInput.setAttribute(""String_Node_Str"",new File(tempDir,""String_Node_Str"").getPath());
  pipelineInput.setAttribute(Constants.ANT_INVOKER_EXT_PARAN_SETSYSTEMID,""String_Node_Str"");
  final AbstractFacade facade=new PipelineFacade();
  facade.setLogger(new TestUtils.TestLogger());
  facade.execute(""String_Node_Str"",pipelineInput);
}","@Before public void setUp() throws IOException, DITAOTException {
  tempDir=TestUtils.createTempDir(getClass());
  final File inputDir=new File(""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str"");
  final File inputMap=new File(inputDir,""String_Node_Str"");
  final File outDir=new File(tempDir,""String_Node_Str"");
  final PipelineHashIO pipelineInput=new PipelineHashIO();
  pipelineInput.setAttribute(""String_Node_Str"",inputMap.getPath());
  pipelineInput.setAttribute(""String_Node_Str"",baseDir.getAbsolutePath());
  pipelineInput.setAttribute(""String_Node_Str"",inputDir.getPath());
  pipelineInput.setAttribute(""String_Node_Str"",outDir.getPath());
  pipelineInput.setAttribute(""String_Node_Str"",tempDir.getPath());
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pipelineInput.setAttribute(""String_Node_Str"",new File(tempDir,""String_Node_Str"").getPath());
  pipelineInput.setAttribute(""String_Node_Str"",new File(tempDir,""String_Node_Str"").getPath());
  pipelineInput.setAttribute(ANT_INVOKER_EXT_PARAN_SETSYSTEMID,""String_Node_Str"");
  final AbstractFacade facade=new PipelineFacade();
  facade.setLogger(new TestUtils.TestLogger());
  facade.execute(""String_Node_Str"",pipelineInput);
}",0.997178329571106
100825,"@Test public void testFileContent() throws Exception {
  final Properties properties=new Properties();
  properties.load(new FileInputStream(tempDir + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  properties.load(new FileInputStream(tempDir + File.separator + ""String_Node_Str""));
  final String[] expFullditamapandtopiclist={""String_Node_Str"" + File.separator + ""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str""};
  final String[] actFullditamapandtopiclist=properties.getProperty(""String_Node_Str"").split(""String_Node_Str"");
  Arrays.sort(expFullditamapandtopiclist);
  Arrays.sort(actFullditamapandtopiclist);
  assertArrayEquals(expFullditamapandtopiclist,actFullditamapandtopiclist);
  properties.load(new FileInputStream(tempDir + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  properties.load(new FileInputStream(tempDir + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  properties.load(new FileInputStream(tempDir + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  properties.load(new FileInputStream(tempDir + File.separator + ""String_Node_Str""));
  assertEquals(""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"",properties.getProperty(""String_Node_Str""));
  assertEquals(""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"",properties.getProperty(""String_Node_Str""));
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  final DocumentBuilder builder=factory.newDocumentBuilder();
  final Document document=builder.parse(new File(tempDir + File.separator + ""String_Node_Str""));
  final Element elem=document.getDocumentElement();
  final NodeList nodeList=elem.getElementsByTagName(""String_Node_Str"");
  final String[] keys={""String_Node_Str"",""String_Node_Str""};
  final String[] href={""String_Node_Str"" + File.separator + ""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str""};
  final String[] source={""String_Node_Str"" + File.separator + ""String_Node_Str"",""String_Node_Str"" + File.separator + ""String_Node_Str""};
  for (int i=0; i < nodeList.getLength(); i++) {
    assertEquals(keys[i],((Element)nodeList.item(i)).getAttribute(""String_Node_Str""));
    assertEquals(href[i],((Element)nodeList.item(i)).getAttribute(""String_Node_Str""));
    assertEquals(source[i],((Element)nodeList.item(i)).getAttribute(""String_Node_Str""));
  }
  properties.load(new FileInputStream(tempDir + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  properties.load(new FileInputStream(tempDir + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
  properties.load(new FileInputStream(tempDir + File.separator + ""String_Node_Str""));
  assertTrue(properties.containsKey(""String_Node_Str"" + File.separator + ""String_Node_Str""));
}","@Test public void testFileContent() throws Exception {
  final List<String> canditopicsList=readLines(new File(tempDir,""String_Node_Str""));
  assertTrue(canditopicsList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  assertTrue(canditopicsList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  assertTrue(canditopicsList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  final Properties ditaProps=readProperties(new File(tempDir,""String_Node_Str""));
  final String[] expFullditamapandtopiclist={""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""};
  final String[] actFullditamapandtopiclist=ditaProps.getProperty(""String_Node_Str"").split(""String_Node_Str"");
  Arrays.sort(expFullditamapandtopiclist);
  Arrays.sort(actFullditamapandtopiclist);
  assertArrayEquals(expFullditamapandtopiclist,actFullditamapandtopiclist);
  final List<String> fullditamapandtopicList=readLines(new File(tempDir,""String_Node_Str""));
  assertTrue(fullditamapandtopicList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  assertTrue(fullditamapandtopicList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  assertTrue(fullditamapandtopicList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  assertTrue(fullditamapandtopicList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  final List<String> hrefditatopicList=readLines(new File(tempDir,""String_Node_Str""));
  assertTrue(hrefditatopicList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  final List<String> hreftargetsList=readLines(new File(tempDir,""String_Node_Str""));
  assertTrue(hreftargetsList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  assertTrue(hreftargetsList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  assertTrue(hreftargetsList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  final Properties keyProps=readProperties(new File(tempDir,""String_Node_Str""));
  assertEquals(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""+ UNIX_SEPARATOR+ ""String_Node_Str"",keyProps.getProperty(""String_Node_Str""));
  assertEquals(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""+ UNIX_SEPARATOR+ ""String_Node_Str"",keyProps.getProperty(""String_Node_Str""));
  final DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
  final DocumentBuilder builder=factory.newDocumentBuilder();
  final Document document=builder.parse(new File(tempDir + File.separator + ""String_Node_Str""));
  final Element elem=document.getDocumentElement();
  final NodeList nodeList=elem.getElementsByTagName(""String_Node_Str"");
  final String[] keys={""String_Node_Str"",""String_Node_Str""};
  final String[] href={""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""};
  final String[] source={""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str"",""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""};
  for (int i=0; i < nodeList.getLength(); i++) {
    assertEquals(keys[i],((Element)nodeList.item(i)).getAttribute(""String_Node_Str""));
    assertEquals(href[i],((Element)nodeList.item(i)).getAttribute(""String_Node_Str""));
    assertEquals(source[i],((Element)nodeList.item(i)).getAttribute(""String_Node_Str""));
  }
  final List<String> keyrefList=readLines(new File(tempDir,""String_Node_Str""));
  assertTrue(keyrefList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  final List<String> outditafilesList=readLines(new File(tempDir,""String_Node_Str""));
  assertTrue(outditafilesList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  assertTrue(outditafilesList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  assertTrue(outditafilesList.contains(""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""));
  final List<String> usrInputFileList=readLines(new File(tempDir,""String_Node_Str""));
  assertTrue(usrInputFileList.contains(""String_Node_Str"" + File.separator + ""String_Node_Str""));
}",0.4277442987120406
100826,"@Test public void testread(){
  final File path=new File(resourceDir,""String_Node_Str"" + File.separator);
  DitaURIResolverFactory.setPath(path.getAbsolutePath());
  final ListReader listreader=new ListReader();
  listreader.read(null);
  final String userinputfile=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
  assertEquals(userinputfile,listreader.getContent().getValue().toString());
  final String userinputmap=""String_Node_Str"";
  assertEquals(userinputmap,listreader.getInputMap());
  final String subjectschemelist=""String_Node_Str"";
  assertEquals(subjectschemelist,listreader.getSchemeSet().toString());
}","@Test public void testread(){
  final File path=new File(resourceDir,""String_Node_Str"" + File.separator);
  DitaURIResolverFactory.setPath(path.getAbsolutePath());
  final ListReader listreader=new ListReader();
  listreader.read(null);
  final String userinputfile=""String_Node_Str"" + UNIX_SEPARATOR + ""String_Node_Str""+ UNIX_SEPARATOR+ ""String_Node_Str""+ UNIX_SEPARATOR+ ""String_Node_Str""+ UNIX_SEPARATOR+ ""String_Node_Str""+ UNIX_SEPARATOR+ ""String_Node_Str""+ UNIX_SEPARATOR+ ""String_Node_Str""+ UNIX_SEPARATOR+ ""String_Node_Str""+ UNIX_SEPARATOR+ ""String_Node_Str"";
  assertEquals(userinputfile,listreader.getContent().getValue().toString());
  final String userinputmap=""String_Node_Str"";
  assertEquals(userinputmap,listreader.getInputMap());
  final String subjectschemelist=""String_Node_Str"";
  assertEquals(subjectschemelist,listreader.getSchemeSet().toString());
}",0.7014925373134329
100827,"/** 
 * Get the image height(ODT Transform).
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return int -The height of the picture in pixels.
 */
public static int getHeightODT(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  final File imgInput=new File(getImageOutPutPath(fileName));
  try {
    final BufferedImage img=ImageIO.read(imgInput);
    return img.getHeight();
  }
 catch (  final Exception e) {
    final Properties prop=new Properties();
    prop.put(""String_Node_Str"",dirName + File.separatorChar + fileName);
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    logger.logException(e);
    return -1;
  }
}","/** 
 * Get the image height(ODT Transform).
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return int -The height of the picture in pixels.
 */
public static int getHeightODT(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  File imgInput=new File(dirName + File.separatorChar + fileName);
  if (checkDirName(dirName))   imgInput=new File(getImageOutPutPath(fileName));
  try {
    final BufferedImage img=ImageIO.read(imgInput);
    return img.getHeight();
  }
 catch (  final Exception e) {
    final Properties prop=new Properties();
    prop.put(""String_Node_Str"",dirName + File.separatorChar + fileName);
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    logger.logException(e);
    return -1;
  }
}",0.9428403064230996
100828,"/** 
 * Get the image binary data, with hexical output. For RTF transformation
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return java.lang.String -The Hexical binary of image data converted to String.
 */
public static String getBinData(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  final File imgInput=new File(getImageOutPutPath(fileName));
  FileInputStream binInput=null;
  int bin;
  try {
    String binStr=null;
    final StringBuffer ret=new StringBuffer(INT_16 * INT_1024);
    binInput=new FileInputStream(imgInput);
    bin=binInput.read();
    while (bin != -1) {
      binStr=Integer.toHexString(bin);
      if (binStr.length() < 2) {
        ret.append(""String_Node_Str"");
      }
      ret.append(binStr);
      bin=binInput.read();
    }
    return ret.toString();
  }
 catch (  final Exception e) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    logger.logException(e);
    return null;
  }
 finally {
    try {
      binInput.close();
    }
 catch (    final IOException ioe) {
      logger.logException(ioe);
    }
  }
}","/** 
 * Get the image binary data, with hexical output. For RTF transformation
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return java.lang.String -The Hexical binary of image data converted to String.
 */
public static String getBinData(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  File imgInput=new File(dirName + File.separatorChar + fileName);
  if (checkDirName(dirName))   imgInput=new File(getImageOutPutPath(fileName));
  FileInputStream binInput=null;
  int bin;
  try {
    String binStr=null;
    final StringBuffer ret=new StringBuffer(INT_16 * INT_1024);
    binInput=new FileInputStream(imgInput);
    bin=binInput.read();
    while (bin != -1) {
      binStr=Integer.toHexString(bin);
      if (binStr.length() < 2) {
        ret.append(""String_Node_Str"");
      }
      ret.append(binStr);
      bin=binInput.read();
    }
    return ret.toString();
  }
 catch (  final Exception e) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    logger.logException(e);
    return null;
  }
 finally {
    try {
      binInput.close();
    }
 catch (    final IOException ioe) {
      logger.logException(ioe);
    }
  }
}",0.961915979583824
100829,"/** 
 * Get the image height.
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return int -The height of the picture in pixels.
 */
public static int getHeight(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  final File imgInput=new File(getImageOutPutPath(fileName));
  try {
    final BufferedImage img=ImageIO.read(imgInput);
    return img.getHeight();
  }
 catch (  final Exception e) {
    final Properties prop=new Properties();
    prop.put(""String_Node_Str"",dirName + File.separatorChar + fileName);
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    logger.logException(e);
    return -1;
  }
}","/** 
 * Get the image height.
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return int -The height of the picture in pixels.
 */
public static int getHeight(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  File imgInput=new File(dirName + File.separatorChar + fileName);
  if (checkDirName(dirName))   imgInput=new File(getImageOutPutPath(fileName));
  try {
    final BufferedImage img=ImageIO.read(imgInput);
    return img.getHeight();
  }
 catch (  final Exception e) {
    final Properties prop=new Properties();
    prop.put(""String_Node_Str"",dirName + File.separatorChar + fileName);
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    logger.logException(e);
    return -1;
  }
}",0.9416014449127031
100830,"/** 
 * Get the image width(ODT Transform).
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return int -The width of the picture in pixels.
 */
public static int getWidthODT(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  final File imgInput=new File(getImageOutPutPath(fileName));
  try {
    final BufferedImage img=ImageIO.read(imgInput);
    return img.getWidth();
  }
 catch (  final Exception e) {
    final Properties prop=new Properties();
    prop.put(""String_Node_Str"",dirName + File.separatorChar + fileName);
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    logger.logException(e);
    return -1;
  }
}","/** 
 * Get the image width(ODT Transform).
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return int -The width of the picture in pixels.
 */
public static int getWidthODT(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  File imgInput=new File(dirName + File.separatorChar + fileName);
  if (checkDirName(dirName))   imgInput=new File(getImageOutPutPath(fileName));
  try {
    final BufferedImage img=ImageIO.read(imgInput);
    return img.getWidth();
  }
 catch (  final Exception e) {
    final Properties prop=new Properties();
    prop.put(""String_Node_Str"",dirName + File.separatorChar + fileName);
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    logger.logException(e);
    return -1;
  }
}",0.9425695677915926
100831,"/** 
 * Get Base64 encoding content. For ODT transformation
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return base64 encoded binary data.
 */
public static String getBASE64(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  final File imgInput=new File(getImageOutPutPath(fileName));
  final Base64 encoder=new Base64();
  final byte buff[]=new byte[(int)imgInput.length()];
  FileInputStream file=null;
  try {
    file=new FileInputStream(imgInput);
    file.read(buff);
    final String ret=encoder.encodeToString(buff);
    return ret;
  }
 catch (  final FileNotFoundException e) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    logger.logException(e);
    return null;
  }
catch (  final IOException e) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    logger.logException(e);
    return null;
  }
 finally {
    try {
      file.close();
    }
 catch (    final IOException ioe) {
      logger.logException(ioe);
    }
  }
}","/** 
 * Get Base64 encoding content. For ODT transformation
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return base64 encoded binary data.
 */
public static String getBASE64(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  File imgInput=new File(dirName + File.separatorChar + fileName);
  if (checkDirName(dirName))   imgInput=new File(getImageOutPutPath(fileName));
  final Base64 encoder=new Base64();
  final byte buff[]=new byte[(int)imgInput.length()];
  FileInputStream file=null;
  try {
    file=new FileInputStream(imgInput);
    file.read(buff);
    final String ret=encoder.encodeToString(buff);
    return ret;
  }
 catch (  final FileNotFoundException e) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    logger.logException(e);
    return null;
  }
catch (  final IOException e) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    logger.logException(e);
    return null;
  }
 finally {
    try {
      file.close();
    }
 catch (    final IOException ioe) {
      logger.logException(ioe);
    }
  }
}",0.959329140461216
100832,"/** 
 * Get the image width.
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return int -The width of the picture in pixels.
 */
public static int getWidth(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  final File imgInput=new File(getImageOutPutPath(fileName));
  try {
    final BufferedImage img=ImageIO.read(imgInput);
    return img.getWidth();
  }
 catch (  final Exception e) {
    final Properties prop=new Properties();
    prop.put(""String_Node_Str"",dirName + File.separatorChar + fileName);
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    logger.logException(e);
    return -1;
  }
}","/** 
 * Get the image width.
 * @param dirName -The directory name that will be added to the path of the image file.
 * @param fileName -The file name of the image file.
 * @return int -The width of the picture in pixels.
 */
public static int getWidth(final String dirName,final String fileName){
  final DITAOTJavaLogger logger=new DITAOTJavaLogger();
  File imgInput=new File(dirName + File.separatorChar + fileName);
  if (checkDirName(dirName))   imgInput=new File(getImageOutPutPath(fileName));
  try {
    final BufferedImage img=ImageIO.read(imgInput);
    return img.getWidth();
  }
 catch (  final Exception e) {
    final Properties prop=new Properties();
    prop.put(""String_Node_Str"",dirName + File.separatorChar + fileName);
    logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    logger.logException(e);
    return -1;
  }
}",0.941318814277072
100833,"/** 
 * Read temporary configuration files.
 * @throws IOException if reading configuration files failed
 * @throws IllegalStateException if configuration files are missing
 */
private void read() throws IOException {
  final File ditalist=new File(tempDir,FILE_NAME_DITA_LIST);
  final File xmlDitalist=new File(tempDir,FILE_NAME_DITA_LIST_XML);
  InputStream in=null;
  try {
    if (xmlDitalist.exists()) {
      in=new FileInputStream(xmlDitalist);
      prop.loadFromXML(in);
    }
 else     if (ditalist.exists()) {
      in=new FileInputStream(ditalist);
      prop.load(in);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
}","/** 
 * Read temporary configuration files.
 * @throws IOException if reading configuration files failed
 * @throws IllegalStateException if configuration files are missing
 */
private void read() throws IOException {
  final File ditalist=new File(tempDir,FILE_NAME_DITA_LIST);
  final File xmlDitalist=new File(tempDir,FILE_NAME_DITA_LIST_XML);
  InputStream in=null;
  try {
    if (xmlDitalist.exists()) {
      in=new FileInputStream(xmlDitalist);
      prop.loadFromXML(in);
    }
 else     if (ditalist.exists()) {
      in=new FileInputStream(ditalist);
      prop.load(in);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
}",0.9979231568016614
100834,"/** 
 * Store job into temporary configuration files.
 * @throws IOException if writing configuration files failed
 */
public void write() throws IOException {
  FileOutputStream propertiesOutputStream=null;
  try {
    propertiesOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST));
    prop.store(propertiesOutputStream,null);
    propertiesOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    if (propertiesOutputStream != null) {
      try {
        propertiesOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
  FileOutputStream xmlOutputStream=null;
  try {
    xmlOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST_XML));
    prop.storeToXML(xmlOutputStream,null);
    xmlOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    if (xmlOutputStream != null) {
      try {
        xmlOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
}","/** 
 * Store job into temporary configuration files.
 * @throws IOException if writing configuration files failed
 */
public void write() throws IOException {
  FileOutputStream propertiesOutputStream=null;
  try {
    propertiesOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST));
    prop.store(propertiesOutputStream,null);
    propertiesOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (propertiesOutputStream != null) {
      try {
        propertiesOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  FileOutputStream xmlOutputStream=null;
  try {
    xmlOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST_XML));
    prop.storeToXML(xmlOutputStream,null);
    xmlOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    if (xmlOutputStream != null) {
      try {
        xmlOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
}",0.9984152139461172
100835,"/** 
 * Store job into temporary configuration files.
 * @throws IOException if writing configuration files failed
 */
public void write() throws IOException {
  FileOutputStream propertiesOutputStream=null;
  try {
    propertiesOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST));
    prop.store(propertiesOutputStream,null);
    propertiesOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (propertiesOutputStream != null) {
      try {
        propertiesOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  FileOutputStream xmlOutputStream=null;
  try {
    xmlOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST_XML));
    prop.storeToXML(xmlOutputStream,null);
    xmlOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    if (xmlOutputStream != null) {
      try {
        xmlOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
}","/** 
 * Store job into temporary configuration files.
 * @throws IOException if writing configuration files failed
 */
public void write() throws IOException {
  FileOutputStream propertiesOutputStream=null;
  try {
    propertiesOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST));
    prop.store(propertiesOutputStream,null);
    propertiesOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (propertiesOutputStream != null) {
      try {
        propertiesOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  FileOutputStream xmlOutputStream=null;
  try {
    xmlOutputStream=new FileOutputStream(new File(tempDir,FILE_NAME_DITA_LIST_XML));
    prop.storeToXML(xmlOutputStream,null);
    xmlOutputStream.flush();
  }
 catch (  final IOException e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (xmlOutputStream != null) {
      try {
        xmlOutputStream.close();
      }
 catch (      final IOException e) {
        throw new IOException(""String_Node_Str"" + e.getMessage());
      }
    }
  }
}",0.9984101748807632
100836,"@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final String attrValue=atts.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  mapInfo.append(LESS_THAN).append(qName);
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final int attsLen=atts.getLength();
  for (int i=0; i < attsLen; i++) {
    final String attQName=atts.getQName(i);
    String attValue=atts.getValue(i);
    if (ATTRIBUTE_NAME_HREF.equals(attQName) && !StringUtils.isEmptyString(attValue) && classValue != null && MAP_TOPICREF.matches(classValue)) {
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        if (util.isVisited(attValue)) {
          mapInfo.append(STRING_BLANK).append(""String_Node_Str"").append(EQUAL).append(QUOTATION).append(StringUtils.escapeXML(ohref)).append(QUOTATION);
          attValue=new StringBuffer(SHARP).append(util.getIdValue(attValue)).toString();
        }
 else {
          mapInfo.append(STRING_BLANK).append(""String_Node_Str"").append(EQUAL).append(QUOTATION).append(StringUtils.escapeXML(ohref)).append(QUOTATION);
          util.visit(attValue);
          if (new File(dirPath,attValue).exists()) {
            final String fileId=topicParser.parse(attValue,dirPath);
            attValue=new StringBuffer(SHARP).append(fileId).toString();
          }
 else {
            final String fileName=new File(dirPath,attValue).getAbsolutePath();
            final Properties prop=new Properties();
            prop.put(""String_Node_Str"",fileName);
            logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
          }
        }
      }
    }
    mapInfo.append(STRING_BLANK).append(attQName).append(EQUAL).append(QUOTATION).append(StringUtils.escapeXML(attValue)).append(QUOTATION);
  }
  mapInfo.append(GREATER_THAN);
}","@Override public void startElement(final String uri,final String localName,final String qName,final Attributes atts) throws SAXException {
  final String attrValue=atts.getValue(ATTRIBUTE_NAME_PROCESSING_ROLE);
  if (attrValue != null) {
    processStack.push(attrValue);
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(attrValue)) {
      return;
    }
  }
 else   if (processLevel > 0) {
    processLevel++;
    if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processStack.peek())) {
      return;
    }
  }
  mapInfo.append(LESS_THAN).append(qName);
  final String classValue=atts.getValue(ATTRIBUTE_NAME_CLASS);
  final int attsLen=atts.getLength();
  for (int i=0; i < attsLen; i++) {
    final String attQName=atts.getQName(i);
    String attValue=atts.getValue(i);
    if (ATTRIBUTE_NAME_HREF.equals(attQName) && !StringUtils.isEmptyString(attValue) && classValue != null && MAP_TOPICREF.matches(classValue)) {
      final String scopeValue=atts.getValue(ATTRIBUTE_NAME_SCOPE);
      final String formatValue=atts.getValue(ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        final String ohref=attValue;
        final String copyToValue=atts.getValue(ATTRIBUTE_NAME_COPY_TO);
        if (!StringUtils.isEmptyString(copyToValue)) {
          attValue=copyToValue;
        }
        if (util.isVisited(attValue)) {
          mapInfo.append(STRING_BLANK).append(""String_Node_Str"").append(EQUAL).append(QUOTATION).append(StringUtils.escapeXML(ohref)).append(QUOTATION);
          attValue=new StringBuffer(SHARP).append(util.getIdValue(attValue)).toString();
        }
 else {
          mapInfo.append(STRING_BLANK).append(""String_Node_Str"").append(EQUAL).append(QUOTATION).append(StringUtils.escapeXML(ohref)).append(QUOTATION);
          util.visit(attValue);
          if (new File(dirPath,attValue.indexOf(SHARP) != -1 ? attValue.substring(0,attValue.indexOf(SHARP)) : attValue).exists()) {
            final String fileId=topicParser.parse(attValue,dirPath);
            attValue=new StringBuffer(SHARP).append(fileId).toString();
          }
 else {
            final String fileName=new File(dirPath,attValue).getAbsolutePath();
            final Properties prop=new Properties();
            prop.put(""String_Node_Str"",fileName);
            logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
          }
        }
      }
    }
    mapInfo.append(STRING_BLANK).append(attQName).append(EQUAL).append(QUOTATION).append(StringUtils.escapeXML(attValue)).append(QUOTATION);
  }
  mapInfo.append(GREATER_THAN);
}",0.9852180339985218
100837,"@Test public void testExecute() throws Exception {
  final File libDir=new File(tempDir,""String_Node_Str"");
  if (!libDir.exists() && !libDir.mkdirs()) {
    throw new IOException(""String_Node_Str"" + libDir);
  }
  final Integrator i=new Integrator();
  i.setBasedir(tempDir);
  i.setDitaDir(tempDir);
  i.setProperties(new File(tempDir,""String_Node_Str""));
  i.execute();
  assertEquals(getProperties(new File(expDir,""String_Node_Str"" + File.separator + Constants.CONF_PROPERTIES)),getProperties(new File(tempDir,""String_Node_Str"" + File.separator + Constants.CONF_PROPERTIES)));
  XMLUnit.setNormalizeWhitespace(true);
  XMLUnit.setIgnoreWhitespace(true);
  XMLUnit.setIgnoreDiffBetweenTextAndCDATA(true);
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"").toURI().toString()));
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"").toURI().toString()));
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"" + File.separator + ""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"" + File.separator + ""String_Node_Str"").toURI().toString()));
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toURI().toString()));
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toURI().toString()));
}","@Test public void testExecute() throws Exception {
  final File libDir=new File(tempDir,""String_Node_Str"");
  if (!libDir.exists() && !libDir.mkdirs()) {
    throw new IOException(""String_Node_Str"" + libDir);
  }
  final Integrator i=new Integrator();
  i.setBasedir(tempDir);
  i.setDitaDir(tempDir);
  i.setProperties(new File(tempDir,""String_Node_Str""));
  i.execute();
  assertEquals(getProperties(new File(expDir,""String_Node_Str"" + File.separator + Constants.CONF_PROPERTIES)),getProperties(new File(tempDir,""String_Node_Str"" + File.separator + Constants.CONF_PROPERTIES)));
  XMLUnit.setNormalizeWhitespace(true);
  XMLUnit.setIgnoreWhitespace(true);
  XMLUnit.setIgnoreDiffBetweenTextAndCDATA(true);
  XMLUnit.setControlDocumentBuilderFactory(DocumentBuilderFactory.newInstance());
  XMLUnit.setTestDocumentBuilderFactory(DocumentBuilderFactory.newInstance());
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"").toURI().toString()));
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"").toURI().toString()));
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"" + File.separator + ""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"" + File.separator + ""String_Node_Str"").toURI().toString()));
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toURI().toString()));
  assertXMLEqual(new InputSource(new File(expDir,""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toURI().toString()),new InputSource(new File(tempDir,""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toURI().toString()));
}",0.9603741078021166
100838,"@AfterClass public static void tearDown() throws IOException {
}","@AfterClass public static void tearDown() throws IOException {
  TestUtils.forceDelete(tempDir);
}",0.7901234567901234
100839,"@BeforeClass public static void setUp() throws IOException, DITAOTException {
  tempDir=TestUtils.createTempDir(TestCHMIndexWriter.class);
  final DocumentBuilderFactory factory=new HTMLDocumentBuilderFactory();
  XMLUnit.setControlDocumentBuilderFactory(factory);
  XMLUnit.setTestDocumentBuilderFactory(factory);
  XMLUnit.setIgnoreWhitespace(true);
  XMLUnit.setIgnoreComments(true);
}","@BeforeClass public static void setUp() throws IOException, DITAOTException {
  tempDir=TestUtils.createTempDir(TestCHMIndexWriter.class);
  final DocumentBuilderFactory factory=new HTMLDocumentBuilderFactory();
  XMLUnit.setControlDocumentBuilderFactory(factory);
  XMLUnit.setTestDocumentBuilderFactory(factory);
  XMLUnit.setControlEntityResolver(null);
  XMLUnit.setTestEntityResolver(null);
  XMLUnit.setIgnoreWhitespace(true);
  XMLUnit.setIgnoreComments(true);
}",0.9054842473745623
100840,"@AfterClass public static void tearDown() throws IOException {
}","@AfterClass public static void tearDown() throws IOException {
  TestUtils.forceDelete(tempDir);
}",0.7901234567901234
100841,"public void write(final String filename) throws DITAOTException {
  final File inputFile=new File(filename);
  final File outputFile=new File(filename + FILE_EXTENSION_TEMP);
  try {
    final Transformer transformer=TransformerFactory.newInstance().newTransformer();
    final XMLReader reader=StringUtils.getXMLReader();
    setParent(reader);
    final Source source=new SAXSource(this,new InputSource(inputFile.toURI().toString()));
    final Result result=new StreamResult(outputFile.toURI().toString());
    transformer.transform(source,result);
    if (!inputFile.delete()) {
      final Properties prop=new Properties();
      prop.put(""String_Node_Str"",inputFile.getPath());
      prop.put(""String_Node_Str"",outputFile.getPath());
      logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    }
    if (!outputFile.renameTo(inputFile)) {
      final Properties prop=new Properties();
      prop.put(""String_Node_Str"",inputFile.getPath());
      prop.put(""String_Node_Str"",outputFile.getPath());
      logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    }
  }
 catch (  final Exception e) {
    logger.logException(e);
  }
}","public void write(final String filename) throws DITAOTException {
  final File inputFile=new File(filename);
  final File outputFile=new File(filename + FILE_EXTENSION_TEMP);
  InputStream in=null;
  OutputStream out=null;
  try {
    final Transformer transformer=TransformerFactory.newInstance().newTransformer();
    final XMLReader reader=StringUtils.getXMLReader();
    setParent(reader);
    setContentHandler(null);
    in=new BufferedInputStream(new FileInputStream(inputFile));
    out=new BufferedOutputStream(new FileOutputStream(outputFile));
    final Source source=new SAXSource(this,new InputSource(in));
    final Result result=new StreamResult(out);
    transformer.transform(source,result);
  }
 catch (  final Exception e) {
    logger.logException(e);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        logger.logException(e);
      }
    }
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
        logger.logException(e);
      }
    }
  }
  try {
    if (!inputFile.delete()) {
      final Properties prop=new Properties();
      prop.put(""String_Node_Str"",inputFile.getPath());
      prop.put(""String_Node_Str"",outputFile.getPath());
      logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    }
    if (!outputFile.renameTo(inputFile)) {
      final Properties prop=new Properties();
      prop.put(""String_Node_Str"",inputFile.getPath());
      prop.put(""String_Node_Str"",outputFile.getPath());
      logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
    }
  }
 catch (  final Exception e) {
    logger.logException(e);
  }
}",0.7526733356329769
100842,"/** 
 * Write end element.
 * @throws SAXException if processing the event failed
 */
public void writeEndElement() throws SAXException {
  processStartElement();
  final QName qName=elementStack.remove();
  transformer.endElement(qName.uri,qName.localName,qName.prefix);
  for (  NamespaceMapping p : qName.mappings) {
    if (p.newMapping) {
      transformer.endPrefixMapping(p.prefix);
    }
  }
}","/** 
 * Write end element.
 * @throws SAXException if processing the event failed
 */
public void writeEndElement() throws SAXException {
  processStartElement();
  final QName qName=elementStack.remove();
  transformer.endElement(qName.uri,qName.localName,qName.qName);
  for (  NamespaceMapping p : qName.mappings) {
    if (p.newMapping) {
      transformer.endPrefixMapping(p.prefix);
    }
  }
}",0.9862671660424468
100843,"/** 
 * End document.
 * @throws SAXException if processing the event failed
 */
public void writeEndDocument() throws SAXException {
  transformer.endDocument();
}","/** 
 * End document.
 * @throws SAXException if processing the event failed
 */
public void writeEndDocument() throws SAXException {
  while (!elementStack.isEmpty()) {
    writeEndElement();
  }
  transformer.endDocument();
}",0.8286445012787724
100844,"private void processStartElement() throws SAXException {
  if (openStartElement) {
    final QName qName=elementStack.peek();
    if (qName.newMapping) {
      transformer.startPrefixMapping(qName.prefix,qName.uri);
    }
    final Attributes atts=openAttributes != null ? openAttributes : EMPTY_ATTS;
    transformer.startElement(qName.uri,qName.localName,qName.qName,atts);
    openStartElement=false;
    openAttributes=null;
  }
}","private void processStartElement() throws SAXException {
  if (openStartElement) {
    final QName qName=elementStack.getFirst();
    for (    NamespaceMapping p : qName.mappings) {
      if (p.newMapping) {
        transformer.startPrefixMapping(p.prefix,p.uri);
      }
    }
    final Attributes atts=openAttributes != null ? openAttributes : EMPTY_ATTS;
    transformer.startElement(qName.uri,qName.localName,qName.qName,atts);
    openStartElement=false;
    openAttributes=null;
  }
}",0.8593073593073594
100845,"QName(final String uri,final String qName){
  final int i=qName.indexOf(':');
  this.uri=uri != null ? uri : DEFAULT_NS_PREFIX;
  this.localName=i != -1 ? qName.substring(i + 1) : qName;
  this.prefix=i != -1 ? qName.substring(0,i) : DEFAULT_NS_PREFIX;
  this.qName=qName;
}","QName(final String uri,final String qName){
  final int i=qName.indexOf(':');
  this.uri=uri != null ? uri : DEFAULT_NS_PREFIX;
  this.localName=i != -1 ? qName.substring(i + 1) : qName;
  this.prefix=i != -1 ? qName.substring(0,i) : DEFAULT_NS_PREFIX;
  this.qName=qName;
  this.mappings=new ArrayList<NamespaceMapping>(5);
}",0.9133333333333332
100846,"/** 
 * Write characters.
 * @param text character data
 * @throws SAXException if processing the event failed
 */
public void writeCharacters(final String text) throws SAXException {
  processStartElement();
  final char[] ch=text.toCharArray();
  transformer.characters(ch,0,ch.length);
}","/** 
 * Write characters.
 * @param text character data
 * @throws SAXException if processing the event failed
 * @throws IllegalStateException if start element is not open
 */
public void writeCharacters(final char[] ch,final int start,final int length) throws SAXException {
  if (elementStack.isEmpty())   throw new IllegalStateException(""String_Node_Str"");
  processStartElement();
  transformer.characters(ch,0,ch.length);
}",0.631432545201669
100847,"/** 
 * Writer start element without attributes.
 * @param qName element QName
 * @throws SAXException if processing the event failed
 */
public void writeStartElement(final String uri,final String qName) throws SAXException {
  processStartElement();
  final QName res=new QName(uri,qName);
  if (uri != null) {
    boolean found=false;
    for (    final QName e : elementStack) {
      if (e.uri.equals(res.uri) && e.prefix.equals(res.prefix)) {
        found=true;
        break;
      }
    }
    res.newMapping=!found;
  }
  elementStack.push(res);
  openStartElement=true;
}","/** 
 * Write start element without attributes.
 * @param qName element QName
 * @throws SAXException if processing the event failed
 */
public void writeStartElement(final String uri,final String qName) throws SAXException {
  processStartElement();
  final QName res=new QName(uri,qName);
  addNamespace(res.uri,res.prefix,res);
  elementStack.addFirst(res);
  openStartElement=true;
}",0.7293388429752066
100848,"/** 
 * Write end element.
 * @throws SAXException if processing the event failed
 */
public void writeEndElement() throws SAXException {
  processStartElement();
  final QName qName=elementStack.pop();
  transformer.endElement(qName.uri,qName.localName,qName.prefix);
  if (qName.newMapping) {
    transformer.endPrefixMapping(qName.prefix);
  }
}","/** 
 * Write end element.
 * @throws SAXException if processing the event failed
 */
public void writeEndElement() throws SAXException {
  processStartElement();
  final QName qName=elementStack.remove();
  transformer.endElement(qName.uri,qName.localName,qName.prefix);
  for (  NamespaceMapping p : qName.mappings) {
    if (p.newMapping) {
      transformer.endPrefixMapping(p.prefix);
    }
  }
}",0.897196261682243
100849,"/** 
 * Write attribute
 * @param qName attribute name
 * @param atts attribute value
 * @throws SAXException if processing the event failed
 */
public void writeAttribute(final String qName,final String value) throws SAXException {
  if (openAttributes == null) {
    openAttributes=new AttributesImpl();
  }
  openAttributes.addAttribute(""String_Node_Str"",qName,qName,""String_Node_Str"",value);
}","/** 
 * Write attribute
 * @param uri namespace URI
 * @param qName attribute name
 * @param atts attribute value
 * @throws SAXException if processing the event failed
 * @throws IllegalStateException if start element is not open
 */
public void writeAttribute(final String uri,final String qName,final String value) throws SAXException {
  if (!openStartElement)   throw new IllegalStateException(""String_Node_Str"");
  if (openAttributes == null) {
    openAttributes=new AttributesImpl();
  }
  final QName att=new QName(uri,qName);
  addNamespace(uri,att.prefix,elementStack.getFirst());
  openAttributes.addAttribute(uri,att.localName,qName,""String_Node_Str"",value);
}",0.6355140186915887
100850,"/** 
 * Init xml reader used for pipeline parsing.
 * @param ditaDir ditaDir
 * @param validate whether validate input file
 * @param rootFile input file
 * @throws SAXException parsing exception
 */
public void initXMLReader(String ditaDir,boolean validate,String rootFile,boolean arg_setSystemid) throws SAXException {
  rootDir=new File(rootFile).getAbsoluteFile().getParent();
  rootDir=FileUtils.removeRedundantNames(rootDir);
  rootFilePath=new File(rootFile).getAbsolutePath();
  rootFilePath=FileUtils.removeRedundantNames(rootFilePath);
  reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
  if (validate == true) {
    reader.setFeature(FEATURE_VALIDATION,true);
    reader.setFeature(FEATURE_VALIDATION_SCHEMA,true);
  }
 else {
    final String msg=MessageUtils.getMessage(""String_Node_Str"").toString();
    logger.logWarn(msg);
  }
  final XMLGrammarPool grammarPool=GrammarPoolManager.getGrammarPool();
  setGrammarPool(reader,grammarPool);
  CatalogUtils.setDitaDir(ditaDir);
  catalogMap=CatalogUtils.getCatalog(ditaDir);
  setSystemid=arg_setSystemid;
}","/** 
 * Init xml reader used for pipeline parsing.
 * @param ditaDir ditaDir
 * @param validate whether validate input file
 * @param rootFile input file
 * @throws SAXException parsing exception
 */
public void initXMLReader(String ditaDir,boolean validate,String rootFile,boolean arg_setSystemid) throws SAXException {
  rootDir=new File(rootFile).getAbsoluteFile().getParent();
  rootDir=FileUtils.removeRedundantNames(rootDir);
  rootFilePath=new File(rootFile).getAbsolutePath();
  rootFilePath=FileUtils.removeRedundantNames(rootFilePath);
  reader.setFeature(FEATURE_NAMESPACE_PREFIX,true);
  if (validate == true) {
    reader.setFeature(FEATURE_VALIDATION,true);
    reader.setFeature(FEATURE_VALIDATION_SCHEMA,true);
  }
 else {
    final String msg=MessageUtils.getMessage(""String_Node_Str"").toString();
    logger.logWarn(msg);
  }
  final XMLGrammarPool grammarPool=GrammarPoolManager.getGrammarPool();
  setGrammarPool(reader,grammarPool);
  CatalogUtils.setDitaDir(ditaDir);
  catalogMap=CatalogUtils.getCatalog(ditaDir);
  setSystemid=arg_setSystemid;
  try {
    Class.forName(RESOLVER_CLASS);
    reader.setEntityResolver(CatalogUtils.getCatalogResolver());
  }
 catch (  final ClassNotFoundException e) {
    reader.setEntityResolver(this);
  }
}",0.9160239931448158
100851,"/** 
 * Constructor.
 */
public GenListModuleReader(){
  nonConrefCopytoTargets=new HashSet<String>(INT_64);
  hrefTargets=new HashSet<String>(INT_32);
  hrefTopicSet=new HashSet<String>(INT_32);
  chunkTopicSet=new HashSet<String>(INT_32);
  schemeSet=new HashSet<String>(INT_32);
  schemeRefSet=new HashSet<String>(INT_32);
  conrefTargets=new HashSet<String>(INT_32);
  copytoMap=new HashMap<String,String>(INT_16);
  subsidiarySet=new HashSet<String>(INT_16);
  ignoredCopytoSourceSet=new HashSet<String>(INT_16);
  outDitaFilesSet=new HashSet<String>(INT_64);
  keysDefMap=new HashMap<String,String>();
  keysRefMap=new HashMap<String,String>();
  exKeysDefMap=new HashMap<String,String>();
  processRoleLevel=0;
  processRoleStack=new Stack<String>();
  resourceOnlySet=new HashSet<String>(INT_32);
  crossSet=new HashSet<String>(INT_32);
  topicMetaSet=new HashSet<String>(INT_16);
  vaildBranches=new HashMap<String,List<String>>(INT_32);
  level=0;
  topicrefStack=new Stack<String>();
  props=null;
  try {
    reader=StringUtils.getXMLReader();
  }
 catch (  SAXException e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  reader.setContentHandler(this);
  try {
    reader.setProperty(LEXICAL_HANDLER_PROPERTY,this);
  }
 catch (  final SAXNotRecognizedException e1) {
    logger.logException(e1);
  }
catch (  final SAXNotSupportedException e1) {
    logger.logException(e1);
  }
  try {
    Class.forName(RESOLVER_CLASS);
    reader.setEntityResolver(CatalogUtils.getCatalogResolver());
  }
 catch (  final ClassNotFoundException e) {
    reader.setEntityResolver(this);
  }
}","/** 
 * Constructor.
 */
public GenListModuleReader(){
  nonConrefCopytoTargets=new HashSet<String>(INT_64);
  hrefTargets=new HashSet<String>(INT_32);
  hrefTopicSet=new HashSet<String>(INT_32);
  chunkTopicSet=new HashSet<String>(INT_32);
  schemeSet=new HashSet<String>(INT_32);
  schemeRefSet=new HashSet<String>(INT_32);
  conrefTargets=new HashSet<String>(INT_32);
  copytoMap=new HashMap<String,String>(INT_16);
  subsidiarySet=new HashSet<String>(INT_16);
  ignoredCopytoSourceSet=new HashSet<String>(INT_16);
  outDitaFilesSet=new HashSet<String>(INT_64);
  keysDefMap=new HashMap<String,String>();
  keysRefMap=new HashMap<String,String>();
  exKeysDefMap=new HashMap<String,String>();
  processRoleLevel=0;
  processRoleStack=new Stack<String>();
  resourceOnlySet=new HashSet<String>(INT_32);
  crossSet=new HashSet<String>(INT_32);
  topicMetaSet=new HashSet<String>(INT_16);
  vaildBranches=new HashMap<String,List<String>>(INT_32);
  level=0;
  topicrefStack=new Stack<String>();
  props=null;
  try {
    reader=StringUtils.getXMLReader();
  }
 catch (  SAXException e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  reader.setContentHandler(this);
  try {
    reader.setProperty(LEXICAL_HANDLER_PROPERTY,this);
  }
 catch (  final SAXNotRecognizedException e1) {
    logger.logException(e1);
  }
catch (  final SAXNotSupportedException e1) {
    logger.logException(e1);
  }
}",0.9356110381077528
100852,"private void processChunk(Element element,String outputFile){
  String hrefValue=element.getAttribute(ATTRIBUTE_NAME_HREF);
  String chunkValue=element.getAttribute(ATTRIBUTE_NAME_CHUNK);
  String copytoValue=element.getAttribute(ATTRIBUTE_NAME_COPY_TO);
  String scopeValue=element.getAttribute(ATTRIBUTE_NAME_SCOPE);
  String classValue=element.getAttribute(ATTRIBUTE_NAME_CLASS);
  String processRoleValue=element.getAttribute(ATTRIBUTE_NAME_PROCESSING_ROLE);
  String id=element.getAttribute(ATTRIBUTE_NAME_ID);
  String navtitle=element.getAttribute(ATTRIBUTE_NAME_NAVTITLE);
  String parseFilePath=null;
  String outputFileName=outputFile;
  Writer tempWriter=new StringWriter();
  Set<String> tempTopicID=new HashSet<String>();
  targetTopicId=null;
  selectMethod=""String_Node_Str"";
  include=false;
  boolean needWriteDitaTag=true;
  try {
    if (copytoValue.length() != 0 && !chunkValue.contains(""String_Node_Str"")) {
      if (hrefValue.indexOf(SHARP) != -1) {
        parseFilePath=copytoValue + hrefValue.substring(hrefValue.indexOf(SHARP));
      }
 else {
        parseFilePath=copytoValue;
      }
    }
 else {
      parseFilePath=hrefValue;
    }
    if (copytoValue.length() != 0 && chunkValue.contains(""String_Node_Str"") && !hrefValue.length() == 0) {
      copyto.add(copytoValue);
      if (hrefValue.indexOf(SHARP) != -1) {
        copytoSource.add(hrefValue.substring(0,hrefValue.indexOf(SHARP)));
        copytotarget2source.put(copytoValue,hrefValue.substring(0,hrefValue.indexOf(SHARP)));
      }
 else {
        copytoSource.add(hrefValue);
        copytotarget2source.put(copytoValue,hrefValue);
      }
    }
    if (!StringUtils.isEmptyString(classValue)) {
      if ((!classValue.contains(ATTR_CLASS_VALUE_TOPIC_GROUP)) && (!StringUtils.isEmptyString(parseFilePath)) && (!""String_Node_Str"".equalsIgnoreCase(scopeValue))) {
        if (chunkValue.indexOf(""String_Node_Str"") != -1) {
          tempWriter=output;
          tempTopicID=topicID;
          output=new StringWriter();
          topicID=new HashSet<String>();
          if (classValue.contains(ATTR_CLASS_VALUE_MAP)) {
            outputFileName=FileUtils.resolveFile(filePath,parseFilePath);
            needWriteDitaTag=false;
          }
 else           if (copytoValue.length() != 0) {
            outputFileName=FileUtils.resolveFile(filePath,copytoValue);
          }
 else           if (hrefValue.length() != 0) {
            if (chunkValue.contains(""String_Node_Str"") || chunkValue.contains(""String_Node_Str"")) {
              if (hrefValue.contains(SHARP) && hrefValue.indexOf(SHARP) < hrefValue.length() - 1) {
                outputFileName=FileUtils.resolveFile(filePath,hrefValue.substring(hrefValue.indexOf(SHARP) + 1)) + ditaext;
              }
 else {
                String firstTopic=this.getFirstTopicId(FileUtils.resolveFile(filePath,hrefValue));
                if (!StringUtils.isEmptyString(firstTopic)) {
                  outputFileName=FileUtils.resolveFile(filePath,firstTopic) + ditaext;
                }
 else {
                  outputFileName=FileUtils.resolveFile(filePath,hrefValue);
                }
              }
            }
 else {
              outputFileName=FileUtils.resolveFile(filePath,hrefValue);
            }
          }
 else {
            Random random=new Random();
            outputFileName=FileUtils.resolveFile(filePath,""String_Node_Str"" + random.nextInt(Integer.MAX_VALUE)) + ditaext;
          }
          if (FileUtils.fileExists(outputFileName) && !classValue.contains(ATTR_CLASS_VALUE_MAP)) {
            String t=outputFileName;
            Random random=new Random();
            outputFileName=FileUtils.resolveFile(filePath,""String_Node_Str"" + random.nextInt(Integer.MAX_VALUE)) + ditaext;
            conflictTable.put(outputFileName,t);
          }
          changeTable.put(outputFileName,outputFileName);
        }
        this.outputFile=outputFileName;
{
          String path=FileUtils.resolveTopic(filePath,parseFilePath);
          String newpath=null;
          if (path.indexOf(SHARP) != -1) {
            newpath=outputFileName + path.substring(path.indexOf(SHARP));
          }
 else {
            String firstTopicID=this.getFirstTopicId(path);
            if (!StringUtils.isEmptyString(firstTopicID)) {
              newpath=outputFileName + ""String_Node_Str"" + firstTopicID;
            }
 else {
              newpath=outputFileName;
            }
          }
          changeTable.put(path,newpath);
          element.setAttribute(ATTRIBUTE_NAME_HREF,FileUtils.getRelativePathFromMap(filePath + SLASH + ""String_Node_Str"",newpath));
        }
        if (parseFilePath.indexOf(SHARP) != -1) {
          targetTopicId=parseFilePath.substring(parseFilePath.indexOf(SHARP) + 1);
        }
        if (chunkValue.indexOf(""String_Node_Str"") != -1) {
          int endIndex=chunkValue.indexOf(STRING_BLANK,chunkValue.indexOf(""String_Node_Str""));
          if (endIndex == -1) {
            selectMethod=chunkValue.substring(chunkValue.indexOf(""String_Node_Str""));
          }
 else {
            selectMethod=chunkValue.substring(chunkValue.indexOf(""String_Node_Str""),endIndex);
          }
          if (""String_Node_Str"".equals(selectMethod) || ""String_Node_Str"".equals(selectMethod)) {
            if (targetTopicId == null) {
              selectMethod=""String_Node_Str"";
            }
          }
        }
        String tempPath=currentParsingFile;
        currentParsingFile=FileUtils.resolveFile(filePath,parseFilePath);
        if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processRoleValue)) {
          currentParsingFileTopicIDChangeTable=new HashMap<String,String>();
          reader.parse(currentParsingFile);
          if (currentParsingFileTopicIDChangeTable.size() > 0) {
            String href=element.getAttribute(ATTRIBUTE_NAME_HREF);
            href=href.replaceAll(DOUBLE_BACK_SLASH,SLASH);
            String pathtoElem=href.contains(SHARP) ? href.substring(href.indexOf(SHARP) + 1) : ""String_Node_Str"";
            String old_elementid=pathtoElem.contains(SLASH) ? pathtoElem.substring(0,pathtoElem.indexOf(SLASH)) : pathtoElem;
            if (old_elementid.length() > 0) {
              String new_elementid=currentParsingFileTopicIDChangeTable.get(old_elementid);
              if (new_elementid != null && new_elementid.length() > 0) {
                href=href.replaceFirst(SHARP + old_elementid,SHARP + new_elementid);
                element.setAttribute(ATTRIBUTE_NAME_HREF,href);
              }
            }
          }
          currentParsingFileTopicIDChangeTable=null;
        }
        currentParsingFile=tempPath;
      }
      if (outputFileName == null) {
        if (!StringUtils.isEmptyString(copytoValue)) {
          outputFileName=FileUtils.resolveFile(filePath,copytoValue);
        }
 else         if (!StringUtils.isEmptyString(id)) {
          outputFileName=FileUtils.resolveFile(filePath,id + ditaext);
        }
 else {
          Random random=new Random();
          outputFileName=FileUtils.resolveFile(filePath,""String_Node_Str"" + random.nextInt(Integer.MAX_VALUE)) + ditaext;
          if (FileUtils.fileExists(outputFileName) && !classValue.contains(ATTR_CLASS_VALUE_MAP)) {
            String t=outputFileName;
            outputFileName=FileUtils.resolveFile(filePath,""String_Node_Str"" + random.nextInt(Integer.MAX_VALUE)) + ditaext;
            conflictTable.put(outputFileName,t);
          }
        }
        if (element.hasChildNodes() || !StringUtils.isEmptyString(navtitle)) {
          DITAAttrUtils utils=DITAAttrUtils.getInstance();
          String navtitleValue=null;
          String shortDescValue=null;
          navtitleValue=utils.getChildElementValueOfTopicmeta(element,ATTR_CLASS_VALUE_NAVTITLE);
          shortDescValue=utils.getChildElementValueOfTopicmeta(element,ATTR_CLASS_VALUE_MAP_SHORTDESC);
          if (navtitleValue == null) {
            navtitleValue=navtitle;
          }
          changeTable.put(outputFileName,outputFileName);
          if (!StringUtils.isEmptyString(navtitleValue)) {
            element.setAttribute(ATTRIBUTE_NAME_HREF,FileUtils.getRelativePathFromMap(filePath + SLASH + ""String_Node_Str"",outputFileName));
            StringBuffer buffer=new StringBuffer();
            buffer.append(""String_Node_Str"").append(""String_Node_Str"").append(navtitleValue).append(""String_Node_Str"");
            if (shortDescValue != null) {
              buffer.append(""String_Node_Str"").append(shortDescValue).append(""String_Node_Str"");
            }
            buffer.append(""String_Node_Str"");
            StringReader rder=new StringReader(buffer.toString());
            InputSource source=new InputSource(rder);
            String tempPath=currentParsingFile;
            currentParsingFile=outputFileName;
            parseFilePath=outputFileName;
            reader.parse(source);
            currentParsingFile=tempPath;
          }
        }
      }
      if (element.hasChildNodes()) {
        StringWriter temp=(StringWriter)output;
        output=new StringWriter();
        NodeList children=element.getChildNodes();
        for (int i=0; i < children.getLength(); i++) {
          Node current=children.item(i);
          if (current.getNodeType() == Node.ELEMENT_NODE && ((Element)current).getAttribute(ATTRIBUTE_NAME_CLASS).indexOf(ATTR_CLASS_VALUE_TOPICREF) != -1) {
            processChunk((Element)current,outputFileName);
          }
        }
        StringBuffer parentResult=temp.getBuffer();
        if (parentResult.length() > 0 && !StringUtils.isEmptyString(parseFilePath) && !ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processRoleValue)) {
          int insertpoint=parentResult.lastIndexOf(""String_Node_Str"");
          int end=parentResult.indexOf(""String_Node_Str"",insertpoint);
          if (insertpoint == -1 || end == -1) {
            Properties prop=new Properties();
            prop.put(""String_Node_Str"",hrefValue);
            logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
          }
 else {
            if (ELEMENT_NAME_DITA.equalsIgnoreCase(parentResult.substring(insertpoint,end).trim())) {
              insertpoint=parentResult.lastIndexOf(""String_Node_Str"",insertpoint);
            }
            parentResult.insert(insertpoint,((StringWriter)output).getBuffer());
          }
        }
 else {
          parentResult.append(((StringWriter)output).getBuffer());
        }
        output=temp;
      }
      if (chunkValue.indexOf(""String_Node_Str"") != -1) {
        FileOutputStream fileOutput=new FileOutputStream(outputFileName);
        OutputStreamWriter ditaFileOutput=null;
        try {
          ditaFileOutput=new OutputStreamWriter(fileOutput,UTF8);
          if (outputFileName.equals(changeTable.get(outputFileName))) {
            ditaFileOutput.write(XML_HEAD);
            if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
              ditaFileOutput.write(PI_WORKDIR_HEAD + new File(outputFileName).getParent() + PI_END);
            }
 else {
              ditaFileOutput.write(PI_WORKDIR_HEAD + SLASH + new File(outputFileName).getParent()+ PI_END);
            }
            if ((conflictTable.get(outputFileName) != null)) {
              String relativePath=FileUtils.getRelativePathFromMap(filePath + SLASH + ""String_Node_Str"",conflictTable.get(outputFileName));
              String path2project=FileUtils.getPathtoProject(relativePath);
              if (null == path2project) {
                path2project=""String_Node_Str"";
              }
              ditaFileOutput.write(""String_Node_Str"" + path2project + ""String_Node_Str"");
            }
          }
          if (needWriteDitaTag)           ditaFileOutput.write(""String_Node_Str"");
          ditaFileOutput.write(((StringWriter)output).getBuffer().toString());
          if (needWriteDitaTag)           ditaFileOutput.write(""String_Node_Str"");
          ditaFileOutput.flush();
        }
  finally {
          ditaFileOutput.close();
        }
        output=tempWriter;
        topicID=tempTopicID;
      }
    }
  }
 catch (  Exception e) {
    logger.logException(e);
  }
}","private void processChunk(Element element,String outputFile){
  String hrefValue=element.getAttribute(ATTRIBUTE_NAME_HREF);
  String chunkValue=element.getAttribute(ATTRIBUTE_NAME_CHUNK);
  String copytoValue=element.getAttribute(ATTRIBUTE_NAME_COPY_TO);
  String scopeValue=element.getAttribute(ATTRIBUTE_NAME_SCOPE);
  String classValue=element.getAttribute(ATTRIBUTE_NAME_CLASS);
  String processRoleValue=element.getAttribute(ATTRIBUTE_NAME_PROCESSING_ROLE);
  String id=element.getAttribute(ATTRIBUTE_NAME_ID);
  String navtitle=element.getAttribute(ATTRIBUTE_NAME_NAVTITLE);
  String parseFilePath=null;
  String outputFileName=outputFile;
  Writer tempWriter=new StringWriter();
  Set<String> tempTopicID=new HashSet<String>();
  targetTopicId=null;
  selectMethod=""String_Node_Str"";
  include=false;
  boolean needWriteDitaTag=true;
  try {
    if (copytoValue.length() != 0 && !chunkValue.contains(""String_Node_Str"")) {
      if (hrefValue.indexOf(SHARP) != -1) {
        parseFilePath=copytoValue + hrefValue.substring(hrefValue.indexOf(SHARP));
      }
 else {
        parseFilePath=copytoValue;
      }
    }
 else {
      parseFilePath=hrefValue;
    }
    if (copytoValue.length() != 0 && chunkValue.contains(""String_Node_Str"") && hrefValue.length() != 0) {
      copyto.add(copytoValue);
      if (hrefValue.indexOf(SHARP) != -1) {
        copytoSource.add(hrefValue.substring(0,hrefValue.indexOf(SHARP)));
        copytotarget2source.put(copytoValue,hrefValue.substring(0,hrefValue.indexOf(SHARP)));
      }
 else {
        copytoSource.add(hrefValue);
        copytotarget2source.put(copytoValue,hrefValue);
      }
    }
    if (!StringUtils.isEmptyString(classValue)) {
      if ((!classValue.contains(ATTR_CLASS_VALUE_TOPIC_GROUP)) && (!StringUtils.isEmptyString(parseFilePath)) && (!""String_Node_Str"".equalsIgnoreCase(scopeValue))) {
        if (chunkValue.indexOf(""String_Node_Str"") != -1) {
          tempWriter=output;
          tempTopicID=topicID;
          output=new StringWriter();
          topicID=new HashSet<String>();
          if (classValue.contains(ATTR_CLASS_VALUE_MAP)) {
            outputFileName=FileUtils.resolveFile(filePath,parseFilePath);
            needWriteDitaTag=false;
          }
 else           if (copytoValue.length() != 0) {
            outputFileName=FileUtils.resolveFile(filePath,copytoValue);
          }
 else           if (hrefValue.length() != 0) {
            if (chunkValue.contains(""String_Node_Str"") || chunkValue.contains(""String_Node_Str"")) {
              if (hrefValue.contains(SHARP) && hrefValue.indexOf(SHARP) < hrefValue.length() - 1) {
                outputFileName=FileUtils.resolveFile(filePath,hrefValue.substring(hrefValue.indexOf(SHARP) + 1)) + ditaext;
              }
 else {
                String firstTopic=this.getFirstTopicId(FileUtils.resolveFile(filePath,hrefValue));
                if (!StringUtils.isEmptyString(firstTopic)) {
                  outputFileName=FileUtils.resolveFile(filePath,firstTopic) + ditaext;
                }
 else {
                  outputFileName=FileUtils.resolveFile(filePath,hrefValue);
                }
              }
            }
 else {
              outputFileName=FileUtils.resolveFile(filePath,hrefValue);
            }
          }
 else {
            Random random=new Random();
            outputFileName=FileUtils.resolveFile(filePath,""String_Node_Str"" + random.nextInt(Integer.MAX_VALUE)) + ditaext;
          }
          if (FileUtils.fileExists(outputFileName) && !classValue.contains(ATTR_CLASS_VALUE_MAP)) {
            String t=outputFileName;
            Random random=new Random();
            outputFileName=FileUtils.resolveFile(filePath,""String_Node_Str"" + random.nextInt(Integer.MAX_VALUE)) + ditaext;
            conflictTable.put(outputFileName,t);
          }
          changeTable.put(outputFileName,outputFileName);
        }
        this.outputFile=outputFileName;
{
          String path=FileUtils.resolveTopic(filePath,parseFilePath);
          String newpath=null;
          if (path.indexOf(SHARP) != -1) {
            newpath=outputFileName + path.substring(path.indexOf(SHARP));
          }
 else {
            String firstTopicID=this.getFirstTopicId(path);
            if (!StringUtils.isEmptyString(firstTopicID)) {
              newpath=outputFileName + ""String_Node_Str"" + firstTopicID;
            }
 else {
              newpath=outputFileName;
            }
          }
          changeTable.put(path,newpath);
          element.setAttribute(ATTRIBUTE_NAME_HREF,FileUtils.getRelativePathFromMap(filePath + SLASH + ""String_Node_Str"",newpath));
        }
        if (parseFilePath.indexOf(SHARP) != -1) {
          targetTopicId=parseFilePath.substring(parseFilePath.indexOf(SHARP) + 1);
        }
        if (chunkValue.indexOf(""String_Node_Str"") != -1) {
          int endIndex=chunkValue.indexOf(STRING_BLANK,chunkValue.indexOf(""String_Node_Str""));
          if (endIndex == -1) {
            selectMethod=chunkValue.substring(chunkValue.indexOf(""String_Node_Str""));
          }
 else {
            selectMethod=chunkValue.substring(chunkValue.indexOf(""String_Node_Str""),endIndex);
          }
          if (""String_Node_Str"".equals(selectMethod) || ""String_Node_Str"".equals(selectMethod)) {
            if (targetTopicId == null) {
              selectMethod=""String_Node_Str"";
            }
          }
        }
        String tempPath=currentParsingFile;
        currentParsingFile=FileUtils.resolveFile(filePath,parseFilePath);
        if (!ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processRoleValue)) {
          currentParsingFileTopicIDChangeTable=new HashMap<String,String>();
          reader.parse(currentParsingFile);
          if (currentParsingFileTopicIDChangeTable.size() > 0) {
            String href=element.getAttribute(ATTRIBUTE_NAME_HREF);
            href=href.replaceAll(DOUBLE_BACK_SLASH,SLASH);
            String pathtoElem=href.contains(SHARP) ? href.substring(href.indexOf(SHARP) + 1) : ""String_Node_Str"";
            String old_elementid=pathtoElem.contains(SLASH) ? pathtoElem.substring(0,pathtoElem.indexOf(SLASH)) : pathtoElem;
            if (old_elementid.length() > 0) {
              String new_elementid=currentParsingFileTopicIDChangeTable.get(old_elementid);
              if (new_elementid != null && new_elementid.length() > 0) {
                href=href.replaceFirst(SHARP + old_elementid,SHARP + new_elementid);
                element.setAttribute(ATTRIBUTE_NAME_HREF,href);
              }
            }
          }
          currentParsingFileTopicIDChangeTable=null;
        }
        currentParsingFile=tempPath;
      }
      if (outputFileName == null) {
        if (!StringUtils.isEmptyString(copytoValue)) {
          outputFileName=FileUtils.resolveFile(filePath,copytoValue);
        }
 else         if (!StringUtils.isEmptyString(id)) {
          outputFileName=FileUtils.resolveFile(filePath,id + ditaext);
        }
 else {
          Random random=new Random();
          outputFileName=FileUtils.resolveFile(filePath,""String_Node_Str"" + random.nextInt(Integer.MAX_VALUE)) + ditaext;
          if (FileUtils.fileExists(outputFileName) && !classValue.contains(ATTR_CLASS_VALUE_MAP)) {
            String t=outputFileName;
            outputFileName=FileUtils.resolveFile(filePath,""String_Node_Str"" + random.nextInt(Integer.MAX_VALUE)) + ditaext;
            conflictTable.put(outputFileName,t);
          }
        }
        if (element.hasChildNodes() || !StringUtils.isEmptyString(navtitle)) {
          DITAAttrUtils utils=DITAAttrUtils.getInstance();
          String navtitleValue=null;
          String shortDescValue=null;
          navtitleValue=utils.getChildElementValueOfTopicmeta(element,ATTR_CLASS_VALUE_NAVTITLE);
          shortDescValue=utils.getChildElementValueOfTopicmeta(element,ATTR_CLASS_VALUE_MAP_SHORTDESC);
          if (navtitleValue == null) {
            navtitleValue=navtitle;
          }
          changeTable.put(outputFileName,outputFileName);
          if (!StringUtils.isEmptyString(navtitleValue)) {
            element.setAttribute(ATTRIBUTE_NAME_HREF,FileUtils.getRelativePathFromMap(filePath + SLASH + ""String_Node_Str"",outputFileName));
            StringBuffer buffer=new StringBuffer();
            buffer.append(""String_Node_Str"").append(""String_Node_Str"").append(navtitleValue).append(""String_Node_Str"");
            if (shortDescValue != null) {
              buffer.append(""String_Node_Str"").append(shortDescValue).append(""String_Node_Str"");
            }
            buffer.append(""String_Node_Str"");
            StringReader rder=new StringReader(buffer.toString());
            InputSource source=new InputSource(rder);
            String tempPath=currentParsingFile;
            currentParsingFile=outputFileName;
            parseFilePath=outputFileName;
            reader.parse(source);
            currentParsingFile=tempPath;
          }
        }
      }
      if (element.hasChildNodes()) {
        StringWriter temp=(StringWriter)output;
        output=new StringWriter();
        NodeList children=element.getChildNodes();
        for (int i=0; i < children.getLength(); i++) {
          Node current=children.item(i);
          if (current.getNodeType() == Node.ELEMENT_NODE && ((Element)current).getAttribute(ATTRIBUTE_NAME_CLASS).indexOf(ATTR_CLASS_VALUE_TOPICREF) != -1) {
            processChunk((Element)current,outputFileName);
          }
        }
        StringBuffer parentResult=temp.getBuffer();
        if (parentResult.length() > 0 && !StringUtils.isEmptyString(parseFilePath) && !ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equalsIgnoreCase(processRoleValue)) {
          int insertpoint=parentResult.lastIndexOf(""String_Node_Str"");
          int end=parentResult.indexOf(""String_Node_Str"",insertpoint);
          if (insertpoint == -1 || end == -1) {
            Properties prop=new Properties();
            prop.put(""String_Node_Str"",hrefValue);
            logger.logError(MessageUtils.getMessage(""String_Node_Str"",prop).toString());
          }
 else {
            if (ELEMENT_NAME_DITA.equalsIgnoreCase(parentResult.substring(insertpoint,end).trim())) {
              insertpoint=parentResult.lastIndexOf(""String_Node_Str"",insertpoint);
            }
            parentResult.insert(insertpoint,((StringWriter)output).getBuffer());
          }
        }
 else {
          parentResult.append(((StringWriter)output).getBuffer());
        }
        output=temp;
      }
      if (chunkValue.indexOf(""String_Node_Str"") != -1) {
        FileOutputStream fileOutput=new FileOutputStream(outputFileName);
        OutputStreamWriter ditaFileOutput=null;
        try {
          ditaFileOutput=new OutputStreamWriter(fileOutput,UTF8);
          if (outputFileName.equals(changeTable.get(outputFileName))) {
            ditaFileOutput.write(XML_HEAD);
            if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
              ditaFileOutput.write(PI_WORKDIR_HEAD + new File(outputFileName).getParent() + PI_END);
            }
 else {
              ditaFileOutput.write(PI_WORKDIR_HEAD + SLASH + new File(outputFileName).getParent()+ PI_END);
            }
            if ((conflictTable.get(outputFileName) != null)) {
              String relativePath=FileUtils.getRelativePathFromMap(filePath + SLASH + ""String_Node_Str"",conflictTable.get(outputFileName));
              String path2project=FileUtils.getPathtoProject(relativePath);
              if (null == path2project) {
                path2project=""String_Node_Str"";
              }
              ditaFileOutput.write(""String_Node_Str"" + path2project + ""String_Node_Str"");
            }
          }
          if (needWriteDitaTag)           ditaFileOutput.write(""String_Node_Str"");
          ditaFileOutput.write(((StringWriter)output).getBuffer().toString());
          if (needWriteDitaTag)           ditaFileOutput.write(""String_Node_Str"");
          ditaFileOutput.flush();
        }
  finally {
          ditaFileOutput.close();
        }
        output=tempWriter;
        topicID=tempTopicID;
      }
    }
  }
 catch (  Exception e) {
    logger.logException(e);
  }
}",0.9983964475144936
100853,"/** 
 * execution point of this invoker.
 * @throws BuildException Exception
 */
public void execute() throws BuildException {
  pipeline.setLogger(new DITAOTAntLogger(getProject()));
  try {
    pipeline.execute(pipelineInput.getAttribute(""String_Node_Str""),pipelineInput);
  }
 catch (  DITAOTException e) {
    throw new BuildException(e.getMessage(),e);
  }
}","/** 
 * execution point of this invoker.
 * @throws BuildException Exception
 */
public void execute() throws BuildException {
  pipeline.setLogger(new DITAOTJavaLogger());
  try {
    pipeline.execute(pipelineInput.getAttribute(""String_Node_Str""),pipelineInput);
  }
 catch (  DITAOTException e) {
    throw new BuildException(e.getMessage(),e);
  }
}",0.9734265734265736
100854,"/** 
 * @see org.dita.dost.module.AbstractPipelineModule#execute(org.dita.dost.pipeline.AbstractPipelineInput)
 */
public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  if (logger == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final Date executeStartTime=TimingUtils.getNowTime();
  final String msg=""String_Node_Str"";
  fileLogger.logInfo(msg);
  try {
    final String baseDir=input.getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
    String ditavalFile=input.getAttribute(Constants.ANT_INVOKER_PARAM_DITAVAL);
    tempDir=input.getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
    final String ext=input.getAttribute(Constants.ANT_INVOKER_PARAM_DITAEXT);
    ditaDir=input.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_DITADIR);
    final String transtype=input.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_TRANSTYPE);
    final String setSystemid_tmp=input.getAttribute(Constants.ANT_INVOKER_EXT_PARAN_SETSYSTEMID);
    if (setSystemid_tmp.equals(""String_Node_Str"")) {
      setSystemid=true;
    }
 else {
      setSystemid=false;
    }
    DitaValReader.initXMLReader(setSystemid);
    inputDir=null;
    extName=ext.startsWith(Constants.DOT) ? ext : (Constants.DOT + ext);
    if (!new File(tempDir).isAbsolute()) {
      tempDir=new File(baseDir,tempDir).getAbsolutePath();
    }
    if (ditavalFile != null && !new File(ditavalFile).isAbsolute()) {
      ditavalFile=new File(baseDir,ditavalFile).getAbsolutePath();
    }
    final ListReader listReader=new ListReader();
    listReader.setLogger(logger);
    listReader.read(null);
    final LinkedList<String> parseList=(LinkedList<String>)listReader.getContent().getCollection();
    inputDir=(String)listReader.getContent().getValue();
    inputMap=new File(inputDir + File.separator + listReader.getInputMap()).getAbsolutePath();
    this.outputSubjectScheme();
    if (!new File(inputDir).isAbsolute()) {
      inputDir=new File(baseDir,inputDir).getAbsolutePath();
    }
    final DitaValReader filterReader=new DitaValReader();
    Content content;
    if (ditavalFile != null) {
      filterReader.read(ditavalFile);
      content=filterReader.getContent();
      FilterUtils.setFilterMap(filterReader.getFilterMap());
    }
 else {
      content=new ContentImpl();
    }
    final DitaWriter fileWriter=new DitaWriter();
    fileWriter.setLogger(fileLogger);
    try {
      final boolean xmlValidate=Boolean.valueOf(input.getAttribute(""String_Node_Str""));
      fileWriter.initXMLReader(ditaDir,xmlValidate,setSystemid);
    }
 catch (    final SAXException e) {
      throw new DITAOTException(e.getMessage(),e);
    }
    content.setValue(tempDir);
    fileWriter.setContent(content);
    fileWriter.setExtName(extName);
    fileWriter.setTranstype(transtype);
    String filePathPrefix=null;
    if (inputDir != null) {
      filePathPrefix=inputDir + Constants.STICK;
    }
    final Map<String,Set<String>> dic=readMapFromXML(Constants.FILE_NAME_SUBJECT_DICTIONARY);
    while (!parseList.isEmpty()) {
      final String filename=parseList.removeLast();
      final String message=""String_Node_Str"" + filename + ""String_Node_Str"";
      fileLogger.logInfo(message);
      final Set<String> schemaSet=dic.get(filename);
      filterReader.reset();
      if (schemaSet != null) {
        final Iterator<String> iter=schemaSet.iterator();
        while (iter.hasNext()) {
          filterReader.loadSubjectScheme(FileUtils.resolveFile(DebugAndFilterModule.tempDir,iter.next()) + ""String_Node_Str"");
        }
        if (ditavalFile != null) {
          filterReader.filterReset();
          filterReader.read(ditavalFile);
          FilterUtils.setFilterMap(filterReader.getFilterMap());
        }
 else {
          FilterUtils.setFilterMap(null);
        }
        fileWriter.setValidateMap(filterReader.getValidValuesMap());
        fileWriter.setDefaultValueMap(filterReader.getDefaultValueMap());
      }
 else {
        if (ditavalFile != null) {
          FilterUtils.setFilterMap(filterReader.getFilterMap());
        }
 else {
          FilterUtils.setFilterMap(null);
        }
      }
      if (!new File(inputDir,filename).exists()) {
        System.out.println(""String_Node_Str"");
        continue;
      }
      fileWriter.write(new StringBuffer().append(filePathPrefix).append(filename).toString());
    }
    updateList(tempDir);
    updateDictionary(tempDir);
    final File xmlListFile=new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML);
    if (xmlListFile.exists()) {
      listReader.read(xmlListFile.getAbsolutePath());
    }
 else {
      listReader.read(new File(tempDir,Constants.FILE_NAME_DITA_LIST).getAbsolutePath());
    }
    performCopytoTask(tempDir,listReader.getCopytoMap());
  }
 catch (  final Exception e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    fileLogger.logInfo(""String_Node_Str"" + TimingUtils.reportElapsedTime(executeStartTime));
  }
  return null;
}","/** 
 * @see org.dita.dost.module.AbstractPipelineModule#execute(org.dita.dost.pipeline.AbstractPipelineInput)
 */
public AbstractPipelineOutput execute(final AbstractPipelineInput input) throws DITAOTException {
  if (logger == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final Date executeStartTime=TimingUtils.getNowTime();
  final String msg=""String_Node_Str"";
  fileLogger.logInfo(msg);
  try {
    final String baseDir=input.getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
    String ditavalFile=input.getAttribute(Constants.ANT_INVOKER_PARAM_DITAVAL);
    tempDir=input.getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
    final String ext=input.getAttribute(Constants.ANT_INVOKER_PARAM_DITAEXT);
    ditaDir=input.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_DITADIR);
    final String transtype=input.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_TRANSTYPE);
    final String setSystemid_tmp=input.getAttribute(Constants.ANT_INVOKER_EXT_PARAN_SETSYSTEMID);
    if (setSystemid_tmp.equals(""String_Node_Str"")) {
      setSystemid=true;
    }
 else {
      setSystemid=false;
    }
    DitaValReader.initXMLReader(setSystemid);
    inputDir=null;
    extName=ext.startsWith(Constants.DOT) ? ext : (Constants.DOT + ext);
    if (!new File(tempDir).isAbsolute()) {
      tempDir=new File(baseDir,tempDir).getAbsolutePath();
    }
    if (ditavalFile != null && !new File(ditavalFile).isAbsolute()) {
      ditavalFile=new File(baseDir,ditavalFile).getAbsolutePath();
    }
    final ListReader listReader=new ListReader();
    listReader.setLogger(logger);
    listReader.read(null);
    final LinkedList<String> parseList=(LinkedList<String>)listReader.getContent().getCollection();
    inputDir=(String)listReader.getContent().getValue();
    inputMap=new File(inputDir + File.separator + listReader.getInputMap()).getAbsolutePath();
    this.outputSubjectScheme();
    if (!new File(inputDir).isAbsolute()) {
      inputDir=new File(baseDir,inputDir).getAbsolutePath();
    }
    final DitaValReader filterReader=new DitaValReader();
    Content content;
    if (ditavalFile != null) {
      filterReader.read(ditavalFile);
      content=filterReader.getContent();
      FilterUtils.setFilterMap(filterReader.getFilterMap());
    }
 else {
      content=new ContentImpl();
    }
    final DitaWriter fileWriter=new DitaWriter();
    fileWriter.setLogger(logger);
    try {
      final boolean xmlValidate=Boolean.valueOf(input.getAttribute(""String_Node_Str""));
      fileWriter.initXMLReader(ditaDir,xmlValidate,setSystemid);
    }
 catch (    final SAXException e) {
      throw new DITAOTException(e.getMessage(),e);
    }
    content.setValue(tempDir);
    fileWriter.setContent(content);
    fileWriter.setExtName(extName);
    fileWriter.setTranstype(transtype);
    String filePathPrefix=null;
    if (inputDir != null) {
      filePathPrefix=inputDir + Constants.STICK;
    }
    final Map<String,Set<String>> dic=readMapFromXML(Constants.FILE_NAME_SUBJECT_DICTIONARY);
    while (!parseList.isEmpty()) {
      final String filename=parseList.removeLast();
      final String message=""String_Node_Str"" + filename + ""String_Node_Str"";
      fileLogger.logInfo(message);
      final Set<String> schemaSet=dic.get(filename);
      filterReader.reset();
      if (schemaSet != null) {
        final Iterator<String> iter=schemaSet.iterator();
        while (iter.hasNext()) {
          filterReader.loadSubjectScheme(FileUtils.resolveFile(DebugAndFilterModule.tempDir,iter.next()) + ""String_Node_Str"");
        }
        if (ditavalFile != null) {
          filterReader.filterReset();
          filterReader.read(ditavalFile);
          FilterUtils.setFilterMap(filterReader.getFilterMap());
        }
 else {
          FilterUtils.setFilterMap(null);
        }
        fileWriter.setValidateMap(filterReader.getValidValuesMap());
        fileWriter.setDefaultValueMap(filterReader.getDefaultValueMap());
      }
 else {
        if (ditavalFile != null) {
          FilterUtils.setFilterMap(filterReader.getFilterMap());
        }
 else {
          FilterUtils.setFilterMap(null);
        }
      }
      if (!new File(inputDir,filename).exists()) {
        System.out.println(""String_Node_Str"");
        continue;
      }
      fileWriter.write(new StringBuffer().append(filePathPrefix).append(filename).toString());
    }
    updateList(tempDir);
    updateDictionary(tempDir);
    final File xmlListFile=new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML);
    if (xmlListFile.exists()) {
      listReader.read(xmlListFile.getAbsolutePath());
    }
 else {
      listReader.read(new File(tempDir,Constants.FILE_NAME_DITA_LIST).getAbsolutePath());
    }
    performCopytoTask(tempDir,listReader.getCopytoMap());
  }
 catch (  final Exception e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    fileLogger.logInfo(""String_Node_Str"" + TimingUtils.reportElapsedTime(executeStartTime));
  }
  return null;
}",0.9993985565356855
100855,"/** 
 * Get max value.
 */
public static Integer getMax(Integer fn_depth,Integer list_depth,Integer dlist_depth,Integer table_depth,Integer stable_depth){
  int fnDepth=fn_depth;
  int listDepth=list_depth;
  int dlistDepth=dlist_depth;
  int tableDepth=table_depth;
  int stableDepth=stable_depth;
  int max=fnDepth;
  if (listDepth > max) {
    max=listDepth;
  }
  if (dlistDepth > max) {
    max=dlistDepth;
  }
  if (tableDepth > max) {
    max=tableDepth;
  }
  if (stableDepth > max) {
    max=stableDepth;
  }
  return max;
}","/** 
 * Get max value.
 */
public static Integer getMax(String fn_depth,String list_depth,String dlist_depth,String table_depth,String stable_depth){
  int fnDepth=Integer.parseInt(fn_depth);
  int listDepth=Integer.parseInt(list_depth);
  int dlistDepth=Integer.parseInt(dlist_depth);
  int tableDepth=Integer.parseInt(table_depth);
  int stableDepth=Integer.parseInt(stable_depth);
  int max=fnDepth;
  if (listDepth > max) {
    max=listDepth;
  }
  if (dlistDepth > max) {
    max=dlistDepth;
  }
  if (tableDepth > max) {
    max=tableDepth;
  }
  if (stableDepth > max) {
    max=stableDepth;
  }
  return max;
}",0.6429192006950478
100856,"/** 
 * IndexTerm will be equal if they have same name, target and subterms.
 * @param o object to compare with.
 * @return boolean
 */
public boolean equals(Object o){
  IndexTerm it=(IndexTerm)o;
  boolean eqTermName;
  boolean eqTermKey;
  boolean eqTargetList;
  boolean eqSubTerms;
  boolean eqTermPrefix;
  if (o == this) {
    return true;
  }
  if (!(o instanceof IndexTerm)) {
    return false;
  }
  eqTermName=termName == it.getTermName() || termName != null && termName.equals(it.getTermName());
  eqTermPrefix=termPrefix == it.getTermPrefix() || termPrefix != null && termPrefix.equals(it.getTermPrefix());
  eqTermKey=termKey == it.getTermKey() || termKey != null && termKey.equals(it.getTermKey());
  eqTargetList=targetList == it.getTargetList() || targetList != null && targetList.equals(it.getTargetList());
  eqSubTerms=subTerms == it.getSubTerms() || subTerms != null && subTerms.equals(it.getSubTerms());
  return eqTermName && eqTermKey && eqTargetList&& eqSubTerms&& eqTermPrefix;
}","/** 
 * IndexTerm will be equal if they have same name, target and subterms.
 * @param o object to compare with.
 * @return boolean
 */
public boolean equals(Object o){
  if (!(o instanceof IndexTerm)) {
    return false;
  }
 else   if (o == this) {
    return true;
  }
  IndexTerm it=(IndexTerm)o;
  boolean eqTermName;
  boolean eqTermKey;
  boolean eqTargetList;
  boolean eqSubTerms;
  boolean eqTermPrefix;
  eqTermName=termName == it.getTermName() || termName != null && termName.equals(it.getTermName());
  eqTermPrefix=termPrefix == it.getTermPrefix() || termPrefix != null && termPrefix.equals(it.getTermPrefix());
  eqTermKey=termKey == it.getTermKey() || termKey != null && termKey.equals(it.getTermKey());
  eqTargetList=targetList == it.getTargetList() || targetList != null && targetList.equals(it.getTargetList());
  eqSubTerms=subTerms == it.getSubTerms() || subTerms != null && subTerms.equals(it.getSubTerms());
  return eqTermName && eqTermKey && eqTargetList&& eqSubTerms&& eqTermPrefix;
}",0.8958333333333334
100857,"/** 
 * The only interface to access IndexTermCollection instance.
 * @return Singleton IndexTermCollection instance
 * @author Marshall
 */
public static IndexTermCollection getInstantce(){
  if (collection == null) {
    collection=new IndexTermCollection();
  }
  return collection;
}","/** 
 * The only interface to access IndexTermCollection instance.
 * @return Singleton IndexTermCollection instance
 * @author Marshall
 */
public static synchronized IndexTermCollection getInstantce(){
  if (collection == null) {
    collection=new IndexTermCollection();
  }
  return collection;
}",0.9778534923339012
100858,"/** 
 * Defalut Constructor. Construct pipeline & input instance.
 */
public AntInvoker(){
  super();
  pipeline=new PipelineFacade();
  pipelineInput=new PipelineHashIO();
  javaLogger=new DITAOTJavaLogger();
}","/** 
 * Defalut Constructor. Construct pipeline & input instance.
 */
public AntInvoker(){
  super();
  pipeline=new PipelineFacade();
  pipelineInput=new PipelineHashIO();
}",0.903896103896104
100859,"/** 
 * begin transformation.
 * @param cmd cmd
 * @throws IOException exception
 */
private static void startTransformation(String[] cmd) throws IOException {
  BufferedReader reader=null;
  Process antProcess=Runtime.getRuntime().exec(cmd);
  try {
    reader=new BufferedReader(new InputStreamReader(antProcess.getInputStream()));
    for (String line=reader.readLine(); line != null; line=reader.readLine()) {
      System.out.println(line);
    }
  }
  finally {
    reader.close();
  }
  reader=new BufferedReader(new InputStreamReader(antProcess.getErrorStream()));
  for (String line=reader.readLine(); line != null; line=reader.readLine()) {
    System.err.println(line);
  }
}","/** 
 * begin transformation.
 * @param cmd cmd
 * @throws IOException exception
 */
private static void startTransformation(String[] cmd) throws IOException {
  BufferedReader reader=null;
  Process antProcess=Runtime.getRuntime().exec(cmd);
  try {
    reader=new BufferedReader(new InputStreamReader(antProcess.getInputStream()));
    for (String line=reader.readLine(); line != null; line=reader.readLine()) {
      System.out.println(line);
    }
  }
  finally {
    reader.close();
  }
  reader=null;
  try {
    reader=new BufferedReader(new InputStreamReader(antProcess.getErrorStream()));
    for (String line=reader.readLine(); line != null; line=reader.readLine()) {
      System.err.println(line);
    }
  }
  finally {
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      IOException e) {
        javaLogger.logException(e);
      }
    }
  }
}",0.8678526048284625
100860,"/** 
 * Start ant process to execute the build process.
 * @throws IOException IOException
 */
public void startAnt() throws IOException {
  List<String> cmd=new ArrayList<String>(Constants.INT_8);
  String[] cmds=null;
  cmd.add(getCommandRunner());
  cmd.add(""String_Node_Str"");
  cmd.add(antBuildFile);
  cmd.add(""String_Node_Str"");
  cmd.add(""String_Node_Str"");
  cmd.add(""String_Node_Str"");
  cmd.add(propertyFile);
  if (debugMode) {
    cmd.add(""String_Node_Str"");
  }
  cmds=new String[cmd.size()];
  cmd.toArray(cmds);
  startTransformation(cmds);
}","/** 
 * Start ant process to execute the build process.
 * @throws IOException IOException
 */
public void startAnt() throws IOException {
  List<String> cmd=new ArrayList<String>(Constants.INT_8);
  String[] cmds;
  cmd.add(getCommandRunner());
  cmd.add(""String_Node_Str"");
  cmd.add(antBuildFile);
  cmd.add(""String_Node_Str"");
  cmd.add(""String_Node_Str"");
  cmd.add(""String_Node_Str"");
  cmd.add(propertyFile);
  if (debugMode) {
    cmd.add(""String_Node_Str"");
  }
  cmds=new String[cmd.size()];
  cmd.toArray(cmds);
  startTransformation(cmds);
}",0.9954995499549956
100861,"/** 
 * Get the DITAOTFileLogger instance. Singleton.
 * @return DITAOTFileLogger logger
 */
public static DITAOTFileLogger getInstance(){
  if (logger == null) {
    logger=new DITAOTFileLogger();
  }
  return logger;
}","/** 
 * Get the DITAOTFileLogger instance. Singleton.
 * @return DITAOTFileLogger logger
 */
public static synchronized DITAOTFileLogger getInstance(){
  if (logger == null) {
    logger=new DITAOTFileLogger();
  }
  return logger;
}",0.9713024282560706
100862,"/** 
 * Internal Singleton getInstance() method, for Classloader to locate the CLASSPATH
 * @return
 */
private static MessageUtils getInstance(){
  if (utils == null) {
    utils=new MessageUtils();
  }
  return utils;
}","/** 
 * Internal Singleton getInstance() method, for Classloader to locate the CLASSPATH
 * @return
 */
private static synchronized MessageUtils getInstance(){
  if (utils == null) {
    utils=new MessageUtils();
  }
  return utils;
}",0.9714285714285714
100863,"private void updateRefOfDita(Content changeTable,Hashtable<String,String> conflictTable,AbstractPipelineInput input){
  DITAOTJavaLogger logger=new DITAOTJavaLogger();
  String tempDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
  if (!new File(tempDir).isAbsolute()) {
    String baseDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
    tempDir=new File(baseDir,tempDir).getAbsolutePath();
  }
  File ditalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST);
  File xmlDitalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML);
  Properties prop=new Properties();
  try {
    if (xmlDitalist.exists()) {
      prop.loadFromXML(new FileInputStream(xmlDitalist));
    }
 else {
      prop.load(new FileInputStream(ditalist));
    }
  }
 catch (  IOException io) {
    logger.logError(io.getMessage());
  }
  TopicRefWriter topicRefWriter=new TopicRefWriter();
  topicRefWriter.setContent(changeTable);
  topicRefWriter.setup(conflictTable);
  StringTokenizer fullTopicList=new StringTokenizer(prop.getProperty(Constants.FULL_DITAMAP_TOPIC_LIST),Constants.COMMA);
  try {
    while (fullTopicList.hasMoreTokens()) {
      topicRefWriter.write(new File(tempDir,fullTopicList.nextToken()).getAbsolutePath());
    }
  }
 catch (  DITAOTException ex) {
    logger.logException(ex);
  }
}","private void updateRefOfDita(Content changeTable,Hashtable<String,String> conflictTable,AbstractPipelineInput input){
  DITAOTJavaLogger logger=new DITAOTJavaLogger();
  String tempDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
  if (!new File(tempDir).isAbsolute()) {
    String baseDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
    tempDir=new File(baseDir,tempDir).getAbsolutePath();
  }
  File ditalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST);
  File xmlDitalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML);
  Properties prop=new Properties();
  InputStream in=null;
  try {
    if (xmlDitalist.exists()) {
      in=new FileInputStream(xmlDitalist);
      prop.loadFromXML(in);
    }
 else {
      in=new FileInputStream(ditalist);
      prop.load(in);
    }
  }
 catch (  IOException io) {
    logger.logError(io.getMessage());
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        logger.logException(e);
      }
    }
  }
  TopicRefWriter topicRefWriter=new TopicRefWriter();
  topicRefWriter.setContent(changeTable);
  topicRefWriter.setup(conflictTable);
  StringTokenizer fullTopicList=new StringTokenizer(prop.getProperty(Constants.FULL_DITAMAP_TOPIC_LIST),Constants.COMMA);
  try {
    while (fullTopicList.hasMoreTokens()) {
      topicRefWriter.write(new File(tempDir,fullTopicList.nextToken()).getAbsolutePath());
    }
  }
 catch (  DITAOTException ex) {
    logger.logException(ex);
  }
}",0.8800553059108193
100864,"/** 
 * Entry point of chunk module. Starting from map files, it parses and processes chunk attribute, writes out the ""chunked"" results and finally update references pointing to ""chunked"" topics in other dita topics.
 * @param input Input parameters and resources.
 * @return null
 * @throws DITAOTException exception
 */
public AbstractPipelineOutput execute(AbstractPipelineInput input) throws DITAOTException {
  String tempDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
  String ditaext=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_DITAEXT);
  String transtype=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_EXT_PARAM_TRANSTYPE);
  DITAOTJavaLogger javaLogger=new DITAOTJavaLogger();
  if (!new File(tempDir).isAbsolute()) {
    String baseDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
    tempDir=new File(baseDir,tempDir).getAbsolutePath();
  }
  File ditalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST);
  File xmlDitalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML);
  ChunkMapReader mapReader=new ChunkMapReader();
  mapReader.setup(ditaext,transtype);
  Properties prop=new Properties();
  try {
    if (xmlDitalist.exists()) {
      prop.loadFromXML(new FileInputStream(xmlDitalist));
    }
 else {
      prop.load(new FileInputStream(ditalist));
    }
  }
 catch (  IOException ioe) {
    throw new DITAOTException(ioe);
  }
  String mapFile=new File(tempDir,prop.getProperty(Constants.INPUT_DITAMAP)).getAbsolutePath();
  try {
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document doc=builder.parse(mapFile);
    Element root=doc.getDocumentElement();
    if (root.getAttribute(Constants.ATTRIBUTE_NAME_CLASS).contains(""String_Node_Str"") && transtype.equals(Constants.INDEX_TYPE_ECLIPSEHELP)) {
      StringTokenizer st=new StringTokenizer(prop.getProperty(Constants.FULL_DITAMAP_LIST),Constants.COMMA);
      while (st.hasMoreTokens()) {
        mapFile=new File(tempDir,st.nextToken()).getAbsolutePath();
        mapReader.read(mapFile);
      }
    }
 else {
      mapReader.read(mapFile);
    }
  }
 catch (  Exception e) {
    javaLogger.logException(e);
  }
  Content content=mapReader.getContent();
  if (content.getValue() != null) {
    updateList((LinkedHashMap<String,String>)content.getValue(),mapReader.getConflicTable(),input);
    updateRefOfDita(content,mapReader.getConflicTable(),input);
  }
  return null;
}","/** 
 * Entry point of chunk module. Starting from map files, it parses and processes chunk attribute, writes out the ""chunked"" results and finally update references pointing to ""chunked"" topics in other dita topics.
 * @param input Input parameters and resources.
 * @return null
 * @throws DITAOTException exception
 */
public AbstractPipelineOutput execute(AbstractPipelineInput input) throws DITAOTException {
  String tempDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
  String ditaext=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_DITAEXT);
  String transtype=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_EXT_PARAM_TRANSTYPE);
  DITAOTJavaLogger javaLogger=new DITAOTJavaLogger();
  if (!new File(tempDir).isAbsolute()) {
    String baseDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
    tempDir=new File(baseDir,tempDir).getAbsolutePath();
  }
  File ditalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST);
  File xmlDitalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML);
  ChunkMapReader mapReader=new ChunkMapReader();
  mapReader.setup(ditaext,transtype);
  Properties prop=new Properties();
  InputStream in=null;
  try {
    if (xmlDitalist.exists()) {
      in=new FileInputStream(xmlDitalist);
      prop.loadFromXML(in);
    }
 else {
      in=new FileInputStream(ditalist);
      prop.load(in);
    }
  }
 catch (  IOException ioe) {
    throw new DITAOTException(ioe);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        javaLogger.logException(e);
      }
    }
  }
  String mapFile=new File(tempDir,prop.getProperty(Constants.INPUT_DITAMAP)).getAbsolutePath();
  try {
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    DocumentBuilder builder=factory.newDocumentBuilder();
    Document doc=builder.parse(mapFile);
    Element root=doc.getDocumentElement();
    if (root.getAttribute(Constants.ATTRIBUTE_NAME_CLASS).contains(""String_Node_Str"") && transtype.equals(Constants.INDEX_TYPE_ECLIPSEHELP)) {
      StringTokenizer st=new StringTokenizer(prop.getProperty(Constants.FULL_DITAMAP_LIST),Constants.COMMA);
      while (st.hasMoreTokens()) {
        mapFile=new File(tempDir,st.nextToken()).getAbsolutePath();
        mapReader.read(mapFile);
      }
    }
 else {
      mapReader.read(mapFile);
    }
  }
 catch (  Exception e) {
    javaLogger.logException(e);
  }
  Content content=mapReader.getContent();
  if (content.getValue() != null) {
    updateList((LinkedHashMap<String,String>)content.getValue(),mapReader.getConflicTable(),input);
    updateRefOfDita(content,mapReader.getConflicTable(),input);
  }
  return null;
}",0.9128049933799888
100865,"private void updateList(LinkedHashMap<String,String> changeTable,Hashtable<String,String> conflictTable,AbstractPipelineInput input){
  DITAOTJavaLogger logger=new DITAOTJavaLogger();
  String tempDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
  if (!new File(tempDir).isAbsolute()) {
    String baseDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
    tempDir=new File(baseDir,tempDir).getAbsolutePath();
  }
  File ditalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST);
  File xmlDitalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML);
  Properties prop=new Properties();
  try {
    if (xmlDitalist.exists()) {
      prop.loadFromXML(new FileInputStream(xmlDitalist));
    }
 else {
      prop.load(new FileInputStream(ditalist));
    }
  }
 catch (  IOException ex) {
    logger.logException(ex);
  }
  Set<String> hrefTopics=StringUtils.restoreSet((String)prop.getProperty(Constants.HREF_TOPIC_LIST));
  Set<String> chunkTopics=StringUtils.restoreSet((String)prop.getProperty(Constants.CHUNK_TOPIC_LIST));
  for (  String s : chunkTopics) {
    if (!StringUtils.isEmptyString(s) && !s.contains(Constants.SHARP)) {
      Iterator<String> hrefit=hrefTopics.iterator();
      while (hrefit.hasNext()) {
        String ent=hrefit.next();
        if (FileUtils.resolveFile(tempDir,ent).equalsIgnoreCase(FileUtils.resolveFile(tempDir,s))) {
          hrefit.remove();
        }
      }
    }
 else     if (!StringUtils.isEmptyString(s) && hrefTopics.contains(s)) {
      hrefTopics.remove(s);
    }
  }
  Set<String> topicList=new LinkedHashSet<String>(Constants.INT_128);
  Set<String> oldTopicList=StringUtils.restoreSet((String)prop.getProperty(Constants.FULL_DITA_TOPIC_LIST));
  for (  String t : hrefTopics) {
    if (t.lastIndexOf(Constants.SHARP) != -1) {
      t=t.substring(0,t.lastIndexOf(Constants.SHARP));
    }
    if (t.lastIndexOf(Constants.FILE_EXTENSION_DITAMAP) == -1) {
      String ditaext=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_DITAEXT);
      t=changeExtName(t,ditaext,ditaext);
    }
    t=FileUtils.getRelativePathFromMap(xmlDitalist.getAbsolutePath(),FileUtils.resolveFile(tempDir,t));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  HashSet<String> chunkedTopicSet=new LinkedHashSet<String>(Constants.INT_128);
  HashSet<String> chunkedDitamapSet=new LinkedHashSet<String>(Constants.INT_128);
  Set<String> ditamapList=StringUtils.restoreSet((String)prop.getProperty(Constants.FULL_DITAMAP_LIST));
  for (  Map.Entry<String,String> entry : changeTable.entrySet()) {
    String oldFile=entry.getKey();
    if (entry.getValue().toString().equals(oldFile)) {
      String newChunkedFile=entry.getValue().toString();
      newChunkedFile=FileUtils.getRelativePathFromMap(xmlDitalist.getAbsolutePath(),newChunkedFile);
      String extName=getExtName(newChunkedFile);
      if (extName != null && !extName.equalsIgnoreCase(""String_Node_Str"")) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  String s : oldTopicList) {
    if (!StringUtils.isEmptyString(s)) {
      File f=new File(tempDir,s);
      if (f.exists()) {
        f.delete();
      }
    }
  }
  for (  Map.Entry<String,String> entry : changeTable.entrySet()) {
    String oldFile=entry.getKey();
    if (entry.getValue().toString().equals(oldFile)) {
      String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        File target=new File(targetPath);
        if (!FileUtils.fileExists(target.getAbsolutePath())) {
          File from=new File(entry.getValue().toString());
          String relativePath=FileUtils.getRelativePathFromMap(xmlDitalist.getAbsolutePath(),from.getAbsolutePath());
          target.delete();
          from.renameTo(target);
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=FileUtils.getRelativePathFromMap(xmlDitalist.getAbsolutePath(),target.getAbsolutePath());
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  Set<String> resourceOnlySet=StringUtils.restoreSet(prop.getProperty(Constants.RESOURCE_ONLY_LIST));
  resourceOnlySet.removeAll(chunkedTopicSet);
  resourceOnlySet.removeAll(chunkedDitamapSet);
  prop.setProperty(Constants.RESOURCE_ONLY_LIST,StringUtils.assembleString(resourceOnlySet,Constants.COMMA));
  prop.setProperty(Constants.FULL_DITA_TOPIC_LIST,StringUtils.assembleString(topicList,Constants.COMMA));
  prop.setProperty(Constants.FULL_DITAMAP_LIST,StringUtils.assembleString(ditamapList,Constants.COMMA));
  topicList.addAll(ditamapList);
  prop.setProperty(Constants.FULL_DITAMAP_TOPIC_LIST,StringUtils.assembleString(topicList,Constants.COMMA));
  try {
    writeList(prop,tempDir,Constants.FULL_DITA_TOPIC_LIST);
    writeList(prop,tempDir,Constants.FULL_DITAMAP_LIST);
    writeList(prop,tempDir,Constants.FULL_DITAMAP_TOPIC_LIST);
  }
 catch (  FileNotFoundException e) {
    logger.logException(e);
  }
catch (  IOException e) {
    logger.logException(e);
  }
  String[] keys={Constants.CHUNKED_DITAMAP_LIST,Constants.CHUNKED_TOPIC_LIST,Constants.RESOURCE_ONLY_LIST};
  List<Set<String>> sets=new ArrayList<Set<String>>();
  sets.add(chunkedDitamapSet);
  sets.add(chunkedTopicSet);
  sets.add(resourceOnlySet);
  for (int i=0; i < keys.length; i++) {
    String key=keys[i];
    String fileKey=key.substring(0,key.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"";
    prop.put(fileKey,key.substring(0,key.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"");
    File list=new File(tempDir,prop.getProperty(fileKey));
    BufferedWriter bufferedWriter=null;
    try {
      bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(list)));
      Iterator<String> it=sets.get(i).iterator();
      while (it.hasNext()) {
        bufferedWriter.write(it.next());
        if (it.hasNext()) {
          bufferedWriter.write(""String_Node_Str"");
        }
      }
      bufferedWriter.flush();
      bufferedWriter.close();
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
 finally {
      if (bufferedWriter != null) {
        try {
          bufferedWriter.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
  addSetToProperties(prop,Constants.CHUNKED_DITAMAP_LIST,chunkedDitamapSet);
  addSetToProperties(prop,Constants.CHUNKED_TOPIC_LIST,chunkedTopicSet);
  Content content=new ContentImpl();
  content.setValue(prop);
  PropertiesWriter writer=new PropertiesWriter();
  writer.setContent(content);
  try {
    writer.write(ditalist.getAbsolutePath());
    writer.writeToXML(xmlDitalist.getAbsolutePath());
  }
 catch (  DITAOTException ex) {
    logger.logException(ex);
  }
}","private void updateList(LinkedHashMap<String,String> changeTable,Hashtable<String,String> conflictTable,AbstractPipelineInput input){
  DITAOTJavaLogger logger=new DITAOTJavaLogger();
  String tempDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
  if (!new File(tempDir).isAbsolute()) {
    String baseDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
    tempDir=new File(baseDir,tempDir).getAbsolutePath();
  }
  File ditalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST);
  File xmlDitalist=new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML);
  Properties prop=new Properties();
  InputStream in=null;
  try {
    if (xmlDitalist.exists()) {
      in=new FileInputStream(xmlDitalist);
      prop.loadFromXML(in);
    }
 else {
      in=new FileInputStream(ditalist);
      prop.load(in);
    }
  }
 catch (  IOException ex) {
    logger.logException(ex);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        logger.logException(e);
      }
    }
  }
  Set<String> hrefTopics=StringUtils.restoreSet((String)prop.getProperty(Constants.HREF_TOPIC_LIST));
  Set<String> chunkTopics=StringUtils.restoreSet((String)prop.getProperty(Constants.CHUNK_TOPIC_LIST));
  for (  String s : chunkTopics) {
    if (!StringUtils.isEmptyString(s) && !s.contains(Constants.SHARP)) {
      Iterator<String> hrefit=hrefTopics.iterator();
      while (hrefit.hasNext()) {
        String ent=hrefit.next();
        if (FileUtils.resolveFile(tempDir,ent).equalsIgnoreCase(FileUtils.resolveFile(tempDir,s))) {
          hrefit.remove();
        }
      }
    }
 else     if (!StringUtils.isEmptyString(s) && hrefTopics.contains(s)) {
      hrefTopics.remove(s);
    }
  }
  Set<String> topicList=new LinkedHashSet<String>(Constants.INT_128);
  Set<String> oldTopicList=StringUtils.restoreSet((String)prop.getProperty(Constants.FULL_DITA_TOPIC_LIST));
  for (  String t : hrefTopics) {
    if (t.lastIndexOf(Constants.SHARP) != -1) {
      t=t.substring(0,t.lastIndexOf(Constants.SHARP));
    }
    if (t.lastIndexOf(Constants.FILE_EXTENSION_DITAMAP) == -1) {
      String ditaext=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_DITAEXT);
      t=changeExtName(t,ditaext,ditaext);
    }
    t=FileUtils.getRelativePathFromMap(xmlDitalist.getAbsolutePath(),FileUtils.resolveFile(tempDir,t));
    topicList.add(t);
    if (oldTopicList.contains(t)) {
      oldTopicList.remove(t);
    }
  }
  HashSet<String> chunkedTopicSet=new LinkedHashSet<String>(Constants.INT_128);
  HashSet<String> chunkedDitamapSet=new LinkedHashSet<String>(Constants.INT_128);
  Set<String> ditamapList=StringUtils.restoreSet((String)prop.getProperty(Constants.FULL_DITAMAP_LIST));
  for (  Map.Entry<String,String> entry : changeTable.entrySet()) {
    String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      String newChunkedFile=entry.getValue();
      newChunkedFile=FileUtils.getRelativePathFromMap(xmlDitalist.getAbsolutePath(),newChunkedFile);
      String extName=getExtName(newChunkedFile);
      if (extName != null && !extName.equalsIgnoreCase(""String_Node_Str"")) {
        chunkedTopicSet.add(newChunkedFile);
        if (!topicList.contains(newChunkedFile)) {
          topicList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
      }
 else {
        if (!ditamapList.contains(newChunkedFile)) {
          ditamapList.add(newChunkedFile);
          if (oldTopicList.contains(newChunkedFile)) {
            oldTopicList.remove(newChunkedFile);
          }
        }
        chunkedDitamapSet.add(newChunkedFile);
      }
    }
  }
  for (  String s : oldTopicList) {
    if (!StringUtils.isEmptyString(s)) {
      File f=new File(tempDir,s);
      if (f.exists()) {
        f.delete();
      }
    }
  }
  for (  Map.Entry<String,String> entry : changeTable.entrySet()) {
    String oldFile=entry.getKey();
    if (entry.getValue().equals(oldFile)) {
      String targetPath=conflictTable.get(entry.getKey());
      if (targetPath != null) {
        File target=new File(targetPath);
        if (!FileUtils.fileExists(target.getAbsolutePath())) {
          File from=new File(entry.getValue());
          String relativePath=FileUtils.getRelativePathFromMap(xmlDitalist.getAbsolutePath(),from.getAbsolutePath());
          target.delete();
          from.renameTo(target);
          if (topicList.contains(relativePath)) {
            topicList.remove(relativePath);
          }
          if (chunkedTopicSet.contains(relativePath)) {
            chunkedTopicSet.remove(relativePath);
          }
          relativePath=FileUtils.getRelativePathFromMap(xmlDitalist.getAbsolutePath(),target.getAbsolutePath());
          topicList.add(relativePath);
          chunkedTopicSet.add(relativePath);
        }
 else {
          conflictTable.remove(entry.getKey());
        }
      }
    }
  }
  Set<String> resourceOnlySet=StringUtils.restoreSet(prop.getProperty(Constants.RESOURCE_ONLY_LIST));
  resourceOnlySet.removeAll(chunkedTopicSet);
  resourceOnlySet.removeAll(chunkedDitamapSet);
  prop.setProperty(Constants.RESOURCE_ONLY_LIST,StringUtils.assembleString(resourceOnlySet,Constants.COMMA));
  prop.setProperty(Constants.FULL_DITA_TOPIC_LIST,StringUtils.assembleString(topicList,Constants.COMMA));
  prop.setProperty(Constants.FULL_DITAMAP_LIST,StringUtils.assembleString(ditamapList,Constants.COMMA));
  topicList.addAll(ditamapList);
  prop.setProperty(Constants.FULL_DITAMAP_TOPIC_LIST,StringUtils.assembleString(topicList,Constants.COMMA));
  try {
    writeList(prop,tempDir,Constants.FULL_DITA_TOPIC_LIST);
    writeList(prop,tempDir,Constants.FULL_DITAMAP_LIST);
    writeList(prop,tempDir,Constants.FULL_DITAMAP_TOPIC_LIST);
  }
 catch (  FileNotFoundException e) {
    logger.logException(e);
  }
catch (  IOException e) {
    logger.logException(e);
  }
  String[] keys={Constants.CHUNKED_DITAMAP_LIST,Constants.CHUNKED_TOPIC_LIST,Constants.RESOURCE_ONLY_LIST};
  List<Set<String>> sets=new ArrayList<Set<String>>();
  sets.add(chunkedDitamapSet);
  sets.add(chunkedTopicSet);
  sets.add(resourceOnlySet);
  for (int i=0; i < keys.length; i++) {
    String key=keys[i];
    String fileKey=key.substring(0,key.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"";
    prop.put(fileKey,key.substring(0,key.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"");
    File list=new File(tempDir,prop.getProperty(fileKey));
    BufferedWriter bufferedWriter=null;
    try {
      bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(list)));
      Iterator<String> it=sets.get(i).iterator();
      while (it.hasNext()) {
        bufferedWriter.write(it.next());
        if (it.hasNext()) {
          bufferedWriter.write(""String_Node_Str"");
        }
      }
      bufferedWriter.flush();
      bufferedWriter.close();
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
 finally {
      if (bufferedWriter != null) {
        try {
          bufferedWriter.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
  addSetToProperties(prop,Constants.CHUNKED_DITAMAP_LIST,chunkedDitamapSet);
  addSetToProperties(prop,Constants.CHUNKED_TOPIC_LIST,chunkedTopicSet);
  Content content=new ContentImpl();
  content.setValue(prop);
  PropertiesWriter writer=new PropertiesWriter();
  writer.setContent(content);
  try {
    writer.write(ditalist.getAbsolutePath());
    writer.writeToXML(xmlDitalist.getAbsolutePath());
  }
 catch (  DITAOTException ex) {
    logger.logException(ex);
  }
}",0.9743722831376112
100866,"private Map<String,Set<String>> readMapFromXML(String filename){
  File inputFile=new File(tempDir,filename);
  Map<String,Set<String>> graph=new HashMap<String,Set<String>>();
  if (!inputFile.exists())   return graph;
  Properties prop=new Properties();
  try {
    FileInputStream in=new FileInputStream(inputFile);
    prop.loadFromXML(in);
    in.close();
  }
 catch (  IOException e) {
    this.javaLogger.logException(e);
  }
  Iterator<Object> it=prop.keySet().iterator();
  while (it.hasNext()) {
    String key=(String)it.next();
    String value=prop.getProperty(key);
    graph.put(key,StringUtils.restoreSet(value,Constants.COMMA));
  }
  return graph;
}","private Map<String,Set<String>> readMapFromXML(String filename){
  File inputFile=new File(tempDir,filename);
  Map<String,Set<String>> graph=new HashMap<String,Set<String>>();
  if (!inputFile.exists())   return graph;
  Properties prop=new Properties();
  FileInputStream in=null;
  try {
    in=new FileInputStream(inputFile);
    prop.loadFromXML(in);
    in.close();
  }
 catch (  IOException e) {
    this.javaLogger.logException(e);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        javaLogger.logException(e);
      }
    }
  }
  Iterator<Object> it=prop.keySet().iterator();
  while (it.hasNext()) {
    String key=(String)it.next();
    String value=prop.getProperty(key);
    graph.put(key,StringUtils.restoreSet(value,Constants.COMMA));
  }
  return graph;
}",0.8662674650698603
100867,"private static void updateProperty(String listName,Properties property){
  StringBuffer result=new StringBuffer(Constants.INT_1024);
  String propValue=property.getProperty(listName);
  String file;
  int equalIndex;
  int fileExtIndex;
  StringTokenizer tokenizer=null;
  if (propValue == null || Constants.STRING_EMPTY.equals(propValue.trim())) {
    return;
  }
  tokenizer=new StringTokenizer(propValue,Constants.COMMA);
  while (tokenizer.hasMoreElements()) {
    file=(String)tokenizer.nextElement();
    equalIndex=file.indexOf(Constants.EQUAL);
    fileExtIndex=file.lastIndexOf(Constants.DOT);
    if (fileExtIndex != -1 && Constants.FILE_EXTENSION_DITAMAP.equalsIgnoreCase(file.substring(fileExtIndex))) {
      result.append(Constants.COMMA).append(file);
    }
 else     if (equalIndex == -1) {
      result.append(Constants.COMMA).append(FileUtils.replaceExtName(file,extName));
    }
 else {
      result.append(Constants.COMMA);
      result.append(FileUtils.replaceExtName(file.substring(0,equalIndex),extName));
      result.append(Constants.EQUAL);
      result.append(FileUtils.replaceExtName(file.substring(equalIndex + 1),extName));
    }
  }
  String list=result.substring(Constants.INT_1);
  property.setProperty(listName,list);
  String files[]=list.split(Constants.COMMA);
  String filename=""String_Node_Str"";
  if (listName == ""String_Node_Str"") {
    filename=""String_Node_Str"";
  }
 else   filename=listName.substring(Constants.INT_0,listName.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"";
  try {
    BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(tempDir,filename))));
    if (files.length > 0) {
      for (int i=0; i < files.length; i++) {
        bufferedWriter.write(files[i]);
        if (i < files.length - 1)         bufferedWriter.write(""String_Node_Str"");
        bufferedWriter.flush();
      }
    }
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","private static void updateProperty(String listName,Properties property){
  StringBuffer result=new StringBuffer(Constants.INT_1024);
  String propValue=property.getProperty(listName);
  String file;
  int equalIndex;
  int fileExtIndex;
  StringTokenizer tokenizer=null;
  if (propValue == null || Constants.STRING_EMPTY.equals(propValue.trim())) {
    return;
  }
  tokenizer=new StringTokenizer(propValue,Constants.COMMA);
  while (tokenizer.hasMoreElements()) {
    file=(String)tokenizer.nextElement();
    equalIndex=file.indexOf(Constants.EQUAL);
    fileExtIndex=file.lastIndexOf(Constants.DOT);
    if (fileExtIndex != -1 && Constants.FILE_EXTENSION_DITAMAP.equalsIgnoreCase(file.substring(fileExtIndex))) {
      result.append(Constants.COMMA).append(file);
    }
 else     if (equalIndex == -1) {
      result.append(Constants.COMMA).append(FileUtils.replaceExtName(file,extName));
    }
 else {
      result.append(Constants.COMMA);
      result.append(FileUtils.replaceExtName(file.substring(0,equalIndex),extName));
      result.append(Constants.EQUAL);
      result.append(FileUtils.replaceExtName(file.substring(equalIndex + 1),extName));
    }
  }
  String list=result.substring(Constants.INT_1);
  property.setProperty(listName,list);
  String files[]=list.split(Constants.COMMA);
  String filename=""String_Node_Str"";
  if (listName.equals(""String_Node_Str"")) {
    filename=""String_Node_Str"";
  }
 else   filename=listName.substring(Constants.INT_0,listName.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"";
  Writer bufferedWriter=null;
  try {
    bufferedWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(tempDir,filename))));
    if (files.length > 0) {
      for (int i=0; i < files.length; i++) {
        bufferedWriter.write(files[i]);
        if (i < files.length - 1)         bufferedWriter.write(""String_Node_Str"");
        bufferedWriter.flush();
      }
    }
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    if (bufferedWriter != null) {
      try {
        bufferedWriter.close();
      }
 catch (      IOException e) {
        final DITAOTLogger logger=new DITAOTJavaLogger();
        logger.logException(e);
      }
    }
  }
}",0.9318181818181818
100868,"private void writeMapToXML(Map<String,Set<String>> m,String filename){
  if (m == null)   return;
  Properties prop=new Properties();
  Iterator<Map.Entry<String,Set<String>>> iter=m.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<String,Set<String>> entry=iter.next();
    String key=entry.getKey();
    String value=StringUtils.assembleString(entry.getValue(),Constants.COMMA);
    prop.setProperty(key,value);
  }
  File outputFile=new File(tempDir,filename);
  try {
    FileOutputStream os=new FileOutputStream(outputFile,false);
    prop.storeToXML(os,null);
    os.close();
  }
 catch (  IOException e) {
    this.javaLogger.logException(e);
  }
}","private void writeMapToXML(Map<String,Set<String>> m,String filename){
  if (m == null)   return;
  Properties prop=new Properties();
  Iterator<Map.Entry<String,Set<String>>> iter=m.entrySet().iterator();
  while (iter.hasNext()) {
    Map.Entry<String,Set<String>> entry=iter.next();
    String key=entry.getKey();
    String value=StringUtils.assembleString(entry.getValue(),Constants.COMMA);
    prop.setProperty(key,value);
  }
  File outputFile=new File(tempDir,filename);
  FileOutputStream os=null;
  try {
    os=new FileOutputStream(outputFile,false);
    prop.storeToXML(os,null);
    os.close();
  }
 catch (  IOException e) {
    this.javaLogger.logException(e);
  }
 finally {
    if (os != null) {
      try {
        os.close();
      }
 catch (      IOException e) {
        javaLogger.logException(e);
      }
    }
  }
}",0.8654738237243207
100869,"private void updateList(String tempDir){
  Properties property=new Properties();
  FileOutputStream output=null;
  FileOutputStream xmlDitalist=null;
  try {
    property.loadFromXML(new FileInputStream(new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML)));
    for (int i=0; i < PROPERTY_UPDATE_LIST.length; i++) {
      updateProperty(PROPERTY_UPDATE_LIST[i],property);
    }
    output=new FileOutputStream(new File(tempDir,Constants.FILE_NAME_DITA_LIST));
    xmlDitalist=new FileOutputStream(new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML));
    property.store(output,null);
    property.storeToXML(xmlDitalist,null);
    output.flush();
    xmlDitalist.flush();
  }
 catch (  Exception e) {
    javaLogger.logException(e);
  }
 finally {
    try {
      output.close();
      xmlDitalist.close();
    }
 catch (    IOException e) {
      javaLogger.logException(e);
    }
  }
}","private void updateList(String tempDir){
  Properties property=new Properties();
  FileInputStream in=null;
  FileOutputStream output=null;
  FileOutputStream xmlDitalist=null;
  try {
    in=new FileInputStream(new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML));
    property.loadFromXML(in);
    for (int i=0; i < PROPERTY_UPDATE_LIST.length; i++) {
      updateProperty(PROPERTY_UPDATE_LIST[i],property);
    }
    output=new FileOutputStream(new File(tempDir,Constants.FILE_NAME_DITA_LIST));
    xmlDitalist=new FileOutputStream(new File(tempDir,Constants.FILE_NAME_DITA_LIST_XML));
    property.store(output,null);
    property.storeToXML(xmlDitalist,null);
    output.flush();
    xmlDitalist.flush();
  }
 catch (  Exception e) {
    javaLogger.logException(e);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        javaLogger.logException(e);
      }
    }
    if (output != null) {
      try {
        output.close();
      }
 catch (      IOException e) {
        javaLogger.logException(e);
      }
    }
    if (xmlDitalist != null) {
      try {
        xmlDitalist.close();
      }
 catch (      IOException e) {
        javaLogger.logException(e);
      }
    }
  }
}",0.7651195499296765
100870,"/** 
 * Return if the file is a supported image file by extension
 * @param lcasefn
 * @return
 */
public static boolean isSupportedImageFile(String lcasefn){
  return lcasefn.endsWith(Constants.FILE_EXTENSION_JPG) || lcasefn.endsWith(Constants.FILE_EXTENSION_GIF) || lcasefn.endsWith(Constants.FILE_EXTENSION_EPS)|| lcasefn.endsWith(Constants.FILE_EXTENSION_JPEG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_PNG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_SVG);
}","/** 
 * Return if the file is a supported image file by extension
 * @param lcasefn
 * @return
 */
public static boolean isSupportedImageFile(String lcasefn){
  return lcasefn.endsWith(Constants.FILE_EXTENSION_JPG) || lcasefn.endsWith(Constants.FILE_EXTENSION_GIF) || lcasefn.endsWith(Constants.FILE_EXTENSION_EPS)|| lcasefn.endsWith(Constants.FILE_EXTENSION_JPEG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_PNG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_SVG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_TIFF)|| lcasefn.endsWith(Constants.FILE_EXTENSION_TIF);
}",0.9037900874635568
100871,"/** 
 * Return if the file is a valid target file by extension
 * @param lcasefn
 * @return
 */
public static boolean isValidTarget(String lcasefn){
  DITAOTJavaLogger logger=new DITAOTJavaLogger();
  Properties params=new Properties();
  if (lcasefn.indexOf(Constants.STRING_BLANK) != -1) {
    params.put(""String_Node_Str"",lcasefn);
    logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",params).toString());
  }
  return lcasefn.endsWith(Constants.FILE_EXTENSION_DITA) || lcasefn.endsWith(Constants.FILE_EXTENSION_DITAMAP) || lcasefn.endsWith(Constants.FILE_EXTENSION_XML)|| lcasefn.endsWith(Constants.FILE_EXTENSION_JPG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_GIF)|| lcasefn.endsWith(Constants.FILE_EXTENSION_EPS)|| lcasefn.endsWith(Constants.FILE_EXTENSION_HTML)|| lcasefn.endsWith(Constants.FILE_EXTENSION_JPEG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_PNG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_SVG);
}","/** 
 * Return if the file is a valid target file by extension
 * @param lcasefn
 * @return
 */
public static boolean isValidTarget(String lcasefn){
  DITAOTJavaLogger logger=new DITAOTJavaLogger();
  Properties params=new Properties();
  if (lcasefn.indexOf(Constants.STRING_BLANK) != -1) {
    params.put(""String_Node_Str"",lcasefn);
    logger.logWarn(MessageUtils.getMessage(""String_Node_Str"",params).toString());
  }
  return lcasefn.endsWith(Constants.FILE_EXTENSION_DITA) || lcasefn.endsWith(Constants.FILE_EXTENSION_DITAMAP) || lcasefn.endsWith(Constants.FILE_EXTENSION_XML)|| lcasefn.endsWith(Constants.FILE_EXTENSION_JPG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_GIF)|| lcasefn.endsWith(Constants.FILE_EXTENSION_EPS)|| lcasefn.endsWith(Constants.FILE_EXTENSION_HTML)|| lcasefn.endsWith(Constants.FILE_EXTENSION_JPEG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_PNG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_SVG)|| lcasefn.endsWith(Constants.FILE_EXTENSION_TIFF)|| lcasefn.endsWith(Constants.FILE_EXTENSION_TIF);
}",0.9494123658661217
100872,"private void moveMeta(Entry entry,Node root){
  String metaPath=(String)moveTable.get(entry.getKey());
  if (metaPath == null) {
    return;
  }
  StringTokenizer token=new StringTokenizer(metaPath,Constants.SLASH);
  Node parent=null;
  Node child=root;
  Node current=null;
  Node item=null;
  NodeList childElements;
  boolean createChild=false;
  while (token.hasMoreElements()) {
    parent=child;
    String next=(String)token.nextElement();
    Integer nextIndex=(Integer)compareTable.get(next);
    Integer currentIndex=null;
    childElements=parent.getChildNodes();
    for (int i=0; i < childElements.getLength(); i++) {
      String name=null;
      current=childElements.item(i);
      if (current.getNodeType() == Node.ELEMENT_NODE) {
        name=current.getNodeName();
      }
      if (name != null && current.getNodeName().equals(next)) {
        child=current;
        break;
      }
 else       if (name != null) {
        currentIndex=(Integer)compareTable.get(name);
        if (currentIndex.compareTo(nextIndex) > 0) {
          break;
        }
      }
    }
    if (child == parent) {
      child=parent.getOwnerDocument().createElement(next);
      ((Element)child).setAttribute(Constants.ATTRIBUTE_NAME_CLASS,""String_Node_Str"" + next + ""String_Node_Str"");
      if (current == null || currentIndex == null || nextIndex.compareTo(currentIndex) >= 0) {
        parent.appendChild(child);
        current=null;
      }
 else {
        parent.insertBefore(child,current);
        current=null;
      }
      createChild=true;
    }
  }
  NodeList list=((Node)entry.getValue()).getChildNodes();
  for (int i=0; i < list.getLength(); i++) {
    item=list.item(i);
    if ((i == 0 && createChild) || uniqueSet.contains(entry.getKey())) {
      item=parent.getOwnerDocument().importNode(item,true);
      parent.replaceChild(item,child);
      child=item;
    }
 else {
      item=parent.getOwnerDocument().importNode(item,true);
      ((Element)parent).insertBefore(item,child);
    }
  }
}","private void moveMeta(Entry entry,Node root){
  String metaPath=(String)moveTable.get(entry.getKey());
  if (metaPath == null) {
    return;
  }
  StringTokenizer token=new StringTokenizer(metaPath,Constants.SLASH);
  Node parent=null;
  Node child=root;
  Node current=null;
  Node item=null;
  NodeList childElements;
  boolean createChild=false;
  while (token.hasMoreElements()) {
    parent=child;
    String next=(String)token.nextElement();
    Integer nextIndex=(Integer)compareTable.get(next);
    Integer currentIndex=null;
    childElements=parent.getChildNodes();
    for (int i=0; i < childElements.getLength(); i++) {
      String name=null;
      current=childElements.item(i);
      if (current.getNodeType() == Node.ELEMENT_NODE) {
        name=current.getNodeName();
      }
      if (name != null && current.getNodeName().equals(next)) {
        child=current;
        break;
      }
 else       if (name != null) {
        currentIndex=(Integer)compareTable.get(name);
        if (currentIndex == null) {
          String classValue=((Element)current).getAttribute(Constants.ATTRIBUTE_NAME_CLASS);
          String generalizedName=classValue.substring(classValue.indexOf(Constants.SLASH) + 1);
          generalizedName=generalizedName.substring(0,generalizedName.indexOf(Constants.STRING_BLANK));
          currentIndex=(Integer)compareTable.get(generalizedName);
        }
        if (currentIndex.compareTo(nextIndex) > 0) {
          break;
        }
      }
    }
    if (child == parent) {
      child=parent.getOwnerDocument().createElement(next);
      ((Element)child).setAttribute(Constants.ATTRIBUTE_NAME_CLASS,""String_Node_Str"" + next + ""String_Node_Str"");
      if (current == null || currentIndex == null || nextIndex.compareTo(currentIndex) >= 0) {
        parent.appendChild(child);
        current=null;
      }
 else {
        parent.insertBefore(child,current);
        current=null;
      }
      createChild=true;
    }
  }
  NodeList list=((Node)entry.getValue()).getChildNodes();
  for (int i=0; i < list.getLength(); i++) {
    item=list.item(i);
    if ((i == 0 && createChild) || uniqueSet.contains(entry.getKey())) {
      item=parent.getOwnerDocument().importNode(item,true);
      parent.replaceChild(item,child);
      child=item;
    }
 else {
      item=parent.getOwnerDocument().importNode(item,true);
      ((Element)parent).insertBefore(item,child);
    }
  }
}",0.9082693176683236
100873,"/** 
 * (non-Javadoc)
 * @see org.dita.dost.module.AbstractPipelineModule#execute(org.dita.dost.pipeline.AbstractPipelineInput)
 */
public AbstractPipelineOutput execute(AbstractPipelineInput input) throws DITAOTException {
  try {
    parseAndValidateInput(input);
    extractIndexTerm();
    IndexTermCollection.getInstantce().sort();
    IndexTermCollection.getInstantce().outputTerms();
  }
 catch (  Exception e) {
    javaLogger.logException(e);
  }
  return null;
}","/** 
 * (non-Javadoc)
 * @see org.dita.dost.module.AbstractPipelineModule#execute(org.dita.dost.pipeline.AbstractPipelineInput)
 */
public AbstractPipelineOutput execute(AbstractPipelineInput input) throws DITAOTException {
  try {
    IndexTermCollection.getInstantce().clear();
    parseAndValidateInput(input);
    extractIndexTerm();
    IndexTermCollection.getInstantce().sort();
    IndexTermCollection.getInstantce().outputTerms();
  }
 catch (  Exception e) {
    javaLogger.logException(e);
  }
  return null;
}",0.8145161290322581
100874,"/** 
 * Add a sub term into the sub term list.
 * @param term
 */
public void addSubTerm(IndexTerm term){
  int i=0;
  int subTermNum=subTerms.size();
  for (; i < subTermNum; i++) {
    IndexTerm subTerm=(IndexTerm)subTerms.get(i);
    if (subTerm.equals(term)) {
      return;
    }
    if (subTerm.getTermFullName().equals(term.getTermFullName()) && subTerm.getTermKey().equals(term.getTermKey())) {
      subTerm.addTargets(term.getTargetList());
      subTerm.addSubTerms(term.getSubTerms());
      return;
    }
  }
  if (i == subTermNum) {
    subTerms.add(term);
  }
}","/** 
 * Add a sub term into the sub term list.
 * @param term
 */
public void addSubTerm(IndexTerm term){
  int i=0;
  int subTermNum=subTerms.size();
  if (!Constants.IndexTerm_Prefix_See.equals(term.getTermPrefix()) && !Constants.IndexTerm_Prefix_See_Also.equals(term.getTermPrefix())) {
    leaf=false;
  }
  for (; i < subTermNum; i++) {
    IndexTerm subTerm=(IndexTerm)subTerms.get(i);
    if (subTerm.equals(term)) {
      return;
    }
    if (subTerm.getTermFullName().equals(term.getTermFullName()) && subTerm.getTermKey().equals(term.getTermKey())) {
      subTerm.addTargets(term.getTargetList());
      subTerm.addSubTerms(term.getSubTerms());
      return;
    }
  }
  if (i == subTermNum) {
    subTerms.add(term);
  }
}",0.8787185354691075
100875,"public void updateSubTerm(){
  if (subTerms.size() == 1) {
    IndexTerm term=(IndexTerm)subTerms.get(0);
    if (term.getTermPrefix() != null && ""String_Node_Str"".equalsIgnoreCase(term.getTermPrefix().trim())) {
      term.setTermPrefix(""String_Node_Str"");
    }
  }
}","public void updateSubTerm(){
  if (subTerms.size() == 1) {
    IndexTerm term=(IndexTerm)subTerms.get(0);
    if (term.getTermPrefix() != null && Constants.IndexTerm_Prefix_See.equalsIgnoreCase(term.getTermPrefix().trim())) {
      term.setTermPrefix(Constants.IndexTerm_Prefix_See_Also);
    }
  }
}",0.5764499121265377
100876,"private void extractIndexTerm() throws SAXException {
  int topicNum=topicList.size();
  int ditamapNum=ditamapList.size();
  FileInputStream inputStream=null;
  XMLReader xmlReader=null;
  IndexTermReader handler=new IndexTermReader();
  DitamapIndexTermReader ditamapIndexTermReader=new DitamapIndexTermReader();
  if (System.getProperty(Constants.SAX_DRIVER_PROPERTY) == null) {
    StringUtils.initSaxDriver();
  }
  xmlReader=XMLReaderFactory.createXMLReader();
  try {
    xmlReader.setContentHandler(handler);
    for (int i=0; i < topicNum; i++) {
      String target;
      String targetPathFromMap;
      String targetPathFromMapWithoutExt;
      handler.reset();
      target=(String)topicList.get(i);
      targetPathFromMap=FileUtils.getRelativePathFromMap(inputMap,target);
      targetPathFromMapWithoutExt=targetPathFromMap.substring(0,targetPathFromMap.lastIndexOf(""String_Node_Str""));
      handler.setTargetFile(new StringBuffer(targetPathFromMapWithoutExt).append(targetExt).toString());
      try {
        if (!new File(baseInputDir,target).exists()) {
          javaLogger.logWarn(""String_Node_Str"" + target);
          continue;
        }
        inputStream=new FileInputStream(new File(baseInputDir,target));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      Exception e) {
        Properties params=new Properties();
        StringBuffer buff=new StringBuffer();
        String msg=null;
        params.put(""String_Node_Str"",target);
        msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
        javaLogger.logError(buff.append(msg).append(e.getMessage()).toString());
      }
    }
    xmlReader.setContentHandler(ditamapIndexTermReader);
    for (int j=0; j < ditamapNum; j++) {
      String ditamap=(String)ditamapList.get(j);
      String currentMapPathName=FileUtils.getRelativePathFromMap(inputMap,ditamap);
      String mapPathFromInputMap=""String_Node_Str"";
      if (currentMapPathName.lastIndexOf(Constants.SLASH) != -1) {
        mapPathFromInputMap=currentMapPathName.substring(0,currentMapPathName.lastIndexOf(Constants.SLASH));
      }
      ditamapIndexTermReader.setMapPath(mapPathFromInputMap);
      try {
        if (!new File(baseInputDir,ditamap).exists()) {
          javaLogger.logWarn(""String_Node_Str"" + ditamap);
          continue;
        }
        inputStream=new FileInputStream(new File(baseInputDir,ditamap));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      Exception e) {
        Properties params=new Properties();
        String msg=null;
        params.put(""String_Node_Str"",ditamap);
        msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
        javaLogger.logError(msg);
        javaLogger.logException(e);
      }
    }
  }
  finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      IOException e) {
        javaLogger.logException(e);
      }
    }
  }
}","private void extractIndexTerm() throws SAXException {
  int topicNum=topicList.size();
  int ditamapNum=ditamapList.size();
  FileInputStream inputStream=null;
  XMLReader xmlReader=null;
  IndexTermReader handler=new IndexTermReader();
  if (System.getProperty(Constants.SAX_DRIVER_PROPERTY) == null) {
    StringUtils.initSaxDriver();
  }
  xmlReader=XMLReaderFactory.createXMLReader();
  try {
    xmlReader.setContentHandler(handler);
    for (int i=0; i < topicNum; i++) {
      String target;
      String targetPathFromMap;
      String targetPathFromMapWithoutExt;
      handler.reset();
      target=(String)topicList.get(i);
      targetPathFromMap=FileUtils.getRelativePathFromMap(inputMap,target);
      targetPathFromMapWithoutExt=targetPathFromMap.substring(0,targetPathFromMap.lastIndexOf(""String_Node_Str""));
      handler.setTargetFile(new StringBuffer(targetPathFromMapWithoutExt).append(targetExt).toString());
      try {
        if (!new File(baseInputDir,target).exists()) {
          javaLogger.logWarn(""String_Node_Str"" + target);
          continue;
        }
        inputStream=new FileInputStream(new File(baseInputDir,target));
        xmlReader.parse(new InputSource(inputStream));
        inputStream.close();
      }
 catch (      Exception e) {
        Properties params=new Properties();
        StringBuffer buff=new StringBuffer();
        String msg=null;
        params.put(""String_Node_Str"",target);
        msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
        javaLogger.logError(buff.append(msg).append(e.getMessage()).toString());
      }
    }
  }
  finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      IOException e) {
        javaLogger.logException(e);
      }
    }
  }
}",0.743973399833749
100877,"private void parseIndexTerm(String localName){
  if (indexTermSpecList.contains(localName)) {
    IndexTerm indexTerm=new IndexTerm();
    IndexTermTarget target=new IndexTermTarget();
    String fragment=null;
    IndexTerm parentTerm=null;
    if (!termStack.isEmpty()) {
      parentTerm=(IndexTerm)termStack.peek();
      if (parentTerm.hasSubTerms()) {
        parentTerm.updateSubTerm();
      }
    }
    if (topicIdStack.peek() == null) {
      fragment=null;
    }
 else {
      fragment=topicIdStack.peek().toString();
    }
    if (title != null) {
      target.setTargetName(title);
    }
 else {
      target.setTargetName(targetFile);
    }
    if (fragment != null)     target.setTargetURI(targetFile + Constants.SHARP + fragment);
 else     target.setTargetURI(targetFile);
    indexTerm.addTarget(target);
    termStack.push(indexTerm);
  }
}","private void parseIndexTerm(String localName){
  if (indexTermSpecList.contains(localName)) {
    IndexTerm indexTerm=new IndexTerm();
    IndexTerm parentTerm=null;
    if (!termStack.isEmpty()) {
      parentTerm=(IndexTerm)termStack.peek();
      if (parentTerm.hasSubTerms()) {
        parentTerm.updateSubTerm();
      }
    }
    termStack.push(indexTerm);
  }
}",0.2868785656071719
100878,"private void parseIndexSeeAlso(String localName){
  if (indexSeeAlsoSpecList.contains(localName)) {
    IndexTerm indexTerm=new IndexTerm();
    IndexTerm parentTerm=null;
    if (!termStack.isEmpty()) {
      parentTerm=(IndexTerm)termStack.peek();
      if (parentTerm.hasSubTerms()) {
        parentTerm.updateSubTerm();
      }
    }
    indexTerm.setTermPrefix(""String_Node_Str"");
    termStack.push(indexTerm);
  }
}","private void parseIndexSeeAlso(String localName){
  if (indexSeeAlsoSpecList.contains(localName)) {
    IndexTerm indexTerm=new IndexTerm();
    IndexTerm parentTerm=null;
    if (!termStack.isEmpty()) {
      parentTerm=(IndexTerm)termStack.peek();
      if (parentTerm.hasSubTerms()) {
        parentTerm.updateSubTerm();
      }
    }
    indexTerm.setTermPrefix(Constants.IndexTerm_Prefix_See_Also);
    termStack.push(indexTerm);
  }
}",0.9466357308584686
100879,"private void parseIndexSee(String localName){
  if (indexSeeSpecList.contains(localName)) {
    IndexTerm indexTerm=new IndexTerm();
    IndexTerm parentTerm=null;
    indexTerm.setTermPrefix(""String_Node_Str"");
    if (!termStack.isEmpty()) {
      parentTerm=(IndexTerm)termStack.peek();
      if (parentTerm.hasSubTerms()) {
        parentTerm.updateSubTerm();
        indexTerm.setTermPrefix(""String_Node_Str"");
      }
    }
    termStack.push(indexTerm);
  }
}","private void parseIndexSee(String localName){
  if (indexSeeSpecList.contains(localName)) {
    IndexTerm indexTerm=new IndexTerm();
    IndexTerm parentTerm=null;
    indexTerm.setTermPrefix(Constants.IndexTerm_Prefix_See);
    if (!termStack.isEmpty()) {
      parentTerm=(IndexTerm)termStack.peek();
      if (parentTerm.hasSubTerms()) {
        parentTerm.updateSubTerm();
        indexTerm.setTermPrefix(Constants.IndexTerm_Prefix_See_Also);
      }
    }
    termStack.push(indexTerm);
  }
}",0.909657320872274
100880,"/** 
 * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String,java.lang.String,java.lang.String)
 */
public void endElement(String uri,String localName,String qName) throws SAXException {
  if (indexTermSpecList.contains(localName)) {
    IndexTerm term=(IndexTerm)termStack.pop();
    if (term.getTermName() == null) {
      term.setTermName(""String_Node_Str"");
      javaLogger.logWarn(MessageUtils.getMessage(""String_Node_Str"").toString());
    }
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermName());
    }
    if (termStack.empty()) {
      indexTermList.add(term);
    }
 else {
      IndexTerm parentTerm=(IndexTerm)termStack.peek();
      parentTerm.addSubTerm(term);
    }
  }
  if (indexSeeSpecList.contains(localName) || indexSeeAlsoSpecList.contains(localName)) {
    IndexTerm term=(IndexTerm)termStack.pop();
    IndexTerm parentTerm=(IndexTerm)termStack.peek();
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermFullName());
    }
    term.addTargets(parentTerm.getTargetList());
    parentTerm.addSubTerm(term);
  }
  if (Constants.ELEMENT_NAME_TITLE.equals(localName)) {
    inTitleElement=false;
    if (!titleMap.containsKey(topicIdStack.peek())) {
      if (titleMap.size() == 0)       defaultTitle=title;
      titleMap.put(topicIdStack.peek(),title);
    }
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=false;
  }
  if (topicSpecList.contains(localName)) {
    topicIdStack.pop();
  }
}","/** 
 * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String,java.lang.String,java.lang.String)
 */
public void endElement(String uri,String localName,String qName) throws SAXException {
  if (indexTermSpecList.contains(localName)) {
    IndexTerm term=(IndexTerm)termStack.pop();
    if (term.getTermName() == null) {
      term.setTermName(""String_Node_Str"");
      javaLogger.logWarn(MessageUtils.getMessage(""String_Node_Str"").toString());
    }
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermName());
    }
    if (term.isLeaf()) {
      IndexTermTarget target=genTarget();
      term.addTarget(target);
    }
    if (termStack.empty()) {
      indexTermList.add(term);
    }
 else {
      IndexTerm parentTerm=(IndexTerm)termStack.peek();
      parentTerm.addSubTerm(term);
    }
  }
  if (indexSeeSpecList.contains(localName) || indexSeeAlsoSpecList.contains(localName)) {
    IndexTerm term=(IndexTerm)termStack.pop();
    IndexTerm parentTerm=(IndexTerm)termStack.peek();
    if (term.getTermKey() == null) {
      term.setTermKey(term.getTermFullName());
    }
    term.addTarget(genTarget());
    parentTerm.addSubTerm(term);
  }
  if (Constants.ELEMENT_NAME_TITLE.equals(localName)) {
    inTitleElement=false;
    if (!titleMap.containsKey(topicIdStack.peek())) {
      if (titleMap.size() == 0)       defaultTitle=title;
      titleMap.put(topicIdStack.peek(),title);
    }
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=false;
  }
  if (topicSpecList.contains(localName)) {
    topicIdStack.pop();
  }
}",0.9554761130971726
100881,"/** 
 * Output the given indexterm into the PrintWriter.  
 * @param term
 * @param printWriter
 */
private void outputIndexTerm(IndexTerm term,PrintWriter printWriter){
  List targets=term.getTargetList();
  List subTerms=term.getSubTerms();
  int targetNum=targets.size();
  int subTermNum=subTerms.size();
  printWriter.println(""String_Node_Str"");
  printWriter.print(""String_Node_Str"");
  printWriter.print(term.getTermFullName());
  printWriter.print(""String_Node_Str"");
  printWriter.println();
  for (int i=0; i < targetNum; i++) {
    IndexTermTarget target=(IndexTermTarget)targets.get(i);
    printWriter.print(""String_Node_Str"");
    printWriter.print(target.getTargetName());
    printWriter.print(""String_Node_Str"");
    printWriter.println();
    printWriter.print(""String_Node_Str"");
    printWriter.print(target.getTargetURI());
    printWriter.print(""String_Node_Str"");
    printWriter.println();
  }
  printWriter.println(""String_Node_Str"");
  if (subTerms != null && subTermNum > 0) {
    printWriter.println(""String_Node_Str"");
    for (int i=0; i < subTermNum; i++) {
      IndexTerm subTerm=(IndexTerm)subTerms.get(i);
      outputIndexTerm(subTerm,printWriter);
    }
    printWriter.println(""String_Node_Str"");
  }
  printWriter.println(""String_Node_Str"");
}","/** 
 * Output the given indexterm into the PrintWriter.  
 * @param term
 * @param printWriter
 */
private void outputIndexTerm(IndexTerm term,PrintWriter printWriter){
  List targets=term.getTargetList();
  List subTerms=term.getSubTerms();
  int targetNum=targets.size();
  int subTermNum=subTerms.size();
  printWriter.println(""String_Node_Str"");
  printWriter.print(""String_Node_Str"");
  printWriter.print(term.getTermFullName());
  printWriter.print(""String_Node_Str"");
  printWriter.println();
  if (targets == null || targets.isEmpty()) {
    targets=new ArrayList(Constants.INT_1);
    findTargets(term,targets);
    targetNum=targets.size();
  }
  for (int i=0; i < targetNum; i++) {
    IndexTermTarget target=(IndexTermTarget)targets.get(i);
    printWriter.print(""String_Node_Str"");
    printWriter.print(target.getTargetName());
    printWriter.print(""String_Node_Str"");
    printWriter.println();
    printWriter.print(""String_Node_Str"");
    printWriter.print(target.getTargetURI());
    printWriter.print(""String_Node_Str"");
    printWriter.println();
  }
  printWriter.println(""String_Node_Str"");
  if (subTerms != null && subTermNum > 0) {
    printWriter.println(""String_Node_Str"");
    for (int i=0; i < subTermNum; i++) {
      IndexTerm subTerm=(IndexTerm)subTerms.get(i);
      outputIndexTerm(subTerm,printWriter);
    }
    printWriter.println(""String_Node_Str"");
  }
  printWriter.println(""String_Node_Str"");
}",0.9429937477013608
100882,"/** 
 * Module execution point
 * @see org.dita.dost.module.AbstractPipelineModule#execute(org.dita.dost.pipeline.AbstractPipelineInput)
 * @author Stephen
 */
public AbstractPipelineOutput execute(AbstractPipelineInput input) throws DITAOTException {
  String ditaInput=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_INPUTMAP);
  String style=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_EXT_PARAM_STYLE);
  String out=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_EXT_PARAM_OUTPUT);
  OutputStreamWriter output=null;
  DITAOTJavaLogger logger=new DITAOTJavaLogger();
  MergeMapParser mapParser=new MergeMapParser();
  String midResult=null;
  StringReader midStream=null;
  File outputDir=null;
  if (ditaInput == null || !new File(ditaInput).exists()) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    return null;
  }
  if (out == null) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    return null;
  }
  mapParser.read(ditaInput);
  midResult=new StringBuffer(Constants.XML_HEAD).append(""String_Node_Str"").append(((StringBuffer)mapParser.getContent().getValue())).append(""String_Node_Str"").toString();
  midStream=new StringReader(midResult);
  try {
    outputDir=new File(out).getParentFile();
    if (!outputDir.exists()) {
      outputDir.mkdirs();
    }
    if (style != null) {
      TransformerFactory factory=TransformerFactory.newInstance();
      Transformer transformer=factory.newTransformer(new StreamSource(new FileInputStream(style)));
      transformer.transform(new StreamSource(midStream),new StreamResult(new File(out)));
    }
 else {
      output=new OutputStreamWriter(new FileOutputStream(out),Constants.UTF8);
      output.write(midResult);
      output.flush();
    }
  }
 catch (  Exception e) {
    logger.logException(e);
  }
 finally {
    try {
      if (output != null) {
        output.close();
      }
      midStream.close();
    }
 catch (    Exception e) {
      logger.logException(e);
    }
  }
  return null;
}","/** 
 * Module execution point
 * @see org.dita.dost.module.AbstractPipelineModule#execute(org.dita.dost.pipeline.AbstractPipelineInput)
 * @author Stephen
 */
public AbstractPipelineOutput execute(AbstractPipelineInput input) throws DITAOTException {
  String ditaInput=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_INPUTMAP);
  String style=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_EXT_PARAM_STYLE);
  String out=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_EXT_PARAM_OUTPUT);
  OutputStreamWriter output=null;
  DITAOTJavaLogger logger=new DITAOTJavaLogger();
  MergeMapParser mapParser=new MergeMapParser();
  String midResult=null;
  StringReader midStream=null;
  File outputDir=null;
  if (ditaInput == null || !new File(ditaInput).exists()) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    return null;
  }
  if (out == null) {
    logger.logError(MessageUtils.getMessage(""String_Node_Str"").toString());
    return null;
  }
  mapParser.read(ditaInput);
  midResult=new StringBuffer(Constants.XML_HEAD).append(""String_Node_Str"").append(((StringBuffer)mapParser.getContent().getValue())).append(""String_Node_Str"").toString();
  midStream=new StringReader(midResult);
  try {
    outputDir=new File(out).getParentFile();
    if (!outputDir.exists()) {
      outputDir.mkdirs();
    }
    if (style != null) {
      TransformerFactory factory=TransformerFactory.newInstance();
      Transformer transformer=factory.newTransformer(new StreamSource(new FileInputStream(style)));
      transformer.transform(new StreamSource(midStream),new StreamResult(new FileOutputStream(new File(out))));
    }
 else {
      output=new OutputStreamWriter(new FileOutputStream(out),Constants.UTF8);
      output.write(midResult);
      output.flush();
    }
  }
 catch (  Exception e) {
    logger.logException(e);
  }
 finally {
    try {
      if (output != null) {
        output.close();
      }
      midStream.close();
    }
 catch (    Exception e) {
      logger.logException(e);
    }
  }
  return null;
}",0.9927710843373494
100883,"/** 
 * Sort term list extracted from dita files base on Locale.
 */
public void sort(){
  int termListSize=termList.size();
  if (IndexTerm.getTermLocale() == null) {
    IndexTerm.setTermLocale(new Locale(Constants.LANGUAGE_EN,Constants.COUNTRY_US));
  }
  for (int i=0; i < termListSize; i++) {
    IndexTerm term=(IndexTerm)termList.get(i);
    term.sortSubTerms();
  }
  Collections.sort(termList);
}","/** 
 * Sort term list extracted from dita files base on Locale.
 */
public void sort(){
  int termListSize=termList.size();
  if (IndexTerm.getTermLocale() == null || IndexTerm.getTermLocale().getLanguage().trim().length() == 0) {
    IndexTerm.setTermLocale(new Locale(Constants.LANGUAGE_EN,Constants.COUNTRY_US));
  }
  for (int i=0; i < termListSize; i++) {
    IndexTerm term=(IndexTerm)termList.get(i);
    term.sortSubTerms();
  }
  Collections.sort(termList);
}",0.9267734553775744
100884,"private void parseAndValidateInput(AbstractPipelineInput input) throws DITAOTException {
  StringTokenizer tokenizer=null;
  Properties prop=new Properties();
  String outputRoot=null;
  int lastIndexOfDot;
  String ditalist;
  Properties params=new Properties();
  PipelineHashIO hashIO=(PipelineHashIO)input;
  String baseDir=hashIO.getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
  String tempDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
  String output=hashIO.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_OUTPUT);
  String encoding=hashIO.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_ENCODING);
  String indextype=hashIO.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_INDEXTYPE);
  inputMap=hashIO.getAttribute(Constants.ANT_INVOKER_PARAM_INPUTMAP);
  targetExt=hashIO.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_TARGETEXT);
  if (!new File(tempDir).isAbsolute()) {
    tempDir=new File(baseDir,tempDir).getAbsolutePath();
  }
  if (!new File(output).isAbsolute()) {
    output=new File(baseDir,output).getAbsolutePath();
  }
  baseInputDir=tempDir;
  ditalist=new File(tempDir,""String_Node_Str"").getAbsolutePath();
  try {
    prop.load(new FileInputStream(ditalist));
  }
 catch (  Exception e) {
    String msg=null;
    params.put(""String_Node_Str"",ditalist);
    msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
    msg=new StringBuffer(msg).append(Constants.LINE_SEPARATOR).append(e.toString()).toString();
    throw new DITAOTException(msg,e);
  }
  tokenizer=new StringTokenizer(prop.getProperty(Constants.FULL_DITA_TOPIC_LIST),Constants.COMMA);
  topicList=new ArrayList(tokenizer.countTokens());
  while (tokenizer.hasMoreTokens()) {
    topicList.add(tokenizer.nextToken());
  }
  tokenizer=new StringTokenizer(prop.getProperty(Constants.FULL_DITAMAP_LIST),Constants.COMMA);
  ditamapList=new ArrayList(tokenizer.countTokens());
  while (tokenizer.hasMoreTokens()) {
    ditamapList.add(tokenizer.nextToken());
  }
  lastIndexOfDot=output.lastIndexOf(""String_Node_Str"");
  outputRoot=(lastIndexOfDot == -1) ? output : output.substring(0,lastIndexOfDot);
  IndexTermCollection.getInstantce().setOutputFileRoot(outputRoot);
  IndexTermCollection.getInstantce().setIndexType(indextype);
  if (encoding != null && encoding.trim().length() > 0) {
    Locale locale=new Locale(encoding.substring(0,2),encoding.substring(3,5));
    IndexTerm.setTermLocale(locale);
  }
}","private void parseAndValidateInput(AbstractPipelineInput input) throws DITAOTException {
  StringTokenizer tokenizer=null;
  Properties prop=new Properties();
  String outputRoot=null;
  int lastIndexOfDot;
  String ditalist;
  Properties params=new Properties();
  PipelineHashIO hashIO=(PipelineHashIO)input;
  String baseDir=hashIO.getAttribute(Constants.ANT_INVOKER_PARAM_BASEDIR);
  String tempDir=((PipelineHashIO)input).getAttribute(Constants.ANT_INVOKER_PARAM_TEMPDIR);
  String output=hashIO.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_OUTPUT);
  String encoding=hashIO.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_ENCODING);
  String indextype=hashIO.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_INDEXTYPE);
  inputMap=hashIO.getAttribute(Constants.ANT_INVOKER_PARAM_INPUTMAP);
  targetExt=hashIO.getAttribute(Constants.ANT_INVOKER_EXT_PARAM_TARGETEXT);
  if (!new File(tempDir).isAbsolute()) {
    tempDir=new File(baseDir,tempDir).getAbsolutePath();
  }
  if (!new File(output).isAbsolute()) {
    output=new File(baseDir,output).getAbsolutePath();
  }
  baseInputDir=tempDir;
  ditalist=new File(tempDir,""String_Node_Str"").getAbsolutePath();
  try {
    prop.load(new FileInputStream(ditalist));
  }
 catch (  Exception e) {
    String msg=null;
    params.put(""String_Node_Str"",ditalist);
    msg=MessageUtils.getMessage(""String_Node_Str"",params).toString();
    msg=new StringBuffer(msg).append(Constants.LINE_SEPARATOR).append(e.toString()).toString();
    throw new DITAOTException(msg,e);
  }
  tokenizer=new StringTokenizer(prop.getProperty(Constants.FULL_DITA_TOPIC_LIST),Constants.COMMA);
  topicList=new ArrayList(tokenizer.countTokens());
  while (tokenizer.hasMoreTokens()) {
    topicList.add(tokenizer.nextToken());
  }
  tokenizer=new StringTokenizer(prop.getProperty(Constants.FULL_DITAMAP_LIST),Constants.COMMA);
  ditamapList=new ArrayList(tokenizer.countTokens());
  while (tokenizer.hasMoreTokens()) {
    ditamapList.add(tokenizer.nextToken());
  }
  lastIndexOfDot=output.lastIndexOf(""String_Node_Str"");
  outputRoot=(lastIndexOfDot == -1) ? output : output.substring(0,lastIndexOfDot);
  IndexTermCollection.getInstantce().setOutputFileRoot(outputRoot);
  IndexTermCollection.getInstantce().setIndexType(indextype);
  if (encoding != null && encoding.trim().length() > 0) {
    IndexTerm.setTermLocale(StringUtils.getLocale(encoding));
  }
}",0.9779534109816972
100885,"/** 
 * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)
 */
public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  String classAttr=attributes.getValue(Constants.ATTRIBUTE_NAME_CLASS);
  handleSpecialization(localName,classAttr);
  parseTopic(localName,attributes.getValue(Constants.ATTRIBUTE_NAME_ID));
  parseIndexTerm(localName);
  parseIndexSee(localName);
  parseIndexSeeAlso(localName);
  if (IndexTerm.getTermLocale() == null) {
    String xmlLang=attributes.getValue(Constants.ATTRIBUTE_NAME_XML_LANG);
    if (xmlLang != null) {
      Locale locale;
      if (xmlLang.length() == 5) {
        locale=new Locale(xmlLang.substring(0,2).toLowerCase(),xmlLang.substring(3,5).toUpperCase());
      }
 else {
        locale=new Locale(xmlLang.substring(0,2).toLowerCase());
      }
      IndexTerm.setTermLocale(locale);
    }
  }
  if (Constants.ELEMENT_NAME_TITLE.equals(localName) && !titleMap.containsKey(topicIdStack.peek())) {
    inTitleElement=true;
    title=null;
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=true;
  }
}","/** 
 * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)
 */
public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  String classAttr=attributes.getValue(Constants.ATTRIBUTE_NAME_CLASS);
  handleSpecialization(localName,classAttr);
  parseTopic(localName,attributes.getValue(Constants.ATTRIBUTE_NAME_ID));
  parseIndexTerm(localName);
  parseIndexSee(localName);
  parseIndexSeeAlso(localName);
  if (IndexTerm.getTermLocale() == null) {
    String xmlLang=attributes.getValue(Constants.ATTRIBUTE_NAME_XML_LANG);
    if (xmlLang != null) {
      Locale locale;
      IndexTerm.setTermLocale(StringUtils.getLocale(xmlLang));
    }
  }
  if (Constants.ELEMENT_NAME_TITLE.equals(localName) && !titleMap.containsKey(topicIdStack.peek())) {
    inTitleElement=true;
    title=null;
  }
  if (indexSortAsSpecList.contains(localName)) {
    insideSortingAs=true;
  }
}",0.8597449908925319
100886,"/** 
 * @see org.xml.sax.ContentHandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)
 */
public void startElement(String uri,String localName,String qName,Attributes atts) throws SAXException {
  String scopeValue=null;
  String formatValue=null;
  String fileId=null;
  int attsLen=atts.getLength();
  mapInfo.append(Constants.LESS_THAN).append(qName);
  for (int i=0; i < attsLen; i++) {
    String attQName=atts.getQName(i);
    String attValue=atts.getValue(i);
    if (Constants.ATTRIBUTE_NAME_HREF.equals(attQName) && !StringUtils.isEmptyString(attValue)) {
      scopeValue=atts.getValue(Constants.ATTRIBUTE_NAME_SCOPE);
      formatValue=atts.getValue(Constants.ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || Constants.ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || Constants.ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        if (util.isVisited(attValue)) {
          mapInfo.append(Constants.STRING_BLANK).append(""String_Node_Str"").append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
          attValue=new StringBuffer(Constants.SHARP).append(util.getIdValue(attValue)).toString();
        }
 else {
          mapInfo.append(Constants.STRING_BLANK).append(""String_Node_Str"").append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
          fileId=topicParser.parse(attValue,dirPath);
          util.visit(attValue);
          attValue=new StringBuffer(Constants.SHARP).append(fileId).toString();
        }
      }
    }
    mapInfo.append(Constants.STRING_BLANK).append(attQName).append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
  }
  mapInfo.append(Constants.GREATER_THAN);
}","/** 
 * @see org.xml.sax.ContentHandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)
 */
public void startElement(String uri,String localName,String qName,Attributes atts) throws SAXException {
  String scopeValue=null;
  String formatValue=null;
  String classValue=null;
  String fileId=null;
  int attsLen=atts.getLength();
  mapInfo.append(Constants.LESS_THAN).append(qName);
  for (int i=0; i < attsLen; i++) {
    String attQName=atts.getQName(i);
    String attValue=atts.getValue(i);
    if (Constants.ATTRIBUTE_NAME_HREF.equals(attQName) && !StringUtils.isEmptyString(attValue) && classValue != null && classValue.indexOf(Constants.ATTR_CLASS_VALUE_TOPICREF) != -1) {
      scopeValue=atts.getValue(Constants.ATTRIBUTE_NAME_SCOPE);
      formatValue=atts.getValue(Constants.ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || Constants.ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || Constants.ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        if (util.isVisited(attValue)) {
          mapInfo.append(Constants.STRING_BLANK).append(""String_Node_Str"").append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
          attValue=new StringBuffer(Constants.SHARP).append(util.getIdValue(attValue)).toString();
        }
 else {
          mapInfo.append(Constants.STRING_BLANK).append(""String_Node_Str"").append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
          fileId=topicParser.parse(attValue,dirPath);
          util.visit(attValue);
          attValue=new StringBuffer(Constants.SHARP).append(fileId).toString();
        }
      }
    }
    mapInfo.append(Constants.STRING_BLANK).append(attQName).append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
  }
  mapInfo.append(Constants.GREATER_THAN);
}",0.9710330684439888
100887,"/** 
 * @see org.xml.sax.ContentHandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)
 */
public void startElement(String uri,String localName,String qName,Attributes atts) throws SAXException {
  String scopeValue=null;
  String formatValue=null;
  String classValue=null;
  String fileId=null;
  int attsLen=atts.getLength();
  mapInfo.append(Constants.LESS_THAN).append(qName);
  for (int i=0; i < attsLen; i++) {
    String attQName=atts.getQName(i);
    String attValue=atts.getValue(i);
    if (Constants.ATTRIBUTE_NAME_HREF.equals(attQName) && !StringUtils.isEmptyString(attValue) && classValue != null && classValue.indexOf(Constants.ATTR_CLASS_VALUE_TOPICREF) != -1) {
      scopeValue=atts.getValue(Constants.ATTRIBUTE_NAME_SCOPE);
      formatValue=atts.getValue(Constants.ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || Constants.ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || Constants.ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        if (util.isVisited(attValue)) {
          mapInfo.append(Constants.STRING_BLANK).append(""String_Node_Str"").append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
          attValue=new StringBuffer(Constants.SHARP).append(util.getIdValue(attValue)).toString();
        }
 else {
          mapInfo.append(Constants.STRING_BLANK).append(""String_Node_Str"").append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
          fileId=topicParser.parse(attValue,dirPath);
          util.visit(attValue);
          attValue=new StringBuffer(Constants.SHARP).append(fileId).toString();
        }
      }
    }
    mapInfo.append(Constants.STRING_BLANK).append(attQName).append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
  }
  mapInfo.append(Constants.GREATER_THAN);
}","/** 
 * @see org.xml.sax.ContentHandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)
 */
public void startElement(String uri,String localName,String qName,Attributes atts) throws SAXException {
  String scopeValue=null;
  String formatValue=null;
  String classValue=null;
  String fileId=null;
  int attsLen=atts.getLength();
  mapInfo.append(Constants.LESS_THAN).append(qName);
  classValue=atts.getValue(Constants.ATTRIBUTE_NAME_CLASS);
  for (int i=0; i < attsLen; i++) {
    String attQName=atts.getQName(i);
    String attValue=atts.getValue(i);
    if (Constants.ATTRIBUTE_NAME_HREF.equals(attQName) && !StringUtils.isEmptyString(attValue) && classValue != null && classValue.indexOf(Constants.ATTR_CLASS_VALUE_TOPICREF) != -1) {
      scopeValue=atts.getValue(Constants.ATTRIBUTE_NAME_SCOPE);
      formatValue=atts.getValue(Constants.ATTRIBUTE_NAME_FORMAT);
      if ((scopeValue == null || Constants.ATTR_SCOPE_VALUE_LOCAL.equalsIgnoreCase(scopeValue)) && (formatValue == null || Constants.ATTR_FORMAT_VALUE_DITA.equalsIgnoreCase(formatValue))) {
        if (util.isVisited(attValue)) {
          mapInfo.append(Constants.STRING_BLANK).append(""String_Node_Str"").append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
          attValue=new StringBuffer(Constants.SHARP).append(util.getIdValue(attValue)).toString();
        }
 else {
          mapInfo.append(Constants.STRING_BLANK).append(""String_Node_Str"").append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
          fileId=topicParser.parse(attValue,dirPath);
          util.visit(attValue);
          attValue=new StringBuffer(Constants.SHARP).append(fileId).toString();
        }
      }
    }
    mapInfo.append(Constants.STRING_BLANK).append(attQName).append(Constants.EQUAL).append(Constants.QUOTATION).append(StringUtils.escapeXML(attValue)).append(Constants.QUOTATION);
  }
  mapInfo.append(Constants.GREATER_THAN);
}",0.9852724594992636
100888,"/** 
 * @see org.xml.sax.helpers.DefaultHandler#characters(char[],int,int)
 */
public void characters(char[] ch,int start,int length) throws SAXException {
  String temp=new String(ch,start,length).trim();
  boolean withSpace=(ch[start] == '\n' || temp.startsWith(Constants.LINE_SEPARATOR));
  if (temp.length() == 0) {
    return;
  }
  if (!termStack.empty()) {
    IndexTerm indexTerm=(IndexTerm)termStack.peek();
    temp=StringUtils.restoreEntity(temp);
    indexTerm.setTermName(StringUtils.setOrAppend(indexTerm.getTermName(),temp,withSpace));
  }
 else   if (insideSortingAs && temp.length() > 0) {
    IndexTerm indexTerm=(IndexTerm)termStack.peek();
    temp=StringUtils.restoreEntity(temp);
    indexTerm.setTermKey(StringUtils.setOrAppend(indexTerm.getTermKey(),temp,withSpace));
  }
 else   if (inTitleElement) {
    temp=StringUtils.restoreEntity(temp);
    title=StringUtils.setOrAppend(title,temp,true);
  }
}","/** 
 * @see org.xml.sax.helpers.DefaultHandler#characters(char[],int,int)
 */
public void characters(char[] ch,int start,int length) throws SAXException {
  String temp=new String(ch,start,length).trim();
  boolean withSpace=(ch[start] == '\n' || temp.startsWith(Constants.LINE_SEPARATOR));
  if (temp.length() == 0) {
    return;
  }
  if (!insideSortingAs && !termStack.empty()) {
    IndexTerm indexTerm=(IndexTerm)termStack.peek();
    temp=StringUtils.restoreEntity(temp);
    indexTerm.setTermName(StringUtils.setOrAppend(indexTerm.getTermName(),temp,withSpace));
  }
 else   if (insideSortingAs && temp.length() > 0) {
    IndexTerm indexTerm=(IndexTerm)termStack.peek();
    temp=StringUtils.restoreEntity(temp);
    indexTerm.setTermKey(StringUtils.setOrAppend(indexTerm.getTermKey(),temp,withSpace));
  }
 else   if (inTitleElement) {
    temp=StringUtils.restoreEntity(temp);
    title=StringUtils.setOrAppend(title,temp,true);
  }
}",0.7497326203208556
100889,"/** 
 * @param rootPath
 * @param relativePath
 * @return
 */
public static String resolveDirectory(String rootPath,String relativePath){
  if (relativePath.indexOf('#') != -1) {
    relativePath=relativePath.substring(0,relativePath.indexOf('#'));
  }
  relativePath=relativePath.replace('\\',File.separatorChar);
  relativePath=relativePath.replace('/',File.separatorChar);
  if (rootPath == null) {
    return relativePath;
  }
  String prefix=null;
  if (rootPath.charAt(rootPath.length() - 1) == File.separatorChar) {
    prefix=rootPath.substring(0,rootPath.length() - 1);
  }
 else {
    prefix=rootPath;
  }
  String postfix=relativePath;
  if (relativePath.startsWith(""String_Node_Str"")) {
    int sepPos=relativePath.indexOf(File.separatorChar);
    int lastPos=prefix.lastIndexOf(File.separatorChar);
    postfix=relativePath.substring(sepPos == -1 ? 0 : sepPos + File.separator.length(),relativePath.length());
    if (lastPos == -1) {
      return postfix;
    }
    prefix=prefix.substring(0,lastPos);
  }
  return prefix + File.separatorChar + postfix;
}","/** 
 * @param rootPath
 * @param relativePath
 * @return
 */
public static String resolveDirectory(String rootPath,String relativePath){
  if (relativePath.indexOf('#') != -1) {
    relativePath=relativePath.substring(0,relativePath.indexOf('#'));
  }
  relativePath=relativePath.replace('\\',File.separatorChar);
  relativePath=relativePath.replace('/',File.separatorChar);
  if (rootPath == null) {
    return relativePath;
  }
  String prefix=null;
  if (rootPath.charAt(rootPath.length() - 1) == File.separatorChar) {
    prefix=rootPath.substring(0,rootPath.length() - 1);
  }
 else {
    prefix=rootPath;
  }
  String postfix=relativePath;
  while (postfix.startsWith(""String_Node_Str"")) {
    int sepPos=postfix.indexOf(File.separatorChar);
    int lastPos=prefix.lastIndexOf(File.separatorChar);
    postfix=postfix.substring(sepPos == -1 ? 0 : sepPos + File.separator.length(),postfix.length());
    if (lastPos == -1) {
      return postfix;
    }
    prefix=prefix.substring(0,lastPos);
  }
  return prefix + File.separatorChar + postfix;
}",0.958981612446959
100890,"/** 
 * Parses the command line arguments and provides feedback to the main class.
 * @return A boolean value if there is a file to be processed by arara.
 */
public boolean parse(){
  Option optVersion=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optHelp=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optLog=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optVerbose=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optTimeout=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  Option optLanguage=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  Option optDryRun=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optMaxNumberLoops=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  commandLineOptions.addOption(optVersion);
  commandLineOptions.addOption(optHelp);
  commandLineOptions.addOption(optLog);
  commandLineOptions.addOption(optVerbose);
  commandLineOptions.addOption(optTimeout);
  commandLineOptions.addOption(optLanguage);
  commandLineOptions.addOption(optDryRun);
  commandLineOptions.addOption(optMaxNumberLoops);
  CommandLineParser parser=new BasicParser();
  try {
    CommandLine line=parser.parse(commandLineOptions,theArgs);
    if (line.hasOption(""String_Node_Str"")) {
      LanguageController language=new LanguageController();
      if (!language.setLanguage(line.getOptionValue(""String_Node_Str""))) {
        language.printLanguageHelp();
        printUsage();
        return false;
      }
 else {
        optVersion.setDescription(localization.getMessage(""String_Node_Str""));
        optHelp.setDescription(localization.getMessage(""String_Node_Str""));
        optLog.setDescription(localization.getMessage(""String_Node_Str""));
        optVerbose.setDescription(localization.getMessage(""String_Node_Str""));
        optTimeout.setDescription(localization.getMessage(""String_Node_Str""));
        optLanguage.setDescription(localization.getMessage(""String_Node_Str""));
        optDryRun.setDescription(localization.getMessage(""String_Node_Str""));
        optMaxNumberLoops.setDescription(localization.getMessage(""String_Node_Str""));
      }
    }
    if (line.hasOption(""String_Node_Str"")) {
      printVersion();
      printUsage();
      return false;
    }
 else {
      if (line.hasOption(""String_Node_Str"")) {
        printVersion();
        printSpecialThanks();
        return false;
      }
 else {
        String[] files=line.getArgs();
        if (files.length != 1) {
          printVersion();
          printUsage();
          return false;
        }
 else {
          if (line.hasOption(""String_Node_Str"")) {
            try {
              executionTimeout=Long.parseLong(line.getOptionValue(""String_Node_Str""));
              if (executionTimeout <= 0) {
                printVersion();
                printUsage();
                return false;
              }
            }
 catch (            NumberFormatException numberFormatException) {
              printVersion();
              printUsage();
              return false;
            }
          }
 else {
            executionTimeout=0;
          }
          if (line.hasOption(""String_Node_Str"")) {
            try {
              maximumNumberOfLoops=Long.parseLong(line.getOptionValue(""String_Node_Str""));
              if (maximumNumberOfLoops <= 0) {
                printVersion();
                printUsage();
                return false;
              }
            }
 catch (            NumberFormatException numberFormatException) {
              printVersion();
              printUsage();
              return false;
            }
          }
 else {
            maximumNumberOfLoops=AraraConstants.MAXLOOPS;
          }
          AraraLogging.enableLogging(line.hasOption(""String_Node_Str""));
          showVerboseOutput=line.hasOption(""String_Node_Str"");
          if (line.hasOption(""String_Node_Str"")) {
            showVerboseOutput=false;
            dryRun=true;
          }
          theFile=files[0];
          if (!checkFile(theFile,configuration.getValidExtensions())) {
            return false;
          }
          return true;
        }
      }
    }
  }
 catch (  ParseException parseException) {
    printVersion();
    printUsage();
    return false;
  }
}","/** 
 * Parses the command line arguments and provides feedback to the main class.
 * @return A boolean value if there is a file to be processed by arara.
 */
public boolean parse(){
  Option optVersion=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optHelp=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optLog=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optVerbose=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optTimeout=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  Option optLanguage=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  Option optDryRun=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optMaxNumberLoops=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  commandLineOptions.addOption(optVersion);
  commandLineOptions.addOption(optHelp);
  commandLineOptions.addOption(optLog);
  commandLineOptions.addOption(optVerbose);
  commandLineOptions.addOption(optTimeout);
  commandLineOptions.addOption(optLanguage);
  commandLineOptions.addOption(optDryRun);
  commandLineOptions.addOption(optMaxNumberLoops);
  CommandLineParser parser=new BasicParser();
  try {
    CommandLine line=parser.parse(commandLineOptions,theArgs);
    if (line.hasOption(""String_Node_Str"")) {
      LanguageController language=new LanguageController();
      if (!language.setLanguage(line.getOptionValue(""String_Node_Str""))) {
        language.printLanguageHelp();
        printUsage();
        return false;
      }
 else {
        optVersion.setDescription(localization.getMessage(""String_Node_Str""));
        optHelp.setDescription(localization.getMessage(""String_Node_Str""));
        optLog.setDescription(localization.getMessage(""String_Node_Str""));
        optVerbose.setDescription(localization.getMessage(""String_Node_Str""));
        optTimeout.setDescription(localization.getMessage(""String_Node_Str""));
        optLanguage.setDescription(localization.getMessage(""String_Node_Str""));
        optDryRun.setDescription(localization.getMessage(""String_Node_Str""));
        optMaxNumberLoops.setDescription(localization.getMessage(""String_Node_Str""));
      }
    }
    if (line.hasOption(""String_Node_Str"")) {
      printVersion();
      printUsage();
      return false;
    }
 else {
      if (line.hasOption(""String_Node_Str"")) {
        printVersion();
        printSpecialThanks();
        return false;
      }
 else {
        String[] files=line.getArgs();
        if (files.length != 1) {
          printVersion();
          printUsage();
          return false;
        }
 else {
          if (line.hasOption(""String_Node_Str"")) {
            try {
              executionTimeout=Long.parseLong(line.getOptionValue(""String_Node_Str""));
              if (executionTimeout <= 0) {
                printVersion();
                printUsage();
                return false;
              }
            }
 catch (            NumberFormatException numberFormatException) {
              printVersion();
              printUsage();
              return false;
            }
          }
 else {
            executionTimeout=0;
          }
          if (line.hasOption(""String_Node_Str"")) {
            try {
              maximumNumberOfLoops=Long.parseLong(line.getOptionValue(""String_Node_Str""));
              if (maximumNumberOfLoops <= 0) {
                printVersion();
                printUsage();
                return false;
              }
            }
 catch (            NumberFormatException numberFormatException) {
              printVersion();
              printUsage();
              return false;
            }
          }
 else {
            maximumNumberOfLoops=AraraConstants.MAXLOOPS;
          }
          AraraLogging.enableLogging(line.hasOption(""String_Node_Str""));
          showVerboseOutput=line.hasOption(""String_Node_Str"");
          if (line.hasOption(""String_Node_Str"")) {
            showVerboseOutput=false;
            dryRun=true;
          }
          theFile=files[0];
          if (!checkFile(theFile,configuration.getValidExtensions())) {
            return false;
          }
          return true;
        }
      }
    }
  }
 catch (  ParseException parseException) {
    printVersion();
    printUsage();
    return false;
  }
}",0.999244631488076
100891,"/** 
 * The main method. The idea is to provide to arara only the supported file name and let it handle. The application will remove the file extension (if any) and call the other helper classes.
 * @param args The command line arguments. In fact, arara supports a lot offlags, all listed in the CommandLineAnalyzer class.
 */
public static void main(String[] args){
  int exitStatus;
  try {
    AraraUtils.printHeader();
    ConfigurationLoader configuration=new ConfigurationLoader();
    configuration.load();
    CommandLineAnalyzer commandLine=new CommandLineAnalyzer(args,configuration);
    if (!commandLine.parse()) {
      exitStatus=0;
      System.exit(exitStatus);
    }
    File file;
    file=new File(commandLine.getFile());
    logger.info(localization.getMessage(""String_Node_Str"",AraraConstants.VERSION));
    logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
    DirectiveExtractor dirExtractor=new DirectiveExtractor(file,configuration);
    dirExtractor.extract();
    List<AraraDirective> directives=dirExtractor.getDirectives();
    boolean overallResult=true;
    if (!directives.isEmpty()) {
      DirectiveParser dirParser=new DirectiveParser(directives);
      dirParser.setFile(file);
      TaskDeployer taskDeployer=new TaskDeployer(dirParser.parse(),configuration);
      CommandTrigger commandTrigger=new CommandTrigger(taskDeployer.deploy());
      commandTrigger.setVerbose(commandLine.isVerbose());
      commandTrigger.setDryRun(commandLine.isDryRun());
      commandTrigger.setExecutionTimeout(commandLine.getExecutionTimeout());
      commandTrigger.setMaximumNumberOfLoops(commandLine.getMaximumNumberOfLoops());
      overallResult=commandTrigger.execute();
    }
 else {
      logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
      System.out.println(AraraUtils.wrap(localization.getMessage(""String_Node_Str"",file.getName())));
    }
    logger.info(localization.getMessage(""String_Node_Str""));
    if (overallResult) {
      exitStatus=0;
    }
 else {
      exitStatus=1;
    }
  }
 catch (  Exception exception) {
    System.out.println(AraraUtils.wrap(exception.getMessage()));
    logger.error(localization.getMessage(""String_Node_Str""));
    logger.error(exception.getMessage());
    exitStatus=1;
  }
  System.exit(exitStatus);
}","/** 
 * The main method. The idea is to provide to arara only the supported file name and let it handle. The application will remove the file extension (if any) and call the other helper classes.
 * @param args The command line arguments. In fact, arara supports a lot offlags, all listed in the CommandLineAnalyzer class.
 */
public static void main(String[] args){
  int exitStatus;
  try {
    AraraUtils.printHeader();
    ConfigurationLoader configuration=new ConfigurationLoader();
    configuration.load();
    CommandLineAnalyzer commandLine=new CommandLineAnalyzer(args,configuration);
    if (!commandLine.parse()) {
      exitStatus=0;
      System.exit(exitStatus);
    }
    File file;
    file=new File(commandLine.getFile());
    ConditionalMethods.setAbsolutePath(file);
    AraraDatabase.setAbsolutePath(file);
    logger.info(localization.getMessage(""String_Node_Str"",AraraConstants.VERSION));
    logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
    DirectiveExtractor dirExtractor=new DirectiveExtractor(file,configuration);
    dirExtractor.extract();
    List<AraraDirective> directives=dirExtractor.getDirectives();
    boolean overallResult=true;
    if (!directives.isEmpty()) {
      DirectiveParser dirParser=new DirectiveParser(directives);
      dirParser.setFile(file);
      TaskDeployer taskDeployer=new TaskDeployer(dirParser.parse(),configuration);
      CommandTrigger commandTrigger=new CommandTrigger(taskDeployer.deploy());
      commandTrigger.setVerbose(commandLine.isVerbose());
      commandTrigger.setDryRun(commandLine.isDryRun());
      commandTrigger.setExecutionTimeout(commandLine.getExecutionTimeout());
      commandTrigger.setMaximumNumberOfLoops(commandLine.getMaximumNumberOfLoops());
      overallResult=commandTrigger.execute();
    }
 else {
      logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
      System.out.println(AraraUtils.wrap(localization.getMessage(""String_Node_Str"",file.getName())));
    }
    logger.info(localization.getMessage(""String_Node_Str""));
    if (overallResult) {
      exitStatus=0;
    }
 else {
      exitStatus=1;
    }
  }
 catch (  Exception exception) {
    System.out.println(AraraUtils.wrap(exception.getMessage()));
    logger.error(localization.getMessage(""String_Node_Str""));
    logger.error(exception.getMessage());
    exitStatus=1;
  }
  System.exit(exitStatus);
}",0.9816106531388712
100892,"/** 
 * Loads the XML file and maps the content to a hashmap.
 * @return A hashmap containing all data from the XML file, hopefully thefilename and its corresponding hash.
 * @throws com.github.arara.exception.AraraException if something badhappens, including a malformed XML or an encoding problem.
 */
public static HashMap load() throws AraraException {
  try {
    FileInputStream inputStream=new FileInputStream(AraraConstants.ARARADATABASE);
    Reader reader=new InputStreamReader(inputStream,""String_Node_Str"");
    XStream xstream=new XStream();
    HashMap map=(HashMap)xstream.fromXML(reader);
    reader.close();
    inputStream.close();
    return map;
  }
 catch (  FileNotFoundException fnfe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  UnsupportedEncodingException uee) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  XStreamException xe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  IOException ioe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
}","/** 
 * Loads the XML file and maps the content to a hashmap.
 * @return A hashmap containing all data from the XML file, hopefully thefilename and its corresponding hash.
 * @throws com.github.arara.exception.AraraException if something badhappens, including a malformed XML or an encoding problem.
 */
public static HashMap load() throws AraraException {
  try {
    FileInputStream inputStream=new FileInputStream(absolutePath.concat(File.separator).concat(AraraConstants.ARARADATABASE));
    Reader reader=new InputStreamReader(inputStream,""String_Node_Str"");
    XStream xstream=new XStream();
    HashMap map=(HashMap)xstream.fromXML(reader);
    reader.close();
    inputStream.close();
    return map;
  }
 catch (  FileNotFoundException fnfe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  UnsupportedEncodingException uee) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  XStreamException xe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  IOException ioe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
}",0.9826224328593997
100893,"/** 
 * Saves the hashmap into a XML file.
 * @param map A hashmap containing all data from files and theircorresponding hashes.
 * @throws com.github.arara.exception.AraraException if something badhappens.
 */
public static void save(HashMap map) throws AraraException {
  try {
    FileOutputStream outputStream=new FileOutputStream(AraraConstants.ARARADATABASE);
    OutputStreamWriter writer=new OutputStreamWriter(outputStream,""String_Node_Str"");
    XStream xstream=new XStream();
    xstream.toXML(map,writer);
    writer.close();
    outputStream.close();
  }
 catch (  UnsupportedEncodingException uee) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  XStreamException xe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  IOException ioe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
}","/** 
 * Saves the hashmap into a XML file.
 * @param map A hashmap containing all data from files and theircorresponding hashes.
 * @throws com.github.arara.exception.AraraException if something badhappens.
 */
public static void save(HashMap map) throws AraraException {
  try {
    FileOutputStream outputStream=new FileOutputStream(absolutePath.concat(File.separator).concat(AraraConstants.ARARADATABASE));
    OutputStreamWriter writer=new OutputStreamWriter(outputStream,""String_Node_Str"");
    XStream xstream=new XStream();
    xstream.toXML(map,writer);
    writer.close();
    outputStream.close();
  }
 catch (  UnsupportedEncodingException uee) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  XStreamException xe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  IOException ioe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
}",0.9783889980353636
100894,"/** 
 * Checks if the XML file exists in the current directory.
 * @return a boolean indicating if the XML file exists in the currentdirectory.
 */
public static boolean exists(){
  return ConditionalMethods.exists(AraraConstants.ARARADATABASE);
}","/** 
 * Checks if the XML file exists in the current directory.
 * @return a boolean indicating if the XML file exists in the currentdirectory.
 */
public static boolean exists(){
  return ConditionalMethods.exists(absolutePath.concat(File.separator).concat(AraraConstants.ARARADATABASE));
}",0.9182156133828996
100895,"/** 
 * Executes the arara commands provided in the list.
 * @return A boolean value about the execution. To be honest, I don't thinkit's necessary to return an actual value, but I kept it for possible future use.
 * @throws com.github.arara.exception.AraraException Raised when the commandis not found in the underlying system.
 */
public boolean execute() throws AraraException {
  logger.info(localization.getMessage(""String_Node_Str""));
  for (  AraraCommand currentAraraCommand : commands) {
    if (dryRun == false) {
      ConditionalMethods.setBasenameReference(AraraMethods.getBasename(currentAraraCommand.getFilename()));
      if ((currentAraraCommand.getConditional().getType() == AraraConditionalType.IF) || (currentAraraCommand.getConditional().getType() == AraraConditionalType.WHILE)) {
        if (ConditionalEvaluator.evaluate(currentAraraCommand.getConditional().getCondition()) == false) {
          continue;
        }
      }
      if (AraraUtils.haltFromAraraTrigger(currentAraraCommand.getCommand())) {
        break;
      }
      long counter=0;
      boolean condition;
      do {
        System.out.print(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()).concat(""String_Node_Str""));
        if (showVerboseOutput) {
          System.out.println(""String_Node_Str"");
        }
        logger.info(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
        logger.trace(localization.getMessage(""String_Node_Str"",currentAraraCommand.getCommand()));
        if (runCommand(currentAraraCommand)) {
          System.out.println(localization.getMessage(""String_Node_Str""));
          logger.info(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
        }
 else {
          System.out.println(localization.getMessage(""String_Node_Str""));
          logger.warn(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
          return false;
        }
        if (showVerboseOutput) {
          System.out.println(""String_Node_Str"");
        }
        if (currentAraraCommand.getConditional().isEmpty()) {
          break;
        }
        counter++;
        condition=ConditionalEvaluator.evaluate(currentAraraCommand.getConditional().getCondition());
        if (currentAraraCommand.getConditional().getType() == AraraConditionalType.UNTIL) {
          condition=!condition;
        }
      }
 while (condition && (counter <= maximumNumberOfLoops));
    }
 else {
      if (AraraUtils.haltFromAraraTrigger(currentAraraCommand.getCommand())) {
        break;
      }
      System.out.println(currentAraraCommand.getName() + ""String_Node_Str"" + currentAraraCommand.getCommand());
    }
  }
  logger.info(localization.getMessage(""String_Node_Str""));
  return true;
}","/** 
 * Executes the arara commands provided in the list.
 * @return A boolean value about the execution. To be honest, I don't thinkit's necessary to return an actual value, but I kept it for possible future use.
 * @throws com.github.arara.exception.AraraException Raised when the commandis not found in the underlying system.
 */
public boolean execute() throws AraraException {
  logger.info(localization.getMessage(""String_Node_Str""));
  for (  AraraCommand currentAraraCommand : commands) {
    if (dryRun == false) {
      ConditionalMethods.setBasenameReference(AraraMethods.getBasename(currentAraraCommand.getFilename()));
      if ((currentAraraCommand.getConditional().getType() == AraraConditionalType.IF) || (currentAraraCommand.getConditional().getType() == AraraConditionalType.WHILE)) {
        if (ConditionalEvaluator.evaluate(currentAraraCommand.getConditional().getCondition()) == false) {
          continue;
        }
      }
      if (AraraUtils.haltFromAraraTrigger(currentAraraCommand.getCommand())) {
        break;
      }
      long counter=0;
      boolean condition;
      do {
        System.out.print(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()).concat(""String_Node_Str""));
        if (showVerboseOutput) {
          System.out.println(""String_Node_Str"");
        }
        logger.info(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
        logger.trace(localization.getMessage(""String_Node_Str"",currentAraraCommand.getCommand()));
        if (runCommand(currentAraraCommand)) {
          System.out.println(localization.getMessage(""String_Node_Str""));
          logger.info(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
        }
 else {
          System.out.println(localization.getMessage(""String_Node_Str""));
          logger.warn(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
          return false;
        }
        if (showVerboseOutput) {
          System.out.println(""String_Node_Str"");
        }
        if (currentAraraCommand.getConditional().isEmpty() || currentAraraCommand.getConditional().getType() == AraraConditionalType.IF) {
          break;
        }
        counter++;
        condition=ConditionalEvaluator.evaluate(currentAraraCommand.getConditional().getCondition());
        if (currentAraraCommand.getConditional().getType() == AraraConditionalType.UNTIL) {
          condition=!condition;
        }
      }
 while (condition && (counter <= maximumNumberOfLoops));
    }
 else {
      if (AraraUtils.haltFromAraraTrigger(currentAraraCommand.getCommand())) {
        break;
      }
      System.out.println(currentAraraCommand.getName() + ""String_Node_Str"" + currentAraraCommand.getCommand());
    }
  }
  logger.info(localization.getMessage(""String_Node_Str""));
  return true;
}",0.986315976541674
100896,"/** 
 * Evaluates the conditional.
 * @param conditional The conditional.
 * @return A boolean indicating the conditional resolution.
 * @throws com.github.arara.exception.AraraException An exception is raisedin case of error.
 */
public static boolean evaluate(String conditional) throws AraraException {
  if (""String_Node_Str"".equals(conditional)) {
    return true;
  }
  HashMap map=new HashMap();
  try {
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class,String.class));
  }
 catch (  NoSuchMethodException nsme) {
  }
  try {
    Object result=TemplateRuntime.eval(""String_Node_Str"".concat(conditional).concat(""String_Node_Str""),map);
    if (!(result instanceof Boolean)) {
      throw new AraraException(localization.getMessage(""String_Node_Str"").concat(""String_Node_Str"").concat(conditional));
    }
 else {
      return ((Boolean)result).booleanValue();
    }
  }
 catch (  RuntimeException runtimeException) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraUtils.getVariableFromException(runtimeException)));
  }
}","/** 
 * Evaluates the conditional.
 * @param conditional The conditional.
 * @return A boolean indicating the conditional resolution.
 * @throws com.github.arara.exception.AraraException An exception is raisedin case of error.
 */
public static boolean evaluate(String conditional) throws AraraException {
  if (""String_Node_Str"".equals(conditional)) {
    return true;
  }
  HashMap map=new HashMap();
  try {
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class,String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
  }
 catch (  NoSuchMethodException nsme) {
  }
  try {
    Object result=TemplateRuntime.eval(""String_Node_Str"".concat(conditional).concat(""String_Node_Str""),map);
    if (!(result instanceof Boolean)) {
      throw new AraraException(localization.getMessage(""String_Node_Str"").concat(""String_Node_Str"").concat(conditional));
    }
 else {
      return ((Boolean)result).booleanValue();
    }
  }
 catch (  RuntimeException runtimeException) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraUtils.getVariableFromException(runtimeException)));
  }
}",0.8974093264248705
100897,"/** 
 * Discovers name based on some tricky rules.
 * @param value The value to be analyzed.
 * @param prefix The file prefix.
 * @return The new discovered name.
 */
private static String discoverName(String value,String prefix){
  if (value.lastIndexOf(""String_Node_Str"") == -1) {
    return prefix.concat(""String_Node_Str"").concat(value);
  }
 else {
    if (value.endsWith(""String_Node_Str"")) {
      return value.substring(0,value.length() - 1);
    }
 else {
      return value;
    }
  }
}","/** 
 * Discovers name based on some tricky rules.
 * @param value The value to be analyzed.
 * @param prefix The file prefix.
 * @return The new discovered name.
 */
private static String discoverName(String value,String prefix){
  if (!value.contains(File.separator)) {
    if (value.lastIndexOf(""String_Node_Str"") == -1) {
      return absolutePath.concat(File.separator).concat(prefix).concat(""String_Node_Str"").concat(value);
    }
 else {
      if (value.endsWith(""String_Node_Str"")) {
        return absolutePath.concat(File.separator).concat(value.substring(0,value.length() - 1));
      }
 else {
        return absolutePath.concat(File.separator).concat(value);
      }
    }
  }
 else {
    if (value.startsWith(File.separator)) {
      return value;
    }
 else {
      return absolutePath.concat(File.separator).concat(value);
    }
  }
}",0.6978470675575352
100898,"/** 
 * Test filenames.
 * @throws IllegalAccessException Throw exception in case of error.
 * @throws IllegalArgumentException Throw exception in case of error.
 * @throws NoSuchMethodException Throw exception in case of error.
 * @throws InvocationTargetException Throw exception in case of error.
 */
public void testFilenames() throws IllegalAccessException, IllegalArgumentException, NoSuchMethodException, InvocationTargetException {
  Method method=ConditionalMethods.class.getDeclaredMethod(""String_Node_Str"",String.class,String.class);
  method.setAccessible(true);
  List<String> results=new ArrayList<String>();
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  List<String> expected=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(results,expected);
}","/** 
 * Test filenames.
 * @throws IllegalAccessException Throw exception in case of error.
 * @throws IllegalArgumentException Throw exception in case of error.
 * @throws NoSuchMethodException Throw exception in case of error.
 * @throws InvocationTargetException Throw exception in case of error.
 */
public void testFilenames() throws IllegalAccessException, IllegalArgumentException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
  Method method=ConditionalMethods.class.getDeclaredMethod(""String_Node_Str"",String.class,String.class);
  method.setAccessible(true);
  Field field=ConditionalMethods.class.getDeclaredField(""String_Node_Str"");
  field.setAccessible(true);
  field.set(null,""String_Node_Str"");
  List<String> results=new ArrayList<String>();
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  List<String> expected=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(results,expected);
}",0.9300341296928328
100899,"/** 
 * The main method. The idea is to provide to arara only the supported file name and let it handle. The application will remove the file extension (if any) and call the other helper classes.
 * @param args The command line arguments. In fact, arara supports a lot offlags, all listed in the CommandLineAnalyzer class.
 */
public static void main(String[] args){
  int exitStatus;
  try {
    AraraUtils.printHeader();
    ConfigurationLoader configuration=new ConfigurationLoader();
    configuration.load();
    CommandLineAnalyzer commandLine=new CommandLineAnalyzer(args,configuration);
    if (!commandLine.parse()) {
      exitStatus=0;
      System.exit(exitStatus);
    }
    File file;
    file=new File(commandLine.getFile());
    logger.info(localization.getMessage(""String_Node_Str"",AraraConstants.VERSION));
    logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
    DirectiveExtractor dirExtractor=new DirectiveExtractor(file,configuration);
    dirExtractor.extract();
    List<AraraDirective> directives=dirExtractor.getDirectives();
    boolean overallResult=true;
    if (!directives.isEmpty()) {
      DirectiveParser dirParser=new DirectiveParser(directives);
      dirParser.setFile(file);
      TaskDeployer taskDeployer=new TaskDeployer(dirParser.parse(),configuration);
      CommandTrigger commandTrigger=new CommandTrigger(taskDeployer.deploy());
      commandTrigger.setVerbose(commandLine.isVerbose());
      commandTrigger.setDryRun(commandLine.isDryRun());
      commandTrigger.setExecutionTimeout(commandLine.getExecutionTimeout());
      commandTrigger.setMaximumNumberOfLoops(commandLine.getMaximumNumberOfLoops());
      overallResult=commandTrigger.execute();
    }
 else {
      logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
      System.out.println(AraraUtils.wrap(localization.getMessage(""String_Node_Str"",file.getName())));
    }
    logger.info(localization.getMessage(""String_Node_Str""));
    if (overallResult) {
      exitStatus=0;
    }
 else {
      exitStatus=1;
    }
  }
 catch (  Exception exception) {
    System.out.println(AraraUtils.wrap(exception.getMessage()));
    logger.error(localization.getMessage(""String_Node_Str""));
    logger.error(exception.getMessage());
    exitStatus=1;
  }
  System.exit(exitStatus);
}","/** 
 * The main method. The idea is to provide to arara only the supported file name and let it handle. The application will remove the file extension (if any) and call the other helper classes.
 * @param args The command line arguments. In fact, arara supports a lot offlags, all listed in the CommandLineAnalyzer class.
 */
public static void main(String[] args){
  int exitStatus;
  try {
    AraraUtils.printHeader();
    ConfigurationLoader configuration=new ConfigurationLoader();
    configuration.load();
    CommandLineAnalyzer commandLine=new CommandLineAnalyzer(args,configuration);
    if (!commandLine.parse()) {
      exitStatus=0;
      System.exit(exitStatus);
    }
    File file;
    file=new File(commandLine.getFile());
    ConditionalMethods.setAbsolutePath(file);
    AraraDatabase.setAbsolutePath(file);
    logger.info(localization.getMessage(""String_Node_Str"",AraraConstants.VERSION));
    logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
    DirectiveExtractor dirExtractor=new DirectiveExtractor(file,configuration);
    dirExtractor.extract();
    List<AraraDirective> directives=dirExtractor.getDirectives();
    boolean overallResult=true;
    if (!directives.isEmpty()) {
      DirectiveParser dirParser=new DirectiveParser(directives);
      dirParser.setFile(file);
      TaskDeployer taskDeployer=new TaskDeployer(dirParser.parse(),configuration);
      CommandTrigger commandTrigger=new CommandTrigger(taskDeployer.deploy());
      commandTrigger.setVerbose(commandLine.isVerbose());
      commandTrigger.setDryRun(commandLine.isDryRun());
      commandTrigger.setExecutionTimeout(commandLine.getExecutionTimeout());
      commandTrigger.setMaximumNumberOfLoops(commandLine.getMaximumNumberOfLoops());
      overallResult=commandTrigger.execute();
    }
 else {
      logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
      System.out.println(AraraUtils.wrap(localization.getMessage(""String_Node_Str"",file.getName())));
    }
    logger.info(localization.getMessage(""String_Node_Str""));
    if (overallResult) {
      exitStatus=0;
    }
 else {
      exitStatus=1;
    }
  }
 catch (  Exception exception) {
    System.out.println(AraraUtils.wrap(exception.getMessage()));
    logger.error(localization.getMessage(""String_Node_Str""));
    logger.error(exception.getMessage());
    exitStatus=1;
  }
  System.exit(exitStatus);
}",0.9816106531388712
100900,"/** 
 * Loads the XML file and maps the content to a hashmap.
 * @return A hashmap containing all data from the XML file, hopefully thefilename and its corresponding hash.
 * @throws com.github.arara.exception.AraraException if something badhappens, including a malformed XML or an encoding problem.
 */
public static HashMap load() throws AraraException {
  try {
    FileInputStream inputStream=new FileInputStream(AraraConstants.ARARADATABASE);
    Reader reader=new InputStreamReader(inputStream,""String_Node_Str"");
    XStream xstream=new XStream();
    HashMap map=(HashMap)xstream.fromXML(reader);
    reader.close();
    inputStream.close();
    return map;
  }
 catch (  FileNotFoundException fnfe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  UnsupportedEncodingException uee) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  XStreamException xe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  IOException ioe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
}","/** 
 * Loads the XML file and maps the content to a hashmap.
 * @return A hashmap containing all data from the XML file, hopefully thefilename and its corresponding hash.
 * @throws com.github.arara.exception.AraraException if something badhappens, including a malformed XML or an encoding problem.
 */
public static HashMap load() throws AraraException {
  try {
    FileInputStream inputStream=new FileInputStream(absolutePath.concat(File.separator).concat(AraraConstants.ARARADATABASE));
    Reader reader=new InputStreamReader(inputStream,""String_Node_Str"");
    XStream xstream=new XStream();
    HashMap map=(HashMap)xstream.fromXML(reader);
    reader.close();
    inputStream.close();
    return map;
  }
 catch (  FileNotFoundException fnfe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  UnsupportedEncodingException uee) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  XStreamException xe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  IOException ioe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
}",0.9826224328593997
100901,"/** 
 * Saves the hashmap into a XML file.
 * @param map A hashmap containing all data from files and theircorresponding hashes.
 * @throws com.github.arara.exception.AraraException if something badhappens.
 */
public static void save(HashMap map) throws AraraException {
  try {
    FileOutputStream outputStream=new FileOutputStream(AraraConstants.ARARADATABASE);
    OutputStreamWriter writer=new OutputStreamWriter(outputStream,""String_Node_Str"");
    XStream xstream=new XStream();
    xstream.toXML(map,writer);
    writer.close();
    outputStream.close();
  }
 catch (  UnsupportedEncodingException uee) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  XStreamException xe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  IOException ioe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
}","/** 
 * Saves the hashmap into a XML file.
 * @param map A hashmap containing all data from files and theircorresponding hashes.
 * @throws com.github.arara.exception.AraraException if something badhappens.
 */
public static void save(HashMap map) throws AraraException {
  try {
    FileOutputStream outputStream=new FileOutputStream(absolutePath.concat(File.separator).concat(AraraConstants.ARARADATABASE));
    OutputStreamWriter writer=new OutputStreamWriter(outputStream,""String_Node_Str"");
    XStream xstream=new XStream();
    xstream.toXML(map,writer);
    writer.close();
    outputStream.close();
  }
 catch (  UnsupportedEncodingException uee) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  XStreamException xe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
catch (  IOException ioe) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraConstants.ARARADATABASE));
  }
}",0.9783889980353636
100902,"/** 
 * Checks if the XML file exists in the current directory.
 * @return a boolean indicating if the XML file exists in the currentdirectory.
 */
public static boolean exists(){
  return ConditionalMethods.exists(AraraConstants.ARARADATABASE);
}","/** 
 * Checks if the XML file exists in the current directory.
 * @return a boolean indicating if the XML file exists in the currentdirectory.
 */
public static boolean exists(){
  return ConditionalMethods.exists(absolutePath.concat(File.separator).concat(AraraConstants.ARARADATABASE));
}",0.9182156133828996
100903,"/** 
 * Executes the arara commands provided in the list.
 * @return A boolean value about the execution. To be honest, I don't thinkit's necessary to return an actual value, but I kept it for possible future use.
 * @throws com.github.arara.exception.AraraException Raised when the commandis not found in the underlying system.
 */
public boolean execute() throws AraraException {
  logger.info(localization.getMessage(""String_Node_Str""));
  for (  AraraCommand currentAraraCommand : commands) {
    if (dryRun == false) {
      ConditionalMethods.setBasenameReference(AraraMethods.getBasename(currentAraraCommand.getFilename()));
      if ((currentAraraCommand.getConditional().getType() == AraraConditionalType.IF) || (currentAraraCommand.getConditional().getType() == AraraConditionalType.WHILE)) {
        if (ConditionalEvaluator.evaluate(currentAraraCommand.getConditional().getCondition()) == false) {
          continue;
        }
      }
      if (AraraUtils.haltFromAraraTrigger(currentAraraCommand.getCommand())) {
        break;
      }
      long counter=0;
      boolean condition;
      do {
        System.out.print(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()).concat(""String_Node_Str""));
        if (showVerboseOutput) {
          System.out.println(""String_Node_Str"");
        }
        logger.info(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
        logger.trace(localization.getMessage(""String_Node_Str"",currentAraraCommand.getCommand()));
        if (runCommand(currentAraraCommand)) {
          System.out.println(localization.getMessage(""String_Node_Str""));
          logger.info(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
        }
 else {
          System.out.println(localization.getMessage(""String_Node_Str""));
          logger.warn(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
          return false;
        }
        if (showVerboseOutput) {
          System.out.println(""String_Node_Str"");
        }
        if (currentAraraCommand.getConditional().isEmpty()) {
          break;
        }
        counter++;
        condition=ConditionalEvaluator.evaluate(currentAraraCommand.getConditional().getCondition());
        if (currentAraraCommand.getConditional().getType() == AraraConditionalType.UNTIL) {
          condition=!condition;
        }
      }
 while (condition && (counter <= maximumNumberOfLoops));
    }
 else {
      if (AraraUtils.haltFromAraraTrigger(currentAraraCommand.getCommand())) {
        break;
      }
      System.out.println(currentAraraCommand.getName() + ""String_Node_Str"" + currentAraraCommand.getCommand());
    }
  }
  logger.info(localization.getMessage(""String_Node_Str""));
  return true;
}","/** 
 * Executes the arara commands provided in the list.
 * @return A boolean value about the execution. To be honest, I don't thinkit's necessary to return an actual value, but I kept it for possible future use.
 * @throws com.github.arara.exception.AraraException Raised when the commandis not found in the underlying system.
 */
public boolean execute() throws AraraException {
  logger.info(localization.getMessage(""String_Node_Str""));
  for (  AraraCommand currentAraraCommand : commands) {
    if (dryRun == false) {
      ConditionalMethods.setBasenameReference(AraraMethods.getBasename(currentAraraCommand.getFilename()));
      if ((currentAraraCommand.getConditional().getType() == AraraConditionalType.IF) || (currentAraraCommand.getConditional().getType() == AraraConditionalType.WHILE)) {
        if (ConditionalEvaluator.evaluate(currentAraraCommand.getConditional().getCondition()) == false) {
          continue;
        }
      }
      if (AraraUtils.haltFromAraraTrigger(currentAraraCommand.getCommand())) {
        break;
      }
      long counter=0;
      boolean condition;
      do {
        System.out.print(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()).concat(""String_Node_Str""));
        if (showVerboseOutput) {
          System.out.println(""String_Node_Str"");
        }
        logger.info(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
        logger.trace(localization.getMessage(""String_Node_Str"",currentAraraCommand.getCommand()));
        if (runCommand(currentAraraCommand)) {
          System.out.println(localization.getMessage(""String_Node_Str""));
          logger.info(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
        }
 else {
          System.out.println(localization.getMessage(""String_Node_Str""));
          logger.warn(localization.getMessage(""String_Node_Str"",currentAraraCommand.getName()));
          return false;
        }
        if (showVerboseOutput) {
          System.out.println(""String_Node_Str"");
        }
        if (currentAraraCommand.getConditional().isEmpty() || currentAraraCommand.getConditional().getType() == AraraConditionalType.IF) {
          break;
        }
        counter++;
        condition=ConditionalEvaluator.evaluate(currentAraraCommand.getConditional().getCondition());
        if (currentAraraCommand.getConditional().getType() == AraraConditionalType.UNTIL) {
          condition=!condition;
        }
      }
 while (condition && (counter <= maximumNumberOfLoops));
    }
 else {
      if (AraraUtils.haltFromAraraTrigger(currentAraraCommand.getCommand())) {
        break;
      }
      System.out.println(currentAraraCommand.getName() + ""String_Node_Str"" + currentAraraCommand.getCommand());
    }
  }
  logger.info(localization.getMessage(""String_Node_Str""));
  return true;
}",0.986315976541674
100904,"/** 
 * Evaluates the conditional.
 * @param conditional The conditional.
 * @return A boolean indicating the conditional resolution.
 * @throws com.github.arara.exception.AraraException An exception is raisedin case of error.
 */
public static boolean evaluate(String conditional) throws AraraException {
  if (""String_Node_Str"".equals(conditional)) {
    return true;
  }
  HashMap map=new HashMap();
  try {
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class,String.class));
  }
 catch (  NoSuchMethodException nsme) {
  }
  try {
    Object result=TemplateRuntime.eval(""String_Node_Str"".concat(conditional).concat(""String_Node_Str""),map);
    if (!(result instanceof Boolean)) {
      throw new AraraException(localization.getMessage(""String_Node_Str"").concat(""String_Node_Str"").concat(conditional));
    }
 else {
      return ((Boolean)result).booleanValue();
    }
  }
 catch (  RuntimeException runtimeException) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraUtils.getVariableFromException(runtimeException)));
  }
}","/** 
 * Evaluates the conditional.
 * @param conditional The conditional.
 * @return A boolean indicating the conditional resolution.
 * @throws com.github.arara.exception.AraraException An exception is raisedin case of error.
 */
public static boolean evaluate(String conditional) throws AraraException {
  if (""String_Node_Str"".equals(conditional)) {
    return true;
  }
  HashMap map=new HashMap();
  try {
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class,String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
    map.put(""String_Node_Str"",ConditionalMethods.class.getMethod(""String_Node_Str"",String.class));
  }
 catch (  NoSuchMethodException nsme) {
  }
  try {
    Object result=TemplateRuntime.eval(""String_Node_Str"".concat(conditional).concat(""String_Node_Str""),map);
    if (!(result instanceof Boolean)) {
      throw new AraraException(localization.getMessage(""String_Node_Str"").concat(""String_Node_Str"").concat(conditional));
    }
 else {
      return ((Boolean)result).booleanValue();
    }
  }
 catch (  RuntimeException runtimeException) {
    throw new AraraException(localization.getMessage(""String_Node_Str"",AraraUtils.getVariableFromException(runtimeException)));
  }
}",0.8974093264248705
100905,"/** 
 * Discovers name based on some tricky rules.
 * @param value The value to be analyzed.
 * @param prefix The file prefix.
 * @return The new discovered name.
 */
private static String discoverName(String value,String prefix){
  if (value.lastIndexOf(""String_Node_Str"") == -1) {
    return prefix.concat(""String_Node_Str"").concat(value);
  }
 else {
    if (value.endsWith(""String_Node_Str"")) {
      return value.substring(0,value.length() - 1);
    }
 else {
      return value;
    }
  }
}","/** 
 * Discovers name based on some tricky rules.
 * @param value The value to be analyzed.
 * @param prefix The file prefix.
 * @return The new discovered name.
 */
private static String discoverName(String value,String prefix){
  if (!value.contains(File.separator)) {
    if (value.lastIndexOf(""String_Node_Str"") == -1) {
      return absolutePath.concat(File.separator).concat(prefix).concat(""String_Node_Str"").concat(value);
    }
 else {
      if (value.endsWith(""String_Node_Str"")) {
        return absolutePath.concat(File.separator).concat(value.substring(0,value.length() - 1));
      }
 else {
        return absolutePath.concat(File.separator).concat(value);
      }
    }
  }
 else {
    if (value.startsWith(File.separator)) {
      return value;
    }
 else {
      return absolutePath.concat(File.separator).concat(value);
    }
  }
}",0.6978470675575352
100906,"/** 
 * Test filenames.
 * @throws IllegalAccessException Throw exception in case of error.
 * @throws IllegalArgumentException Throw exception in case of error.
 * @throws NoSuchMethodException Throw exception in case of error.
 * @throws InvocationTargetException Throw exception in case of error.
 */
public void testFilenames() throws IllegalAccessException, IllegalArgumentException, NoSuchMethodException, InvocationTargetException {
  Method method=ConditionalMethods.class.getDeclaredMethod(""String_Node_Str"",String.class,String.class);
  method.setAccessible(true);
  List<String> results=new ArrayList<String>();
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  List<String> expected=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(results,expected);
}","/** 
 * Test filenames.
 * @throws IllegalAccessException Throw exception in case of error.
 * @throws IllegalArgumentException Throw exception in case of error.
 * @throws NoSuchMethodException Throw exception in case of error.
 * @throws InvocationTargetException Throw exception in case of error.
 */
public void testFilenames() throws IllegalAccessException, IllegalArgumentException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
  Method method=ConditionalMethods.class.getDeclaredMethod(""String_Node_Str"",String.class,String.class);
  method.setAccessible(true);
  Field field=ConditionalMethods.class.getDeclaredField(""String_Node_Str"");
  field.setAccessible(true);
  field.set(null,""String_Node_Str"");
  List<String> results=new ArrayList<String>();
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  results.add((String)method.invoke(this,""String_Node_Str"",""String_Node_Str""));
  List<String> expected=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(results,expected);
}",0.9300341296928328
100907,"/** 
 * Parses the command line arguments and provides feedback to the main class.
 * @return A boolean value if there is a file to be processed by arara.
 */
public boolean parse(){
  Option optVersion=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optHelp=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optLog=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optVerbose=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optTimeout=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  Option optLanguage=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  Option optDryRun=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optMaxNumberLoops=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  commandLineOptions.addOption(optVersion);
  commandLineOptions.addOption(optHelp);
  commandLineOptions.addOption(optLog);
  commandLineOptions.addOption(optVerbose);
  commandLineOptions.addOption(optTimeout);
  commandLineOptions.addOption(optLanguage);
  commandLineOptions.addOption(optDryRun);
  commandLineOptions.addOption(optMaxNumberLoops);
  CommandLineParser parser=new BasicParser();
  try {
    CommandLine line=parser.parse(commandLineOptions,theArgs);
    if (line.hasOption(""String_Node_Str"")) {
      LanguageController language=new LanguageController();
      if (!language.setLanguage(line.getOptionValue(""String_Node_Str""))) {
        language.printLanguageHelp();
        printUsage();
        return false;
      }
 else {
        optVersion.setDescription(localization.getMessage(""String_Node_Str""));
        optHelp.setDescription(localization.getMessage(""String_Node_Str""));
        optLog.setDescription(localization.getMessage(""String_Node_Str""));
        optVerbose.setDescription(localization.getMessage(""String_Node_Str""));
        optTimeout.setDescription(localization.getMessage(""String_Node_Str""));
        optLanguage.setDescription(localization.getMessage(""String_Node_Str""));
        optDryRun.setDescription(localization.getMessage(""String_Node_Str""));
        optMaxNumberLoops.setDescription(localization.getMessage(""String_Node_Str""));
      }
    }
    if (line.hasOption(""String_Node_Str"")) {
      printVersion();
      printUsage();
      return false;
    }
 else {
      if (line.hasOption(""String_Node_Str"")) {
        printVersion();
        printSpecialThanks();
        return false;
      }
 else {
        String[] files=line.getArgs();
        if (files.length != 1) {
          printVersion();
          printUsage();
          return false;
        }
 else {
          if (line.hasOption(""String_Node_Str"")) {
            try {
              executionTimeout=Long.parseLong(line.getOptionValue(""String_Node_Str""));
              if (executionTimeout <= 0) {
                printVersion();
                printUsage();
                return false;
              }
            }
 catch (            NumberFormatException numberFormatException) {
              printVersion();
              printUsage();
              return false;
            }
          }
 else {
            executionTimeout=0;
          }
          if (line.hasOption(""String_Node_Str"")) {
            try {
              maximumNumberOfLoops=Long.parseLong(line.getOptionValue(""String_Node_Str""));
              if (maximumNumberOfLoops <= 0) {
                printVersion();
                printUsage();
                return false;
              }
            }
 catch (            NumberFormatException numberFormatException) {
              printVersion();
              printUsage();
              return false;
            }
          }
 else {
            maximumNumberOfLoops=AraraConstants.MAXLOOPS;
          }
          AraraLogging.enableLogging(line.hasOption(""String_Node_Str""));
          showVerboseOutput=line.hasOption(""String_Node_Str"");
          if (line.hasOption(""String_Node_Str"")) {
            showVerboseOutput=false;
            dryRun=true;
          }
          theFile=files[0];
          if (!checkFile(theFile,configuration.getValidExtensions())) {
            return false;
          }
          return true;
        }
      }
    }
  }
 catch (  ParseException parseException) {
    printVersion();
    printUsage();
    return false;
  }
}","/** 
 * Parses the command line arguments and provides feedback to the main class.
 * @return A boolean value if there is a file to be processed by arara.
 */
public boolean parse(){
  Option optVersion=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optHelp=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optLog=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optVerbose=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optTimeout=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  Option optLanguage=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  Option optDryRun=new Option(""String_Node_Str"",""String_Node_Str"",false,localization.getMessage(""String_Node_Str""));
  Option optMaxNumberLoops=new Option(""String_Node_Str"",""String_Node_Str"",true,localization.getMessage(""String_Node_Str""));
  commandLineOptions.addOption(optVersion);
  commandLineOptions.addOption(optHelp);
  commandLineOptions.addOption(optLog);
  commandLineOptions.addOption(optVerbose);
  commandLineOptions.addOption(optTimeout);
  commandLineOptions.addOption(optLanguage);
  commandLineOptions.addOption(optDryRun);
  commandLineOptions.addOption(optMaxNumberLoops);
  CommandLineParser parser=new BasicParser();
  try {
    CommandLine line=parser.parse(commandLineOptions,theArgs);
    if (line.hasOption(""String_Node_Str"")) {
      LanguageController language=new LanguageController();
      if (!language.setLanguage(line.getOptionValue(""String_Node_Str""))) {
        language.printLanguageHelp();
        printUsage();
        return false;
      }
 else {
        optVersion.setDescription(localization.getMessage(""String_Node_Str""));
        optHelp.setDescription(localization.getMessage(""String_Node_Str""));
        optLog.setDescription(localization.getMessage(""String_Node_Str""));
        optVerbose.setDescription(localization.getMessage(""String_Node_Str""));
        optTimeout.setDescription(localization.getMessage(""String_Node_Str""));
        optLanguage.setDescription(localization.getMessage(""String_Node_Str""));
        optDryRun.setDescription(localization.getMessage(""String_Node_Str""));
        optMaxNumberLoops.setDescription(localization.getMessage(""String_Node_Str""));
      }
    }
    if (line.hasOption(""String_Node_Str"")) {
      printVersion();
      printUsage();
      return false;
    }
 else {
      if (line.hasOption(""String_Node_Str"")) {
        printVersion();
        printSpecialThanks();
        return false;
      }
 else {
        String[] files=line.getArgs();
        if (files.length != 1) {
          printVersion();
          printUsage();
          return false;
        }
 else {
          if (line.hasOption(""String_Node_Str"")) {
            try {
              executionTimeout=Long.parseLong(line.getOptionValue(""String_Node_Str""));
              if (executionTimeout <= 0) {
                printVersion();
                printUsage();
                return false;
              }
            }
 catch (            NumberFormatException numberFormatException) {
              printVersion();
              printUsage();
              return false;
            }
          }
 else {
            executionTimeout=0;
          }
          if (line.hasOption(""String_Node_Str"")) {
            try {
              maximumNumberOfLoops=Long.parseLong(line.getOptionValue(""String_Node_Str""));
              if (maximumNumberOfLoops <= 0) {
                printVersion();
                printUsage();
                return false;
              }
            }
 catch (            NumberFormatException numberFormatException) {
              printVersion();
              printUsage();
              return false;
            }
          }
 else {
            maximumNumberOfLoops=AraraConstants.MAXLOOPS;
          }
          AraraLogging.enableLogging(line.hasOption(""String_Node_Str""));
          showVerboseOutput=line.hasOption(""String_Node_Str"");
          if (line.hasOption(""String_Node_Str"")) {
            showVerboseOutput=false;
            dryRun=true;
          }
          theFile=files[0];
          if (!checkFile(theFile,configuration.getValidExtensions())) {
            return false;
          }
          return true;
        }
      }
    }
  }
 catch (  ParseException parseException) {
    printVersion();
    printUsage();
    return false;
  }
}",0.999244631488076
100908,"/** 
 * The main method. The idea is to provide to arara only the supported file name and let it handle. The application will remove the file extension (if any) and call the other helper classes.
 * @param args The command line arguments. In fact, arara supports a lot offlags, all listed in the CommandLineAnalyzer.
 */
public static void main(String[] args){
  int exitStatus;
  try {
    AraraUtils.printHeader();
    ConfigurationLoader configuration=new ConfigurationLoader();
    configuration.load();
    CommandLineAnalyzer commandLine=new CommandLineAnalyzer(args,configuration);
    if (!commandLine.parse()) {
      exitStatus=0;
      System.exit(exitStatus);
    }
    File file;
    file=new File(commandLine.getFile());
    logger.info(localization.getMessage(""String_Node_Str""));
    logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
    DirectiveExtractor dirExtractor=new DirectiveExtractor(file,configuration);
    dirExtractor.extract();
    DirectiveParser dirParser=new DirectiveParser(dirExtractor.getDirectives());
    file=commandLine.getFileReference();
    dirParser.setFile(file);
    TaskDeployer taskDeployer=new TaskDeployer(dirParser.parse(),configuration);
    CommandTrigger commandTrigger=new CommandTrigger(taskDeployer.deploy());
    commandTrigger.setVerbose(commandLine.isVerbose());
    commandTrigger.setExecutionTimeout(commandLine.getExecutionTimeout());
    boolean overallResult=commandTrigger.execute();
    logger.info(localization.getMessage(""String_Node_Str""));
    if (overallResult) {
      exitStatus=0;
    }
 else {
      exitStatus=1;
    }
  }
 catch (  Exception exception) {
    System.out.println(AraraUtils.wrap(exception.getMessage()));
    logger.error(localization.getMessage(""String_Node_Str""));
    logger.error(exception.getMessage());
    exitStatus=1;
  }
  System.exit(exitStatus);
}","/** 
 * The main method. The idea is to provide to arara only the supported file name and let it handle. The application will remove the file extension (if any) and call the other helper classes.
 * @param args The command line arguments. In fact, arara supports a lot offlags, all listed in the CommandLineAnalyzer.
 */
public static void main(String[] args){
  int exitStatus;
  try {
    AraraUtils.printHeader();
    ConfigurationLoader configuration=new ConfigurationLoader();
    configuration.load();
    CommandLineAnalyzer commandLine=new CommandLineAnalyzer(args,configuration);
    if (!commandLine.parse()) {
      exitStatus=0;
      System.exit(exitStatus);
    }
    File file;
    file=new File(commandLine.getFile());
    logger.info(localization.getMessage(""String_Node_Str""));
    logger.info(localization.getMessage(""String_Node_Str"",file.getName()));
    DirectiveExtractor dirExtractor=new DirectiveExtractor(file,configuration);
    dirExtractor.extract();
    DirectiveParser dirParser=new DirectiveParser(dirExtractor.getDirectives());
    dirParser.setFile(file);
    TaskDeployer taskDeployer=new TaskDeployer(dirParser.parse(),configuration);
    CommandTrigger commandTrigger=new CommandTrigger(taskDeployer.deploy());
    commandTrigger.setVerbose(commandLine.isVerbose());
    commandTrigger.setExecutionTimeout(commandLine.getExecutionTimeout());
    boolean overallResult=commandTrigger.execute();
    logger.info(localization.getMessage(""String_Node_Str""));
    if (overallResult) {
      exitStatus=0;
    }
 else {
      exitStatus=1;
    }
  }
 catch (  Exception exception) {
    System.out.println(AraraUtils.wrap(exception.getMessage()));
    logger.error(localization.getMessage(""String_Node_Str""));
    logger.error(exception.getMessage());
    exitStatus=1;
  }
  System.exit(exitStatus);
}",0.98893984353925
100909,"/** 
 * Checks if file is valid.
 * @param filename The file name.
 * @param extensions A priority list of allowed extensions.
 * @return A boolean value to determine if the file is valid.
 */
private boolean checkFile(String filename,String[] extensions){
  boolean foundFile=false;
  for (  String currentExtension : extensions) {
    if (filename.toLowerCase().endsWith(currentExtension)) {
      foundFile=true;
      configuration.setChosenFilePattern(currentExtension);
      break;
    }
  }
  File fileStatus=null;
  if (foundFile) {
    fileStatus=new File(filename);
    if (fileStatus.exists()) {
      theFile=filename;
      fileReference=new File(theFile.substring(0,theFile.length() - 4));
      return true;
    }
 else {
      System.out.println(""String_Node_Str"" + filename + ""String_Node_Str"");
      return false;
    }
  }
 else {
    for (    String currentExtension : extensions) {
      fileStatus=new File(filename + currentExtension);
      if (fileStatus.exists()) {
        theFile=filename + currentExtension;
        fileReference=new File(theFile.substring(0,theFile.length() - 4));
        return true;
      }
    }
    System.out.println(AraraUtils.wrap(localization.getMessage(""String_Node_Str"",filename,getExtensionsList(extensions))));
    return false;
  }
}","/** 
 * Checks if file is valid.
 * @param filename The file name.
 * @param extensions A priority list of allowed extensions.
 * @return A boolean value to determine if the file is valid.
 */
private boolean checkFile(String filename,String[] extensions){
  boolean foundFile=false;
  for (  String currentExtension : extensions) {
    if (filename.toLowerCase().endsWith(currentExtension)) {
      foundFile=true;
      configuration.setChosenFilePattern(currentExtension);
      break;
    }
  }
  File fileStatus=null;
  if (foundFile) {
    fileStatus=new File(filename);
    if (fileStatus.exists()) {
      theFile=filename;
      return true;
    }
 else {
      System.out.println(localization.getMessage(""String_Node_Str"",filename));
      return false;
    }
  }
 else {
    for (    String currentExtension : extensions) {
      fileStatus=new File(filename + currentExtension);
      if (fileStatus.exists()) {
        theFile=filename + currentExtension;
        configuration.setChosenFilePattern(currentExtension);
        return true;
      }
    }
    System.out.println(AraraUtils.wrap(localization.getMessage(""String_Node_Str"",filename,getExtensionsList(extensions))));
    return false;
  }
}",0.60263053009167
100910,"/** 
 * Returns the collection of   {@link UriTemplateComponent} instancesfound in this template.
 * @return
 */
public Collection<UriTemplateComponent> getComponents(){
  return Collections.unmodifiableCollection(components);
}","/** 
 * <p> Returns the collection of   {@link UriTemplateComponent} instancesfound in this template. </p>
 * @return the collection of {@link UriTemplateComponent}s
 */
public Collection<UriTemplateComponent> getComponents(){
  return Collections.unmodifiableCollection(components);
}",0.8888888888888888
100911,"/** 
 * <p> Creates a new   {@link UriTemplate} from a root {@link UriTemplate}. This method will create a new   {@link UriTemplate} from the base and copy the variablesfrom the base template to the new  {@link UriTemplate}. </p> <p> This method is useful when the base template is less volatile than the child expression and you want to merge the two. </p>
 * @param baseTemplate
 * @return
 * @since 1.0
 */
public static UriTemplateBuilder fromTemplate(UriTemplate baseTemplate) throws MalformedUriTemplateException {
  return new UriTemplateBuilder(baseTemplate.getTemplate());
}","/** 
 * <p> This method is now deprecated. Use   {@link UriTemplate#buildFromTemplate(UriTemplate)} instead.</p>
 * @deprecated use {@link #buildFromTemplate(UriTemplate)}
 * @param baseTemplate
 * @return
 * @since 1.0
 */
@Deprecated public static UriTemplateBuilder fromTemplate(UriTemplate baseTemplate) throws MalformedUriTemplateException {
  return new UriTemplateBuilder(baseTemplate);
}",0.5173824130879345
100912,"/** 
 * @param sourceValue
 * @return the encoded string
 */
public static String encodeFragment(String sourceValue) throws UnsupportedEncodingException {
  return encode(sourceValue,ESCAPE_CHARS);
}","/** 
 * @param sourceValue
 * @return the encoded string
 */
public static String encodeFragment(String sourceValue) throws UnsupportedEncodingException {
  Matcher m=PCT_ENCODDED_STRING.matcher(sourceValue);
  List<int[]> positions=new ArrayList<int[]>();
  while (m.find()) {
    positions.add(new int[]{m.start(),m.end()});
  }
  if (!positions.isEmpty()) {
    StringBuilder b=new StringBuilder();
    int offset=0;
    for (    int[] pos : positions) {
      b.append(UriUtil.encode(sourceValue.substring(offset,pos[0]),ESCAPE_CHARS));
      b.append(sourceValue.substring(pos[0],pos[1]));
      offset=pos[1];
    }
    b.append(encode(sourceValue.substring(offset,sourceValue.length()),ESCAPE_CHARS));
    return b.toString();
  }
  return encode(sourceValue,ESCAPE_CHARS);
}",0.3751274209989806
100913,"/** 
 * A lite version of the introspection logic performed by the BeanInfo introspector.
 * @param method
 */
private void inspectGetters(Method method){
  String methodName=method.getName();
  int prefixLength=0;
  if (methodName.startsWith(GET_PREFIX)) {
    prefixLength=GET_PREFIX.length();
  }
  if (methodName.startsWith(IS_PREIX)) {
    prefixLength=IS_PREIX.length();
  }
  if (prefixLength == 0) {
    return;
  }
  String name=decapitalize(methodName.substring(prefixLength));
  if (!isValidProperty(name)) {
    return;
  }
  Class propertyType=method.getReturnType();
  if (propertyType == null || propertyType == void.class) {
    return;
  }
  if (prefixLength == 2) {
    if (!(propertyType == boolean.class)) {
      return;
    }
  }
  Class[] paramTypes=method.getParameterTypes();
  if (paramTypes.length > 1 || (paramTypes.length == 1 && paramTypes[0] != int.class)) {
    return;
  }
  if (!method.isAnnotationPresent(UriTransient.class) && !name.equals(""String_Node_Str"")) {
    Object value=getValue(method);
    if (method.isAnnotationPresent(VarName.class)) {
      name=method.getAnnotation(VarName.class).value();
    }
    if (value != null) {
      pairs.put(name,value);
    }
  }
}","/** 
 * A lite version of the introspection logic performed by the BeanInfo introspector.
 * @param method
 */
private void inspectGetters(Method method){
  String methodName=method.getName();
  int prefixLength=0;
  if (methodName.startsWith(GET_PREFIX)) {
    prefixLength=GET_PREFIX.length();
  }
  if (methodName.startsWith(IS_PREIX)) {
    prefixLength=IS_PREIX.length();
  }
  if (prefixLength == 0) {
    return;
  }
  String name=decapitalize(methodName.substring(prefixLength));
  if (!isValidProperty(name)) {
    return;
  }
  Class propertyType=method.getReturnType();
  if (propertyType == null || propertyType == void.class) {
    return;
  }
  if (prefixLength == 2) {
    if (!(propertyType == boolean.class)) {
      return;
    }
  }
  Class[] paramTypes=method.getParameterTypes();
  if (paramTypes.length > 1 || (paramTypes.length == 1 && paramTypes[0] != int.class)) {
    return;
  }
  if (!method.isAnnotationPresent(UriTransient.class) && !""String_Node_Str"".equals(name)) {
    Object value=getValue(method);
    if (method.isAnnotationPresent(VarName.class)) {
      name=method.getAnnotation(VarName.class).value();
    }
    if (value != null) {
      pairs.put(name,value);
    }
  }
}",0.9901071723000824
100914,"/** 
 * @param operator
 * @param varSpec
 * @param variable
 * @param format
 * @return
 */
private String expandStringValue(Operator operator,VarSpec varSpec,String variable,VarSpec.VarFormat format) throws VariableExpansionException {
  String expanded;
  if (varSpec.getModifier() == Modifier.PREFIX) {
    int position=varSpec.getPosition();
    if (position < variable.length()) {
      variable=variable.substring(0,position);
    }
  }
  try {
    if (operator.getEncoding() == Encoding.UR) {
      expanded=UriUtil.encodeFragment(variable);
    }
 else {
      expanded=UriUtil.encode(variable);
    }
  }
 catch (  UnsupportedEncodingException e) {
    throw new VariableExpansionException(""String_Node_Str"",e);
  }
  if (operator.isNamed()) {
    if (expanded.isEmpty() && !operator.getSeparator().equals(""String_Node_Str"")) {
      expanded=varSpec.getValue();
    }
 else     if (format == VarSpec.VarFormat.SINGLE) {
      expanded=varSpec.getVariableName() + ""String_Node_Str"" + expanded;
    }
 else {
      if (varSpec.getModifier() == Modifier.EXPLODE) {
        if (operator.useVarNameWhenExploded() && format != VarSpec.VarFormat.PAIRS) {
          expanded=varSpec.getVariableName() + ""String_Node_Str"" + expanded;
        }
      }
    }
  }
  return expanded;
}","/** 
 * @param operator
 * @param varSpec
 * @param variable
 * @param format
 * @return
 */
private String expandStringValue(Operator operator,VarSpec varSpec,String variable,VarSpec.VarFormat format) throws VariableExpansionException {
  String expanded;
  if (varSpec.getModifier() == Modifier.PREFIX) {
    int position=varSpec.getPosition();
    if (position < variable.length()) {
      variable=variable.substring(0,position);
    }
  }
  try {
    if (operator.getEncoding() == Encoding.UR) {
      expanded=UriUtil.encodeFragment(variable);
    }
 else {
      expanded=UriUtil.encode(variable);
    }
  }
 catch (  UnsupportedEncodingException e) {
    throw new VariableExpansionException(""String_Node_Str"",e);
  }
  if (operator.isNamed()) {
    if (expanded.isEmpty() && !""String_Node_Str"".equals(operator.getSeparator())) {
      expanded=varSpec.getValue();
    }
 else     if (format == VarSpec.VarFormat.SINGLE) {
      expanded=varSpec.getVariableName() + ""String_Node_Str"" + expanded;
    }
 else {
      if (varSpec.getModifier() == Modifier.EXPLODE) {
        if (operator.useVarNameWhenExploded() && format != VarSpec.VarFormat.PAIRS) {
          expanded=varSpec.getVariableName() + ""String_Node_Str"" + expanded;
        }
      }
    }
  }
  return expanded;
}",0.968847352024922
100915,"/** 
 * Initializes the values from the object properties and constructs a map from those values.
 * @throws VarExploderException
 */
private void initValues() throws VarExploderException {
  Class<?> c=source.getClass();
  if (c.isAnnotation() || c.isArray() || c.isEnum()|| c.isPrimitive()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Method[] methods=c.getMethods();
  for (  Method method : methods) {
    inspectGetters(method);
  }
  scanFields(c);
}","/** 
 * Initializes the values from the object properties and constructs a map from those values.
 * @throws VarExploderException
 */
private void initValues() throws VarExploderException {
  Class<?> c=source.getClass();
  if (c.isAnnotation() || c.isArray() || c.isEnum()|| c.isPrimitive()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (source instanceof Map) {
    this.pairs=(Map)source;
    return;
  }
  Method[] methods=c.getMethods();
  for (  Method method : methods) {
    inspectGetters(method);
  }
  scanFields(c);
}",0.9273959341723136
100916,"private void initVariableName(){
  if (modifier != Modifier.NONE) {
    if (modifier == Modifier.PREFIX) {
      String[] values=getValue().split(Modifier.PREFIX.getValue());
      variableName=values[0];
    }
 else     if (modifier == Modifier.EXPLODE) {
      variableName=getValue().substring(0,getValue().length() - 1);
    }
  }
 else {
    variableName=getValue();
  }
}","private void initVariableName(){
  variableName=getValue();
  if (modifier != Modifier.NONE) {
    if (modifier == Modifier.PREFIX) {
      String[] values=getValue().split(Modifier.PREFIX.getValue());
      variableName=values[0];
    }
    if (modifier == Modifier.EXPLODE && getValue().lastIndexOf('*') != -1) {
      variableName=getValue().substring(0,getValue().length() - 1);
    }
  }
}",0.8560311284046692
100917,"/** 
 * Returns true of the object is: <ul> <li>a primitive type</li> <li>an instance of   {@link CharSequence}</li> <li>an instance of   {@link Number} <li><li>an instance of  {@link Date} <li></ul>
 * @param value
 * @return
 */
private boolean isSimpleType(Object value){
  if (value.getClass().isPrimitive() || value instanceof Number || value instanceof CharSequence|| value instanceof Date|| value instanceof Boolean) {
    return true;
  }
  return false;
}","/** 
 * Returns true of the object is: <ul> <li>a primitive type</li> <li>an enum</li> <li>an instance of   {@link CharSequence}</li> <li>an instance of   {@link Number} <li><li>an instance of  {@link Date} <li><li>an instance of  {@link Boolean}</li> <li>an instance of   {@link UUID}</li> <li>an instance of   {@link Class}</li> </ul>
 * @param value
 * @return
 */
private boolean isSimpleType(Object value){
  if (value.getClass().isPrimitive() || value.getClass().isEnum() || value instanceof Class|| value instanceof Number|| value instanceof CharSequence|| value instanceof Date|| value instanceof Boolean|| value instanceof UUID) {
    return true;
  }
  return false;
}",0.8108581436077058
100918,"/** 
 * Returns the
 * @return
 */
protected Pattern getReverseMatchPattern(){
  if (this.reverseMatchPattern == null) {
    buildReverssMatchRegexFromComponents();
  }
  return this.reverseMatchPattern;
}","/** 
 * Returns the
 * @return
 */
protected Pattern getReverseMatchPattern(){
  if (this.reverseMatchPattern == null) {
    buildReverseMatchRegexFromComponents();
  }
  return this.reverseMatchPattern;
}",0.9951219512195122
100919,"/** 
 * <p> Creates a new   {@link UriTemplate} from a root {@link UriTemplate}. This method will create a new   {@link UriTemplate} from the base and copy the variablesfrom the base template to the new  {@link UriTemplate}. </p> <p> This method is useful when the base template is less volatile than the child expression and you want to merge the two. </p>
 * @param base
 * @return
 * @since 1.0
 */
public static UriTemplateBuilder fromTemplate(UriTemplate base) throws MalformedUriTemplateException {
  return new UriTemplateBuilder(base.getTemplate());
}","/** 
 * <p> Creates a new   {@link UriTemplate} from a root {@link UriTemplate}. This method will create a new   {@link UriTemplate} from the base and copy the variablesfrom the base template to the new  {@link UriTemplate}. </p> <p> This method is useful when the base template is less volatile than the child expression and you want to merge the two. </p>
 * @param baseTemplate
 * @return
 * @since 1.0
 */
public static UriTemplateBuilder fromTemplate(UriTemplate baseTemplate) throws MalformedUriTemplateException {
  return new UriTemplateBuilder(baseTemplate.getTemplate());
}",0.978984238178634
100920,"public String expandPartial() throws VariableExpansionException {
  String template=getTemplate();
  for (  Expression expression : expressions) {
    final String replacement=expressionReplacementString(expression,true);
    template=template.replaceAll(expression.getReplacementPattern(),replacement);
  }
  return template;
}","/** 
 * @return
 * @throws VariableExpansionException
 */
public String expandPartial() throws VariableExpansionException {
  String template=getTemplate();
  for (  Expression expression : expressions) {
    final String replacement=expressionReplacementString(expression,true);
    template=template.replaceAll(expression.getReplacementPattern(),replacement);
  }
  return template;
}",0.9187675070028012
100921,"/** 
 * <p> Creates a new   {@link UriTemplateBuilder} from a root {@link UriTemplate}. This method will create a new   {@link UriTemplate} from the base and copy the variablesfrom the base template to the new  {@link UriTemplate}. </p> <p> This method is useful when the base template is less volatile than the child expression and you want to merge the two. </p>
 * @param base
 * @return
 * @since 2.0
 */
public static UriTemplateBuilder buildFromTemplate(UriTemplate template) throws MalformedUriTemplateException {
  return new UriTemplateBuilder(template);
}","/** 
 * <p> Creates a new   {@link UriTemplateBuilder} from a root {@link UriTemplate}. This method will create a new   {@link UriTemplate} from the base and copy the variablesfrom the base template to the new  {@link UriTemplate}. </p> <p> This method is useful when the base template is less volatile than the child expression and you want to merge the two. </p>
 * @param baseTemplate
 * @return
 * @since 2.0
 */
public static UriTemplateBuilder buildFromTemplate(UriTemplate baseTemplate) throws MalformedUriTemplateException {
  return new UriTemplateBuilder(baseTemplate);
}",0.9825479930191972
100922,"/** 
 * @param soureValue
 * @param chars
 * @return
 * @throws UriEncodingException
 */
private static String encode(String sourceValue,BitSet chars) throws UriEncodingException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  try {
    byte[] source=sourceValue.getBytes(Charset.forName(""String_Node_Str""));
    for (int i=0; i < source.length; i++) {
      byte c=source[i];
      if (chars.get(c) || c <= 0x20) {
        out.write('%');
        char hex1=Character.toUpperCase(Character.forDigit((c >> 4) & 0xF,16));
        char hex2=Character.toUpperCase(Character.forDigit(c & 0xF,16));
        out.write(hex1);
        out.write(hex2);
      }
 else {
        out.write(c);
      }
    }
    return new String(out.toByteArray(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new UriEncodingException(e);
  }
}","/** 
 * @param soureValue
 * @param chars
 * @return
 * @throws UriEncodingException
 */
private static String encode(String sourceValue,BitSet chars) throws UriEncodingException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  try {
    byte[] source=sourceValue.getBytes(Charset.forName(""String_Node_Str""));
    for (int i=0; i < source.length; i++) {
      byte c=source[i];
      if (chars.get(c & 0xff) || c <= 0x20) {
        out.write('%');
        char hex1=Character.toUpperCase(Character.forDigit((c >> 4) & 0xF,16));
        char hex2=Character.toUpperCase(Character.forDigit(c & 0xF,16));
        out.write(hex1);
        out.write(hex2);
      }
 else {
        out.write(c);
      }
    }
    return new String(out.toByteArray(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new UriEncodingException(e);
  }
}",0.9959467284308048
100923,"/** 
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") @Test public void test() throws Exception {
  UriTemplate t=UriTemplate.fromExpression(template);
  String actual=t.expand(variables);
  if (expected instanceof String) {
    Assert.assertEquals(testsuite + ""String_Node_Str"" + template,expected,actual);
  }
 else   if (expected instanceof Collection) {
    List<String> combinations=(List<String>)expected;
    boolean match=false;
    for (    String combo : combinations) {
      if (combo.equalsIgnoreCase(actual)) {
        match=true;
        break;
      }
    }
    Assert.assertTrue(testsuite + ""String_Node_Str"" + template+ ""String_Node_Str"",match);
  }
}","/** 
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") @Test public void test() throws Exception {
  UriTemplate t=UriTemplate.fromExpression(template);
  String actual=t.expand(variables);
  if (expected instanceof String) {
    Assert.assertEquals(testsuite + ""String_Node_Str"" + template,expected,actual);
  }
 else   if (expected instanceof Collection) {
    List<String> combinations=(List<String>)expected;
    boolean match=false;
    for (    String combo : combinations) {
      if (combo.equalsIgnoreCase(actual)) {
        match=true;
        break;
      }
    }
    Assert.assertTrue(testsuite + ""String_Node_Str"" + template+ ""String_Node_Str""+ actual+ ""String_Node_Str"",match);
  }
}",0.98058950395399
100924,"/** 
 * FIXME Comment this
 * @param operator
 * @param varSpec
 * @param variable
 * @param format
 * @return
 */
private String expandStringValue(Op operator,VarSpec varSpec,String variable,VarFormat format){
  String expanded=""String_Node_Str"";
  if (varSpec.getModifier() == Modifier.PREFIX) {
    int position=varSpec.getPosition();
    if (position < variable.length()) {
      variable=variable.substring(0,position);
    }
  }
  try {
    if (operator == Op.NAME_LABEL || operator == Op.FRAGMENT || operator == Op.RESERVED) {
      expanded=variable.replaceAll(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      expanded=urlCodec.encode(variable).replaceAll(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  EncoderException e) {
    throw new RuntimeException(e);
  }
  if (operator.useQueryString()) {
    if (expanded.isEmpty() && !operator.getJoiner().equals(""String_Node_Str"")) {
      expanded=varSpec.getValue();
    }
 else     if (format == VarFormat.SINGLE) {
      expanded=varSpec.getVariableName() + ""String_Node_Str"" + expanded;
    }
 else {
      if (expanded.isEmpty()) {
        expanded=varSpec.getValue();
      }
 else       if (varSpec.getModifier() == Modifier.EXPLODE) {
        if (operator.useVarNameWhenExploded() && format != VarFormat.PAIRS) {
          expanded=varSpec.getVariableName() + ""String_Node_Str"" + expanded;
        }
      }
    }
  }
  return expanded;
}","/** 
 * FIXME Comment this
 * @param operator
 * @param varSpec
 * @param variable
 * @param format
 * @return
 */
private String expandStringValue(Op operator,VarSpec varSpec,String variable,VarFormat format){
  String expanded=""String_Node_Str"";
  if (varSpec.getModifier() == Modifier.PREFIX) {
    int position=varSpec.getPosition();
    if (position < variable.length()) {
      variable=variable.substring(0,position);
    }
  }
  if (operator == Op.NAME_LABEL || operator == Op.RESERVED) {
    expanded=variable.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (operator == Op.FRAGMENT) {
    expanded=UriUtil.encodeUri(variable);
  }
 else {
    try {
      expanded=urlCodec.encode(variable).replaceAll(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    EncoderException e) {
      throw new RuntimeException(e);
    }
  }
  if (operator.useQueryString()) {
    if (expanded.isEmpty() && !operator.getJoiner().equals(""String_Node_Str"")) {
      expanded=varSpec.getValue();
    }
 else     if (format == VarFormat.SINGLE) {
      expanded=varSpec.getVariableName() + ""String_Node_Str"" + expanded;
    }
 else {
      if (expanded.isEmpty()) {
        expanded=varSpec.getValue();
      }
 else       if (varSpec.getModifier() == Modifier.EXPLODE) {
        if (operator.useVarNameWhenExploded() && format != VarFormat.PAIRS) {
          expanded=varSpec.getVariableName() + ""String_Node_Str"" + expanded;
        }
      }
    }
  }
  return expanded;
}",0.84
100925,"/** 
 * Stores blocks, transactions, and input/output nodes to the database. Blocks will be given a relationship of ""succeeds"" to the previous categorized block to the database. Transactions will be given a relationship of ""from"" to its owner Block. Input/Output nodes (called Money nodes) will either be given ""sent"" or ""received"" relationships based upon what they represent. This function maintains a local json repository by downloading it directly from the API. Then, it persists the json blocks to the datastore from these local json files.
 * @author John
 */
public void downloadBlockChain(boolean doValidate){
  final int LATEST_DISK_BLOCK_INDEX;
  final int LATEST_INTERNET_BLOCK_INDEX;
  int lastDatabaseBlockIndex;
  LatestBlock latestInternetBlock=Fetcher.GetLatest();
  LATEST_INTERNET_BLOCK_INDEX=latestInternetBlock.getBlock_index();
  Collection<File> files=Fetcher.getFolderContents(""String_Node_Str"");
  ArrayList<Integer> fileNames=new ArrayList<Integer>();
  for (  File file : files) {
    if (file.getName().endsWith(""String_Node_Str""))     fileNames.add(Integer.parseInt(file.getName().split(""String_Node_Str"")[0]));
  }
  Collections.sort(fileNames);
  LATEST_DISK_BLOCK_INDEX=fileNames.get(fileNames.size() - 1);
  downloadChain(LATEST_DISK_BLOCK_INDEX,latestInternetBlock);
  Node latestDatabaseBlock=getLatestLocalBlockNode();
  if (latestDatabaseBlock.hasProperty(""String_Node_Str""))   lastDatabaseBlockIndex=(Integer)latestDatabaseBlock.getProperty(""String_Node_Str"");
 else   lastDatabaseBlockIndex=0;
  if (doValidate) {
    if (isBlockchainComplete()) {
      LOG.info(""String_Node_Str"");
    }
 else {
      LOG.severe(""String_Node_Str"");
      return;
    }
  }
 else {
    LOG.info(""String_Node_Str"");
    BlockType currentBlock=null;
    RestNode currentBlockNode=null;
    while (lastDatabaseBlockIndex < LATEST_INTERNET_BLOCK_INDEX) {
      try {
        for (int i=lastDatabaseBlockIndex; i < LATEST_INTERNET_BLOCK_INDEX; i++) {
          if (FileUtils.getFile((i + 1) + ""String_Node_Str"").exists()) {
            currentBlock=Fetcher.GetBlock(FileUtils.getFile((i + 1) + ""String_Node_Str"")).getBlockType();
            break;
          }
        }
      }
 catch (      FetcherException e) {
        LOG.log(Level.SEVERE,""String_Node_Str"" + e.getMessage() + ""String_Node_Str"",e);
        return;
      }
      LOG.info(""String_Node_Str"" + currentBlock.getBlock_index());
      Map<String,Object> blockProps=new HashMap<String,Object>();
      blockProps.put(""String_Node_Str"",currentBlock.getHash());
      blockProps.put(""String_Node_Str"",currentBlock.getVer());
      blockProps.put(""String_Node_Str"",currentBlock.getPrev_block());
      blockProps.put(""String_Node_Str"",currentBlock.getMrkl_root());
      blockProps.put(""String_Node_Str"",currentBlock.getTime());
      blockProps.put(""String_Node_Str"",currentBlock.getBits());
      blockProps.put(""String_Node_Str"",currentBlock.getNonce());
      blockProps.put(""String_Node_Str"",currentBlock.getN_tx());
      blockProps.put(""String_Node_Str"",currentBlock.getSize());
      blockProps.put(""String_Node_Str"",currentBlock.getBlock_index());
      blockProps.put(""String_Node_Str"",currentBlock.getMain_chain());
      blockProps.put(""String_Node_Str"",currentBlock.getHeight());
      blockProps.put(""String_Node_Str"",currentBlock.getReceived_time());
      blockProps.put(""String_Node_Str"",currentBlock.getRelayed_by());
      currentBlockNode=restApi.createNode(blockProps);
      if (latestDatabaseBlock.hasProperty(""String_Node_Str"") && !((String)currentBlockNode.getProperty(""String_Node_Str"")).contains((String)latestDatabaseBlock.getProperty(""String_Node_Str""))) {
        TraversalDescription td=new TraversalDescriptionImpl();
        td=td.depthFirst().relationships(BitcoinRelationships.succeeds);
        Iterable<Node> nodeTraversal=td.traverse(latestDatabaseBlock).nodes();
        for (Iterator<Node> iter=nodeTraversal.iterator(); iter.hasNext(); ) {
          Node blockNode=iter.next();
          if (blockNode.hasProperty(""String_Node_Str"") && ((String)blockNode.getProperty(""String_Node_Str"")).contains(((String)currentBlockNode.getProperty(""String_Node_Str"")))) {
            restApi.createRelationship(currentBlockNode,blockNode,BitcoinRelationships.succeeds,null);
          }
        }
      }
 else {
        restApi.createRelationship(currentBlockNode,latestDatabaseBlock,BitcoinRelationships.succeeds,null);
      }
      Map<String,Object> tranProps;
      TransactionType tran;
      RestNode tranNode=null;
      Map<String,Object> fromRelation;
      for (Iterator<TransactionType> tranIter=currentBlock.getAscTx().iterator(); tranIter.hasNext(); ) {
        tranProps=new HashMap<String,Object>();
        tran=tranIter.next();
        tranProps.put(""String_Node_Str"",tran.getHash());
        tranProps.put(""String_Node_Str"",tran.getVer());
        tranProps.put(""String_Node_Str"",tran.getVin_sz());
        tranProps.put(""String_Node_Str"",tran.getVout_sz());
        tranProps.put(""String_Node_Str"",tran.getSize());
        tranProps.put(""String_Node_Str"",tran.getRelayed_by());
        tranProps.put(""String_Node_Str"",tran.getTx_index());
        tranNode=restApi.createNode(tranProps);
        fromRelation=new HashMap<String,Object>();
        fromRelation.put(""String_Node_Str"",currentBlock.getHash());
        restApi.createRelationship(tranNode,currentBlockNode,BitcoinRelationships.from,fromRelation);
        transactionsIndex.add(tranNode,""String_Node_Str"",tran.getTx_index());
        Map<String,Object> moneyProps;
        RestNode outNode=null;
        OutputType output;
        Map<String,Object> sentRelation;
        int n=0;
        for (Iterator<OutputType> outputIter=tran.getOut().iterator(); outputIter.hasNext(); ) {
          moneyProps=new HashMap<String,Object>();
          output=outputIter.next();
          moneyProps.put(""String_Node_Str"",output.getType());
          moneyProps.put(""String_Node_Str"",output.getAddr());
          moneyProps.put(""String_Node_Str"",output.getValue());
          moneyProps.put(""String_Node_Str"",n);
          outNode=restApi.createNode(moneyProps);
          sentRelation=new HashMap<String,Object>();
          sentRelation.put(""String_Node_Str"",output.getAddr());
          sentRelation.put(""String_Node_Str"",n);
          restApi.createRelationship(tranNode,outNode,BitcoinRelationships.sent,sentRelation);
          n++;
        }
        Map<String,Object> receivedRelation;
        PrevOut prevOut;
        for (Iterator<InputType> inputIter=tran.getInputs().iterator(); inputIter.hasNext(); ) {
          moneyProps=new HashMap<String,Object>();
          prevOut=inputIter.next().getPrev_out();
          if (prevOut == null)           continue;
          moneyProps.put(""String_Node_Str"",prevOut.getType());
          moneyProps.put(""String_Node_Str"",prevOut.getAddr());
          moneyProps.put(""String_Node_Str"",prevOut.getValue());
          moneyProps.put(""String_Node_Str"",prevOut.getN());
          Node transactionNode=transactionsIndex.query(""String_Node_Str"",prevOut.getTx_index()).getSingle();
          if (transactionNode != null) {
            Iterable<Relationship> moneyNodeRelationships=transactionNode.getRelationships(BitcoinRelationships.sent,Direction.OUTGOING);
            for (Iterator<Relationship> moneyIter=moneyNodeRelationships.iterator(); moneyIter.hasNext(); ) {
              Node[] moneyNodes=moneyIter.next().getNodes();
              for (int i=0; i < moneyNodes.length; i++) {
                if (moneyNodes[i].hasProperty(""String_Node_Str"") && moneyNodes[i].hasProperty(""String_Node_Str"") && ((String)moneyNodes[i].getProperty(""String_Node_Str"")).contains(prevOut.getAddr())&& ((Integer)moneyNodes[i].getProperty(""String_Node_Str"") == prevOut.getN())) {
                  receivedRelation=new HashMap<String,Object>();
                  receivedRelation.put(""String_Node_Str"",prevOut.getTx_index());
                  restApi.createRelationship(moneyNodes[i],tranNode,BitcoinRelationships.received,receivedRelation);
                  break;
                }
              }
            }
          }
        }
      }
      lastDatabaseBlockIndex=currentBlock.getBlock_index();
      latestDatabaseBlock=currentBlockNode;
    }
  }
}","/** 
 * Stores blocks, transactions, and input/output nodes to the database. Blocks will be given a relationship of ""succeeds"" to the previous categorized block to the database. Transactions will be given a relationship of ""from"" to its owner Block. Input/Output nodes (called Money nodes) will either be given ""sent"" or ""received"" relationships based upon what they represent. This function maintains a local json repository by downloading it directly from the API. Then, it persists the json blocks to the datastore from these local json files.
 * @author John
 */
public void downloadBlockChain(boolean doValidate){
  final int LATEST_DISK_BLOCK_INDEX;
  final int LATEST_INTERNET_BLOCK_INDEX;
  int lastDatabaseBlockIndex;
  LatestBlock latestInternetBlock=Fetcher.GetLatest();
  LATEST_INTERNET_BLOCK_INDEX=latestInternetBlock.getBlock_index();
  Collection<File> files=Fetcher.getFolderContents(""String_Node_Str"");
  ArrayList<Integer> fileNames=new ArrayList<Integer>();
  for (  File file : files) {
    if (file.getName().endsWith(""String_Node_Str""))     fileNames.add(Integer.parseInt(file.getName().split(""String_Node_Str"")[0]));
  }
  Collections.sort(fileNames);
  LATEST_DISK_BLOCK_INDEX=fileNames.get(fileNames.size() - 1);
  downloadChain(LATEST_DISK_BLOCK_INDEX,latestInternetBlock);
  Node latestDatabaseBlock=getLatestLocalBlockNode();
  if (latestDatabaseBlock.hasProperty(""String_Node_Str""))   lastDatabaseBlockIndex=(Integer)latestDatabaseBlock.getProperty(""String_Node_Str"");
 else   lastDatabaseBlockIndex=0;
  if (doValidate) {
    if (isBlockchainComplete()) {
      LOG.info(""String_Node_Str"");
    }
 else {
      LOG.severe(""String_Node_Str"");
      return;
    }
  }
  LOG.info(""String_Node_Str"");
  BlockType currentBlock=null;
  RestNode currentBlockNode=null;
  while (lastDatabaseBlockIndex < LATEST_INTERNET_BLOCK_INDEX) {
    try {
      for (int i=lastDatabaseBlockIndex; i < LATEST_INTERNET_BLOCK_INDEX; i++) {
        if (FileUtils.getFile((i + 1) + ""String_Node_Str"").exists()) {
          currentBlock=Fetcher.GetBlock(FileUtils.getFile((i + 1) + ""String_Node_Str"")).getBlockType();
          break;
        }
      }
    }
 catch (    FetcherException e) {
      LOG.log(Level.SEVERE,""String_Node_Str"" + e.getMessage() + ""String_Node_Str"",e);
      return;
    }
    LOG.info(""String_Node_Str"" + currentBlock.getBlock_index());
    Map<String,Object> blockProps=new HashMap<String,Object>();
    blockProps.put(""String_Node_Str"",currentBlock.getHash());
    blockProps.put(""String_Node_Str"",currentBlock.getVer());
    blockProps.put(""String_Node_Str"",currentBlock.getPrev_block());
    blockProps.put(""String_Node_Str"",currentBlock.getMrkl_root());
    blockProps.put(""String_Node_Str"",currentBlock.getTime());
    blockProps.put(""String_Node_Str"",currentBlock.getBits());
    blockProps.put(""String_Node_Str"",currentBlock.getNonce());
    blockProps.put(""String_Node_Str"",currentBlock.getN_tx());
    blockProps.put(""String_Node_Str"",currentBlock.getSize());
    blockProps.put(""String_Node_Str"",currentBlock.getBlock_index());
    blockProps.put(""String_Node_Str"",currentBlock.getMain_chain());
    blockProps.put(""String_Node_Str"",currentBlock.getHeight());
    blockProps.put(""String_Node_Str"",currentBlock.getReceived_time());
    blockProps.put(""String_Node_Str"",currentBlock.getRelayed_by());
    currentBlockNode=restApi.createNode(blockProps);
    if (latestDatabaseBlock.hasProperty(""String_Node_Str"") && !((String)currentBlockNode.getProperty(""String_Node_Str"")).contains((String)latestDatabaseBlock.getProperty(""String_Node_Str""))) {
      TraversalDescription td=new TraversalDescriptionImpl();
      td=td.depthFirst().relationships(BitcoinRelationships.succeeds);
      Iterable<Node> nodeTraversal=td.traverse(latestDatabaseBlock).nodes();
      for (Iterator<Node> iter=nodeTraversal.iterator(); iter.hasNext(); ) {
        Node blockNode=iter.next();
        if (blockNode.hasProperty(""String_Node_Str"") && ((String)blockNode.getProperty(""String_Node_Str"")).contains(((String)currentBlockNode.getProperty(""String_Node_Str"")))) {
          restApi.createRelationship(currentBlockNode,blockNode,BitcoinRelationships.succeeds,null);
        }
      }
    }
 else {
      restApi.createRelationship(currentBlockNode,latestDatabaseBlock,BitcoinRelationships.succeeds,null);
    }
    Map<String,Object> tranProps;
    TransactionType tran;
    RestNode tranNode=null;
    Map<String,Object> fromRelation;
    for (Iterator<TransactionType> tranIter=currentBlock.getAscTx().iterator(); tranIter.hasNext(); ) {
      tranProps=new HashMap<String,Object>();
      tran=tranIter.next();
      tranProps.put(""String_Node_Str"",tran.getHash());
      tranProps.put(""String_Node_Str"",tran.getVer());
      tranProps.put(""String_Node_Str"",tran.getVin_sz());
      tranProps.put(""String_Node_Str"",tran.getVout_sz());
      tranProps.put(""String_Node_Str"",tran.getSize());
      tranProps.put(""String_Node_Str"",tran.getRelayed_by());
      tranProps.put(""String_Node_Str"",tran.getTx_index());
      tranNode=restApi.createNode(tranProps);
      fromRelation=new HashMap<String,Object>();
      fromRelation.put(""String_Node_Str"",currentBlock.getHash());
      restApi.createRelationship(tranNode,currentBlockNode,BitcoinRelationships.from,fromRelation);
      transactionsIndex.add(tranNode,""String_Node_Str"",tran.getTx_index());
      Map<String,Object> moneyProps;
      RestNode outNode=null;
      OutputType output;
      Map<String,Object> sentRelation;
      int n=0;
      for (Iterator<OutputType> outputIter=tran.getOut().iterator(); outputIter.hasNext(); ) {
        moneyProps=new HashMap<String,Object>();
        output=outputIter.next();
        moneyProps.put(""String_Node_Str"",output.getType());
        moneyProps.put(""String_Node_Str"",output.getAddr());
        moneyProps.put(""String_Node_Str"",output.getValue());
        moneyProps.put(""String_Node_Str"",n);
        outNode=restApi.createNode(moneyProps);
        sentRelation=new HashMap<String,Object>();
        sentRelation.put(""String_Node_Str"",output.getAddr());
        sentRelation.put(""String_Node_Str"",n);
        restApi.createRelationship(tranNode,outNode,BitcoinRelationships.sent,sentRelation);
        n++;
      }
      Map<String,Object> receivedRelation;
      PrevOut prevOut;
      for (Iterator<InputType> inputIter=tran.getInputs().iterator(); inputIter.hasNext(); ) {
        moneyProps=new HashMap<String,Object>();
        prevOut=inputIter.next().getPrev_out();
        if (prevOut == null)         continue;
        moneyProps.put(""String_Node_Str"",prevOut.getType());
        moneyProps.put(""String_Node_Str"",prevOut.getAddr());
        moneyProps.put(""String_Node_Str"",prevOut.getValue());
        moneyProps.put(""String_Node_Str"",prevOut.getN());
        Node transactionNode=transactionsIndex.query(""String_Node_Str"",prevOut.getTx_index()).getSingle();
        if (transactionNode != null) {
          Iterable<Relationship> moneyNodeRelationships=transactionNode.getRelationships(BitcoinRelationships.sent,Direction.OUTGOING);
          for (Iterator<Relationship> moneyIter=moneyNodeRelationships.iterator(); moneyIter.hasNext(); ) {
            Node[] moneyNodes=moneyIter.next().getNodes();
            for (int i=0; i < moneyNodes.length; i++) {
              if (moneyNodes[i].hasProperty(""String_Node_Str"") && moneyNodes[i].hasProperty(""String_Node_Str"") && ((String)moneyNodes[i].getProperty(""String_Node_Str"")).contains(prevOut.getAddr())&& ((Integer)moneyNodes[i].getProperty(""String_Node_Str"") == prevOut.getN())) {
                receivedRelation=new HashMap<String,Object>();
                receivedRelation.put(""String_Node_Str"",prevOut.getTx_index());
                restApi.createRelationship(moneyNodes[i],tranNode,BitcoinRelationships.received,receivedRelation);
                break;
              }
            }
          }
        }
      }
    }
    lastDatabaseBlockIndex=currentBlock.getBlock_index();
    latestDatabaseBlock=currentBlockNode;
  }
}",0.9829364105082248
100926,"public void close() throws ZkInterruptedException {
  if (_connection == null) {
    return;
  }
  LOG.debug(""String_Node_Str"");
  getEventLock().lock();
  try {
    setShutdownTrigger(true);
    _eventThread.interrupt();
    _eventThread.join(2000);
    _connection.close();
    _connection=null;
  }
 catch (  InterruptedException e) {
    throw new ZkInterruptedException(e);
  }
 finally {
    getEventLock().unlock();
  }
  LOG.debug(""String_Node_Str"");
}","public void close() throws ZkInterruptedException {
  if (_connection == null) {
    return;
  }
  LOG.debug(""String_Node_Str"");
  getEventLock().lock();
  try {
    setShutdownTrigger(true);
    _eventThread.interrupt();
    _eventThread.join(2000);
    _connection.close();
    _connection=null;
    _eventThread=null;
  }
 catch (  InterruptedException e) {
    throw new ZkInterruptedException(e);
  }
 finally {
    getEventLock().unlock();
  }
  LOG.debug(""String_Node_Str"");
}",0.975609756097561
100927,"public void connect(final long maxMsToWaitUntilConnected,Watcher watcher){
  boolean started=false;
  try {
    getEventLock().lockInterruptibly();
    setShutdownTrigger(false);
    _eventThread=new ZkEventThread(_connection.getServers());
    _eventThread.start();
    _connection.connect(watcher);
    LOG.debug(""String_Node_Str"" + maxMsToWaitUntilConnected);
    if (!waitUntilConnected(maxMsToWaitUntilConnected,TimeUnit.MILLISECONDS)) {
      throw new ZkTimeoutException(String.format(""String_Node_Str"",_connection.getServers(),maxMsToWaitUntilConnected));
    }
    started=true;
  }
 catch (  InterruptedException e) {
    States state=_connection.getZookeeperState();
    throw new IllegalStateException(""String_Node_Str"" + state);
  }
 finally {
    getEventLock().unlock();
    if (!started) {
      close();
    }
  }
}","public synchronized void connect(final long maxMsToWaitUntilConnected,Watcher watcher){
  if (_eventThread != null) {
    return;
  }
  boolean started=false;
  try {
    getEventLock().lockInterruptibly();
    setShutdownTrigger(false);
    _eventThread=new ZkEventThread(_connection.getServers());
    _eventThread.start();
    _connection.connect(watcher);
    LOG.debug(""String_Node_Str"" + maxMsToWaitUntilConnected);
    if (!waitUntilConnected(maxMsToWaitUntilConnected,TimeUnit.MILLISECONDS)) {
      throw new ZkTimeoutException(String.format(""String_Node_Str"",_connection.getServers(),maxMsToWaitUntilConnected));
    }
    started=true;
  }
 catch (  InterruptedException e) {
    States state=_connection.getZookeeperState();
    throw new IllegalStateException(""String_Node_Str"" + state);
  }
 finally {
    getEventLock().unlock();
    if (!started) {
      close();
    }
  }
}",0.9657573998839234
100928,"@Before public void setUp() throws Exception {
  this.server=startZkServer(""String_Node_Str"" + counter.incrementAndGet(),4711);
  this.client=this.server.getZkClient();
}","@Before public void setUp() throws Exception {
  this.server=startZkServer(""String_Node_Str"" + counter.incrementAndGet(),4711);
  this.client=this.server.getZkClient();
  assertTrue(this.client.isConnected());
}",0.8923884514435696
100929,"public void setShutdownTrigger(boolean triggerState){
  _shutdownTriggered=triggerState;
}","private void setShutdownTrigger(boolean triggerState){
  _shutdownTriggered=triggerState;
}",0.9502762430939228
100930,"public void close() throws ZkInterruptedException {
  if (_connection == null) {
    return;
  }
  LOG.debug(""String_Node_Str"");
  getEventLock().lock();
  try {
    setShutdownTrigger(true);
    _eventThread.interrupt();
    _eventThread.join(2000);
    _connection.close();
    _connection=null;
    _eventThread=null;
  }
 catch (  InterruptedException e) {
    throw new ZkInterruptedException(e);
  }
 finally {
    getEventLock().unlock();
  }
  LOG.debug(""String_Node_Str"");
}","public synchronized void close() throws ZkInterruptedException {
  if (_eventThread == null) {
    return;
  }
  LOG.debug(""String_Node_Str"");
  getEventLock().lock();
  try {
    setShutdownTrigger(true);
    _currentState=null;
    _eventThread.interrupt();
    _eventThread.join(2000);
    _connection.close();
    _eventThread=null;
  }
 catch (  InterruptedException e) {
    throw new ZkInterruptedException(e);
  }
 finally {
    getEventLock().unlock();
  }
  LOG.debug(""String_Node_Str"");
}",0.9185336048879836
100931,"public boolean getShutdownTrigger(){
  return _shutdownTriggered;
}","private boolean getShutdownTrigger(){
  return _shutdownTriggered;
}",0.9333333333333332
100932,"@Override public void onStart(){
  super.onStart();
  String description=archiveMeta.getDescription().trim();
  if (description.length() > 0) {
    mDescription.setTextColor(getResources().getColor(R.color.snowhite));
    mDescription.setText(description);
  }
 else {
    mDescription.setTextColor(getResources().getColor(R.color.gray));
    mDescription.setText(getString(R.string.no_description));
  }
  mDescription.setOnClickListener(this);
  addArchiveMetaTimeFragment();
  addArchiveMetaFragment();
  actionBar.setTitle(getString(R.string.title_detail));
  actionBar.removeAllActions();
  actionBar.addAction(new ActionBar.Action(){
    @Override public int getDrawable(){
      return R.drawable.ic_menu_share;
    }
    @Override public void performAction(    View view){
      shareToSina();
    }
  }
);
}","@Override public void onStart(){
  super.onStart();
  String description=archiveMeta.getDescription().trim();
  if (description.length() > 0) {
    mDescription.setTextColor(getResources().getColor(R.color.snowhite));
    mDescription.setText(description);
  }
 else {
    mDescription.setTextColor(getResources().getColor(R.color.gray));
    mDescription.setText(getString(R.string.no_description));
  }
  mDescription.setOnClickListener(this);
  addArchiveMetaTimeFragment();
  addArchiveMetaFragment();
  actionBar.setTitle(getString(R.string.title_detail));
  actionBar.removeAllActions();
  actionBar.addAction(new ActionBar.Action(){
    @Override public int getDrawable(){
      return R.drawable.ic_menu_view;
    }
    @Override public void performAction(    View view){
      Intent intent=new Intent(context,SpeedCharts.class);
      intent.putExtra(Records.INTENT_ARCHIVE_FILE_NAME,archiveFileName);
      startActivity(intent);
    }
  }
);
  actionBar.addAction(new ActionBar.Action(){
    @Override public int getDrawable(){
      return R.drawable.ic_menu_share;
    }
    @Override public void performAction(    View view){
      shareToSina();
    }
  }
);
}",0.8122489959839357
100933,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  layoutView=inflater.inflate(R.layout.archive_meta_items,container,false);
  mDistance=(TextView)layoutView.findViewById(R.id.item_distance);
  mAvgSpeed=(TextView)layoutView.findViewById(R.id.item_avg_speed);
  mMaxSpeed=(TextView)layoutView.findViewById(R.id.item_max_speed);
  mRecords=(TextView)layoutView.findViewById(R.id.item_records);
  mAvgSpeed.setOnClickListener(this);
  mMaxSpeed.setOnClickListener(this);
  return layoutView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  layoutView=inflater.inflate(R.layout.archive_meta_items,container,false);
  mDistance=(TextView)layoutView.findViewById(R.id.item_distance);
  mAvgSpeed=(TextView)layoutView.findViewById(R.id.item_avg_speed);
  mMaxSpeed=(TextView)layoutView.findViewById(R.id.item_max_speed);
  mRecords=(TextView)layoutView.findViewById(R.id.item_records);
  return layoutView;
}",0.9256360078277888
100934,"private void updateView(){
  Cursor result=null;
  try {
    result=db.getReadableDatabase().rawQuery(""String_Node_Str"",null);
  }
 catch (  SQLiteException e) {
    Log.e(TAG,e.getMessage());
  }
  if (result.getCount() <= 0) {
    return;
  }
  double latitude, longitude, speed, bearing, altitude, accuracy;
  String timeStamp;
  result.moveToFirst();
  latitude=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  longitude=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  speed=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  bearing=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  altitude=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  accuracy=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  timeStamp=result.getString(result.getColumnIndex(""String_Node_Str""));
  timeStamp=new java.text.SimpleDateFormat(""String_Node_Str"").format(new java.util.Date(Long.parseLong(timeStamp)));
  String resultString=String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",db.getValvedCount(),latitude,longitude,speed,bearing,altitude,accuracy,timeStamp);
  resultString+=String.format(""String_Node_Str"",new java.text.SimpleDateFormat(""String_Node_Str"").format(new Date()));
  TextView t=(TextView)findViewById(R.id.status);
  t.setText(resultString);
}","private void updateView(){
  Cursor result=null;
  try {
    result=db.getReadableDatabase().rawQuery(""String_Node_Str"",null);
  }
 catch (  SQLiteException e) {
    Log.e(TAG,e.getMessage());
  }
  if (result.getCount() <= 0) {
    return;
  }
  double latitude, longitude, speed, bearing, altitude, accuracy;
  String timeStamp;
  result.moveToFirst();
  latitude=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  longitude=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  speed=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  if (maxSpeed < speed) {
    maxSpeed=speed;
  }
  bearing=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  altitude=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  accuracy=result.getDouble(result.getColumnIndex(""String_Node_Str""));
  timeStamp=result.getString(result.getColumnIndex(""String_Node_Str""));
  timeStamp=new java.text.SimpleDateFormat(""String_Node_Str"").format(new java.util.Date(Long.parseLong(timeStamp)));
  String resultString=String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",db.getValvedCount(),latitude,longitude,speed,maxSpeed,bearing,altitude,accuracy,timeStamp);
  resultString+=String.format(""String_Node_Str"",new java.text.SimpleDateFormat(""String_Node_Str"").format(new Date()));
  TextView t=(TextView)findViewById(R.id.status);
  t.setText(resultString);
}",0.9798703514158992
100935,"@Override public void onDestroy(){
  super.onDestroy();
  locManager.removeUpdates(locListener);
}","@Override public void onDestroy(){
  super.onDestroy();
  locManager.removeUpdates(loc);
}",0.9574468085106383
100936,"/** 
 * 绑定 GPS，获得地理位置等信息
 */
public void bindLocationListener(){
  locManager=(LocationManager)getSystemService(Context.LOCATION_SERVICE);
  locListener=new LocationListener(this.getApplicationContext());
  Log.e(TAG,""String_Node_Str"");
  locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,0,0,locListener);
}","/** 
 * 绑定 GPS，获得地理位置等信息
 */
public void bindLocationListener(){
  locManager=(LocationManager)getSystemService(Context.LOCATION_SERVICE);
  loc=new Location(this.getApplicationContext());
  Log.e(TAG,""String_Node_Str"");
  locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,0,0,loc);
}",0.9611650485436892
100937,"public Database(Context context){
  this.context=context;
  helper=new OpenHelper(this.context,context.getString(R.string.app_database_name));
}","public Database(Context context){
  this.context=context;
  this.helper=new OpenHelper(context,getDatabasePath());
}",0.8153846153846154
100938,"public long getValvedCount(){
  long count=0;
  Cursor result=null;
  try {
    result=getReadableDatabase().rawQuery(""String_Node_Str"",null);
    result.moveToFirst();
    count=result.getLong(result.getColumnIndex(""String_Node_Str""));
  }
 catch (  SQLiteException e) {
  }
  return count;
}","public long getValvedCount(){
  return getValvedCount(getReadableDatabase());
}",0.3333333333333333
100939,"public void close(){
  helper.close();
}","public void close(){
  if (helper != null) {
    helper.close();
  }
}",0.7272727272727273
100940,"@Override public void onLocationChanged(android.location.Location loc){
  ContentValues values=new ContentValues();
  DecimalFormat formatter=new DecimalFormat(""String_Node_Str"");
  String tmpLongitude=formatter.format(loc.getLongitude());
  String tmpLatitude=formatter.format(loc.getLatitude());
  if (tmpLatitude.equals(latitude) && tmpLongitude.equals(longitude)) {
    Log.i(TAG,String.format(""String_Node_Str"",loc.getLatitude(),loc.getLongitude()));
    return;
  }
  latitude=tmpLatitude;
  longitude=tmpLongitude;
  values.put(""String_Node_Str"",loc.getLatitude());
  values.put(""String_Node_Str"",loc.getLongitude());
  values.put(""String_Node_Str"",loc.getSpeed());
  values.put(""String_Node_Str"",loc.getBearing());
  values.put(""String_Node_Str"",loc.getAltitude());
  values.put(""String_Node_Str"",loc.getAccuracy());
  values.put(""String_Node_Str"",loc.getTime());
  try {
    db.insert(""String_Node_Str"",null,values);
    Log.v(TAG,String.format(""String_Node_Str"",latitude,longitude));
  }
 catch (  SQLException e) {
    Log.e(TAG,e.getMessage());
  }
  lastLocationRecord=loc;
}","@Override public void onLocationChanged(android.location.Location loc){
  ContentValues values=new ContentValues();
  DecimalFormat formatter=new DecimalFormat(""String_Node_Str"");
  String tmpLongitude=formatter.format(loc.getLongitude());
  String tmpLatitude=formatter.format(loc.getLatitude());
  if (tmpLatitude.equals(latitude) && tmpLongitude.equals(longitude)) {
    Log.v(TAG,String.format(""String_Node_Str"",loc.getLatitude(),loc.getLongitude()));
    return;
  }
  latitude=tmpLatitude;
  longitude=tmpLongitude;
  values.put(""String_Node_Str"",loc.getLatitude());
  values.put(""String_Node_Str"",loc.getLongitude());
  values.put(""String_Node_Str"",loc.getSpeed());
  values.put(""String_Node_Str"",loc.getBearing());
  values.put(""String_Node_Str"",loc.getAltitude());
  values.put(""String_Node_Str"",loc.getAccuracy());
  values.put(""String_Node_Str"",loc.getTime());
  try {
    db.insert(""String_Node_Str"",null,values);
    Log.v(TAG,String.format(""String_Node_Str"",latitude,longitude));
  }
 catch (  SQLException e) {
    Log.e(TAG,e.getMessage());
  }
  lastLocationRecord=loc;
}",0.9990808823529412
100941,"@Override public Response toResponse(Throwable exception){
  String name=exception.getClass().getName();
  if (name.equals(""String_Node_Str"")) {
    try {
      return (Response)exception.getClass().getMethod(""String_Node_Str"").invoke(exception);
    }
 catch (    Exception e) {
      return Response.status(Status.INTERNAL_SERVER_ERROR).build();
    }
  }
  Map<String,String> error=new HashMap<String,String>();
  error.put(""String_Node_Str"",exception.toString());
  return Response.status(Status.BAD_REQUEST).entity(error).build();
}","@Override public Response toResponse(Throwable exception){
  String name=exception.getClass().getName();
  if (name.equals(""String_Node_Str"")) {
    try {
      return (Response)exception.getClass().getMethod(""String_Node_Str"").invoke(exception);
    }
 catch (    Exception e) {
      return Response.status(Status.INTERNAL_SERVER_ERROR).build();
    }
  }
  exception.printStackTrace();
  Error error=new Error(exception.toString());
  return Response.status(Status.BAD_REQUEST).entity(error).build();
}",0.8886756238003839
100942,"public ConsoleState(TIAState tia,PIAState pia,RAMState ram,M6502State cpu,Cartridge cartridge,VideoStandard videoStandard){
  this.tiaState=tia;
  this.piaState=pia;
  this.ramState=ram;
  this.cpuState=cpu;
  this.cartridge=cartridge.clone();
  this.videoStandard=videoStandard;
}","public ConsoleState(TIAState tia,PIAState pia,RAMState ram,M6502State cpu,Cartridge cartridge,VideoStandard videoStandard){
  this.tiaState=tia;
  this.piaState=pia;
  this.ramState=ram;
  this.cpuState=cpu;
  this.cartridge=cartridge != null ? cartridge.clone() : null;
  this.videoStandard=videoStandard;
}",0.9541595925297114
100943,"public List<ControlChange> getChangesToSend(){
  List<ControlChange> changesToSend;
synchronized (queuedChanges) {
    if (queuedChanges.isEmpty())     changesToSend=emptyChanges;
 else {
      changesToSend=new ArrayList<ControlChange>(queuedChanges);
      queuedChanges.clear();
    }
  }
  return changesToSend;
}","public List<ControlChange> getChangesToSend(){
  List<ControlChange> changesToSend;
synchronized (queuedChanges) {
    if (queuedChanges.isEmpty())     return null;
 else {
      changesToSend=new ArrayList<ControlChange>(queuedChanges);
      queuedChanges.clear();
      return changesToSend;
    }
  }
}",0.8571428571428571
100944,"@Override public void controlStateChanged(Control control,boolean state){
synchronized (queuedChanges) {
    queuedChanges.add(new ControlChange(control,state));
  }
}","@Override public void controlStateChanged(Control control,int position){
synchronized (queuedChanges) {
    queuedChanges.add(new ControlChangeForPaddle(control,position));
  }
}",0.8927536231884058
100945,"public void serverControlChanges(List<ControlChange> changes){
  for (  ControlChange change : changes)   super.controlStateChanged(change.control,change.state);
}","public void serverControlChanges(List<ControlChange> changes){
  for (  ControlChange change : changes)   if (change instanceof ControlChangeForPaddle)   super.controlStateChanged(change.control,((ControlChangeForPaddle)change).position);
 else   super.controlStateChanged(change.control,change.state);
}",0.6980728051391863
100946,"public void receiveClientControlChanges(List<ControlChange> clientControlChages){
  for (  ControlChange change : clientControlChages)   controlsSocket.controlStateChanged(change.control,change.state);
}","public void receiveClientControlChanges(List<ControlChange> clientControlChages){
  for (  ControlChange change : clientControlChages)   if (change instanceof ControlChangeForPaddle)   controlsSocket.controlStateChanged(change.control,((ControlChangeForPaddle)change).position);
 else   controlsSocket.controlStateChanged(change.control,change.state);
}",0.7302158273381295
100947,"@Override public void controlStateChanged(Control control,boolean state){
  if (control == Control.FAST_SPEED || control.isStateControl()) {
    super.controlStateChanged(control,state);
    return;
  }
synchronized (queuedChanges) {
    queuedChanges.add(new ControlChange(control,state));
  }
}","@Override public void controlStateChanged(Control control,int position){
synchronized (queuedChanges) {
    queuedChanges.add(new ControlChangeForPaddle(control,position));
  }
}",0.6497890295358649
100948,"@Override public synchronized void clockPulse(){
  List<ControlChange> controlChanges=((ServerConsoleControlsSocketAdapter)controlsSocket).commitAndGetChangesToSend();
  if (powerOn)   tia.clockPulse();
  if (remoteTransmitter != null && remoteTransmitter.isClientConnected()) {
    ServerUpdate update=new ServerUpdate();
    if (!controlChanges.isEmpty())     update.controlChanges=controlChanges;
    update.isClockPulse=powerOn;
    remoteTransmitter.sendUpdate(update);
  }
}","@Override public synchronized void clockPulse(){
  List<ControlChange> controlChanges=((ServerConsoleControlsSocketAdapter)controlsSocket).commitAndGetChangesToSend();
  if (powerOn)   tia.clockPulse();
  if (remoteTransmitter != null && remoteTransmitter.isClientConnected()) {
    ServerUpdate update=new ServerUpdate();
    update.controlChanges=controlChanges;
    update.isClockPulse=powerOn;
    remoteTransmitter.sendUpdate(update);
  }
}",0.9621621621621622
100949,"private List<ControlChange> commitAndGetChangesToSend(){
  List<ControlChange> changesToSend;
synchronized (queuedChanges) {
    if (queuedChanges.isEmpty())     changesToSend=emptyChanges;
 else {
      changesToSend=new ArrayList<ControlChange>(queuedChanges);
      queuedChanges.clear();
    }
  }
  for (  ControlChange change : changesToSend)   super.controlStateChanged(change.control,change.state);
  return changesToSend;
}","private List<ControlChange> commitAndGetChangesToSend(){
  List<ControlChange> changesToSend;
synchronized (queuedChanges) {
    if (queuedChanges.isEmpty())     return null;
 else {
      changesToSend=new ArrayList<ControlChange>(queuedChanges);
      queuedChanges.clear();
    }
  }
  for (  ControlChange change : changesToSend)   if (change instanceof ControlChangeForPaddle)   super.controlStateChanged(change.control,((ControlChangeForPaddle)change).position);
 else   super.controlStateChanged(change.control,change.state);
  return changesToSend;
}",0.8202020202020202
100950,"@Override public void run(){
  ServerUpdate update;
  while (true) {
synchronized (updates) {
      while ((update=updates.poll()) == null) {
        try {
          updates.wait();
        }
 catch (        InterruptedException e) {
        }
      }
      updates.notifyAll();
    }
    try {
      if (receiver != null) {
        List<ControlChange> clientControlChages=receiver.receiveServerUpdate(update);
        console.receiveClientControlChanges(clientControlChages);
      }
    }
 catch (    RemoteException e) {
      e.printStackTrace();
      disconnectReceiver();
    }
  }
}","@Override public void run(){
  ServerUpdate update;
  while (true) {
synchronized (updates) {
      while ((update=updates.poll()) == null) {
        try {
          updates.wait();
        }
 catch (        InterruptedException e) {
        }
      }
      updates.notifyAll();
    }
    try {
      if (receiver != null) {
        List<ControlChange> clientControlChages=receiver.receiveServerUpdate(update);
        if (clientControlChages != null)         console.receiveClientControlChanges(clientControlChages);
      }
    }
 catch (    RemoteException ex) {
      System.out.println(""String_Node_Str"" + ex);
      disconnectReceiver();
    }
  }
}",0.9076305220883534
100951,"public void listen(){
  try {
    Registry reg=LocateRegistry.createRegistry(SERVICE_PORT);
    reg.bind(SERVICE_NAME,this);
  }
 catch (  Exception e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","public void listen(){
  try {
    Registry reg=LocateRegistry.createRegistry(SERVICE_PORT);
    reg.bind(SERVICE_NAME,this);
  }
 catch (  Exception ex) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ex,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}",0.9441441441441442
100952,"public boolean askUserForConnection(String server){
  boolean connected=false;
  while (!connected) {
    while (server == null || server.isEmpty()) {
      server=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
      if (server == null)       return false;
    }
    try {
      connect(server);
      connected=true;
    }
 catch (    Exception e) {
      e.printStackTrace();
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + server,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      server=null;
    }
  }
  return true;
}","public boolean askUserForConnection(String server){
  boolean connected=false;
  while (!connected) {
    while (server == null || server.isEmpty()) {
      server=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
      if (server == null)       return false;
    }
    try {
      connect(server);
      connected=true;
    }
 catch (    Exception ex) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + server + ""String_Node_Str""+ ex,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      server=null;
    }
  }
  return true;
}",0.955631399317406
100953,"@Override public void run(){
  ServerUpdate update;
  try {
    while (true) {
synchronized (updates) {
        while ((update=updates.poll()) == null) {
          try {
            updates.wait();
          }
 catch (          InterruptedException e) {
          }
        }
        updates.notifyAll();
      }
      if (outputStream != null) {
        outputStream.writeObject(update);
        outputStream.flush();
        socketOutputStream.flush();
        @SuppressWarnings(""String_Node_Str"") List<ControlChange> clientControlChanges=(List<ControlChange>)inputStream.readObject();
        console.receiveClientControlChanges(clientControlChanges);
      }
    }
  }
 catch (  IOException e) {
    disconnectReceiver();
  }
catch (  ClassNotFoundException e) {
    disconnectReceiver();
  }
}","@Override public void run(){
  ServerUpdate update;
  try {
    while (true) {
synchronized (updates) {
        while ((update=updates.poll()) == null) {
          try {
            updates.wait();
          }
 catch (          InterruptedException e) {
          }
        }
        updates.notifyAll();
      }
      if (outputStream != null) {
        outputStream.writeObject(update);
        outputStream.flush();
        socketOutputStream.flush();
        @SuppressWarnings(""String_Node_Str"") List<ControlChange> clientControlChanges=(List<ControlChange>)inputStream.readObject();
        if (clientControlChanges != null)         console.receiveClientControlChanges(clientControlChanges);
      }
    }
  }
 catch (  IOException e) {
    disconnectReceiver();
  }
catch (  ClassNotFoundException e) {
    disconnectReceiver();
  }
}",0.9743589743589745
100954,"public boolean listen(){
  try {
    ServerSocket serverSocket=new ServerSocket(SERVICE_PORT);
    connectReceiver(serverSocket.accept());
    serverSocket.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return false;
  }
  return true;
}","public boolean listen(){
  try {
    ServerSocket serverSocket=new ServerSocket(SERVICE_PORT);
    connectReceiver(serverSocket.accept());
    serverSocket.close();
  }
 catch (  Exception ex) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ex,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return false;
  }
  return true;
}",0.955777460770328
100955,"private static Cartridge read(FileContents fileCont){
  InputStream stream=null;
  String fileName=""String_Node_Str"";
  try {
    fileName=fileCont.getName();
    stream=fileCont.getInputStream();
    System.out.println(""String_Node_Str"" + fileName);
    stream.close();
    return CartridgeLoader.load(stream,fileName);
  }
 catch (  Exception ex) {
    System.out.println(""String_Node_Str"" + fileName);
    System.out.println(ex);
  }
 finally {
    if (stream != null)     try {
      stream.close();
    }
 catch (    IOException e) {
    }
  }
  return null;
}","private static Cartridge read(FileContents fileCont){
  InputStream stream=null;
  String fileName=""String_Node_Str"";
  try {
    fileName=fileCont.getName();
    stream=fileCont.getInputStream();
    System.out.println(""String_Node_Str"" + fileName);
    stream.close();
    return CartridgeLoader.load(stream,fileName);
  }
 catch (  Exception ex) {
    System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ ex);
  }
 finally {
    if (stream != null)     try {
      stream.close();
    }
 catch (    IOException e) {
    }
  }
  return null;
}",0.9573712255772646
100956,"public static Cartridge chooseFile(){
  try {
    FileOpenService fos=(FileOpenService)ServiceManager.lookup(""String_Node_Str"");
    FileContents fileCon=fos.openFileDialog(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    return read(fileCon);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return null;
  }
}","public static Cartridge chooseFile(){
  try {
    FileOpenService fos=(FileOpenService)ServiceManager.lookup(""String_Node_Str"");
    FileContents fileCon=fos.openFileDialog(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    return read(fileCon);
  }
 catch (  Exception ex) {
    System.out.println(""String_Node_Str"" + ex);
    return null;
  }
}",0.925531914893617
100957,"private void paddlesUpdatePosition(){
  if (paddle0MovingLeft) {
    paddle0Position+=paddle0Speed;
    if (paddle0Position > 380)     paddle0Position=380;
    consoleControlsInput.controlStateChanged(Control.PADDLE0_POSITION,paddle0Position);
  }
  if (paddle0MovingRight) {
    paddle0Position-=paddle0Speed;
    if (paddle0Position < 0)     paddle0Position=0;
    consoleControlsInput.controlStateChanged(Control.PADDLE0_POSITION,paddle0Position);
  }
  if (paddle1MovingLeft) {
    paddle1Position+=paddle1Speed;
    if (paddle1Position > 380)     paddle1Position=380;
    consoleControlsInput.controlStateChanged(Control.PADDLE1_POSITION,paddle1Position);
  }
  if (paddle1MovingRight) {
    paddle1Position-=paddle1Speed;
    if (paddle1Position < 0)     paddle1Position=0;
    consoleControlsInput.controlStateChanged(Control.PADDLE1_POSITION,paddle1Position);
  }
}","private void paddlesUpdatePosition(){
  if (paddle0MovingRight) {
    if (!paddle0MovingLeft) {
      paddle0Position-=paddle0Speed;
      if (paddle0Position < 0)       paddle0Position=0;
      consoleControlsInput.controlStateChanged(Control.PADDLE0_POSITION,paddle0Position);
    }
  }
 else   if (paddle0MovingLeft) {
    paddle0Position+=paddle0Speed;
    if (paddle0Position > 380)     paddle0Position=380;
    consoleControlsInput.controlStateChanged(Control.PADDLE0_POSITION,paddle0Position);
  }
  if (paddle1MovingRight) {
    if (!paddle1MovingLeft) {
      paddle1Position-=paddle1Speed;
      if (paddle1Position < 0)       paddle1Position=0;
      consoleControlsInput.controlStateChanged(Control.PADDLE1_POSITION,paddle1Position);
    }
  }
 else   if (paddle1MovingLeft) {
    paddle1Position+=paddle1Speed;
    if (paddle1Position > 380)     paddle1Position=380;
    consoleControlsInput.controlStateChanged(Control.PADDLE1_POSITION,paddle1Position);
  }
}",0.828819068255688
100958,"private void loadImages(){
  try {
    panelImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    retractButtonImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    expandButtonImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    closeButtonImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    powerDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    colorDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    selectDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    resetDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    p0DiffDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    p1DiffDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void loadImages(){
  try {
    panelImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    retractButtonImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    expandButtonImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    closeButtonImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    powerDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    colorDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    selectDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    resetDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    p0DiffDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    p1DiffDownImage=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"" + ex);
  }
}",0.967948717948718
100959,"@Override public Graphics2D canvasGraphics(){
  try {
    Graphics2D canvasGraphics=(Graphics2D)(bufferStrategy != null ? bufferStrategy.getDrawGraphics() : getGraphics());
    if (clearBackgoundFrames-- > 0) {
      canvasGraphics.setColor(Color.BLACK);
      canvasGraphics.clearRect(0,0,getWidth(),getHeight());
    }
    canvasGraphics.translate(canvasOriginX,canvasOriginY);
    return canvasGraphics;
  }
 catch (  IllegalStateException e) {
    e.printStackTrace();
    return null;
  }
}","@Override public Graphics2D canvasGraphics(){
  Graphics2D canvasGraphics=(Graphics2D)(bufferStrategy != null ? bufferStrategy.getDrawGraphics() : getGraphics());
  if (clearBackgoundFrames-- > 0) {
    canvasGraphics.setColor(Color.BLACK);
    canvasGraphics.clearRect(0,0,getWidth(),getHeight());
  }
  canvasGraphics.translate(canvasOriginX,canvasOriginY);
  return canvasGraphics;
}",0.8240635641316686
100960,"@Override public Graphics2D canvasGraphics(){
  try {
    Graphics2D graphics=(Graphics2D)(bufferStrategy != null ? bufferStrategy.getDrawGraphics() : canvas.getGraphics());
    return graphics;
  }
 catch (  IllegalStateException e) {
    e.printStackTrace();
    return null;
  }
}","@Override public Graphics2D canvasGraphics(){
  Graphics2D graphics=(Graphics2D)(bufferStrategy != null ? bufferStrategy.getDrawGraphics() : canvas.getGraphics());
  return graphics;
}",0.7880085653104925
100961,"private void loadImages(){
  try {
    topLeft=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomLeft=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    topRight=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomRight=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    top=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomLeftBar=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomRightBar=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomBar=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    logoBar=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    favicon=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    icon64=GraphicsDeviceHelper.loadAsCompatibleTranslucentImage(""String_Node_Str"");
    icon32=GraphicsDeviceHelper.loadAsCompatibleTranslucentImage(""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void loadImages(){
  try {
    topLeft=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomLeft=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    topRight=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomRight=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    top=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomLeftBar=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomRightBar=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    bottomBar=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    logoBar=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    favicon=GraphicsDeviceHelper.loadAsCompatibleImage(""String_Node_Str"");
    icon64=GraphicsDeviceHelper.loadAsCompatibleTranslucentImage(""String_Node_Str"");
    icon32=GraphicsDeviceHelper.loadAsCompatibleTranslucentImage(""String_Node_Str"");
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"" + ex);
  }
}",0.97134670487106
100962,"private void sendStateUpdate(){
  if (remoteTransmitter != null) {
    ServerUpdate update=new ServerUpdate();
    update.consoleState=saveState();
    remoteTransmitter.sendUpdate(update);
  }
}","private void sendStateUpdate(){
  if (remoteTransmitter != null && remoteTransmitter.isClientConnected()) {
    ServerUpdate update=new ServerUpdate();
    update.consoleState=saveState();
    remoteTransmitter.sendUpdate(update);
  }
}",0.9048723897911832
100963,"@Override public void run(){
  ServerUpdate update;
  try {
    while (true) {
synchronized (updates) {
        while ((update=updates.poll()) == null) {
          try {
            updates.wait();
          }
 catch (          InterruptedException e) {
          }
        }
        updates.notifyAll();
      }
      if (outputStream != null) {
        outputStream.writeObject(update);
        outputStream.flush();
        socketOutputStream.flush();
        @SuppressWarnings(""String_Node_Str"") List<ControlChange> clientControlChanges=(List<ControlChange>)inputStream.readObject();
        console.receiveClientControlChanges(clientControlChanges);
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    disconnectReceiver();
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
    disconnectReceiver();
  }
}","@Override public void run(){
  ServerUpdate update;
  try {
    while (true) {
synchronized (updates) {
        while ((update=updates.poll()) == null) {
          try {
            updates.wait();
          }
 catch (          InterruptedException e) {
          }
        }
        updates.notifyAll();
      }
      if (outputStream != null) {
        outputStream.writeObject(update);
        outputStream.flush();
        socketOutputStream.flush();
        @SuppressWarnings(""String_Node_Str"") List<ControlChange> clientControlChanges=(List<ControlChange>)inputStream.readObject();
        console.receiveClientControlChanges(clientControlChanges);
      }
    }
  }
 catch (  IOException e) {
    disconnectReceiver();
  }
catch (  ClassNotFoundException e) {
    disconnectReceiver();
  }
}",0.9696233292831106
100964,"public void loadState(TIAState state){
  linePixels=state.linePixels;
  lastObservableChangeClock=state.lastObservableChangeClock;
  repeatLastLine=state.repeatLastLine;
  vSyncOn=state.vSyncOn;
  vBlankOn=state.vBlankOn;
  playfieldPattern=state.playfieldPattern;
  playfieldPatternInvalid=state.playfieldPatternInvalid;
  playfieldCurrentPixel=state.playfieldCurrentPixel;
  playfieldColor=state.playfieldColor;
  playfieldBackground=state.playfieldBackground;
  playfieldReflected=state.playfieldReflected;
  playfieldScoreMode=state.playfieldScoreMode;
  playfieldPriority=state.playfieldPriority;
  player0ActiveSprite=state.player0ActiveSprite;
  player0DelayedSprite=state.player0DelayedSprite;
  player0Color=state.player0Color;
  player0RecentResetHit=state.player0RecentResetHit;
  player0Counter=state.player0Counter;
  player0ScanStartCountdown=state.player0ScanStartCountdown;
  player0ScanCounter=state.player0ScanCounter;
  player0ScanSpeed=state.player0ScanSpeed;
  player0ScanSubCounter=state.player0ScanSubCounter;
  player0VerticalDelay=state.player0VerticalDelay;
  player0CloseCopy=state.player0CloseCopy;
  player0MediumCopy=state.player0MediumCopy;
  player0WideCopy=state.player0WideCopy;
  player0Reflected=state.player0Reflected;
  player1ActiveSprite=state.player1ActiveSprite;
  player1DelayedSprite=state.player1DelayedSprite;
  player1Color=state.player1Color;
  player1RecentResetHit=state.player1RecentResetHit;
  player1Counter=state.player1Counter;
  player1ScanStartCountdown=state.player1ScanStartCountdown;
  player1ScanCounter=state.player1ScanCounter;
  player1ScanSpeed=state.player1ScanSpeed;
  player1ScanSubCounter=state.player1ScanSubCounter;
  player1VerticalDelay=state.player1VerticalDelay;
  player1CloseCopy=state.player1CloseCopy;
  player1MediumCopy=state.player1MediumCopy;
  player1WideCopy=state.player1WideCopy;
  player1Reflected=state.player1Reflected;
  missile0Enabled=state.missile0Enabled;
  missile0Color=state.missile0Color;
  missile0RecentResetHit=state.missile0RecentResetHit;
  missile0Counter=state.missile0Counter;
  missile0ScanCounter=state.missile0ScanCounter;
  missile0ScanSpeed=state.missile0ScanSpeed;
  missile0ScanSubCounter=state.missile0ScanSubCounter;
  missile0ResetToPlayer=state.missile0ResetToPlayer;
  missile1Enabled=state.missile1Enabled;
  missile1Color=state.missile1Color;
  missile1RecentResetHit=state.missile1RecentResetHit;
  missile1Counter=state.missile1Counter;
  missile1ScanCounter=state.missile1ScanCounter;
  missile1ScanSpeed=state.missile1ScanSpeed;
  missile1ScanSubCounter=state.missile1ScanSubCounter;
  missile1ResetToPlayer=state.missile1ResetToPlayer;
  ballEnabled=state.ballEnabled;
  ballDelayedEnablement=state.ballDelayedEnablement;
  ballColor=state.ballColor;
  ballCounter=state.ballCounter;
  ballScanCounter=state.ballScanCounter;
  ballScanSpeed=state.ballScanSpeed;
  ballScanSubCounter=state.ballScanSubCounter;
  ballVerticalDelay=state.ballVerticalDelay;
  playfieldDelayedChangeClock=state.playfieldDelayedChangeClock;
  playfieldDelayedChangePart=state.playfieldDelayedChangePart;
  playfieldDelayedChangePattern=state.playfieldDelayedChangePattern;
  playersDelayedSpriteChanges=state.playersDelayedSpriteChanges;
  playersDelayedSpriteChangesCount=state.playersDelayedSpriteChangesCount;
  controlsButtonsLatched=state.controlsButtonsLatched;
  controlsJOY0ButtonPressed=state.controlsJOY0ButtonPressed;
  controlsJOY1ButtonPressed=state.controlsJOY1ButtonPressed;
  paddle0Position=state.paddle0Position;
  paddle0CapacitorCharge=state.paddle0CapacitorCharge;
  paddle1Position=state.paddle1Position;
  paddle1CapacitorCharge=state.paddle1CapacitorCharge;
  PF0=state.PF0;
  PF1=state.PF1;
  PF2=state.PF2;
  AUDC0=state.AUDC0;
  audioOutput.channel0().setControl(AUDC0 & 0x0f);
  AUDC1=state.AUDC1;
  audioOutput.channel1().setControl(AUDC1 & 0x0f);
  AUDF0=state.AUDF0;
  audioOutput.channel0().setDivider((AUDF0 & 0x1f) + 1);
  AUDF1=state.AUDF1;
  audioOutput.channel1().setDivider((AUDF1 & 0x1f) + 1);
  AUDV0=state.AUDV0;
  audioOutput.channel0().setVolume(AUDV0 & 0x0f);
  AUDV1=state.AUDV1;
  audioOutput.channel1().setVolume(AUDV1 & 0x0f);
  HMP0=state.HMP0;
  HMP1=state.HMP1;
  HMM0=state.HMM0;
  HMM1=state.HMM1;
  HMBL=state.HMBL;
  CXM0P=state.CXM0P;
  CXM1P=state.CXM1P;
  CXP0FB=state.CXP0FB;
  CXP1FB=state.CXP1FB;
  CXM0FB=state.CXM0FB;
  CXM1FB=state.CXM1FB;
  CXBLPF=state.CXBLPF;
  CXPPMM=state.CXPPMM;
  if (debug)   debugSetColors();
}","public void loadState(TIAState state){
  linePixels=state.linePixels;
  lastObservableChangeClock=state.lastObservableChangeClock;
  repeatLastLine=state.repeatLastLine;
  vSyncOn=state.vSyncOn;
  vBlankOn=state.vBlankOn;
  playfieldPattern=state.playfieldPattern;
  playfieldPatternInvalid=state.playfieldPatternInvalid;
  playfieldCurrentPixel=state.playfieldCurrentPixel;
  playfieldColor=state.playfieldColor;
  playfieldBackground=state.playfieldBackground;
  playfieldReflected=state.playfieldReflected;
  playfieldScoreMode=state.playfieldScoreMode;
  playfieldPriority=state.playfieldPriority;
  player0ActiveSprite=state.player0ActiveSprite;
  player0DelayedSprite=state.player0DelayedSprite;
  player0Color=state.player0Color;
  player0RecentResetHit=state.player0RecentResetHit;
  player0Counter=state.player0Counter;
  player0ScanStartCountdown=state.player0ScanStartCountdown;
  player0ScanCounter=state.player0ScanCounter;
  player0ScanSpeed=state.player0ScanSpeed;
  player0ScanSubCounter=state.player0ScanSubCounter;
  player0VerticalDelay=state.player0VerticalDelay;
  player0CloseCopy=state.player0CloseCopy;
  player0MediumCopy=state.player0MediumCopy;
  player0WideCopy=state.player0WideCopy;
  player0Reflected=state.player0Reflected;
  player1ActiveSprite=state.player1ActiveSprite;
  player1DelayedSprite=state.player1DelayedSprite;
  player1Color=state.player1Color;
  player1RecentResetHit=state.player1RecentResetHit;
  player1Counter=state.player1Counter;
  player1ScanStartCountdown=state.player1ScanStartCountdown;
  player1ScanCounter=state.player1ScanCounter;
  player1ScanSpeed=state.player1ScanSpeed;
  player1ScanSubCounter=state.player1ScanSubCounter;
  player1VerticalDelay=state.player1VerticalDelay;
  player1CloseCopy=state.player1CloseCopy;
  player1MediumCopy=state.player1MediumCopy;
  player1WideCopy=state.player1WideCopy;
  player1Reflected=state.player1Reflected;
  missile0Enabled=state.missile0Enabled;
  missile0Color=state.missile0Color;
  missile0RecentResetHit=state.missile0RecentResetHit;
  missile0Counter=state.missile0Counter;
  missile0ScanCounter=state.missile0ScanCounter;
  missile0ScanSpeed=state.missile0ScanSpeed;
  missile0ScanSubCounter=state.missile0ScanSubCounter;
  missile0ResetToPlayer=state.missile0ResetToPlayer;
  missile1Enabled=state.missile1Enabled;
  missile1Color=state.missile1Color;
  missile1RecentResetHit=state.missile1RecentResetHit;
  missile1Counter=state.missile1Counter;
  missile1ScanCounter=state.missile1ScanCounter;
  missile1ScanSpeed=state.missile1ScanSpeed;
  missile1ScanSubCounter=state.missile1ScanSubCounter;
  missile1ResetToPlayer=state.missile1ResetToPlayer;
  ballEnabled=state.ballEnabled;
  ballDelayedEnablement=state.ballDelayedEnablement;
  ballColor=state.ballColor;
  ballCounter=state.ballCounter;
  ballScanCounter=state.ballScanCounter;
  ballScanSpeed=state.ballScanSpeed;
  ballScanSubCounter=state.ballScanSubCounter;
  ballVerticalDelay=state.ballVerticalDelay;
  playfieldDelayedChangeClock=state.playfieldDelayedChangeClock;
  playfieldDelayedChangePart=state.playfieldDelayedChangePart;
  playfieldDelayedChangePattern=state.playfieldDelayedChangePattern;
  playersDelayedSpriteChanges=state.playersDelayedSpriteChanges;
  playersDelayedSpriteChangesCount=state.playersDelayedSpriteChangesCount;
  controlsButtonsLatched=state.controlsButtonsLatched;
  PF0=state.PF0;
  PF1=state.PF1;
  PF2=state.PF2;
  AUDC0=state.AUDC0;
  audioOutput.channel0().setControl(AUDC0 & 0x0f);
  AUDC1=state.AUDC1;
  audioOutput.channel1().setControl(AUDC1 & 0x0f);
  AUDF0=state.AUDF0;
  audioOutput.channel0().setDivider((AUDF0 & 0x1f) + 1);
  AUDF1=state.AUDF1;
  audioOutput.channel1().setDivider((AUDF1 & 0x1f) + 1);
  AUDV0=state.AUDV0;
  audioOutput.channel0().setVolume(AUDV0 & 0x0f);
  AUDV1=state.AUDV1;
  audioOutput.channel1().setVolume(AUDV1 & 0x0f);
  HMP0=state.HMP0;
  HMP1=state.HMP1;
  HMM0=state.HMM0;
  HMM1=state.HMM1;
  HMBL=state.HMBL;
  CXM0P=state.CXM0P;
  CXM1P=state.CXM1P;
  CXP0FB=state.CXP0FB;
  CXP1FB=state.CXP1FB;
  CXM0FB=state.CXM0FB;
  CXM1FB=state.CXM1FB;
  CXBLPF=state.CXBLPF;
  CXPPMM=state.CXPPMM;
  if (debug)   debugSetColors();
}",0.9637497113830524
100965,"public void powerOn(){
  Arrays.fill(linePixels,HBLANK_COLOR);
  Arrays.fill(debugPixels,0);
  groundLatchesAtPowerOn();
  observableChange();
  powerOn=true;
}","public void powerOn(){
  Arrays.fill(linePixels,HBLANK_COLOR);
  Arrays.fill(debugPixels,0);
  initLatchesAtPowerOn();
  observableChange();
  powerOn=true;
}",0.9748427672955976
100966,"protected CartridgeBanked(Boolean superChip,int extraRAMSize){
  super();
  this.extraRAMSize=extraRAMSize;
  if (superChip == null) {
    superChipMode=false;
    superChipAutoDetect=true;
  }
 else {
    superChipMode=superChip;
    superChipAutoDetect=false;
  }
  extraRAM=superChip != false ? new byte[this.extraRAMSize] : null;
}","protected CartridgeBanked(Boolean superChip,int extraRAMSize){
  super();
  this.extraRAMSize=extraRAMSize;
  if (superChip == null) {
    superChipMode=false;
    superChipAutoDetect=true;
  }
 else {
    superChipMode=superChip;
    superChipAutoDetect=false;
  }
  extraRAM=(superChip == null || superChip) ? new byte[this.extraRAMSize] : null;
}",0.9269005847953216
100967,"private void paintLogo(){
synchronized (refreshMonitor) {
    Graphics2D canvasGraphics=canvasGraphics();
    if (canvasGraphics == null)     return;
    canvasGraphics.setColor(Color.BLACK);
    int w=canvas.canvasEffectiveSize().width;
    int h=canvas.canvasEffectiveSize().height;
    canvasGraphics.fillRect(0,0,w,h);
    canvasGraphics.drawImage(logoIcon,(w - logoIcon.getWidth(null)) / 2,(h - logoIcon.getHeight(null)) / 2,null);
    paintOSD(canvasGraphics);
    canvasFinish(canvasGraphics);
  }
}","private void paintLogo(){
synchronized (refreshMonitor) {
    Graphics2D canvasGraphics=canvasGraphics();
    if (canvasGraphics == null)     return;
    int w=canvas.canvasEffectiveSize().width;
    int h=canvas.canvasEffectiveSize().height;
    canvasGraphics.setBackground(Color.BLACK);
    canvasGraphics.clearRect(0,0,w,h);
    canvasGraphics.drawImage(logoIcon,(w - logoIcon.getWidth(null)) / 2,(h - logoIcon.getHeight(null)) / 2,null);
    paintOSD(canvasGraphics);
    canvasFinish(canvasGraphics);
  }
}",0.7288801571709234
100968,"private Graphics2D canvasGraphics(){
  if (canvas == null)   return null;
  Graphics2D canvasGraphics=canvas.canvasGraphics();
  if (canvasGraphics != null)   canvasGraphics.setRenderingHint(RenderingHints.KEY_RENDERING,qualityRendering ? RenderingHints.VALUE_RENDER_QUALITY : RenderingHints.VALUE_RENDER_DEFAULT);
  return canvasGraphics;
}","private Graphics2D canvasGraphics(){
  if (canvas == null)   return null;
  Graphics2D canvasGraphics=canvas.canvasGraphics();
  canvasGraphics.setComposite(AlphaComposite.Src);
  if (canvasGraphics != null)   canvasGraphics.setRenderingHint(RenderingHints.KEY_RENDERING,qualityRendering ? RenderingHints.VALUE_RENDER_QUALITY : RenderingHints.VALUE_RENDER_DEFAULT);
  return canvasGraphics;
}",0.9304229195088676
100969,"private void refresh(){
  if (!signalOn) {
    paintLogo();
    return;
  }
synchronized (refreshMonitor) {
    Graphics2D canvasGraphics=canvasGraphics();
    if (canvasGraphics == null)     return;
    int canvasEffectiveWidth=canvas.canvasEffectiveSize().width;
    int canvasEffectiveHeight=canvas.canvasEffectiveSize().height;
    if (crtMode >= 3 || (MULTI_BUFFERING < 2 && (osdFramesLeft >= 0 || crtMode > 0))) {
      int intermWidth=Math.min(canvasEffectiveWidth,2048);
      int intermHeight=Math.min(canvasEffectiveHeight,1280);
      Graphics2D intermGraphics=intermFrameImage.createGraphics();
      intermGraphics.setBackground(Color.BLACK);
      intermGraphics.clearRect(0,0,intermWidth,intermHeight);
      renderFrame(intermGraphics,intermWidth,intermHeight);
      if (crtMode == 2)       intermGraphics.drawImage(scanlinesTextureImage,0,0,intermWidth,intermHeight,0,0,intermWidth,intermHeight,null);
      if (crtMode >= 3) {
        intermGraphics.setComposite(crtTriadComposite);
        intermGraphics.drawImage(intermFrameImage,0,0,intermWidth,intermHeight,0,0,intermWidth,intermHeight,null);
      }
      intermGraphics.dispose();
      canvasGraphics.drawImage(intermFrameImage,0,0,intermWidth,intermHeight,0,0,intermWidth,intermHeight,null);
      paintOSD(canvasGraphics);
    }
 else {
      renderFrame(canvasGraphics,canvasEffectiveWidth,canvasEffectiveHeight);
      if (crtMode == 2)       canvasGraphics.drawImage(scanlinesTextureImage,0,0,canvasEffectiveWidth,canvasEffectiveHeight,0,0,canvasEffectiveWidth,canvasEffectiveHeight,null);
      paintOSD(canvasGraphics);
    }
    canvasFinish(canvasGraphics);
  }
}","private void refresh(){
  if (!signalOn) {
    paintLogo();
    return;
  }
synchronized (refreshMonitor) {
    Graphics2D canvasGraphics=canvasGraphics();
    if (canvasGraphics == null)     return;
    int canvasEffectiveWidth=canvas.canvasEffectiveSize().width;
    int canvasEffectiveHeight=canvas.canvasEffectiveSize().height;
    if (crtMode >= 3 || (MULTI_BUFFERING < 2 && (osdFramesLeft >= 0 || crtMode > 0))) {
      int intermWidth=Math.min(canvasEffectiveWidth,2048);
      int intermHeight=Math.min(canvasEffectiveHeight,1280);
      Graphics2D intermGraphics=intermFrameImage.createGraphics();
      intermGraphics.setBackground(Color.BLACK);
      intermGraphics.clearRect(0,0,intermWidth,intermHeight);
      renderFrame(intermGraphics,intermWidth,intermHeight);
      if (crtMode == 2)       intermGraphics.drawImage(scanlinesTextureImage,0,0,intermWidth,intermHeight,0,0,intermWidth,intermHeight,null);
      if (crtMode >= 3) {
        intermGraphics.setComposite(crtTriadComposite);
        intermGraphics.drawImage(intermFrameImage,0,0,intermWidth,intermHeight,0,0,intermWidth,intermHeight,null);
      }
      paintOSD(intermGraphics);
      intermGraphics.dispose();
      canvasGraphics.drawImage(intermFrameImage,0,0,intermWidth,intermHeight,0,0,intermWidth,intermHeight,null);
    }
 else {
      renderFrame(canvasGraphics,canvasEffectiveWidth,canvasEffectiveHeight);
      if (crtMode == 2) {
        canvasGraphics.setComposite(AlphaComposite.SrcOver);
        canvasGraphics.drawImage(scanlinesTextureImage,0,0,canvasEffectiveWidth,canvasEffectiveHeight,0,0,canvasEffectiveWidth,canvasEffectiveHeight,null);
      }
      paintOSD(canvasGraphics);
    }
    canvasFinish(canvasGraphics);
  }
}",0.78018392168496
100970,"private void renderFrame(Graphics2D graphics,int canvasWidth,int canvasHeight){
  if (crtMode > 0 && crtMode != 3) {
    graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,CRT_RETENTION_ALPHA));
    graphics.drawImage(frameImage,0,0,canvasWidth,canvasHeight,0,0,displayWidth,displayHeight,null);
  }
  frameImage.getRaster().setDataElements(0,0,displayWidth,displayHeight,frontBuffer);
  graphics.drawImage(frameImage,0,0,canvasWidth,canvasHeight,0,0,displayWidth,displayHeight,null);
  if (crtMode > 0 && crtMode != 3)   graphics.setComposite(AlphaComposite.SrcOver);
}","private void renderFrame(Graphics2D graphics,int canvasWidth,int canvasHeight){
  if (crtMode > 0 && crtMode != 3) {
    graphics.setBackground(Color.BLACK);
    graphics.clearRect(0,0,canvasWidth,canvasHeight);
    graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,CRT_RETENTION_ALPHA));
    graphics.drawImage(frameImage,0,0,canvasWidth,canvasHeight,0,0,displayWidth,displayHeight,null);
  }
  frameImage.getRaster().setDataElements(0,0,displayWidth,displayHeight,frontBuffer);
  graphics.drawImage(frameImage,0,0,canvasWidth,canvasHeight,0,0,displayWidth,displayHeight,null);
}",0.8502092050209205
100971,"private void paintOSD(Graphics2D canvasGraphics){
  if (--osdFramesLeft < 0)   return;
  osdComponent.setText(osdMessage);
  Dimension s=osdComponent.getPreferredSize();
  SwingUtilities.paintComponent(canvasGraphics,osdComponent,canvas.canvasContainer(),(canvas.canvasEffectiveSize().width - s.width) - 12,12,s.width,s.height);
}","private void paintOSD(Graphics2D canvasGraphics){
  if (--osdFramesLeft < 0)   return;
  canvasGraphics.setComposite(AlphaComposite.SrcOver);
  osdComponent.setText(osdMessage);
  Dimension s=osdComponent.getPreferredSize();
  SwingUtilities.paintComponent(canvasGraphics,osdComponent,canvas.canvasContainer(),(canvas.canvasEffectiveSize().width - s.width) - 12,12,s.width,s.height);
}",0.9230769230769232
100972,"public BUS(TIA tia,PIA pia,RAM ram,Cartridge cart){
  this.cartridge=cart;
  this.ram=ram;
  this.tia=tia;
  this.pia=pia;
}","public BUS(TIA tia,PIA pia,RAM ram){
  this.ram=ram;
  this.tia=tia;
  this.pia=pia;
}",0.819047619047619
100973,"public void forceVideoStandard(VideoStandard videoStandard){
  this.videoStandard=videoStandard;
}","public void forceVideoStandard(VideoStandard videoStandard){
  this.forcedVideoStandard=videoStandard;
}",0.9603960396039604
100974,"@Override public void writeByte(int address,byte b){
  int addr=maskAddress(address);
  if (addr <= 0x7f && (superChipMode || superChipAutoDetect)) {
    if (!superChipMode)     superChipMode=true;
    extraRAM[addr]=b;
  }
}","@Override public void writeByte(int address,byte b){
  int addr=maskAddress(address);
  if (addr <= 0x7f && (superChipMode || superChipAutoDetect)) {
    if (!superChipMode) {
      superChipMode=true;
      System.out.println(""String_Node_Str"");
    }
    extraRAM[addr]=b;
  }
}",0.8
100975,"protected void mainComponentsCreate(Cartridge cartridge){
  cpu=new M6502();
  pia=new PIA(this);
  ram=new RAM();
  tia=new TIA(cpu,pia,cartridge.videoStandard());
  bus=new BUS(tia,pia,ram,cartridge);
  cpu.connectBus(bus);
}","protected void mainComponentsCreate(){
  cpu=new M6502();
  pia=new PIA(this);
  ram=new RAM();
  tia=new TIA(this,cpu,pia);
  bus=new BUS(tia,pia,ram);
  cpu.connectBus(bus);
}",0.8514851485148515
100976,"public void powerOff(){
  mainClockPause();
  tia.powerOff();
  bus.ram(ram=new RAM());
  powerOn=false;
  controlsSocket.controlsStatesRedefined();
}","public void powerOff(){
  mainClockPause();
  tia.powerOff();
  pia.powerOff();
  cpu.powerOff();
  ram.powerOff();
  powerOn=false;
  controlsSocket.controlsStatesRedefined();
}",0.823170731707317
100977,"public Console(Cartridge cartridge){
  mainComponentsCreate(cartridge);
  socketsCreate();
  mainClockCreate();
  cartridge(cartridge);
}","public Console(Cartridge cartridge){
  mainComponentsCreate();
  socketsCreate();
  mainClockCreate();
  videoStandardAuto();
  cartridge(cartridge);
}",0.8888888888888888
100978,"public void powerOn(){
  if (powerOn)   powerOff();
  cpu.powerOn();
  pia.powerOn();
  tia.powerOn();
  powerOn=true;
  controlsSocket.controlsStatesRedefined();
  mainClockGo();
}","public void powerOn(){
  if (powerOn)   powerOff();
  ram.powerOn();
  cpu.powerOn();
  pia.powerOn();
  tia.powerOn();
  powerOn=true;
  controlsSocket.controlsStatesRedefined();
  mainClockGo();
}",0.9551451187335092
100979,"protected void cartridge(Cartridge cartridge){
  bus.cartridge(cartridge);
  tia.videoStandard(cartridge.videoStandard());
  mainClockAdjustToNormal();
}","protected void cartridge(Cartridge cartridge){
  bus.cartridge(cartridge);
  if (cartridge.forcedVideoStandard() != null)   videoStandardForced(cartridge.forcedVideoStandard());
}",0.7349397590361446
100980,"@Override public synchronized void clockPulse(){
  List<ControlChange> controlChanges=((ServerConsoleControlsSocketAdapter)controlsSocket).commitAndGetChangesToSend();
  if (powerOn)   tia.clockPulse();
  if (remoteTransmitter.isClientConnected()) {
    ServerUpdate update=new ServerUpdate();
    if (!controlChanges.isEmpty())     update.controlChanges=controlChanges;
    update.isClockPulse=powerOn;
    remoteTransmitter.sendUpdate(update);
  }
}","@Override public synchronized void clockPulse(){
  List<ControlChange> controlChanges=((ServerConsoleControlsSocketAdapter)controlsSocket).commitAndGetChangesToSend();
  if (powerOn)   tia.clockPulse();
  if (remoteTransmitter != null && remoteTransmitter.isClientConnected()) {
    ServerUpdate update=new ServerUpdate();
    if (!controlChanges.isEmpty())     update.controlChanges=controlChanges;
    update.isClockPulse=powerOn;
    remoteTransmitter.sendUpdate(update);
  }
}",0.9688506981740064
100981,"public void loadState(PIAState state){
  debug=state.debug;
  timerCount=state.timerCount;
  currentTimerInterval=state.currentTimerInterval;
  lastSetTimerInterval=state.lastSetTimerInterval;
  SWACNT=state.SWACNT;
  SWCHB=state.SWCHB;
  SWBCNT=state.SWBCNT;
  INTIM=state.INTIM;
  INSTAT=state.INSTAT;
  TIM1T=state.TIM1T;
  TIM8T=state.TIM8T;
  TIM64T=state.TIM64T;
  T1024T=state.T1024T;
}","public void loadState(PIAState state){
  timerCount=state.timerCount;
  currentTimerInterval=state.currentTimerInterval;
  lastSetTimerInterval=state.lastSetTimerInterval;
  SWACNT=state.SWACNT;
  SWCHB=state.SWCHB;
  SWBCNT=state.SWBCNT;
  INTIM=state.INTIM;
  INSTAT=state.INSTAT;
  TIM1T=state.TIM1T;
  TIM8T=state.TIM8T;
  TIM64T=state.TIM64T;
  T1024T=state.T1024T;
}",0.9725490196078432
100982,"public PIA(Console console){
  this.console=console;
  powerOn();
}","public PIA(Console console){
  this.console=console;
}",0.8925619834710744
100983,"@Override public void onResume(){
  super.onResume();
  if (db.availableEntries()) {
    titleTextView.setText(this.getString(R.string.availableData));
    chartInit();
    new Thread(new Runnable(){
      @Override public void run(){
        try {
          chartDraw();
        }
 catch (        Exception e) {
        }
      }
    }
).start();
  }
 else {
    titleTextView.setText(this.getString(R.string.notAvailableDataYet));
  }
}","@Override public void onResume(){
  super.onResume();
  if (db.availableEntries()) {
    titleTextView.setText(this.getString(R.string.availableData));
    chartInit();
    new Thread(new Runnable(){
      @Override public void run(){
        try {
          chartDraw();
        }
 catch (        Exception e) {
        }
      }
    }
).start();
  }
 else {
    titleTextView.setText(this.getString(R.string.notAvailableDataYet));
    db.close();
  }
}",0.9753363228699552
100984,"@Override public int select0(int count){
}","@Override public int select0(int count){
  if (count > size0)   return -1;
  if (count <= 3) {
    if (count == 1)     return node1pos;
 else     if (count == 2)     return node2pos;
 else     if (count == 3)     return node3pos;
 else     return -1;
  }
  int idx=count / BITS0_COUNT_IN_EACH_INDEX;
  int start=0;
  int end=0;
  if (idx < indexCache0.size()) {
    start=indexCache0.get(idx);
    if (count % CACHE_WIDTH == 0)     return start;
    start/=CACHE_WIDTH;
    if (idx + 1 < indexCache0.size()) {
      end=indexCache0.get(idx + 1) / CACHE_WIDTH + 1;
    }
 else {
      end=countCache0Size(size);
    }
  }
 else   if (idx > 0) {
    start=indexCache0.get(idx - 1) / CACHE_WIDTH;
    end=Math.min(start + CACHE_WIDTH,countCache0Size(size));
  }
  long m=-1 * Unsafe.ARRAY_INT_INDEX_SCALE + Unsafe.ARRAY_INT_BASE_OFFSET;
  int d=0;
  long startOffset=start * Unsafe.ARRAY_INT_INDEX_SCALE + Unsafe.ARRAY_INT_BASE_OFFSET;
  long endOffset=end * Unsafe.ARRAY_INT_INDEX_SCALE + Unsafe.ARRAY_INT_BASE_OFFSET;
  if (startOffset != endOffset) {
    do {
      m=((startOffset + endOffset) / 2) & 0xfffffffffffffffcL;
      d=count - unsafe.getInt(countCache0,m);
      if (d < 0) {
        endOffset=m;
        continue;
      }
 else       if (d > 0) {
        if (startOffset != m)         startOffset=m;
 else         break;
      }
 else {
        break;
      }
    }
 while (endOffset - startOffset >= 4);
    if (d > 0) {
      count=d;
    }
 else {
      while (m >= Unsafe.ARRAY_INT_BASE_OFFSET && count <= unsafe.getInt(countCache0,m)) {
        m-=Unsafe.ARRAY_INT_INDEX_SCALE;
      }
      if (m >= Unsafe.ARRAY_INT_BASE_OFFSET)       count-=unsafe.getInt(countCache0,m);
    }
  }
  int n=bytes.length;
  for (int i=(((int)(m - Unsafe.ARRAY_INT_BASE_OFFSET) / Unsafe.ARRAY_INT_INDEX_SCALE) + 1) * CACHE_WIDTH / 8; i < n; i++) {
    int bits=bytes[i] & 0xff;
    int c=BITCOUNTS0[bits];
    if (count <= c) {
      return i * 8 + BITPOS0[bits][count - 1];
    }
    count-=c;
  }
  return -1;
}",0.0408560311284046
100985,"@Override public int select0(int count){
  if (count > size0)   return -1;
  if (count <= 3) {
    if (count == 1)     return node1pos;
 else     if (count == 2)     return node2pos;
 else     if (count == 3)     return node3pos;
 else     return -1;
  }
  int c=count - 1;
  int ci=bvD.rank1(c) - 1;
  int u=ci + arS[bvR.rank1(ci) - 1];
  if (u != 0) {
    int ui=u * 8;
    int r=u == 0 ? 0 : rank0(ui - 1);
    return ui + find0(longs[u],c - r);
  }
 else {
    return find0(longs[0],c);
  }
}","@Override public int select0(int count){
  if (count > size0)   return -1;
  if (count <= 3) {
    if (count == 1)     return node1pos;
 else     if (count == 2)     return node2pos;
 else     if (count == 3)     return node3pos;
 else     return -1;
  }
  int c=count - 1;
  int ci=bvD.rank1(c) - 1;
  int u=ci + arS[bvR.rank1(ci) - 1];
  if (u != 0) {
    int ui=u * 8;
    int r=rank0(ui - 1);
    int bi=u % 8;
    return ui + BITPOS0[(int)((longs[u / 8] >>> ((7 - bi) * 8)) & 0xff)][c - r];
  }
 else {
    return BITPOS0[(int)((longs[0] >>> 56) & 0xff)][c];
  }
}",0.8676056338028169
100986,"public void append1(){
  int blockIndex=size / BITS_IN_BLOCK;
  int indexInBlock=size % BITS_IN_BLOCK;
  int cacheBlockIndex=size / BITS_IN_COUNTCACHE0;
  if (blockIndex >= longs.length) {
    extendLongsAndCountCache0();
  }
  if (size % BITS_IN_COUNTCACHE0 == 0 && cacheBlockIndex > 0) {
    countCache0[cacheBlockIndex]=countCache0[cacheBlockIndex - 1];
  }
  longs[blockIndex]|=0x8000000000000000L >>> (size % BITS_IN_BLOCK);
  if (indexInBlock == 0) {
    prevBsC=currentBsC;
    currentBsC=false;
    arS[arSSize - 1]++;
  }
  size++;
  if (size % BITS_IN_BLOCK == 0) {
    first0bitInBlock=true;
  }
}","public void append1(){
  int blockIndex=size / BITS_IN_BLOCK;
  int cacheBlockIndex=size / BITS_IN_COUNTCACHE0;
  if (blockIndex >= longs.length) {
    extendLongsAndCountCache0();
  }
  if (size % BITS_IN_COUNTCACHE0 == 0 && cacheBlockIndex > 0) {
    countCache0[cacheBlockIndex]=countCache0[cacheBlockIndex - 1];
  }
  longs[blockIndex]|=0x8000000000000000L >>> (size % BITS_IN_BLOCK);
  if ((size % 8) == 0) {
    prevBsC=currentBsC;
    currentBsC=false;
    arS[arSSize - 1]++;
  }
  size++;
  if (size % 8 == 0) {
    first0bitInBlock=true;
  }
}",0.933677863910422
100987,"public void append0(){
  int blockIndex=size / BITS_IN_BLOCK;
  int indexInBlock=size % BITS_IN_BLOCK;
  int cacheBlockIndex=size / BITS_IN_COUNTCACHE0;
  int indexInCacheBlock=size % BITS_IN_COUNTCACHE0;
  if (blockIndex >= longs.length) {
    extendLongsAndCountCache0();
  }
  if (indexInCacheBlock == 0 && cacheBlockIndex > 0) {
    countCache0[cacheBlockIndex]=countCache0[cacheBlockIndex - 1];
  }
  size0++;
switch (size0) {
case 1:
    node1pos=size;
  break;
case 2:
node2pos=size;
break;
case 3:
node3pos=size;
break;
}
countCache0[cacheBlockIndex]++;
if (first0bitInBlock) {
bvD.append1();
first0bitInBlock=false;
}
 else {
bvD.append0();
}
if (indexInBlock == 0) {
if (bvR.size() == 0 || !currentBsC) {
bvR.append1();
addArS();
}
 else {
bvR.append0();
}
prevBsC=currentBsC;
currentBsC=true;
}
 else if (!currentBsC) {
if (bvR.size() == 0 || !prevBsC) {
bvR.append1();
}
 else {
bvR.append0();
}
arS[arSSize - 1]--;
if (!prevBsC) {
addArS();
}
currentBsC=true;
}
size++;
if (size % 8 == 0) {
first0bitInBlock=true;
}
}","public void append0(){
  int blockIndex=size / BITS_IN_BLOCK;
  int cacheBlockIndex=size / BITS_IN_COUNTCACHE0;
  int indexInCacheBlock=size % BITS_IN_COUNTCACHE0;
  if (blockIndex >= longs.length) {
    extendLongsAndCountCache0();
  }
  if (indexInCacheBlock == 0 && cacheBlockIndex > 0) {
    countCache0[cacheBlockIndex]=countCache0[cacheBlockIndex - 1];
  }
  size0++;
switch (size0) {
case 1:
    node1pos=size;
  break;
case 2:
node2pos=size;
break;
case 3:
node3pos=size;
break;
}
countCache0[cacheBlockIndex]++;
if (first0bitInBlock) {
bvD.append1();
first0bitInBlock=false;
}
 else {
bvD.append0();
}
if ((size % 8) == 0) {
if (bvR.size() == 0 || !currentBsC) {
bvR.append1();
addArS();
}
 else {
bvR.append0();
}
prevBsC=currentBsC;
currentBsC=true;
}
 else if (!currentBsC) {
if (bvR.size() == 0 || !prevBsC) {
bvR.append1();
}
 else {
bvR.append0();
}
arS[arSSize - 1]--;
if (!prevBsC) {
addArS();
}
currentBsC=true;
}
size++;
if (size % 8 == 0) {
first0bitInBlock=true;
}
}",0.9687654933068914
100988,"@Test public void test_count0CacheSize() throws Exception {
  Assert.assertEquals(0,new LongsSuccinctBitVector(0).getCountCache0().length);
  Assert.assertEquals(1,new LongsSuccinctBitVector(1).getCountCache0().length);
  Assert.assertEquals(1,new LongsSuccinctBitVector(64).getCountCache0().length);
  Assert.assertEquals(2,new LongsSuccinctBitVector(LongsSuccinctBitVector.CACHE_WIDTH_BITS + 1).getCountCache0().length);
}","@Test public void test_count0CacheSize() throws Exception {
  Assert.assertEquals(0,new LongsSuccinctBitVector(0).getCountCache0().length);
  Assert.assertEquals(1,new LongsSuccinctBitVector(1).getCountCache0().length);
  Assert.assertEquals(1,new LongsSuccinctBitVector(64).getCountCache0().length);
  Assert.assertEquals(2,new LongsSuccinctBitVector(LongsSuccinctBitVector.BITS_IN_COUNTCACHE0 + 1).getCountCache0().length);
}",0.9682726204465336
100989,"@Test public void test_append_countCache0_1() throws Exception {
  LongsSuccinctBitVector sbv=new LongsSuccinctBitVector();
  for (int i=0; i < LongsSuccinctBitVector.CACHE_WIDTH_BITS; i++) {
    sbv.append0();
    Assert.assertEquals(i + 1,sbv.getCountCache0()[0]);
  }
  for (int i=0; i < LongsSuccinctBitVector.CACHE_WIDTH_BITS; i++) {
    sbv.append0();
    Assert.assertEquals(LongsSuccinctBitVector.CACHE_WIDTH_BITS,sbv.getCountCache0()[0]);
    Assert.assertEquals(LongsSuccinctBitVector.CACHE_WIDTH_BITS + i + 1,sbv.getCountCache0()[1]);
  }
}","@Test public void test_append_countCache0_1() throws Exception {
  LongsSuccinctBitVector sbv=new LongsSuccinctBitVector();
  for (int i=0; i < LongsSuccinctBitVector.BITS_IN_COUNTCACHE0; i++) {
    sbv.append0();
    Assert.assertEquals(i + 1,sbv.getCountCache0()[0]);
  }
  for (int i=0; i < LongsSuccinctBitVector.BITS_IN_COUNTCACHE0; i++) {
    sbv.append0();
    Assert.assertEquals(LongsSuccinctBitVector.BITS_IN_COUNTCACHE0,sbv.getCountCache0()[0]);
    Assert.assertEquals(LongsSuccinctBitVector.BITS_IN_COUNTCACHE0 + i + 1,sbv.getCountCache0()[1]);
  }
}",0.725314183123878
100990,"@Test public void test_append_indexCache0_1() throws Exception {
  LongsSuccinctBitVector sbv=new LongsSuccinctBitVector();
  for (int i=0; i < LongsSuccinctBitVector.BITS0_COUNT_IN_EACH_INDEX * 3; i++) {
    sbv.append0();
  }
  Assert.assertEquals(0,sbv.getIndexCache0().get(0));
  Assert.assertEquals(LongsSuccinctBitVector.BITS0_COUNT_IN_EACH_INDEX - 1,sbv.getIndexCache0().get(1));
  Assert.assertEquals(LongsSuccinctBitVector.BITS0_COUNT_IN_EACH_INDEX * 2 - 1,sbv.getIndexCache0().get(2));
  Assert.assertEquals(LongsSuccinctBitVector.BITS0_COUNT_IN_EACH_INDEX * 3 - 1,sbv.getIndexCache0().get(3));
}","@Test public void test_append_indexCache0_1() throws Exception {
  LongsSuccinctBitVector sbv=new LongsSuccinctBitVector();
  for (int i=0; i < LongsSuccinctBitVector.ZEROBITS_IN_EACH_INDEX * 3; i++) {
    sbv.append0();
  }
  Assert.assertEquals(0,sbv.getIndexCache0().get(0));
  Assert.assertEquals(LongsSuccinctBitVector.ZEROBITS_IN_EACH_INDEX - 1,sbv.getIndexCache0().get(1));
  Assert.assertEquals(LongsSuccinctBitVector.ZEROBITS_IN_EACH_INDEX * 2 - 1,sbv.getIndexCache0().get(2));
  Assert.assertEquals(LongsSuccinctBitVector.ZEROBITS_IN_EACH_INDEX * 3 - 1,sbv.getIndexCache0().get(3));
}",0.9633333333333334
100991,"@Test public void test_append_countCache0_2() throws Exception {
  LongsSuccinctBitVector sbv=new LongsSuccinctBitVector();
  for (int i=0; i < 10000; i++) {
    sbv.append0();
    Assert.assertEquals(i + 1,sbv.getCountCache0()[i / LongsSuccinctBitVector.CACHE_WIDTH_BITS]);
  }
}","@Test public void test_append_countCache0_2() throws Exception {
  LongsSuccinctBitVector sbv=new LongsSuccinctBitVector();
  for (int i=0; i < 10000; i++) {
    sbv.append0();
    Assert.assertEquals(i + 1,sbv.getCountCache0()[i / LongsSuccinctBitVector.BITS_IN_COUNTCACHE0]);
  }
}",0.955595026642984
100992,"@Test public void test_append_countCache0_3() throws Exception {
  LongsSuccinctBitVector sbv=new LongsSuccinctBitVector();
  for (int i=0; i < 10000; i++) {
    sbv.append0();
    sbv.append1();
    String msg=i + ""String_Node_Str"";
    Assert.assertEquals(msg,i + 1,sbv.getCountCache0()[i * 2 / LongsSuccinctBitVector.CACHE_WIDTH_BITS]);
  }
}","@Test public void test_append_countCache0_3() throws Exception {
  LongsSuccinctBitVector sbv=new LongsSuccinctBitVector();
  for (int i=0; i < 10000; i++) {
    sbv.append0();
    sbv.append1();
    String msg=i + ""String_Node_Str"";
    Assert.assertEquals(msg,i + 1,sbv.getCountCache0()[i * 2 / LongsSuccinctBitVector.BITS_IN_COUNTCACHE0]);
  }
}",0.961038961038961
100993,"@Override public Iterable<Pair<String,Integer>> predictiveSearchWithTermId(String query){
  List<Pair<String,Integer>> ret=new ArrayList<Pair<String,Integer>>();
  char[] chars=query.toCharArray();
  int charsLen=chars.length;
  int nodeId=0;
  Range r=new Range();
  TailCharIterator tci=tailArray.newIterator();
  String pfx=null;
  int charsIndexBack=0;
  for (int charsIndex=0; charsIndex < charsLen; charsIndex++) {
    charsIndexBack=charsIndex;
    int child=getChildNode(nodeId,chars[charsIndex],r);
    if (child == -1)     return ret;
    tci.setOffset(tailArray.getIteratorOffset(child));
    while (tci.hasNext()) {
      charsIndex++;
      if (charsIndex >= charsLen)       break;
      if (chars[charsIndex] != tci.next())       return ret;
    }
    nodeId=child;
  }
  pfx=new String(chars,0,charsIndexBack);
  Deque<Pair<Integer,String>> queue=new LinkedList<Pair<Integer,String>>();
  queue.offerLast(Pair.create(nodeId,pfx));
  while (queue.size() > 0) {
    Pair<Integer,String> element=queue.pollFirst();
    int nid=element.getFirst();
    StringBuilder b=new StringBuilder(element.getSecond());
    b.append(labels[nid]);
    tci.setOffset(tailArray.getIteratorOffset(nid));
    while (tci.hasNext())     b.append(tci.next());
    String letter=b.toString();
    if (term.get(nid))     ret.add(Pair.create(letter,nid));
    bvtree.getChildNodeIds(nid,r);
    for (int i=(r.getEnd() - 1); i >= r.getStart(); i--) {
      queue.offerFirst(Pair.create(i,letter));
    }
  }
  return ret;
}","@Override public Iterable<Pair<String,Integer>> predictiveSearchWithTermId(String query){
  List<Pair<String,Integer>> ret=new ArrayList<Pair<String,Integer>>();
  char[] chars=query.toCharArray();
  int charsLen=chars.length;
  int nodeId=0;
  Range r=new Range();
  TailCharIterator tci=tailArray.newIterator();
  String pfx=null;
  int charsIndexBack=0;
  for (int charsIndex=0; charsIndex < charsLen; charsIndex++) {
    charsIndexBack=charsIndex;
    int child=getChildNode(nodeId,chars[charsIndex],r);
    if (child == -1)     return ret;
    tci.setOffset(tailArray.getIteratorOffset(child));
    while (tci.hasNext()) {
      charsIndex++;
      if (charsIndex >= charsLen)       break;
      if (chars[charsIndex] != tci.next())       return ret;
    }
    nodeId=child;
  }
  pfx=new String(chars,0,charsIndexBack);
  Deque<Pair<Integer,String>> queue=new LinkedList<Pair<Integer,String>>();
  queue.offerLast(Pair.create(nodeId,pfx));
  while (queue.size() > 0) {
    Pair<Integer,String> element=queue.pollFirst();
    int nid=element.getFirst();
    StringBuilder b=new StringBuilder(element.getSecond());
    if (nid > 0) {
      b.append(labels[nid]);
    }
    tci.setOffset(tailArray.getIteratorOffset(nid));
    while (tci.hasNext())     b.append(tci.next());
    String letter=b.toString();
    if (term.get(nid)) {
      ret.add(Pair.create(letter,nid));
    }
    bvtree.getChildNodeIds(nid,r);
    for (int i=(r.getEnd() - 1); i >= r.getStart(); i--) {
      queue.offerFirst(Pair.create(i,letter));
    }
  }
  return ret;
}",0.9878966306836768
100994,"@Override public Iterable<Pair<String,Integer>> predictiveSearchWithTermId(String query){
  List<Pair<String,Integer>> ret=new ArrayList<Pair<String,Integer>>();
  char[] chars=query.toCharArray();
  int charsLen=chars.length;
  int nodeId=0;
  Range r=new Range();
  TailCharIterator tci=tailArray.newIterator();
  String pfx=null;
  int charsIndexBack=0;
  for (int charsIndex=0; charsIndex < charsLen; charsIndex++) {
    charsIndexBack=charsIndex;
    int child=getChildNode(nodeId,chars[charsIndex],r);
    if (child == -1)     return ret;
    tci.setOffset(tailArray.getIteratorOffset(child));
    while (tci.hasNext()) {
      charsIndex++;
      if (charsIndex >= charsLen)       break;
      if (chars[charsIndex] != tci.next())       return ret;
    }
    nodeId=child;
  }
  pfx=new String(chars,0,charsIndexBack);
  Deque<Pair<Integer,String>> queue=new LinkedList<Pair<Integer,String>>();
  queue.offerLast(Pair.create(nodeId,pfx));
  while (queue.size() > 0) {
    Pair<Integer,String> element=queue.pollFirst();
    int nid=element.getFirst();
    StringBuilder b=new StringBuilder(element.getSecond());
    if (nid > 0) {
      b.append(labels[nid]);
    }
    tci.setOffset(tailArray.getIteratorOffset(nid));
    while (tci.hasNext())     b.append(tci.next());
    String letter=b.toString();
    if (term.get(nid)) {
      ret.add(Pair.create(letter,nid));
    }
    bvtree.getChildNodeIds(nid,r);
    for (int i=(r.getEnd() - 1); i >= r.getStart(); i--) {
      queue.offerFirst(Pair.create(i,letter));
    }
  }
  return ret;
}","@Override public Iterable<Pair<String,Integer>> predictiveSearchWithTermId(String query){
  List<Pair<String,Integer>> ret=new ArrayList<Pair<String,Integer>>();
  char[] chars=query.toCharArray();
  int charsLen=chars.length;
  int nodeId=0;
  Range r=new Range();
  TailCharIterator tci=tailArray.newIterator();
  String pfx=null;
  int charsIndexBack=0;
  for (int charsIndex=0; charsIndex < charsLen; charsIndex++) {
    charsIndexBack=charsIndex;
    int child=getChildNode(nodeId,chars[charsIndex],r);
    if (child == -1)     return ret;
    tci.setOffset(tailArray.getIteratorOffset(child));
    while (tci.hasNext()) {
      charsIndex++;
      if (charsIndex >= charsLen)       break;
      if (chars[charsIndex] != tci.next())       return ret;
    }
    nodeId=child;
  }
  pfx=new String(chars,0,charsIndexBack);
  Deque<Pair<Integer,String>> queue=new LinkedList<Pair<Integer,String>>();
  queue.offerLast(Pair.create(nodeId,pfx));
  while (queue.size() > 0) {
    Pair<Integer,String> element=queue.pollFirst();
    int nid=element.getFirst();
    StringBuilder b=new StringBuilder(element.getSecond());
    if (nid > 0) {
      b.append(labels[nid]);
    }
    tci.setOffset(tailArray.getIteratorOffset(nid));
    while (tci.hasNext())     b.append(tci.next());
    String letter=b.toString();
    if (term.get(nid)) {
      ret.add(Pair.create(letter,term.rank1(nid) - 1));
    }
    bvtree.getChildNodeIds(nid,r);
    for (int i=(r.getEnd() - 1); i >= r.getStart(); i--) {
      queue.offerFirst(Pair.create(i,letter));
    }
  }
  return ret;
}",0.9929260450160772
100995,"@Override public Iterable<Pair<String,Integer>> commonPrefixSearchWithTermId(String query){
  List<Pair<String,Integer>> ret=new ArrayList<Pair<String,Integer>>();
  char[] chars=query.toCharArray();
  int charsLen=chars.length;
  int nodeId=0;
  TailCharIterator tci=tailArray.newIterator();
  Range r=new Range();
  for (int charsIndex=0; charsIndex < charsLen; charsIndex++) {
    int child=getChildNode(nodeId,chars[charsIndex],r);
    if (child == -1)     return ret;
    tci.setOffset(tailArray.getIteratorOffset(child));
    while (tci.hasNext()) {
      charsIndex++;
      if (charsLen <= charsIndex)       return ret;
      if (chars[charsIndex] != tci.next())       return ret;
    }
    if (term.get(child)) {
      ret.add(Pair.create(new String(chars,0,charsIndex + 1),child));
    }
    nodeId=child;
  }
  return ret;
}","@Override public Iterable<Pair<String,Integer>> commonPrefixSearchWithTermId(String query){
  List<Pair<String,Integer>> ret=new ArrayList<Pair<String,Integer>>();
  char[] chars=query.toCharArray();
  int charsLen=chars.length;
  int nodeId=0;
  TailCharIterator tci=tailArray.newIterator();
  Range r=new Range();
  for (int charsIndex=0; charsIndex < charsLen; charsIndex++) {
    int child=getChildNode(nodeId,chars[charsIndex],r);
    if (child == -1)     return ret;
    tci.setOffset(tailArray.getIteratorOffset(child));
    while (tci.hasNext()) {
      charsIndex++;
      if (charsLen <= charsIndex)       return ret;
      if (chars[charsIndex] != tci.next())       return ret;
    }
    if (term.get(child)) {
      ret.add(Pair.create(new String(chars,0,charsIndex + 1),term.rank1(child) - 1));
    }
    nodeId=child;
  }
  return ret;
}",0.9845788849347568
100996,"public void trimToSize(){
  int vectorSize=size / 64 + 1;
  longs=Arrays.copyOf(longs,Math.min(longs.length,vectorSize));
  int blockSize=CACHE_WIDTH_BITS / 8;
  int size=vectorSize / blockSize + (((vectorSize % blockSize) != 0) ? 1 : 0);
  int countCacheSize0=size;
  countCache0=Arrays.copyOf(countCache0,Math.min(countCache0.length,countCacheSize0));
}","public void trimToSize(){
  longs=Arrays.copyOf(longs,longsSize(size));
  countCache0=Arrays.copyOf(countCache0,countCache0Size(size));
}",0.516260162601626
100997,"public int select0(int count){
  if (count > size)   return -1;
  if (count <= 3) {
    if (count == 1)     return node1pos;
 else     if (count == 2)     return node2pos;
 else     if (count == 3)     return node3pos;
 else     return -1;
  }
  int idx=count / CACHE_WIDTH;
  int start=indexCache0[idx];
  if (count % CACHE_WIDTH == 0)   return start;
  start/=CACHE_WIDTH;
  int end=0;
  if (indexCache0.length > (idx + 1)) {
    int c=(indexCache0[idx + 1]) / CACHE_WIDTH + 1;
    if (c != 1)     end=c;
  }
  if (end == 0) {
    int vectorSize=size / 8 + 1;
    int blockSize=CACHE_WIDTH / 8;
    end=vectorSize / blockSize + (((vectorSize % blockSize) != 0) ? 1 : 0);
    if (end == 0) {
      end=size;
    }
  }
  int m=0;
  int d=0;
  while (start != end) {
    m=(start + end) / 2;
    d=count - countCache0[m];
    if (d < 0) {
      end=m;
      continue;
    }
 else     if (d > 0) {
      if (start != m)       start=m;
 else       break;
    }
 else {
      break;
    }
  }
  if (d > 0) {
    count=d;
  }
 else {
    while (m >= 0 && count <= countCache0[m])     m--;
    if (m >= 0)     count-=countCache0[m];
  }
  int n=size / 8 + 1;
  for (int i=(m + 1) * CACHE_WIDTH / 8; i < n; i++) {
    int bits=bytes[i] & 0xff;
    int c=BITCOUNTS0[bits];
    if (count <= c) {
      return i * 8 + BITPOS0[bits][count - 1];
    }
    count-=c;
  }
  return -1;
}","public int select0(int count){
  if (count > size)   return -1;
  if (count <= 3) {
    if (count == 1)     return node1pos;
 else     if (count == 2)     return node2pos;
 else     if (count == 3)     return node3pos;
 else     return -1;
  }
  int idx=count / CACHE_WIDTH;
  int start=indexCache0[idx];
  if (count % CACHE_WIDTH == 0)   return start;
  start/=CACHE_WIDTH;
  int end=0;
  if (indexCache0.length > (idx)) {
    int c=(indexCache0[idx]) / CACHE_WIDTH;
    if (c != 0)     end=c + 1;
  }
  if (end == 0) {
    int vectorSize=containerBytesCount(size);
    int blockSize=CACHE_WIDTH / 8;
    end=vectorSize / blockSize + (((vectorSize % blockSize) != 0) ? 1 : 0);
    if (end == 0) {
      end=size;
    }
  }
  int m=0;
  int d=0;
  while (start != end) {
    m=(start + end) / 2;
    d=count - countCache0[m];
    if (d < 0) {
      end=m;
      continue;
    }
 else     if (d > 0) {
      if (start != m)       start=m;
 else       break;
    }
 else {
      break;
    }
  }
  if (d > 0) {
    count=d;
  }
 else {
    while (m >= 0 && count <= countCache0[m])     m--;
    if (m >= 0)     count-=countCache0[m];
  }
  int n=containerBytesCount(size);
  for (int i=(m + 1) * CACHE_WIDTH / 8; i < n; i++) {
    int bits=bytes[i] & 0xff;
    int c=BITCOUNTS0[bits];
    if (count <= c) {
      return i * 8 + BITPOS0[bits][count - 1];
    }
    count-=c;
  }
  return -1;
}",0.9565532223026793
100998,"public BytesSuccinctBitVector(byte[] bytes,int bitsSize){
  this.bytes=Arrays.copyOf(bytes,containerBytesCount(bitsSize));
  this.size=bitsSize;
  int cacheSize=bitsSize / CACHE_WIDTH + 1;
  countCache0=new int[cacheSize + 1];
  indexCache0=new int[cacheSize + 1];
  int n=bytes.length;
  for (int i=0; i < n; i++) {
    int b=bytes[i] & 0xff;
    byte[] zeroPosInB=BITPOS0[b];
    int rest=bitsSize - i * 8;
    if (rest < 8) {
      int nz=zeroPosInB.length;
      for (int j=0; j < nz; j++) {
        if (zeroPosInB[j] >= rest) {
          zeroPosInB=Arrays.copyOf(zeroPosInB,j);
          break;
        }
      }
    }
    int zeroCount=zeroPosInB.length;
    if (size0 < 3 && zeroCount > 0) {
      if (size0 == 0) {
        node1pos=zeroPosInB[0] + 8 * i;
        if (zeroPosInB.length > 1)         node2pos=zeroPosInB[1] + 8 * i;
        if (zeroPosInB.length > 2)         node3pos=zeroPosInB[2] + 8 * i;
      }
 else       if (size0 == 1) {
        node2pos=zeroPosInB[0] + 8 * i;
        if (zeroPosInB.length > 1)         node3pos=zeroPosInB[1] + 8 * i;
      }
 else {
        node3pos=zeroPosInB[0] + 8 * i;
      }
    }
    int prevSize0=size0;
    size0+=zeroCount;
    if ((i + 1) % (CACHE_WIDTH / 8) == 0) {
      countCache0[i / (CACHE_WIDTH / 8)]=size0;
    }
    if (zeroCount > 0 && ((size0 / CACHE_WIDTH) != (prevSize0 / CACHE_WIDTH))) {
      indexCache0[size0 / CACHE_WIDTH]=prevSize0 + zeroPosInB[zeroPosInB.length - size0 % CACHE_WIDTH - 1];
    }
    if (rest < 8)     break;
  }
  countCache0[(size - 1) / CACHE_WIDTH]=size0;
  if (indexCache0[size0 / CACHE_WIDTH] == 0) {
    indexCache0[size0 / CACHE_WIDTH]=size;
  }
 else {
    indexCache0[(size0 / CACHE_WIDTH) + 1]=size;
  }
}","public BytesSuccinctBitVector(byte[] bytes,int bitsSize){
  this.bytes=Arrays.copyOf(bytes,containerBytesCount(bitsSize));
  this.size=bitsSize;
  int cacheSize=bitsSize / CACHE_WIDTH + 1;
  countCache0=new int[cacheSize + 1];
  indexCache0=new int[cacheSize / 2 + 1];
  int n=bytes.length;
  for (int i=0; i < n; i++) {
    int b=bytes[i] & 0xff;
    byte[] zeroPosInB=BITPOS0[b];
    int rest=bitsSize - i * 8;
    if (rest < 8) {
      int nz=zeroPosInB.length;
      for (int j=0; j < nz; j++) {
        if (zeroPosInB[j] >= rest) {
          zeroPosInB=Arrays.copyOf(zeroPosInB,j);
          break;
        }
      }
    }
    int zeroCount=zeroPosInB.length;
    if (size0 < 3 && zeroCount > 0) {
      if (size0 == 0) {
        node1pos=zeroPosInB[0] + 8 * i;
        if (zeroPosInB.length > 1)         node2pos=zeroPosInB[1] + 8 * i;
        if (zeroPosInB.length > 2)         node3pos=zeroPosInB[2] + 8 * i;
      }
 else       if (size0 == 1) {
        node2pos=zeroPosInB[0] + 8 * i;
        if (zeroPosInB.length > 1)         node3pos=zeroPosInB[1] + 8 * i;
      }
 else {
        node3pos=zeroPosInB[0] + 8 * i;
      }
    }
    int prevSize0=size0;
    size0+=zeroCount;
    if ((i + 1) % (CACHE_WIDTH / 8) == 0) {
      countCache0[i / (CACHE_WIDTH / 8)]=size0;
    }
    if (zeroCount > 0 && ((size0 / CACHE_WIDTH) != (prevSize0 / CACHE_WIDTH))) {
      indexCache0[size0 / CACHE_WIDTH]=i * 8 + zeroPosInB[zeroPosInB.length - (size0 % CACHE_WIDTH) - 1];
    }
    if (rest < 8)     break;
  }
  countCache0[(size - 1) / CACHE_WIDTH]=size0;
}",0.9464995414246408
100999,"private void build(Trie orig,BvTree bvtree,TailArrayBuilder tailArrayBuilder,FastBitSet termBs,NodeListener listener){
  this.bvtree=bvtree;
  this.size=orig.size();
  this.labels=new char[size];
  LinkedList<Node> queue=new LinkedList<Node>();
  int count=0;
  if (orig.getRoot() != null)   queue.add(orig.getRoot());
  while (!queue.isEmpty()) {
    Node node=queue.pollFirst();
    int index=count++;
    if (index >= labels.length) {
      extend();
    }
    listener.listen(node,index);
    if (node.isTerminate()) {
      termBs.set(index);
    }
 else     if (termBs.size() <= index) {
      termBs.ensureCapacity(index);
    }
    for (    Node c : node.getChildren()) {
      bvtree.appendChild();
      queue.offerLast(c);
    }
    bvtree.appendSelf();
    char[] letters=node.getLetters();
    if (letters.length == 0) {
      labels[index]=0xffff;
      tailArrayBuilder.appendEmpty(index);
    }
 else {
      labels[index]=letters[0];
      if (letters.length >= 2) {
        tailArrayBuilder.append(index,letters,1,letters.length - 1);
      }
 else {
        tailArrayBuilder.appendEmpty(index);
      }
    }
  }
  nodeSize=count;
  this.tailArray=tailArrayBuilder.build();
}","private void build(Trie orig,BvTree bvtree,TailArrayBuilder tailArrayBuilder,FastBitSet termBs,NodeListener listener){
  this.bvtree=bvtree;
  this.size=orig.size();
  this.labels=new char[size];
  LinkedList<Node> queue=new LinkedList<Node>();
  int count=0;
  if (orig.getRoot() != null)   queue.add(orig.getRoot());
  while (!queue.isEmpty()) {
    Node node=queue.pollFirst();
    int index=count++;
    if (index >= labels.length) {
      extend();
    }
    listener.listen(node,index);
    if (node.isTerminate()) {
      termBs.set(index);
    }
 else     if (termBs.size() <= index) {
      termBs.ensureCapacity(index);
    }
    for (    Node c : node.getChildren()) {
      bvtree.appendChild();
      queue.offerLast(c);
    }
    bvtree.appendSelf();
    char[] letters=node.getLetters();
    if (letters.length == 0) {
      labels[index]=0xffff;
      tailArrayBuilder.appendEmpty(index);
    }
 else {
      labels[index]=letters[0];
      if (letters.length >= 2) {
        tailArrayBuilder.append(index,letters,1,letters.length - 1);
      }
 else {
        tailArrayBuilder.appendEmpty(index);
      }
    }
  }
  this.nodeSize=count;
  this.tailArray=tailArrayBuilder.build();
}",0.9979105725031342
101000,"public MapTailLOUDSPPTrie(MapTrie<T> orig,BvTree bvtree,TailArrayBuilder tailArrayBuilder){
  final List<T> values=new ArrayList<T>();
  setTrie(new TailLOUDSTrie(orig,bvtree,tailArrayBuilder,new NodeListener(){
    @Override @SuppressWarnings(""String_Node_Str"") public void listen(    Node node,    int id){
      if (node.isTerminate()) {
        values.add(((MapNode<T>)node).getValue());
      }
    }
  }
));
  setValues(values.toArray());
}","public MapTailLOUDSPPTrie(MapTrie<T> orig,TailArrayBuilder tailArrayBuilder){
  final List<T> values=new ArrayList<T>();
  setTrie(new TailLOUDSTrie(orig,tailArrayBuilder,new NodeListener(){
    @Override @SuppressWarnings(""String_Node_Str"") public void listen(    Node node,    int id){
      if (node.isTerminate()) {
        values.add(((MapNode<T>)node).getValue());
      }
    }
  }
));
  setValues(values.toArray());
}",0.9758897818599312
