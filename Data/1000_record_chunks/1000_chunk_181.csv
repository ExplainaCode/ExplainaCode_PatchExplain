record_number,buggy_code,fixed_code,code_similarity
180001,"public SwipeController(Context context){
  ViewConfiguration config=ViewConfiguration.get(context);
  mSlop=config.getScaledTouchSlop();
  DisplayMetrics display=context.getResources().getDisplayMetrics();
  mSwipeDistance=display.heightPixels / 2;
  setMode(MODE_WORKSPACE,false);
}","public SwipeController(Context context){
  ViewConfiguration config=ViewConfiguration.get(context);
  mSlopX=config.getScaledTouchSlop();
  mSlopY=3 * mSlopX / 2;
  DisplayMetrics display=context.getResources().getDisplayMetrics();
  mSwipeDistance=display.heightPixels / 2;
  setMode(MODE_WORKSPACE,false);
}",0.956081081081081
180002,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (mLauncher.isWorkspaceLocked() || mLauncher.isAllAppsVisible()) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
  final float x=ev.getX();
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  mLastMotionX=x;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int deltaX=(int)(mLastMotionX - x);
mLastMotionX=x;
if (deltaX < 0) {
  if (mScrollX > 0) {
    scrollBy(Math.max(-mScrollX,deltaX),0);
    updateWallpaperOffset();
  }
}
 else if (deltaX > 0) {
  final int availableToScroll=getChildAt(getChildCount() - 1).getRight() - mScrollX - getWidth();
  if (availableToScroll > 0) {
    scrollBy(Math.min(availableToScroll,deltaX),0);
    updateWallpaperOffset();
  }
}
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity();
if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) {
snapToScreen(mCurrentScreen - 1);
}
 else if (velocityX < -SNAP_VELOCITY && mCurrentScreen < getChildCount() - 1) {
snapToScreen(mCurrentScreen + 1);
}
 else {
snapToDestination();
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
mTouchState=TOUCH_STATE_REST;
break;
case MotionEvent.ACTION_CANCEL:
mTouchState=TOUCH_STATE_REST;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (mLauncher.isWorkspaceLocked()) {
    return false;
  }
  if (mLauncher.isAllAppsVisible()) {
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
    snapToScreen(mCurrentScreen);
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
  final float x=ev.getX();
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  mLastMotionX=x;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int deltaX=(int)(mLastMotionX - x);
mLastMotionX=x;
if (deltaX < 0) {
  if (mScrollX > 0) {
    scrollBy(Math.max(-mScrollX,deltaX),0);
    updateWallpaperOffset();
  }
}
 else if (deltaX > 0) {
  final int availableToScroll=getChildAt(getChildCount() - 1).getRight() - mScrollX - getWidth();
  if (availableToScroll > 0) {
    scrollBy(Math.min(availableToScroll,deltaX),0);
    updateWallpaperOffset();
  }
}
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity();
if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) {
snapToScreen(mCurrentScreen - 1);
}
 else if (velocityX < -SNAP_VELOCITY && mCurrentScreen < getChildCount() - 1) {
snapToScreen(mCurrentScreen + 1);
}
 else {
snapToDestination();
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
mTouchState=TOUCH_STATE_REST;
break;
case MotionEvent.ACTION_CANCEL:
mTouchState=TOUCH_STATE_REST;
}
return true;
}",0.9580803700491471
180003,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isVisible()) {
    return true;
  }
  if (mLocks != 0) {
    return true;
  }
  super.onTouchEvent(ev);
  int x=(int)ev.getX();
  int deltaX;
switch (ev.getAction()) {
case MotionEvent.ACTION_DOWN:
    mMotionDownRawX=(int)ev.getRawX();
  mMotionDownRawY=(int)ev.getRawY();
mLastMotionX=x;
mRollo.mReadback.read();
mRollo.mState.newPositionX=ev.getRawX() / Defines.SCREEN_WIDTH_PX;
mRollo.mState.newTouchDown=1;
if (!mRollo.checkClickOK()) {
mRollo.clearSelectedIcon();
}
 else {
mRollo.selectIcon(x,(int)ev.getY(),mRollo.mReadback.posX);
}
mRollo.mState.save();
mRollo.mInvokeMove.execute();
mVelocity=VelocityTracker.obtain();
mVelocity.addMovement(ev);
mStartedScrolling=false;
break;
case MotionEvent.ACTION_MOVE:
case MotionEvent.ACTION_OUTSIDE:
int slop=Math.abs(x - mLastMotionX);
if (!mStartedScrolling && slop < mConfig.getScaledTouchSlop()) {
}
 else {
mRollo.mState.newPositionX=ev.getRawX() / Defines.SCREEN_WIDTH_PX;
mRollo.mState.newTouchDown=1;
mRollo.mInvokeMove.execute();
mStartedScrolling=true;
mRollo.clearSelectedIcon();
deltaX=x - mLastMotionX;
mVelocity.addMovement(ev);
mRollo.mState.save();
mLastMotionX=x;
}
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mRollo.mState.newTouchDown=0;
mRollo.mState.newPositionX=ev.getRawX() / Defines.SCREEN_WIDTH_PX;
if (!mZoomSwipeInProgress) {
mVelocity.computeCurrentVelocity(1000,mConfig.getScaledMaximumFlingVelocity());
mRollo.mState.flingVelocityX=mVelocity.getXVelocity() / Defines.SCREEN_WIDTH_PX;
mRollo.clearSelectedIcon();
mRollo.mState.save();
mRollo.mInvokeFling.execute();
}
 else {
mRollo.mState.save();
mRollo.mInvokeMove.execute();
}
mLastMotionX=-10000;
mVelocity.recycle();
mVelocity=null;
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isVisible()) {
    return true;
  }
  if (mLocks != 0) {
    return true;
  }
  super.onTouchEvent(ev);
  int x=(int)ev.getX();
  int deltaX;
switch (ev.getAction()) {
case MotionEvent.ACTION_DOWN:
    mMotionDownRawX=(int)ev.getRawX();
  mMotionDownRawY=(int)ev.getRawY();
mLastMotionX=x;
mRollo.mReadback.read();
mRollo.mState.newPositionX=ev.getRawX() / Defines.SCREEN_WIDTH_PX;
mRollo.mState.newTouchDown=1;
if (!mRollo.checkClickOK()) {
mRollo.clearSelectedIcon();
}
 else {
mRollo.selectIcon(x,(int)ev.getY(),mRollo.mReadback.posX);
}
mRollo.mState.save();
mRollo.mInvokeMove.execute();
mVelocity=VelocityTracker.obtain();
mVelocity.addMovement(ev);
mStartedScrolling=false;
break;
case MotionEvent.ACTION_MOVE:
case MotionEvent.ACTION_OUTSIDE:
int slopX=Math.abs(x - mLastMotionX);
if (!mStartedScrolling && slopX < mSlopX) {
}
 else {
mRollo.mState.newPositionX=ev.getRawX() / Defines.SCREEN_WIDTH_PX;
mRollo.mState.newTouchDown=1;
mRollo.mInvokeMove.execute();
mStartedScrolling=true;
mRollo.clearSelectedIcon();
deltaX=x - mLastMotionX;
mVelocity.addMovement(ev);
mRollo.mState.save();
mLastMotionX=x;
}
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mRollo.mState.newTouchDown=0;
mRollo.mState.newPositionX=ev.getRawX() / Defines.SCREEN_WIDTH_PX;
if (!mZoomSwipeInProgress) {
mVelocity.computeCurrentVelocity(1000,mMaxFlingVelocity);
mRollo.mState.flingVelocityX=mVelocity.getXVelocity() / Defines.SCREEN_WIDTH_PX;
mRollo.clearSelectedIcon();
mRollo.mState.save();
mRollo.mInvokeFling.execute();
}
 else {
mRollo.mState.save();
mRollo.mInvokeMove.execute();
}
mLastMotionX=-10000;
mVelocity.recycle();
mVelocity=null;
break;
}
return true;
}",0.9863247863247864
180004,"public boolean onTouchEvent(MotionEvent ev){
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int screenX=(int)ev.getRawX();
  final int screenY=(int)ev.getRawY();
  final int deltaX=screenX - mDownX;
  final int deltaY=screenY - mDownY;
  final int action=ev.getAction();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mCanceled=false;
  mTracking=false;
mDownX=screenX;
mDownY=screenY;
mAllAppsView.setZoomSwipeInProgress(true,true);
break;
case MotionEvent.ACTION_MOVE:
if (!mCanceled && !mTracking) {
if (Math.abs(deltaX) > mSlop) {
mCanceled=true;
mTracking=false;
mAllAppsView.setZoomSwipeInProgress(false,true);
}
if (Math.abs(deltaY) > mSlop) {
mTracking=true;
}
}
if (mTracking && !mCanceled) {
track(screenY);
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mTracking && !mCanceled) {
fling(screenY);
mAllAppsView.setZoomSwipeInProgress(false,false);
}
mVelocityTracker.recycle();
mVelocityTracker=null;
break;
}
return mTracking || mCanceled;
}","public boolean onTouchEvent(MotionEvent ev){
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int screenX=(int)ev.getRawX();
  final int screenY=(int)ev.getRawY();
  final int deltaX=screenX - mDownX;
  final int deltaY=screenY - mDownY;
  final int action=ev.getAction();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mCanceled=false;
  mTracking=false;
mDownX=screenX;
mDownY=screenY;
mAllAppsView.setZoomSwipeInProgress(true,true);
break;
case MotionEvent.ACTION_MOVE:
if (!mCanceled && !mTracking) {
if (Math.abs(deltaX) > mSlopX) {
mCanceled=true;
mTracking=false;
mAllAppsView.setZoomSwipeInProgress(false,true);
}
 else if (Math.abs(deltaY) > mSlopY) {
mTracking=true;
}
}
if (mTracking && !mCanceled) {
track(screenY);
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mTracking && !mCanceled) {
fling(screenY);
mAllAppsView.setZoomSwipeInProgress(false,false);
}
mVelocityTracker.recycle();
mVelocityTracker=null;
break;
}
return mTracking || mCanceled;
}",0.9962581852198316
180005,"public SwipeController(Context context){
  ViewConfiguration config=ViewConfiguration.get(context);
  mSlop=config.getScaledTouchSlop();
  DisplayMetrics display=context.getResources().getDisplayMetrics();
  mSwipeDistance=display.heightPixels / 2;
  setMode(MODE_WORKSPACE,false);
}","public SwipeController(Context context){
  ViewConfiguration config=ViewConfiguration.get(context);
  mSlopX=config.getScaledTouchSlop();
  mSlopY=3 * mSlopX / 2;
  DisplayMetrics display=context.getResources().getDisplayMetrics();
  mSwipeDistance=display.heightPixels / 2;
  setMode(MODE_WORKSPACE,false);
}",0.956081081081081
180006,"public void onDrop(DragSource source,int x,int y,int xOffset,int yOffset,DragView dragView,Object dragInfo){
  final CellLayout cellLayout=getCurrentDropLayout();
  if (source != this) {
    onDropExternal(x - xOffset,y - yOffset,dragInfo,cellLayout);
  }
 else {
    if (mDragInfo != null) {
      final View cell=mDragInfo.cell;
      if (mCurrentScreen != mDragInfo.screen) {
        final CellLayout originalCellLayout=(CellLayout)getChildAt(mDragInfo.screen);
        originalCellLayout.removeView(cell);
        cellLayout.addView(cell);
      }
      mTargetCell=estimateDropCell(x - xOffset,y - yOffset,mDragInfo.spanX,mDragInfo.spanY,cell,cellLayout,mTargetCell);
      cellLayout.onDropChild(cell,mTargetCell);
      final ItemInfo info=(ItemInfo)cell.getTag();
      CellLayout.LayoutParams lp=(CellLayout.LayoutParams)cell.getLayoutParams();
      LauncherModel.moveItemInDatabase(mLauncher,info,LauncherSettings.Favorites.CONTAINER_DESKTOP,mCurrentScreen,lp.cellX,lp.cellY);
    }
  }
}","public void onDrop(DragSource source,int x,int y,int xOffset,int yOffset,DragView dragView,Object dragInfo){
  final CellLayout cellLayout=getCurrentDropLayout();
  if (source != this) {
    onDropExternal(x - xOffset,y - yOffset,dragInfo,cellLayout);
  }
 else {
    if (mDragInfo != null) {
      final View cell=mDragInfo.cell;
      int index=mScroller.isFinished() ? mCurrentScreen : mNextScreen;
      if (index != mDragInfo.screen) {
        final CellLayout originalCellLayout=(CellLayout)getChildAt(mDragInfo.screen);
        originalCellLayout.removeView(cell);
        cellLayout.addView(cell);
      }
      mTargetCell=estimateDropCell(x - xOffset,y - yOffset,mDragInfo.spanX,mDragInfo.spanY,cell,cellLayout,mTargetCell);
      cellLayout.onDropChild(cell,mTargetCell);
      final ItemInfo info=(ItemInfo)cell.getTag();
      CellLayout.LayoutParams lp=(CellLayout.LayoutParams)cell.getLayoutParams();
      LauncherModel.moveItemInDatabase(mLauncher,info,LauncherSettings.Favorites.CONTAINER_DESKTOP,index,lp.cellX,lp.cellY);
    }
  }
}",0.946855192588981
180007,"private ArrayList<StringValue> getParameters(ArrayList<Token> tokens) throws Exception {
  for (int i=0; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.OPENBRACKET) {
      ArrayList<Token> parameterTokens=Tokens.sliceBody(tokens,TokenType.OPENBRACKET,i);
      ArrayList<ArrayList<Token>> parameterValues=new ArrayList<ArrayList<Token>>();
      parameterValues.add(new ArrayList<Token>());
      int k=0;
      for (int o=0; o < parameterTokens.size(); o++) {
        if (parameterTokens.get(o).getTokenType() == TokenType.COMMA) {
          parameterValues.add(new ArrayList<Token>());
          k++;
        }
 else {
          parameterValues.get(k).add(parameterTokens.get(o));
        }
      }
      ArrayList<StringValue> argumentValues=new ArrayList<StringValue>();
      for (int x=0; x < parameterValues.size(); x++) {
        if (parameterValues.get(x).size() > 1) {
          throw new Exception(""String_Node_Str"");
        }
        try {
          argumentValues.add((StringValue)parameterValues.get(x).get(0).getTokenValue());
        }
 catch (        ClassCastException ex) {
          throw new Exception(""String_Node_Str"" + parameterValues.get(0).get(0).getTokenValue().getType());
        }
      }
      return argumentValues;
    }
  }
  throw new Exception(""String_Node_Str"");
}","private ArrayList<StringValue> getParameters(ArrayList<Token> tokens) throws Exception {
  for (int i=0; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.OPENBRACKET) {
      ArrayList<Token> parameterTokens=Tokens.sliceBody(tokens,TokenType.OPENBRACKET,i);
      ArrayList<ArrayList<Token>> parameterValues=new ArrayList<ArrayList<Token>>();
      parameterValues.add(new ArrayList<Token>());
      int k=0;
      for (int o=0; o < parameterTokens.size(); o++) {
        if (parameterTokens.get(o).getTokenType() == TokenType.COMMA) {
          parameterValues.add(new ArrayList<Token>());
          k++;
        }
 else {
          parameterValues.get(k).add(parameterTokens.get(o));
        }
      }
      ArrayList<StringValue> argumentValues=new ArrayList<StringValue>();
      if (!parameterValues.isEmpty()) {
        for (int x=0; x < parameterValues.size(); x++) {
          if (parameterValues.get(x).size() == 0) {
            continue;
          }
          if (parameterValues.get(x).size() > 1) {
            throw new Exception(""String_Node_Str"");
          }
          try {
            argumentValues.add((StringValue)parameterValues.get(x).get(0).getTokenValue());
          }
 catch (          ClassCastException ex) {
            throw new Exception(""String_Node_Str"" + parameterValues.get(0).get(0).getTokenValue().getType());
          }
        }
      }
      return argumentValues;
    }
  }
  throw new Exception(""String_Node_Str"");
}",0.9455687369155618
180008,"public Value evaluate(ArrayList<Token> tokens,ComplexScope scope) throws Exception {
  if (tokens.isEmpty())   return new NullValue();
  compileFunctions(tokens,scope);
  doFunctionCalls(tokens,scope);
  doBrackets(tokens,scope);
  for (  MathOperation op : this.operations) {
    op.doOperation(tokens,scope);
  }
  doAssignment(tokens,scope);
  if (tokens.size() > 1) {
    System.out.println(tokens);
    throw new Exception(""String_Node_Str"");
  }
  return getToken(tokens,0,scope);
}","public Value evaluate(ArrayList<Token> tokens,ComplexScope scope) throws Exception {
  if (tokens.isEmpty())   return new NullValue();
  compileFunctions(tokens,scope);
  doFunctionCalls(tokens,scope);
  doBrackets(tokens,scope);
  for (  MathOperation op : this.operations) {
    op.doOperation(tokens,scope);
  }
  doAssignment(tokens,scope);
  cleanEndStatements(tokens);
  if (tokens.size() > 1) {
    System.out.println(tokens);
    throw new Exception(""String_Node_Str"");
  }
  return getToken(tokens,0,scope);
}",0.9701789264413518
180009,"public TokenType getToken(){
  return TokenType.LOCAL_DECLARE;
}","public TokenType getToken(){
  return TokenType.RETURN;
}",0.8760330578512396
180010,"private void processDeclaration(ArrayList<Token> tokens,ComplexScope scope) throws Exception {
  Token declare=tokens.get(0);
  Token name=tokens.get(1);
  if (declare.getTokenType() == TokenType.GLOBAL_DECLARE) {
    declareVariable(name.toString(),scope,false);
  }
 else   if (declare.getTokenType() == TokenType.LOCAL_DECLARE) {
    declareVariable(name.toString(),scope,true);
  }
 else {
    throw new Exception(""String_Node_Str"" + declare.getTokenType());
  }
}","private void processDeclaration(ArrayList<Token> tokens,ComplexScope scope) throws Exception {
  Token declare=tokens.get(0);
  Token name=tokens.get(1);
  if (declare.getTokenType() == TokenType.GLOBAL_DECLARE) {
    declareVariable(name.getTokenValue().toString(),scope,false);
  }
 else   if (declare.getTokenType() == TokenType.LOCAL_DECLARE) {
    declareVariable(name.getTokenValue().toString(),scope,true);
  }
 else {
    throw new Exception(""String_Node_Str"" + declare.getTokenType());
  }
}",0.9669421487603306
180011,"private void declareVariable(String name,ComplexScope scope,boolean local) throws Exception {
  if (local == true) {
    System.out.println(""String_Node_Str"");
    scope.getLocal().addVariable(name);
    System.out.println(scope.getVariables());
  }
 else {
    scope.getGlobal().addVariable(name);
  }
}","private void declareVariable(String name,ComplexScope scope,boolean local) throws Exception {
  if (local == true) {
    scope.getLocal().addVariable(name);
  }
 else {
    scope.getGlobal().addVariable(name);
  }
}",0.6435452793834296
180012,"private Value parseLine(TokenScanner statement,ComplexScope fullScope) throws Exception {
  Token token=statement.next(false);
  if (token.getTokenType() == TokenType.CLOSEBRACES || token.getTokenType() == TokenType.OPENBRACES) {
    if (token.getTokenType() == TokenType.CLOSEBRACES)     fullScope.local.removeStack(""String_Node_Str"");
 else     fullScope.local.addStack(""String_Node_Str"");
    statement.next();
    token=statement.next(false);
    statement=statement.getTokenToEndStatement();
  }
  if (token.getTokenType() == TokenType.LOCAL_DECLARE || token.getTokenType() == TokenType.GLOBAL_DECLARE) {
    processDeclaration(statement.getTokens(),fullScope);
    statement.getTokens().remove(0);
    return evaluateOperation(statement,fullScope);
  }
 else   if (token.getTokenType() == TokenType.RETURN) {
    statement.next();
    statement=statement.getTokenToEndStatement();
    return new ReturnValue(evaluateOperation(statement,fullScope));
  }
 else   if (token.getTokenType() == TokenType.IF) {
    statement.next();
    statement=statement.getTokenToEndStatement();
    return evaluateConditional(statement,fullScope);
  }
 else {
    return evaluateOperation(statement,fullScope);
  }
}","private Value parseLine(TokenScanner statement,ComplexScope fullScope) throws Exception {
  System.out.println(statement.getTokens());
  Token token=statement.next(false);
  if (token.getTokenType() == TokenType.CLOSEBRACES || token.getTokenType() == TokenType.OPENBRACES) {
    if (token.getTokenType() == TokenType.CLOSEBRACES)     fullScope.local.removeStack(""String_Node_Str"");
 else     fullScope.local.addStack(""String_Node_Str"");
    statement.next();
    token=statement.next(false);
    statement=statement.getTokenToEndStatement();
  }
  if (token.getTokenType() == TokenType.LOCAL_DECLARE || token.getTokenType() == TokenType.GLOBAL_DECLARE) {
    processDeclaration(statement.getTokens(),fullScope);
    statement.getTokens().remove(0);
    return evaluateOperation(statement,fullScope);
  }
 else   if (token.getTokenType() == TokenType.RETURN) {
    statement.next();
    statement=statement.getTokenToEndStatement();
    return new ReturnValue(evaluateOperation(statement,fullScope));
  }
 else   if (token.getTokenType() == TokenType.IF) {
    statement.next();
    statement=statement.getTokenToEndStatement();
    return evaluateConditional(statement,fullScope);
  }
 else {
    return evaluateOperation(statement,fullScope);
  }
}",0.9816551161842642
180013,"public String toString(){
  return this.value;
}","@Override public String toString(){
  return this.value;
}",0.9056603773584906
180014,"@Override public Token toToken(){
  return new Token(TokenType.BOOLEAN);
}","@Override public Token toToken(){
  return new Token(TokenType.BOOLEAN,this);
}",0.9673202614379084
180015,"public void process(ArrayList<Token> tokens,ComplexScope scope,ExpressionProcessor processor) throws Exception {
  for (int i=0; i < tokens.size() - 1; i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.CLOSEBRACKET) {
      throw new SyntaxException(""String_Node_Str"",tokens);
    }
 else     if (token.getTokenType() == TokenType.USERFUNC) {
      Value v=token.getTokenValue();
      FunctionValue value;
      try {
        value=(FunctionValue)v;
      }
 catch (      ClassCastException ex) {
        System.out.println(ex);
        throw new SyntaxException(""String_Node_Str"",tokens);
      }
      ArrayList<Token> statement=Tokens.sliceBody(tokens,TokenType.OPENBRACKET,i + 1);
      tokens.remove(i);
      ArrayList<ArrayList<Token>> arguments=new ArrayList<ArrayList<Token>>();
      arguments.add(new ArrayList<Token>());
      int k=0;
      for (int o=0; o < statement.size(); o++) {
        if (statement.get(o).getTokenType() == TokenType.COMMA) {
          arguments.add(new ArrayList<Token>());
          k++;
        }
 else {
          arguments.get(k).add(statement.get(o));
        }
      }
      ArrayList<Value> argumentValues=new ArrayList<Value>();
      for (int x=0; x < arguments.size(); x++) {
        Value t=processor.evaluate(arguments.get(x),scope);
        argumentValues.add(t);
      }
      Value returnValue=value.call(argumentValues,scope);
      tokens.add(i,returnValue.toToken());
    }
 else     if (token.getTokenType() == TokenType.STRING && tokens.get(i + 1).getTokenType() == TokenType.OPENBRACKET) {
      String name=token.getTokenValue().toString();
      Value v=scope.getVariable(name).getValue();
      FunctionValue value;
      try {
        value=(FunctionValue)v;
      }
 catch (      ClassCastException ex) {
        System.out.println(ex);
        throw new SyntaxException(""String_Node_Str"",tokens);
      }
      ArrayList<Token> statement=Tokens.sliceBody(tokens,TokenType.OPENBRACKET,i + 1);
      tokens.remove(i);
      ArrayList<ArrayList<Token>> arguments=new ArrayList<ArrayList<Token>>();
      ArrayList<Value> argumentValues=new ArrayList<Value>();
      if (statement.size() > 0) {
        arguments.add(new ArrayList<Token>());
        int k=0;
        for (int o=0; o < statement.size(); o++) {
          if (statement.get(o).getTokenType() == TokenType.COMMA) {
            arguments.add(new ArrayList<Token>());
            k++;
          }
 else {
            arguments.get(k).add(statement.get(o));
          }
        }
        for (int x=0; x < arguments.size(); x++) {
          Value t=processor.evaluate(arguments.get(x),scope);
          argumentValues.add(t);
        }
      }
      Value returnValue=value.call(argumentValues,scope);
      tokens.add(i,returnValue.toToken());
    }
  }
}","public void process(ArrayList<Token> tokens,ComplexScope scope,ExpressionProcessor processor) throws Exception {
  for (int i=0; i < tokens.size() - 1; i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.CLOSEBRACKET) {
      throw new SyntaxException(""String_Node_Str"",tokens);
    }
 else     if (token.getTokenType() == TokenType.USERFUNC) {
      if (tokens.size() <= i + 1)       continue;
      if (tokens.get(i + 1).getTokenType() != TokenType.OPENBRACKET)       continue;
      Value v=token.getTokenValue();
      FunctionValue value;
      try {
        value=(FunctionValue)v;
      }
 catch (      ClassCastException ex) {
        System.out.println(ex);
        throw new SyntaxException(""String_Node_Str"",tokens);
      }
      ArrayList<Token> statement=Tokens.sliceBody(tokens,TokenType.OPENBRACKET,i + 1);
      tokens.remove(i);
      ArrayList<ArrayList<Token>> arguments=new ArrayList<ArrayList<Token>>();
      arguments.add(new ArrayList<Token>());
      int k=0;
      for (int o=0; o < statement.size(); o++) {
        if (statement.get(o).getTokenType() == TokenType.COMMA) {
          arguments.add(new ArrayList<Token>());
          k++;
        }
 else {
          arguments.get(k).add(statement.get(o));
        }
      }
      ArrayList<Value> argumentValues=new ArrayList<Value>();
      for (int x=0; x < arguments.size(); x++) {
        Value t=processor.evaluate(arguments.get(x),scope);
        argumentValues.add(t);
      }
      Value returnValue=value.call(argumentValues,scope);
      tokens.add(i,returnValue.toToken());
    }
 else     if (token.getTokenType() == TokenType.STRING && tokens.get(i + 1).getTokenType() == TokenType.OPENBRACKET) {
      String name=token.getTokenValue().toString();
      Value v=scope.getVariable(name).getValue();
      FunctionValue value;
      try {
        value=(FunctionValue)v;
      }
 catch (      ClassCastException ex) {
        System.out.println(ex);
        throw new SyntaxException(""String_Node_Str"",tokens);
      }
      ArrayList<Token> statement=Tokens.sliceBody(tokens,TokenType.OPENBRACKET,i + 1);
      tokens.remove(i);
      ArrayList<ArrayList<Token>> arguments=new ArrayList<ArrayList<Token>>();
      ArrayList<Value> argumentValues=new ArrayList<Value>();
      if (statement.size() > 0) {
        arguments.add(new ArrayList<Token>());
        int k=0;
        for (int o=0; o < statement.size(); o++) {
          if (statement.get(o).getTokenType() == TokenType.COMMA) {
            arguments.add(new ArrayList<Token>());
            k++;
          }
 else {
            arguments.get(k).add(statement.get(o));
          }
        }
        for (int x=0; x < arguments.size(); x++) {
          Value t=processor.evaluate(arguments.get(x),scope);
          argumentValues.add(t);
        }
      }
      Value returnValue=value.call(argumentValues,scope);
      tokens.add(i,returnValue.toToken());
    }
  }
}",0.4555729438358546
180016,"public void process(ArrayList<Token> tokens,ComplexScope scope,ExpressionProcessor processor) throws Exception {
  for (int i=0; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.FUNCTION_DECLARE) {
      tokens.remove(i);
      FunctionValue value=getFunction(tokens,scope);
      tokens.add(i,new Token(TokenType.USERFUNC,value));
      i=0;
    }
  }
}","public void process(ArrayList<Token> tokens,ComplexScope scope,ExpressionProcessor processor) throws Exception {
  for (int i=0; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.FUNCTION_DECLARE) {
      tokens.remove(i);
      System.out.println(tokens);
      replaceFunction(i,tokens,scope);
      i=0;
    }
  }
}",0.8119325551232166
180017,"private ArrayList<Token> getBody(ArrayList<Token> tokens) throws Exception {
  for (int i=0; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.OPENBRACES)     return Tokens.sliceBody(tokens,TokenType.OPENBRACES,i);
  }
  throw new Exception(""String_Node_Str"");
}","private ArrayList<Token> getBody(int startIndex,ArrayList<Token> tokens) throws Exception {
  for (int i=startIndex; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.OPENBRACES)     return Tokens.sliceBody(tokens,TokenType.OPENBRACES,i);
  }
  throw new Exception(""String_Node_Str"");
}",0.959752321981424
180018,"public void process(ArrayList<Token> tokens,ComplexScope scope,ExpressionProcessor processor) throws Exception {
  for (int i=0; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.OBJECT) {
      if (tokens.size() <= i + 1)       continue;
      if (tokens.get(i + 1).getTokenType() == TokenType.DOT) {
        if (tokens.get(i + 2).getTokenType() != TokenType.STRING) {
          throw new SyntaxException(""String_Node_Str"",tokens);
        }
        String identifier=tokens.get(i + 2).getTokenValue().toString();
        VariableValue container=(VariableValue)token.getTokenValue();
        ObjectValue object=(ObjectValue)container.getValue();
        Value value=object.getValue(identifier);
        tokens.remove(i);
        tokens.remove(i);
        tokens.remove(i);
        tokens.add(value.toToken());
        i=0;
      }
    }
 else     if (token.getTokenType() == TokenType.STRING) {
      Value value=scope.getVariable(token.toString());
      if (value == null) {
        scope.local.addVariable(token.toString());
        value=scope.local.getVariable(token.toString());
      }
      tokens.remove(i);
      tokens.add(i,value.toToken());
      process(tokens,scope,processor);
    }
  }
}","public void process(ArrayList<Token> tokens,ComplexScope scope,ExpressionProcessor processor) throws Exception {
  for (int i=0; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.OBJECT) {
      if (tokens.size() <= i + 1)       continue;
      if (tokens.get(i + 1).getTokenType() == TokenType.DOT) {
        if (tokens.get(i + 2).getTokenType() != TokenType.STRING) {
          throw new SyntaxException(""String_Node_Str"",tokens);
        }
        String identifier=tokens.get(i + 2).getTokenValue().toString();
        VariableValue container=(VariableValue)token.getTokenValue();
        ObjectValue object=(ObjectValue)container.getValue();
        Value value=object.getValue(identifier);
        tokens.remove(i);
        tokens.remove(i);
        tokens.remove(i);
        tokens.add(i,value.toToken());
        i=0;
      }
    }
 else     if (token.getTokenType() == TokenType.STRING) {
      Value value=scope.getVariable(token.toString());
      if (value == null) {
        scope.local.addVariable(token.toString());
        value=scope.local.getVariable(token.toString());
      }
      tokens.remove(i);
      tokens.add(i,value.toToken());
      process(tokens,scope,processor);
    }
  }
}",0.999203187250996
180019,"public ExpressionProcessor(){
  this.operations.add(new Add(this));
  this.operations.add(new Subtract(this));
  this.operations.add(new Multiply(this));
  this.operations.add(new Divide(this));
  this.operations.add(new Equality(this));
  this.operations.add(new And(this));
  this.operations.add(new Or(this));
  this.compilers.add(new FunctionCompiler());
  this.compilers.add(new CallingCompiler());
  this.compilers.add(new ObjectCompiler());
  this.compilers.add(new ReferenceCompiler());
  this.compilers.add(new BracketCompiler());
}","public ExpressionProcessor(){
  this.operations.add(new Add(this));
  this.operations.add(new Subtract(this));
  this.operations.add(new Multiply(this));
  this.operations.add(new Divide(this));
  this.operations.add(new Equality(this));
  this.operations.add(new And(this));
  this.operations.add(new Or(this));
  this.compilers.add(new FunctionCompiler());
  this.compilers.add(new ReferenceCompiler());
  this.compilers.add(new CallingCompiler());
  this.compilers.add(new ObjectCompiler());
  this.compilers.add(new BracketCompiler());
}",0.9001848428835489
180020,"private ArrayList<StringValue> getParameters(ArrayList<Token> tokens) throws Exception {
  for (int i=0; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.OPENBRACKET) {
      ArrayList<Token> parameterTokens=Tokens.sliceBody(tokens,TokenType.OPENBRACKET,i);
      ArrayList<ArrayList<Token>> parameterValues=new ArrayList<ArrayList<Token>>();
      parameterValues.add(new ArrayList<Token>());
      int k=0;
      for (int o=0; o < parameterTokens.size(); o++) {
        if (parameterTokens.get(o).getTokenType() == TokenType.COMMA) {
          parameterValues.add(new ArrayList<Token>());
          k++;
        }
 else {
          parameterValues.get(k).add(parameterTokens.get(o));
        }
      }
      ArrayList<StringValue> argumentValues=new ArrayList<StringValue>();
      if (!parameterValues.isEmpty()) {
        for (int x=0; x < parameterValues.size(); x++) {
          if (parameterValues.get(x).size() == 0) {
            continue;
          }
          if (parameterValues.get(x).size() > 1) {
            throw new Exception(""String_Node_Str"");
          }
          try {
            argumentValues.add((StringValue)parameterValues.get(x).get(0).getTokenValue());
          }
 catch (          ClassCastException ex) {
            throw new Exception(""String_Node_Str"" + parameterValues.get(0).get(0).getTokenValue().getType());
          }
        }
      }
      return argumentValues;
    }
  }
  throw new Exception(""String_Node_Str"");
}","private ArrayList<StringValue> getParameters(ArrayList<Token> tokens) throws Exception {
  for (int i=0; i < tokens.size(); i++) {
    Token token=tokens.get(i);
    if (token.getTokenType() == TokenType.OPENBRACKET) {
      ArrayList<Token> parameterTokens=Tokens.sliceBody(tokens,TokenType.OPENBRACKET,i);
      ArrayList<ArrayList<Token>> parameterValues=new ArrayList<ArrayList<Token>>();
      parameterValues.add(new ArrayList<Token>());
      int k=0;
      for (int o=0; o < parameterTokens.size(); o++) {
        if (parameterTokens.get(o).getTokenType() == TokenType.COMMA) {
          parameterValues.add(new ArrayList<Token>());
          k++;
        }
 else {
          parameterValues.get(k).add(parameterTokens.get(o));
        }
      }
      ArrayList<StringValue> argumentValues=new ArrayList<StringValue>();
      if (!parameterValues.isEmpty()) {
        for (int x=0; x < parameterValues.size(); x++) {
          if (parameterValues.get(x).size() == 0) {
            continue;
          }
          if (parameterValues.get(x).size() > 1) {
            throw new Exception(""String_Node_Str"");
          }
          try {
            argumentValues.add(new StringValue(parameterValues.get(x).get(0).getTokenValue().toString()));
          }
 catch (          ClassCastException ex) {
            throw new Exception(""String_Node_Str"" + parameterValues.get(0).get(0).getTokenValue().getType());
          }
        }
      }
      return argumentValues;
    }
  }
  throw new Exception(""String_Node_Str"");
}",0.9937438261442212
180021,"@Override public void packetReceived(IBroadcastStream stream,IStreamPacket packet){
  if (packet instanceof IRTMPEvent) {
    outputStream.dispatchEvent((IEvent)packet);
  }
}","@Override public void packetReceived(IBroadcastStream stream,IStreamPacket packet){
  if (packet instanceof IRTMPEvent) {
    try {
      IBroadcastStream bstream=getPublishStream(stream.getScope(),stream.getPublishedName().substring(1));
      ((BroadcastStream)bstream).dispatchEvent((IEvent)packet);
    }
 catch (    Exception e) {
    }
  }
}",0.632183908045977
180022,"@Override public boolean appStart(IScope scope){
  final ApplicationAdapterEx aaex=this;
  final IScope scopeex=scope;
  System.out.println(""String_Node_Str"");
  this.addScheduledJob(10000,new IScheduledJob(){
    @Override public void execute(    ISchedulingService service) throws CloneNotSupportedException {
      List<String> list=aaex.getBroadcastStreamNames(scopeex);
      for (      String name : list) {
        System.out.println(name);
      }
    }
  }
);
  return super.appStart(scope);
}","@Override public boolean appStart(IScope scope){
  final IScope scopeex=scope;
  this.addScheduledJob(10000,new IScheduledJob(){
    @Override public void execute(    ISchedulingService service) throws CloneNotSupportedException {
      List<String> list=getBroadcastStreamNames(scopeex);
      for (      String name : list) {
        IBroadcastStream stream=getPublishStream(scopeex,name);
        if (stream instanceof BroadcastStream) {
          ((BroadcastStream)stream).terminateGhostConnection();
        }
      }
    }
  }
);
  return super.appStart(scope);
}",0.4780578898225957
180023,"@Override public void streamBroadcastClose(IBroadcastStream stream){
  String publishName=stream.getPublishedName();
  System.out.println(publishName);
  if (publishName.startsWith(""String_Node_Str"")) {
    outputStream.stop();
  }
  super.streamBroadcastClose(stream);
}","@Override public void streamBroadcastClose(IBroadcastStream stream){
  String publishName=stream.getPublishedName();
  if (publishName.startsWith(""String_Node_Str"")) {
    IBroadcastStream bstream=getPublishStream(stream.getScope(),publishName.substring(1));
    if (stream instanceof BroadcastStream) {
      bstream.stop();
    }
  }
  super.streamBroadcastClose(stream);
}",0.5975232198142415
180024,"@Override public void streamBroadcastStart(IBroadcastStream stream){
  String publishName=stream.getPublishedName();
  if (publishName.startsWith(""String_Node_Str"")) {
    if (outputStream == null) {
      String outputName=publishName.substring(1);
      IScope scope=stream.getScope();
      outputStream=new BroadcastStream(outputName);
      outputStream.setScope(scope);
      IProviderService providerService=(IProviderService)this.getContext().getBean(IProviderService.BEAN_NAME);
      if (providerService.registerBroadcastStream(scope,outputName,outputStream)) {
        IBroadcastScope bsScope=(BroadcastScope)providerService.getLiveProviderInput(scope,outputName,true);
        bsScope.setAttribute(IBroadcastScope.STREAM_ATTRIBUTE,outputStream);
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    outputStream.start();
    stream.addStreamListener(new IStreamListener(){
      @Override public void packetReceived(      IBroadcastStream stream,      IStreamPacket packet){
        if (packet instanceof IRTMPEvent) {
          outputStream.dispatchEvent((IEvent)packet);
        }
      }
    }
);
  }
  super.streamBroadcastStart(stream);
}","@Override public void streamBroadcastStart(IBroadcastStream stream){
  String publishName=stream.getPublishedName();
  if (publishName.startsWith(""String_Node_Str"")) {
    String outputName=publishName.substring(1);
    IBroadcastStream outputStream=getPublishStream(stream.getScope(),outputName);
    if (outputStream == null) {
      IScope scope=stream.getScope();
      outputStream=new BroadcastStream(outputName);
      ((BroadcastStream)outputStream).setScope(scope);
      IProviderService providerService=(IProviderService)this.getContext().getBean(IProviderService.BEAN_NAME);
      System.out.println(providerService);
      if (providerService.registerBroadcastStream(scope,outputName,outputStream)) {
        IBroadcastScope bsScope=(BroadcastScope)providerService.getLiveProviderInput(scope,outputName,true);
        bsScope.setAttribute(IBroadcastScope.STREAM_ATTRIBUTE,outputStream);
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    outputStream.start();
    stream.addStreamListener(new IStreamListener(){
      @Override public void packetReceived(      IBroadcastStream stream,      IStreamPacket packet){
        if (packet instanceof IRTMPEvent) {
          try {
            IBroadcastStream bstream=getPublishStream(stream.getScope(),stream.getPublishedName().substring(1));
            ((BroadcastStream)bstream).dispatchEvent((IEvent)packet);
          }
 catch (          Exception e) {
          }
        }
      }
    }
);
  }
  super.streamBroadcastStart(stream);
}",0.7784299339691856
180025,"@Override public void execute(ISchedulingService service) throws CloneNotSupportedException {
  List<String> list=aaex.getBroadcastStreamNames(scopeex);
  for (  String name : list) {
    System.out.println(name);
  }
}","@Override public void execute(ISchedulingService service) throws CloneNotSupportedException {
  List<String> list=getBroadcastStreamNames(scopeex);
  for (  String name : list) {
    IBroadcastStream stream=getPublishStream(scopeex,name);
    if (stream instanceof BroadcastStream) {
      ((BroadcastStream)stream).terminateGhostConnection();
    }
  }
}",0.4425087108013937
180026,"public boolean close(int i){
  if (mLivePipe != null) {
  }
  return true;
}","@Override public void close(){
  log.trace(""String_Node_Str"");
}",0.3857142857142857
180027,"public void maintainMenu(boolean preserve){
  if (!preserve)   selString=""String_Node_Str"";
  m.setText(getTitle() + selString);
}","public void maintainMenu(int step){
  selString+=""String_Node_Str"" + step + ""String_Node_Str"";
  m.setText(getTitle() + selString);
}",0.752851711026616
180028,"public void loadDataSet(File file,String dataFrameName){
  ProgIndicatorImpl progIndicator=new ProgIndicatorImpl();
  DataSet dataSet=new AsciiFileLoader(progIndicator,getMonFrame()).loadAsciiFile(file);
  progIndicator.dispose();
  if (dataSet != null) {
    Mondrian mondrian=new Mondrian(dataSet,this);
    addAndActiviate(mondrian);
  }
}","public void loadDataSet(File file,String dsName){
  ProgIndicatorImpl progIndicator=new ProgIndicatorImpl();
  DataSet dataSet=new AsciiFileLoader(progIndicator,getMonFrame()).loadAsciiFile(file);
  progIndicator.dispose();
  if (dataSet != null) {
    if (dsName != null) {
      dataSet.setName=dsName;
    }
    Mondrian mondrian=new Mondrian(dataSet,this);
    addAndActiviate(mondrian);
  }
}",0.2273342354533153
180029,"public void addAndActiviate(Mondrian mondrian){
  mondrians.add(mondrian);
  monFrame.closeDataSetMenuItem.setEnabled(true);
  monFrame.saveMenuItem.setEnabled(true);
  monFrame.maintainOptionMenu();
}","public void addAndActiviate(Mondrian mondrian){
  mondrians.add(mondrian);
  monFrame.maintainOptionMenu();
}",0.7032258064516129
180030,"public MDialog(MonFrame parentFrame,Mondrian mondrian){
  this.mondrian=mondrian;
  this.parentFrame=parentFrame;
  this.getContentPane().setBackground(ColorManager.backgroundColor);
  addWindowListener(this);
}","public MDialog(MonFrame parentFrame,Mondrian mondrian){
  this.mondrian=mondrian;
  this.parentFrame=parentFrame;
  this.getContentPane().setBackground(ColorManager.backgroundColor);
}",0.9316455696202532
180031,"public void clearColors(){
  if (controller.countInstances() > -1) {
    controller.getCurrentDataSet().colorsOff();
    controller.getCurrent().dataChanged(-1);
  }
}","public void clearColors(){
  if (controller.countInstances() > 0) {
    controller.getCurrentDataSet().colorsOff();
    controller.getCurrent().dataChanged(-1);
  }
}",0.990990990990991
180032,"public void toggleSelection(){
  if (controller.countInstances() > -1) {
    controller.getCurrentDataSet().toggleSelection();
    controller.getCurrent().updateSelection();
  }
}","public void toggleSelection(){
  if (controller.countInstances() > 0) {
    controller.getCurrentDataSet().toggleSelection();
    controller.getCurrent().updateSelection();
  }
}",0.9915966386554622
180033,"public Barchart(MDialog frame,int width,int height,Table tablep){
  super(frame);
  this.tablep=tablep;
  this.name=tablep.name;
  this.levels=tablep.levels;
  this.names=tablep.names;
  this.lnames=tablep.lnames;
  this.width=width;
  this.height=height;
  sb.setUnitIncrement(22);
  sb.setBlockIncrement(22);
  this.k=levels[0];
  for (int i=0; i < k; i++)   max=Math.max(max,tablep.table[i]);
  iniMax=max;
  setCoordinates(0,0,max,1,-1);
  this.setScrollX();
  frame.getContentPane().add(this,""String_Node_Str"");
  Font SF=new Font(""String_Node_Str"",Font.PLAIN,11);
  frame.setFont(SF);
  border=20;
  String titletext;
  if (tablep.count == -1)   titletext=""String_Node_Str"" + names[0] + ""String_Node_Str"";
 else   titletext=""String_Node_Str"" + names[0] + ""String_Node_Str""+ tablep.data.getName(tablep.count)+ ""String_Node_Str"";
  frame.setTitle(titletext);
  evtq=Toolkit.getDefaultToolkit().getSystemEventQueue();
}","public Barchart(MDialog frame,int width,int height,Table tablep){
  super(frame);
  this.tablep=tablep;
  this.name=tablep.name;
  this.levels=tablep.levels;
  this.names=tablep.names;
  this.lnames=tablep.lnames;
  this.width=width;
  this.height=height;
  sb.setUnitIncrement(22);
  sb.setBlockIncrement(22);
  this.k=levels[0];
  for (int i=0; i < k; i++)   max=Math.max(max,tablep.table[i]);
  iniMax=max;
  setCoordinates(0,0,max,1,-1);
  this.setScrollX();
  Font SF=new Font(""String_Node_Str"",Font.PLAIN,11);
  frame.setFont(SF);
  border=20;
  String titletext;
  if (tablep.count == -1)   titletext=""String_Node_Str"" + names[0] + ""String_Node_Str"";
 else   titletext=""String_Node_Str"" + names[0] + ""String_Node_Str""+ tablep.data.getName(tablep.count)+ ""String_Node_Str"";
  setName(titletext);
  evtq=Toolkit.getDefaultToolkit().getSystemEventQueue();
}",0.9590577678070668
180034,"public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int[] indices=varNames.getSelectedIndices();
  PlotPanel barChartsContainer=new PlotPanel();
  plotDialog.setLayout(new GridLayout(1,indices.length));
  int weight=-1;
  for (int i=0; i < indices.length; i++) {
    int[] dummy={0};
    dummy[0]=indices[i];
    Table breakdown=dataSet.breakDown(dataSet.setName,dummy,weight);
    int totHeight=(Toolkit.getDefaultToolkit().getScreenSize()).height;
    int tmpHeight=Math.min(totHeight - 30,60 + breakdown.levels[0] * 30);
    Barchart barchart=new Barchart(plotDialog,300,tmpHeight,breakdown);
    barChartsContainer.add(barchart);
  }
  return barChartsContainer;
}","public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int[] indices=varNames.getSelectedIndices();
  PlotPanel barChartsContainer=new PlotPanel();
  int numPlots=indices.length;
  barChartsContainer.setLayout(new GridLayout(1,numPlots));
  int weight=-1;
  Table[] breakdowns=new Table[numPlots];
  int maxLevels=-1;
  for (int i=0; i < numPlots; i++) {
    int[] dummy={0};
    dummy[0]=indices[i];
    Table breakdown=dataSet.breakDown(dataSet.setName,dummy,weight);
    maxLevels=Math.max(maxLevels,breakdown.levels[0]);
    breakdowns[i]=breakdown;
  }
  Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
  int height=Math.min(screenSize.height - 30,60 + maxLevels * 30);
  int frameWidth=Math.min(screenSize.width - 50,300 * numPlots);
  int plotWidth=frameWidth / numPlots;
  plotDialog.setSize(frameWidth - plotDialog.getInsets().left - plotDialog.getInsets().right,height);
  for (int i=0; i < numPlots; i++) {
    Barchart barchart=new Barchart(plotDialog,plotWidth,height,breakdowns[i]);
    barChartsContainer.add(barchart);
    if (barChartsContainer.getName() != null)     barChartsContainer.setName(barChartsContainer.getName() + ""String_Node_Str"" + barchart.getName());
 else     barChartsContainer.setName(barchart.getName());
  }
  return barChartsContainer;
}",0.5230024213075061
180035,"public Histogram(MDialog frame,int width,int height,Table tablep,double bStart,double bWidth,int weight){
  super(frame);
  this.tablep=tablep;
  this.name=tablep.name;
  this.levels=tablep.levels;
  this.names=tablep.names;
  this.lnames=tablep.lnames;
  this.bStart=bStart;
  this.bWidth=bWidth;
  this.width=width;
  this.height=height;
  this.weight=weight;
  frame.getContentPane().add(this);
  border=20;
  yShift=-10;
  data=tablep.data;
  dvar=tablep.initialVars[0];
  this.k=levels[0];
  round=(int)Math.max(0,3 - Math.round((Math.log(data.getMax(dvar) - data.getMin(dvar)) / Math.log(10))));
  Font SF=new Font(""String_Node_Str"",Font.PLAIN,11);
  frame.setFont(SF);
  String titletext;
  if (weight == -1)   titletext=""String_Node_Str"" + names[0] + ""String_Node_Str"";
 else   titletext=""String_Node_Str"" + names[0] + ""String_Node_Str""+ data.getName(weight)+ ""String_Node_Str"";
  frame.setTitle(titletext);
  xMin=tablep.data.getMin(tablep.initialVars[0]);
  xMax=tablep.data.getMax(tablep.initialVars[0]);
  double range=xMax - xMin;
  yMin=0;
  yMax=1 / range * 4.25;
  if (rects.size() == 0) {
    setCoordinates(xMin - range * 0.05,yMin,xMax + range * 0.05,yMax,-1);
    coordsSet=false;
  }
  this.enableEvents(AWTEvent.WINDOW_EVENT_MASK);
  this.enableEvents(AWTEvent.KEY_EVENT_MASK);
  this.enableEvents(AWTEvent.MOUSE_EVENT_MASK);
  this.requestFocus();
  evtq=Toolkit.getDefaultToolkit().getSystemEventQueue();
}","public Histogram(MDialog frame,int width,int height,Table tablep,double bStart,double bWidth,int weight){
  super(frame);
  this.tablep=tablep;
  this.name=tablep.name;
  this.levels=tablep.levels;
  this.names=tablep.names;
  this.lnames=tablep.lnames;
  this.bStart=bStart;
  this.bWidth=bWidth;
  this.width=width;
  this.height=height;
  this.weight=weight;
  frame.getContentPane().add(this);
  border=20;
  yShift=-10;
  data=tablep.data;
  dvar=tablep.initialVars[0];
  this.k=levels[0];
  round=(int)Math.max(0,3 - Math.round((Math.log(data.getMax(dvar) - data.getMin(dvar)) / Math.log(10))));
  Font SF=new Font(""String_Node_Str"",Font.PLAIN,11);
  frame.setFont(SF);
  String titletext;
  if (weight == -1)   titletext=""String_Node_Str"" + names[0] + ""String_Node_Str"";
 else   titletext=""String_Node_Str"" + names[0] + ""String_Node_Str""+ data.getName(weight)+ ""String_Node_Str"";
  setName(titletext);
  xMin=tablep.data.getMin(tablep.initialVars[0]);
  xMax=tablep.data.getMax(tablep.initialVars[0]);
  double range=xMax - xMin;
  yMin=0;
  yMax=1 / range * 4.25;
  if (rects.size() == 0) {
    setCoordinates(xMin - range * 0.05,yMin,xMax + range * 0.05,yMax,-1);
    coordsSet=false;
  }
  this.enableEvents(AWTEvent.WINDOW_EVENT_MASK);
  this.enableEvents(AWTEvent.KEY_EVENT_MASK);
  this.enableEvents(AWTEvent.MOUSE_EVENT_MASK);
  this.requestFocus();
  evtq=Toolkit.getDefaultToolkit().getSystemEventQueue();
}",0.9933403434980722
180036,"/** 
 * This constructor requires a Frame and a desired size
 */
public MapPlot(MDialog frame,int width,int height,DataSet data,Vector polys,JList varList){
  super(frame);
  this.polys=polys;
  this.data=data;
  border=20;
  if (varList.getSelectedIndices().length > 0)   this.displayVar=varList.getSelectedIndices()[0];
 else   this.displayVar=-1;
  allVarList=varList;
  frame.setTitle(""String_Node_Str"" + data.setName + ""String_Node_Str"");
  int xMin=((MyPoly)polys.elementAt(0)).xpoints[0];
  int xMax=((MyPoly)polys.elementAt(0)).xpoints[0];
  int yMin=((MyPoly)polys.elementAt(0)).ypoints[0];
  int yMax=((MyPoly)polys.elementAt(0)).ypoints[0];
  for (int i=0; i < polys.size(); i++) {
    MyPoly p=(MyPoly)polys.elementAt(i);
    Rectangle box=p.getBounds();
    xMin=Math.min(box.x,xMin);
    xMax=Math.max(box.x + box.width,xMax);
    yMin=Math.min(box.y,yMin);
    yMax=Math.max(box.y + box.height,yMax);
  }
  setCoordinates(xMin,yMin,xMax,yMax,1);
  ratio=(double)(xMax - xMin) / (double)(yMax - yMin);
  p=new JPanel(new FlowLayout());
  Varlist=new JComboBox();
  Varlist.addItem(""String_Node_Str"");
  for (int j=0; j < data.k; j++) {
    Varlist.addItem(data.getName(j));
  }
  Varlist.setSelectedIndex(this.displayVar + 1);
  Varlist.setSize(200,(Varlist.getSize()).height);
  Varlist.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      updateMap();
    }
  }
);
  p.add(Varlist);
  if (RService.hasR()) {
    try {
      RConnection c=new RConnection();
      double[] reds=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      double[] greens=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      double[] blues=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      terrain=new Color[polys.size()];
      for (int i=0; i < polys.size(); i++)       terrain[i]=new Color((float)(reds[i] / 255),(float)(greens[i] / 255),(float)(blues[i] / 255));
      reds=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      greens=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      blues=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      heat=new Color[polys.size()];
      for (int i=0; i < polys.size(); i++)       heat[i]=new Color((float)(reds[i] / 255),(float)(greens[i] / 255),(float)(blues[i] / 255));
      reds=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      greens=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      blues=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      topo=new Color[polys.size()];
      for (int i=0; i < polys.size(); i++)       topo[i]=new Color((float)(reds[i] / 255),(float)(greens[i] / 255),(float)(blues[i] / 255));
      c.close();
    }
 catch (    RserveException rse) {
      System.out.println(""String_Node_Str"" + rse.getMessage());
    }
catch (    REXPMismatchException mme) {
      System.out.println(""String_Node_Str"" + mme.getMessage());
    }
  }
  Collist=new JComboBox();
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  if (RService.hasR()) {
    Collist.addItem(""String_Node_Str"");
    Collist.addItem(""String_Node_Str"");
    Collist.addItem(""String_Node_Str"");
  }
  Collist.setSize(200,(Varlist.getSize()).height);
  p.add(Collist);
  Collist.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      updateMap();
    }
  }
);
  ColMap=new JComboBox();
  ColMap.addItem(""String_Node_Str"");
  ColMap.addItem(""String_Node_Str"");
  ColMap.addItem(""String_Node_Str"");
  p.add(ColMap);
  ColMap.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      updateMap();
    }
  }
);
  JCheckBox cbInvert=new JCheckBox(""String_Node_Str"",inverted);
  cbInvert.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      inverted=!inverted;
      updateMap();
    }
  }
);
  p.add(cbInvert);
  p.add(new JLabel(""String_Node_Str""));
  minField=new JTextField(5);
  minField.addActionListener(this);
  minField.setActionCommand(""String_Node_Str"");
  p.add(minField);
  p.add(new JLabel(""String_Node_Str""));
  maxField=new JTextField(5);
  maxField.addActionListener(this);
  maxField.setActionCommand(""String_Node_Str"");
  p.add(maxField);
  p.setPreferredSize(new Dimension(frame.getWidth(),frame.getHeight()));
  frame.getContentPane().setLayout(new BorderLayout());
  frame.getContentPane().add(p,BorderLayout.NORTH);
  frame.getContentPane().add(this,BorderLayout.CENTER);
  frame.pack();
  System.out.println(p.getMinimumSize() + ""String_Node_Str"" + p.getPreferredSize()+ ""String_Node_Str""+ p.getSize()+ ""String_Node_Str""+ maxField.getY()+ ""String_Node_Str""+ maxField.getHeight());
  p.setPreferredSize(new Dimension(frame.getWidth(),2 + maxField.getY() + maxField.getHeight()));
  frame.pack();
  frame.setVisible(true);
  Varlist.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  Collist.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  ColMap.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  cbInvert.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  maxField.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  minField.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  match=new int[polys.size()];
  boolean[] recMatch=new boolean[data.n];
  int pid=0;
  while (!data.isPolyID(pid))   pid++;
  double[] ids=data.getRawNumbers(pid);
  for (int i=0; i < polys.size(); i++) {
    MyPoly P=(MyPoly)polys.elementAt(i);
    int j=0;
    while (j < ids.length && (int)ids[j] != P.Id) {
      if ((int)ids[j] != P.Id)       j++;
    }
    if (j < ids.length) {
      match[i]=j;
      recMatch[j]=true;
    }
 else {
      P.Id=-1;
      match[i]=-1;
      System.out.println(""String_Node_Str"" + P.Id + ""String_Node_Str"");
    }
  }
  for (int i=0; i < data.n; i++)   if (!recMatch[i])   System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
  this.enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);
  this.enableEvents(AWTEvent.MOUSE_EVENT_MASK);
  this.enableEvents(AWTEvent.ITEM_EVENT_MASK);
  this.enableEvents(AWTEvent.WINDOW_EVENT_MASK);
  this.enableEvents(AWTEvent.KEY_EVENT_MASK);
  this.requestFocus();
}","/** 
 * This constructor requires a Frame and a desired size
 */
public MapPlot(MDialog frame,int width,int height,DataSet data,Vector polys,JList varList){
  super(frame);
  this.polys=polys;
  this.data=data;
  border=20;
  if (varList.getSelectedIndices().length > 0)   this.displayVar=varList.getSelectedIndices()[0];
 else   this.displayVar=-1;
  allVarList=varList;
  setName(""String_Node_Str"" + data.setName + ""String_Node_Str"");
  int xMin=((MyPoly)polys.elementAt(0)).xpoints[0];
  int xMax=((MyPoly)polys.elementAt(0)).xpoints[0];
  int yMin=((MyPoly)polys.elementAt(0)).ypoints[0];
  int yMax=((MyPoly)polys.elementAt(0)).ypoints[0];
  for (int i=0; i < polys.size(); i++) {
    MyPoly p=(MyPoly)polys.elementAt(i);
    Rectangle box=p.getBounds();
    xMin=Math.min(box.x,xMin);
    xMax=Math.max(box.x + box.width,xMax);
    yMin=Math.min(box.y,yMin);
    yMax=Math.max(box.y + box.height,yMax);
  }
  setCoordinates(xMin,yMin,xMax,yMax,1);
  ratio=(double)(xMax - xMin) / (double)(yMax - yMin);
  p=new JPanel(new FlowLayout());
  Varlist=new JComboBox();
  Varlist.addItem(""String_Node_Str"");
  for (int j=0; j < data.k; j++) {
    Varlist.addItem(data.getName(j));
  }
  Varlist.setSelectedIndex(this.displayVar + 1);
  Varlist.setSize(200,(Varlist.getSize()).height);
  Varlist.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      updateMap();
    }
  }
);
  p.add(Varlist);
  if (RService.hasR()) {
    try {
      RConnection c=new RConnection();
      double[] reds=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      double[] greens=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      double[] blues=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      terrain=new Color[polys.size()];
      for (int i=0; i < polys.size(); i++)       terrain[i]=new Color((float)(reds[i] / 255),(float)(greens[i] / 255),(float)(blues[i] / 255));
      reds=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      greens=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      blues=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      heat=new Color[polys.size()];
      for (int i=0; i < polys.size(); i++)       heat[i]=new Color((float)(reds[i] / 255),(float)(greens[i] / 255),(float)(blues[i] / 255));
      reds=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      greens=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      blues=c.eval(""String_Node_Str"" + (polys.size()) + ""String_Node_Str"").asDoubles();
      topo=new Color[polys.size()];
      for (int i=0; i < polys.size(); i++)       topo[i]=new Color((float)(reds[i] / 255),(float)(greens[i] / 255),(float)(blues[i] / 255));
      c.close();
    }
 catch (    RserveException rse) {
      System.out.println(""String_Node_Str"" + rse.getMessage());
    }
catch (    REXPMismatchException mme) {
      System.out.println(""String_Node_Str"" + mme.getMessage());
    }
  }
  Collist=new JComboBox();
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  Collist.addItem(""String_Node_Str"");
  if (RService.hasR()) {
    Collist.addItem(""String_Node_Str"");
    Collist.addItem(""String_Node_Str"");
    Collist.addItem(""String_Node_Str"");
  }
  Collist.setSize(200,(Varlist.getSize()).height);
  p.add(Collist);
  Collist.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      updateMap();
    }
  }
);
  ColMap=new JComboBox();
  ColMap.addItem(""String_Node_Str"");
  ColMap.addItem(""String_Node_Str"");
  ColMap.addItem(""String_Node_Str"");
  p.add(ColMap);
  ColMap.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      updateMap();
    }
  }
);
  JCheckBox cbInvert=new JCheckBox(""String_Node_Str"",inverted);
  cbInvert.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      inverted=!inverted;
      updateMap();
    }
  }
);
  p.add(cbInvert);
  p.add(new JLabel(""String_Node_Str""));
  minField=new JTextField(5);
  minField.addActionListener(this);
  minField.setActionCommand(""String_Node_Str"");
  p.add(minField);
  p.add(new JLabel(""String_Node_Str""));
  maxField=new JTextField(5);
  maxField.addActionListener(this);
  maxField.setActionCommand(""String_Node_Str"");
  p.add(maxField);
  p.setPreferredSize(new Dimension(frame.getWidth(),frame.getHeight()));
  frame.getContentPane().setLayout(new BorderLayout());
  frame.getContentPane().add(p,BorderLayout.NORTH);
  frame.getContentPane().add(this,BorderLayout.CENTER);
  frame.pack();
  System.out.println(p.getMinimumSize() + ""String_Node_Str"" + p.getPreferredSize()+ ""String_Node_Str""+ p.getSize()+ ""String_Node_Str""+ maxField.getY()+ ""String_Node_Str""+ maxField.getHeight());
  p.setPreferredSize(new Dimension(frame.getWidth(),2 + maxField.getY() + maxField.getHeight()));
  frame.pack();
  frame.setVisible(true);
  Varlist.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  Collist.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  ColMap.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  cbInvert.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  maxField.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  minField.addKeyListener(new KeyAdapter(){
    public void keyPressed(    KeyEvent e){
      processKeyEvent(e);
    }
  }
);
  match=new int[polys.size()];
  boolean[] recMatch=new boolean[data.n];
  int pid=0;
  while (!data.isPolyID(pid))   pid++;
  double[] ids=data.getRawNumbers(pid);
  for (int i=0; i < polys.size(); i++) {
    MyPoly P=(MyPoly)polys.elementAt(i);
    int j=0;
    while (j < ids.length && (int)ids[j] != P.Id) {
      if ((int)ids[j] != P.Id)       j++;
    }
    if (j < ids.length) {
      match[i]=j;
      recMatch[j]=true;
    }
 else {
      P.Id=-1;
      match[i]=-1;
      System.out.println(""String_Node_Str"" + P.Id + ""String_Node_Str"");
    }
  }
  for (int i=0; i < data.n; i++)   if (!recMatch[i])   System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
  this.enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);
  this.enableEvents(AWTEvent.MOUSE_EVENT_MASK);
  this.enableEvents(AWTEvent.ITEM_EVENT_MASK);
  this.enableEvents(AWTEvent.WINDOW_EVENT_MASK);
  this.enableEvents(AWTEvent.KEY_EVENT_MASK);
  this.requestFocus();
}",0.9986164712735746
180037,"public MissPlot(MDialog frame,DataSet data,int[] vars){
  super(frame);
  this.vars=vars;
  this.data=data;
  this.k=vars.length;
  permA=new int[k];
  IpermA=new int[k];
  for (int j=0; j < k; j++) {
    permA[j]=j;
    IpermA[permA[j]]=j;
  }
  sb.setUnitIncrement(22);
  sb.setBlockIncrement(22);
  frame.getContentPane().add(this);
  Font SF=new Font(""String_Node_Str"",Font.PLAIN,11);
  frame.setFont(SF);
  border=20;
  String titletext;
  titletext=""String_Node_Str"";
  for (int j=0; j < this.k; j++) {
    boolean[] tmpMiss;
    double[] values=new double[2];
    int[][] Ids=new int[2][];
    tmpMiss=data.getMissings(vars[j]);
    values[0]=data.getN(vars[j]);
    values[1]=data.n - values[0];
    Ids[0]=new int[(int)values[0]];
    Ids[1]=new int[(int)values[1]];
    int obsPointer=0;
    int NAPointer=0;
    for (int i=0; i < data.n; i++) {
      if (!tmpMiss[i])       Ids[0][obsPointer++]=i;
 else       Ids[1][NAPointer++]=i;
    }
    tables.addElement(new Table(""String_Node_Str"",values,1,new int[]{2},new String[]{data.getName(vars[j])},new String[][]{{""String_Node_Str"",""String_Node_Str""}},new int[]{vars[j]},Ids,data,-1));
  }
  frame.setTitle(titletext);
  setScrollX();
  EventQueue evtq=Toolkit.getDefaultToolkit().getSystemEventQueue();
}","public MissPlot(MDialog frame,DataSet data,int[] vars){
  super(frame);
  this.vars=vars;
  this.data=data;
  this.k=vars.length;
  permA=new int[k];
  IpermA=new int[k];
  for (int j=0; j < k; j++) {
    permA[j]=j;
    IpermA[permA[j]]=j;
  }
  sb.setUnitIncrement(22);
  sb.setBlockIncrement(22);
  frame.getContentPane().add(this);
  Font SF=new Font(""String_Node_Str"",Font.PLAIN,11);
  frame.setFont(SF);
  border=20;
  String titletext;
  titletext=""String_Node_Str"";
  for (int j=0; j < this.k; j++) {
    boolean[] tmpMiss;
    double[] values=new double[2];
    int[][] Ids=new int[2][];
    tmpMiss=data.getMissings(vars[j]);
    values[0]=data.getN(vars[j]);
    values[1]=data.n - values[0];
    Ids[0]=new int[(int)values[0]];
    Ids[1]=new int[(int)values[1]];
    int obsPointer=0;
    int NAPointer=0;
    for (int i=0; i < data.n; i++) {
      if (!tmpMiss[i])       Ids[0][obsPointer++]=i;
 else       Ids[1][NAPointer++]=i;
    }
    tables.addElement(new Table(""String_Node_Str"",values,1,new int[]{2},new String[]{data.getName(vars[j])},new String[][]{{""String_Node_Str"",""String_Node_Str""}},new int[]{vars[j]},Ids,data,-1));
  }
  setName(titletext);
  setScrollX();
  EventQueue evtq=Toolkit.getDefaultToolkit().getSystemEventQueue();
}",0.9274673008323424
180038,"public void paint(Graphics2D g){
  frame.setBackground(ColorManager.backgroundColor);
  tablep.getSelection();
  Dimension size;
  size=this.getSize();
  Graphics2D bg;
  if (!printing) {
    bi=createImage(size.width,size.height);
    bg=(Graphics2D)bi.getGraphics();
  }
 else   bg=g;
  create(border,border,size.width - border,size.height - border,""String_Node_Str"");
  String titletext=""String_Node_Str"";
  for (int i=0; i < k; i++) {
    if (i < k - 1 && i != maxLevel - 1)     titletext+=names[i] + ""String_Node_Str"";
 else     titletext+=names[i];
    if (i + 1 == maxLevel && maxLevel < k)     titletext+=""String_Node_Str"";
  }
  if (maxLevel < k)   titletext+=""String_Node_Str"";
 else   titletext+=""String_Node_Str"";
  frame.setTitle(titletext);
  if (displayMode.equals(""String_Node_Str"") || displayMode.equals(""String_Node_Str"")) {
    if (!printing)     bg.setColor(new Color(1.0F,1.0F,1.0F,0.2F));
 else     bg.setColor(new Color(0.95F,0.95F,0.95F,1.0F));
    for (int i=0; i < rects.size(); i++) {
      MyRect r=(MyRect)rects.elementAt(i);
      bg.fillRect(r.x,r.y - r.height + r.h,r.width,r.height);
      bg.drawRect(r.x,r.y - r.height + r.h,r.width,r.height);
    }
  }
  for (int i=0; i < rects.size(); i++) {
    MyRect r=(MyRect)rects.elementAt(i);
    r.setMax(residMax);
    double sum=0, sumh=0;
    for (int j=0; j < r.tileIds.size(); j++) {
      int id=(Integer)(r.tileIds.elementAt(j));
      sumh+=tablep.getSelected(id) * tablep.table[id];
      sum+=tablep.table[id];
    }
    r.setHilite(sumh / sum);
    if (!((displayMode.equals(""String_Node_Str"") || displayMode.equals(""String_Node_Str"")) && sum == 0))     r.draw(bg);
    bg.setColor(Color.black);
  }
  bg.setColor(ColorManager.lineColor);
  if (displayMode.equals(""String_Node_Str"") || displayMode.equals(""String_Node_Str"") || displayMode.equals(""String_Node_Str"")|| printing|| showLabels)   for (int i=0; i < Labels.size(); i++) {
    MyText t=(MyText)Labels.elementAt(i);
    t.draw(bg);
  }
  if (!printing) {
    drawSelections(bg);
    g.drawImage(bi,0,0,null);
    bg.dispose();
  }
}","public void paint(Graphics2D g){
  frame.setBackground(ColorManager.backgroundColor);
  tablep.getSelection();
  Dimension size;
  size=this.getSize();
  Graphics2D bg;
  if (!printing) {
    bi=createImage(size.width,size.height);
    bg=(Graphics2D)bi.getGraphics();
  }
 else   bg=g;
  create(border,border,size.width - border,size.height - border,""String_Node_Str"");
  String titletext=""String_Node_Str"";
  for (int i=0; i < k; i++) {
    if (i < k - 1 && i != maxLevel - 1)     titletext+=names[i] + ""String_Node_Str"";
 else     titletext+=names[i];
    if (i + 1 == maxLevel && maxLevel < k)     titletext+=""String_Node_Str"";
  }
  if (maxLevel < k)   titletext+=""String_Node_Str"";
 else   titletext+=""String_Node_Str"";
  setName(titletext);
  if (displayMode.equals(""String_Node_Str"") || displayMode.equals(""String_Node_Str"")) {
    if (!printing)     bg.setColor(new Color(1.0F,1.0F,1.0F,0.2F));
 else     bg.setColor(new Color(0.95F,0.95F,0.95F,1.0F));
    for (int i=0; i < rects.size(); i++) {
      MyRect r=(MyRect)rects.elementAt(i);
      bg.fillRect(r.x,r.y - r.height + r.h,r.width,r.height);
      bg.drawRect(r.x,r.y - r.height + r.h,r.width,r.height);
    }
  }
  for (int i=0; i < rects.size(); i++) {
    MyRect r=(MyRect)rects.elementAt(i);
    r.setMax(residMax);
    double sum=0, sumh=0;
    for (int j=0; j < r.tileIds.size(); j++) {
      int id=(Integer)(r.tileIds.elementAt(j));
      sumh+=tablep.getSelected(id) * tablep.table[id];
      sum+=tablep.table[id];
    }
    r.setHilite(sumh / sum);
    if (!((displayMode.equals(""String_Node_Str"") || displayMode.equals(""String_Node_Str"")) && sum == 0))     r.draw(bg);
    bg.setColor(Color.black);
  }
  bg.setColor(ColorManager.lineColor);
  if (displayMode.equals(""String_Node_Str"") || displayMode.equals(""String_Node_Str"") || displayMode.equals(""String_Node_Str"")|| printing|| showLabels)   for (int i=0; i < Labels.size(); i++) {
    MyText t=(MyText)Labels.elementAt(i);
    t.draw(bg);
  }
  if (!printing) {
    drawSelections(bg);
    g.drawImage(bi,0,0,null);
    bg.dispose();
  }
}",0.9954249939802552
180039,"public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int k=(varNames.getSelectedIndices()).length;
  int[] passBuffer=new int[k];
  for (int i=0; i < k; i++)   passBuffer[i]=mondrian.getSelector().selectBuffer[k - i - 1];
  Table breakdown=dataSet.breakDown(dataSet.setName,passBuffer,-1);
  for (int i=0; i < (varNames.getSelectedIndices()).length - 1; i++) {
    breakdown.addInteraction(new int[]{i},false);
  }
  breakdown.addInteraction(new int[]{(varNames.getSelectedIndices()).length - 1},true);
  return new MosaicPlot(plotDialog,400,400,breakdown);
}","public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int k=(varNames.getSelectedIndices()).length;
  int[] passBuffer=new int[k];
  for (int i=0; i < k; i++)   passBuffer[i]=mondrian.getSelector().selectBuffer[k - i - 1];
  Table breakdown=dataSet.breakDown(dataSet.setName,passBuffer,-1);
  for (int i=0; i < (varNames.getSelectedIndices()).length - 1; i++) {
    breakdown.addInteraction(new int[]{i},false);
  }
  breakdown.addInteraction(new int[]{(varNames.getSelectedIndices()).length - 1},true);
  plotDialog.setSize(400,400);
  plotDialog.setLocation(Utils.genRandomLoacation(plotDialog));
  return new MosaicPlot(plotDialog,400,400,breakdown);
}",0.9278663629460896
180040,"public boolean isCompliant(DataSet dataSet,int numVariables,int numCategoricalVariables){
  return numVariables > 2 && (numVariables - 1) == numCategoricalVariables;
}","public boolean isCompliant(DataSet dataSet,int numVariables,int numCategoricalVariables){
  return numVariables >= 2 && numVariables == numCategoricalVariables;
}",0.9787234042553192
180041,"public ParallelPlot(MDialog frame,DataSet data,int[] vars,String mode,JList varList){
  super(frame);
  Dimension size=frame.getSize();
  this.width=size.width;
  this.height=size.height;
  oldWidth=size.width;
  oldHeight=size.height;
  this.vars=vars;
  this.data=data;
  this.k=vars.length;
  this.paintMode=mode;
  this.varList=varList;
  border=22;
  onlyHi=new boolean[data.n];
  for (int i=0; i < data.n; i++)   onlyHi[i]=true;
  if (k == 2) {
    if (data.categorical(vars[0]) && !data.categorical(vars[1]) && mode.equals(""String_Node_Str"")) {
      paintMode=""String_Node_Str"";
      xVar=vars[1];
      yVar=vars[0];
    }
    if (data.categorical(vars[1]) && !data.categorical(vars[0]) && mode.equals(""String_Node_Str"")) {
      paintMode=""String_Node_Str"";
      xVar=vars[0];
      yVar=vars[1];
    }
  }
  if (paintMode.equals(""String_Node_Str"")) {
    k=data.getNumLevels(yVar);
    frame.setSize(50 * (1 + k),400);
  }
  selected=new boolean[k];
  inverted=new boolean[k];
  for (int j=0; j < k; j++) {
    selected[j]=false;
    inverted[j]=false;
  }
  permA=new int[k];
  for (int j=0; j < k; j++)   permA[j]=j;
  frame.getContentPane().add(this);
  Font SF=new Font(""String_Node_Str"",Font.BOLD,12);
  frame.setFont(SF);
  getData();
  this.setBackground(frame.getBackground());
  setCoordinates(0,0,0,0,-1);
  if (paintMode.equals(""String_Node_Str""))   frame.setTitle(""String_Node_Str"" + data.getName(xVar) + ""String_Node_Str""+ data.getName(yVar)+ ""String_Node_Str"");
 else   if (paintMode.equals(""String_Node_Str""))   frame.setTitle(""String_Node_Str"" + data.setName + ""String_Node_Str"");
 else   frame.setTitle(""String_Node_Str"" + data.setName + ""String_Node_Str"");
  evtq=Toolkit.getDefaultToolkit().getSystemEventQueue();
  this.enableEvents(AWTEvent.MOUSE_EVENT_MASK);
  this.enableEvents(AWTEvent.KEY_EVENT_MASK);
  this.requestFocus();
}","public ParallelPlot(MDialog frame,DataSet data,int[] vars,String mode,JList varList){
  super(frame);
  Dimension size=frame.getSize();
  this.width=size.width;
  this.height=size.height;
  oldWidth=size.width;
  oldHeight=size.height;
  this.vars=vars;
  this.data=data;
  this.k=vars.length;
  this.paintMode=mode;
  this.varList=varList;
  border=22;
  onlyHi=new boolean[data.n];
  for (int i=0; i < data.n; i++)   onlyHi[i]=true;
  if (k == 2) {
    if (data.categorical(vars[0]) && !data.categorical(vars[1]) && mode.equals(""String_Node_Str"")) {
      paintMode=""String_Node_Str"";
      xVar=vars[1];
      yVar=vars[0];
    }
    if (data.categorical(vars[1]) && !data.categorical(vars[0]) && mode.equals(""String_Node_Str"")) {
      paintMode=""String_Node_Str"";
      xVar=vars[0];
      yVar=vars[1];
    }
  }
  if (paintMode.equals(""String_Node_Str"")) {
    k=data.getNumLevels(yVar);
    frame.setSize(50 * (1 + k),400);
  }
  selected=new boolean[k];
  inverted=new boolean[k];
  for (int j=0; j < k; j++) {
    selected[j]=false;
    inverted[j]=false;
  }
  permA=new int[k];
  for (int j=0; j < k; j++)   permA[j]=j;
  frame.getContentPane().add(this);
  Font SF=new Font(""String_Node_Str"",Font.BOLD,12);
  frame.setFont(SF);
  getData();
  this.setBackground(frame.getBackground());
  setCoordinates(0,0,0,0,-1);
  if (paintMode.equals(""String_Node_Str""))   setName(""String_Node_Str"" + data.getName(xVar) + ""String_Node_Str""+ data.getName(yVar)+ ""String_Node_Str"");
 else   if (paintMode.equals(""String_Node_Str""))   setName(""String_Node_Str"" + data.setName + ""String_Node_Str"");
 else   setName(""String_Node_Str"" + data.setName + ""String_Node_Str"");
  evtq=Toolkit.getDefaultToolkit().getSystemEventQueue();
  this.enableEvents(AWTEvent.MOUSE_EVENT_MASK);
  this.enableEvents(AWTEvent.KEY_EVENT_MASK);
  this.requestFocus();
}",0.9846236849204208
180042,"public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int k=(varNames.getSelectedIndices()).length;
  int[] passTmpBuffer=new int[k];
  int count=0;
  for (int i=0; i < k; i++) {
    if (dataSet.getNumMissings(mondrian.getSelector().selectBuffer[k - i - 1]) < dataSet.n)     passTmpBuffer[count++]=mondrian.getSelector().selectBuffer[k - i - 1];
  }
  int[] passBuffer=new int[count];
  System.arraycopy(passTmpBuffer,0,passBuffer,0,count);
  return new ParallelPlot(plotDialog,dataSet,passBuffer,getMode(),varNames);
}","public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int totWidth=(Toolkit.getDefaultToolkit().getScreenSize()).width;
  int tmpWidth=50 * (1 + (varNames.getSelectedIndices()).length);
  if (tmpWidth > totWidth)   if (20 * (1 + (varNames.getSelectedIndices()).length) < totWidth)   tmpWidth=totWidth;
 else   tmpWidth=20 * (1 + (varNames.getSelectedIndices()).length);
  plotDialog.setSize(tmpWidth,400);
  plotDialog.setLocation(Utils.genRandomLoacation(plotDialog));
  int k=(varNames.getSelectedIndices()).length;
  int[] passTmpBuffer=new int[k];
  int count=0;
  for (int i=0; i < k; i++) {
    if (dataSet.getNumMissings(mondrian.getSelector().selectBuffer[k - i - 1]) < dataSet.n)     passTmpBuffer[count++]=mondrian.getSelector().selectBuffer[k - i - 1];
  }
  int[] passBuffer=new int[count];
  System.arraycopy(passTmpBuffer,0,passBuffer,0,count);
  return new ParallelPlot(plotDialog,dataSet,passBuffer,getMode(),varNames);
}",0.7317073170731707
180043,"public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int numVars=(varNames.getSelectedIndices()).length;
  PlotPanel splomPanel=new PlotPanel();
  splomPanel.setLayout(new GridLayout(numVars - 1,numVars - 1));
  splomPanel.setMinimumSize(new Dimension(200 * numVars,200 * numVars));
  for (int i=0; i < (numVars - 1); i++)   for (int j=1; j < numVars; j++) {
    if (i >= j) {
      JPanel Filler=new JPanel();
      Filler.setBackground(ColorManager.backgroundColor);
      splomPanel.add(Filler);
    }
 else {
      int[] tmpVars=new int[2];
      tmpVars[0]=mondrian.getSelector().selectBuffer[numVars - j - 1];
      tmpVars[1]=mondrian.getSelector().selectBuffer[numVars - i - 1];
      Scatter2DPlot scat=new Scatter2DPlot(plotDialog,200,200,dataSet,tmpVars,varNames,true);
      splomPanel.add(scat);
    }
  }
  return splomPanel;
}","public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int numVars=(varNames.getSelectedIndices()).length;
  PlotPanel splomPanel=new PlotPanel();
  splomPanel.setLayout(new GridLayout(numVars - 1,numVars - 1));
  splomPanel.setMinimumSize(new Dimension(200 * numVars,200 * numVars));
  int dims=Math.min(200 * numVars,(Toolkit.getDefaultToolkit().getScreenSize()).height);
  plotDialog.setSize(dims - 20,dims);
  for (int i=0; i < (numVars - 1); i++)   for (int j=1; j < numVars; j++) {
    if (i >= j) {
      JPanel Filler=new JPanel();
      Filler.setBackground(ColorManager.backgroundColor);
      splomPanel.add(Filler);
    }
 else {
      int[] tmpVars=new int[2];
      tmpVars[0]=mondrian.getSelector().selectBuffer[numVars - j - 1];
      tmpVars[1]=mondrian.getSelector().selectBuffer[numVars - i - 1];
      Scatter2DPlot scat=new Scatter2DPlot(plotDialog,200,200,dataSet,tmpVars,varNames,true);
      splomPanel.add(scat);
    }
  }
  return splomPanel;
}",0.9336121275483532
180044,"public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int[] indices=varNames.getSelectedIndices();
  PlotPanel barChartsContainer=new PlotPanel();
  plotDialog.setLayout(new GridLayout(1,indices.length));
  int[] vars=WeightCaclulator.getWeightVariable(varNames.getSelectedIndices(),dataSet,mondrian.calcNumCategoricalVars(),mondrian.determineWeightIndex(),null,varNames);
  int[] passed=new int[vars.length - 1];
  System.arraycopy(vars,0,passed,0,vars.length - 1);
  int weight=vars[vars.length - 1];
  for (int i=0; i < passed.length; i++) {
    int[] dummy={0};
    dummy[0]=passed[i];
    Table breakdown=dataSet.breakDown(dataSet.setName,dummy,weight);
    int totHeight=(Toolkit.getDefaultToolkit().getScreenSize()).height;
    int tmpHeight=Math.min(totHeight - 20,60 + breakdown.levels[0] * 30);
    Barchart weightedBarchart=new Barchart(plotDialog,300,tmpHeight,breakdown);
    barChartsContainer.add(weightedBarchart);
  }
  return barChartsContainer;
}","public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int[] indices=varNames.getSelectedIndices();
  PlotPanel barChartsContainer=new PlotPanel();
  plotDialog.setLayout(new GridLayout(1,indices.length));
  int[] vars=WeightCaclulator.getWeightVariable(varNames.getSelectedIndices(),dataSet,mondrian.calcNumCategoricalVars(),mondrian.determineWeightIndex(),null,varNames);
  int[] passed=new int[vars.length - 1];
  System.arraycopy(vars,0,passed,0,vars.length - 1);
  int weight=vars[vars.length - 1];
  for (int i=0; i < passed.length; i++) {
    int[] dummy={0};
    dummy[0]=passed[i];
    Table breakdown=dataSet.breakDown(dataSet.setName,dummy,weight);
    int totHeight=(Toolkit.getDefaultToolkit().getScreenSize()).height;
    int tmpHeight=Math.min(totHeight - 20,60 + breakdown.levels[0] * 30);
    Barchart weightedBarchart=new Barchart(plotDialog,300,tmpHeight,breakdown);
    barChartsContainer.setSize(300,tmpHeight);
    barChartsContainer.add(weightedBarchart);
  }
  plotDialog.setLocation(100,100);
  return barChartsContainer;
}",0.9612109744560076
180045,"public boolean isCompliant(DataSet dataSet,int numVariables,int numCategoricalVariables){
  return numVariables == numCategoricalVariables;
}","public boolean isCompliant(DataSet dataSet,int numVariables,int numCategoricalVariables){
  return numVariables == 1 && numVariables == numCategoricalVariables;
}",0.9306930693069309
180046,"public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int k=(varNames.getSelectedIndices()).length;
  int[] passBuffer=new int[k];
  for (int i=0; i < k; i++)   passBuffer[i]=mondrian.getSelector().selectBuffer[k - i - 1];
  int[] vars=WeightCaclulator.getWeightVariable(passBuffer,dataSet,mondrian.calcNumCategoricalVars(),mondrian.determineWeightIndex(),null,varNames);
  int[] passed=new int[vars.length - 1];
  System.arraycopy(vars,0,passed,0,vars.length - 1);
  int weight=vars[vars.length - 1];
  Table breakdown=dataSet.breakDown(dataSet.setName,passed,weight);
  for (int i=0; i < passed.length - 1; i++)   breakdown.addInteraction(new int[]{i},false);
  breakdown.addInteraction(new int[]{passed.length - 1},true);
  return new MosaicPlot(plotDialog,400,400,breakdown);
}","public PlotPanel createPlotPanel(Mondrian mondrian,MDialog plotDialog,DataSet dataSet,JList varNames){
  int k=(varNames.getSelectedIndices()).length;
  int[] passBuffer=new int[k];
  for (int i=0; i < k; i++)   passBuffer[i]=mondrian.getSelector().selectBuffer[k - i - 1];
  int[] vars=WeightCaclulator.getWeightVariable(passBuffer,dataSet,mondrian.calcNumCategoricalVars(),mondrian.determineWeightIndex(),null,varNames);
  int[] passed=new int[vars.length - 1];
  System.arraycopy(vars,0,passed,0,vars.length - 1);
  int weight=vars[vars.length - 1];
  Table breakdown=dataSet.breakDown(dataSet.setName,passed,weight);
  for (int i=0; i < passed.length - 1; i++)   breakdown.addInteraction(new int[]{i},false);
  breakdown.addInteraction(new int[]{passed.length - 1},true);
  plotDialog.setSize(400,400);
  plotDialog.setLocation(Utils.genRandomLoacation(plotDialog));
  return new MosaicPlot(plotDialog,400,400,breakdown);
}",0.945992040932348
180047,"public void actionPerformed(ActionEvent e){
  Mondrian mondrian=monFrame.getController().getCurrent();
  mondrian.getSelector().checkHistoryBuffer();
  MDialog plotFrame=new MDialog(monFrame,mondrian);
  Font SF=new Font(""String_Node_Str"",Font.PLAIN,11);
  plotFrame.setFont(SF);
  PlotPanel plotPanel=plotFactory.createPlotPanel(mondrian,plotFrame,mondrian.getDataSet(),mondrian.getSelector().getVarNames());
  if (plotPanel != null) {
    for (    PlotPanel plot : plotPanel.getPlots()) {
      monFrame.getController().getCurrent().addPlot((DragBox)plot);
    }
    plotFrame.getContentPane().add(plotPanel);
    plotFrame.setTitle(plotPanel.getName() != null ? plotPanel.getName() : plotFactory.getPlotName());
    plotFrame.setVisible(true);
  }
}","public void actionPerformed(ActionEvent e){
  Mondrian mondrian=monFrame.getController().getCurrent();
  mondrian.getSelector().checkHistoryBuffer();
  MDialog plotFrame=new MDialog(monFrame,mondrian);
  Font SF=new Font(""String_Node_Str"",Font.PLAIN,11);
  plotFrame.setFont(SF);
  PlotPanel plotPanel=plotFactory.createPlotPanel(mondrian,plotFrame,mondrian.getDataSet(),mondrian.getSelector().getVarNames());
  if (plotPanel != null) {
    for (    PlotPanel plot : plotPanel.getPlots()) {
      mondrian.addPlot((DragBox)plot);
    }
    plotFrame.getContentPane().add(plotPanel);
    plotFrame.setTitle(plotPanel.getName() != null ? plotPanel.getName() : plotFactory.getPlotName());
    plotFrame.setVisible(true);
  }
}",0.9735593220338984
180048,"public PlotPanel createPlotPanel(Mondrian mondrian,MFrame plotFrame,DataSet dataSet,JList varNames){
  int[] indices=varNames.getSelectedIndices();
  PlotPanel barChartsContainer=new PlotPanel();
  int numPlots=indices.length;
  barChartsContainer.setLayout(new GridLayout(1,numPlots));
  int weight=-1;
  Table[] breakdowns=new Table[numPlots];
  int maxLevels=-1;
  for (int i=0; i < numPlots; i++) {
    int[] dummy={0};
    dummy[0]=indices[i];
    Table breakdown=dataSet.breakDown(dataSet.setName,dummy,weight);
    maxLevels=Math.max(maxLevels,breakdown.levels[0]);
    breakdowns[i]=breakdown;
  }
  Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
  int height=Math.min(screenSize.height - 30,60 + maxLevels * 30);
  int frameWidth=Math.min(screenSize.width - 50,300 * numPlots);
  int plotWidth=frameWidth / numPlots;
  plotFrame.setSize(frameWidth - plotFrame.getInsets().left - plotFrame.getInsets().right,height);
  for (int i=0; i < numPlots; i++) {
    Barchart barchart=new Barchart(plotFrame,plotWidth,height,breakdowns[i]);
    barChartsContainer.add(barchart);
    if (barChartsContainer.getName() != null)     barChartsContainer.setName(barChartsContainer.getName() + ""String_Node_Str"" + barchart.getName());
 else     barChartsContainer.setName(barchart.getName());
  }
  return barChartsContainer;
}","public PlotPanel createPlotPanel(Mondrian mondrian,MFrame plotFrame,DataSet dataSet,JList varNames){
  int[] indices=varNames.getSelectedIndices();
  int weight=-1;
  return createBarChart(mondrian,plotFrame,dataSet,indices,weight);
}",0.2290076335877862
180049,"public PlotPanel createPlotPanel(Mondrian mondrian,MFrame plotFrame,DataSet dataSet,JList varNames){
  int[] indices=varNames.getSelectedIndices();
  PlotPanel barChartsContainer=new PlotPanel();
  plotFrame.setLayout(new GridLayout(1,indices.length));
  int[] vars=WeightCaclulator.getWeightVariable(varNames.getSelectedIndices(),dataSet,mondrian.calcNumCategoricalVars(),mondrian.determineWeightIndex(),null,varNames);
  int[] passed=new int[vars.length - 1];
  System.arraycopy(vars,0,passed,0,vars.length - 1);
  int weight=vars[vars.length - 1];
  for (int i=0; i < passed.length; i++) {
    int[] dummy={0};
    dummy[0]=passed[i];
    Table breakdown=dataSet.breakDown(dataSet.setName,dummy,weight);
    int totHeight=(Toolkit.getDefaultToolkit().getScreenSize()).height;
    int tmpHeight=Math.min(totHeight - 20,60 + breakdown.levels[0] * 30);
    Barchart weightedBarchart=new Barchart(plotFrame,300,tmpHeight,breakdown);
    barChartsContainer.setSize(300,tmpHeight);
    barChartsContainer.add(weightedBarchart);
  }
  plotFrame.setLocation(100,100);
  return barChartsContainer;
}","@Override public PlotPanel createPlotPanel(Mondrian mondrian,MFrame plotFrame,DataSet dataSet,JList varNames){
  int[] vars=WeightCaclulator.getWeightVariable(varNames.getSelectedIndices(),dataSet,mondrian.calcNumCategoricalVars(),mondrian.determineWeightIndex(),null,varNames);
  if (vars.length > 1) {
    int[] passed=new int[vars.length - 1];
    System.arraycopy(vars,0,passed,0,vars.length - 1);
    int weight=vars[vars.length - 1];
    return super.createBarChart(mondrian,plotFrame,dataSet,passed,weight);
  }
 else {
    return super.createBarChart(mondrian,plotFrame,dataSet,vars,vars[0]);
  }
}",0.4932313125367863
180050,"public void show(){
  m=new JMenuItem(getTitle());
  parentFrame.closeAllMenuItem.setEnabled(true);
  for (int i=2; i < parentFrame.windowMenu.getItemCount(); i++)   if (((parentFrame.windowMenu.getItem(i)).getText()).substring(0,2).equals((m.getText()).substring(0,2)))   same=true;
 else   if (same) {
    parentFrame.windowMenu.insert(m,i);
    added=true;
    same=false;
  }
  if (!added) {
    parentFrame.windowMenu.add(m);
    added=true;
  }
  m.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      toFront();
    }
  }
);
  super.show();
}","public void show(){
  m=new JMenuItem(getTitle());
  parentFrame.closeAllMenuItem.setEnabled(true);
  for (int i=2; i < parentFrame.windowMenu.getItemCount(); i++) {
    String entryName=(parentFrame.windowMenu.getItem(i)).getText();
    if (entryName.length() < 3) {
      continue;
    }
    if (entryName.substring(0,2).equals((m.getText()).substring(0,2))) {
      same=true;
    }
 else     if (same) {
      parentFrame.windowMenu.insert(m,i);
      added=true;
      same=false;
    }
  }
  if (!added) {
    parentFrame.windowMenu.add(m);
    added=true;
  }
  m.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      toFront();
    }
  }
);
  super.show();
}",0.8328220858895705
180051,"public MDialog(MonFrame parentFrame,Mondrian mondrian){
  this.mondrian=mondrian;
  this.parentFrame=parentFrame;
  this.setBackground(ColorManager.backgroundColor);
  addWindowListener(this);
}","public MDialog(MonFrame parentFrame,Mondrian mondrian){
  this.mondrian=mondrian;
  this.parentFrame=parentFrame;
  this.getContentPane().setBackground(ColorManager.backgroundColor);
  addWindowListener(this);
}",0.9580246913580248
180052,"public void loadDataSet(File file,String dsName){
  ProgIndicatorImpl progIndicator=new ProgIndicatorImpl();
  DataSet dataSet=new AsciiFileLoader(progIndicator,getMonFrame()).loadAsciiFile(file);
  progIndicator.dispose();
  if (dataSet != null) {
    if (dsName != null) {
      dataSet.setName=dsName;
    }
    Mondrian mondrian=new Mondrian(dataSet,this);
    addAndActiviate(mondrian);
  }
}","public void loadDataSet(File file,String dsName){
  ProgIndicatorImpl progIndicator=new ProgIndicatorImpl();
  DataSet dataSet=new AsciiFileLoader(progIndicator,getMonFrame()).loadAsciiFile(file);
  progIndicator.dispose();
  if (dataSet != null) {
    if (dsName != null) {
      dataSet.setName=dsName;
    }
    Mondrian mondrian=new Mondrian(dataSet,this);
    addAndActiviate(mondrian);
    mondrian.getDialog().setVisible(true);
  }
}",0.948626045400239
180053,"public void addAndActiviate(Mondrian mondrian){
  mondrians.add(mondrian);
  monFrame.maintainOptionMenu();
}","public void addAndActiviate(Mondrian mondrian){
  mondrians.add(mondrian);
  setCurrent(mondrian);
  monFrame.maintainOptionMenu();
}",0.9008264462809916
180054,"public Mondrian getCurrent(){
  return null;
}","public Mondrian getCurrent(){
  return current;
}",0.9052631578947368
180055,"public void closeAll(){
  String message=""String_Node_Str"";
  int answer=JOptionPane.showConfirmDialog(monFrame,message);
  if (answer == JOptionPane.YES_OPTION) {
    closeAll();
  }
}","public void closeAll(){
  if (countInstances() > 0) {
    String message=""String_Node_Str"";
    int answer=JOptionPane.showConfirmDialog(monFrame,message);
    if (answer == JOptionPane.YES_OPTION) {
      System.exit(0);
    }
  }
 else {
    System.exit(0);
  }
}",0.7466666666666667
180056,"public void showModeNavigator(){
  if (modelNavigator == null)   modelNavigator=new ModelNavigator();
 else   modelNavigator.show();
}","public void showModeNavigator(){
  if (modelNavigator == null) {
    modelNavigator=new ModelNavigator();
  }
 else {
    modelNavigator.show();
  }
}",0.943661971830986
180057,"public MonFrame(){
  Toolkit.getDefaultToolkit().setDynamicLayout(false);
  MRJApplicationUtils.registerQuitHandler(this);
  RService.init();
  Font SF=new Font(""String_Node_Str"",Font.BOLD,12);
  this.setFont(SF);
  this.setTitle(""String_Node_Str"");
  num_windows++;
  menubar=new JMenuBar();
  JMenu file=menubar.add(new JMenu(""String_Node_Str""));
  file.add(new JMenuItem(new OpenDataSetAction(controller)));
  file.add(new JMenuItem(new LoadRDataFrameAction(controller)));
  file.add(new JMenuItem(new CreateDBDataSetAction(controller)));
  saveAction=new SaveDataSetAction(""String_Node_Str"",false,controller);
  file.add(new JMenuItem(saveAction));
  saveDataSetAction=new SaveDataSetAction(""String_Node_Str"",true,controller);
  file.add(new JMenuItem(saveDataSetAction));
  file.add(closeDataSetMenuItem=new JMenuItem(new CloseDataSetAction(controller)));
  JMenuItem q=new JMenuItem(""String_Node_Str"");
  if (((System.getProperty(""String_Node_Str"")).toLowerCase()).indexOf(""String_Node_Str"") == -1) {
    file.addSeparator();
    file.add(q);
    q.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
    q.addActionListener(new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        try {
          RConnection c=new RConnection();
          c.shutdown();
        }
 catch (        RserveException ignored) {
        }
        System.exit(0);
      }
    }
);
  }
  menubar.add(file);
  plotMenu=new JMenu(""String_Node_Str"");
  menubar.add(plotMenu);
  transformMenu=TransformAction.createTrafoMenu(this);
  menubar.add(transformMenu);
  JMenu options=new JMenu(""String_Node_Str"");
  JMenuItem sa;
  options.add(sa=new JMenuItem(""String_Node_Str""));
  sa.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  JMenuItem ts;
  options.add(ts=new JMenuItem(""String_Node_Str""));
  ts.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_K,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  JMenu sam=new JMenu(""String_Node_Str"");
  options.add(sam=new JMenu(""String_Node_Str""));
  sam.add(orSelectionCheckMenuItem=new JCheckBoxMenuItem(""String_Node_Str""));
  sam.add(andSelectionCheckMenuItem=new JCheckBoxMenuItem(""String_Node_Str""));
  andSelectionCheckMenuItem.setSelected(true);
  options.addSeparator();
  JMenuItem cc;
  options.add(cc=new JMenuItem(""String_Node_Str""));
  cc.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_B,Event.ALT_MASK | Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  options.addSeparator();
  options.add(selSeqCheckItem=new JCheckBoxMenuItem(""String_Node_Str"",selseq));
  selSeqCheckItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  JMenuItem cs;
  options.add(cs=new JMenuItem(""String_Node_Str""));
  cs.setAccelerator(KeyStroke.getKeyStroke(Event.BACK_SPACE,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  options.addSeparator();
  options.add(alphaOnHighlightCheckMenuItem=new JCheckBoxMenuItem(""String_Node_Str"",alphaHi));
  alphaOnHighlightCheckMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_L,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  options.addSeparator();
  JMenuItem vm;
  options.add(vm=new JMenuItem(""String_Node_Str""));
  vm.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_T,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  options.add(deriveVarMenu=new JMenu(""String_Node_Str""));
  deriveVarMenu.add(selectionMenuItem=new JMenuItem(""String_Node_Str""));
  selectionMenuItem.setEnabled(false);
  deriveVarMenu.add(colorsMenuItem=new JMenuItem(""String_Node_Str""));
  colorsMenuItem.setEnabled(false);
  options.addSeparator();
  options.add(modelNavigatorButton=new JMenuItem(""String_Node_Str"",KeyEvent.VK_J));
  modelNavigatorButton.setEnabled(false);
  options.addSeparator();
  JMenuItem pr;
  options.add(pr=new JMenuItem(""String_Node_Str"",KeyEvent.VK_K));
  pr.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_COMMA,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  menubar.add(options);
  windowMenu=menubar.add(new JMenu(""String_Node_Str""));
  windowMenu.add(closeAllMenuItem=new JMenuItem(""String_Node_Str""));
  closeAllMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W,Event.SHIFT_MASK | Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  closeAllMenuItem.setEnabled(false);
  windowMenu.addSeparator();
  windowMenu.add(me=new JMenuItem(this.getTitle()));
  helpMenu=menubar.add(new JMenu(""String_Node_Str""));
  JMenuItem rc;
  helpMenu.add(rc=new JMenuItem(""String_Node_Str""));
  rc.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_HELP,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  rc.setEnabled(true);
  JCheckBoxMenuItem ih;
  helpMenu.add(ih=new JCheckBoxMenuItem(""String_Node_Str""));
  ih.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_HELP,Event.SHIFT_MASK | Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  ih.setEnabled(false);
  JMenuItem oh;
  helpMenu.add(oh=new JMenuItem(""String_Node_Str""));
  oh.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_HELP,Event.SHIFT_MASK | Event.ALT_MASK | Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  oh.setEnabled(true);
  this.setJMenuBar(menubar);
  Icon MondrianIcon=new ImageIcon(Utils.readGif(""String_Node_Str""));
  JLabel MondrianLabel=new JLabel(MondrianIcon);
  JScrollPane scrollPane=new JScrollPane(MondrianLabel,JScrollPane.VERTICAL_SCROLLBAR_NEVER,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  getContentPane().add(""String_Node_Str"",scrollPane);
  selSeqCheckItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      switchSelection();
    }
  }
);
  selectionMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      deriveVariable(false);
    }
  }
);
  colorsMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      deriveVariable(true);
    }
  }
);
  orSelectionCheckMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setExtSelMode(true);
    }
  }
);
  andSelectionCheckMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setExtSelMode(false);
    }
  }
);
  sa.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      selectAll();
    }
  }
);
  ts.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      toggleSelection();
    }
  }
);
  cc.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      clearColors();
    }
  }
);
  alphaOnHighlightCheckMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      switchAlpha();
    }
  }
);
  modelNavigatorButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      showModeNavigator();
    }
  }
);
  pr.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      preferenceFrame();
    }
  }
);
  cs.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
    }
  }
);
  vm.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      controller.getCurrent().getSelector().switchVariableMode();
    }
  }
);
  closeAllMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      controller.closeAll();
    }
  }
);
  closeDataSetMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      controller.close(controller.getCurrent());
    }
  }
);
  me.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      toFront();
    }
  }
);
  rc.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      Utils.showRefCard();
    }
  }
);
  oh.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      try {
        Desktop.getDesktop().browse(new URL(""String_Node_Str"").toURI());
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
catch (      URISyntaxException e11) {
        e11.printStackTrace();
      }
    }
  }
);
  setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
  this.addWindowListener(new WindowAdapter(){
    public void windowClosing(    WindowEvent e){
      controller.closeAll();
    }
  }
);
  this.addWindowListener(new WindowAdapter(){
    public void windowActivated(    WindowEvent e){
    }
  }
);
  this.setResizable(false);
  this.setSize(295,320);
  this.show();
  Graphics g=this.getGraphics();
  g.setFont(new Font(""String_Node_Str"",0,11));
  g.drawString(""String_Node_Str"",260,285);
}","public MonFrame(){
  controller=new MonController(this);
  Toolkit.getDefaultToolkit().setDynamicLayout(false);
  MRJApplicationUtils.registerQuitHandler(this);
  RService.init();
  Font SF=new Font(""String_Node_Str"",Font.BOLD,12);
  this.setFont(SF);
  this.setTitle(""String_Node_Str"");
  num_windows++;
  menubar=new JMenuBar();
  JMenu file=menubar.add(new JMenu(""String_Node_Str""));
  file.add(new JMenuItem(new OpenDataSetAction(controller)));
  file.add(new JMenuItem(new LoadRDataFrameAction(controller)));
  file.add(new JMenuItem(new CreateDBDataSetAction(controller)));
  saveAction=new SaveDataSetAction(""String_Node_Str"",false,controller);
  file.add(new JMenuItem(saveAction));
  saveSelectionAction=new SaveDataSetAction(""String_Node_Str"",true,controller);
  file.add(new JMenuItem(saveSelectionAction));
  file.add(closeDataSetMenuItem=new JMenuItem(new CloseDataSetAction(controller)));
  JMenuItem q=new JMenuItem(""String_Node_Str"");
  if (((System.getProperty(""String_Node_Str"")).toLowerCase()).indexOf(""String_Node_Str"") == -1) {
    file.addSeparator();
    file.add(q);
    q.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
    q.addActionListener(new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        try {
          RConnection c=new RConnection();
          c.shutdown();
        }
 catch (        RserveException ignored) {
        }
        System.exit(0);
      }
    }
);
  }
  menubar.add(file);
  plotMenu=new JMenu(""String_Node_Str"");
  menubar.add(plotMenu);
  transformMenu=TransformAction.createTrafoMenu(this);
  menubar.add(transformMenu);
  JMenu options=new JMenu(""String_Node_Str"");
  JMenuItem sa;
  options.add(sa=new JMenuItem(""String_Node_Str""));
  sa.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  JMenuItem ts;
  options.add(ts=new JMenuItem(""String_Node_Str""));
  ts.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_K,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  JMenu sam=new JMenu(""String_Node_Str"");
  options.add(sam);
  sam.add(orSelectionCheckMenuItem=new JCheckBoxMenuItem(""String_Node_Str""));
  sam.add(andSelectionCheckMenuItem=new JCheckBoxMenuItem(""String_Node_Str""));
  andSelectionCheckMenuItem.setSelected(true);
  options.addSeparator();
  JMenuItem cc;
  options.add(cc=new JMenuItem(""String_Node_Str""));
  cc.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_B,Event.ALT_MASK | Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  options.addSeparator();
  options.add(selSeqCheckItem=new JCheckBoxMenuItem(""String_Node_Str"",selseq));
  selSeqCheckItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  JMenuItem cs;
  options.add(cs=new JMenuItem(""String_Node_Str""));
  cs.setAccelerator(KeyStroke.getKeyStroke(Event.BACK_SPACE,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  options.addSeparator();
  options.add(alphaOnHighlightCheckMenuItem=new JCheckBoxMenuItem(""String_Node_Str"",alphaHi));
  alphaOnHighlightCheckMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_L,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  options.addSeparator();
  JMenuItem vm;
  options.add(vm=new JMenuItem(""String_Node_Str""));
  vm.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_T,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  options.add(deriveVarMenu=new JMenu(""String_Node_Str""));
  deriveVarMenu.add(selectionMenuItem=new JMenuItem(""String_Node_Str""));
  selectionMenuItem.setEnabled(false);
  deriveVarMenu.add(colorsMenuItem=new JMenuItem(""String_Node_Str""));
  colorsMenuItem.setEnabled(false);
  options.addSeparator();
  options.add(modelNavigatorButton=new JMenuItem(""String_Node_Str"",KeyEvent.VK_J));
  modelNavigatorButton.setEnabled(false);
  options.addSeparator();
  JMenuItem pr;
  options.add(pr=new JMenuItem(""String_Node_Str"",KeyEvent.VK_K));
  pr.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_COMMA,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  menubar.add(options);
  windowMenu=menubar.add(new JMenu(""String_Node_Str""));
  windowMenu.add(closeAllMenuItem=new JMenuItem(""String_Node_Str""));
  closeAllMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W,Event.SHIFT_MASK | Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  closeAllMenuItem.setEnabled(false);
  windowMenu.addSeparator();
  windowMenu.add(me=new JMenuItem(this.getTitle()));
  helpMenu=menubar.add(new JMenu(""String_Node_Str""));
  JMenuItem rc;
  helpMenu.add(rc=new JMenuItem(""String_Node_Str""));
  rc.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_HELP,Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  rc.setEnabled(true);
  JCheckBoxMenuItem ih;
  helpMenu.add(ih=new JCheckBoxMenuItem(""String_Node_Str""));
  ih.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_HELP,Event.SHIFT_MASK | Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  ih.setEnabled(false);
  JMenuItem oh;
  helpMenu.add(oh=new JMenuItem(""String_Node_Str""));
  oh.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_HELP,Event.SHIFT_MASK | Event.ALT_MASK | Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
  oh.setEnabled(true);
  this.setJMenuBar(menubar);
  Icon MondrianIcon=new ImageIcon(Utils.readGif(""String_Node_Str""));
  JLabel MondrianLabel=new JLabel(MondrianIcon);
  JScrollPane scrollPane=new JScrollPane(MondrianLabel,JScrollPane.VERTICAL_SCROLLBAR_NEVER,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  getContentPane().add(""String_Node_Str"",scrollPane);
  selSeqCheckItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      switchSelection();
    }
  }
);
  selectionMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      deriveVariable(false);
    }
  }
);
  colorsMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      deriveVariable(true);
    }
  }
);
  orSelectionCheckMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setExtSelMode(true);
    }
  }
);
  andSelectionCheckMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setExtSelMode(false);
    }
  }
);
  sa.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      selectAll();
    }
  }
);
  ts.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      toggleSelection();
    }
  }
);
  cc.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      clearColors();
    }
  }
);
  alphaOnHighlightCheckMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      switchAlpha();
    }
  }
);
  modelNavigatorButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      showModeNavigator();
    }
  }
);
  pr.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      preferenceFrame();
    }
  }
);
  cs.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
    }
  }
);
  vm.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      controller.getCurrent().getSelector().switchVariableMode();
    }
  }
);
  closeAllMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      controller.closeAll();
    }
  }
);
  closeDataSetMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      controller.close(controller.getCurrent());
    }
  }
);
  me.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      toFront();
    }
  }
);
  rc.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      Utils.showRefCard();
    }
  }
);
  oh.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      try {
        Desktop.getDesktop().browse(new URL(""String_Node_Str"").toURI());
      }
 catch (      IOException e1) {
        e1.printStackTrace();
      }
catch (      URISyntaxException e11) {
        e11.printStackTrace();
      }
    }
  }
);
  setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
  this.addWindowListener(new WindowAdapter(){
    public void windowClosing(    WindowEvent e){
      controller.closeAll();
    }
  }
);
  this.addWindowListener(new WindowAdapter(){
    public void windowActivated(    WindowEvent e){
    }
  }
);
  this.setResizable(false);
  this.setSize(295,320);
  this.show();
  Graphics g=this.getGraphics();
  g.setFont(new Font(""String_Node_Str"",0,11));
  g.drawString(""String_Node_Str"",260,285);
  registerCommonPlots();
}",0.9930687534935718
180058,"public void maintainOptionMenu(){
  DataSet data=controller.getCurrentDataSet();
  closeDataSetMenuItem.setEnabled(true);
  saveMenuItem.setEnabled(true);
  if (data.countSelection() == 0)   selectionMenuItem.setEnabled(false);
 else   selectionMenuItem.setEnabled(true);
  if (data.colorBrush)   colorsMenuItem.setEnabled(true);
 else   colorsMenuItem.setEnabled(false);
  boolean mode=DragBox.extSelMode;
  orSelectionCheckMenuItem.setSelected(mode);
  andSelectionCheckMenuItem.setSelected(!mode);
}","public void maintainOptionMenu(){
  DataSet data=controller.getCurrentDataSet();
  closeDataSetMenuItem.setEnabled(true);
  saveAction.setEnabled(true);
  if (data.countSelection() == 0)   selectionMenuItem.setEnabled(false);
 else   selectionMenuItem.setEnabled(true);
  if (data.colorBrush)   colorsMenuItem.setEnabled(true);
 else   colorsMenuItem.setEnabled(false);
  boolean mode=DragBox.extSelMode;
  orSelectionCheckMenuItem.setSelected(mode);
  andSelectionCheckMenuItem.setSelected(!mode);
}",0.9860279441117764
180059,"public Mondrian(DataSet dataSet,MonController controller){
  this.dataSet=dataSet;
  this.controller=controller;
  dialog=new MondrianDialog(controller.getMonFrame(),this);
  dialog.setSize(300,400);
  dialog.setVisible(true);
}","public Mondrian(DataSet dataSet,MonController controller){
  this.dataSet=dataSet;
  this.controller=controller;
  dialog=new MondrianDialog(controller.getMonFrame(),this);
}",0.8656716417910447
180060,"public void updateSelection(){
  boolean selectAll=false;
  boolean unSelect=false;
  boolean toggleSelection=false;
  for (int i=0; i < plots.size(); i++) {
    if (plots.elementAt(i).selectAll) {
      plots.elementAt(i).selectAll=false;
      selectAll=true;
    }
    if (plots.elementAt(i).unSelect) {
      plots.elementAt(i).unSelect=false;
      unSelect=true;
    }
    if (plots.elementAt(i).toggleSelection) {
      plots.elementAt(i).toggleSelection=false;
      toggleSelection=true;
    }
    if (plots.elementAt(i).deleteAll) {
      plots.elementAt(i).deleteAll=false;
      deleteSelection();
      return;
    }
    if (plots.elementAt(i).switchSel) {
      plots.elementAt(i).switchSel=false;
      JCheckBoxMenuItem selSeqCheckItem=controller.getMonFrame().selSeqCheckItem;
      selSeqCheckItem.setSelected(!selSeqCheckItem.isSelected());
      controller.monFrame.switchSelection();
      return;
    }
    if (plots.elementAt(i).switchAlpha) {
      plots.elementAt(i).switchAlpha=false;
      JCheckBoxMenuItem alphaOnHighlightCheckMenuItem=controller.getMonFrame().alphaOnHighlightCheckMenuItem;
      alphaOnHighlightCheckMenuItem.setSelected(!alphaOnHighlightCheckMenuItem.isSelected());
      controller.getMonFrame().switchAlpha();
      plots.elementAt(i).updateSelection();
      return;
    }
  }
  if (!(unSelect || selectAll || toggleSelection)) {
    for (int i=selList.size() - 1; i >= 0; i--) {
      if ((selList.elementAt(i).status == Selection.KILLED) || !selList.elementAt(i).d.frame.isVisible()) {
        selList.removeElementAt(i);
      }
    }
    selList.trimToSize();
    Selection oneClick=null;
    for (int i=0; i < plots.size(); i++)     if (plots.elementAt(i).frame.isVisible()) {
      if (plots.elementAt(i).selectFlag) {
        plots.elementAt(i).selectFlag=false;
        Selection S=(Selection)(((DragBox)plots.elementAt(i)).Selections.lastElement());
        if (selList.indexOf(S) == -1) {
          if (!(S.r.width < 3 || S.r.height < 3) && controller.monFrame.selseq) {
            System.out.println(""String_Node_Str"");
            S.step=selList.size() + 1;
            selList.addElement(S);
          }
 else {
            oneClick=S;
            System.out.println(""String_Node_Str"");
            oneClick.status=Selection.KILLED;
            plots.elementAt(i).Selections.removeElementAt(plots.elementAt(i).Selections.size() - 1);
          }
        }
      }
    }
 else     plots.removeElementAt(i--);
    if (selList.size() > 1) {
      selList.firstElement().mode=Selection.MODE_STANDARD;
    }
    if (oneClick != null) {
      oneClick.r.width+=1;
      oneClick.r.height+=1;
      (oneClick.d).maintainSelection(oneClick);
    }
 else {
      for (int i=0; i < selList.size(); i++) {
        Selection S=selList.elementAt(i);
        S.step=i + 1;
        S.total=selList.size();
        (S.d).maintainSelection(S);
        (S.d).frame.maintainMenu(S.step);
      }
    }
  }
 else {
    if (toggleSelection) {
      System.out.println(""String_Node_Str"");
      controller.getCurrentDataSet().toggleSelection();
    }
 else     if (unSelect) {
      System.out.println(""String_Node_Str"");
      controller.getCurrentDataSet().clearSelection();
    }
 else {
      System.out.println(""String_Node_Str"");
      controller.getCurrentDataSet().selectAll();
    }
  }
  for (int i=0; i < plots.size(); i++) {
    getProgBar().setValue(1);
    plots.elementAt(i).updateSelection();
  }
  controller.getCurrentDataSet().selChanged=true;
  int selectionCount=controller.getCurrentDataSet().countSelection();
  int denom=controller.getCurrentDataSet().n;
  String msg=selectionCount + ""String_Node_Str"" + denom+ ""String_Node_Str""+ StatUtil.roundToString(100F * selectionCount / denom,2)+ ""String_Node_Str"";
  setProgText(msg);
  getProgBar().setValue(selectionCount);
  controller.getMonFrame().maintainOptionMenu();
  controller.getMonFrame().saveSelectionMenuItem.setEnabled(selectionCount > 0);
}","public void updateSelection(){
  boolean selectAll=false;
  boolean unSelect=false;
  boolean toggleSelection=false;
  for (int i=0; i < plots.size(); i++) {
    if (plots.elementAt(i).selectAll) {
      plots.elementAt(i).selectAll=false;
      selectAll=true;
    }
    if (plots.elementAt(i).unSelect) {
      plots.elementAt(i).unSelect=false;
      unSelect=true;
    }
    if (plots.elementAt(i).toggleSelection) {
      plots.elementAt(i).toggleSelection=false;
      toggleSelection=true;
    }
    if (plots.elementAt(i).deleteAll) {
      plots.elementAt(i).deleteAll=false;
      deleteSelection();
      return;
    }
    if (plots.elementAt(i).switchSel) {
      plots.elementAt(i).switchSel=false;
      JCheckBoxMenuItem selSeqCheckItem=controller.getMonFrame().selSeqCheckItem;
      selSeqCheckItem.setSelected(!selSeqCheckItem.isSelected());
      controller.monFrame.switchSelection();
      return;
    }
    if (plots.elementAt(i).switchAlpha) {
      plots.elementAt(i).switchAlpha=false;
      JCheckBoxMenuItem alphaOnHighlightCheckMenuItem=controller.getMonFrame().alphaOnHighlightCheckMenuItem;
      alphaOnHighlightCheckMenuItem.setSelected(!alphaOnHighlightCheckMenuItem.isSelected());
      controller.getMonFrame().switchAlpha();
      plots.elementAt(i).updateSelection();
      return;
    }
  }
  if (!(unSelect || selectAll || toggleSelection)) {
    for (int i=selList.size() - 1; i >= 0; i--) {
      if ((selList.elementAt(i).status == Selection.KILLED) || !selList.elementAt(i).d.frame.isVisible()) {
        selList.removeElementAt(i);
      }
    }
    selList.trimToSize();
    Selection oneClick=null;
    for (int i=0; i < plots.size(); i++)     if (plots.elementAt(i).frame.isVisible()) {
      if (plots.elementAt(i).selectFlag) {
        plots.elementAt(i).selectFlag=false;
        Selection S=(Selection)(((DragBox)plots.elementAt(i)).Selections.lastElement());
        if (selList.indexOf(S) == -1) {
          if (!(S.r.width < 3 || S.r.height < 3) && controller.monFrame.selseq) {
            System.out.println(""String_Node_Str"");
            S.step=selList.size() + 1;
            selList.addElement(S);
          }
 else {
            oneClick=S;
            System.out.println(""String_Node_Str"");
            oneClick.status=Selection.KILLED;
            plots.elementAt(i).Selections.removeElementAt(plots.elementAt(i).Selections.size() - 1);
          }
        }
      }
    }
 else     plots.removeElementAt(i--);
    if (selList.size() > 1) {
      selList.firstElement().mode=Selection.MODE_STANDARD;
    }
    if (oneClick != null) {
      oneClick.r.width+=1;
      oneClick.r.height+=1;
      (oneClick.d).maintainSelection(oneClick);
    }
 else {
      for (int i=0; i < selList.size(); i++) {
        Selection S=selList.elementAt(i);
        S.step=i + 1;
        S.total=selList.size();
        (S.d).maintainSelection(S);
        (S.d).frame.maintainMenu(S.step);
      }
    }
  }
 else {
    if (toggleSelection) {
      System.out.println(""String_Node_Str"");
      controller.getCurrentDataSet().toggleSelection();
    }
 else     if (unSelect) {
      System.out.println(""String_Node_Str"");
      controller.getCurrentDataSet().clearSelection();
    }
 else {
      System.out.println(""String_Node_Str"");
      controller.getCurrentDataSet().selectAll();
    }
  }
  for (int i=0; i < plots.size(); i++) {
    getProgBar().setValue(1);
    plots.elementAt(i).updateSelection();
  }
  controller.getCurrentDataSet().selChanged=true;
  int selectionCount=controller.getCurrentDataSet().countSelection();
  int denom=controller.getCurrentDataSet().n;
  String msg=selectionCount + ""String_Node_Str"" + denom+ ""String_Node_Str""+ StatUtil.roundToString(100F * selectionCount / denom,2)+ ""String_Node_Str"";
  setProgText(msg);
  getProgBar().setValue(selectionCount);
  controller.getMonFrame().maintainOptionMenu();
  controller.getMonFrame().saveSelectionAction.setEnabled(selectionCount > 0);
}",0.9982349974785678
180061,"public MondrianDialog(MonFrame parentFrame,Mondrian mondrian){
  super(parentFrame,mondrian);
  this.mondrian=mondrian;
  JPanel content=new JPanel(new BorderLayout());
  getContentPane().add(content);
  varSelector=new VariableSelector(mondrian.getDataSet());
  content.add(varSelector,BorderLayout.CENTER);
  JPanel progPanel=new JPanel();
  progPanel.add(""String_Node_Str"",progText);
  progBar=new JProgressBar();
  progBar.setMinimum(0);
  progBar.setMaximum(1);
  progBar.setValue(0);
  progBar.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      paintAll(MondrianDialog.this.getGraphics());
    }
  }
);
  progPanel.add(progBar,BorderLayout.CENTER);
  progText=new JLabel();
  progPanel.add(progText,BorderLayout.WEST);
  content.add(progPanel,BorderLayout.CENTER);
  updateSelectionInfo();
}","public MondrianDialog(MonFrame parentFrame,Mondrian mondrian){
  super(parentFrame,mondrian);
  this.mondrian=mondrian;
  JPanel content=new JPanel(new BorderLayout());
  getContentPane().add(content);
  varSelector=new VariableSelector(mondrian.getDataSet());
  content.add(varSelector,BorderLayout.CENTER);
  JPanel progPanel=new JPanel();
  progBar=new JProgressBar();
  progBar.setMinimum(0);
  progBar.setMaximum(1);
  progBar.setValue(0);
  progBar.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      paintAll(MondrianDialog.this.getGraphics());
    }
  }
);
  progPanel.add(progBar,BorderLayout.EAST);
  progText=new JLabel();
  progPanel.add(progText,BorderLayout.WEST);
  content.add(progPanel,BorderLayout.CENTER);
  setTitle(mondrian.getDataSet().setName);
  setSize(300,400);
  updateSelectionInfo();
}",0.7962308598351001
180062,"public MondrianStarter(String dataFileName){
  MonFrame monFrame=new MonFrame();
  monFrame.registerPlotFactory(new MissPlotFactory());
  monFrame.plotMenu.add(new JSeparator());
  monFrame.registerPlotFactory(new BarchartFactory());
  monFrame.registerPlotFactory(new WeightedBarCharFactory());
  monFrame.plotMenu.add(new JSeparator());
  monFrame.registerPlotFactory(new HistogramFactory());
  monFrame.registerPlotFactory(new WeightedHistogramFactory());
  monFrame.plotMenu.add(new JSeparator());
  monFrame.registerPlotFactory(new ScatterplotFactory());
  monFrame.registerPlotFactory(new SplomFactory());
  monFrame.plotMenu.add(new JSeparator());
  monFrame.registerPlotFactory(new MosaicPlotFactory());
  monFrame.registerPlotFactory(new WeightedMosaicPlotFactory());
  monFrame.plotMenu.add(new JSeparator());
  monFrame.registerPlotFactory(new BoxplotByXYFactory());
  monFrame.registerPlotFactory(new ParallelBoxplotFactory());
  monFrame.registerPlotFactory(new ParallelPlotFactory());
  monFrame.plotMenu.add(new JSeparator());
  monFrame.registerPlotFactory(new TwoDimMDSFactory());
  monFrame.registerPlotFactory(new MapPlotFactory());
  monFrame.registerPlotFactory(new PCAPlotFactory());
  MRJApplicationUtils.registerOpenDocumentHandler(this);
  if (dataFileName != null) {
    File dataFile=new File(dataFileName);
    if (dataFile.canRead()) {
      if (dataFile.getName().endsWith(""String_Node_Str"")) {
        new DataFrameConverter(monFrame).loadDataFrame(dataFile);
      }
 else {
        monFrame.getController().loadDataSet(dataFile,""String_Node_Str"");
      }
    }
  }
  try {
    Thread.sleep(Integer.MAX_VALUE);
  }
 catch (  InterruptedException ignored) {
  }
}","public MondrianStarter(String dataFileName){
  MonFrame monFrame=new MonFrame();
  MRJApplicationUtils.registerOpenDocumentHandler(this);
  if (dataFileName != null) {
    File dataFile=new File(dataFileName);
    if (dataFile.canRead()) {
      if (dataFile.getName().endsWith(""String_Node_Str"")) {
        new DataFrameConverter(monFrame).loadDataFrame(dataFile);
      }
 else {
        monFrame.getController().loadDataSet(dataFile,dataFile.getName());
      }
    }
  }
  try {
    Thread.sleep(Integer.MAX_VALUE);
  }
 catch (  InterruptedException ignored) {
  }
}",0.4889673433362754
180063,"public void setProgText(String msg){
}","public void setProgText(String msg){
  setTitle(msg);
}",0.8172043010752689
180064,"public JProgressBar getProgBar(){
  return null;
}","public JProgressBar getProgBar(){
  return progBar;
}",0.8932038834951457
180065,"public ProgIndicatorImpl(){
  setSize(300,300);
  setLayout(new BorderLayout());
  progBar.setMinimum(0);
  progBar.setMaximum(100);
  add(progBar,BorderLayout.CENTER);
  setModal(true);
  setVisible(true);
}","public ProgIndicatorImpl(){
  setSize(200,30);
  setLayout(new BorderLayout());
  progBar.setMinimum(0);
  progBar.setMaximum(100);
  add(progBar,BorderLayout.CENTER);
  setLocationRelativeTo(null);
  setVisible(true);
}",0.9158878504672896
180066,"private static SessionFactory buildSessionFactory(){
  try {
    return new AnnotationConfiguration().configure().buildSessionFactory();
  }
 catch (  Throwable ex) {
    System.err.println(""String_Node_Str"" + ex);
    throw new ExceptionInInitializerError(ex);
  }
}","private static SessionFactory buildSessionFactory(){
  try {
    return new AnnotationConfiguration().configure().buildSessionFactory();
  }
 catch (  Throwable ex) {
    log.error(""String_Node_Str"" + ex);
    throw new ExceptionInInitializerError(ex);
  }
}",0.9638095238095238
180067,"/** 
 * Randomly generates a short code of 6 characters
 * @return
 */
public static String generateShortCode(){
  StringBuffer buffer=new StringBuffer();
  for (int i=0; i < 6; i++) {
    int r=random.nextInt(CHARSET.length());
    buffer.append(CHARSET.charAt(r));
  }
  return buffer.toString();
}","/** 
 * Randomly generates a short code of 6 characters
 * @return
 */
public static String generateShortCode(){
  StringBuilder buffer=new StringBuilder();
  for (int i=0; i < 6; i++) {
    int r=random.nextInt(CHARSET.length());
    buffer.append(CHARSET.charAt(r));
  }
  return buffer.toString();
}",0.9833887043189368
180068,"private LinkController initLinkController(){
  String persistence=request.getSession().getServletContext().getInitParameter(""String_Node_Str"");
  if (persistence != null && ""String_Node_Str"".equals(persistence.toLowerCase())) {
    return new HibernateLinkController();
  }
  return new SimpleDBLinkController();
}","private LinkDAO initLinkController(){
  String persistence=request.getSession().getServletContext().getInitParameter(""String_Node_Str"");
  if (persistence != null && ""String_Node_Str"".equals(persistence.toLowerCase())) {
    return new HibernateLinkDAO();
  }
  return new SimpleDBLinkDAO();
}",0.9357495881383856
180069,"private LinkController getLinkController(){
  if (linkController == null) {
    linkController=initLinkController();
  }
  return linkController;
}","private LinkDAO getLinkController(){
  if (linkController == null) {
    linkController=initLinkController();
  }
  return linkController;
}",0.9547038327526132
180070,"void saveClayBlocks(){
  LinkedList<SaveBlock> glocations=new LinkedList<SaveBlock>();
  Collection<ClayDelay> cblock=clayblocks.values();
  for (  Object oblock : cblock) {
    ClayDelay theblock=(ClayDelay)oblock;
    glocations.add(new SaveBlock(theblock));
  }
  try {
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(new File(claySaveFile)));
    out.writeObject(glocations);
    out.flush();
    out.close();
  }
 catch (  Exception e) {
    if (debug) {
      System.out.println(""String_Node_Str"");
      System.out.println(e);
    }
  }
}","void saveClayBlocks(){
  LinkedList<SaveBlock> glocations=new LinkedList<SaveBlock>();
  Collection<ClayDelay> cblock=clayblocks.values();
  for (  ClayDelay theblock : cblock) {
    glocations.add(new SaveBlock(theblock));
  }
  try {
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(new File(claySaveFile)));
    out.writeObject(glocations);
    out.flush();
    out.close();
  }
 catch (  Exception e) {
    if (true) {
      System.out.println(""String_Node_Str"");
      System.out.println(e);
    }
  }
}",0.9344262295081968
180071,"private void loadBlocks(){
  try {
    ObjectInputStream out=new ObjectInputStream(new FileInputStream(new File(blockSaveFile)));
    if (debug) {
      System.out.println(""String_Node_Str"");
    }
    LinkedList<SaveBlock> glocations=(LinkedList<SaveBlock>)out.readObject();
    if (debug) {
      System.out.println(""String_Node_Str"");
    }
    newgravellist.clear();
    for (    SaveBlock blocklocation : glocations) {
      org.bukkit.World theworld=getServer().getWorld(blocklocation.getWorld());
      Location lblock=new Location(theworld,blocklocation.getX(),blocklocation.getY(),blocklocation.getZ());
      Block theblock=lblock.getBlock();
      newgravellist.put(getBlockString(theblock),new ClayDelay(theblock,blocklocation.getDelayvalue(),blocklocation.getIntime()));
    }
    if (debug) {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    if (debug) {
      System.out.println(""String_Node_Str"");
      System.out.println(e);
    }
  }
}","private void loadBlocks(){
  try {
    ObjectInputStream out=new ObjectInputStream(new FileInputStream(new File(blockSaveFile)));
    if (debug) {
      System.out.println(""String_Node_Str"");
    }
    LinkedList<SaveBlock> glocations=(LinkedList<SaveBlock>)out.readObject();
    if (debug) {
      System.out.println(""String_Node_Str"");
    }
    newgravellist.clear();
    for (    SaveBlock blocklocation : glocations) {
      org.bukkit.World theworld=getServer().getWorld(blocklocation.getWorld());
      Location lblock=new Location(theworld,blocklocation.getX(),blocklocation.getY(),blocklocation.getZ());
      Block theblock=lblock.getBlock();
      if (loadchunks) {
        addBlockToChunk(theblock);
      }
      newgravellist.put(getBlockString(theblock),new ClayDelay(theblock,blocklocation.getDelayvalue(),blocklocation.getIntime()));
    }
    if (debug) {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    if (debug) {
      System.out.println(""String_Node_Str"");
      System.out.println(e);
    }
  }
}",0.9672371638141808
180072,"@Override public synchronized void run(){
  boolean running=true;
  int savedelay=0;
  while (running) {
    if (newgravellist.size() == 0) {
      if (debug) {
        System.out.println(""String_Node_Str"");
      }
      if (savefarm) {
        saveBlocks();
        savedelay=0;
      }
      try {
        wait();
      }
 catch (      InterruptedException e) {
      }
    }
    try {
      wait(10000);
    }
 catch (    InterruptedException e) {
    }
    Iterator<Entry<String,ClayDelay>> listing=newgravellist.entrySet().iterator();
    while (listing.hasNext()) {
      ClayDelay blockupdate=(ClayDelay)listing.next().getValue();
      boolean isloaded=blockupdate.getBlock().getWorld().isChunkLoaded(blockupdate.getBlock().getChunk());
      if (isloaded || loadchunks) {
        if (!isloaded) {
          if (debug) {
            System.out.println(""String_Node_Str"");
          }
          blockupdate.getBlock().getWorld().loadChunk(blockupdate.getBlock().getChunk());
        }
        if (blockupdate.getBlock().getTypeId() == GRAVEL && (mcmmomode || blockupdate.getBlock().getRelative(BlockFace.DOWN).getTypeId() == activateblock)) {
          boolean alreadyupdated=false;
          if (waterenabled && lavaenabled) {
            if (hasBlockNextTo(blockupdate.getBlock(),FLOWINGWATER,WATER,FLOWINGLAVA,LAVA)) {
              blockupdate.upDelay(generator.nextInt(2));
              if (debug) {
                System.out.println(""String_Node_Str"" + blockupdate.getDelay());
              }
              alreadyupdated=true;
            }
          }
 else           if (waterenabled) {
            if (hasBlockNextTo(blockupdate.getBlock(),FLOWINGWATER,WATER)) {
              blockupdate.upDelay(generator.nextInt(2));
              if (debug) {
                System.out.println(""String_Node_Str"" + blockupdate.getDelay());
              }
              alreadyupdated=true;
            }
          }
 else           if (lavaenabled) {
            if (hasBlockNextTo(blockupdate.getBlock(),FLOWINGLAVA,LAVA)) {
              blockupdate.upDelay(generator.nextInt(2));
              if (debug) {
                System.out.println(""String_Node_Str"" + blockupdate.getDelay());
              }
              alreadyupdated=true;
            }
          }
          if (alreadyupdated == false) {
            if (debug) {
              System.out.println(""String_Node_Str"");
            }
            listing.remove();
          }
 else           if (blockupdate.getDelay() >= farmdelay || (blockupdate.getInTime() + (10000 * maxfarmdelay)) <= System.currentTimeMillis()) {
            listing.remove();
            int rand=generator.nextInt(10000);
            if (graveltoclaychance == 100.0) {
              doneblocks.add(blockupdate.getBlock());
              if (customdrops) {
                blockupdate.resetTimeIn();
                clayblocks.put(compileBlockString(blockupdate.getBlock()),blockupdate);
                saveClayBlocks();
              }
            }
 else             if (rand >= (10000.0 - (graveltoclaychance * 100.0))) {
              doneblocks.add(blockupdate.getBlock());
              if (customdrops) {
                blockupdate.resetTimeIn();
                clayblocks.put(compileBlockString(blockupdate.getBlock()),blockupdate);
                saveClayBlocks();
              }
            }
            if (debug) {
              System.out.println(""String_Node_Str"" + newgravellist.size() + ""String_Node_Str"");
            }
          }
        }
 else {
          listing.remove();
          if (debug) {
            System.out.println(""String_Node_Str"" + newgravellist.size() + ""String_Node_Str"");
          }
        }
      }
 else       if (loadchunks) {
        blockupdate.getBlock().getWorld().loadChunk(blockupdate.getBlock().getChunk());
      }
    }
    savedelay++;
    if (savefarm && savedelay >= 10) {
      saveBlocks();
      savedelay=0;
    }
  }
}","@Override public synchronized void run(){
  boolean running=true;
  int savedelay=0;
  while (running) {
    if (newgravellist.size() == 0) {
      if (debug) {
        System.out.println(""String_Node_Str"");
      }
      if (savefarm) {
        saveBlocks();
        savedelay=0;
      }
      try {
        wait();
      }
 catch (      InterruptedException e) {
      }
    }
    try {
      wait(10000);
    }
 catch (    InterruptedException e) {
    }
    Iterator<Entry<String,ClayDelay>> listing=newgravellist.entrySet().iterator();
    if (debug) {
      System.out.println(""String_Node_Str"" + newgravellist.size() + ""String_Node_Str"");
    }
    while (listing.hasNext()) {
      ClayDelay blockupdate=(ClayDelay)listing.next().getValue();
      boolean isloaded=blockupdate.getBlock().getWorld().isChunkLoaded(blockupdate.getBlock().getChunk());
      if (isloaded) {
        if (blockupdate.getBlock().getTypeId() == GRAVEL && (mcmmomode || blockupdate.getBlock().getRelative(BlockFace.DOWN).getTypeId() == activateblock)) {
          boolean alreadyupdated=false;
          if (waterenabled && lavaenabled) {
            if (hasBlockNextTo(blockupdate.getBlock(),FLOWINGWATER,WATER,FLOWINGLAVA,LAVA)) {
              blockupdate.upDelay(generator.nextInt(2));
              if (debug) {
                System.out.println(""String_Node_Str"" + blockupdate.getDelay());
              }
              alreadyupdated=true;
            }
          }
 else           if (waterenabled) {
            if (hasBlockNextTo(blockupdate.getBlock(),FLOWINGWATER,WATER)) {
              blockupdate.upDelay(generator.nextInt(2));
              if (debug) {
                System.out.println(""String_Node_Str"" + blockupdate.getDelay());
              }
              alreadyupdated=true;
            }
          }
 else           if (lavaenabled) {
            if (hasBlockNextTo(blockupdate.getBlock(),FLOWINGLAVA,LAVA)) {
              blockupdate.upDelay(generator.nextInt(2));
              if (debug) {
                System.out.println(""String_Node_Str"" + blockupdate.getDelay());
              }
              alreadyupdated=true;
            }
          }
          if (alreadyupdated == false) {
            if (debug) {
              System.out.println(""String_Node_Str"");
            }
            if (loadchunks) {
              removeBlockFromChunk(blockupdate.getBlock());
            }
            listing.remove();
          }
 else           if (blockupdate.getDelay() >= farmdelay || (blockupdate.getInTime() + (10000 * maxfarmdelay)) <= System.currentTimeMillis()) {
            if (loadchunks) {
              removeBlockFromChunk(blockupdate.getBlock());
            }
            listing.remove();
            int rand=generator.nextInt(10000);
            if (graveltoclaychance == 100.0) {
              doneblocks.add(blockupdate.getBlock());
              if (customdrops) {
                blockupdate.resetTimeIn();
                clayblocks.put(compileBlockString(blockupdate.getBlock()),blockupdate);
                saveClayBlocks();
              }
            }
 else             if (rand >= (10000.0 - (graveltoclaychance * 100.0))) {
              doneblocks.add(blockupdate.getBlock());
              if (customdrops) {
                blockupdate.resetTimeIn();
                clayblocks.put(compileBlockString(blockupdate.getBlock()),blockupdate);
                saveClayBlocks();
              }
            }
            if (debug) {
              System.out.println(""String_Node_Str"" + newgravellist.size() + ""String_Node_Str"");
            }
          }
        }
 else {
          if (loadchunks) {
            removeBlockFromChunk(blockupdate.getBlock());
          }
          listing.remove();
          if (debug) {
            System.out.println(""String_Node_Str"" + newgravellist.size() + ""String_Node_Str"");
          }
        }
      }
 else       if (loadchunks) {
        blockupdate.getBlock().getWorld().loadChunk(blockupdate.getBlock().getChunk());
      }
    }
    savedelay++;
    if (savefarm && savedelay >= 10) {
      saveBlocks();
      savedelay=0;
    }
  }
}",0.9203473945409428
180073,"public synchronized void onEnable(){
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_FROMTO,blockListener,Priority.Normal,this);
  if (clayfarm) {
    pm.registerEvent(Event.Type.BLOCK_PLACE,blockListener,Priority.Normal,this);
    loadBlocks();
    if (slowserver) {
      getServer().getScheduler().scheduleSyncRepeatingTask(this,new ClayUpdate(this),50L,25L);
    }
 else {
      getServer().getScheduler().scheduleSyncRepeatingTask(this,new ClayUpdate(this),200L,100L);
    }
    dispatchThread=new Thread(this);
    dispatchThread.start();
  }
  if (customdrops) {
    loadClayBlocks();
    pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,Priority.Normal,this);
    pm.registerEvent(Event.Type.BLOCK_PHYSICS,blockListener,Priority.Normal,this);
  }
 else   if (defaultclaydrop != 4 && defaultclaydrop > 0) {
    pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,Priority.Normal,this);
  }
  PluginDescriptionFile pdfFile=this.getDescription();
  System.out.println(pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
}","public synchronized void onEnable(){
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Event.Type.BLOCK_FROMTO,blockListener,Priority.Normal,this);
  if (clayfarm) {
    pm.registerEvent(Event.Type.BLOCK_PLACE,blockListener,Priority.Normal,this);
    loadBlocks();
    if (slowserver) {
      getServer().getScheduler().scheduleSyncRepeatingTask(this,new ClayUpdate(this),50L,25L);
    }
 else {
      getServer().getScheduler().scheduleSyncRepeatingTask(this,new ClayUpdate(this),200L,100L);
    }
    dispatchThread=new Thread(this);
    dispatchThread.start();
  }
  if (customdrops) {
    loadClayBlocks();
    pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,Priority.Normal,this);
    pm.registerEvent(Event.Type.BLOCK_PHYSICS,blockListener,Priority.Normal,this);
  }
 else   if (defaultclaydrop != 4 && defaultclaydrop > 0) {
    pm.registerEvent(Event.Type.BLOCK_BREAK,blockListener,Priority.Normal,this);
  }
  if (loadchunks) {
    ClaygenWorldListener cu=new ClaygenWorldListener(this);
    pm.registerEvent(Event.Type.CHUNK_UNLOAD,cu,Priority.Normal,this);
  }
  PluginDescriptionFile pdfFile=this.getDescription();
  System.out.println(pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
}",0.9342941924544298
180074,"public synchronized void gravelPlaced(Block thegravelblock){
  if (thegravelblock.getTypeId() == GRAVEL && (mcmmomode || thegravelblock.getRelative(BlockFace.DOWN).getTypeId() == activateblock)) {
    if (!newgravellist.containsKey(getBlockString(thegravelblock))) {
      boolean alreadyupdated=false;
      if (waterenabled) {
        if (hasBlockNextTo(thegravelblock,WATER,FLOWINGWATER)) {
          newgravellist.put(getBlockString(thegravelblock),new ClayDelay(thegravelblock));
          if (newgravellist.size() <= 1) {
            dispatchThread.interrupt();
          }
          alreadyupdated=true;
        }
      }
      if (lavaenabled && !alreadyupdated) {
        if (hasBlockNextTo(thegravelblock,LAVA,FLOWINGLAVA)) {
          newgravellist.put(getBlockString(thegravelblock),new ClayDelay(thegravelblock));
          if (newgravellist.size() <= 1) {
            dispatchThread.interrupt();
          }
        }
      }
    }
  }
}","public synchronized void gravelPlaced(Block thegravelblock){
  if (debug) {
    System.out.println(""String_Node_Str"");
  }
  if (thegravelblock.getTypeId() == GRAVEL && (mcmmomode || thegravelblock.getRelative(BlockFace.DOWN).getTypeId() == activateblock)) {
    if (!newgravellist.containsKey(getBlockString(thegravelblock))) {
      boolean alreadyupdated=false;
      if (waterenabled) {
        if (hasBlockNextTo(thegravelblock,WATER,FLOWINGWATER)) {
          if (loadchunks) {
            addBlockToChunk(thegravelblock);
          }
          newgravellist.put(getBlockString(thegravelblock),new ClayDelay(thegravelblock));
          if (newgravellist.size() <= 1) {
            dispatchThread.interrupt();
          }
          alreadyupdated=true;
        }
      }
      if (lavaenabled && !alreadyupdated) {
        if (hasBlockNextTo(thegravelblock,LAVA,FLOWINGLAVA)) {
          if (loadchunks) {
            addBlockToChunk(thegravelblock);
          }
          newgravellist.put(getBlockString(thegravelblock),new ClayDelay(thegravelblock));
          if (newgravellist.size() <= 1) {
            dispatchThread.interrupt();
          }
        }
      }
    }
  }
}",0.8912839737582006
180075,"private void saveBlocks(){
  LinkedList<SaveBlock> glocations=new LinkedList<SaveBlock>();
  Enumeration<ClayDelay> gravellist=newgravellist.elements();
  while (gravellist.hasMoreElements()) {
    glocations.add(new SaveBlock(gravellist.nextElement()));
  }
  try {
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(new File(blockSaveFile)));
    out.writeObject(glocations);
    out.flush();
    out.close();
  }
 catch (  Exception e) {
    if (debug) {
      System.out.println(""String_Node_Str"");
      System.out.println(e);
    }
  }
}","private void saveBlocks(){
  if (debug) {
    System.out.println(""String_Node_Str"");
  }
  LinkedList<SaveBlock> glocations=new LinkedList<SaveBlock>();
  Enumeration<ClayDelay> gravellist=newgravellist.elements();
  while (gravellist.hasMoreElements()) {
    glocations.add(new SaveBlock(gravellist.nextElement()));
  }
  try {
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(new File(blockSaveFile)));
    out.writeObject(glocations);
    out.flush();
    out.close();
  }
 catch (  Exception e) {
    if (debug) {
      System.out.println(""String_Node_Str"");
      System.out.println(e);
    }
  }
}",0.9478114478114478
180076,"public synchronized void convertBlocks(Block thewaterblock){
  int waterid=thewaterblock.getTypeId();
  if ((waterenabled && (waterid == 8 || waterid == 9)) || (lavaenabled && (waterid == 10 || waterid == 11))) {
    Block thegravelblocks[]={thewaterblock.getRelative(BlockFace.DOWN),thewaterblock.getRelative(BlockFace.NORTH),thewaterblock.getRelative(BlockFace.SOUTH),thewaterblock.getRelative(BlockFace.EAST),thewaterblock.getRelative(BlockFace.WEST)};
    if (debug) {
      System.out.println(""String_Node_Str"");
    }
    for (int i=0; i < thegravelblocks.length; i++) {
      if (thegravelblocks[i].getTypeId() == GRAVEL) {
        if (debug) {
          System.out.println(""String_Node_Str"");
        }
        if (mcmmomode || getActivationBlock() == thegravelblocks[i].getRelative(BlockFace.DOWN).getTypeId()) {
          if (debug) {
            System.out.println(""String_Node_Str"");
          }
          if (clayfarm) {
            if (!newgravellist.containsKey(getBlockString(thegravelblocks[i]))) {
              newgravellist.put(getBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
              if (newgravellist.size() <= 1) {
                dispatchThread.interrupt();
              }
            }
          }
 else {
            int rand=generator.nextInt(10000);
            if (graveltoclaychance == 100.0) {
              thegravelblocks[i].setTypeId(CLAY);
              if (customdrops) {
                clayblocks.put(compileBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
                saveClayBlocks();
              }
            }
 else             if (rand >= (10000.0 - (graveltoclaychance * 25.0))) {
              if (waterenabled && lavaenabled) {
                thegravelblocks[i].setTypeId(CLAY);
                if (customdrops) {
                  clayblocks.put(compileBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
                  saveClayBlocks();
                }
              }
 else               if (waterenabled) {
                thegravelblocks[i].setTypeId(CLAY);
                if (customdrops) {
                  clayblocks.put(compileBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
                  saveClayBlocks();
                }
              }
 else               if (lavaenabled) {
                thegravelblocks[i].setTypeId(CLAY);
                if (customdrops) {
                  clayblocks.put(compileBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
                  saveClayBlocks();
                }
              }
            }
          }
        }
      }
    }
  }
}","public synchronized void convertBlocks(Block thewaterblock){
  int waterid=thewaterblock.getTypeId();
  if ((waterenabled && (waterid == 8 || waterid == 9)) || (lavaenabled && (waterid == 10 || waterid == 11))) {
    Block thegravelblocks[]={thewaterblock.getRelative(BlockFace.DOWN),thewaterblock.getRelative(BlockFace.NORTH),thewaterblock.getRelative(BlockFace.SOUTH),thewaterblock.getRelative(BlockFace.EAST),thewaterblock.getRelative(BlockFace.WEST)};
    if (debug) {
      System.out.println(""String_Node_Str"");
    }
    for (int i=0; i < thegravelblocks.length; i++) {
      if (thegravelblocks[i].getTypeId() == GRAVEL) {
        if (debug) {
          System.out.println(""String_Node_Str"");
        }
        if (mcmmomode || getActivationBlock() == thegravelblocks[i].getRelative(BlockFace.DOWN).getTypeId()) {
          if (debug) {
            System.out.println(""String_Node_Str"");
          }
          if (clayfarm) {
            if (!newgravellist.containsKey(getBlockString(thegravelblocks[i]))) {
              if (loadchunks) {
                addBlockToChunk(thegravelblocks[i]);
              }
              newgravellist.put(getBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
              if (newgravellist.size() <= 1) {
                dispatchThread.interrupt();
              }
            }
          }
 else {
            int rand=generator.nextInt(10000);
            if (graveltoclaychance == 100.0) {
              thegravelblocks[i].setTypeId(CLAY);
              if (customdrops) {
                clayblocks.put(compileBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
                saveClayBlocks();
              }
            }
 else             if (rand >= (10000.0 - (graveltoclaychance * 25.0))) {
              if (waterenabled && lavaenabled) {
                thegravelblocks[i].setTypeId(CLAY);
                if (customdrops) {
                  clayblocks.put(compileBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
                  saveClayBlocks();
                }
              }
 else               if (waterenabled) {
                thegravelblocks[i].setTypeId(CLAY);
                if (customdrops) {
                  clayblocks.put(compileBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
                  saveClayBlocks();
                }
              }
 else               if (lavaenabled) {
                thegravelblocks[i].setTypeId(CLAY);
                if (customdrops) {
                  clayblocks.put(compileBlockString(thegravelblocks[i]),new ClayDelay(thegravelblocks[i]));
                  saveClayBlocks();
                }
              }
            }
          }
        }
      }
    }
  }
}",0.9813549935388592
180077,"public void clayWaterRemoved(Block block){
  if (clayblocks.containsKey(compileBlockString(block))) {
    ClayDelay theblock=clayblocks.get(compileBlockString(block));
    try {
      block.setData((byte)getNumberOfDrops(theblock));
    }
 catch (    StackOverflowError e) {
    }
    clayblocks.remove(compileBlockString(block));
    saveClayBlocks();
  }
}","public void clayWaterRemoved(Block block){
  if (clayblocks.containsKey(compileBlockString(block))) {
    ClayDelay theblock=clayblocks.get(compileBlockString(block));
    try {
      clayblocks.remove(compileBlockString(block));
      block.setData((byte)getNumberOfDrops(theblock));
    }
 catch (    StackOverflowError e) {
    }
    saveClayBlocks();
  }
}",0.8161559888579387
180078,"/** 
 * @param args
 */
public static void main(String[] args){
  SudokuPuzzle puzzle=new SudokuPuzzle(""String_Node_Str"");
  puzzle.printPuzzle();
  long start=System.currentTimeMillis();
  puzzle.solve();
  long stop=System.currentTimeMillis();
  puzzle.printPuzzle();
  System.out.println((stop - start) + ""String_Node_Str"");
}","/** 
 * @param args
 */
public static void main(String[] args){
  SudokuPuzzle puzzle=new SudokuPuzzle(""String_Node_Str"");
  puzzle.printPuzzle();
  long start=System.currentTimeMillis();
  puzzle.solve();
  puzzle.checkRowsCols();
  long stop=System.currentTimeMillis();
  puzzle.printPuzzle();
  System.out.println((stop - start) + ""String_Node_Str"");
}",0.9619883040935672
180079,"/** 
 * Row and Column Checker collect any hints that is not shared by any other. if hint is not shared by any other, it is the answer/Value for its owner.
 */
public void RCChecker(Cell[] col){
  int[] hintCounter=new int[9];
  Cell[] owner=new Cell[9];
  for (int i=0; i < 9; i++) {
    if (col[i].getValue() > 0)     continue;
    ArrayList<Integer> hints=col[i].getHints();
    for (int j=0; j < hints.size(); j++) {
      int hintVal=hints.get(j) - 1;
      if (owner[hintVal] == null)       owner[hintVal]=col[i];
      hintCounter[hintVal]++;
    }
  }
  for (int i=0; i < 9; i++) {
    if (hintCounter[i] == 1) {
      owner[i].setValue(i);
      System.out.println(col[i].toString());
    }
  }
}","/** 
 * Row and Column Checker collect any hints that is not shared by any other. if hint is not shared by any other, it is the answer/Value for its owner.
 */
public void RCChecker(Cell[] col){
  int[] hintCounter=new int[9];
  Cell[] owner=new Cell[9];
  for (int i=0; i < 9; i++) {
    if (col[i].getValue() > 0)     continue;
    ArrayList<Integer> hints=col[i].getHints();
    for (int j=0; j < hints.size(); j++) {
      int hintVal=hints.get(j) - 1;
      if (owner[hintVal] == null)       owner[hintVal]=col[i];
      hintCounter[hintVal]++;
    }
  }
  for (int i=0; i < 9; i++) {
    if (hintCounter[i] == 1) {
      owner[i].setValue(i + 1);
      System.out.println(col[i].toString());
    }
  }
}",0.9971711456859972
180080,"/** 
 * Function to get the specified row
 * @param row
 * @return
 */
public Cell[] getRow(int row){
  return _puzzle[row];
}","/** 
 * Function to get the specified row
 * @param row
 * @return
 */
public Cell[] getRow(int row){
  Cell[] r=new Cell[9];
  for (int x=0; x < 9; x++) {
    r[x]=_puzzle[row][x];
  }
  return r;
}",0.7569230769230769
180081,"public String toString(){
  return ""String_Node_Str"" + this.x + ""String_Node_Str""+ this.y+ ""String_Node_Str""+ this.value;
}","/** 
 * @return String representation of the Cell
 */
public String toString(){
  return ""String_Node_Str"" + this.x + ""String_Node_Str""+ this.y+ ""String_Node_Str""+ this.value;
}",0.82
180082,"void RCChecker(Cell[] col){
}","void RCChecker(Cell[] col){
  int[] hintCounter=new int[9];
  Cell[] owner=new Cell[9];
  for (int i=0; i < 9; i++) {
    if (col[i].getValue() > 0)     continue;
    ArrayList<Integer> hints=col[i].getHints();
    for (int j=0; j < hints.size(); j++) {
      int hintVal=hints.get(j) - 1;
      if (owner[hintVal] == null)       owner[hintVal]=col[i];
      hintCounter[hintVal]++;
    }
  }
  for (int i=0; i < 9; i++) {
    if (hintCounter[i] == 1) {
      owner[i].setValue(i);
      System.out.println(col[i].toString());
    }
  }
}",0.1022927689594356
180083,"private String levelString(int level){
switch (level) {
case LogService.LOG_DEBUG:
    return ""String_Node_Str"";
case LogService.LOG_ERROR:
  return ""String_Node_Str"";
case LogService.LOG_INFO:
return ""String_Node_Str"";
case LogService.LOG_WARNING:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}","/** 
 * Convert the log level int into a human-readable string.  See org.osgi.service.log.LogService for details.
 * @param level log level
 * @return human-readable string
 */
private String levelString(int level){
switch (level) {
case LogService.LOG_DEBUG:
    return ""String_Node_Str"";
case LogService.LOG_ERROR:
  return ""String_Node_Str"";
case LogService.LOG_INFO:
return ""String_Node_Str"";
case LogService.LOG_WARNING:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}",0.7801242236024845
180084,"/** 
 * @param context if context is null, it will return a log service that uses stdout.
 * @return Either the first LogService available in the runtime if availableor a SysoutLogService.
 */
public static LogService getLogService(BundleContext context){
  final LogService logService;
  boolean created=false;
  ServiceReference sr=null;
  if (context != null)   sr=context.getServiceReference(LogService.class.getName());
  if (sr != null) {
    logService=(LogService)context.getService(sr);
  }
 else {
    logService=new LogService(){
      public void log(      int level,      String message){
        System.out.println(levelString(level) + message);
      }
      public void log(      int level,      String message,      Throwable exception){
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        }
        exception.printStackTrace(new PrintWriter(System.out,true));
      }
      public void log(      ServiceReference sr,      int level,      String message){
        if (message == null)         message=""String_Node_Str"";
        System.out.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        }
      }
      public void log(      ServiceReference sr,      int level,      String message,      Throwable exception){
        if (exception == null) {
          log(sr,level,message);
          return;
        }
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        exception.printStackTrace(new PrintWriter(System.out,true));
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
          exception.printStackTrace(new PrintWriter(System.err,true));
        }
      }
      private String levelString(      int level){
switch (level) {
case LogService.LOG_DEBUG:
          return ""String_Node_Str"";
case LogService.LOG_ERROR:
        return ""String_Node_Str"";
case LogService.LOG_INFO:
      return ""String_Node_Str"";
case LogService.LOG_WARNING:
    return ""String_Node_Str"";
default :
  return ""String_Node_Str"";
}
}
}
;
created=true;
}
if (created && context != null) {
context.registerService(LogService.class.getName(),logService,null);
}
return logService;
}","/** 
 * @param context if context is null, it will return a log service that uses stdout.
 * @return Either the first LogService available in the runtime if availableor a SysoutLogService.
 */
public static LogService getLogService(BundleContext context){
  final LogService logService;
  boolean created=false;
  ServiceReference sr=null;
  if (context != null)   sr=context.getServiceReference(LogService.class.getName());
  if (sr != null) {
    logService=(LogService)context.getService(sr);
  }
 else {
    logService=new LogService(){
      public void log(      int level,      String message){
        System.out.println(levelString(level) + message);
      }
      public void log(      int level,      String message,      Throwable exception){
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        }
        exception.printStackTrace(new PrintWriter(System.out,true));
      }
      public void log(      ServiceReference sr,      int level,      String message){
        if (sr == null) {
          log(level,message);
          return;
        }
        if (message == null)         message=""String_Node_Str"";
        System.out.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        }
      }
      public void log(      ServiceReference sr,      int level,      String message,      Throwable exception){
        if (exception == null) {
          log(sr,level,message);
          return;
        }
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        exception.printStackTrace(new PrintWriter(System.out,true));
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
          exception.printStackTrace(new PrintWriter(System.err,true));
        }
      }
      /** 
 * Convert the log level int into a human-readable string.  See org.osgi.service.log.LogService for details.
 * @param level log level
 * @return human-readable string
 */
      private String levelString(      int level){
switch (level) {
case LogService.LOG_DEBUG:
          return ""String_Node_Str"";
case LogService.LOG_ERROR:
        return ""String_Node_Str"";
case LogService.LOG_INFO:
      return ""String_Node_Str"";
case LogService.LOG_WARNING:
    return ""String_Node_Str"";
default :
  return ""String_Node_Str"";
}
}
}
;
created=true;
}
if (created && context != null) {
context.registerService(LogService.class.getName(),logService,null);
}
return logService;
}",0.9518137520303196
180085,"private String parseChecksum(String sentence){
  String[] splitSentence=sentence.split(CHECKSUM_SEPARATOR);
  if (splitSentence.length > 1) {
    checksum=splitSentence[1];
  }
  return splitSentence[0];
}","private String parseChecksum(String sentence){
  String[] splitSentence=sentence.split(""String_Node_Str"" + CHECKSUM_SEPARATOR);
  if (splitSentence.length > 1) {
    checksum=splitSentence[1];
  }
  return splitSentence[0];
}",0.9534883720930232
180086,"/** 
 * Does a multipart post which is different than a regular post mostly use this one if you're posting files
 * @param url
 * @param parameters Key-Value pairs in map.  Keys are always string.  Values can be string or IFormFile
 * @param properties
 * @return
 */
public HTTPResponse postMultipart(String url,Map<String,String> parameters) throws IOException {
  HttpURLConnection conn=getAndConfigureConnection(url);
  conn.setRequestMethod(""String_Node_Str"");
  String boundary=createMultipartBoundary();
  conn.setRequestProperty(HEADER_TYPE,CONTENT_TYPE + ""String_Node_Str"" + BOUNDARY+ boundary);
  conn.setDoOutput(true);
  if (debugMode)   debugMessage(""String_Node_Str"",url,conn);
  OutputStream os=conn.getOutputStream();
  Object[] elems=parameters.keySet().toArray();
  StringBuffer buf;
  IFormFile file;
  for (int i=0; i < elems.length; i++) {
    String key=(String)elems[i];
    Object obj=parameters.get(key);
    buf=new StringBuffer();
    if (obj instanceof IFormFile) {
      file=(IFormFile)obj;
      buf.append(""String_Node_Str"" + boundary + LINE_ENDING);
      buf.append(HEADER_PARA);
      buf.append(""String_Node_Str"" + PARA_NAME + ""String_Node_Str""+ key+ ""String_Node_Str"");
      buf.append(""String_Node_Str"" + FILE_NAME + ""String_Node_Str""+ file.getFilename()+ ""String_Node_Str""+ LINE_ENDING);
      buf.append(HEADER_TYPE + ""String_Node_Str"" + file.getContentType()+ ""String_Node_Str"");
      buf.append(LINE_ENDING);
      buf.append(LINE_ENDING);
      os.write(buf.toString().getBytes());
      os.write(file.getBytes());
    }
 else     if (obj != null) {
      buf.append(""String_Node_Str"" + boundary + LINE_ENDING);
      buf.append(HEADER_PARA);
      buf.append(""String_Node_Str"" + PARA_NAME + ""String_Node_Str""+ key+ ""String_Node_Str"");
      buf.append(LINE_ENDING);
      buf.append(LINE_ENDING);
      buf.append(obj.toString());
      os.write(buf.toString().getBytes());
    }
    os.write(LINE_ENDING.getBytes());
  }
  os.write((""String_Node_Str"" + boundary + ""String_Node_Str""+ LINE_ENDING).getBytes());
  return connect(conn);
}","/** 
 * Does a multipart post which is different than a regular post mostly use this one if you're posting files
 * @param url
 * @param parameters Key-Value pairs in map.  Keys are always string.  Values can be string or IFormFile
 * @param properties
 * @return
 */
public HTTPResponse postMultipart(String url,Map<String,Object> parameters) throws IOException {
  HttpURLConnection conn=getAndConfigureConnection(url);
  conn.setRequestMethod(""String_Node_Str"");
  String boundary=createMultipartBoundary();
  conn.setRequestProperty(HEADER_TYPE,CONTENT_TYPE + ""String_Node_Str"" + BOUNDARY+ boundary);
  conn.setDoOutput(true);
  if (debugMode)   debugMessage(""String_Node_Str"",url,conn);
  OutputStream os=conn.getOutputStream();
  Object[] elems=parameters.keySet().toArray();
  StringBuffer buf;
  IFormFile file;
  for (int i=0; i < elems.length; i++) {
    String key=(String)elems[i];
    Object obj=parameters.get(key);
    buf=new StringBuffer();
    if (obj instanceof IFormFile) {
      file=(IFormFile)obj;
      buf.append(""String_Node_Str"" + boundary + LINE_ENDING);
      buf.append(HEADER_PARA);
      buf.append(""String_Node_Str"" + PARA_NAME + ""String_Node_Str""+ key+ ""String_Node_Str"");
      buf.append(""String_Node_Str"" + FILE_NAME + ""String_Node_Str""+ file.getFilename()+ ""String_Node_Str""+ LINE_ENDING);
      buf.append(HEADER_TYPE + ""String_Node_Str"" + file.getContentType()+ ""String_Node_Str"");
      buf.append(LINE_ENDING);
      buf.append(LINE_ENDING);
      os.write(buf.toString().getBytes());
      os.write(file.getBytes());
    }
 else     if (obj != null) {
      buf.append(""String_Node_Str"" + boundary + LINE_ENDING);
      buf.append(HEADER_PARA);
      buf.append(""String_Node_Str"" + PARA_NAME + ""String_Node_Str""+ key+ ""String_Node_Str"");
      buf.append(LINE_ENDING);
      buf.append(LINE_ENDING);
      buf.append(obj.toString());
      os.write(buf.toString().getBytes());
    }
    os.write(LINE_ENDING.getBytes());
  }
  os.write((""String_Node_Str"" + boundary + ""String_Node_Str""+ LINE_ENDING).getBytes());
  return connect(conn);
}",0.9971167707832772
180087,"public int LEDGreenOff() throws IOException {
  int result=-1;
  if (gpsControl != null) {
    result=gpsControl.ioctl_BMI_GPS_GLEDOFF();
  }
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  return result;
}","/** 
 * @return
 * @throws IOException
 */
public int LEDGreenOff() throws IOException {
  int result=-1;
  if (gpsControl != null) {
    result=gpsControl.ioctl_BMI_GPS_GLEDOFF();
  }
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  return result;
}",0.9145129224652088
180088,"public int LEDRedOn() throws IOException {
  int result=-1;
  if (gpsControl != null) {
    result=gpsControl.ioctl_BMI_GPS_RLEDON();
  }
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  return result;
}","/** 
 * @return
 * @throws IOException
 */
public int LEDRedOn() throws IOException {
  int result=-1;
  if (gpsControl != null) {
    result=gpsControl.ioctl_BMI_GPS_RLEDON();
  }
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  return result;
}",0.9131313131313132
180089,"public List<IModuleProperty> getModuleProperties(){
  List<IModuleProperty> mprops=super.getModuleProperties();
  try {
    int status=getStatus();
    status&=0xFF;
    String status_str=Integer.toHexString(status);
    mprops.add(new ModuleProperty(PROPERTY_IOX,""String_Node_Str"" + status_str,""String_Node_Str"",false));
    mprops.add(new ModuleProperty(PROPERTY_GPS_FIX,Boolean.toString((status&=0x1) == 0)));
    String antenna=PROPERTY_ANTENNA_ACTIVE;
    if ((status & 0xC0) == IGPSModuleControl.STATUS_PASSIVE_ANTENNA) {
      antenna=PROPERTY_ANTENNA_PASSIVE;
    }
    mprops.add(new ModuleProperty(PROPERTY_ANTENNA,antenna,""String_Node_Str"",false));
  }
 catch (  IOException e) {
    getLog().log(LogService.LOG_ERROR,""String_Node_Str"",e);
  }
  return mprops;
}","public List<IModuleProperty> getModuleProperties(){
  List<IModuleProperty> mprops=super.getModuleProperties();
  try {
    int status=getStatus();
    status&=0xFF;
    String statusValue=Integer.toHexString(status);
    mprops.add(new ModuleProperty(PROPERTY_IOX,""String_Node_Str"" + statusValue,""String_Node_Str"",false));
    mprops.add(new ModuleProperty(PROPERTY_GPS_FIX,Boolean.toString((status&=0x1) == 0)));
    String antenna=PROPERTY_ANTENNA_ACTIVE;
    if ((status & 0xC0) == IGPSModuleControl.STATUS_PASSIVE_ANTENNA) {
      antenna=PROPERTY_ANTENNA_PASSIVE;
    }
    mprops.add(new ModuleProperty(PROPERTY_ANTENNA,antenna,""String_Node_Str"",false));
  }
 catch (  IOException e) {
    getLog().log(LogService.LOG_ERROR,""String_Node_Str"",e);
  }
  return mprops;
}",0.9883720930232558
180090,"private boolean isAntennaExternal() throws IOException {
  return (getStatus() & 0xC0) == 0x40;
}","/** 
 * @return true if antenna mode is 'external', false otherwise.
 * @throws IOException on device I/O error
 */
private boolean isAntennaExternal() throws IOException {
  return (getStatus() & 0xC0) == 0x40;
}",0.3935483870967742
180091,"private void updateIModuleControlProperties(){
  if (moduleReg != null) {
    Dictionary modProperties=createBasicServiceProperties();
    modProperties.put(""String_Node_Str"",suspended ? ""String_Node_Str"" : ""String_Node_Str"");
    moduleReg.setProperties(modProperties);
  }
}","/** 
 * Update module properties based on internal state.
 */
private void updateIModuleControlProperties(){
  if (moduleReg != null) {
    Dictionary modProperties=createBasicServiceProperties();
    modProperties.put(""String_Node_Str"",suspended ? ""String_Node_Str"" : ""String_Node_Str"");
    moduleReg.setProperties(modProperties);
  }
}",0.8990228013029316
180092,"private String getPositionXml(){
  Position p=getPosition();
  XmlNode root=new XmlNode(""String_Node_Str"");
  if (p != null) {
    if (p.getLatitude() != null) {
      root.addChild(new XmlNode(""String_Node_Str"",p.getLatitude().toString()));
    }
    if (p.getLongitude() != null) {
      root.addChild(new XmlNode(""String_Node_Str"",p.getLongitude().toString()));
    }
    if (p.getAltitude() != null) {
      root.addChild(new XmlNode(""String_Node_Str"",p.getAltitude().toString()));
    }
    RMC rmc=nmeaProvider.getLastRMC();
    DegreesMinutesSeconds dmsLat=rmc.getLatitudeAsDMS();
    DegreesMinutesSeconds dmsLon=rmc.getLongitudeAsDMS();
    if (dmsLat != null) {
      root.addChild(new XmlNode(""String_Node_Str"",Double.toString(dmsLat.toDecimalDegrees())));
    }
    if (dmsLon != null) {
      root.addChild(new XmlNode(""String_Node_Str"",Double.toString(dmsLon.toDecimalDegrees())));
    }
  }
  return root.toString();
}","/** 
 * @return a String containing the location retrieved from GPS device in XML format.
 */
private String getPositionXml(){
  Position p=getPosition();
  XmlNode root=new XmlNode(""String_Node_Str"");
  if (p != null) {
    if (p.getLatitude() != null) {
      root.addChild(new XmlNode(""String_Node_Str"",p.getLatitude().toString()));
    }
    if (p.getLongitude() != null) {
      root.addChild(new XmlNode(""String_Node_Str"",p.getLongitude().toString()));
    }
    if (p.getAltitude() != null) {
      root.addChild(new XmlNode(""String_Node_Str"",p.getAltitude().toString()));
    }
    RMC rmc=nmeaProvider.getLastRMC();
    DegreesMinutesSeconds dmsLat=rmc.getLatitudeAsDMS();
    DegreesMinutesSeconds dmsLon=rmc.getLongitudeAsDMS();
    if (dmsLat != null) {
      root.addChild(new XmlNode(""String_Node_Str"",Double.toString(dmsLat.toDecimalDegrees())));
    }
    if (dmsLon != null) {
      root.addChild(new XmlNode(""String_Node_Str"",Double.toString(dmsLon.toDecimalDegrees())));
    }
  }
  return root.toString();
}",0.9520408163265306
180093,"private Dictionary createBasicServiceProperties(){
  Dictionary d=getCommonProperties();
  try {
    d.remove(EXTERNAL_ANTENNA_PROPERTY);
    d.put(EXTERNAL_ANTENNA_PROPERTY,""String_Node_Str"" + isAntennaExternal());
  }
 catch (  IOException e) {
    getLog().log(LogService.LOG_ERROR,""String_Node_Str"",e);
  }
  return d;
}","/** 
 * @return A dictionary of properties for the OSGi service registry.
 */
private Dictionary createBasicServiceProperties(){
  Dictionary d=getCommonProperties();
  try {
    d.remove(EXTERNAL_ANTENNA_PROPERTY);
    d.put(EXTERNAL_ANTENNA_PROPERTY,""String_Node_Str"" + isAntennaExternal());
  }
 catch (  IOException e) {
    getLog().log(LogService.LOG_ERROR,""String_Node_Str"",e);
  }
  return d;
}",0.8925619834710744
180094,"public int resume() throws IOException {
  int result=-1;
  result=gpsControl.ioctl_BMI_GPS_RESUME();
  suspended=false;
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  suspended=false;
  updateIModuleControlProperties();
  return result;
}","public int resume() throws IOException {
  getBMIDevice().resume();
  suspended=false;
  updateIModuleControlProperties();
  return 0;
}",0.6
180095,"public int suspend() throws IOException {
  int result=-1;
  result=gpsControl.ioctl_BMI_GPS_SUSPEND();
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  suspended=true;
  updateIModuleControlProperties();
  return result;
}","public int suspend() throws IOException {
  getBMIDevice().suspend();
  suspended=true;
  updateIModuleControlProperties();
  return 0;
}",0.6214099216710183
180096,"public int LEDGreenOn() throws IOException {
  int result=-1;
  if (gpsControl != null) {
    result=gpsControl.ioctl_BMI_GPS_GLEDON();
  }
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  return result;
}","/** 
 * @return
 * @throws IOException
 */
public int LEDGreenOn() throws IOException {
  int result=-1;
  if (gpsControl != null) {
    result=gpsControl.ioctl_BMI_GPS_GLEDON();
  }
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  return result;
}",0.9138276553106212
180097,"public void start() throws Exception {
  boolean retry=false;
  int count=0;
  do {
    getLog().log(LogService.LOG_INFO,""String_Node_Str"");
    try {
      setActiveAntenna();
      retry=false;
    }
 catch (    IOException e) {
      getLog().log(LogService.LOG_ERROR,""String_Node_Str"",e);
      retry=true;
      Thread.sleep(200);
      count++;
    }
  }
 while (retry && count < 10);
  nmeaProvider.start();
  Dictionary properties=createBasicServiceProperties();
  properties.put(""String_Node_Str"",suspended ? ""String_Node_Str"" : ""String_Node_Str"");
  moduleReg=context.registerService(IModuleControl.class.getName(),this,properties);
  registerService(IModuleLEDController.class.getName(),this,createBasicServiceProperties());
  registerService(IGPSModuleControl.class.getName(),this,createBasicServiceProperties());
  registerService(INMEARawFeed.class.getName(),new NMEARawFeed(gpsInputStream),createBasicServiceProperties());
  registerService(INMEASentenceProvider.class.getName(),nmeaProvider,createBasicServiceProperties());
  registerService(PublicWSProvider.class.getName(),this,null);
  timer=new Timer();
  timer.schedule(new GPSFIXLEDStatusTask(this,getLog()),500,GPS_STATUS_SCAN_INTERVAL);
  registerService(IPositionProvider.class.getName(),this,createBasicServiceProperties());
  context.addServiceListener(nmeaProvider,FilterUtil.generateServiceFilter(INMEASentenceSubscriber.class.getName(),IPositionSubscriber.class.getName()));
}","public void start() throws Exception {
  boolean retry=false;
  int count=0;
  do {
    getLog().log(LogService.LOG_INFO,""String_Node_Str"");
    try {
      setActiveAntenna();
      retry=false;
    }
 catch (    IOException e) {
      getLog().log(LogService.LOG_ERROR,""String_Node_Str"",e);
      retry=true;
      Thread.sleep(ANTENNA_SET_RETRY_INTERVAL_MILLIS);
      count++;
    }
  }
 while (retry && count < GPS_SET_ANTENNA_MAX_RETRIES);
  nmeaProvider.start();
  Dictionary properties=createBasicServiceProperties();
  properties.put(""String_Node_Str"",suspended ? ""String_Node_Str"" : ""String_Node_Str"");
  moduleReg=context.registerService(IModuleControl.class.getName(),this,properties);
  registerService(IModuleLEDController.class.getName(),this,createBasicServiceProperties());
  registerService(IGPSModuleControl.class.getName(),this,createBasicServiceProperties());
  registerService(INMEARawFeed.class.getName(),new NMEARawFeed(gpsInputStream),createBasicServiceProperties());
  registerService(INMEASentenceProvider.class.getName(),nmeaProvider,createBasicServiceProperties());
  registerService(PublicWSProvider.class.getName(),this,null);
  timer=new Timer();
  timer.schedule(new GPSFIXLEDStatusTask(this,getLog()),GPS_STATUS_SCAN_INTERVAL,GPS_STATUS_SCAN_INTERVAL);
  registerService(IPositionProvider.class.getName(),this,createBasicServiceProperties());
  context.addServiceListener(nmeaProvider,FilterUtil.generateServiceFilter(INMEASentenceSubscriber.class.getName(),IPositionSubscriber.class.getName()));
}",0.9685408299866132
180098,"public int LEDRedOff() throws IOException {
  int result=-1;
  if (gpsControl != null) {
    result=gpsControl.ioctl_BMI_GPS_RLEDOFF();
  }
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  return result;
}","/** 
 * @return
 * @throws IOException
 */
public int LEDRedOff() throws IOException {
  int result=-1;
  if (gpsControl != null) {
    result=gpsControl.ioctl_BMI_GPS_RLEDOFF();
  }
  if (result < 0) {
    throw new IOException(""String_Node_Str"");
  }
  return result;
}",0.9138276553106212
180099,"@Override public void run(Map<Object,Object> services){
  LogManager.logInfo(""String_Node_Str"");
  service=(ISewingService)services.get(ISewingService.class.getName());
  mainServlet=new BUGwebAdminServlet();
  hardwareServlet=new BUGwebAdminHardwareServlet();
  systemServlet=new BUGwebAdminSystemServlet();
  softwareServlet=new BUGwebAdminSoftwareServlet();
  bugnetServlet=new BUGwebAdminBUGnetServlet();
  utilsServlet=new BUGwebAdminUtilsServlet();
  imageServlet=new BUGwebFileServlet();
  service.register(context,""String_Node_Str"",mainServlet);
  service.register(context,""String_Node_Str"",hardwareServlet);
  service.register(context,""String_Node_Str"",systemServlet);
  service.register(context,""String_Node_Str"",softwareServlet);
  service.register(context,""String_Node_Str"",bugnetServlet);
  service.register(context,""String_Node_Str"",utilsServlet);
  service.register(context,""String_Node_Str"",imageServlet);
  try {
    moduleTracker=new ServiceTracker(context,FilterUtil.generateServiceFilter(context,new String[]{IModuleControl.class.getName()}),new BUGwebAdminModuleControlServiceTracker(context));
    moduleTracker.open();
  }
 catch (  InvalidSyntaxException e) {
  }
}","@Override public void run(Map<String,Object> services){
  LogManager.logInfo(""String_Node_Str"");
  service=(ISewingService)services.get(ISewingService.class.getName());
  mainServlet=new BUGwebAdminServlet();
  hardwareServlet=new BUGwebAdminHardwareServlet();
  systemServlet=new BUGwebAdminSystemServlet();
  softwareServlet=new BUGwebAdminSoftwareServlet();
  bugnetServlet=new BUGwebAdminBUGnetServlet();
  utilsServlet=new BUGwebAdminUtilsServlet();
  imageServlet=new BUGwebFileServlet();
  service.register(context,""String_Node_Str"",mainServlet);
  service.register(context,""String_Node_Str"",hardwareServlet);
  service.register(context,""String_Node_Str"",systemServlet);
  service.register(context,""String_Node_Str"",softwareServlet);
  service.register(context,""String_Node_Str"",bugnetServlet);
  service.register(context,""String_Node_Str"",utilsServlet);
  service.register(context,""String_Node_Str"",imageServlet);
  try {
    moduleTracker=new ServiceTracker(context,FilterUtil.generateServiceFilter(context,new String[]{IModuleControl.class.getName()}),new BUGwebAdminModuleControlServiceTracker(context));
    moduleTracker.open();
  }
 catch (  InvalidSyntaxException e) {
  }
}",0.9949537426408748
180100,"@Override public void run(Map<Object,Object> services){
  display=(IModuleDisplay)services.get(IModuleDisplay.class.getName());
  networking=(INetworking)services.get(INetworking.class.getName());
  wifiAccessPointPicker=new WifiAccessPointPicker(networking,context);
  networkSettingsEditor=new NetworkSettingsEditor(networking,context);
  deviceActivator=new DeviceActivator(networking,context);
  registerDesktopApp();
}","@Override public void run(Map<String,Object> services){
  display=(IModuleDisplay)services.get(IModuleDisplay.class.getName());
  networking=(INetworking)services.get(INetworking.class.getName());
  wifiAccessPointPicker=new WifiAccessPointPicker(networking,context);
  networkSettingsEditor=new NetworkSettingsEditor(networking,context);
  deviceActivator=new DeviceActivator(networking,context);
  registerDesktopApp();
}",0.9858156028368794
180101,"public void start(BundleContext ctx) throws Exception {
  this.context=ctx;
  logger=LogServiceUtil.getLogService(context);
  Activator.logDebug(""String_Node_Str"");
  serviceTracker=ServiceTrackerUtil.openServiceTracker(context,new ServiceTrackerUtil.ManagedInlineRunnable(){
    @Override public void run(    Map<Object,Object> services){
      display=(IModuleDisplay)services.get(IModuleDisplay.class.getName());
      networking=(INetworking)services.get(INetworking.class.getName());
      wifiAccessPointPicker=new WifiAccessPointPicker(networking,context);
      networkSettingsEditor=new NetworkSettingsEditor(networking,context);
      deviceActivator=new DeviceActivator(networking,context);
      registerDesktopApp();
    }
    @Override public void shutdown(){
      unregisterDesktopApp();
    }
  }
,services);
}","public void start(BundleContext ctx) throws Exception {
  this.context=ctx;
  logger=LogServiceUtil.getLogService(context);
  Activator.logDebug(""String_Node_Str"");
  serviceTracker=ServiceTrackerUtil.openServiceTracker(context,new ServiceTrackerUtil.ManagedInlineRunnable(){
    @Override public void run(    Map<String,Object> services){
      display=(IModuleDisplay)services.get(IModuleDisplay.class.getName());
      networking=(INetworking)services.get(INetworking.class.getName());
      wifiAccessPointPicker=new WifiAccessPointPicker(networking,context);
      networkSettingsEditor=new NetworkSettingsEditor(networking,context);
      deviceActivator=new DeviceActivator(networking,context);
      registerDesktopApp();
    }
    @Override public void shutdown(){
      unregisterDesktopApp();
    }
  }
,services);
}",0.992744860943168
180102,"@Override public void run(Map<Object,Object> services){
  this.httpService=(HttpService)services.get(HttpService.class.getName());
  try {
    logService.log(LogService.LOG_INFO,""String_Node_Str"");
    httpService.registerServlet(INFO_SERVLET_PATH,new SupportServlet(new BUGSupportInfo(context),new SupportInfoXMLFormatter()),null,null);
    httpService.registerServlet(INFO_SERVLET_HTML_PATH,new SupportServlet(new BUGSupportInfo(context),new SupportInfoTextFormatter()),null,null);
    httpService.registerResources(ROOT_ALIAS,""String_Node_Str"",new StaticResourceContext(""String_Node_Str"" + ROOT_ALIAS));
  }
 catch (  Exception e) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getMessage());
  }
}","@Override public void run(Map<String,Object> services){
  this.httpService=(HttpService)services.get(HttpService.class.getName());
  try {
    logService.log(LogService.LOG_INFO,""String_Node_Str"");
    httpService.registerServlet(INFO_SERVLET_PATH,new SupportServlet(new BUGSupportInfo(context),new SupportInfoXMLFormatter()),null,null);
    httpService.registerServlet(INFO_SERVLET_HTML_PATH,new SupportServlet(new BUGSupportInfo(context),new SupportInfoTextFormatter()),null,null);
    httpService.registerResources(ROOT_ALIAS,""String_Node_Str"",new StaticResourceContext(""String_Node_Str"" + ROOT_ALIAS));
  }
 catch (  Exception e) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getMessage());
  }
}",0.9916434540389972
180103,"public void run(Map<Object,Object> services){
  httpService=(HttpService)services.get(HttpService.class.getName());
  try {
    httpService.registerServlet(DRAGONFLY_WS_PATH,new DragonflyEventServlet(eventMap),null,null);
    logService.log(LogService.LOG_INFO,""String_Node_Str"" + DRAGONFLY_WS_PATH);
  }
 catch (  Exception e) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"",e);
  }
}","public void run(Map<String,Object> services){
  httpService=(HttpService)services.get(HttpService.class.getName());
  try {
    httpService.registerServlet(DRAGONFLY_WS_PATH,new DragonflyEventServlet(eventMap),null,null);
    logService.log(LogService.LOG_INFO,""String_Node_Str"" + DRAGONFLY_WS_PATH);
  }
 catch (  Exception e) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"",e);
  }
}",0.9848866498740554
180104,"@Override public void run(Map<Object,Object> services){
  if (servlets != null) {
    log.log(LogService.LOG_ERROR,""String_Node_Str"");
    return;
  }
  httpService=(HttpService)services.get(HttpService.class.getName());
  KnapsackInitService initService=(KnapsackInitService)services.get(KnapsackInitService.class.getName());
  configAdmin=(ConfigurationAdmin)services.get(ConfigurationAdmin.class.getName());
  servlets=new Hashtable<String,HttpServlet>();
  try {
    moduleServlet=new ModuleServlet(getExistingModules());
    context.addServiceListener(moduleServlet,FilterUtil.generateServiceFilter(IModuleControl.class.getName()));
    servlets.put(MODULE_WS_PATH,moduleServlet);
  }
 catch (  InvalidSyntaxException e) {
    log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
    return;
  }
  servlets.put(PACKAGE_WS_PATH,new PackageServlet(context));
  servlets.put(PROGRAM_WS_PATH,new ProgramServlet(context,initService));
  servlets.put(CONFIG_WS_PATH,new ConfigAdminServlet(context,configAdmin));
  servlets.put(SERVICE_WS_PATH,new WSServlet(context,serviceMap,configAdmin));
  servlets.put(SERVICE_HTML_PATH,new WSHtmlServlet(context,serviceMap,configAdmin));
  for (  Map.Entry<String,HttpServlet> e : servlets.entrySet())   try {
    httpService.registerServlet(e.getKey(),e.getValue(),null,null);
  }
 catch (  Exception e1) {
    log.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getKey(),e1);
  }
}","@Override public void run(Map<String,Object> services){
  if (servlets != null) {
    log.log(LogService.LOG_ERROR,""String_Node_Str"");
    return;
  }
  httpService=(HttpService)services.get(HttpService.class.getName());
  KnapsackInitService initService=(KnapsackInitService)services.get(KnapsackInitService.class.getName());
  configAdmin=(ConfigurationAdmin)services.get(ConfigurationAdmin.class.getName());
  servlets=new Hashtable<String,HttpServlet>();
  try {
    moduleServlet=new ModuleServlet(getExistingModules());
    context.addServiceListener(moduleServlet,FilterUtil.generateServiceFilter(IModuleControl.class.getName()));
    servlets.put(MODULE_WS_PATH,moduleServlet);
  }
 catch (  InvalidSyntaxException e) {
    log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
    return;
  }
  servlets.put(PACKAGE_WS_PATH,new PackageServlet(context));
  servlets.put(PROGRAM_WS_PATH,new ProgramServlet(context,initService));
  servlets.put(CONFIG_WS_PATH,new ConfigAdminServlet(context,configAdmin));
  servlets.put(SERVICE_WS_PATH,new WSServlet(context,serviceMap,configAdmin));
  servlets.put(SERVICE_HTML_PATH,new WSHtmlServlet(context,serviceMap,configAdmin));
  for (  Map.Entry<String,HttpServlet> e : servlets.entrySet())   try {
    httpService.registerServlet(e.getKey(),e.getValue(),null,null);
  }
 catch (  Exception e1) {
    log.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getKey(),e1);
  }
}",0.9957657021877204
180105,"/** 
 * @param context BundleContext
 * @param runnable ManagedRunnable
 * @param serviceCount number of services tracked
 */
public ServiceTrackerUtil(BundleContext context,ManagedRunnable runnable,int serviceCount){
  this.bc=context;
  this.runnable=runnable;
  this.serviceCount=serviceCount;
  this.serviceMap=new Hashtable<String,Object>();
  this.runCalled=false;
  this.shutdownCalled=false;
  sc=0;
}","/** 
 * @param context BundleContext
 * @param runnable ManagedRunnable
 * @param serviceCount number of services tracked
 */
public ServiceTrackerUtil(BundleContext context,ManagedRunnable runnable,int serviceCount){
  this.bc=context;
  this.runnable=runnable;
  this.serviceCount=serviceCount;
  this.serviceMap=new HashMap<String,Object>();
  this.runCalled=false;
  this.shutdownCalled=false;
  sc=0;
}",0.9901960784313726
180106,"@Override public void run(Map<Object,Object> services){
  httpService=(HttpService)services.get(HttpService.class.getName());
  sewingRegistration=context.registerService(ISewingService.class.getName(),new SewingServiceImpl(httpService),null);
}","@Override public void run(Map<String,Object> services){
  httpService=(HttpService)services.get(HttpService.class.getName());
  sewingRegistration=context.registerService(ISewingService.class.getName(),new SewingServiceImpl(httpService),null);
}",0.9755102040816328
180107,"public void log(ServiceReference sr,int level,String message,Throwable exception){
  System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
  exception.printStackTrace(new PrintWriter(System.out,true));
  if (level == LogService.LOG_ERROR) {
    System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
    exception.printStackTrace(new PrintWriter(System.err,true));
  }
}","public void log(ServiceReference sr,int level,String message,Throwable exception){
  if (exception == null) {
    log(sr,level,message);
    return;
  }
  System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
  exception.printStackTrace(new PrintWriter(System.out,true));
  if (level == LogService.LOG_ERROR) {
    System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
    exception.printStackTrace(new PrintWriter(System.err,true));
  }
}",0.9270833333333334
180108,"/** 
 * @param context if context is null, it will return a log service that uses stdout.
 * @return Either the first LogService available in the runtime if availableor a SysoutLogService.
 */
public static LogService getLogService(BundleContext context){
  final LogService logService;
  boolean created=false;
  ServiceReference sr=null;
  if (context != null)   sr=context.getServiceReference(LogService.class.getName());
  if (sr != null) {
    logService=(LogService)context.getService(sr);
  }
 else {
    logService=new LogService(){
      public void log(      int level,      String message){
        System.out.println(levelString(level) + message);
      }
      public void log(      int level,      String message,      Throwable exception){
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        }
        exception.printStackTrace(new PrintWriter(System.out,true));
      }
      public void log(      ServiceReference sr,      int level,      String message){
        System.out.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        }
      }
      public void log(      ServiceReference sr,      int level,      String message,      Throwable exception){
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        exception.printStackTrace(new PrintWriter(System.out,true));
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
          exception.printStackTrace(new PrintWriter(System.err,true));
        }
      }
      private String levelString(      int level){
switch (level) {
case LogService.LOG_DEBUG:
          return ""String_Node_Str"";
case LogService.LOG_ERROR:
        return ""String_Node_Str"";
case LogService.LOG_INFO:
      return ""String_Node_Str"";
case LogService.LOG_WARNING:
    return ""String_Node_Str"";
default :
  return ""String_Node_Str"";
}
}
}
;
created=true;
}
if (created && context != null) {
context.registerService(LogService.class.getName(),logService,null);
}
return logService;
}","/** 
 * @param context if context is null, it will return a log service that uses stdout.
 * @return Either the first LogService available in the runtime if availableor a SysoutLogService.
 */
public static LogService getLogService(BundleContext context){
  final LogService logService;
  boolean created=false;
  ServiceReference sr=null;
  if (context != null)   sr=context.getServiceReference(LogService.class.getName());
  if (sr != null) {
    logService=(LogService)context.getService(sr);
  }
 else {
    logService=new LogService(){
      public void log(      int level,      String message){
        System.out.println(levelString(level) + message);
      }
      public void log(      int level,      String message,      Throwable exception){
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        }
        exception.printStackTrace(new PrintWriter(System.out,true));
      }
      public void log(      ServiceReference sr,      int level,      String message){
        if (message == null)         message=""String_Node_Str"";
        System.out.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        }
      }
      public void log(      ServiceReference sr,      int level,      String message,      Throwable exception){
        if (exception == null) {
          log(sr,level,message);
          return;
        }
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        exception.printStackTrace(new PrintWriter(System.out,true));
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
          exception.printStackTrace(new PrintWriter(System.err,true));
        }
      }
      private String levelString(      int level){
switch (level) {
case LogService.LOG_DEBUG:
          return ""String_Node_Str"";
case LogService.LOG_ERROR:
        return ""String_Node_Str"";
case LogService.LOG_INFO:
      return ""String_Node_Str"";
case LogService.LOG_WARNING:
    return ""String_Node_Str"";
default :
  return ""String_Node_Str"";
}
}
}
;
created=true;
}
if (created && context != null) {
context.registerService(LogService.class.getName(),logService,null);
}
return logService;
}",0.9691164972634873
180109,"/** 
 * Set the name of the tag.
 * @param tagName
 */
public XmlNode setName(String tagName){
  this.name=tagName;
  return this;
}","/** 
 * Set the name of the tag.
 * @param tagName Name of tag.
 * @return instance of node.
 */
public XmlNode setName(String tagName){
  this.name=tagName;
  return this;
}",0.8627450980392157
180110,"/** 
 * @param name
 * @return true if a node with the given name exists, false otherwise.
 */
public boolean childExists(String name){
  return hasChild(name);
}","/** 
 * @param name name of child node
 * @deprecated use hasChild()
 * @return true if a node with the given name exists, false otherwise.
 */
public boolean childExists(String name){
  return hasChild(name);
}",0.868632707774799
180111,"/** 
 * @param name
 * @param value
 * @return
 */
public XmlNode setAttribute(String name,String value){
  attributes.put(name,value);
  return this;
}","/** 
 * @param name attribute name
 * @param value attribute value
 * @return instance of XmlNode
 */
public XmlNode setAttribute(String name,String value){
  attributes.put(name,value);
  return this;
}",0.8
180112,"/** 
 * Get contents of attribute, or null if attribute does not exist.
 * @param name
 * @return
 */
public String getAttribute(String name){
  return (String)attributes.get(name);
}","/** 
 * Get contents of attribute, or null if attribute does not exist.
 * @param name name of attribute
 * @return value of attribute or null if does not exist.
 */
public String getAttribute(String name){
  return (String)attributes.get(name);
}",0.8511627906976744
180113,"/** 
 * @return
 * @throws XmlPullParserException
 */
private static XmlPullParser getParser(boolean isNamespaceAware) throws XmlPullParserException {
  if (parser == null) {
    if (factory == null) {
      factory=XmlPullParserFactory.newInstance(""String_Node_Str"",null);
    }
    factory.setNamespaceAware(isNamespaceAware);
    parser=factory.newPullParser();
  }
  parser=factory.newPullParser();
  return parser;
}","/** 
 * @param isNamespaceAware if namespaces should be parsed
 * @return An XmlNode that corresponds to the root of the parsed xmlString.
 * @throws XmlPullParserException on parse error
 */
private static XmlPullParser getParser(boolean isNamespaceAware) throws XmlPullParserException {
  if (parser == null) {
    if (factory == null) {
      factory=XmlPullParserFactory.newInstance(""String_Node_Str"",null);
    }
    factory.setNamespaceAware(isNamespaceAware);
    parser=factory.newPullParser();
  }
  parser=factory.newPullParser();
  return parser;
}",0.8469387755102041
180114,"/** 
 * @param parent
 * @throws SelfReferenceException
 */
public XmlNode setParent(XmlNode parent){
  if (parentNode != null) {
    parentNode.getChildren().remove(this);
  }
  parentNode=parent;
  return this;
}","/** 
 * Set the parent node.
 * @param parent parent node
 * @return instance of XmlNode
 */
public XmlNode setParent(XmlNode parent){
  if (parentNode != null) {
    parentNode.getChildren().remove(this);
  }
  parentNode=parent;
  return this;
}",0.806941431670282
180115,"/** 
 * Create a node with a parent and a String value.
 * @param parent
 * @param tagName
 * @param value
 */
public XmlNode(XmlNode parent,String tagName,String value){
  this(parent,tagName);
  if (value.length() > 0) {
    this.value=value;
  }
}","/** 
 * Create a node with a parent and a String value.
 * @param parent Parent XmlNode.
 * @param tagName Name of tag.  RuntimeExeception will be thrown if null value is passed.
 * @param value List<XmlNode> of child nodes.
 */
public XmlNode(XmlNode parent,String tagName,String value){
  this(parent,tagName);
  if (value != null && value.length() > 0) {
    this.value=value;
  }
}",0.7874015748031497
180116,"/** 
 * @param nodeName
 * @return node with given name if exists or null otherwise.
 */
public XmlNode getChild(String nodeName){
  if (children == null) {
    return null;
  }
  for (Iterator<XmlNode> i=getChildren().iterator(); i.hasNext(); ) {
    XmlNode child=i.next();
    if (child.name.equals(nodeName)) {
      return child;
    }
  }
  return null;
}","/** 
 * @param nodeName name of child node
 * @return node with given name if exists or null otherwise.
 */
public XmlNode getChild(String nodeName){
  if (children == null) {
    return null;
  }
  for (Iterator<XmlNode> i=getChildren().iterator(); i.hasNext(); ) {
    XmlNode child=i.next();
    if (child.name.equals(nodeName)) {
      return child;
    }
  }
  return null;
}",0.9743589743589745
180117,"public boolean hasValue(){
  return value != null;
}","/** 
 * @return true if value is not null
 */
public boolean hasValue(){
  return value != null;
}",0.6933333333333334
180118,"private static XmlNode parse(XmlPullParser parser2,XmlNode e) throws XmlPullParserException, IOException {
  while (true) {
switch (parser.next()) {
case XmlPullParser.START_TAG:
      if (e == null)       e=new XmlNode(parser.getName());
 else       e=new XmlNode(e,parser.getName());
    for (int i=0; i < parser.getAttributeCount(); ++i) {
      e.addAttribute(parser.getAttributeName(i),parser.getAttributeValue(i));
    }
  break;
case XmlPullParser.TEXT:
if (!parser.isWhitespace()) e.setValue(parser.getText());
break;
case XmlPullParser.END_TAG:
if (e.getParent() != null) e=e.getParent();
break;
case XmlPullParser.END_DOCUMENT:
return e;
default :
break;
}
}
}","/** 
 * @param pullParser parser
 * @param node XmlNode
 * @return An XmlNode that corresponds to the root of the parsed xmlString.
 * @throws XmlPullParserException on xml parse error
 * @throws IOException on I/O error
 */
private static XmlNode parse(XmlPullParser pullParser,XmlNode node) throws XmlPullParserException, IOException {
  while (true) {
switch (parser.next()) {
case XmlPullParser.START_TAG:
      if (node == null)       node=new XmlNode(parser.getName());
 else       node=new XmlNode(node,parser.getName());
    for (int i=0; i < parser.getAttributeCount(); ++i) {
      node.addAttribute(parser.getAttributeName(i),parser.getAttributeValue(i));
    }
  break;
case XmlPullParser.TEXT:
if (!parser.isWhitespace()) node.setValue(parser.getText());
break;
case XmlPullParser.END_TAG:
if (node.getParent() != null) node=node.getParent();
break;
case XmlPullParser.END_DOCUMENT:
return node;
default :
break;
}
}
}",0.8294815740162399
180119,"/** 
 * Clear the value of the XML node.
 */
public XmlNode clearValue(){
  value=null;
  return this;
}","/** 
 * Clear the value of the XML node.
 * @return instance of XmlNode
 */
public XmlNode clearValue(){
  value=null;
  return this;
}",0.8702928870292888
180120,"/** 
 * @return
 */
public String getValue(){
  return value;
}","/** 
 * @return value of tag.  Can be null.
 */
public String getValue(){
  return value;
}",0.8181818181818182
180121,"/** 
 * @param name
 * @param value
 * @return instance of self
 */
public XmlNode addAttribute(String name,String value){
  this.getAttributes().put(name,value);
  return this;
}","/** 
 * @param name name of attribute
 * @param value value of attribute
 * @return instance of self
 */
public XmlNode addAttribute(String name,String value){
  this.getAttributes().put(name,value);
  return this;
}",0.9063291139240506
180122,"public XmlNode setValue(String text){
  if (text == null) {
    clearValue();
  }
 else {
    if (hasValue())     throw new RuntimeException(""String_Node_Str"");
  }
  this.value=text;
  return this;
}","/** 
 * @param value Value of node.  Can only be called on nodes that do not contain children.  Runtime exception will be generated otherwise.
 * @return instance of node.
 */
public XmlNode setValue(String value){
  if (value == null) {
    clearValue();
  }
 else {
    if (hasValue())     throw new RuntimeException(""String_Node_Str"");
  }
  this.value=value;
  return this;
}",0.6493955094991365
180123,"/** 
 * @param name
 * @return true if a node with the given name exists, false otherwise.
 */
public boolean hasChild(String name){
  if (!hasChildren()) {
    return false;
  }
  if (getChild(name) != null) {
    return true;
  }
  return false;
}","/** 
 * @param name name of child node
 * @return true if a node with the given name exists, false otherwise.
 */
public boolean hasChild(String name){
  if (!hasChildren()) {
    return false;
  }
  if (getChild(name) != null) {
    return true;
  }
  return false;
}",0.9632495164410058
180124,"public String toString(){
  try {
    return serialize(this);
  }
 catch (  XmlPullParserException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  return super.toString();
}","public String toString(){
  try {
    return serialize(this);
  }
 catch (  Exception e) {
  }
  return super.toString();
}",0.7256637168141593
180125,"/** 
 * Retrieve a node from this element using xpath-like notation. Ex. for <root><leaf1><leaf1><leaf2></root> call with ""root/leaf1"" to return first occurrence leaf1 node.
 * @param path
 * @return
 */
public XmlNode getFirstElement(String path){
  String[] elems=path.split(""String_Node_Str"");
  XmlNode root=this;
  for (int i=0; i < elems.length; ++i) {
    root=(XmlNode)root.getChild(elems[i]);
    if (root == null) {
      break;
    }
  }
  return root;
}","/** 
 * Retrieve a node from this element using xpath-like notation. Example: for ""<root><leaf1></leaf1><leaf2/></root>"" call with ""root/leaf1"" to return first occurrence leaf1 node.
 * @param path tree path expressed as node names delimited with '/' character.
 * @return The node or null if not found.
 */
public XmlNode getFirstElement(String path){
  String[] elems=path.split(""String_Node_Str"");
  XmlNode root=this;
  for (int i=0; i < elems.length; ++i) {
    root=(XmlNode)root.getChild(elems[i]);
    if (root == null) {
      break;
    }
  }
  return root;
}",0.8878143133462283
180126,"/** 
 * Equivalent to addChildElement except that unchecked exception is thrown on self referencing call.
 * @param element
 * @return
 */
public XmlNode addChild(XmlNode element){
  if (element == this) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (this.value != null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  getChildren().add(element);
  element.setParent(this);
  return element;
}","/** 
 * Add a child XmlNode to the current node.  Runtime exception will be thrown if a node is added to itself. Runtime exception will also be generated if parent node already contains a value.
 * @param element Child XmlNode
 * @return instance of XmlNode
 */
public XmlNode addChild(XmlNode element){
  if (element == this) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (this.value != null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  getChildren().add(element);
  element.setParent(this);
  return element;
}",0.6313603322949117
180127,"/** 
 * @param val Set's the intensity of the backlight 0-7.
 */
public int setBackLight(int val) throws IOException ;","/** 
 * Set's the intensity of the backlight.
 * @param val (0 - 100)
 * @return 0 if successful, 1 on failure.
 */
public int setBackLight(int val) throws IOException ;",0.7317073170731707
180128,"/** 
 * TODO: replace this with sysfs API.
 * @param sysfsEntry
 * @param value
 * @return
 * @throws IOException
 */
private int writeToSysfs(File sysfsEntry,String value) throws IOException {
  BufferedWriter out;
  out=new BufferedWriter(new FileWriter(sysfsEntry));
  out.write(String.valueOf(value));
  out.close();
  return 1;
}","/** 
 * TODO: replace this with sysfs API.
 * @param sysfsEntry file of sysfs entry
 * @param value value to write to file
 * @return 0
 * @throws IOException on File I/O error
 */
private int writeToSysfs(File sysfsEntry,String value) throws IOException {
  BufferedWriter out;
  out=new BufferedWriter(new FileWriter(sysfsEntry));
  out.write(String.valueOf(value));
  out.close();
  return 0;
}",0.9110807113543092
180129,"public int setBackLight(int val) throws IOException {
  if (val < 0 || val > 100) {
    throw new IllegalArgumentException();
  }
  return writeToSysfs(new File(BRIGHTNESS_SYSFS),String.valueOf(val));
}","public int setBackLight(int val) throws IOException {
  if (val < 0 || val > 100) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return writeToSysfs(new File(BRIGHTNESS_SYSFS),String.valueOf(val));
}",0.9596199524940616
180130,"/** 
 * servicesMap is SortedMap<String, Map<String, String>> where the key is the service name and the map is a map of service properties. (| (& (objectClass=com.buglabs.bug.module.bugbee.pub.IBUGBeeControl) (& (Provider=com.buglabs.bug.module.bugbee.BUGBeeModlet)(Slot=2))) (| (& (objectClass=com.buglabs.module.IModuleControl)) (& (objectClass=org.osgi.service.http.HttpService)(port=8082))))
 * @param servicesMap Map of services to generate filter with.
 * @return Filter as a string.
 */
public static String generateServiceFilter(SortedMap<String,Map<String,String>> servicesMap){
  if (servicesMap.size() == 1) {
    return ""String_Node_Str"" + Constants.OBJECTCLASS + ""String_Node_Str""+ ((String)servicesMap.firstKey())+ ""String_Node_Str""+ generatePropertiesFilter(new TreeMap((Map)servicesMap.get(servicesMap.firstKey())))+ ""String_Node_Str"";
  }
 else   if (servicesMap.size() > 1) {
    return ""String_Node_Str"" + generateServiceFilter(servicesMap.subMap(servicesMap.firstKey(),servicesMap.firstKey() + ""String_Node_Str"")) + generateServiceFilter(servicesMap.tailMap(servicesMap.firstKey() + ""String_Node_Str""))+ ""String_Node_Str"";
  }
  return ""String_Node_Str"";
}","/** 
 * servicesMap is SortedMap<String, Map<String, String>> where the key is the service name and the map is a map of service properties. (| (& (objectClass=com.buglabs.bug.module.bugbee.pub.IBUGBeeControl) (& (Provider=com.buglabs.bug.module.bugbee.BUGBeeModlet)(Slot=2))) (| (& (objectClass=com.buglabs.module.IModuleControl)) (& (objectClass=org.osgi.service.http.HttpService)(port=8082))))
 * @param servicesMap Map of services to generate filter with.
 * @return Filter as a string.
 */
public static String generateServiceFilter(SortedMap<String,Map<String,String>> servicesMap){
  if (servicesMap.size() == 1) {
    return ""String_Node_Str"" + Constants.OBJECTCLASS + ""String_Node_Str""+ servicesMap.firstKey()+ ""String_Node_Str""+ generatePropertiesFilter(new TreeMap(servicesMap.get(servicesMap.firstKey())))+ ""String_Node_Str"";
  }
 else   if (servicesMap.size() > 1) {
    return ""String_Node_Str"" + generateServiceFilter(servicesMap.subMap(servicesMap.firstKey(),servicesMap.firstKey() + ""String_Node_Str"")) + generateServiceFilter(servicesMap.tailMap(servicesMap.firstKey() + ""String_Node_Str""))+ ""String_Node_Str"";
  }
  return ""String_Node_Str"";
}",0.993581514762516
180131,"/** 
 * Generate a Filter as a String given a Map of property/value pairs. (& (prop1=value1) (& (prop2=value1)))
 * @param propertiesMap
 * @return Filter as a String
 */
public static String generatePropertiesFilter(SortedMap<String,String> propertiesMap){
  if (propertiesMap.size() == 1) {
    return ""String_Node_Str"" + propertiesMap.firstKey() + ""String_Node_Str""+ propertiesMap.get(propertiesMap.firstKey())+ ""String_Node_Str"";
  }
 else   if (propertiesMap.size() > 1) {
    return ""String_Node_Str"" + generatePropertiesFilter(propertiesMap.subMap(propertiesMap.firstKey(),propertiesMap.firstKey() + ""String_Node_Str"")) + generatePropertiesFilter(propertiesMap.tailMap(propertiesMap.firstKey() + ""String_Node_Str""))+ ""String_Node_Str"";
  }
  return ""String_Node_Str"";
}","/** 
 * Generate a Filter as a String given a Map of property/value pairs. (& (prop1=value1) (& (prop2=value1)))
 * @param propertiesMap Map of properties
 * @return Filter as a String
 */
public static String generatePropertiesFilter(SortedMap<String,String> propertiesMap){
  if (propertiesMap.size() == 1) {
    return ""String_Node_Str"" + propertiesMap.firstKey() + ""String_Node_Str""+ propertiesMap.get(propertiesMap.firstKey())+ ""String_Node_Str"";
  }
 else   if (propertiesMap.size() > 1) {
    return ""String_Node_Str"" + generatePropertiesFilter(propertiesMap.subMap(propertiesMap.firstKey(),propertiesMap.firstKey() + ""String_Node_Str"")) + generatePropertiesFilter(propertiesMap.tailMap(propertiesMap.firstKey() + ""String_Node_Str""))+ ""String_Node_Str"";
  }
  return ""String_Node_Str"";
}",0.9885350318471338
180132,"/** 
 * servicesMap is SortedMap<String, Map<String, String>> where the key is the service name and the map is a map of service properties (| (& (objectClass=com.buglabs.bug.module.bugbee.pub.IBUGBeeControl) (& (Provider=com.buglabs.bug.module.bugbee.BUGBeeModlet)(Slot=2))) (| (& (objectClass=com.buglabs.module.IModuleControl)) (& (objectClass=org.osgi.service.http.HttpService)(port=8082))))
 */
public static String generateServiceFilter(SortedMap<String,Map<String,String>> servicesMap){
  if (servicesMap.size() == 1) {
    return ""String_Node_Str"" + Constants.OBJECTCLASS + ""String_Node_Str""+ ((String)servicesMap.firstKey())+ ""String_Node_Str""+ generatePropertiesFilter(new TreeMap((Map)servicesMap.get(servicesMap.firstKey())))+ ""String_Node_Str"";
  }
 else   if (servicesMap.size() > 1) {
    return ""String_Node_Str"" + generateServiceFilter(servicesMap.subMap(servicesMap.firstKey(),servicesMap.firstKey() + ""String_Node_Str"")) + generateServiceFilter(servicesMap.tailMap(servicesMap.firstKey() + ""String_Node_Str""))+ ""String_Node_Str"";
  }
  return ""String_Node_Str"";
}","/** 
 * servicesMap is SortedMap<String, Map<String, String>> where the key is the service name and the map is a map of service properties. (| (& (objectClass=com.buglabs.bug.module.bugbee.pub.IBUGBeeControl) (& (Provider=com.buglabs.bug.module.bugbee.BUGBeeModlet)(Slot=2))) (| (& (objectClass=com.buglabs.module.IModuleControl)) (& (objectClass=org.osgi.service.http.HttpService)(port=8082))))
 * @param servicesMap Map of services to generate filter with.
 * @return Filter as a string.
 */
public static String generateServiceFilter(SortedMap<String,Map<String,String>> servicesMap){
  if (servicesMap.size() == 1) {
    return ""String_Node_Str"" + Constants.OBJECTCLASS + ""String_Node_Str""+ ((String)servicesMap.firstKey())+ ""String_Node_Str""+ generatePropertiesFilter(new TreeMap((Map)servicesMap.get(servicesMap.firstKey())))+ ""String_Node_Str"";
  }
 else   if (servicesMap.size() > 1) {
    return ""String_Node_Str"" + generateServiceFilter(servicesMap.subMap(servicesMap.firstKey(),servicesMap.firstKey() + ""String_Node_Str"")) + generateServiceFilter(servicesMap.tailMap(servicesMap.firstKey() + ""String_Node_Str""))+ ""String_Node_Str"";
  }
  return ""String_Node_Str"";
}",0.9579087284005317
180133,"public void removedService(ServiceReference arg0,Object arg1){
  if (shutdownCalled)   return;
  String key=((String[])arg0.getProperty(Constants.OBJECTCLASS))[0];
  if (serviceMap.containsKey(key)) {
    serviceMap.remove(key);
    sc--;
  }
  if (!(thread == null) && !thread.isInterrupted()) {
    try {
      runnable.shutdown();
    }
 catch (    Exception e) {
      if (arg0 != null && arg0.getBundle() != null && arg0.getBundle().getBundleContext() != null) {
        LogService ls=LogServiceUtil.getLogService(arg0.getBundle().getBundleContext());
        if (ls != null) {
          ls.log(LogService.LOG_ERROR,""String_Node_Str"",e);
        }
      }
    }
    thread.interrupt();
    thread=null;
    shutdownCalled=true;
    runCalled=false;
    return;
  }
  if (runnable instanceof ManagedInlineRunnable) {
    ((ManagedInlineRunnable)runnable).shutdown();
    shutdownCalled=true;
    runCalled=false;
  }
}","public void removedService(ServiceReference reference,Object arg1){
  if (shutdownCalled)   return;
  String key=((String[])reference.getProperty(Constants.OBJECTCLASS))[0];
  if (serviceMap.containsKey(key)) {
    serviceMap.remove(key);
    sc--;
  }
  if (!(thread == null) && !thread.isInterrupted()) {
    try {
      runnable.shutdown();
    }
 catch (    Exception e) {
      if (reference != null && reference.getBundle() != null && reference.getBundle().getBundleContext() != null) {
        LogService ls=LogServiceUtil.getLogService(reference.getBundle().getBundleContext());
        if (ls != null) {
          ls.log(LogService.LOG_ERROR,""String_Node_Str"",e);
        }
      }
    }
    thread.interrupt();
    thread=null;
    shutdownCalled=true;
    runCalled=false;
    return;
  }
  if (runnable instanceof ManagedInlineRunnable) {
    ((ManagedInlineRunnable)runnable).shutdown();
    shutdownCalled=true;
    runCalled=false;
  }
}",0.9583778014941302
180134,"public void modifiedService(ServiceReference arg0,Object arg1){
  String key=((String[])arg0.getProperty(Constants.OBJECTCLASS))[0];
  serviceMap.put(key,arg1);
}","public void modifiedService(ServiceReference reference,Object arg1){
  String key=((String[])reference.getProperty(Constants.OBJECTCLASS))[0];
  serviceMap.put(key,arg1);
}",0.934131736526946
180135,"public void start(BundleContext context) throws Exception {
  Activator.context=context;
  modules=new IModuleControl[BUGBundleConstants.BUG_TOTAL_BMI_SLOTS];
  checkSetting();
  batteryProvider=new BatteryInfoProvider();
  batteryReg=context.registerService(IBatteryInfoProvider.class.getName(),batteryProvider,null);
  stc=ServiceTrackerUtil.openServiceTracker(context,new DashApplication(context),services);
  new BUGwebAdminServiceTracker(context);
  appReg=context.registerService(IDesktopApp.class.getName(),this,null);
}","public void start(BundleContext context) throws Exception {
  Activator.context=context;
  modules=new IModuleControl[BUGBundleConstants.BUG_TOTAL_BMI_SLOTS];
  checkSetting();
  batteryProvider=new BatteryInfoProvider();
  batteryReg=context.registerService(IBatteryInfoProvider.class.getName(),batteryProvider,null);
  stc=ServiceTrackerUtil.openServiceTracker(context,new DashApplication(context),services);
  new BUGwebAdminServiceTracker(context);
  appReg=context.registerService(IDesktopApp.class.getName(),this,null);
  context.addServiceListener(this,FilterUtil.generateServiceFilter(IModuleControl.class.getName()));
}",0.9125541125541126
180136,"public void stop(BundleContext context) throws Exception {
  appReg.unregister();
  ShellUtil.destroySession();
  stc.close();
  if (batteryReg != null)   batteryReg.unregister();
}","public void stop(BundleContext context) throws Exception {
  context.removeServiceListener(this);
  appReg.unregister();
  ShellUtil.destroySession();
  stc.close();
  if (batteryReg != null)   batteryReg.unregister();
}",0.9027431421446384
180137,"@Override public void run(Map<String,Object> services){
  LogManager.logInfo(""String_Node_Str"");
  service=(ISewingService)services.get(ISewingService.class.getName());
  mainServlet=new BUGwebAdminServlet();
  hardwareServlet=new BUGwebAdminHardwareServlet();
  systemServlet=new BUGwebAdminSystemServlet();
  softwareServlet=new BUGwebAdminSoftwareServlet();
  bugnetServlet=new BUGwebAdminBUGnetServlet();
  utilsServlet=new BUGwebAdminUtilsServlet();
  imageServlet=new BUGwebFileServlet();
  service.register(context,""String_Node_Str"",mainServlet);
  service.register(context,""String_Node_Str"",hardwareServlet);
  service.register(context,""String_Node_Str"",systemServlet);
  service.register(context,""String_Node_Str"",softwareServlet);
  service.register(context,""String_Node_Str"",bugnetServlet);
  service.register(context,""String_Node_Str"",utilsServlet);
  service.register(context,""String_Node_Str"",imageServlet);
  try {
    moduleTracker=new ServiceTracker(context,FilterUtil.generateServiceFilter(context,new String[]{IModuleControl.class.getName()}),new BUGwebAdminModuleControlServiceTracker(context));
    moduleTracker.open();
  }
 catch (  InvalidSyntaxException e) {
  }
}","@Override public void run(Map<String,Object> services){
  LogManager.logInfo(""String_Node_Str"");
  sewingService=(ISewingService)services.get(ISewingService.class.getName());
  mainServlet=new BUGwebAdminServlet();
  hardwareServlet=new BUGwebAdminHardwareServlet();
  systemServlet=new BUGwebAdminSystemServlet();
  softwareServlet=new BUGwebAdminSoftwareServlet();
  bugnetServlet=new BUGwebAdminBUGnetServlet();
  utilsServlet=new BUGwebAdminUtilsServlet();
  imageServlet=new BUGwebFileServlet();
  sewingService.register(context,""String_Node_Str"",mainServlet);
  sewingService.register(context,""String_Node_Str"",hardwareServlet);
  sewingService.register(context,""String_Node_Str"",systemServlet);
  sewingService.register(context,""String_Node_Str"",softwareServlet);
  sewingService.register(context,""String_Node_Str"",bugnetServlet);
  sewingService.register(context,""String_Node_Str"",utilsServlet);
  sewingService.register(context,""String_Node_Str"",imageServlet);
}",0.8546296296296296
180138,"@Override public void shutdown(){
  LogManager.logInfo(""String_Node_Str"");
  service.unregister(mainServlet);
  service.unregister(hardwareServlet);
  service.unregister(systemServlet);
  service.unregister(softwareServlet);
  service.unregister(bugnetServlet);
  service.unregister(utilsServlet);
  service.unregister(imageServlet);
  ShellUtil.destroySession();
  if (moduleTracker != null)   moduleTracker.close();
}","@Override public void shutdown(){
  LogManager.logInfo(""String_Node_Str"");
  sewingService.unregister(mainServlet);
  sewingService.unregister(hardwareServlet);
  sewingService.unregister(systemServlet);
  sewingService.unregister(softwareServlet);
  sewingService.unregister(bugnetServlet);
  sewingService.unregister(utilsServlet);
  sewingService.unregister(imageServlet);
  ShellUtil.destroySession();
}",0.7990314769975787
180139,"public URL getResource(String name){
  return context.getBundle().getResource(name);
}","public URL getResource(String name){
  if (name.equals(root))   name=name + ""String_Node_Str"";
  return context.getBundle().getResource(name);
}",0.7478260869565218
180140,"@Override public void run(Map<Object,Object> services){
  this.httpService=(HttpService)services.get(HttpService.class.getName());
  try {
    logService.log(LogService.LOG_INFO,""String_Node_Str"");
    httpService.registerServlet(INFO_SERVLET_PATH,new SupportServlet(new BUGSupportInfo(context),new SupportInfoXMLFormatter()),null,null);
    httpService.registerServlet(INFO_SERVLET_HTML_PATH,new SupportServlet(new BUGSupportInfo(context),new SupportInfoTextFormatter()),null,null);
    httpService.registerResources(ROOT_ALIAS,""String_Node_Str"",new StaticResourceContext());
  }
 catch (  ServletException e) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getMessage());
  }
catch (  NamespaceException e) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getMessage());
  }
}","@Override public void run(Map<Object,Object> services){
  this.httpService=(HttpService)services.get(HttpService.class.getName());
  try {
    logService.log(LogService.LOG_INFO,""String_Node_Str"");
    httpService.registerServlet(INFO_SERVLET_PATH,new SupportServlet(new BUGSupportInfo(context),new SupportInfoXMLFormatter()),null,null);
    httpService.registerServlet(INFO_SERVLET_HTML_PATH,new SupportServlet(new BUGSupportInfo(context),new SupportInfoTextFormatter()),null,null);
    httpService.registerResources(ROOT_ALIAS,""String_Node_Str"",new StaticResourceContext(""String_Node_Str"" + ROOT_ALIAS));
  }
 catch (  ServletException e) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getMessage());
  }
catch (  NamespaceException e) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getMessage());
  }
}",0.9817961165048544
180141,"/** 
 * System - File Browser
 */
public SewingController getFileBrowserController(){
  return new fileBrowserController();
}","/** 
 * System - File Browser
 */
public SewingController getFileBrowserController(){
  return new FileBrowserController();
}",0.992
180142,"public SewingController getFileNavigatorController(){
  return new fileNavigatorController();
}","public SewingController getFileNavigatorController(){
  return new FileNavigatorController();
}",0.9894736842105264
180143,"public SewingController getFileDownloadController(){
  return new fileDownloadController();
}","public SewingController getFileDownloadController(){
  return new FileDownloadController();
}",0.989247311827957
180144,"/** 
 * Login/Logout - Secure Login/Logout for BUG
 */
public SewingController getBugLoginController(){
  return new BugLoginController();
}","/** 
 * Login/Logout - Secure Login/Logout for BUG
 */
public SewingController getBugLoginController(){
  return new BUGLoginController();
}",0.9857142857142858
180145,"public SewingController getFileViewerController(){
  return new fileViewerController();
}","public SewingController getFileViewerController(){
  return new FileViewerController();
}",0.9887640449438202
180146,public void buttonEvent(ButtonEvent event);,"/** 
 * Method called when a button event has occurred.
 * @param event information of event
 */
void buttonEvent(ButtonEvent event);",0.4431818181818182
180147,public void removeListener(IButtonEventListener listener);,"/** 
 * Remove a listener for button events.
 * @param listener IButtonEventListener
 */
void removeListener(IButtonEventListener listener);",0.5454545454545454
180148,public void addListener(IButtonEventListener listener);,"/** 
 * Add a listener for button events.
 * @param listener IButtonEventListener
 */
void addListener(IButtonEventListener listener);",0.5396825396825397
180149,"/** 
 * Return true if the repsonse is an error. If the response is an error, mimeType and Content are ignored.
 * @return
 */
public boolean isError();","/** 
 * Return true if the repsonse is an error. If the response is an error, mimeType and Content are ignored.
 * @return true on error
 */
boolean isError();",0.932475884244373
180150,"/** 
 * Return an appropriate mime-type for content being passed.
 * @return
 */
public String getMimeType();","/** 
 * Return an appropriate mime-type for content being passed.
 * @return mime type
 */
String getMimeType();",0.9230769230769232
180151,"/** 
 * Return error code if the response is an error.
 * @return
 */
public int getErrorCode();","/** 
 * Return error code if the response is an error.
 * @return HTTP error code
 */
int getErrorCode();",0.8855721393034826
180152,"/** 
 * Get content of response.
 * @return
 */
public Object getContent();","/** 
 * Get content of response.
 * @return content, could be a Stream or a String.
 */
Object getContent();",0.7431693989071039
180153,"/** 
 * Return error message if the response is an error.
 * @return
 */
public String getErrorMessage();","/** 
 * Return error message if the response is an error.
 * @return Error String
 */
String getErrorMessage();",0.9074074074074074
180154,"/** 
 * Register a service to be exposed as a public web service.
 * @param provider
 */
void registerService(PublicWSProvider provider);","/** 
 * Register a service to be exposed as a public web service.
 * @param provider PublicWSProvider
 */
void registerService(PublicWSProvider provider);",0.9415807560137456
180155,"/** 
 * Unregister an existing service.
 * @param provider
 */
void unregisterService(PublicWSProvider provider);","/** 
 * Unregister an existing service.
 * @param provider PublicWSProvider
 */
void unregisterService(PublicWSProvider provider);",0.9300411522633744
180156,"/** 
 * @return The mime-type of the returned data (if any).
 */
public String getReturnType();","/** 
 * @return The mime-type of the returned data (if any).
 */
String getReturnType();",0.9617486338797814
180157,"/** 
 * @return A list of <code>String</code> that define parameter names.
 */
public List<String> getParameters();","/** 
 * @return A list of <code>String</code> that define parameter names.
 */
List<String> getParameters();",0.968609865470852
180158,"/** 
 * This method is responsible for loading and starting any bundles that provide Modlets for given module type. After bundle(s) are started, those bundles expose IModulet services. The BMI activator then listens for modlets. Upon new modlet creation, the setup is called.
 * @param event event to handle
 */
public void handleEvent(BMIModuleEvent event){
  if (!modletFactories.containsKey(event.getModuleId())) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + event.getModuleId());
    return;
  }
  try {
    List<IModlet> ml;
switch (event.getType()) {
case INSERT:
      for (      IModletFactory mf : modletFactories.get(event.getModuleId())) {
        IModlet m=mf.createModlet(context,event.getSlot(),event.getBMIDevice());
        try {
          m.setup();
        }
 catch (        Exception e) {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + mf.getName() + ""String_Node_Str""+ e.getMessage(),e);
          continue;
        }
        m.start();
        logService.log(LogService.LOG_INFO,""String_Node_Str"" + mf.getName() + ""String_Node_Str"");
        if (!activeModlets.containsKey(m.getModuleId())) {
          activeModlets.put(m.getModuleId(),new ArrayList<IModlet>());
        }
        List<IModlet> am=activeModlets.get(m.getModuleId());
        if (!am.contains(m)) {
          am.add(m);
        }
      }
    break;
case REMOVE:
  List<IModlet> removalList=new ArrayList<IModlet>();
ml=activeModlets.get(event.getModuleId());
for (IModlet m : ml) {
if (m.getSlotId() == event.getSlot()) {
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + m.getModuleId() + ""String_Node_Str"");
  m.stop();
  removalList.add(m);
}
}
for (IModlet m : removalList) ml.remove(m);
removalList.clear();
logService.log(LogService.LOG_INFO,""String_Node_Str"");
break;
}
}
 catch (BundleException e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
if (e.getNestedException() != null) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getNestedException().getClass().getName() + ""String_Node_Str""+ e.getNestedException().getMessage());
}
e.printStackTrace();
}
catch (Exception e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
}
}","/** 
 * This method is responsible for loading and starting any bundles that provide Modlets for given module type. After bundle(s) are started, those bundles expose IModulet services. The BMI activator then listens for modlets. Upon new modlet creation, the setup is called.
 * @param event event to handle
 */
public void handleEvent(BMIModuleEvent event){
  if (!modletFactories.containsKey(event.getModuleId())) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + event.getModuleId());
    return;
  }
  try {
    List<IModlet> ml;
switch (event.getType()) {
case INSERT:
      for (      IModletFactory mf : modletFactories.get(event.getModuleId())) {
        IModlet m=mf.createModlet(context,event.getSlot(),event.getBMIDevice());
        try {
          m.setup();
        }
 catch (        Exception e) {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + mf.getName() + ""String_Node_Str""+ e.getMessage(),e);
          continue;
        }
        m.start();
        logService.log(LogService.LOG_INFO,""String_Node_Str"" + mf.getName() + ""String_Node_Str"");
        if (!activeModlets.containsKey(m.getModuleId())) {
          activeModlets.put(m.getModuleId(),new CopyOnWriteArrayList<IModlet>());
        }
        List<IModlet> am=activeModlets.get(m.getModuleId());
        if (!am.contains(m)) {
          am.add(m);
        }
      }
    break;
case REMOVE:
  List<IModlet> removalList=new ArrayList<IModlet>();
ml=activeModlets.get(event.getModuleId());
for (IModlet m : ml) {
if (m.getSlotId() == event.getSlot()) {
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + m.getModuleId() + ""String_Node_Str"");
  m.stop();
  removalList.add(m);
}
}
for (IModlet m : removalList) ml.remove(m);
removalList.clear();
logService.log(LogService.LOG_INFO,""String_Node_Str"");
break;
}
}
 catch (BundleException e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
if (e.getNestedException() != null) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getNestedException().getClass().getName() + ""String_Node_Str""+ e.getNestedException().getMessage());
}
e.printStackTrace();
}
catch (Exception e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
}
}",0.9978882703014014
180159,"public void run(){
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + pipeFilename);
  while (!Thread.currentThread().isInterrupted()) {
    try {
      BufferedReader reader=new BufferedReader(new FileReader(pipeFilename));
      String line=null;
      while ((line=reader.readLine()) != null) {
        if (line.equals(POISON_PILL)) {
          return;
        }
        if (logService != null) {
          logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + line);
        }
        try {
          BMIModuleEvent m=new BMIModuleEvent(line);
          eventHandler.handleEvent(m);
        }
 catch (        IOException e) {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + line);
        }
      }
    }
 catch (    FileNotFoundException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
catch (    IOException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
 finally {
      IOUtils.closeQuietly(stream);
    }
  }
}","public void run(){
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + pipeFilename);
  while (!Thread.currentThread().isInterrupted()) {
    try {
      BufferedReader reader=new BufferedReader(new FileReader(pipeFilename));
      String line=null;
      String lastEvent=""String_Node_Str"";
      while ((line=reader.readLine()) != null) {
        if (line.equals(POISON_PILL)) {
          return;
        }
        if (line.equals(lastEvent)) {
          logService.log(LogService.LOG_DEBUG,""String_Node_Str"");
          continue;
        }
        if (logService != null) {
          logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + line);
        }
        try {
          BMIModuleEvent m=new BMIModuleEvent(line);
          eventHandler.handleEvent(m);
        }
 catch (        IOException e) {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + line);
        }
        lastEvent=line;
      }
    }
 catch (    FileNotFoundException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
catch (    IOException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
 finally {
      IOUtils.closeQuietly(stream);
    }
  }
}",0.8926605504587156
180160,"public TemplateModelRoot get(RequestParameters params,HttpServletRequest req,HttpServletResponse resp){
  Configuration[] configs=null;
  try {
    configs=AdminConfigManager.getConfigurations();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  InvalidSyntaxException e) {
    e.printStackTrace();
  }
  SimpleHash root=new SimpleHash();
  SimpleList config_list=new SimpleList();
  SimpleHash item;
  String pid;
  for (int i=0; i < configs.length; i++) {
    pid=configs[i].getPid();
    item=new SimpleHash();
    item.put(""String_Node_Str"",pid);
    item.put(""String_Node_Str"",pid.replace('.','_'));
    config_list.add(item);
  }
  root.put(""String_Node_Str"",config_list);
  root.put(""String_Node_Str"",params.get(""String_Node_Str""));
  return root;
}","public TemplateModelRoot get(RequestParameters params,HttpServletRequest req,HttpServletResponse resp){
  Configuration[] configs=null;
  try {
    configs=AdminConfigManager.getConfigurations();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  InvalidSyntaxException e) {
    e.printStackTrace();
  }
  SimpleHash root=new SimpleHash();
  SimpleList config_list=new SimpleList();
  SimpleHash item;
  String pid;
  if (configs != null) {
    for (int i=0; i < configs.length; i++) {
      pid=configs[i].getPid();
      item=new SimpleHash();
      item.put(""String_Node_Str"",pid);
      item.put(""String_Node_Str"",pid.replace('.','_'));
      config_list.add(item);
    }
  }
  root.put(""String_Node_Str"",config_list);
  root.put(""String_Node_Str"",params.get(""String_Node_Str""));
  return root;
}",0.9441305712492152
180161,"/** 
 * This method is responsible for loading and starting any bundles that provide Modlets for given module type. After bundle(s) are started, those bundles expose IModulet services. The BMI activator then listens for modlets. Upon new modlet creation, the setup is called.
 * @param event event to handle
 */
public void handleEvent(BMIModuleEvent event){
  if (!modletFactories.containsKey(event.getModuleId())) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + event.getModuleId());
    return;
  }
  try {
    List<IModlet> ml;
switch (event.getType()) {
case INSERT:
      for (      IModletFactory mf : modletFactories.get(event.getModuleId())) {
        IModlet m=mf.createModlet(context,event.getSlot(),event.getBMIDevice());
        try {
          m.setup();
        }
 catch (        Exception e) {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + mf.getName() + ""String_Node_Str""+ e.getMessage(),e);
          continue;
        }
        m.start();
        logService.log(LogService.LOG_INFO,""String_Node_Str"" + mf.getName() + ""String_Node_Str"");
        if (!activeModlets.containsKey(m.getModuleId())) {
          activeModlets.put(m.getModuleId(),new ArrayList<IModlet>());
        }
        List<IModlet> am=activeModlets.get(m.getModuleId());
        if (!am.contains(m)) {
          am.add(m);
        }
      }
    break;
case REMOVE:
  List<IModlet> removalList=new ArrayList<IModlet>();
ml=activeModlets.get(event.getModuleId());
for (IModlet m : ml) {
if (m.getSlotId() == event.getSlot()) {
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + m.getModuleId() + ""String_Node_Str"");
  m.stop();
  removalList.add(m);
}
}
for (IModlet m : ml) ml.remove(m);
removalList.clear();
logService.log(LogService.LOG_INFO,""String_Node_Str"");
break;
}
}
 catch (BundleException e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
if (e.getNestedException() != null) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getNestedException().getClass().getName() + ""String_Node_Str""+ e.getNestedException().getMessage());
}
e.printStackTrace();
}
catch (Exception e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
}
}","/** 
 * This method is responsible for loading and starting any bundles that provide Modlets for given module type. After bundle(s) are started, those bundles expose IModulet services. The BMI activator then listens for modlets. Upon new modlet creation, the setup is called.
 * @param event event to handle
 */
public void handleEvent(BMIModuleEvent event){
  if (!modletFactories.containsKey(event.getModuleId())) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + event.getModuleId());
    return;
  }
  try {
    List<IModlet> ml;
switch (event.getType()) {
case INSERT:
      for (      IModletFactory mf : modletFactories.get(event.getModuleId())) {
        IModlet m=mf.createModlet(context,event.getSlot(),event.getBMIDevice());
        try {
          m.setup();
        }
 catch (        Exception e) {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + mf.getName() + ""String_Node_Str""+ e.getMessage(),e);
          continue;
        }
        m.start();
        logService.log(LogService.LOG_INFO,""String_Node_Str"" + mf.getName() + ""String_Node_Str"");
        if (!activeModlets.containsKey(m.getModuleId())) {
          activeModlets.put(m.getModuleId(),new ArrayList<IModlet>());
        }
        List<IModlet> am=activeModlets.get(m.getModuleId());
        if (!am.contains(m)) {
          am.add(m);
        }
      }
    break;
case REMOVE:
  List<IModlet> removalList=new ArrayList<IModlet>();
ml=activeModlets.get(event.getModuleId());
for (IModlet m : ml) {
if (m.getSlotId() == event.getSlot()) {
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + m.getModuleId() + ""String_Node_Str"");
  m.stop();
  removalList.add(m);
}
}
for (IModlet m : removalList) ml.remove(m);
removalList.clear();
logService.log(LogService.LOG_INFO,""String_Node_Str"");
break;
}
}
 catch (BundleException e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
if (e.getNestedException() != null) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getNestedException().getClass().getName() + ""String_Node_Str""+ e.getNestedException().getMessage());
}
e.printStackTrace();
}
catch (Exception e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
}
}",0.997494700327616
180162,"@Override public void run(Map<Object,Object> services){
  LogManager.logInfo(""String_Node_Str"");
  service=(ISewingService)services.get(ISewingService.class);
  mainServlet=new BUGwebAdminServlet();
  hardwareServlet=new BUGwebAdminHardwareServlet();
  systemServlet=new BUGwebAdminSystemServlet();
  softwareServlet=new BUGwebAdminSoftwareServlet();
  bugnetServlet=new BUGwebAdminBUGnetServlet();
  utilsServlet=new BUGwebAdminUtilsServlet();
  imageServlet=new BUGwebFileServlet();
  service.register(context,""String_Node_Str"",mainServlet);
  service.register(context,""String_Node_Str"",hardwareServlet);
  service.register(context,""String_Node_Str"",systemServlet);
  service.register(context,""String_Node_Str"",softwareServlet);
  service.register(context,""String_Node_Str"",bugnetServlet);
  service.register(context,""String_Node_Str"",utilsServlet);
  service.register(context,""String_Node_Str"",imageServlet);
  try {
    moduleTracker=new ServiceTracker(context,FilterUtil.generateServiceFilter(context,new String[]{IModuleControl.class.getName()}),new BUGwebAdminModuleControlServiceTracker(context));
    moduleTracker.open();
  }
 catch (  InvalidSyntaxException e) {
  }
}","@Override public void run(Map<Object,Object> services){
  LogManager.logInfo(""String_Node_Str"");
  service=(ISewingService)services.get(ISewingService.class.getName());
  mainServlet=new BUGwebAdminServlet();
  hardwareServlet=new BUGwebAdminHardwareServlet();
  systemServlet=new BUGwebAdminSystemServlet();
  softwareServlet=new BUGwebAdminSoftwareServlet();
  bugnetServlet=new BUGwebAdminBUGnetServlet();
  utilsServlet=new BUGwebAdminUtilsServlet();
  imageServlet=new BUGwebFileServlet();
  service.register(context,""String_Node_Str"",mainServlet);
  service.register(context,""String_Node_Str"",hardwareServlet);
  service.register(context,""String_Node_Str"",systemServlet);
  service.register(context,""String_Node_Str"",softwareServlet);
  service.register(context,""String_Node_Str"",bugnetServlet);
  service.register(context,""String_Node_Str"",utilsServlet);
  service.register(context,""String_Node_Str"",imageServlet);
  try {
    moduleTracker=new ServiceTracker(context,FilterUtil.generateServiceFilter(context,new String[]{IModuleControl.class.getName()}),new BUGwebAdminModuleControlServiceTracker(context));
    moduleTracker.open();
  }
 catch (  InvalidSyntaxException e) {
  }
}",0.995777027027027
180163,"public URL getResource(String path){
  int slash=path.indexOf('/',1);
  String file=path;
  if (slash > -1) {
    file=path.substring(slash);
  }
  return context.getBundle().getResource(getResourcePath() + file);
}","public URL getResource(String path){
  int slash=path.indexOf('/',1);
  String file=path;
  if (slash > -1) {
    file=path.substring(slash);
  }
  return context.getBundle().getResource(getResourcePath() + ""String_Node_Str"" + file);
}",0.9555555555555556
180164,"public TemplateModelRoot get(RequestParameters params,HttpServletRequest req,HttpServletResponse resp){
  String file_path, file_title, file_type, file_last_modified, file_content;
  long file_size;
  boolean is_image=false;
  boolean is_text=false;
  file_type=""String_Node_Str"";
  file_last_modified=""String_Node_Str"";
  file_content=""String_Node_Str"";
  file_size=0;
  file_path=req.getContextPath();
  file_path=htmlSpaceCheck(file_path);
  file_title=file_path.substring(file_path.lastIndexOf(""String_Node_Str"") + 1);
  if (file_title.equals(""String_Node_Str""))   file_title=""String_Node_Str"";
  file_path=parseFilePath(req.getContextPath());
  file_path=htmlSpaceCheck(file_path);
  if (file_path.compareTo(""String_Node_Str"") != 0) {
    file=new File(file_path);
    if (file.exists()) {
      file_type=getMimeType(file_path);
      file_size=file.length();
      DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
      java.util.Date date=new java.util.Date(file.lastModified());
      file_last_modified=dateFormat.format(date);
      is_image=file_type.indexOf(""String_Node_Str"") > -1;
      if (!is_image) {
        is_text=isText(file);
        if (is_text) {
          FileInputStream fis=null;
          BufferedInputStream bis=null;
          DataInputStream dis=null;
          try {
            fis=new FileInputStream(file);
            bis=new BufferedInputStream(fis);
            dis=new DataInputStream(bis);
            file_content=""String_Node_Str"";
            while (dis.available() != 0) {
              file_content+=encodeHTML(dis.readLine()) + ""String_Node_Str"";
            }
          }
 catch (          FileNotFoundException e) {
            LogManager.logDebug(this.getClass().getName() + ""String_Node_Str"" + e.getMessage());
          }
catch (          IOException e) {
            LogManager.logDebug(this.getClass().getName() + ""String_Node_Str"" + e.getMessage());
          }
 finally {
            try {
              if (fis != null)               fis.close();
              if (bis != null)               bis.close();
              if (dis != null)               dis.close();
            }
 catch (            IOException e) {
              LogManager.logDebug(this.getClass().getName() + ""String_Node_Str"" + e.getMessage());
            }
          }
        }
 else {
          file_type=""String_Node_Str"";
        }
      }
    }
 else {
      file_title=""String_Node_Str"";
    }
  }
  SimpleHash root=new SimpleHash();
  root.put(""String_Node_Str"",file_title);
  root.put(""String_Node_Str"",file_path);
  root.put(""String_Node_Str"",file_type);
  root.put(""String_Node_Str"",file_last_modified);
  root.put(""String_Node_Str"",file_content);
  root.put(""String_Node_Str"",file_size / 1000);
  root.put(""String_Node_Str"",is_image + ""String_Node_Str"");
  root.put(""String_Node_Str"",is_text + ""String_Node_Str"");
  return root;
}","public TemplateModelRoot get(RequestParameters params,HttpServletRequest req,HttpServletResponse resp){
  String file_path, file_title, file_type, file_last_modified, file_content;
  long file_size;
  boolean is_image=false;
  boolean is_text=false;
  file_type=""String_Node_Str"";
  file_last_modified=""String_Node_Str"";
  file_content=""String_Node_Str"";
  file_size=0;
  file_path=req.getQueryString();
  if (file_path == null)   file_path=""String_Node_Str"";
  file_path=htmlSpaceCheck(file_path);
  file_title=file_path.substring(file_path.lastIndexOf(""String_Node_Str"") + 1);
  file_path=req.getQueryString();
  if (file_path == null)   file_path=""String_Node_Str"";
  file_path=parseFilePath(req.getContextPath());
  file_path=htmlSpaceCheck(file_path);
  if (file_path.compareTo(""String_Node_Str"") != 0) {
    file=new File(file_path);
    if (file.exists()) {
      file_type=getMimeType(file_path);
      file_size=file.length();
      DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
      java.util.Date date=new java.util.Date(file.lastModified());
      file_last_modified=dateFormat.format(date);
      is_image=file_type.indexOf(""String_Node_Str"") > -1;
      if (!is_image) {
        is_text=isText(file);
        if (is_text) {
          FileInputStream fis=null;
          BufferedInputStream bis=null;
          DataInputStream dis=null;
          try {
            fis=new FileInputStream(file);
            bis=new BufferedInputStream(fis);
            dis=new DataInputStream(bis);
            file_content=""String_Node_Str"";
            while (dis.available() != 0) {
              file_content+=encodeHTML(dis.readLine()) + ""String_Node_Str"";
            }
          }
 catch (          FileNotFoundException e) {
            LogManager.logDebug(this.getClass().getName() + ""String_Node_Str"" + e.getMessage());
          }
catch (          IOException e) {
            LogManager.logDebug(this.getClass().getName() + ""String_Node_Str"" + e.getMessage());
          }
 finally {
            try {
              if (fis != null)               fis.close();
              if (bis != null)               bis.close();
              if (dis != null)               dis.close();
            }
 catch (            IOException e) {
              LogManager.logDebug(this.getClass().getName() + ""String_Node_Str"" + e.getMessage());
            }
          }
        }
 else {
          file_type=""String_Node_Str"";
        }
      }
    }
 else {
      file_title=""String_Node_Str"";
    }
  }
  SimpleHash root=new SimpleHash();
  root.put(""String_Node_Str"",file_title);
  root.put(""String_Node_Str"",file_path);
  root.put(""String_Node_Str"",file_type);
  root.put(""String_Node_Str"",file_last_modified);
  root.put(""String_Node_Str"",file_content);
  root.put(""String_Node_Str"",file_size / 1000);
  root.put(""String_Node_Str"",is_image + ""String_Node_Str"");
  root.put(""String_Node_Str"",is_text + ""String_Node_Str"");
  return root;
}",0.9657182036338704
180165,"/** 
 * Parses out the full file path from the url
 * @param path - the full url
 * @return - the filepath
 */
private String parseFilePath(String path){
  int index=path.indexOf(""String_Node_Str"");
  String result=path.substring(index + ""String_Node_Str"".length());
  if (result.compareTo(""String_Node_Str"") == 0) {
    return result;
  }
 else {
    result=result.substring(1);
  }
  return result;
}","/** 
 * Parses out the full file path from the url
 * @param path - the full url
 * @return - the filepath
 */
private String parseFilePath(String path){
  if (path.length() == 0)   return path;
  int index=path.indexOf(""String_Node_Str"");
  String result=path.substring(index + ""String_Node_Str"".length());
  if (result.compareTo(""String_Node_Str"") == 0) {
    return result;
  }
 else {
    result=result.substring(1);
  }
  return result;
}",0.9514792899408284
180166,"public static LogService getLog(){
  return log;
}","/** 
 * @return Log Service
 */
public static LogService getLog(){
  return log;
}",0.7575757575757576
180167,"public void start(BundleContext bundleContext) throws Exception {
  Activator.context=bundleContext;
  log=LogServiceUtil.getLogService(bundleContext);
  st=ServiceTrackerUtil.openServiceTracker(bundleContext,this,services);
  serviceMap=new Hashtable();
}","public void start(BundleContext bundleContext) throws Exception {
  Activator.context=bundleContext;
  log=LogServiceUtil.getLogService(bundleContext);
  serviceMap=new Hashtable<String,PublicWSProvider>();
  st=ServiceTrackerUtil.openServiceTracker(bundleContext,this,services);
}",0.8417132216014898
180168,"public static BundleContext getContext(){
  return context;
}","/** 
 * @return BundleContext
 */
public static BundleContext getContext(){
  return context;
}",0.782051282051282
180169,"public WSHtmlServlet(BundleContext context,Hashtable servicesMap,ConfigurationAdmin configAdmin){
  super(context,servicesMap,configAdmin);
}","/** 
 * @param context <String, PublicWSProvider>
 * @param servicesMap map of services
 * @param configAdmin instance of ConfigAdmin
 */
public WSHtmlServlet(BundleContext context,Map<String,PublicWSProvider> servicesMap,ConfigurationAdmin configAdmin){
  super(context,servicesMap,configAdmin);
}",0.6104783599088838
180170,"private String getRequestInfo(PublicWSProvider pubService,PublicWSDefinition def,String reqType){
  String out=""String_Node_Str"" + reqType + ""String_Node_Str""+ ""String_Node_Str""+ def.getReturnType()+ ""String_Node_Str"";
  if (def.getParameters() != null)   out+=""String_Node_Str"" + def.getParameters().toString();
  out+=""String_Node_Str"";
  return out;
}","/** 
 * @param pubService PublicWSProvider
 * @param def PublicWSDefinition
 * @param reqType request type
 * @return request info
 */
private String getRequestInfo(PublicWSProvider pubService,PublicWSDefinition def,String reqType){
  String out=""String_Node_Str"" + reqType + ""String_Node_Str""+ ""String_Node_Str""+ def.getReturnType()+ ""String_Node_Str"";
  if (def.getParameters() != null)   out+=""String_Node_Str"" + def.getParameters().toString();
  out+=""String_Node_Str"";
  return out;
}",0.505338078291815
180171,"private String getServicesListAsHtml(){
  Map servicesMap=getServiceMap();
  String buffer=""String_Node_Str"";
  for (Iterator i=servicesMap.keySet().iterator(); i.hasNext(); ) {
    String key=(String)i.next();
    Object serviceObj=servicesMap.get(key);
    buffer+=""String_Node_Str"";
    if (serviceObj instanceof PublicWSProvider) {
      PublicWSProvider pubService=(PublicWSProvider)serviceObj;
      boolean isServiceEnabled=false;
      try {
        isServiceEnabled=isServiceEnabled(getConfigurationAdmin(),pubService.getPublicName());
      }
 catch (      IOException e) {
      }
      if (!isServiceEnabled)       continue;
      buffer+=""String_Node_Str"" + pubService.getPublicName() + ""String_Node_Str""+ ""String_Node_Str""+ pubService.getPublicName()+ ""String_Node_Str"";
      buffer+=pubService.getDescription() + ""String_Node_Str"";
      buffer+=""String_Node_Str"" + ""String_Node_Str"";
      PublicWSDefinition def=pubService.discover(PublicWSProvider2.GET);
      if (def != null) {
        buffer+=getRequestInfo(pubService,def,""String_Node_Str"");
      }
      def=pubService.discover(PublicWSProvider2.POST);
      if (def != null) {
        buffer+=getRequestInfo(pubService,def,""String_Node_Str"");
      }
      def=pubService.discover(PublicWSProvider2.DELETE);
      if (def != null) {
        buffer+=getRequestInfo(pubService,def,""String_Node_Str"");
      }
      def=pubService.discover(PublicWSProvider2.PUT);
      if (def != null) {
        buffer+=getRequestInfo(pubService,def,""String_Node_Str"");
      }
    }
 else {
      buffer+=key;
    }
    buffer+=""String_Node_Str"";
  }
  buffer+=""String_Node_Str"";
  return buffer;
}","/** 
 * @return services as html
 */
private String getServicesListAsHtml(){
  Map<String,PublicWSProvider> servicesMap=getServiceMap();
  String buffer=""String_Node_Str"";
  for (  Map.Entry<String,PublicWSProvider> e : servicesMap.entrySet()) {
    buffer+=""String_Node_Str"";
    if (e.getValue() instanceof PublicWSProvider) {
      PublicWSProvider pubService=(PublicWSProvider)e.getValue();
      boolean isServiceEnabled=false;
      try {
        isServiceEnabled=isServiceEnabled(getConfigurationAdmin(),pubService.getPublicName());
      }
 catch (      IOException exc) {
      }
      if (!isServiceEnabled)       continue;
      buffer+=""String_Node_Str"" + pubService.getPublicName() + ""String_Node_Str""+ ""String_Node_Str""+ pubService.getPublicName()+ ""String_Node_Str"";
      buffer+=pubService.getDescription() + ""String_Node_Str"";
      buffer+=""String_Node_Str"" + ""String_Node_Str"";
      PublicWSDefinition def=pubService.discover(PublicWSProvider2.GET);
      if (def != null) {
        buffer+=getRequestInfo(pubService,def,""String_Node_Str"");
      }
      def=pubService.discover(PublicWSProvider2.POST);
      if (def != null) {
        buffer+=getRequestInfo(pubService,def,""String_Node_Str"");
      }
      def=pubService.discover(PublicWSProvider2.DELETE);
      if (def != null) {
        buffer+=getRequestInfo(pubService,def,""String_Node_Str"");
      }
      def=pubService.discover(PublicWSProvider2.PUT);
      if (def != null) {
        buffer+=getRequestInfo(pubService,def,""String_Node_Str"");
      }
    }
 else {
      buffer+=e.getKey();
    }
    buffer+=""String_Node_Str"";
  }
  buffer+=""String_Node_Str"";
  return buffer;
}",0.838456901748041
180172,"/** 
 * @param context BundleContext used to load extensions contributed by bundles.
 * @return The BMIDevices attached at the time of the call.  If a given array element is null, no module is attached to that slot.
 * @throws IOException IOException on File I/O error
 */
public static BMIDevice[] getDevices(BundleContext context) throws IOException {
  BMIDevice[] devs=new BMIDevice[BMIDevice.MAX_BMI_SLOTS];
  for (int i=0; i < BMIDevice.MAX_BMI_SLOTS; ++i) {
    File prodFile=getBMIDeviceRoot(i);
    if (!validBMIDeviceRoot(prodFile)) {
      devs[i]=null;
      continue;
    }
    devs[i]=BMIDevice.createFromSYSDirectory(context,prodFile,i);
  }
  return devs;
}","/** 
 * @param context BundleContext used to load extensions contributed by bundles.
 * @return The BMIDevices attached at the time of the call.  If a given array element is null, no module is attached to that slot.
 * @throws IOException IOException on File I/O error
 */
public static BMIDevice[] getDevices(BundleContext context) throws IOException {
  BMIDevice[] devs=new BMIDevice[BMIDevice.MAX_BMI_SLOTS];
  for (int i=0; i < BMIDevice.MAX_BMI_SLOTS; ++i) {
    File prodFile=getBMIDeviceRoot(i);
    if (prodFile == null) {
      devs[i]=null;
      continue;
    }
    devs[i]=BMIDevice.createFromSYSDirectory(context,prodFile,i);
  }
  return devs;
}",0.978244561140285
180173,"/** 
 * @param i slot index
 * @return valid directory of BMI device root
 * @throws IOException 
 */
private static File getBMIDeviceRoot(int i) throws IOException {
  File root=new File(""String_Node_Str"" + i + ""String_Node_Str""+ i);
  if (!root.exists() || root.isFile())   throw new IOException(""String_Node_Str"" + root);
  return root;
}","/** 
 * @param i slot index
 * @return valid directory of BMI device root
 * @throws IOException 
 */
private static File getBMIDeviceRoot(int i) throws IOException {
  File root=new File(""String_Node_Str"".replace(""String_Node_Str"",""String_Node_Str"" + i));
  if (!root.exists() || root.isFile() || root.listFiles().length == 0)   return null;
  return root;
}",0.7685714285714286
180174,"/** 
 * @param device sysfs device
 */
public BMIModuleEvent(BMIDevice device){
  this.moduleId=device.getProductId();
  this.version=""String_Node_Str"" + device.getRevision();
  this.slot=device.getSlot();
  this.event=EVENT_TYPE.INSERT;
}","/** 
 * @param device sysfs device
 */
public BMIModuleEvent(BMIDevice device){
  this.bmiDevice=device;
  this.moduleId=device.getProductId();
  this.version=""String_Node_Str"" + device.getRevision();
  this.slot=device.getSlot();
  this.event=EVENT_TYPE.INSERT;
}",0.9502982107355864
180175,"/** 
 * See http://lurcher/wiki/BMI_-_Runtime_Interface#Message_Definition.
 * @return true if parse successful
 * @throws IOException on File I/O error
 */
public boolean parse() throws IOException {
  String[] toks=raw.split(""String_Node_Str"");
  if (toks.length != 4) {
    return false;
  }
  this.moduleId=toks[0].trim();
  this.version=toks[1].trim();
  try {
    this.slot=Integer.parseInt(toks[2]);
  }
 catch (  NumberFormatException e) {
    return false;
  }
  String action=toks[3].trim().toUpperCase();
  if (action.equals(""String_Node_Str"")) {
    this.event=EVENT_TYPE.INSERT;
    this.bmiDevice=BMIDeviceHelper.getDevice(Activator.getContext(),slot);
  }
 else   if (action.equals(""String_Node_Str"")) {
    this.event=EVENT_TYPE.REMOVE;
  }
 else {
    return false;
  }
  return true;
}","/** 
 * See http://lurcher/wiki/BMI_-_Runtime_Interface#Message_Definition.
 * @return true if parse successful
 * @throws IOException on File I/O error
 */
private boolean parse() throws IOException {
  String[] toks=raw.split(""String_Node_Str"");
  if (toks.length != 4) {
    return false;
  }
  this.moduleId=toks[0].trim();
  this.version=toks[1].trim();
  try {
    this.slot=Integer.parseInt(toks[2]);
  }
 catch (  NumberFormatException e) {
    return false;
  }
  String action=toks[3].trim().toUpperCase();
  if (action.equals(""String_Node_Str"")) {
    this.event=EVENT_TYPE.INSERT;
    this.bmiDevice=BMIDeviceHelper.getDevice(Activator.getContext(),slot);
  }
 else   if (action.equals(""String_Node_Str"")) {
    this.event=EVENT_TYPE.REMOVE;
  }
 else {
    return false;
  }
  return true;
}",0.9931549471064096
180176,"public void run(){
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + pipeFilename);
  while (!Thread.currentThread().isInterrupted()) {
    try {
      BufferedReader reader=new BufferedReader(new FileReader(pipeFilename));
      String line=null;
      while ((line=reader.readLine()) != null) {
        if (line.equals(POISON_PILL)) {
          return;
        }
        if (logService != null) {
          logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + line);
        }
        BMIModuleEvent m=new BMIModuleEvent(line);
        if (m.parse()) {
          eventHandler.handleEvent(m);
        }
 else {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + line);
        }
      }
    }
 catch (    FileNotFoundException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
catch (    IOException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
 finally {
      IOUtils.closeQuietly(stream);
    }
  }
}","public void run(){
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + pipeFilename);
  while (!Thread.currentThread().isInterrupted()) {
    try {
      BufferedReader reader=new BufferedReader(new FileReader(pipeFilename));
      String line=null;
      while ((line=reader.readLine()) != null) {
        if (line.equals(POISON_PILL)) {
          return;
        }
        if (logService != null) {
          logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + line);
        }
        try {
          BMIModuleEvent m=new BMIModuleEvent(line);
          eventHandler.handleEvent(m);
        }
 catch (        IOException e) {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + line);
        }
      }
    }
 catch (    FileNotFoundException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
catch (    IOException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
 finally {
      IOUtils.closeQuietly(stream);
    }
  }
}",0.9226069246435844
180177,"public void setup() throws Exception {
  String devnode_gps=""String_Node_Str"" + Integer.toString(getSlotId());
  String devnode_gpscontrol=""String_Node_Str"" + Integer.toString(getSlotId());
  GPS gps=new GPS();
  CharDeviceUtils.openDeviceWithRetry(gps,devnode_gps,FCNTL_H.O_RDWR | FCNTL_H.O_NONBLOCK,2);
  int result=gps.init();
  if (result < 0) {
    throw new RuntimeException(""String_Node_Str"" + devnode_gpscontrol);
  }
  gpsControl=new GPSControl();
  getLog().log(LogService.LOG_DEBUG,""String_Node_Str"" + devnode_gpscontrol);
  CharDeviceUtils.openDeviceWithRetry(gpsControl,devnode_gpscontrol,2);
  gps.close();
  getLog().log(LogService.LOG_DEBUG,""String_Node_Str"" + devnode_gps);
  gpsInputStream=new FileInputStream(devnode_gps);
  nmeaProvider=new NMEASentenceProvider(gpsInputStream,context);
}","public void setup() throws Exception {
  String devnode_gps=""String_Node_Str"" + Integer.toString(getSlotId());
  String devnode_gpscontrol=""String_Node_Str"" + Integer.toString(getSlotId());
  GPS gps=new GPS();
  CharDeviceUtils.openDeviceWithRetry(gps,devnode_gps,FCNTL_H.O_RDWR | FCNTL_H.O_NONBLOCK,2);
  int result=gps.init();
  if (result < 0) {
    throw new RuntimeException(""String_Node_Str"" + devnode_gpscontrol);
  }
  gpsControl=new GPSControl();
  getLog().log(LogService.LOG_DEBUG,""String_Node_Str"" + devnode_gpscontrol);
  CharDeviceUtils.openDeviceWithRetry(gpsControl,devnode_gpscontrol,2);
  gps.close();
  getLog().log(LogService.LOG_DEBUG,""String_Node_Str"" + devnode_gps);
  gpsInputStream=new FileInputStream(devnode_gps);
  nmeaProvider=new NMEASentenceProvider(gpsInputStream,context,getLog());
}",0.9944615384615384
180178,"private void notifySubscribers(AbstractNMEASentence objSentence){
  if (subscribers == null || subscribers.size() == 0) {
    return;
  }
synchronized (subscribers) {
    for (Iterator i=subscribers.iterator(); i.hasNext(); ) {
      Object subscriber=i.next();
      try {
        if (subscriber instanceof INMEASentenceSubscriber) {
          INMEASentenceSubscriber sub=(INMEASentenceSubscriber)subscriber;
          sub.sentenceReceived(objSentence);
        }
 else         if (subscriber instanceof IPositionSubscriber && objSentence instanceof RMC) {
          IPositionSubscriber sub=(IPositionSubscriber)subscriber;
          sub.positionUpdate(calculatePosition((RMC)objSentence));
        }
      }
 catch (      RuntimeException e) {
        LogServiceUtil.logBundleException(log,""String_Node_Str"",e);
      }
    }
  }
}","private void notifySubscribers(AbstractNMEASentence objSentence){
  if (subscribers == null || subscribers.size() == 0) {
    return;
  }
synchronized (subscribers) {
    for (Iterator<Object> i=subscribers.iterator(); i.hasNext(); ) {
      Object subscriber=i.next();
      try {
        if (subscriber instanceof INMEASentenceSubscriber) {
          INMEASentenceSubscriber sub=(INMEASentenceSubscriber)subscriber;
          sub.sentenceReceived(objSentence);
        }
 else         if (subscriber instanceof IPositionSubscriber && objSentence instanceof RMC) {
          IPositionSubscriber sub=(IPositionSubscriber)subscriber;
          sub.positionUpdate(calculatePosition((RMC)objSentence));
        }
      }
 catch (      RuntimeException e) {
        LogServiceUtil.logBundleException(log,""String_Node_Str"",e);
      }
    }
  }
}",0.995221027479092
180179,"public void serviceChanged(ServiceEvent event){
switch (event.getType()) {
case ServiceEvent.REGISTERED:
    if (subscribers == null) {
      subscribers=new ArrayList();
    }
  subscribers.add(context.getService(event.getServiceReference()));
break;
case ServiceEvent.UNREGISTERING:
if (subscribers != null) subscribers.remove(context.getService(event.getServiceReference()));
break;
}
}","public void serviceChanged(ServiceEvent event){
switch (event.getType()) {
case ServiceEvent.REGISTERED:
    if (subscribers == null) {
      subscribers=new ArrayList<Object>();
    }
  subscribers.add(context.getService(event.getServiceReference()));
break;
case ServiceEvent.UNREGISTERING:
if (subscribers != null) subscribers.remove(context.getService(event.getServiceReference()));
break;
}
}",0.989821882951654
180180,"public NMEASentenceProvider(InputStream nmeaStream,BundleContext context){
  this.nmeaStream=nmeaStream;
  this.context=context;
  this.log=LogServiceUtil.getLogService(context);
  if (context.getProperty(SLEEP_INTERVAL_PROPERTY_KEY) == null) {
    readSleepInterval=DEFAULT_SLEEP_INTERVAL;
  }
 else {
    readSleepInterval=Integer.parseInt(context.getProperty(SLEEP_INTERVAL_PROPERTY_KEY));
  }
}","public NMEASentenceProvider(InputStream nmeaStream,BundleContext context,LogService log){
  this.nmeaStream=nmeaStream;
  this.context=context;
  this.log=log;
  if (context.getProperty(SLEEP_INTERVAL_PROPERTY_KEY) == null) {
    readSleepInterval=DEFAULT_SLEEP_INTERVAL;
  }
 else {
    readSleepInterval=Integer.parseInt(context.getProperty(SLEEP_INTERVAL_PROPERTY_KEY));
  }
}",0.5225225225225225
180181,"/** 
 * @param context if context is null, it will return a log service that uses stdout.
 * @return Either the first LogService available in the runtime if availableor a SysoutLogService.
 */
public static LogService getLogService(BundleContext context){
  final LogService logService;
  boolean created=false;
  ServiceReference sr=null;
  if (context != null)   sr=context.getServiceReference(LogService.class.getName());
  if (sr != null) {
    logService=(LogService)context.getService(sr);
  }
 else {
    logService=new LogService(){
      public void log(      int level,      String message){
        System.out.println(levelString(level) + message);
      }
      public void log(      int level,      String message,      Throwable exception){
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        }
        exception.printStackTrace(new PrintWriter(System.out,true));
      }
      public void log(      ServiceReference sr,      int level,      String message){
        System.out.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        }
      }
      public void log(      ServiceReference sr,      int level,      String message,      Throwable exception){
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        exception.printStackTrace(new PrintWriter(System.out,true));
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
          exception.printStackTrace(new PrintWriter(System.err,true));
        }
      }
      private String levelString(      int level){
switch (level) {
case LogService.LOG_DEBUG:
          return ""String_Node_Str"";
case LogService.LOG_ERROR:
        return ""String_Node_Str"";
case LogService.LOG_INFO:
      return ""String_Node_Str"";
case LogService.LOG_WARNING:
    return ""String_Node_Str"";
default :
  return ""String_Node_Str"";
}
}
}
;
created=true;
}
if (created) {
context.registerService(LogService.class.getName(),logService,null);
}
return logService;
}","/** 
 * @param context if context is null, it will return a log service that uses stdout.
 * @return Either the first LogService available in the runtime if availableor a SysoutLogService.
 */
public static LogService getLogService(BundleContext context){
  final LogService logService;
  boolean created=false;
  ServiceReference sr=null;
  if (context != null)   sr=context.getServiceReference(LogService.class.getName());
  if (sr != null) {
    logService=(LogService)context.getService(sr);
  }
 else {
    logService=new LogService(){
      public void log(      int level,      String message){
        System.out.println(levelString(level) + message);
      }
      public void log(      int level,      String message,      Throwable exception){
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        }
        exception.printStackTrace(new PrintWriter(System.out,true));
      }
      public void log(      ServiceReference sr,      int level,      String message){
        System.out.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + ""String_Node_Str"" + sr.toString()+ ""String_Node_Str""+ message);
        }
      }
      public void log(      ServiceReference sr,      int level,      String message,      Throwable exception){
        System.out.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
        exception.printStackTrace(new PrintWriter(System.out,true));
        if (level == LogService.LOG_ERROR) {
          System.err.println(levelString(level) + message + ""String_Node_Str""+ exception.toString());
          exception.printStackTrace(new PrintWriter(System.err,true));
        }
      }
      private String levelString(      int level){
switch (level) {
case LogService.LOG_DEBUG:
          return ""String_Node_Str"";
case LogService.LOG_ERROR:
        return ""String_Node_Str"";
case LogService.LOG_INFO:
      return ""String_Node_Str"";
case LogService.LOG_WARNING:
    return ""String_Node_Str"";
default :
  return ""String_Node_Str"";
}
}
}
;
created=true;
}
if (created && context != null) {
context.registerService(LogService.class.getName(),logService,null);
}
return logService;
}",0.9961530674225552
180182,"/** 
 * Discover attached BMI devices and send INSERT events into system.
 * @throws IOException on File I/O error
 */
private void coldPlug() throws IOException {
  List<BMIDevice> devices=Arrays.asList(BMIDeviceHelper.getDevices(context));
  if (devices != null) {
    logService.log(LogService.LOG_DEBUG,""String_Node_Str"");
    for (    BMIDevice bmiMessage : devices) {
      logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + bmiMessage.toString());
      eventHandler.handleEvent(new BMIModuleEvent(bmiMessage));
    }
  }
 else {
    logService.log(LogService.LOG_DEBUG,""String_Node_Str"");
  }
}","/** 
 * Discover attached BMI devices and send INSERT events into system.
 * @throws IOException on File I/O error
 */
private void coldPlug() throws IOException {
  List<BMIDevice> devices=Arrays.asList(BMIDeviceHelper.getDevices(context));
  if (devices != null) {
    logService.log(LogService.LOG_DEBUG,""String_Node_Str"");
    for (    BMIDevice bmiMessage : devices) {
      if (bmiMessage != null) {
        logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + bmiMessage.toString());
        eventHandler.handleEvent(new BMIModuleEvent(bmiMessage));
      }
    }
  }
 else {
    logService.log(LogService.LOG_DEBUG,""String_Node_Str"");
  }
}",0.9650238473767886
180183,"public void start() throws Exception {
  Dictionary modProperties=getCommonProperties();
  modProperties.put(""String_Node_Str"",suspended ? ""String_Node_Str"" : ""String_Node_Str"");
  moduleRef=context.registerService(IModuleControl.class.getName(),this,modProperties);
  registerService(IModuleLEDController.class.getName(),this,createExgtendedServiceProperties());
  ML8953AccelerometerImplementation ml8953Control=new ML8953AccelerometerImplementation();
  registerService(IML8953Accelerometer.class.getName(),ml8953Control,modProperties);
  registerService(PublicWSProvider.class.getName(),new AccelerationWS(ml8953Control,getLog()),modProperties);
  registerService(ILCDModuleControl.class.getName(),this,createExgtendedServiceProperties());
  registerService(IModuleDisplay.class.getName(),LCDModlet.this,createExgtendedServiceProperties());
}","public void start() throws Exception {
  Dictionary modProperties=getCommonProperties();
  modProperties.put(""String_Node_Str"",suspended ? ""String_Node_Str"" : ""String_Node_Str"");
  moduleRef=context.registerService(IModuleControl.class.getName(),this,modProperties);
  ML8953AccelerometerImplementation ml8953Control=new ML8953AccelerometerImplementation();
  registerService(IML8953Accelerometer.class.getName(),ml8953Control,modProperties);
  registerService(PublicWSProvider.class.getName(),new AccelerationWS(ml8953Control,getLog()),modProperties);
  registerService(ILCDModuleControl.class.getName(),this,createExtendedServiceProperties());
  registerService(IModuleDisplay.class.getName(),LCDModlet.this,createExtendedServiceProperties());
}",0.9378531073446328
180184,"private void registerService(ServiceReference sr,int eventType){
  IModletFactory factory=(IModletFactory)context.getService(sr);
  validateFactory(factory);
switch (eventType) {
case ServiceEvent.REGISTERED:
    if (!modletFactories.containsKey(factory.getModuleId())) {
      modletFactories.put(factory.getModuleId(),new ArrayList<IModletFactory>());
    }
 else {
      logService.log(LogService.LOG_WARNING,""String_Node_Str"" + factory.getName() + ""String_Node_Str"");
      return;
    }
  List<IModletFactory> ml=modletFactories.get(factory.getModuleId());
if (!ml.contains(factory)) {
  ml.add(factory);
}
logService.log(LogService.LOG_INFO,""String_Node_Str"" + factory.getName() + ""String_Node_Str""+ factory.getModuleId()+ ""String_Node_Str"");
if (context.getProperty(""String_Node_Str"") != null && context.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
try {
createModlets(factory);
}
 catch (Exception e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getMessage());
}
}
break;
case ServiceEvent.UNREGISTERING:
if (modletFactories.containsKey(factory.getModuleId())) {
modletFactories.get(factory.getModuleId()).remove(factory);
logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + factory.getName() + ""String_Node_Str"");
}
 else {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + factory.getModuleId());
}
break;
default :
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + eventType);
}
}","/** 
 * @param sr ServiceReference
 * @param eventType type of event
 */
private void registerService(ServiceReference sr,int eventType){
  IModletFactory factory=(IModletFactory)context.getService(sr);
  validateFactory(factory);
switch (eventType) {
case ServiceEvent.REGISTERED:
    if (!modletFactories.containsKey(factory.getModuleId())) {
      modletFactories.put(factory.getModuleId(),new ArrayList<IModletFactory>());
    }
 else {
      logService.log(LogService.LOG_WARNING,""String_Node_Str"" + factory.getName() + ""String_Node_Str"");
      return;
    }
  List<IModletFactory> ml=modletFactories.get(factory.getModuleId());
if (!ml.contains(factory)) {
  ml.add(factory);
}
logService.log(LogService.LOG_INFO,""String_Node_Str"" + factory.getName() + ""String_Node_Str""+ factory.getModuleId()+ ""String_Node_Str"");
if (context.getProperty(""String_Node_Str"") != null && context.getProperty(""String_Node_Str"").equals(""String_Node_Str"")) {
try {
createModlets(factory);
}
 catch (Exception e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getMessage());
}
}
break;
case ServiceEvent.UNREGISTERING:
if (modletFactories.containsKey(factory.getModuleId())) {
modletFactories.get(factory.getModuleId()).remove(factory);
logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + factory.getName() + ""String_Node_Str"");
}
 else {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + factory.getModuleId());
}
break;
default :
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + eventType);
}
}",0.9752290464879538
180185,"public void start(BundleContext context) throws Exception {
  this.context=context;
  modletFactories=new Hashtable<String,List<IModletFactory>>();
  activeModlets=new Hashtable<String,List<IModlet>>();
  logService=LogServiceUtil.getLogService(context);
  context.addServiceListener(this,FilterUtil.generateServiceFilter(IModletFactory.class.getName()));
  registerExistingServices();
  pipeFilename=context.getProperty(PIPE_FILENAME_KEY);
  if (pipeFilename == null || pipeFilename.length() == 0)   pipeFilename=DEFAULT_PIPE_FILENAME;
  createPipe(pipeFilename);
  eventHandler=new BMIModuleEventHandler(context,logService,modletFactories,activeModlets);
  pipeReader=new PipeReader(pipeFilename,eventHandler,logService);
  coldPlug();
  pipeReader.start();
}","public void start(BundleContext context) throws Exception {
  Activator.context=context;
  modletFactories=new Hashtable<String,List<IModletFactory>>();
  activeModlets=new Hashtable<String,List<IModlet>>();
  logService=LogServiceUtil.getLogService(context);
  context.addServiceListener(this,FilterUtil.generateServiceFilter(IModletFactory.class.getName()));
  registerExistingServices();
  pipeFilename=context.getProperty(PIPE_FILENAME_KEY);
  if (pipeFilename == null || pipeFilename.length() == 0)   pipeFilename=DEFAULT_PIPE_FILENAME;
  createPipe(pipeFilename);
  eventHandler=new BMIModuleEventHandler(context,logService,modletFactories,activeModlets);
  pipeReader=new PipeReader(pipeFilename,eventHandler,logService);
  context.addFrameworkListener(this);
}",0.9522563767168084
180186,"public static BundleContext getContext(){
  return context;
}","/** 
 * @return BundleContext
 */
public static BundleContext getContext(){
  return context;
}",0.782051282051282
180187,"/** 
 * This method is responsible for loading and starting any bundles that provide Modlets for given module type. After bundle(s) are started, those bundles expose IModulet services. The BMI activator then listens for modlets. Upon new modlet creation, the setup is called.
 * @param event event to handle
 */
public void handleEvent(BMIModuleEvent event){
  if (!modletFactories.containsKey(event.getModuleId())) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + event.getModuleId());
    return;
  }
  try {
    List<IModlet> ml;
switch (event.getType()) {
case INSERT:
      for (      IModletFactory mf : modletFactories.get(event.getModuleId())) {
        IModlet m=mf.createModlet(context,event.getSlot(),event.getBMIDevice());
        try {
          m.setup();
        }
 catch (        Exception e) {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + mf.getName() + ""String_Node_Str""+ e.getMessage());
          continue;
        }
        m.start();
        logService.log(LogService.LOG_INFO,""String_Node_Str"" + mf.getName() + ""String_Node_Str"");
        if (!activeModlets.containsKey(m.getModuleId())) {
          activeModlets.put(m.getModuleId(),new ArrayList<IModlet>());
        }
        List<IModlet> am=activeModlets.get(m.getModuleId());
        if (!am.contains(m)) {
          am.add(m);
        }
      }
    break;
case REMOVE:
  List<IModlet> removalList=new ArrayList<IModlet>();
ml=activeModlets.get(event.getModuleId());
for (IModlet m : ml) {
if (m.getSlotId() == event.getSlot()) {
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + m.getModuleId() + ""String_Node_Str"");
  m.stop();
  removalList.add(m);
}
}
for (IModlet m : ml) ml.remove(m);
removalList.clear();
logService.log(LogService.LOG_INFO,""String_Node_Str"");
break;
}
}
 catch (BundleException e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
if (e.getNestedException() != null) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getNestedException().getClass().getName() + ""String_Node_Str""+ e.getNestedException().getMessage());
}
e.printStackTrace();
}
catch (Exception e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
}
}","/** 
 * This method is responsible for loading and starting any bundles that provide Modlets for given module type. After bundle(s) are started, those bundles expose IModulet services. The BMI activator then listens for modlets. Upon new modlet creation, the setup is called.
 * @param event event to handle
 */
public void handleEvent(BMIModuleEvent event){
  if (!modletFactories.containsKey(event.getModuleId())) {
    logService.log(LogService.LOG_ERROR,""String_Node_Str"" + event.getModuleId());
    return;
  }
  try {
    List<IModlet> ml;
switch (event.getType()) {
case INSERT:
      for (      IModletFactory mf : modletFactories.get(event.getModuleId())) {
        IModlet m=mf.createModlet(context,event.getSlot(),event.getBMIDevice());
        try {
          m.setup();
        }
 catch (        Exception e) {
          logService.log(LogService.LOG_ERROR,""String_Node_Str"" + mf.getName() + ""String_Node_Str""+ e.getMessage(),e);
          continue;
        }
        m.start();
        logService.log(LogService.LOG_INFO,""String_Node_Str"" + mf.getName() + ""String_Node_Str"");
        if (!activeModlets.containsKey(m.getModuleId())) {
          activeModlets.put(m.getModuleId(),new ArrayList<IModlet>());
        }
        List<IModlet> am=activeModlets.get(m.getModuleId());
        if (!am.contains(m)) {
          am.add(m);
        }
      }
    break;
case REMOVE:
  List<IModlet> removalList=new ArrayList<IModlet>();
ml=activeModlets.get(event.getModuleId());
for (IModlet m : ml) {
if (m.getSlotId() == event.getSlot()) {
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + m.getModuleId() + ""String_Node_Str"");
  m.stop();
  removalList.add(m);
}
}
for (IModlet m : ml) ml.remove(m);
removalList.clear();
logService.log(LogService.LOG_INFO,""String_Node_Str"");
break;
}
}
 catch (BundleException e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
if (e.getNestedException() != null) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getNestedException().getClass().getName() + ""String_Node_Str""+ e.getNestedException().getMessage());
}
e.printStackTrace();
}
catch (Exception e) {
logService.log(LogService.LOG_ERROR,""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
StringWriter sw=new StringWriter();
e.printStackTrace(new PrintWriter(sw));
logService.log(LogService.LOG_ERROR,sw.getBuffer().toString());
}
}",0.999613750482812
180188,"/** 
 * @return true if device was successfully suspended, false otherwise.
 * @throws IOException 
 */
public void suspend() throws IOException {
  println(new File(root,SUSPEND_FILENAME),""String_Node_Str"");
}","/** 
 * @throws IOException 
 */
public void suspend() throws IOException {
  println(new File(root,SUSPEND_FILENAME),""String_Node_Str"");
}",0.7965616045845272
180189,"/** 
 * @return true if device was successfully resumed, false otherwise.
 * @throws IOException 
 */
public void resume() throws IOException {
  println(new File(root,SUSPEND_FILENAME),""String_Node_Str"");
}","/** 
 * @throws IOException 
 */
public void resume() throws IOException {
  println(new File(root,SUSPEND_FILENAME),""String_Node_Str"");
}",0.8
180190,"/** 
 * Create an instance of BMIModuleProperties class using the base BMI /sys filesystem directory, for example /sys/devices/conn-m1.
 * @param directory of BMI sysfs entry
 * @param slot slot index
 * @return BMIDevice
 */
protected static BMIDevice createFromSYSDirectory(final BundleContext context,File directory,int slot){
  if (directory == null || !directory.exists() || !directory.isDirectory()) {
    return null;
  }
  final String productId=parseHexInt(getFirstLineofFile(new File(directory,""String_Node_Str"")));
  BMIDeviceNodeFactory factory;
  try {
    factory=Fn.find(new Fn.Function<ServiceReference,BMIDeviceNodeFactory>(){
      @Override public BMIDeviceNodeFactory apply(      ServiceReference element){
        if (element.getProperty(""String_Node_Str"") != null && element.getProperty(""String_Node_Str"").equals(productId))         return (BMIDeviceNodeFactory)context.getService(element);
        return null;
      }
    }
,context.getAllServiceReferences(BMIDeviceNodeFactory.class.getName(),null));
    if (factory != null)     return factory.createBMIDeviceNode(directory,slot);
  }
 catch (  InvalidSyntaxException e) {
  }
  return new BMIDevice(directory,slot);
}","/** 
 * Create an instance of BMIModuleProperties class using the base BMI /sys filesystem directory, for example /sys/devices/conn-m1.
 * @param directory of BMI sysfs entry
 * @param slot slot index
 * @return BMIDevice
 */
protected static BMIDevice createFromSYSDirectory(final BundleContext context,File directory,int slot){
  if (directory == null || !directory.exists() || !directory.isDirectory()) {
    return null;
  }
  final String productId=parseHexInt(getFirstLineofFile(new File(directory,""String_Node_Str"")));
  BMIDeviceNodeFactory factory;
  try {
    factory=Fn.find(new Fn.Function<ServiceReference,BMIDeviceNodeFactory>(){
      @Override public BMIDeviceNodeFactory apply(      ServiceReference element){
        if (element.getProperty(""String_Node_Str"") != null && element.getProperty(""String_Node_Str"").equals(productId))         return (BMIDeviceNodeFactory)context.getService(element);
        return null;
      }
    }
,context.getServiceReferences(BMIDeviceNodeFactory.class.getName(),null));
    if (factory != null)     return factory.createBMIDeviceNode(directory,slot);
  }
 catch (  InvalidSyntaxException e) {
  }
  return new BMIDevice(directory,slot);
}",0.99874213836478
180191,"public void setup() throws Exception {
  this.videoOutDevice=(VideoOutBMIDevice)BMIDeviceHelper.getDevice(context,slotId);
}","public void setup() throws Exception {
  this.videoOutDevice=(VideoOutBMIDevice)BMIDeviceHelper.getDevice(slotId);
}",0.9666666666666668
180192,"public VideoModlet(BundleContext context,int slotId,String moduleId,BMIModuleProperties properties){
  this.context=context;
  this.slotId=slotId;
  this.moduleId=moduleId;
  this.properties=properties;
  this.moduleName=""String_Node_Str"";
  this.log=LogServiceUtil.getLogService(context);
  System.out.println(""String_Node_Str"");
  this.videoOutDevice=(VideoOutDevice)BMIDeviceHelper.getDevice(slotId);
}","public VideoModlet(BundleContext context,int slotId,String moduleId,BMIModuleProperties properties){
  this.context=context;
  this.slotId=slotId;
  this.moduleId=moduleId;
  this.properties=properties;
  this.moduleName=""String_Node_Str"";
  this.log=LogServiceUtil.getLogService(context);
  System.out.println(""String_Node_Str"");
}",0.9009497964721844
180193,"public void setup() throws Exception {
}","public void setup() throws Exception {
  this.videoOutDevice=(VideoOutDevice)BMIDeviceHelper.getDevice(slotId);
}",0.5228758169934641
180194,"static BundleContext getContext(){
  return context;
}","public static BundleContext getContext(){
  return context;
}",0.9391304347826088
180195,"public ModuleServlet(){
  this.modules=new IModuleControl[4];
  for (int i=0; i < modules.length; ++i)   modules[i]=null;
}","public ModuleServlet(){
  context=Activator.getContext();
  this.modules=new IModuleControl[4];
  for (int i=0; i < modules.length; ++i)   modules[i]=null;
}",0.8785714285714286
180196,"@Override public void serviceChanged(ServiceEvent event){
  IModuleControl imc=(IModuleControl)event.getSource();
  if (event.getType() == ServiceEvent.REGISTERED) {
    if (modules[imc.getSlotId()] != null)     Activator.getLog().log(LogService.LOG_WARNING,""String_Node_Str"");
    modules[imc.getSlotId()]=imc;
  }
 else   if (event.getType() == ServiceEvent.UNREGISTERING) {
    modules[imc.getSlotId()]=null;
  }
}","@Override public void serviceChanged(ServiceEvent event){
  IModuleControl imc=(IModuleControl)context.getService(event.getServiceReference());
  if (event.getType() == ServiceEvent.REGISTERED) {
    if (modules[imc.getSlotId()] != null)     Activator.getLog().log(LogService.LOG_WARNING,""String_Node_Str"");
    modules[imc.getSlotId()]=imc;
  }
 else   if (event.getType() == ServiceEvent.UNREGISTERING) {
    modules[imc.getSlotId()]=null;
  }
}",0.9282407407407408
180197,"/** 
 * Create an instance of BMIModuleProperties class using the base BMI /sys filesystem directory, for example /sys/devices/conn-m1.
 * @param directory of BMI sysfs entry
 * @param slot slot index
 * @return BMIDevice
 */
protected static BMIDevice createFromSYSDirectory(final BundleContext context,File directory,int slot){
  if (directory == null || !directory.exists() || !directory.isDirectory()) {
    return null;
  }
  final String productId=parseHexInt(getFirstLineofFile(new File(directory,""String_Node_Str"")));
  BMIDeviceNodeFactory factory;
  try {
    factory=Fn.find(new Fn.Function<ServiceReference,BMIDeviceNodeFactory>(){
      @Override public BMIDeviceNodeFactory apply(      ServiceReference element){
        if (element.getProperty(""String_Node_Str"") != null && element.getProperty(""String_Node_Str"").equals(productId))         return context.getService(element);
        return null;
      }
    }
,context.getAllServiceReferences(BMIDeviceNodeFactory.class.getName(),null));
    if (factory != null)     return factory.createBMIDeviceNode(directory,slot);
  }
 catch (  InvalidSyntaxException e) {
  }
  return new BMIDevice(directory,slot);
}","/** 
 * Create an instance of BMIModuleProperties class using the base BMI /sys filesystem directory, for example /sys/devices/conn-m1.
 * @param directory of BMI sysfs entry
 * @param slot slot index
 * @return BMIDevice
 */
protected static BMIDevice createFromSYSDirectory(final BundleContext context,File directory,int slot){
  if (directory == null || !directory.exists() || !directory.isDirectory()) {
    return null;
  }
  final String productId=parseHexInt(getFirstLineofFile(new File(directory,""String_Node_Str"")));
  BMIDeviceNodeFactory factory;
  try {
    factory=Fn.find(new Fn.Function<ServiceReference,BMIDeviceNodeFactory>(){
      @Override public BMIDeviceNodeFactory apply(      ServiceReference element){
        if (element.getProperty(""String_Node_Str"") != null && element.getProperty(""String_Node_Str"").equals(productId))         return (BMIDeviceNodeFactory)context.getService(element);
        return null;
      }
    }
,context.getAllServiceReferences(BMIDeviceNodeFactory.class.getName(),null));
    if (factory != null)     return factory.createBMIDeviceNode(directory,slot);
  }
 catch (  InvalidSyntaxException e) {
  }
  return new BMIDevice(directory,slot);
}",0.9907016060862216
180198,"@Override public BMIDeviceNodeFactory apply(ServiceReference element){
  if (element.getProperty(""String_Node_Str"") != null && element.getProperty(""String_Node_Str"").equals(productId))   return context.getService(element);
  return null;
}","@Override public BMIDeviceNodeFactory apply(ServiceReference element){
  if (element.getProperty(""String_Node_Str"") != null && element.getProperty(""String_Node_Str"").equals(productId))   return (BMIDeviceNodeFactory)context.getService(element);
  return null;
}",0.956
180199,"/** 
 * @return list of BMIDevices that are currently attached, or empty list if no modules are attached.
 */
public static List getAttachedDevices(){
  BMIDevice[] devs=getDevices();
  List l=new ArrayList();
  for (int i=0; i < 4; ++i) {
    if (devs[i] != null) {
      l.add(devs[i]);
    }
  }
  return l;
}","/** 
 * @return list of BMIDevices that are currently attached, or empty list if no modules are attached.
 */
public static List<BMIDevice> getAttachedDevices(){
  BMIDevice[] devs=getDevices();
  List<BMIDevice> l=new ArrayList<BMIDevice>();
  for (int i=0; i < 4; ++i) {
    if (devs[i] != null) {
      l.add(devs[i]);
    }
  }
  return l;
}",0.9497716894977168
180200,"/** 
 * @param slot
 * @return The BMIDevice that exists at the passed slot or null if no device attached.
 */
public static BMIDevice getDevice(int slot){
  if (slot < 0 || slot > 3) {
    return null;
  }
  return getDevices()[slot];
}","/** 
 * @param slot Legal values: 0 - 3
 * @return The BMIDevice that exists at the passed slot or null if no device attached.
 */
public static BMIDevice getDevice(int slot){
  if (slot < 0 || slot > 3) {
    return null;
  }
  return getDevices()[slot];
}",0.9595141700404858
180201,"public void start(BundleContext context) throws Exception {
  this.context=context;
  Activator.ref=this;
  modletFactories=new Hashtable();
  activeModlets=new Hashtable();
  ServiceReference sr=context.getServiceReference(LogService.class.getName());
  if (sr != null) {
    logService=(LogService)context.getService(sr);
  }
  context.addServiceListener(this,""String_Node_Str"" + Constants.OBJECTCLASS + ""String_Node_Str""+ IModletFactory.class.getName()+ ""String_Node_Str"");
  registerExistingServices(context);
  pipeFilename=context.getProperty(""String_Node_Str"");
  if (pipeFilename == null || pipeFilename.length() == 0) {
    pipeFilename=DEFAULT_PIPE_FILENAME;
  }
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + pipeFilename);
  createPipe(pipeFilename);
  pipeReader=new PipeReader(pipeFilename,Manager.getManager(context,logService,modletFactories,activeModlets),logService);
  logService.log(LogService.LOG_INFO,""String_Node_Str"");
  coldPlug();
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + pipeFilename);
  pipeReader.start();
}","public void start(BundleContext context) throws Exception {
  this.context=context;
  Activator.ref=this;
  modletFactories=new Hashtable();
  activeModlets=new Hashtable();
  logService=LogServiceUtil.getLogService(context);
  context.addServiceListener(this,""String_Node_Str"" + Constants.OBJECTCLASS + ""String_Node_Str""+ IModletFactory.class.getName()+ ""String_Node_Str"");
  registerExistingServices(context);
  pipeFilename=context.getProperty(""String_Node_Str"");
  if (pipeFilename == null || pipeFilename.length() == 0) {
    pipeFilename=DEFAULT_PIPE_FILENAME;
  }
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + pipeFilename);
  createPipe(pipeFilename);
  pipeReader=new PipeReader(pipeFilename,Manager.getManager(context,logService,modletFactories,activeModlets),logService);
  logService.log(LogService.LOG_INFO,""String_Node_Str"");
  coldPlug();
  logService.log(LogService.LOG_INFO,""String_Node_Str"" + pipeFilename);
  pipeReader.start();
}",0.9010880316518298
180202,"/** 
 * Allows the user to set the service dependencies by adding them to services list returned by getServices(). i.e.nl getServices().add(MyService.class.getName());
 */
public void initServices(){
  getServices().add(com.buglabs.osgi.sewing.pub.ISewingService.class.getName());
  getServices().add(org.osgi.service.cm.ConfigurationAdmin.class.getName());
  getServices().add(IShellService.class.getName());
  getServices().add(com.buglabs.app.bugdash2.IBatteryInfoProvider.class.getName());
  getServices().add(LogService.class.getName());
}","/** 
 * Allows the user to set the service dependencies by adding them to services list returned by getServices(). i.e.nl getServices().add(MyService.class.getName());
 */
public void initServices(){
  getServices().add(com.buglabs.osgi.sewing.pub.ISewingService.class.getName());
  getServices().add(org.osgi.service.cm.ConfigurationAdmin.class.getName());
  getServices().add(com.buglabs.util.shell.pub.IShellService.class.getName());
  getServices().add(com.buglabs.app.bugdash2.IBatteryInfoProvider.class.getName());
  getServices().add(LogService.class.getName());
}",0.9757847533632288
180203,"public void setup() throws Exception {
  int slot=slotId + 1;
  String devnode_motion=""String_Node_Str"" + slot;
  String devnode_acc=""String_Node_Str"" + slot;
  String devnode_mdacc_control=""String_Node_Str"" + slot;
  motionDevice=new Motion();
  CharDeviceUtils.openDeviceWithRetry(motionDevice,devnode_motion,2);
  int retval=motionDevice.ioctl_BMI_MDACC_MOTION_DETECTOR_RUN();
  if (retval < 0) {
    throw new IOException(""String_Node_Str"" + devnode_motion);
  }
  accDevice=new Accelerometer();
  CharDeviceUtils.openDeviceWithRetry(accDevice,devnode_acc,2);
  accIs=new CharDeviceInputStream(accDevice);
  accControl=new AccelerometerControl(accDevice);
  acceld=new AccelerometerSimpleRawFeed(accIs,accControl);
  mdaccControlDevice=new MDACCControl();
  CharDeviceUtils.openDeviceWithRetry(mdaccControlDevice,devnode_mdacc_control,2);
  motionIs=new CharDeviceInputStream(motionDevice);
  motiond=new MotionRawFeed(motionIs);
  motionSubject=new MotionSubject(motiond.getInputStream(),this,log);
}","public void setup() throws Exception {
  int slot=slotId;
  String devnode_motion=""String_Node_Str"" + slot;
  String devnode_acc=""String_Node_Str"" + slot;
  String devnode_mdacc_control=""String_Node_Str"" + slot;
  motionDevice=new Motion();
  CharDeviceUtils.openDeviceWithRetry(motionDevice,devnode_motion,2);
  int retval=motionDevice.ioctl_BMI_MDACC_MOTION_DETECTOR_RUN();
  if (retval < 0) {
    throw new IOException(""String_Node_Str"" + devnode_motion);
  }
  accDevice=new Accelerometer();
  CharDeviceUtils.openDeviceWithRetry(accDevice,devnode_acc,2);
  accIs=new CharDeviceInputStream(accDevice);
  accControl=new AccelerometerControl(accDevice);
  acceld=new AccelerometerSimpleRawFeed(accIs,accControl);
  mdaccControlDevice=new MDACCControl();
  CharDeviceUtils.openDeviceWithRetry(mdaccControlDevice,devnode_mdacc_control,2);
  motionIs=new CharDeviceInputStream(motionDevice);
  motiond=new MotionRawFeed(motionIs);
  motionSubject=new MotionSubject(motiond.getInputStream(),this,log);
}",0.9980059820538384
180204,"/** 
 * Create a node with a parent and a String value.
 * @param parent
 * @param tagName
 * @param value
 */
public XmlNode(XmlNode parent,String tagName,String value){
  this(parent,tagName);
  if (value.length() > 0) {
    this.text=value;
  }
}","/** 
 * Create a node with a parent and a String value.
 * @param parent
 * @param tagName
 * @param value
 */
public XmlNode(XmlNode parent,String tagName,String value){
  this(parent,tagName);
  if (value != null && value.length() > 0) {
    this.text=value;
  }
}",0.966990291262136
180205,"public static RecordStore openRecordStore(String recordStoreName,boolean createIfNecessary) throws RecordStoreException {
  ConfigurationAdmin ca=getConfigurationAdmin(Activator.getInstance().getBundleContext());
  if (ca == null) {
    throw new RecordStoreException(""String_Node_Str"");
  }
  try {
    Configuration c=ca.getConfiguration(createPid(recordStoreName));
    if (c.getProperties().get(KEYSTORE_KEY) == null && !createIfNecessary) {
      throw new RecordStoreException(""String_Node_Str"" + recordStoreName + ""String_Node_Str"");
    }
    Dictionary keystore=(Dictionary)c.getProperties().get(KEYSTORE_KEY);
    if (keystore == null) {
      keystore=new Hashtable();
      c.getProperties().put(KEYSTORE_KEY,keystore);
    }
    return new RecordStore(recordStoreName,keystore);
  }
 catch (  IOException e) {
    throw new RecordStoreException(""String_Node_Str"",e);
  }
}","public static RecordStore openRecordStore(String recordStoreName,boolean createIfNecessary) throws RecordStoreException {
  ConfigurationAdmin ca=getConfigurationAdmin(Activator.getInstance().getBundleContext());
  if (ca == null) {
    throw new RecordStoreException(""String_Node_Str"");
  }
  try {
    Configuration c=ca.getConfiguration(createPid(recordStoreName));
    c.update();
    if (c.getProperties().get(KEYSTORE_KEY) == null && !createIfNecessary) {
      throw new RecordStoreException(""String_Node_Str"" + recordStoreName + ""String_Node_Str"");
    }
    Dictionary keystore=(Dictionary)c.getProperties().get(KEYSTORE_KEY);
    if (keystore == null) {
      keystore=new Hashtable();
      c.getProperties().put(KEYSTORE_KEY,keystore);
    }
    return new RecordStore(recordStoreName,keystore);
  }
 catch (  IOException e) {
    throw new RecordStoreException(""String_Node_Str"",e);
  }
}",0.9910414333706606
180206,"/** 
 * Create a node with a parent and a String value.
 * @param parent
 * @param tagName
 * @param value
 */
public XmlNode(XmlNode parent,String tagName,String value){
  this(parent,tagName);
  this.text=value;
}","/** 
 * Create a node with a parent and a String value.
 * @param parent
 * @param tagName
 * @param value
 */
public XmlNode(XmlNode parent,String tagName,String value){
  this(parent,tagName);
  if (value.length() > 0) {
    this.text=value;
  }
}",0.9267241379310344
180207,"public XmlNode parse(Reader reader) throws IOException {
  if (!(reader.markSupported())) {
    this.reader=new BufferedReader(reader);
  }
 else {
    this.reader=reader;
  }
  skipPrologs();
  while (true) {
    int index;
    String tagName;
    String currentTag=readTag().trim();
    if (currentTag.startsWith(""String_Node_Str"")) {
      tagName=currentTag.substring(2,currentTag.length() - 1);
      if (ignoreNamespaces) {
        tagName=stripNamespace(tagName);
      }
      if (currentElement == null) {
        throw new IOException(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
      if (!tagName.equals(currentElement.getName())) {
        throw new IOException(""String_Node_Str"" + currentElement.getName() + ""String_Node_Str""+ tagName+ ""String_Node_Str"");
      }
      if (elements.empty()) {
        return currentElement;
      }
 else {
        currentElement=(XmlNode)elements.pop();
      }
    }
 else {
      index=currentTag.indexOf(""String_Node_Str"");
      if (index < 0) {
        if (currentTag.endsWith(""String_Node_Str"")) {
          tagName=currentTag.substring(1,currentTag.length() - 2);
          currentTag=""String_Node_Str"";
        }
 else {
          tagName=currentTag.substring(1,currentTag.length() - 1);
          if (ignoreNamespaces) {
            tagName=stripNamespace(tagName);
          }
          currentTag=""String_Node_Str"";
        }
      }
 else {
        tagName=currentTag.substring(1,index);
        if (ignoreNamespaces) {
          tagName=stripNamespace(tagName);
        }
        currentTag=currentTag.substring(index + 1);
      }
      XmlNode element=new XmlNode(tagName,""String_Node_Str"");
      boolean isTagClosed=false;
      while (currentTag.length() > 0) {
        currentTag=currentTag.trim();
        if (currentTag.equals(""String_Node_Str"")) {
          isTagClosed=true;
          break;
        }
 else         if (currentTag.equals(""String_Node_Str"")) {
          break;
        }
        index=currentTag.indexOf(""String_Node_Str"");
        if (index < 0) {
          throw new IOException(""String_Node_Str"" + tagName + ""String_Node_Str"");
        }
        String attributeName=currentTag.substring(0,index);
        if (ignoreNamespaces) {
          attributeName=stripNamespace(attributeName);
        }
        currentTag=currentTag.substring(index + 1);
        String attributeValue;
        boolean isQuoted=true;
        if (currentTag.startsWith(""String_Node_Str"")) {
          index=currentTag.indexOf('""',1);
        }
 else         if (currentTag.startsWith(""String_Node_Str"")) {
          index=currentTag.indexOf('\'',1);
        }
 else {
          isQuoted=false;
          index=currentTag.indexOf(' ');
          if (index < 0) {
            index=currentTag.indexOf('>');
            if (index < 0) {
              index=currentTag.indexOf('/');
            }
          }
        }
        if (index < 0) {
          throw new IOException(""String_Node_Str"" + tagName + ""String_Node_Str"");
        }
        if (isQuoted) {
          attributeValue=currentTag.substring(1,index);
        }
 else {
          attributeValue=currentTag.substring(0,index);
        }
        element.setAttribute(attributeName,attributeValue);
        currentTag=currentTag.substring(index + 1);
      }
      if (!isTagClosed) {
        element.setValue(readText());
      }
      if (currentElement != null) {
        try {
          element.setParent(currentElement);
        }
 catch (        SelfReferenceException e) {
          throw new IOException(e.getMessage());
        }
      }
      if (!isTagClosed) {
        if (currentElement != null) {
          elements.push(currentElement);
        }
        currentElement=element;
      }
 else       if (currentElement == null) {
        return element;
      }
    }
  }
}","public XmlNode parse(Reader reader) throws IOException {
  if (!(reader.markSupported())) {
    this.reader=new BufferedReader(reader);
  }
 else {
    this.reader=reader;
  }
  skipPrologs();
  while (true) {
    int index;
    String tagName;
    String currentTag=readTag().trim();
    if (currentTag.startsWith(""String_Node_Str"")) {
      tagName=currentTag.substring(2,currentTag.length() - 1);
      if (ignoreNamespaces) {
        tagName=stripNamespace(tagName);
      }
      if (currentElement == null) {
        throw new IOException(""String_Node_Str"" + tagName + ""String_Node_Str"");
      }
      if (!tagName.equals(currentElement.getName())) {
        throw new IOException(""String_Node_Str"" + currentElement.getName() + ""String_Node_Str""+ tagName+ ""String_Node_Str"");
      }
      if (elements.empty()) {
        return currentElement;
      }
 else {
        currentElement=(XmlNode)elements.pop();
      }
    }
 else {
      index=currentTag.indexOf(""String_Node_Str"");
      if (index < 0) {
        if (currentTag.endsWith(""String_Node_Str"")) {
          tagName=currentTag.substring(1,currentTag.length() - 2);
          currentTag=""String_Node_Str"";
        }
 else {
          tagName=currentTag.substring(1,currentTag.length() - 1);
          if (ignoreNamespaces) {
            tagName=stripNamespace(tagName);
          }
          currentTag=""String_Node_Str"";
        }
      }
 else {
        tagName=currentTag.substring(1,index);
        if (ignoreNamespaces) {
          tagName=stripNamespace(tagName);
        }
        currentTag=currentTag.substring(index + 1);
      }
      XmlNode element=new XmlNode(tagName);
      boolean isTagClosed=false;
      while (currentTag.length() > 0) {
        currentTag=currentTag.trim();
        if (currentTag.equals(""String_Node_Str"")) {
          isTagClosed=true;
          break;
        }
 else         if (currentTag.equals(""String_Node_Str"")) {
          break;
        }
        index=currentTag.indexOf(""String_Node_Str"");
        if (index < 0) {
          throw new IOException(""String_Node_Str"" + tagName + ""String_Node_Str"");
        }
        String attributeName=currentTag.substring(0,index);
        if (ignoreNamespaces) {
          attributeName=stripNamespace(attributeName);
        }
        currentTag=currentTag.substring(index + 1);
        String attributeValue;
        boolean isQuoted=true;
        if (currentTag.startsWith(""String_Node_Str"")) {
          index=currentTag.indexOf('""',1);
        }
 else         if (currentTag.startsWith(""String_Node_Str"")) {
          index=currentTag.indexOf('\'',1);
        }
 else {
          isQuoted=false;
          index=currentTag.indexOf(' ');
          if (index < 0) {
            index=currentTag.indexOf('>');
            if (index < 0) {
              index=currentTag.indexOf('/');
            }
          }
        }
        if (index < 0) {
          throw new IOException(""String_Node_Str"" + tagName + ""String_Node_Str"");
        }
        if (isQuoted) {
          attributeValue=currentTag.substring(1,index);
        }
 else {
          attributeValue=currentTag.substring(0,index);
        }
        element.setAttribute(attributeName,attributeValue);
        currentTag=currentTag.substring(index + 1);
      }
      if (!isTagClosed) {
        element.setValue(readText());
      }
      if (currentElement != null) {
        try {
          element.setParent(currentElement);
        }
 catch (        SelfReferenceException e) {
          throw new IOException(e.getMessage());
        }
      }
      if (!isTagClosed) {
        if (currentElement != null) {
          elements.push(currentElement);
        }
        currentElement=element;
      }
 else       if (currentElement == null) {
        return element;
      }
    }
  }
}",0.997639653815893
180208,"/** 
 * Reduce the size of the list until it matches the defined size.
 */
private void checkAndRemove(){
  while (list.size() > size) {
    list.removeFirst();
  }
}","/** 
 * Reduce the size of the list until it matches the defined size.
 */
private synchronized void checkAndRemove(){
  while (list.size() > size) {
    list.removeFirst();
  }
}",0.9623188405797102
180209,"public Object addingService(ServiceReference arg0){
  sc++;
  Object svc=bc.getService(arg0);
  serviceMap.put(arg0.getProperty(Constants.OBJECTCLASS),svc);
  if (thread == null && sc == services.length && !(runnable instanceof UnmanagedRunnable)) {
    if (runnable instanceof ManagedInlineRunnable) {
      runnable.run(serviceMap);
    }
 else {
      thread=new Thread(new Runnable(){
        public void run(){
          runnable.run(serviceMap);
        }
      }
);
      thread.start();
    }
  }
  if (runnable instanceof UnmanagedRunnable) {
    return ((UnmanagedRunnable)runnable).addingService(arg0);
  }
  return svc;
}","public Object addingService(ServiceReference arg0){
  sc++;
  Object svc=bc.getService(arg0);
  String key=((String[])arg0.getProperty(Constants.OBJECTCLASS))[0];
  serviceMap.put(key,svc);
  if (thread == null && sc == services.length && !(runnable instanceof UnmanagedRunnable)) {
    if (runnable instanceof ManagedInlineRunnable) {
      runnable.run(serviceMap);
    }
 else {
      thread=new Thread(new Runnable(){
        public void run(){
          runnable.run(serviceMap);
        }
      }
);
      thread.start();
    }
  }
  if (runnable instanceof UnmanagedRunnable) {
    return ((UnmanagedRunnable)runnable).addingService(arg0);
  }
  return svc;
}",0.9515011547344112
180210,"public void removedService(ServiceReference arg0,Object arg1){
  sc--;
  if (!(thread == null) && !thread.isInterrupted() && !(runnable instanceof UnmanagedRunnable)) {
    runnable.shutdown();
    thread.interrupt();
    return;
  }
  if (runnable instanceof UnmanagedRunnable) {
    ((UnmanagedRunnable)runnable).removedService(arg0,arg1);
  }
  if (runnable instanceof ManagedInlineRunnable) {
    ((ManagedInlineRunnable)runnable).shutdown();
  }
}","public void removedService(ServiceReference arg0,Object arg1){
  String key=((String[])arg0.getProperty(Constants.OBJECTCLASS))[0];
  serviceMap.remove(key);
  sc--;
  if (!(thread == null) && !thread.isInterrupted() && !(runnable instanceof UnmanagedRunnable)) {
    runnable.shutdown();
    thread.interrupt();
    return;
  }
  if (runnable instanceof UnmanagedRunnable) {
    ((UnmanagedRunnable)runnable).removedService(arg0,arg1);
  }
  if (runnable instanceof ManagedInlineRunnable) {
    ((ManagedInlineRunnable)runnable).shutdown();
  }
}",0.9049049049049048
180211,"public void modifiedService(ServiceReference arg0,Object arg1){
  if (runnable instanceof UnmanagedRunnable) {
    ((UnmanagedRunnable)runnable).modifiedService(arg0,arg1);
  }
}","public void modifiedService(ServiceReference arg0,Object arg1){
  String key=((String[])arg0.getProperty(Constants.OBJECTCLASS))[0];
  serviceMap.put(key,arg1);
  if (runnable instanceof UnmanagedRunnable) {
    ((UnmanagedRunnable)runnable).modifiedService(arg0,arg1);
  }
}",0.7858719646799117
180212,"public ServiceTrackerHelper(BundleContext bc,ManagedRunnable t,String[] services){
  this.bc=bc;
  this.runnable=t;
  this.services=services;
  this.serviceMap=new HashMap();
  this.log=LogServiceUtil.getLogService(bc);
  sc=0;
}","public ServiceTrackerHelper(BundleContext bc,ManagedRunnable t,int serviceCount){
  this.bc=bc;
  this.runnable=t;
  this.serviceCount=serviceCount;
  this.serviceMap=new HashMap();
  this.log=LogServiceUtil.getLogService(bc);
  sc=0;
}",0.8688172043010752
180213,"public Object addingService(ServiceReference arg0){
  sc++;
  Object svc=bc.getService(arg0);
  String key=((String[])arg0.getProperty(Constants.OBJECTCLASS))[0];
  serviceMap.put(key,svc);
  if (thread == null && sc == services.length && !(runnable instanceof UnmanagedRunnable)) {
    if (runnable instanceof ManagedInlineRunnable) {
      runnable.run(serviceMap);
    }
 else {
      thread=new Thread(new Runnable(){
        public void run(){
          runnable.run(serviceMap);
        }
      }
);
      thread.start();
    }
  }
  if (runnable instanceof UnmanagedRunnable) {
    return ((UnmanagedRunnable)runnable).addingService(arg0);
  }
  return svc;
}","public Object addingService(ServiceReference arg0){
  Object svc=bc.getService(arg0);
  String key=((String[])arg0.getProperty(Constants.OBJECTCLASS))[0];
  if (!serviceMap.containsKey(key)) {
    sc++;
    serviceMap.put(key,svc);
  }
  if (thread == null && sc == serviceCount && !(runnable instanceof UnmanagedRunnable)) {
    if (runnable instanceof ManagedInlineRunnable) {
      runnable.run(serviceMap);
    }
 else {
      thread=new Thread(new Runnable(){
        public void run(){
          runnable.run(serviceMap);
        }
      }
);
      thread.start();
    }
  }
  if (runnable instanceof UnmanagedRunnable) {
    return ((UnmanagedRunnable)runnable).addingService(arg0);
  }
  return svc;
}",0.9454545454545454
180214,"public void removedService(ServiceReference arg0,Object arg1){
  String key=((String[])arg0.getProperty(Constants.OBJECTCLASS))[0];
  serviceMap.remove(key);
  sc--;
  if (!(thread == null) && !thread.isInterrupted() && !(runnable instanceof UnmanagedRunnable)) {
    runnable.shutdown();
    thread.interrupt();
    return;
  }
  if (runnable instanceof UnmanagedRunnable) {
    ((UnmanagedRunnable)runnable).removedService(arg0,arg1);
  }
  if (runnable instanceof ManagedInlineRunnable) {
    ((ManagedInlineRunnable)runnable).shutdown();
  }
}","public void removedService(ServiceReference arg0,Object arg1){
  String key=((String[])arg0.getProperty(Constants.OBJECTCLASS))[0];
  if (serviceMap.containsKey(key)) {
    serviceMap.remove(key);
    sc--;
  }
  if (!(thread == null) && !thread.isInterrupted() && !(runnable instanceof UnmanagedRunnable)) {
    runnable.shutdown();
    thread.interrupt();
    thread=null;
    return;
  }
  if (runnable instanceof UnmanagedRunnable) {
    ((UnmanagedRunnable)runnable).removedService(arg0,arg1);
  }
  if (runnable instanceof ManagedInlineRunnable) {
    ((ManagedInlineRunnable)runnable).shutdown();
  }
}",0.9463667820069204
180215,"/** 
 * Get a list of BMIMessage strings for existing modules based on entries in the /sys filesystem.
 * @return
 * @throws IOException
 */
private List getSysFSModules() throws IOException {
  List slots=null;
  for (int i=0; i < 4; ++i) {
    File prodFile=new File(""String_Node_Str"" + i + ""String_Node_Str""+ i+ ""String_Node_Str""+ i+ ""String_Node_Str"");
    if (!prodFile.exists()) {
      logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + i);
      continue;
    }
    if (slots == null) {
      slots=new ArrayList();
    }
    BMIModuleProperties props=BMIModuleProperties.createFromSYSDirectory(prodFile.getParentFile());
    BMIMessage m=new BMIMessage(props,i);
    slots.add(m);
  }
  return slots;
}","/** 
 * Get a list of BMIMessage strings for existing modules based on entries in the /sys filesystem.
 * @return
 * @throws IOException
 */
private List getSysFSModules() throws IOException {
  List slots=null;
  for (int i=0; i < 4; ++i) {
    File prodFile=new File(""String_Node_Str"" + i + ""String_Node_Str""+ i+ ""String_Node_Str"");
    if (!prodFile.exists()) {
      logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + i);
      continue;
    }
    if (slots == null) {
      slots=new ArrayList();
    }
    BMIModuleProperties props=BMIModuleProperties.createFromSYSDirectory(prodFile.getParentFile());
    BMIMessage m=new BMIMessage(props,i);
    slots.add(m);
  }
  return slots;
}",0.9843971631205674
180216,"/** 
 * Return a file represented the root directory of a BMI module given it's slot #.
 * @param slot
 * @return
 */
private File sysDirectory(int slot){
  return new File(""String_Node_Str"" + slot + ""String_Node_Str""+ slot+ ""String_Node_Str""+ slot);
}","/** 
 * Return a file represented the root directory of a BMI module given it's slot #.
 * @param slot
 * @return
 */
private File sysDirectory(int slot){
}",0.7647058823529411
180217,"/** 
 * Return a file represented the root directory of a BMI module given it's slot #.
 * @param slot
 * @return
 */
private File sysDirectory(int slot){
}","/** 
 * Return a file represented the root directory of a BMI module given it's slot #.
 * @param slot
 * @return
 */
private File sysDirectory(int slot){
  return new File(""String_Node_Str"" + slot + ""String_Node_Str""+ slot);
}",0.814621409921671
180218,"@Override public boolean accept(File dir,String name){
  return name.endsWith(""String_Node_Str"");
}","public boolean accept(File dir,String name){
  return name.endsWith(""String_Node_Str"");
}",0.946808510638298
180219,"/** 
 * Log an exception and print nested exception if it exists.
 * @param logService
 * @param message
 * @param exception
 */
public static void logBundleException(LogService logService,String message,Exception exception){
  logService.log(LogService.LOG_ERROR,message + ""String_Node_Str"" + exception.getMessage());
  stackTraceToString(exception);
}","/** 
 * Log an exception and print nested exception if it exists.
 * @param logService
 * @param message
 * @param exception
 */
public static void logBundleException(LogService logService,String message,Exception exception){
  logService.log(LogService.LOG_ERROR,message + ""String_Node_Str"" + exception.getMessage()+ ""String_Node_Str""+ stackTraceToString(exception));
}",0.8852005532503457
180220,"public BUGBaseControl() throws FileNotFoundException {
  batteryFH=new FileOutputStream[3];
  batteryFH[COLOR_BLUE]=new FileOutputStream(BATTERY_BLUE_CONTROL_FILE);
  batteryFH[COLOR_RED]=new FileOutputStream(BATTERY_RED_CONTROL_FILE);
  batteryFH[COLOR_GREEN]=new FileOutputStream(BATTERY_GREEN_CONTROL_FILE);
  powerFH=new FileOutputStream[1];
  powerFH[COLOR_BLUE]=new FileOutputStream(POWER_BLUE_CONTROL_FILE);
  wlanFH=new FileOutputStream[3];
  wlanFH[COLOR_BLUE]=new FileOutputStream(WLAN_BLUE_CONTROL_FILE);
  wlanFH[COLOR_RED]=new FileOutputStream(WLAN_RED_CONTROL_FILE);
  wlanFH[COLOR_GREEN]=new FileOutputStream(WLAN_GREEN_CONTROL_FILE);
  btFH=new FileOutputStream[0];
  btFH[COLOR_BLUE]=new FileOutputStream(BT_BLUE_CONTROL_FILE);
}","public BUGBaseControl() throws FileNotFoundException {
  batteryFH=new FileOutputStream[3];
  batteryFH[COLOR_BLUE]=new FileOutputStream(BATTERY_BLUE_CONTROL_FILE);
  batteryFH[COLOR_RED]=new FileOutputStream(BATTERY_RED_CONTROL_FILE);
  batteryFH[COLOR_GREEN]=new FileOutputStream(BATTERY_GREEN_CONTROL_FILE);
  powerFH=new FileOutputStream[1];
  powerFH[COLOR_BLUE]=new FileOutputStream(POWER_BLUE_CONTROL_FILE);
  wlanFH=new FileOutputStream[3];
  wlanFH[COLOR_BLUE]=new FileOutputStream(WLAN_BLUE_CONTROL_FILE);
  wlanFH[COLOR_RED]=new FileOutputStream(WLAN_RED_CONTROL_FILE);
  wlanFH[COLOR_GREEN]=new FileOutputStream(WLAN_GREEN_CONTROL_FILE);
  btFH=new FileOutputStream[1];
  btFH[COLOR_BLUE]=new FileOutputStream(BT_BLUE_CONTROL_FILE);
}",0.9986595174262736
180221,"/** 
 * @return Seconds part of DMS value
 */
public double getSeconds(){
  int i=dms.indexOf(""String_Node_Str"");
  String seconds=dms.substring(i);
  return Double.parseDouble(seconds) * 60;
}","/** 
 * @return Seconds part of DMS value
 */
public double getSeconds(){
  int i=dms.indexOf(""String_Node_Str"");
  if (i == -1) {
    return 0;
  }
  String seconds=dms.substring(i);
  return Double.parseDouble(seconds) * 60;
}",0.9168646080760094
180222,"public AbstractNMEASentence(String sentence){
  initialize();
  String[] fields=StringUtil.split(parseChecksum(sentence),FIELD_SEPARATOR);
  name=fields[0];
  for (int i=1; i < fields.length; ++i) {
    if (isEmpty(fields[i])) {
      continue;
    }
    parseField(i,fields[i],fields);
  }
  validate();
}","public AbstractNMEASentence(String sentence){
  initialize();
  String[] fields=StringUtil.split(parseChecksum(sentence),FIELD_SEPARATOR);
  name=fields[0];
  for (int i=1; i < fields.length; ++i) {
    if (isEmpty(fields[i])) {
      continue;
    }
    try {
      parseField(i,fields[i],fields);
    }
 catch (    RuntimeException e) {
      throw new NMEAParserException(e.getMessage());
    }
  }
  validate();
}",0.8464730290456431
180223,"/** 
 * Get a list of BMIMessage strings for existing modules based on entries in the /sys filesystem.
 * @return
 * @throws IOException
 */
private List getSysFSModules() throws IOException {
  List slots=null;
  for (int i=0; i < 4; ++i) {
    File prodFile=new File(""String_Node_Str"" + i + ""String_Node_Str""+ i+ ""String_Node_Str""+ i+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + prodFile.getAbsolutePath());
    if (!prodFile.exists()) {
      logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + i);
      continue;
    }
    if (slots == null) {
      slots=new ArrayList();
    }
    BMIModuleProperties props=BMIModuleProperties.createFromSYSDirectory(prodFile.getParentFile());
    BMIMessage m=new BMIMessage(props,i);
    slots.add(m);
  }
  return slots;
}","/** 
 * Get a list of BMIMessage strings for existing modules based on entries in the /sys filesystem.
 * @return
 * @throws IOException
 */
private List getSysFSModules() throws IOException {
  List slots=null;
  for (int i=0; i < 4; ++i) {
    File prodFile=new File(""String_Node_Str"" + i + ""String_Node_Str""+ i+ ""String_Node_Str""+ i+ ""String_Node_Str"");
    if (!prodFile.exists()) {
      logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + i);
      continue;
    }
    if (slots == null) {
      slots=new ArrayList();
    }
    BMIModuleProperties props=BMIModuleProperties.createFromSYSDirectory(prodFile.getParentFile());
    BMIMessage m=new BMIMessage(props,i);
    slots.add(m);
  }
  return slots;
}",0.952127659574468
180224,"public void run(){
  while (!Thread.currentThread().isInterrupted()) {
    try {
      ifs=new FileInputStream(pipeFilename);
      int c=0;
      StringBuffer sb=new StringBuffer();
      while ((c=ifs.read()) != -1) {
        sb.append((char)c);
        if (c == '\n' || c == '\r') {
          if (sb.toString().equals(POISON_PILL)) {
            return;
          }
          if (logService != null) {
            logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + sb.toString());
          }
          BMIMessage m=new BMIMessage(sb.toString());
          if (m.parse()) {
            if (m.getEvent() == BMIMessage.EVENT_INSERT) {
              m.setBMIModuleProperties(BMIModuleProperties.createFromSYSDirectory(sysDirectory(m.getSlot() + 1)));
            }
            manager.processMessage(m);
          }
 else {
            logService.log(LogService.LOG_ERROR,""String_Node_Str"" + sb.toString());
          }
          break;
        }
      }
    }
 catch (    FileNotFoundException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
catch (    IOException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
 finally {
      try {
        if (ifs != null) {
          ifs.close();
        }
      }
 catch (      IOException e) {
      }
    }
  }
}","public void run(){
  while (!Thread.currentThread().isInterrupted()) {
    try {
      ifs=new FileInputStream(pipeFilename);
      int c=0;
      StringBuffer sb=new StringBuffer();
      while ((c=ifs.read()) != -1) {
        sb.append((char)c);
        if (c == '\n' || c == '\r') {
          if (sb.toString().equals(POISON_PILL)) {
            return;
          }
          if (logService != null) {
            logService.log(LogService.LOG_DEBUG,""String_Node_Str"" + sb.toString());
          }
          BMIMessage m=new BMIMessage(sb.toString());
          if (m.parse()) {
            if (m.getEvent() == BMIMessage.EVENT_INSERT) {
              m.setBMIModuleProperties(BMIModuleProperties.createFromSYSDirectory(sysDirectory(m.getSlot())));
            }
            manager.processMessage(m);
          }
 else {
            logService.log(LogService.LOG_ERROR,""String_Node_Str"" + sb.toString());
          }
          break;
        }
      }
    }
 catch (    FileNotFoundException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
catch (    IOException e) {
      logService.log(LogService.LOG_ERROR,e.getMessage());
    }
 finally {
      try {
        if (ifs != null) {
          ifs.close();
        }
      }
 catch (      IOException e) {
      }
    }
  }
}",0.998463901689708
180225,"/** 
 * A BMIMessage for inserted module with parsed properties.
 * @param props
 * @param slot
 */
public BMIMessage(BMIModuleProperties props,int slot){
  this.props=props;
  this.moduleId=df.format(props.getProduct_id());
  this.version=""String_Node_Str"" + props.getRevision();
  this.slot=slot;
  this.event=EVENT_INSERT;
}","/** 
 * A BMIMessage for inserted module with parsed properties.
 * @param props
 * @param slot
 */
public BMIMessage(BMIModuleProperties props,int slot){
  this.props=props;
  this.moduleId=props.getProduct_id();
  this.version=""String_Node_Str"" + props.getRevision();
  this.slot=slot;
  this.event=EVENT_INSERT;
}",0.9237947122861586
180226,"public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return ""String_Node_Str"";
      }
    }
;
  }
  return null;
}","public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider2.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return ""String_Node_Str"";
      }
    }
;
  }
  return null;
}",0.9983471074380166
180227,"public String getPublicName(){
  return ""String_Node_Str"";
}","public String getPublicName(){
  return serviceName;
}",0.8245614035087719
180228,"public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider.GET) {
    return new WSResponse(getTimeXml(),""String_Node_Str"");
  }
  return null;
}","public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider2.GET) {
    return new WSResponse(getTimeXml(),""String_Node_Str"");
  }
  return null;
}",0.9971988795518208
180229,"public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return ""String_Node_Str"";
      }
    }
;
  }
  return null;
}","public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider2.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return ""String_Node_Str"";
      }
    }
;
  }
  return null;
}",0.9983471074380166
180230,"public String getPublicName(){
  return ""String_Node_Str"";
}","public String getPublicName(){
  return serviceName;
}",0.8245614035087719
180231,"public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider.GET) {
    return new WSResponse(getAccelerationXml(),""String_Node_Str"");
  }
  return null;
}","public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider2.GET) {
    return new WSResponse(getAccelerationXml(),""String_Node_Str"");
  }
  return null;
}",0.9973190348525468
180232,"public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return ""String_Node_Str"";
      }
    }
;
  }
  return null;
}","public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider2.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return ""String_Node_Str"";
      }
    }
;
  }
  return null;
}",0.9983471074380166
180233,"public String getPublicName(){
  return ""String_Node_Str"";
}","public String getPublicName(){
  return serviceName;
}",0.8245614035087719
180234,"public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider.GET) {
    return new WSResponse(getAccelerationXml(),""String_Node_Str"");
  }
  return null;
}","public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider2.GET) {
    return new WSResponse(getAccelerationXml(),""String_Node_Str"");
  }
  return null;
}",0.9973190348525468
180235,"private long getReadDelay(){
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  ServiceReference sr=context.getServiceReference(ConfigurationAdmin.class.getName());
  long read_delay=100;
  if (sr != null) {
    ConfigurationAdmin ca=(ConfigurationAdmin)context.getService(sr);
    log.log(LogService.LOG_DEBUG,""String_Node_Str"");
    if (ca != null) {
      Configuration c;
      try {
        c=ca.getConfiguration(getModuleName());
        log.log(LogService.LOG_DEBUG,""String_Node_Str"");
        String key=""String_Node_Str"";
        String factoryPid=c.getPid();
        Dictionary properties=c.getProperties();
        Object obj=c.getProperties().get(key);
        if (obj != null) {
          read_delay=Long.parseLong(obj.toString());
          log.log(LogService.LOG_DEBUG,""String_Node_Str"" + read_delay);
        }
 else {
          c.getProperties().put(key,Long.toString(read_delay));
          c.update(c.getProperties());
          log.log(LogService.LOG_DEBUG,""String_Node_Str"");
          Object object=c.getProperties().get(key);
          log.log(LogService.LOG_INFO,""String_Node_Str"" + object.toString());
        }
      }
 catch (      IOException e) {
        log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
      }
    }
  }
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  return read_delay;
}","private long getReadDelay(){
  ServiceReference sr=context.getServiceReference(ConfigurationAdmin.class.getName());
  long read_delay=100;
  if (sr != null) {
    ConfigurationAdmin ca=(ConfigurationAdmin)context.getService(sr);
    log.log(LogService.LOG_DEBUG,""String_Node_Str"");
    if (ca != null) {
      Configuration c;
      try {
        c=ca.getConfiguration(getModuleName());
        log.log(LogService.LOG_DEBUG,""String_Node_Str"");
        String key=""String_Node_Str"";
        String factoryPid=c.getPid();
        Dictionary properties=c.getProperties();
        Object obj=c.getProperties().get(key);
        if (obj != null) {
          read_delay=Long.parseLong(obj.toString());
          log.log(LogService.LOG_DEBUG,""String_Node_Str"" + read_delay);
        }
 else {
          c.getProperties().put(key,Long.toString(read_delay));
          c.update(c.getProperties());
          log.log(LogService.LOG_DEBUG,""String_Node_Str"");
          Object object=c.getProperties().get(key);
          log.log(LogService.LOG_INFO,""String_Node_Str"" + object.toString());
        }
      }
 catch (      IOException e) {
        log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
      }
    }
  }
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  return read_delay;
}",0.308637236084453
180236,"public void start() throws Exception {
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  gpsd.start();
  nmeaProvider.start();
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  setPassiveAntenna();
  moduleRef=context.registerService(IModuleControl.class.getName(),this,null);
  ledRef=context.registerService(IModuleLEDController.class.getName(),this,createRemotableProperties(null));
  gpsControlRef=context.registerService(IGPSModuleControl.class.getName(),this,createRemotableProperties(null));
  nmeaRef=context.registerService(INMEARawFeed.class.getName(),gpsd,createRemotableProperties(null));
  nmeaProviderRef=context.registerService(INMEASentenceProvider.class.getName(),nmeaProvider,createRemotableProperties(null));
  wsTracker=PublicWSAdminTracker.createTracker(context,this);
  regionKey=StatusBarUtils.displayImage(context,icon,this.getModuleName());
  timer=new Timer();
  timer.schedule(new GPSFIXLEDStatusTask(this,log),500,5000);
  positionRef=context.registerService(IPositionProvider.class.getName(),this,createRemotableProperties(null));
  context.addServiceListener(nmeaProvider,""String_Node_Str"" + Constants.OBJECTCLASS + ""String_Node_Str""+ INMEASentenceSubscriber.class.getName()+ ""String_Node_Str""+ Constants.OBJECTCLASS+ ""String_Node_Str""+ IPositionSubscriber.class.getName()+ ""String_Node_Str"");
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
}","public void start() throws Exception {
  gpsd.start();
  nmeaProvider.start();
  log.log(LogService.LOG_INFO,""String_Node_Str"");
  setPassiveAntenna();
  moduleRef=context.registerService(IModuleControl.class.getName(),this,null);
  ledRef=context.registerService(IModuleLEDController.class.getName(),this,createRemotableProperties(null));
  gpsControlRef=context.registerService(IGPSModuleControl.class.getName(),this,createRemotableProperties(null));
  nmeaRef=context.registerService(INMEARawFeed.class.getName(),gpsd,createRemotableProperties(null));
  nmeaProviderRef=context.registerService(INMEASentenceProvider.class.getName(),nmeaProvider,createRemotableProperties(null));
  wsTracker=PublicWSAdminTracker.createTracker(context,this);
  regionKey=StatusBarUtils.displayImage(context,icon,this.getModuleName());
  timer=new Timer();
  timer.schedule(new GPSFIXLEDStatusTask(this,log),500,5000);
  positionRef=context.registerService(IPositionProvider.class.getName(),this,createRemotableProperties(null));
  context.addServiceListener(nmeaProvider,""String_Node_Str"" + Constants.OBJECTCLASS + ""String_Node_Str""+ INMEASentenceSubscriber.class.getName()+ ""String_Node_Str""+ Constants.OBJECTCLASS+ ""String_Node_Str""+ IPositionSubscriber.class.getName()+ ""String_Node_Str"");
}",0.9289740698985344
180237,"public Position getPosition(){
  RMC rmc=nmeaProvider.getLastRMC();
  log.log(LogService.LOG_DEBUG,""String_Node_Str"" + rmc.getLatitude() + ""String_Node_Str""+ rmc.getLongitude());
  if (rmc != null) {
    try {
      Position pos=new Position(new Measurement(rmc.getLatitudeAsDMS().toDecimalDegrees() * Math.PI / 180.0,Unit.rad),new Measurement(rmc.getLongitudeAsDMS().toDecimalDegrees() * Math.PI / 180.0,Unit.rad),new Measurement(0.0d,Unit.m),null,null);
      return pos;
    }
 catch (    NumberFormatException e) {
      log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
      return null;
    }
  }
 else {
    return null;
  }
}","public Position getPosition(){
  RMC rmc=nmeaProvider.getLastRMC();
  if (rmc != null) {
    try {
      Position pos=new Position(new Measurement(rmc.getLatitudeAsDMS().toDecimalDegrees() * Math.PI / 180.0,Unit.rad),new Measurement(rmc.getLongitudeAsDMS().toDecimalDegrees() * Math.PI / 180.0,Unit.rad),new Measurement(0.0d,Unit.m),null,null);
      return pos;
    }
 catch (    NumberFormatException e) {
      log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
      return null;
    }
  }
 else {
    return null;
  }
}",0.904227782571182
180238,"public void setup() throws Exception {
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  String devnode_gps=""String_Node_Str"" + Integer.toString(slotId);
  String devnode_gpscontrol=""String_Node_Str"" + Integer.toString(slotId + 1);
  GPS gps=new GPS();
  CharDeviceUtils.openDeviceWithRetry(gps,devnode_gps,FCNTL_H.O_RDWR | FCNTL_H.O_NONBLOCK,2);
  int result=gps.init();
  if (result < 0) {
    throw new RuntimeException(""String_Node_Str"" + devnode_gpscontrol);
  }
  gpsis=new CharDeviceInputStream(gps);
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  long delay=getReadDelay();
  log.log(LogService.LOG_DEBUG,""String_Node_Str"" + delay);
  gpsd=new NMEARawFeed(gpsis,delay);
  nmeaProvider=new NMEASentenceProvider(gpsd.getInputStream(),context);
  gpscontrol=new GPSControl();
  CharDeviceUtils.openDeviceWithRetry(gpscontrol,devnode_gpscontrol,2);
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
}","public void setup() throws Exception {
  String devnode_gps=""String_Node_Str"" + Integer.toString(slotId);
  String devnode_gpscontrol=""String_Node_Str"" + Integer.toString(slotId + 1);
  GPS gps=new GPS();
  CharDeviceUtils.openDeviceWithRetry(gps,devnode_gps,FCNTL_H.O_RDWR | FCNTL_H.O_NONBLOCK,2);
  int result=gps.init();
  if (result < 0) {
    throw new RuntimeException(""String_Node_Str"" + devnode_gpscontrol);
  }
  gpsis=new CharDeviceInputStream(gps);
  long delay=getReadDelay();
  gpsd=new NMEARawFeed(gpsis,delay);
  nmeaProvider=new NMEASentenceProvider(gpsd.getInputStream(),context);
  gpscontrol=new GPSControl();
  CharDeviceUtils.openDeviceWithRetry(gpscontrol,devnode_gpscontrol,2);
}",0.8477722772277227
180239,"public com.buglabs.nmea.sentences.RMC getRMC(){
  if (cachedRMC == null) {
    return null;
  }
  return new com.buglabs.nmea.sentences.RMC(cachedRMC);
}","public com.buglabs.nmea.sentences.RMC getRMC(){
  if (cachedRMC == null || cachedRMC.getLatitude() == null || cachedRMC.getLongitude() == null) {
    return null;
  }
  return new com.buglabs.nmea.sentences.RMC(cachedRMC);
}",0.8116710875331565
180240,"/** 
 * bit 0: GPS FIX Active Low. bit 1: Overcurrent condition caused by the active antenna path. Active Low. bit 2: Output to wake up device from sleep after push_to_fix. Active High. bit 3: Input to download firmware to flash. bit 4: Unused bit 5: Unused bit 7, 6: 0, 1 Passtive Antenna (External Antenna) 1, 0 Active Antenna (Internal Antenna)
 * @return the value of the IOX register
 */
public int getStatus() throws IOException ;","/** 
 * bit 0: GPS FIX Active Low.  bit 1: Overcurrent condition caused by the active antenna path. Active Low.  bit 2: Output to wake up device from sleep after push_to_fix. Active High.  bit 3: Input to download firmware to flash.  bit 4: Unused  bit 5: Unused  bit 7, 6: 0, 1 Passtive Antenna (External Antenna) 1, 0 Active Antenna (Internal Antenna)
 * @return the value of the IOX register
 */
public int getStatus() throws IOException ;",0.9931662870159452
180241,"public void setup() throws Exception {
  String devnode_control=DEV_NODE_CONTROL;
  lcdcontrol=new LCDControl();
  if (lcdcontrol.open(devnode_control,FCNTL_H.O_RDWR) < 0) {
    throw new RuntimeException(""String_Node_Str"" + devnode_control);
  }
  String lcd_accel_devnode=""String_Node_Str"" + (slotId + 1);
  accel=new CharDevice();
  int result=accel.open(lcd_accel_devnode,FCNTL_H.O_RDWR);
  if (result >= 0) {
    accIs=new CharDeviceInputStream(accel);
    lcd_acc_is_prov=new LCDAccelerometerInputStreamProvider(accIs);
  }
 else {
    log.log(LogService.LOG_ERROR,""String_Node_Str"" + lcd_accel_devnode + ""String_Node_Str""+ result);
  }
}","public void setup() throws Exception {
  String devnode_control=DEV_NODE_CONTROL;
  lcdcontrol=new LCDControl();
  if (lcdcontrol.open(devnode_control,FCNTL_H.O_RDWR) < 0) {
    throw new RuntimeException(""String_Node_Str"" + devnode_control);
  }
  String lcd_accel_devnode=""String_Node_Str"" + (slotId + 1);
  accel=new CharDevice();
  try {
    CharDeviceUtils.openDeviceWithRetry(accel,lcd_accel_devnode,2);
    accIs=new CharDeviceInputStream(accel);
    lcd_acc_is_prov=new LCDAccelerometerInputStreamProvider(accIs);
  }
 catch (  IOException e) {
    log.log(LogService.LOG_ERROR,e.getMessage());
  }
}",0.805111821086262
180242,"public com.buglabs.nmea.sentences.RMC getRMC(){
  return new com.buglabs.nmea.sentences.RMC(cachedRMC);
}","public com.buglabs.nmea.sentences.RMC getRMC(){
  if (cachedRMC == null) {
    return null;
  }
  return new com.buglabs.nmea.sentences.RMC(cachedRMC);
}",0.813953488372093
180243,"/** 
 * For a given string, return true if is null or empy, false otherwise.
 * @param val
 * @return
 */
private boolean isEmpty(String val){
  return val == null || val.length() == 0;
}","/** 
 * For a given string, return true if is null or empty, false otherwise.
 * @param val
 * @return
 */
private boolean isEmpty(String val){
  return val == null || val.length() == 0;
}",0.9973333333333332
180244,"public RMC(com.buglabs.nmea2.RMC newRMC){
  super(""String_Node_Str"");
  this.timeOfFix=newRMC.getTimeOfFix();
  this.dataStatus=newRMC.getDataStatus();
  this.groundSpeed=newRMC.getGroundSpeed();
  this.dateStamp=newRMC.getDateStamp();
  this.magneticVariation=newRMC.getMagneticVariation();
  this.trackMadeGood=newRMC.getTrackMadeGood();
}","public RMC(com.buglabs.nmea2.RMC newRMC){
  super(""String_Node_Str"");
  this.timeOfFix=newRMC.getTimeOfFix();
  this.dataStatus=newRMC.getDataStatus();
  this.groundSpeed=newRMC.getGroundSpeed();
  this.dateStamp=newRMC.getDateStamp();
  this.magneticVariation=newRMC.getMagneticVariation();
  this.trackMadeGood=newRMC.getTrackMadeGood();
  this.setLatitude(newRMC.getLatitude());
  this.setLongitude(newRMC.getLongitude());
}",0.8880208333333334
180245,"public String getPublicName(){
  return ""String_Node_Str"";
}","public String getPublicName(){
  return serviceName;
}",0.8245614035087719
180246,"public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return ""String_Node_Str"";
      }
    }
;
  }
  return null;
}","public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider2.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return ""String_Node_Str"";
      }
    }
;
  }
  return null;
}",0.9983471074380166
180247,"public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider.GET) {
    return new WSResponse(getPositionXml(),""String_Node_Str"");
  }
  return null;
}","public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider2.GET) {
    return new WSResponse(getPositionXml(),""String_Node_Str"");
  }
  return null;
}",0.9972602739726028
180248,"public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return IMAGE_MIME_TYPE;
      }
    }
;
  }
  return null;
}","public PublicWSDefinition discover(int operation){
  if (operation == PublicWSProvider2.GET) {
    return new PublicWSDefinition(){
      public List getParameters(){
        return null;
      }
      public String getReturnType(){
        return IMAGE_MIME_TYPE;
      }
    }
;
  }
  return null;
}",0.9983361064891848
180249,"public String getPublicName(){
  return ""String_Node_Str"";
}","public String getPublicName(){
  return serviceName;
}",0.8245614035087719
180250,"public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider.GET) {
    return new WSResponse(getImageInputStream(),IMAGE_MIME_TYPE);
  }
  return null;
}","public IWSResponse execute(int operation,String input){
  if (operation == PublicWSProvider2.GET) {
    return new WSResponse(getImageInputStream(),IMAGE_MIME_TYPE);
  }
  return null;
}",0.9973045822102424
180251,"/** 
 * Will throw NMEAParserException if parsing error occurs.
 * @param dms
 */
public DegreesMinutesSeconds(String dms){
  if (dms == null || dms.length() == 0 || dms.indexOf(',') == -1 || dms.indexOf('.') == -1) {
    throw new NMEAParserException(""String_Node_Str"" + dms);
  }
  int i=dms.indexOf(""String_Node_Str"");
  this.dms=dms.substring(0,i);
}","/** 
 * Will throw NMEAParserException if parsing error occurs.
 * @param dms
 */
public DegreesMinutesSeconds(String dms){
  if (dms == null || dms.length() == 0 || dms.indexOf(',') == -1 || dms.indexOf('.') == -1) {
    throw new NMEAParserException(""String_Node_Str"" + dms);
  }
  int i=dms.indexOf(""String_Node_Str"");
  this.dms=dms.substring(0,i);
  if (dms.length() > i + 1) {
    direction=dms.charAt(i + 1);
  }
}",0.9135483870967742
180252,"/** 
 * @return Degrees part of DMS
 */
public double getDegrees(){
  int i=dms.indexOf(""String_Node_Str"");
  if (i < 2) {
    throw new NMEAParserException(""String_Node_Str"" + dms);
  }
  if (dms.charAt(0) == '0') {
    return Double.parseDouble(""String_Node_Str"" + dms.substring(1,i - 2));
  }
  return Double.parseDouble(dms.substring(0,i - 2));
}","/** 
 * @return Degrees part of DMS
 */
public double getDegrees(){
  int i=dms.indexOf(""String_Node_Str"");
  if (i < 2) {
    throw new NMEAParserException(""String_Node_Str"" + dms);
  }
  double rawVal=Double.parseDouble(dms.substring(0,i - 2));
  if (direction == 'S' || direction == 'W') {
    rawVal=rawVal * -1;
  }
  return rawVal;
}",0.6792452830188679
180253,"public void stop() throws Exception {
  StatusBarUtils.releaseRegion(context,regionKey);
  if (wsMotionTracker != null) {
    wsMotionTracker.close();
  }
  if (wsAccTracker != null) {
    wsAccTracker.close();
  }
  if (moduleRef != null) {
    moduleRef.unregister();
  }
  if (vhModuleRef != null) {
    vhModuleRef.unregister();
  }
  if (ledref != null) {
    ledref.unregister();
  }
  if (cc != null) {
    cc.close();
  }
}","public void stop() throws Exception {
  StatusBarUtils.releaseRegion(context,regionKey);
  if (vhc != null) {
    vhc.dispose();
  }
  if (wsMotionTracker != null) {
    wsMotionTracker.close();
  }
  if (vhLedRef != null) {
    vhLedRef.unregister();
  }
  if (wsAccTracker != null) {
    wsAccTracker.close();
  }
  if (moduleRef != null) {
    moduleRef.unregister();
  }
  if (vhModuleRef != null) {
    vhModuleRef.unregister();
  }
  if (vhSerialRef != null) {
    vhSerialRef.unregister();
  }
  if (ledref != null) {
    ledref.unregister();
  }
  if (cc != null) {
    cc.close();
  }
}",0.6686159844054581
180254,"public void start() throws Exception {
  moduleRef=context.registerService(IModuleControl.class.getName(),this,createBasicServiceProperties());
  vhModuleRef=context.registerService(IVonHippelModuleControl.class.getName(),vhc,createBasicServiceProperties());
  ledref=context.registerService(IModuleLEDController.class.getName(),vhc,createBasicServiceProperties());
  VonHippelWS vhWS=new VonHippelWS(vhDevice);
  wsMotionTracker=PublicWSAdminTracker.createTracker(context,vhWS);
  regionKey=StatusBarUtils.displayImage(context,icon,this.getModuleName());
}","public void start() throws Exception {
  moduleRef=context.registerService(IModuleControl.class.getName(),this,createBasicServiceProperties());
  vhModuleRef=context.registerService(IVonHippelModuleControl.class.getName(),vhc,createBasicServiceProperties());
  vhSerialRef=context.registerService(IVonHippelSerialPort.class.getName(),vhc,createBasicServiceProperties());
  vhLedRef=context.registerService(IModuleLEDController.class.getName(),vhc,createBasicServiceProperties());
  ledref=context.registerService(IModuleLEDController.class.getName(),vhc,createBasicServiceProperties());
  VonHippelWS vhWS=new VonHippelWS(vhDevice);
  wsMotionTracker=PublicWSAdminTracker.createTracker(context,vhWS);
  regionKey=StatusBarUtils.displayImage(context,icon,this.getModuleName());
}",0.8284644194756554
180255,"public InputStream getRS232InputStream(){
  try {
    return (cc.openInputStream());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","public InputStream getRS232InputStream(){
  try {
    if (cc == null) {
      cc=(CommConnection)Connector.open(getCommString(),Connector.READ_WRITE,true);
    }
    if (inputStream == null) {
      inputStream=cc.openInputStream();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return inputStream;
}",0.5548654244306418
180256,"public OutputStream getRS232OutputStream(){
  try {
    return (cc.openOutputStream());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","public OutputStream getRS232OutputStream(){
  try {
    if (cc == null) {
      cc=(CommConnection)Connector.open(getCommString(),Connector.READ_WRITE,true);
    }
    if (outputStream == null) {
      outputStream=cc.openOutputStream();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return outputStream;
}",0.6056910569105691
180257,"public VonHippelModuleControl(VonHippel vh,int slotId){
  vhDevice=vh;
  try {
    cc=(CommConnection)Connector.open(""String_Node_Str"" + slotId + ""String_Node_Str"",Connector.READ_WRITE,true);
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
  }
}","public VonHippelModuleControl(VonHippel vh,int slotId){
  vhDevice=vh;
  this.slotId=slotId;
  baudrate=""String_Node_Str"";
  bitsPerChar=8;
  stopBits=""String_Node_Str"";
  parity=""String_Node_Str"";
  autoCTS=false;
  autoRTS=false;
  blocking=false;
}",0.2961608775137112
180258,"/** 
 * Gets the input stream associated with the RS232 port on Von Hippel module. This implementation is based on the javax.microedition.commports API. The port is set up with the following parameters in VonHippelModuleControl: baudrate=9600 bitsperchar=8 stopbits=1 parity=none autocts=off autorts=off blocking=off
 * @return stream associated with RS232 input (reading)
 */
public InputStream getRS232InputStream();","/** 
 * Gets the input stream associated with the RS232 port on Von Hippel module. This implementation is based on the javax.microedition.commports API. The port is set up with the following parameters in VonHippelModuleControl: baudrate=9600 bitsperchar=8 stopbits=1 parity=none autocts=off autorts=off blocking=off
 * @deprecated
 * @return stream associated with RS232 input (reading)
 */
public InputStream getRS232InputStream();",0.982373678025852
180259,"/** 
 * Gets the output stream associated with the RS232 port on Von Hippel module. This implementation is based on the javax.microedition.commports API. The port is set up with the following parameters in VonHippelModuleControl: baudrate=9600 bitsperchar=8 stopbits=1 parity=none autocts=off autorts=off blocking=off
 * @return stream associated with RS232 output (writing)
 */
public OutputStream getRS232OutputStream();","/** 
 * Gets the output stream associated with the RS232 port on Von Hippel module. This implementation is based on the javax.microedition.commports API. The port is set up with the following parameters in VonHippelModuleControl: baudrate=9600 bitsperchar=8 stopbits=1 parity=none autocts=off autorts=off blocking=off
 * @deprecated
 * @return stream associated with RS232 output (writing)
 */
public OutputStream getRS232OutputStream();",0.9825378346915018
180260,"public RMC getLastRMC(){
  return cachedRMC;
}","public RMC getLastRMC(){
  if (cachedRMC == null || cachedRMC.getLatitude() == null || cachedRMC.getLongitude() == null) {
    return null;
  }
  return cachedRMC;
}",0.4360189573459715
180261,"/** 
 * @return Last parsed RMC NMEA sentence, or null if no sentence has been received.
 */
public com.buglabs.nmea2.RMC getLastRMC();","/** 
 * @return Last parsed RMC NMEA sentence, or null if no sentence with location information has been received.
 */
public com.buglabs.nmea2.RMC getLastRMC();",0.9121621621621622
180262,"public void start() throws Exception {
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  gpsd.start();
  nmeaProvider.start();
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  setPassiveAntenna();
  moduleRef=context.registerService(IModuleControl.class.getName(),this,null);
  ledRef=context.registerService(IModuleLEDController.class.getName(),this,createRemotableProperties(null));
  gpsControlRef=context.registerService(IGPSModuleControl.class.getName(),this,createRemotableProperties(null));
  nmeaRef=context.registerService(INMEARawFeed.class.getName(),gpsd,createRemotableProperties(null));
  nmeaProviderRef=context.registerService(INMEASentenceProvider.class.getName(),nmeaProvider,createRemotableProperties(null));
  wsTracker=PublicWSAdminTracker.createTracker(context,this);
  regionKey=StatusBarUtils.displayImage(context,icon,this.getModuleName());
  timer=new Timer();
  timer.schedule(new GPSFIXLEDStatusTask(this,log),500,5000);
  positionRef=context.registerService(IPositionProvider.class.getName(),this,createRemotableProperties(null));
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
}","public void start() throws Exception {
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  gpsd.start();
  nmeaProvider.start();
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  setPassiveAntenna();
  moduleRef=context.registerService(IModuleControl.class.getName(),this,null);
  ledRef=context.registerService(IModuleLEDController.class.getName(),this,createRemotableProperties(null));
  gpsControlRef=context.registerService(IGPSModuleControl.class.getName(),this,createRemotableProperties(null));
  nmeaRef=context.registerService(INMEARawFeed.class.getName(),gpsd,createRemotableProperties(null));
  nmeaProviderRef=context.registerService(INMEASentenceProvider.class.getName(),nmeaProvider,createRemotableProperties(null));
  wsTracker=PublicWSAdminTracker.createTracker(context,this);
  regionKey=StatusBarUtils.displayImage(context,icon,this.getModuleName());
  timer=new Timer();
  timer.schedule(new GPSFIXLEDStatusTask(this,log),500,5000);
  positionRef=context.registerService(IPositionProvider.class.getName(),this,createRemotableProperties(null));
  context.addServiceListener(nmeaProvider,""String_Node_Str"" + Constants.OBJECTCLASS + ""String_Node_Str""+ INMEASentenceSubscriber.class.getName()+ ""String_Node_Str"");
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
}",0.9308909242298083
180263,"public void stop() throws Exception {
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  timer.cancel();
  StatusBarUtils.releaseRegion(context,regionKey);
  if (wsTracker != null) {
    wsTracker.close();
  }
  moduleRef.unregister();
  gpsControlRef.unregister();
  nmeaRef.unregister();
  ledRef.unregister();
  positionRef.unregister();
  nmeaProviderRef.unregister();
  nmeaProvider.interrupt();
  gpsd.interrupt();
  gpsis.close();
  gpscontrol.close();
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
}","public void stop() throws Exception {
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  timer.cancel();
  StatusBarUtils.releaseRegion(context,regionKey);
  if (wsTracker != null) {
    wsTracker.close();
  }
  context.removeServiceListener(nmeaProvider);
  moduleRef.unregister();
  gpsControlRef.unregister();
  nmeaRef.unregister();
  ledRef.unregister();
  positionRef.unregister();
  nmeaProviderRef.unregister();
  nmeaProvider.interrupt();
  gpsd.interrupt();
  gpsis.close();
  gpscontrol.close();
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
}",0.9562790697674418
180264,"public void setup() throws Exception {
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  String devnode_gps=""String_Node_Str"" + Integer.toString(slotId);
  String devnode_gpscontrol=""String_Node_Str"" + Integer.toString(slotId + 1);
  GPS gps=new GPS();
  CharDeviceUtils.openDeviceWithRetry(gps,devnode_gps,FCNTL_H.O_RDWR | FCNTL_H.O_NONBLOCK,2);
  int result=gps.init();
  if (result < 0) {
    throw new RuntimeException(""String_Node_Str"" + devnode_gpscontrol);
  }
  gpsis=new CharDeviceInputStream(gps);
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  long delay=getReadDelay();
  log.log(LogService.LOG_DEBUG,""String_Node_Str"" + delay);
  gpsd=new NMEARawFeed(gpsis,delay);
  nmeaProvider=new NMEASentenceProvider(gpsd.getInputStream(),log);
  gpscontrol=new GPSControl();
  CharDeviceUtils.openDeviceWithRetry(gpscontrol,devnode_gpscontrol,2);
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
}","public void setup() throws Exception {
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  String devnode_gps=""String_Node_Str"" + Integer.toString(slotId);
  String devnode_gpscontrol=""String_Node_Str"" + Integer.toString(slotId + 1);
  GPS gps=new GPS();
  CharDeviceUtils.openDeviceWithRetry(gps,devnode_gps,FCNTL_H.O_RDWR | FCNTL_H.O_NONBLOCK,2);
  int result=gps.init();
  if (result < 0) {
    throw new RuntimeException(""String_Node_Str"" + devnode_gpscontrol);
  }
  gpsis=new CharDeviceInputStream(gps);
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
  long delay=getReadDelay();
  log.log(LogService.LOG_DEBUG,""String_Node_Str"" + delay);
  gpsd=new NMEARawFeed(gpsis,delay);
  nmeaProvider=new NMEASentenceProvider(gpsd.getInputStream(),context);
  gpscontrol=new GPSControl();
  CharDeviceUtils.openDeviceWithRetry(gpscontrol,devnode_gpscontrol,2);
  log.log(LogService.LOG_DEBUG,""String_Node_Str"");
}",0.9945175438596492
180265,"public NMEASentenceProvider(InputStream nmeaStream,LogService log){
  this.nmeaStream=nmeaStream;
  this.log=log;
}","public NMEASentenceProvider(InputStream nmeaStream,BundleContext context){
  this.nmeaStream=nmeaStream;
  this.context=context;
  this.log=LogServiceUtil.getLogService(context);
}",0.7050847457627119
180266,"public RMC getRMC(){
  return cachedRMC;
}","public com.buglabs.nmea.sentences.RMC getRMC(){
  return new com.buglabs.nmea.sentences.RMC(cachedRMC);
}",0.5714285714285714
180267,"public void run(){
  BufferedReader br=null;
  try {
    br=new BufferedReader(new InputStreamReader(nmeaStream));
    String sentence;
    NMEAParser parser=new NMEAParser();
    do {
      try {
        sentence=br.readLine();
      }
 catch (      CharConversionException e) {
        sentence=""String_Node_Str"";
        continue;
      }
      try {
        log.log(LogService.LOG_DEBUG,""String_Node_Str"" + sentence);
        Object objSentence=parser.parse(sentence);
        if (objSentence != null && objSentence instanceof RMC) {
          cachedRMC=(RMC)objSentence;
        }
      }
 catch (      NMEAParserException e) {
        log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
      }
    }
 while (!Thread.currentThread().isInterrupted() && (sentence != null));
  }
 catch (  IOException e) {
    log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
  }
 finally {
    try {
      if (br != null) {
        br.close();
      }
 else {
        if (nmeaStream != null) {
          nmeaStream.close();
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","public void run(){
  BufferedReader br=null;
  try {
    br=new BufferedReader(new InputStreamReader(nmeaStream));
    String sentence;
    do {
      try {
        sentence=br.readLine();
      }
 catch (      CharConversionException e) {
        sentence=""String_Node_Str"";
        continue;
      }
      try {
        log.log(LogService.LOG_DEBUG,""String_Node_Str"" + sentence);
        AbstractNMEASentence objSentence=NMEASentenceFactory.getSentence(sentence);
        if (objSentence != null && objSentence instanceof RMC) {
          cachedRMC=(RMC)objSentence;
          index++;
        }
        if (objSentence == null) {
          log.log(LogService.LOG_DEBUG,""String_Node_Str"" + sentence);
        }
 else {
          notifySubscribers(objSentence);
        }
      }
 catch (      NMEAParserException e) {
        log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
      }
    }
 while (!Thread.currentThread().isInterrupted() && (sentence != null));
  }
 catch (  IOException e) {
    log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
  }
 finally {
    try {
      if (br != null) {
        br.close();
      }
 else {
        if (nmeaStream != null) {
          nmeaStream.close();
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}",0.872651356993737
180268,"/** 
 * Provides the latest RMC sentence read from the GPS Device, or null if no information is available.
 * @return RMC sentence object
 */
public RMC getRMC();","/** 
 * Provides the latest RMC sentence read from the GPS Device, or null if no information is available.
 * @deprecated
 * @return RMC sentence object
 */
public RMC getRMC();",0.9557522123893806
180269,"protected void validate(){
  if (msg == null || code == null) {
    throw new NMEAParserException(""String_Node_Str"",null);
  }
}","protected void validate(){
  if (msg == null) {
    throw new NMEAParserException(""String_Node_Str"");
  }
}",0.9106382978723404
180270,"public GPSModlet(BundleContext context,int slotId,String moduleId,String moduleName){
  this.context=context;
  this.slotId=slotId;
  this.moduleName=moduleName;
  this.moduleId=moduleId;
  this.log=LogServiceUtil.getLogService(context);
}","/** 
 * @param context
 * @param slotId
 * @param moduleId
 * @param moduleName
 */
public GPSModlet(BundleContext context,int slotId,String moduleId,String moduleName){
  this.context=context;
  this.slotId=slotId;
  this.moduleName=moduleName;
  this.moduleId=moduleId;
  this.log=LogServiceUtil.getLogService(context);
}",0.8505338078291815
180271,"public Position getPosition(){
  RMC rmc=nmeaProvider.getRMC();
  if (rmc != null) {
    try {
      Position pos=new Position(new Measurement(rmc.getLatitudeAsDMS().toDecimalDegrees() * Math.PI / 180.0,Unit.rad),new Measurement(rmc.getLongitudeAsDMS().toDecimalDegrees() * Math.PI / 180.0,Unit.rad),new Measurement(0.0d,Unit.m),null,null);
      return pos;
    }
 catch (    NumberFormatException e) {
      log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
      return null;
    }
  }
 else {
    return null;
  }
}","public Position getPosition(){
  RMC rmc=nmeaProvider.getRMC();
  if (rmc != null && !rmc.isEmpty()) {
    try {
      Position pos=new Position(new Measurement(rmc.getLatitudeAsDMS().toDecimalDegrees() * Math.PI / 180.0,Unit.rad),new Measurement(rmc.getLongitudeAsDMS().toDecimalDegrees() * Math.PI / 180.0,Unit.rad),new Measurement(0.0d,Unit.m),null,null);
      return pos;
    }
 catch (    NumberFormatException e) {
      log.log(LogService.LOG_ERROR,""String_Node_Str"",e);
      return null;
    }
  }
 else {
    return null;
  }
}",0.9829867674858224
180272,public InputStream getInputStream() throws IOException ;,"/** 
 * @return NMEA data as a stream
 * @throws IOException
 */
public InputStream getInputStream() throws IOException ;",0.632768361581921
180273,"/** 
 * @return current position as Position object.
 */
public Position getPosition();","/** 
 * @return current position as Position object or null if unable to determine position.
 */
public Position getPosition();",0.8130841121495327
180274,"/** 
 * @return current position as LatLon object.
 */
public LatLon getLatitudeLongitude();","/** 
 * @return current position as LatLon object or null if unable to determine Lat/Long.
 */
public LatLon getLatitudeLongitude();",0.8214285714285714
180275,"/** 
 * @param val Set's the intensity of the backlight 0-7.
 */
public int setBlackLight(int val) throws IOException ;","/** 
 * @param val Set's the intensity of the backlight 0-7.
 * @deprecated use setBackLight.
 */
public int setBlackLight(int val) throws IOException ;",0.8782287822878229
180276,"public int putCounter(int columnIndex,CounterColor counterColor){
  if (columnIndex < 0 || columnIndex >= NB_COLUMNS || columnIsfull(columnIndex)) {
    return -1;
  }
  if (CounterColor.RED.equals(counterColor)) {
    colorBoards[0]^=1L << columnsMaxValueUsed[columnIndex]++;
  }
 else {
    colorBoards[1]^=1L << columnsMaxValueUsed[columnIndex]++;
  }
  int verticalIndex=(columnsMaxValueUsed[columnIndex] - ((COLUMN_SIZE + 1) * columnIndex)) - 1;
  if (checkWinningMove(colorBoards[0])) {
    winnerCounterColor=CounterColor.RED;
  }
  if (checkWinningMove(colorBoards[1])) {
    winnerCounterColor=CounterColor.RED;
  }
  numberOfCounters++;
  return verticalIndex;
}","public int putCounter(int columnIndex,CounterColor counterColor){
  if (columnIndex < 0 || columnIndex >= NB_COLUMNS || columnIsfull(columnIndex)) {
    return -1;
  }
  if (CounterColor.RED.equals(counterColor)) {
    colorBoards[0]^=1L << columnsMaxValueUsed[columnIndex]++;
  }
 else {
    colorBoards[1]^=1L << columnsMaxValueUsed[columnIndex]++;
  }
  int verticalIndex=(columnsMaxValueUsed[columnIndex] - ((COLUMN_SIZE + 1) * columnIndex)) - 1;
  if (checkWinningMove(colorBoards[0])) {
    winnerCounterColor=CounterColor.RED;
  }
  if (checkWinningMove(colorBoards[1])) {
    winnerCounterColor=CounterColor.YELLOW;
  }
  numberOfCounters++;
  return verticalIndex;
}",0.9948032665181886
180277,"public boolean putCounter(int columnIndex){
  int verticalIndex=board.putCounter(columnIndex,currentCounterColor);
  if (verticalIndex != -1) {
    currentCounterColor=getNotCurrentCounterColor();
    winnerCounterColor=board.getWinnerCounterColor();
    return true;
  }
  return false;
}","public boolean putCounter(int columnIndex){
  int verticalIndex=board.putCounter(columnIndex,currentCounterColor);
  if (verticalIndex != -1) {
    currentCounterColor=getNotCurrentCounterColor();
    winnerCounterColor=board.getWinnerCounterColor();
    lastValidVerticalIndex=verticalIndex;
    return true;
  }
  return false;
}",0.932258064516129
180278,"public Component createComponents(){
  initPlayers();
  JPanel panel=new JPanel();
  panel.setBorder(BorderFactory.createEmptyBorder(30,30,10,30));
  panel.setLayout(new GridLayout(0,1));
  DefaultTableModel defaultTableModel=buildTableModel();
  JTable jtable=buildJTable(defaultTableModel);
  panel.add(jtable);
  return panel;
}","public Component createComponents(){
  initPlayers();
  JPanel panel=new JPanel();
  panel.setBorder(BorderFactory.createEmptyBorder(30,30,10,30));
  panel.setLayout(new GridLayout(0,1));
  defaultTableModel=buildTableModel();
  JTable jtable=buildJTable(defaultTableModel);
  panel.add(jtable);
  resetGame();
  return panel;
}",0.7556904400606981
180279,"private JTable buildJTable(DefaultTableModel defaultTableModel){
  JTable jtable=new JTable();
  ImageIcon redIcon=new ImageIcon(this.getClass().getResource(""String_Node_Str""));
  ImageIcon yellowIcon=new ImageIcon(this.getClass().getResource(""String_Node_Str""));
  ImageIcon emptyIcon=new ImageIcon(this.getClass().getResource(""String_Node_Str""));
  Board board=BoardFactory.createBoard(""String_Node_Str"");
  for (int x=0; x < board.getNbColumns(); x++) {
    for (int y=0; y < board.getColumnSize(); y++) {
      CounterColor counterColor=board.getCounterColor(x,board.getColumnSize() - 1 - y);
      if (counterColor == null) {
        defaultTableModel.setValueAt(emptyIcon,y,x);
      }
      if (CounterColor.RED.equals(counterColor)) {
        defaultTableModel.setValueAt(redIcon,y,x);
      }
      if (CounterColor.YELLOW.equals(counterColor)) {
        defaultTableModel.setValueAt(yellowIcon,y,x);
      }
    }
  }
  jtable.setShowGrid(true);
  jtable.setSize(700,700);
  jtable.setModel(defaultTableModel);
  ;
  jtable.setRowHeight(100);
  jtable.getColumnModel().getColumn(0).setMinWidth(100);
  jtable.getColumnModel().getColumn(0).setMaxWidth(100);
  jtable.getColumnModel().getColumn(1).setMinWidth(100);
  jtable.getColumnModel().getColumn(1).setMaxWidth(100);
  jtable.getColumnModel().getColumn(2).setMinWidth(100);
  jtable.getColumnModel().getColumn(2).setMaxWidth(100);
  ;
  jtable.getColumnModel().getColumn(3).setMinWidth(100);
  jtable.getColumnModel().getColumn(3).setMaxWidth(100);
  jtable.getColumnModel().getColumn(4).setMinWidth(100);
  jtable.getColumnModel().getColumn(4).setMaxWidth(100);
  jtable.getColumnModel().getColumn(5).setMinWidth(100);
  jtable.getColumnModel().getColumn(5).setMaxWidth(100);
  jtable.getColumnModel().getColumn(6).setMinWidth(100);
  jtable.getColumnModel().getColumn(6).setMaxWidth(100);
  return jtable;
}","private JTable buildJTable(DefaultTableModel defaultTableModel){
  final JTable jtable=new JTable();
  redIcon=new ImageIcon(this.getClass().getResource(""String_Node_Str""));
  yellowIcon=new ImageIcon(this.getClass().getResource(""String_Node_Str""));
  emptyIcon=new ImageIcon(this.getClass().getResource(""String_Node_Str""));
  jtable.setShowGrid(true);
  jtable.setSize(700,700);
  jtable.setModel(defaultTableModel);
  jtable.setRowHeight(100);
  jtable.getColumnModel().getColumn(0).setMinWidth(100);
  jtable.getColumnModel().getColumn(0).setMaxWidth(100);
  jtable.getColumnModel().getColumn(1).setMinWidth(100);
  jtable.getColumnModel().getColumn(1).setMaxWidth(100);
  jtable.getColumnModel().getColumn(2).setMinWidth(100);
  jtable.getColumnModel().getColumn(2).setMaxWidth(100);
  jtable.getColumnModel().getColumn(3).setMinWidth(100);
  jtable.getColumnModel().getColumn(3).setMaxWidth(100);
  jtable.getColumnModel().getColumn(4).setMinWidth(100);
  jtable.getColumnModel().getColumn(4).setMaxWidth(100);
  jtable.getColumnModel().getColumn(5).setMinWidth(100);
  jtable.getColumnModel().getColumn(5).setMaxWidth(100);
  jtable.getColumnModel().getColumn(6).setMinWidth(100);
  jtable.getColumnModel().getColumn(6).setMaxWidth(100);
  jtable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  jtable.addMouseListener(new MouseListener(){
    @Override public void mouseClicked(    MouseEvent mouseEvent){
      putCounter(jtable.getSelectedColumn());
    }
    @Override public void mousePressed(    MouseEvent mouseEvent){
    }
    @Override public void mouseReleased(    MouseEvent mouseEvent){
    }
    @Override public void mouseEntered(    MouseEvent mouseEvent){
    }
    @Override public void mouseExited(    MouseEvent mouseEvent){
    }
  }
);
  return jtable;
}",0.1861353711790393
180280,"/** 
 * get available monomes
 * @return a map<name, info> with the monomes attached to this computer
 */
public String[] getDevices(){
  return (String[])monomesMap.keySet().toArray();
}","/** 
 * get available monomes
 * @return a map<name, info> with the monomes attached to this computer
 */
public String[] getDevices(){
  return monomesMap.keySet().toArray(new String[0]);
}",0.9389920424403184
180281,"/** 
 * Gives income to online players
 */
@SuppressWarnings(""String_Node_Str"") protected void handleOnlineIncome(){
  if (playersActivities.size() == 0)   return;
  if (iConomy == null) {
    logger.warning(""String_Node_Str"");
    return;
  }
  for (  Player player : getServer().getOnlinePlayers()) {
    final int activity=getActivity(player);
    if ((int)activity >= config.incomeMinActivity) {
      Holdings balance=iConomy.getAccount(player.getName()).getHoldings();
      Double amount=config.incomeBaseValue + (((double)(activity - config.incomeTargetActivity) / (double)config.incomeActivityModifier) * config.incomeBaseValue) + (balance.balance() * config.incomeBalanceMultiplier);
      if (amount > 0.0 || config.incomeAllowNegative) {
        balance.add(amount);
        sendMessage(player,""String_Node_Str"" + activityColor(activity) + iConomy.format(amount)+ ChatColor.GRAY+ ""String_Node_Str""+ activityColor(activity)+ activity+ ""String_Node_Str""+ ChatColor.GRAY+ ""String_Node_Str"");
        sendMessage(player,""String_Node_Str"" + ChatColor.WHITE + iConomy.format(balance.balance()));
        return;
      }
    }
    sendMessage(player,ChatColor.RED + ""String_Node_Str"");
  }
}","/** 
 * Gives income to online players
 */
@SuppressWarnings(""String_Node_Str"") protected void handleOnlineIncome(){
  if (playersActivities.size() == 0)   return;
  if (iConomy == null) {
    logger.warning(""String_Node_Str"");
    return;
  }
  for (  Player player : getServer().getOnlinePlayers()) {
    final int activity=getActivity(player);
    if ((int)activity >= config.incomeMinActivity) {
      Holdings balance=iConomy.getAccount(player.getName()).getHoldings();
      Double amount=config.incomeBaseValue + (((double)(activity - config.incomeTargetActivity) / (double)config.incomeActivityModifier) * config.incomeBaseValue) + (balance.balance() * config.incomeBalanceMultiplier);
      if (amount > 0.0 || config.incomeAllowNegative) {
        balance.add(amount);
        sendMessage(player,""String_Node_Str"" + activityColor(activity) + iConomy.format(amount)+ ChatColor.GRAY+ ""String_Node_Str""+ activityColor(activity)+ activity+ ""String_Node_Str""+ ChatColor.GRAY+ ""String_Node_Str"");
        sendMessage(player,""String_Node_Str"" + ChatColor.WHITE + iConomy.format(balance.balance()));
        continue;
      }
    }
    sendMessage(player,ChatColor.RED + ""String_Node_Str"");
  }
}",0.9941520467836256
180282,"public void onEnable(){
  new VanillaPlayerListener(this);
  loadConfig();
  getCommand(""String_Node_Str"").setExecutor(new VanillaCommand(this));
  pluginsCommand=new PluginsCommand(this);
  versionCommand=new VersionCommand(this);
}","public void onEnable(){
  new VanillaPlayerListener(this);
  getDataFolder().mkdirs();
  loadConfig();
  getCommand(""String_Node_Str"").setExecutor(new VanillaCommand(this));
  pluginsCommand=new PluginsCommand(this);
  versionCommand=new VersionCommand(this);
}",0.9433198380566802
180283,"public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  if (args.length == 0) {
    sender.sendMessage(""String_Node_Str"" + Bukkit.getName() + ""String_Node_Str""+ Bukkit.getVersion()+ ""String_Node_Str""+ Bukkit.getBukkitVersion()+ ""String_Node_Str"");
  }
 else {
    StringBuilder name=new StringBuilder();
    for (    String arg : args) {
      if (name.length() > 0) {
        name.append(' ');
      }
      name.append(arg);
    }
    Plugin plugin=Bukkit.getPluginManager().getPlugin(name.toString());
    if (plugin == null || vanillaPlugin.getConfigHandler().getHiddenPlugins().contains(plugin.getDescription().getName())) {
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
    }
 else {
      PluginDescriptionFile desc=plugin.getDescription();
      sender.sendMessage(ChatColor.GREEN + desc.getName() + ChatColor.WHITE+ ""String_Node_Str""+ ChatColor.GREEN+ desc.getVersion());
      if (desc.getDescription() != null) {
        sender.sendMessage(desc.getDescription());
      }
      if (desc.getWebsite() != null) {
        sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + desc.getWebsite());
      }
      if (!desc.getAuthors().isEmpty()) {
        if (desc.getAuthors().size() == 1) {
          sender.sendMessage(""String_Node_Str"" + getAuthors(desc));
        }
 else {
          sender.sendMessage(""String_Node_Str"" + getAuthors(desc));
        }
      }
    }
  }
  return true;
}","public boolean onCommand(CommandSender sender,Command cmd,String commandLabel,String[] args){
  if (args.length == 0) {
    sender.sendMessage(""String_Node_Str"" + Bukkit.getName() + ""String_Node_Str""+ Bukkit.getVersion()+ ""String_Node_Str""+ Bukkit.getBukkitVersion()+ ""String_Node_Str"");
  }
 else {
    StringBuilder name=new StringBuilder();
    for (    String arg : args) {
      if (name.length() > 0) {
        name.append(' ');
      }
      name.append(arg);
    }
    Plugin plugin=Bukkit.getPluginManager().getPlugin(name.toString());
    if (plugin == null || vanillaPlugin.getConfigHandler().getHiddenPlugins().contains(plugin.getDescription().getName().toLowerCase())) {
      sender.sendMessage(""String_Node_Str"");
      sender.sendMessage(""String_Node_Str"");
    }
 else {
      PluginDescriptionFile desc=plugin.getDescription();
      sender.sendMessage(ChatColor.GREEN + desc.getName() + ChatColor.WHITE+ ""String_Node_Str""+ ChatColor.GREEN+ desc.getVersion());
      if (desc.getDescription() != null) {
        sender.sendMessage(desc.getDescription());
      }
      if (desc.getWebsite() != null) {
        sender.sendMessage(""String_Node_Str"" + ChatColor.GREEN + desc.getWebsite());
      }
      if (!desc.getAuthors().isEmpty()) {
        if (desc.getAuthors().size() == 1) {
          sender.sendMessage(""String_Node_Str"" + getAuthors(desc));
        }
 else {
          sender.sendMessage(""String_Node_Str"" + getAuthors(desc));
        }
      }
    }
  }
  return true;
}",0.9953051643192488
180284,"@EventHandler() public void onPlayerCommandPreprocess(PlayerCommandPreprocessEvent event){
  Player player=event.getPlayer();
  String[] split=event.getMessage().split(""String_Node_Str"");
  String cmdName=split[0].substring(1).toLowerCase();
  String[] realArgs;
  if (split.length < 2) {
    realArgs=new String[0];
  }
 else {
    realArgs=new String[split.length - 2];
    for (int i=2; i < split.length; i++) {
      realArgs[i - 2]=split[i];
    }
  }
  boolean handled=true;
  ConfigHandler configHandler=plugin.getConfigHandler();
  if (pluginsCommandAliases.contains(cmdName) && !player.hasPermission(""String_Node_Str"")) {
    if (!configHandler.isHidingPluginsCommand()) {
      plugin.getPluginsCommand().onCommand(player,null,null,realArgs);
    }
  }
 else   if (versionCommandAliases.contains(cmdName) && !player.hasPermission(""String_Node_Str"")) {
    if (!configHandler.isHidingVersionCommand()) {
      plugin.getVersionCommand().onCommand(player,null,null,realArgs);
    }
  }
 else {
    handled=false;
  }
  if (handled) {
    event.setCancelled(true);
  }
}","@EventHandler() public void onPlayerCommandPreprocess(PlayerCommandPreprocessEvent event){
  Player player=event.getPlayer();
  String[] split=event.getMessage().split(""String_Node_Str"");
  String cmdName=split[0].substring(1).toLowerCase();
  String[] realArgs;
  realArgs=new String[split.length - 1];
  for (int i=1; i < split.length; i++) {
    realArgs[i - 1]=split[i];
  }
  boolean handled=true;
  ConfigHandler configHandler=plugin.getConfigHandler();
  if (pluginsCommandAliases.contains(cmdName) && !player.hasPermission(""String_Node_Str"")) {
    if (!configHandler.isHidingPluginsCommand()) {
      plugin.getPluginsCommand().onCommand(player,null,null,realArgs);
    }
  }
 else   if (versionCommandAliases.contains(cmdName) && !player.hasPermission(""String_Node_Str"")) {
    if (!configHandler.isHidingVersionCommand()) {
      plugin.getVersionCommand().onCommand(player,null,null,realArgs);
    }
  }
 else {
    handled=false;
  }
  if (handled) {
    event.setCancelled(true);
  }
}",0.9238921001926782
180285,"public Object unmarshal(HierarchicalStreamReader reader,UnmarshallingContext context){
  String className=reader.getAttribute(""String_Node_Str"");
  RubyClass c=runtime.getClass(className);
  if (c == null)   throw new IllegalArgumentException(""String_Node_Str"" + className);
  Class r=c.getReifiedClass();
  if (r != null) {
    Converter cnv=xs.getConverterLookup().lookupConverterForType(r);
    if (cnv != this)     return cnv.unmarshal(reader,context);
  }
  IRubyObject o=c.allocate();
  while (reader.hasMoreChildren()) {
    reader.moveDown();
    String fieldName=reader.getNodeName();
    Class valueType;
    className=reader.getAttribute(""String_Node_Str"");
    if (className != null) {
      valueType=mapper.realClass(className);
    }
 else {
      valueType=IRubyObject.class;
    }
    IRubyObject value=(IRubyObject)context.convertAnother(o,valueType);
    c.getVariableAccessorForWrite('@' + fieldName).set(o,value);
    reader.moveUp();
  }
  return o;
}","public Object unmarshal(HierarchicalStreamReader reader,UnmarshallingContext context){
  String className=reader.getAttribute(""String_Node_Str"");
  RubyClass c=resolveClass(className);
  if (c == null)   throw new IllegalArgumentException(""String_Node_Str"" + className);
  Class r=c.getReifiedClass();
  if (r != null) {
    Converter cnv=xs.getConverterLookup().lookupConverterForType(r);
    if (cnv != this)     return cnv.unmarshal(reader,context);
  }
  IRubyObject o=c.allocate();
  while (reader.hasMoreChildren()) {
    reader.moveDown();
    String fieldName=reader.getNodeName();
    Class valueType;
    className=reader.getAttribute(""String_Node_Str"");
    if (className != null) {
      valueType=mapper.realClass(className);
    }
 else {
      valueType=IRubyObject.class;
    }
    IRubyObject value=(IRubyObject)context.convertAnother(o,valueType);
    c.getVariableAccessorForWrite('@' + fieldName).set(o,value);
    reader.moveUp();
  }
  return o;
}",0.991761071060762
180286,"@Override protected void setUp() throws Exception {
  super.setUp();
  jruby=new ScriptingContainer();
  xs=new XStream(){
    @Override protected MapperWrapper wrapMapper(    MapperWrapper next){
      return new JRubyMapper(next);
    }
  }
;
  JRubyXStream.register(xs,jruby.getProvider().getRuntime());
}","@Override protected void setUp() throws Exception {
  super.setUp();
  jruby=new ScriptingContainer(LocalContextScope.SINGLETHREAD);
  xs=new XStream(){
    @Override protected MapperWrapper wrapMapper(    MapperWrapper next){
      return new JRubyMapper(next);
    }
  }
;
  JRubyXStream.register(xs,jruby.getProvider().getRuntime());
}",0.953560371517028
180287,"public Object unmarshal(HierarchicalStreamReader reader,UnmarshallingContext context){
  String className=reader.getAttribute(""String_Node_Str"");
  RubyClass c=runtime.getClass(className);
  IRubyObject o=c.allocate();
  while (reader.hasMoreChildren()) {
    reader.moveDown();
    String fieldName=reader.getNodeName();
    Class valueType;
    className=reader.getAttribute(""String_Node_Str"");
    if (className != null) {
      valueType=mapper.realClass(className);
    }
 else {
      valueType=IRubyObject.class;
    }
    IRubyObject value=(IRubyObject)context.convertAnother(o,valueType);
    c.getVariableAccessorForWrite('@' + fieldName).set(o,value);
    reader.moveUp();
  }
  return o;
}","public Object unmarshal(HierarchicalStreamReader reader,UnmarshallingContext context){
  String className=reader.getAttribute(""String_Node_Str"");
  RubyClass c=runtime.getClass(className);
  Class r=c.getReifiedClass();
  if (r != null) {
    return xs.getConverterLookup().lookupConverterForType(r).unmarshal(reader,context);
  }
  IRubyObject o=c.allocate();
  while (reader.hasMoreChildren()) {
    reader.moveDown();
    String fieldName=reader.getNodeName();
    Class valueType;
    className=reader.getAttribute(""String_Node_Str"");
    if (className != null) {
      valueType=mapper.realClass(className);
    }
 else {
      valueType=IRubyObject.class;
    }
    IRubyObject value=(IRubyObject)context.convertAnother(o,valueType);
    c.getVariableAccessorForWrite('@' + fieldName).set(o,value);
    reader.moveUp();
  }
  return o;
}",0.9080310880829016
180288,"public boolean canConvert(Class type){
  return RubyBasicObject.class.isAssignableFrom(type);
}","public boolean canConvert(Class type){
  return IRubyObject.class.isAssignableFrom(type);
}",0.967741935483871
180289,"public JRubyXStreamConverter(Ruby runtime,Mapper mapper){
  this.runtime=runtime;
  this.mapper=mapper;
}","public JRubyXStreamConverter(XStream xs,Ruby runtime){
  this.xs=xs;
  this.runtime=runtime;
  this.mapper=xs.getMapper();
}",0.7860262008733624
180290,"public void test1(){
  ScriptingContainer jruby=new ScriptingContainer();
  RubyObject o=(RubyObject)jruby.runScriptlet(""String_Node_Str"");
  XStream xs=new XStream(){
    @Override protected MapperWrapper wrapMapper(    MapperWrapper next){
      return new JRubyMapper(next);
    }
  }
;
  Ruby runtime=jruby.getProvider().getRuntime();
  xs.registerConverter(new RubyStringConverter(runtime));
  xs.registerConverter(new RubyFixnumConverter(runtime));
  xs.registerConverter(new JRubyXStreamConverter(runtime,xs.getMapper()),XStream.PRIORITY_LOW);
  System.out.println(xs.toXML(o));
}","public void test1(){
  RubyObject o=(RubyObject)jruby.runScriptlet(""String_Node_Str"");
  String xml=xs.toXML(o);
  System.out.println(xml);
  Object r=xs.fromXML(xml);
}",0.3677248677248677
180291,"/** 
 * Filterung der Liste anhand von gegebenen Filterelementen
 * @param mainList  Die Liste mit allen Elementen
 */
public List filter(List mainList){
  List<Object> temp=new ArrayList<Object>();
  for (  Object o : mainList) {
    boolean isValid=true;
    for (    XFilter filter : filterList) {
      if (filter.getFilterValue() != null && !filter.getFilterValue().isEmpty()) {
        try {
          Method om=null;
          Object oc=o;
          for (          String method : XHelper.getMethodPath(filter.getFilterPath())) {
            om=oc.getClass().getMethod(method,new Class[]{});
            oc=om.invoke(oc,new Object[]{});
          }
          if (!oc.toString().toUpperCase().matches(""String_Node_Str"" + filter.getFilterValue().toUpperCase() + ""String_Node_Str"")) {
            isValid=false;
            break;
          }
        }
 catch (        IllegalAccessException ex) {
        }
catch (        IllegalArgumentException ex) {
        }
catch (        InvocationTargetException ex) {
        }
catch (        NoSuchMethodException ex) {
        }
catch (        SecurityException ex) {
        }
      }
    }
    if (isValid) {
      temp.add(o);
    }
  }
  return temp;
}","/** 
 * Filterung der Liste anhand von gegebenen Filterelementen
 * @param mainList  Die Liste mit allen Elementen
 */
public List filter(List mainList){
  List<Object> temp=new ArrayList<Object>();
  String objValue=null;
  for (  Object o : mainList) {
    boolean isValid=true;
    for (    XFilter filter : filterList) {
      if (filter.getFilterValue() != null && !filter.getFilterValue().isEmpty()) {
        try {
          Method om=null;
          Object oc=o;
          for (          String method : XHelper.getMethodPath(filter.getFilterPath())) {
            om=oc.getClass().getMethod(method,new Class[]{});
            oc=om.invoke(oc,new Object[]{});
          }
          objValue=oc.toString();
switch (filter.getFilterType()) {
case INPUT:
{
              if (!objValue.toUpperCase().matches(""String_Node_Str"" + filter.getFilterValue().toUpperCase() + ""String_Node_Str"")) {
                isValid=false;
                break;
              }
              break;
            }
case SELECTONE:
{
            if (!objValue.equals(filter.getFilterValue())) {
              isValid=false;
              break;
            }
            break;
          }
case SELECTMULTIPLE:
{
          break;
        }
    }
  }
 catch (  IllegalAccessException ex) {
  }
catch (  IllegalArgumentException ex) {
  }
catch (  InvocationTargetException ex) {
  }
catch (  NoSuchMethodException ex) {
  }
catch (  SecurityException ex) {
  }
}
}
if (isValid) {
temp.add(o);
}
}
return temp;
}",0.7501853224610823
180292,"public List<Object> getValues(List subList){
  List<Object> temp=new ArrayList<Object>();
  for (  XFilter filter : filterList) {
    Object filterData=null;
switch (filter.getFilterType()) {
case INPUT:
case SUGGEST:
      filterData=new Object[]{filter.getElementId(),filter.getFilterType().toString(),filter.getFilterValue()};
    break;
case SELECTONE:
  filterData=new Object[]{filter.getElementId(),filter.getFilterType().toString(),getOptions(filter,subList),filter.getFilterValue()};
break;
case SELECTMULTIPLE:
filterData=new Object[]{filter.getElementId(),filter.getFilterType().toString(),getOptions(filter,subList),filter.getFilterValue()};
break;
}
temp.add(filterData);
}
return temp;
}","public List<Object> getValues(List subList){
  List<Object> temp=new ArrayList<Object>();
  for (  XFilter filter : filterList) {
    Object filterData=null;
switch (filter.getFilterType()) {
case INPUT:
case SUGGEST:
      filterData=new Object[]{filter.getElementId(),filter.getFilterType().toString(),filter.getFilterValue()};
    break;
case SELECTONE:
  filterData=new Object[]{filter.getElementId(),filter.getFilterType().toString(),getOptions(filter,subList),filter.getFilterValue()};
break;
case SELECTMULTIPLE:
break;
}
temp.add(filterData);
}
return temp;
}",0.8950276243093923
180293,"public static VerificationResult launch(Manager manager,Experiment experiment) throws Exception {
  ApplicationConfiguration configuration=new ApplicationConfiguration();
  ExtensionDescriptor descriptor=manager.resolve(ParasimDescriptor.class,Default.class).getExtensionDescriptor(""String_Node_Str"");
  if (descriptor != null) {
    manager.resolve(ExtensionDescriptorMapper.class,Default.class).map(descriptor,configuration);
  }
  ComputationContainer container=manager.resolve(ComputationContainer.class,Default.class);
  for (  OdeSystemVariable variable : experiment.getOdeSystem()) {
    LOGGER.info(variable.getName() + ""String_Node_Str"" + variable.getRightSideExpression().toFormula());
  }
  LOGGER.info(getFormulaInfo(experiment.getFormula()));
  Future<VerificationResult> result=container.compute(new ValidityRegionsComputation(configuration,experiment.getOdeSystem(),experiment.getPrecisionConfiguration(),experiment.getSimulationSpace(),experiment.getInitialSpace(),experiment.getFormula(),experiment.getIterationLimit()));
  try {
    return result.get(experiment.getTimeoutAmount(),experiment.getTimeoutUnit());
  }
 catch (  TimeoutException e) {
    LOGGER.error(""String_Node_Str"");
    result.cancel(true);
    return result.getPartial();
  }
}","public static VerificationResult launch(Manager manager,Experiment experiment) throws Exception {
  ApplicationConfiguration configuration=manager.resolve(ApplicationConfiguration.class,Default.class);
  ComputationContainer container=manager.resolve(ComputationContainer.class,Default.class);
  for (  OdeSystemVariable variable : experiment.getOdeSystem()) {
    LOGGER.info(variable.getName() + ""String_Node_Str"" + variable.getRightSideExpression().toFormula());
  }
  LOGGER.info(getFormulaInfo(experiment.getFormula()));
  Future<VerificationResult> result=container.compute(new ValidityRegionsComputation(experiment.getOdeSystem(),experiment.getPrecisionConfiguration(),experiment.getSimulationSpace(),experiment.getInitialSpace(),experiment.getFormula(),experiment.getIterationLimit()));
  try {
    return result.get(experiment.getTimeoutAmount(),experiment.getTimeoutUnit());
  }
 catch (  TimeoutException e) {
    LOGGER.error(""String_Node_Str"");
    result.cancel(true);
    return result.getPartial();
  }
}",0.8791593695271454
180294,"public ValidityRegionsComputation(ApplicationConfiguration configuration,OdeSystem odeSystem,PrecisionConfiguration precisionConfiguration,OrthogonalSpace simulationSpace,OrthogonalSpace initialSpace,Formula property,int iterationLimit){
  if (configuration == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (odeSystem == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (precisionConfiguration == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (simulationSpace == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (initialSpace == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (property == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.odeSystem=odeSystem;
  this.precisionConfiguration=precisionConfiguration;
  this.simulationSpace=new OrthogonalSpaceImpl(simulationSpace.getMinBounds(),new ArrayPoint(property.getTimeNeeded(),simulationSpace.getMaxBounds().toArray()),simulationSpace.getOdeSystem());
  this.originalSimulationSpace=simulationSpace;
  this.initialSpace=initialSpace;
  this.property=property;
  this.iterationLimit=iterationLimit;
  this.configuration=configuration;
  if (new FormulaStarInfo(property).getStarNumber() == 0) {
    LOGGER.debug(""String_Node_Str"");
    useFrozenVerifier=false;
  }
 else {
    LOGGER.debug(""String_Node_Str"");
    useFrozenVerifier=true;
  }
}","public ValidityRegionsComputation(OdeSystem odeSystem,PrecisionConfiguration precisionConfiguration,OrthogonalSpace simulationSpace,OrthogonalSpace initialSpace,Formula property,int iterationLimit){
  if (odeSystem == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (precisionConfiguration == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (simulationSpace == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (initialSpace == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (property == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.odeSystem=odeSystem;
  this.precisionConfiguration=precisionConfiguration;
  this.simulationSpace=new OrthogonalSpaceImpl(simulationSpace.getMinBounds(),new ArrayPoint(property.getTimeNeeded(),simulationSpace.getMaxBounds().toArray()),simulationSpace.getOdeSystem());
  this.originalSimulationSpace=simulationSpace;
  this.initialSpace=initialSpace;
  this.property=property;
  this.iterationLimit=iterationLimit;
  if (new FormulaStarInfo(property).getStarNumber() == 0) {
    LOGGER.debug(""String_Node_Str"");
    useFrozenVerifier=false;
  }
 else {
    LOGGER.debug(""String_Node_Str"");
    useFrozenVerifier=true;
  }
}",0.8471268521864835
180295,"public Computation<VerificationResult> cloneComputation(){
  ValidityRegionsComputation computation=new ValidityRegionsComputation(configuration,odeSystem,precisionConfiguration,originalSimulationSpace,initialSpace,property,iterationLimit);
  computation.currentIteration=this.currentIteration;
  computation.spawned=this.spawned;
  return computation;
}","public Computation<VerificationResult> cloneComputation(){
  ValidityRegionsComputation computation=new ValidityRegionsComputation(odeSystem,precisionConfiguration,originalSimulationSpace,initialSpace,property,iterationLimit);
  computation.currentIteration=this.currentIteration;
  computation.spawned=this.spawned;
  return computation;
}",0.9798270893371758
180296,"@Test(enabled=false) public void testComputation2() throws ExecutionException, InterruptedException, TimeoutException {
  ValidityRegionsComputation computation=new ValidityRegionsComputation(new ApplicationConfiguration(),createOdeSystem(),createPrecisionConfiguration(),createSimulationSpace(),createInitialSpace(),createFutureFormula(2),0);
  ComputationContainer container=getManager().resolve(ComputationContainer.class,Default.class);
  VerificationResult result=container.compute(computation).get(40,TimeUnit.SECONDS);
  for (int i=0; i < result.size(); i++) {
    assertEquals(result.getPoint(i).getTime(),0f);
    if (result.getPoint(i).getValue(0) > 2) {
      assertTrue(result.getRobustness(i).getValue() > 0,""String_Node_Str"" + i + ""String_Node_Str""+ result.getPoint(i)+ ""String_Node_Str""+ result.getRobustness(i).getValue());
    }
 else {
      assertTrue(result.getRobustness(i).getValue() <= 0,""String_Node_Str"" + i + ""String_Node_Str""+ result.getPoint(i)+ ""String_Node_Str""+ result.getRobustness(i).getValue());
    }
  }
}","@Test(enabled=false) public void testComputation2() throws ExecutionException, InterruptedException, TimeoutException {
  ValidityRegionsComputation computation=new ValidityRegionsComputation(createOdeSystem(),createPrecisionConfiguration(),createSimulationSpace(),createInitialSpace(),createFutureFormula(2),0);
  ComputationContainer container=getManager().resolve(ComputationContainer.class,Default.class);
  VerificationResult result=container.compute(computation).get(40,TimeUnit.SECONDS);
  for (int i=0; i < result.size(); i++) {
    assertEquals(result.getPoint(i).getTime(),0f);
    if (result.getPoint(i).getValue(0) > 2) {
      assertTrue(result.getRobustness(i).getValue() > 0,""String_Node_Str"" + i + ""String_Node_Str""+ result.getPoint(i)+ ""String_Node_Str""+ result.getRobustness(i).getValue());
    }
 else {
      assertTrue(result.getRobustness(i).getValue() <= 0,""String_Node_Str"" + i + ""String_Node_Str""+ result.getPoint(i)+ ""String_Node_Str""+ result.getRobustness(i).getValue());
    }
  }
}",0.98488542174549
180297,"@Test public void testComputation() throws ExecutionException, InterruptedException, TimeoutException {
  ValidityRegionsComputation computation=new ValidityRegionsComputation(new ApplicationConfiguration(),createOdeSystem(),createPrecisionConfiguration(),createSimulationSpace(),createInitialSpace(),createFutureFormula(-1f),0);
  ComputationContainer container=getManager().resolve(ComputationContainer.class,Default.class);
  VerificationResult result=container.compute(computation).get(40,TimeUnit.SECONDS);
  for (int i=0; i < result.size(); i++) {
    assertTrue(result.getRobustness(i).getValue() > 0,""String_Node_Str"" + i + ""String_Node_Str""+ result.getPoint(i)+ ""String_Node_Str""+ result.getRobustness(i).getValue());
    assertEquals(result.getPoint(i).getTime(),0f);
  }
}","@Test public void testComputation() throws ExecutionException, InterruptedException, TimeoutException {
  ValidityRegionsComputation computation=new ValidityRegionsComputation(createOdeSystem(),createPrecisionConfiguration(),createSimulationSpace(),createInitialSpace(),createFutureFormula(-1f),0);
  ComputationContainer container=getManager().resolve(ComputationContainer.class,Default.class);
  VerificationResult result=container.compute(computation).get(40,TimeUnit.SECONDS);
  for (int i=0; i < result.size(); i++) {
    assertTrue(result.getRobustness(i).getValue() > 0,""String_Node_Str"" + i + ""String_Node_Str""+ result.getPoint(i)+ ""String_Node_Str""+ result.getRobustness(i).getValue());
    assertEquals(result.getPoint(i).getTime(),0f);
  }
}",0.9798045602605864
180298,"public static void main(String[] args) throws Exception {
  Experiment experiment=null;
  VerificationResult result=null;
  ParasimOptions options=ParasimOptions.create(args);
  if (options.getConfigFile() != null) {
    System.setProperty(""String_Node_Str"",options.getConfigFile());
  }
  Manager manager=ManagerImpl.create().start();
  Actions actions=new Actions(manager,options);
  try {
    if (actions.help().isEnabled()) {
      actions.help().call();
    }
    if (actions.loadExperiment().isEnabled()) {
      experiment=actions.loadExperiment().call();
    }
    if (actions.compute(experiment).isEnabled()) {
      result=actions.compute(experiment).call();
    }
    if (actions.loadResults(experiment).isEnabled()) {
      result=actions.loadResults(experiment).call();
    }
    if (actions.plotResults(result,experiment).isEnabled()) {
      actions.plotResults(result,experiment).call();
    }
    if (actions.exportToCsv(result,experiment).isEnabled()) {
      actions.exportToCsv(result,experiment).call();
    }
    if (actions.startServer().isEnabled()) {
      actions.startServer().call();
    }
    if (actions.startGuiManager().isEnabled()) {
      actions.startGuiManager().call();
    }
  }
 catch (  ParseException e) {
    actions.help().call();
  }
 finally {
    if (actions.shutdown().isEnabled()) {
      actions.shutdown().call();
    }
  }
}","public static void main(String[] args) throws Exception {
  Experiment experiment=null;
  VerificationResult result=null;
  ParasimOptions options=ParasimOptions.create(args);
  if (options.getConfigFile() != null) {
    System.setProperty(""String_Node_Str"",options.getConfigFile());
  }
  Manager manager=ManagerImpl.create().start();
  if (options.getConfigFile() != null) {
    LOGGER.info(""String_Node_Str"" + options.getConfigFile());
  }
  Actions actions=new Actions(manager,options);
  try {
    if (actions.help().isEnabled()) {
      actions.help().call();
    }
    if (actions.loadExperiment().isEnabled()) {
      experiment=actions.loadExperiment().call();
    }
    if (actions.compute(experiment).isEnabled()) {
      result=actions.compute(experiment).call();
    }
    if (actions.loadResults(experiment).isEnabled()) {
      result=actions.loadResults(experiment).call();
    }
    if (actions.plotResults(result,experiment).isEnabled()) {
      actions.plotResults(result,experiment).call();
    }
    if (actions.exportToCsv(result,experiment).isEnabled()) {
      actions.exportToCsv(result,experiment).call();
    }
    if (actions.startServer().isEnabled()) {
      actions.startServer().call();
    }
    if (actions.startGuiManager().isEnabled()) {
      actions.startGuiManager().call();
    }
  }
 catch (  ParseException e) {
    actions.help().call();
  }
 finally {
    if (actions.shutdown().isEnabled()) {
      actions.shutdown().call();
    }
  }
}",0.9625481274063704
180299,"public ValidityRegionsComputation(OdeSystem odeSystem,PrecisionConfiguration precisionConfiguration,OrthogonalSpace simulationSpace,OrthogonalSpace initialSpace,Formula property,int iterationLimit){
  if (odeSystem == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (precisionConfiguration == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (simulationSpace == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (initialSpace == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (property == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.odeSystem=odeSystem;
  this.precisionConfiguration=precisionConfiguration;
  this.simulationSpace=new OrthogonalSpaceImpl(simulationSpace.getMinBounds(),new ArrayPoint(Math.min(property.getTimeNeeded(),simulationSpace.getMaxBounds().getTime()),simulationSpace.getMaxBounds().toArray()),simulationSpace.getOdeSystem());
  this.originalSimulationSpace=simulationSpace;
  this.initialSpace=initialSpace;
  this.property=property;
  this.iterationLimit=iterationLimit;
}","public ValidityRegionsComputation(OdeSystem odeSystem,PrecisionConfiguration precisionConfiguration,OrthogonalSpace simulationSpace,OrthogonalSpace initialSpace,Formula property,int iterationLimit){
  if (odeSystem == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (precisionConfiguration == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (simulationSpace == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (initialSpace == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (property == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.odeSystem=odeSystem;
  this.precisionConfiguration=precisionConfiguration;
  this.simulationSpace=new OrthogonalSpaceImpl(simulationSpace.getMinBounds(),new ArrayPoint(property.getTimeNeeded(),simulationSpace.getMaxBounds().toArray()),simulationSpace.getOdeSystem());
  this.originalSimulationSpace=simulationSpace;
  this.initialSpace=initialSpace;
  this.property=property;
  this.iterationLimit=iterationLimit;
}",0.970917225950783
180300,"@Override public VerificationResult call() throws Exception {
  if (threadId.currentId() == 0) {
    spawned=emit(spawner.spawn(initialSpace));
  }
  VerificationResult result=null;
  while (spawned != null) {
    currentIteration++;
    LOGGER.info(""String_Node_Str"" + threadId.currentId() + ""String_Node_Str""+ currentIteration+ ""String_Node_Str""+ spawned.size()+ ""String_Node_Str""+ spawned.getSecondaryTrajectories().size()+ ""String_Node_Str"");
    SimulatedDataBlock<TrajectoryWithNeighborhood> simulated=simulator.simulate(simulationConfiguration,spawned);
    SimulatedDataBlock simulatedSecondary=null;
    if (spawned.getSecondaryTrajectories().size() > 0) {
      simulatedSecondary=simulator.simulate(simulationConfiguration,spawned.getSecondaryTrajectories());
    }
    VerifiedDataBlock<TrajectoryWithNeighborhood> verified=verifier.verify(simulated,property);
    if (result == null) {
      result=new VerifiedDataBlockResultAdapter(verified);
    }
 else {
      result=result.merge(new VerifiedDataBlockResultAdapter(verified));
    }
    if (iterationLimit != 0 && currentIteration == iterationLimit) {
      if (simulatedSecondary != null) {
        VerifiedDataBlock<Trajectory> verifiedSecondary=verifier.verify(simulatedSecondary,property);
        result=result.merge(new VerifiedDataBlockResultAdapter(verifiedSecondary));
      }
      LOGGER.warn(""String_Node_Str"" + threadId.currentId() + ""String_Node_Str""+ iterationLimit+ ""String_Node_Str"");
      break;
    }
 else {
      DistanceCheckedDataBlock distanceChecked=distanceChecker.check(spawned.getConfiguration(),verified);
      if (simulatedSecondary.size() != 0) {
        VerifiedDataBlock<Trajectory> verifiedSecondary=verifier.verify(simulatedSecondary,property);
        result=result.merge(new VerifiedDataBlockResultAdapter(verifiedSecondary));
      }
      spawned=emit(spawner.spawn(spawned.getConfiguration(),distanceChecked));
    }
  }
  return result;
}","@Override public VerificationResult call() throws Exception {
  if (threadId.currentId() == 0) {
    spawned=emit(spawner.spawn(initialSpace));
  }
  VerificationResult result=null;
  while (spawned != null) {
    currentIteration++;
    LOGGER.info(""String_Node_Str"" + threadId.currentId() + ""String_Node_Str""+ currentIteration+ ""String_Node_Str""+ spawned.size()+ ""String_Node_Str""+ spawned.getSecondaryTrajectories().size()+ ""String_Node_Str"");
    SimulatedDataBlock<TrajectoryWithNeighborhood> simulated=simulator.simulate(simulationConfiguration,spawned);
    SimulatedDataBlock simulatedSecondary=null;
    if (spawned.getSecondaryTrajectories().size() > 0) {
      simulatedSecondary=simulator.simulate(simulationConfiguration,spawned.getSecondaryTrajectories());
    }
    VerifiedDataBlock<TrajectoryWithNeighborhood> verified=verifier.verify(simulated,property);
    if (result == null) {
      result=new VerifiedDataBlockResultAdapter(verified);
    }
 else {
      result=result.merge(new VerifiedDataBlockResultAdapter(verified));
    }
    if (iterationLimit != 0 && currentIteration == iterationLimit) {
      if (simulatedSecondary != null) {
        VerifiedDataBlock<Trajectory> verifiedSecondary=verifier.verify(simulatedSecondary,property);
        result=result.merge(new VerifiedDataBlockResultAdapter(verifiedSecondary));
      }
      LOGGER.warn(""String_Node_Str"" + threadId.currentId() + ""String_Node_Str""+ iterationLimit+ ""String_Node_Str"");
      break;
    }
 else {
      DistanceCheckedDataBlock distanceChecked=distanceChecker.check(spawned.getConfiguration(),verified);
      if (simulatedSecondary != null) {
        VerifiedDataBlock<Trajectory> verifiedSecondary=verifier.verify(simulatedSecondary,property);
        result=result.merge(new VerifiedDataBlockResultAdapter(verifiedSecondary));
      }
      spawned=emit(spawner.spawn(spawned.getConfiguration(),distanceChecked));
    }
  }
  return result;
}",0.9969183359013868
180301,"@Override public void setIterationLimit(int iterationLimit){
  if (iterationLimit != iterationLimit) {
    content.setIterationLimit(iterationLimit);
    saved=false;
  }
}","@Override public void setIterationLimit(int iterationLimit){
  if (iterationLimit != getIterationLimit()) {
    content.setIterationLimit(iterationLimit);
    saved=false;
  }
}",0.9799426934097422
180302,"@Override protected SpawnedResult spawnTrajectories(Configuration configuration,Trajectory trajectory,Trajectory neighbor,Distance distance){
  Trajectory newPrimary=neighbor;
  int diffDimension=-1;
  for (int dim=0; dim < trajectory.getDimension(); dim++) {
    if (trajectory.getFirstPoint().getValue(dim) != neighbor.getFirstPoint().getValue(dim)) {
      if (diffDimension != -1) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      diffDimension=dim;
    }
  }
  float radius=Math.abs(trajectory.getFirstPoint().getValue(diffDimension) - neighbor.getFirstPoint().getValue(diffDimension)) / 2;
  List<Trajectory> neighborTrajectories=new ArrayList<>();
  List<Trajectory> spawnedSecondaryTrajectories=new ArrayList<>();
  for (int dim=0; dim < trajectory.getDimension(); dim++) {
    for (int sign=-1; sign <= 1; sign+=2) {
      float[] newPointData=newPrimary.getFirstPoint().toArrayCopy();
      newPointData[dim]+=sign * radius;
      Trajectory newTrajectory=new PointTrajectory(trajectory.getFirstPoint().getTime(),newPointData);
      if (!configuration.getInitialSpace().isIn(newTrajectory.getFirstPoint())) {
        continue;
      }
synchronized (alreadySpawnedCollisionTrajectories) {
        if (alreadySpawnedCollisionTrajectories.containsKey(newTrajectory.getFirstPoint())) {
          WeakReference<Trajectory> reference=alreadySpawnedCollisionTrajectories.get(newTrajectory.getFirstPoint());
          if (reference.get() != null) {
            newTrajectory=reference.get() instanceof TrajectoryWithNeighborhood ? ((TrajectoryWithNeighborhood)reference.get()).withoutNeighbors() : reference.get();
          }
 else {
            alreadySpawnedCollisionTrajectories.put(newTrajectory.getFirstPoint(),new WeakReferenceWithEquals<>(newTrajectory));
          }
        }
 else {
          alreadySpawnedCollisionTrajectories.put(newTrajectory.getFirstPoint(),new WeakReferenceWithEquals<>(newTrajectory));
          spawnedSecondaryTrajectories.add(newTrajectory);
        }
      }
      neighborTrajectories.add(newTrajectory);
    }
  }
  Collection<TrajectoryWithNeighborhood> spawnedCol=new ArrayList<>();
synchronized (alreadySpawnedPrimaryTrajectories) {
    if (!alreadySpawnedPrimaryTrajectories.containsKey(newPrimary.getFirstPoint())) {
      spawnedCol.add(TrajectoryWithNeighborhoodWrapper.createAndUpdateReference(newPrimary,new ListDataBlock<>(neighborTrajectories)));
      alreadySpawnedPrimaryTrajectories.put(newPrimary.getFirstPoint(),new WeakReferenceWithEquals<>(newPrimary));
    }
  }
  return new SpawnedResult(spawnedCol,spawnedCol.isEmpty() ? Collections.EMPTY_LIST : spawnedSecondaryTrajectories);
}","@Override protected SpawnedResult spawnTrajectories(Configuration configuration,Trajectory trajectory,Trajectory neighbor,Distance distance){
  Trajectory newPrimary=neighbor;
  int diffDimension=-1;
  for (int dim=0; dim < trajectory.getDimension(); dim++) {
    if (trajectory.getFirstPoint().getValue(dim) != neighbor.getFirstPoint().getValue(dim)) {
      if (diffDimension != -1) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      diffDimension=dim;
    }
  }
  float radius=Math.abs(trajectory.getFirstPoint().getValue(diffDimension) - neighbor.getFirstPoint().getValue(diffDimension)) / 2;
  List<Trajectory> neighborTrajectories=new ArrayList<>();
  List<Trajectory> spawnedSecondaryTrajectories=new ArrayList<>();
  for (int dim=0; dim < trajectory.getDimension(); dim++) {
    for (int sign=-1; sign <= 1; sign+=2) {
      float[] newPointData=newPrimary.getFirstPoint().toArrayCopy();
      newPointData[dim]+=sign * radius;
      Trajectory newTrajectory=new PointTrajectory(trajectory.getFirstPoint().getTime(),newPointData);
      if (!configuration.getInitialSpace().isIn(newTrajectory.getFirstPoint())) {
        continue;
      }
synchronized (alreadySpawnedCollisionTrajectories) {
        if (alreadySpawnedCollisionTrajectories.containsKey(newTrajectory.getFirstPoint())) {
          Trajectory cachedTrajectory=alreadySpawnedCollisionTrajectories.get(newTrajectory.getFirstPoint());
          if (cachedTrajectory != null) {
            newTrajectory=cachedTrajectory.getReference().getTrajectory() instanceof TrajectoryWithNeighborhood ? ((TrajectoryWithNeighborhood)cachedTrajectory.getReference().getTrajectory()).withoutNeighbors() : cachedTrajectory.getReference().getTrajectory();
          }
 else {
            alreadySpawnedCollisionTrajectories.put(newTrajectory.getFirstPoint(),newTrajectory);
          }
        }
 else {
          alreadySpawnedCollisionTrajectories.put(newTrajectory.getFirstPoint(),newTrajectory);
        }
      }
      spawnedSecondaryTrajectories.add(newTrajectory);
      neighborTrajectories.add(newTrajectory);
    }
  }
  Collection<TrajectoryWithNeighborhood> spawnedCol=new ArrayList<>();
synchronized (alreadySpawnedPrimaryTrajectories) {
    if (!alreadySpawnedPrimaryTrajectories.containsKey(newPrimary.getFirstPoint())) {
      spawnedCol.add(TrajectoryWithNeighborhoodWrapper.createAndUpdateReference(newPrimary,new ListDataBlock<>(neighborTrajectories)));
      alreadySpawnedPrimaryTrajectories.put(newPrimary.getFirstPoint(),newPrimary);
    }
  }
  return new SpawnedResult(spawnedCol,spawnedCol.isEmpty() ? Collections.EMPTY_LIST : spawnedSecondaryTrajectories);
}",0.8623922009748781
180303,"@Override public Monitor createMonitor(Trajectory trajectory,Formula property){
  if (trajectory.getLastPoint().getTime() < property.getTimeNeeded()) {
    throw new IllegalArgumentException(""String_Node_Str"" + property + ""String_Node_Str""+ property.getTimeNeeded()+ ""String_Node_Str""+ trajectory.getLastPoint().getTime()+ ""String_Node_Str"");
  }
switch (property.getType()) {
case AND:
    return new AndMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)));
case FUTURE:
  return new FutureMonitor(property,createMonitor(trajectory,property.getSubformula(0)),((FutureFormula)property).getInterval());
case GLOBALLY:
return new GloballyMonitor(property,createMonitor(trajectory,property.getSubformula(0)),((GloballyFormula)property).getInterval());
case NOT:
return new NotMonitor(property,createMonitor(trajectory,property.getSubformula(0)));
case OR:
return new OrMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)));
case PREDICATE:
return new PredicateMonitor(property,trajectory,(Predicate)property);
case UNTIL:
return new UntilMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)),((UntilFormula)property).getInterval());
default :
throw new UnsupportedOperationException(""String_Node_Str"" + property.getType() + ""String_Node_Str"");
}
}","@Override public Monitor createMonitor(Trajectory trajectory,Formula property){
  if (trajectory.getLastPoint().getTime() < property.getTimeNeeded()) {
    throw new IllegalArgumentException(""String_Node_Str"" + property + ""String_Node_Str""+ property.getTimeNeeded()+ ""String_Node_Str""+ trajectory.getLastPoint().getTime()+ ""String_Node_Str""+ trajectory.getFirstPoint()+ ""String_Node_Str"");
  }
switch (property.getType()) {
case AND:
    return new AndMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)));
case FUTURE:
  return new FutureMonitor(property,createMonitor(trajectory,property.getSubformula(0)),((FutureFormula)property).getInterval());
case GLOBALLY:
return new GloballyMonitor(property,createMonitor(trajectory,property.getSubformula(0)),((GloballyFormula)property).getInterval());
case NOT:
return new NotMonitor(property,createMonitor(trajectory,property.getSubformula(0)));
case OR:
return new OrMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)));
case PREDICATE:
return new PredicateMonitor(property,trajectory,(Predicate)property);
case UNTIL:
return new UntilMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)),((UntilFormula)property).getInterval());
default :
throw new UnsupportedOperationException(""String_Node_Str"" + property.getType() + ""String_Node_Str"");
}
}",0.984029901461094
180304,"@Override public TrajectoryReference getReference(){
  if (reference == null) {
    final Trajectory thisTrajectory=this;
    reference=new TrajectoryReference(){
      private volatile Trajectory referencedTrajectory=thisTrajectory;
      @Override public Trajectory getTrajectory(){
        return referencedTrajectory;
      }
      @Override public void setTrajectory(      Trajectory trajectory){
        referencedTrajectory=trajectory;
      }
    }
;
  }
  return reference;
}","@Override public TrajectoryReference getReference(){
  return reference;
}",0.2652329749103942
180305,"@Override public Trajectory withoutNeighbors(){
  List<Point> points=new ArrayList<>(getLength());
  for (  Point p : this) {
    points.add(p);
  }
  return new ListTrajectory(points);
}","@Override public Trajectory withoutNeighbors(){
  List<Point> points=new ArrayList<>(getLength());
  for (  Point p : this.getReference().getTrajectory()) {
    points.add(p);
  }
  return new ListTrajectory(points);
}",0.9234567901234568
180306,"@Override public VerificationResult getObject(Node source) throws XMLFormatException {
  NodeList children=source.getChildNodes();
  int size=children.getLength();
  if (size == 0) {
    return new ArrayVerificationResult(0,new PointWithNeighborhood[0],new Robustness[0]);
  }
  Map<Point,Robustness> robustnesses=new HashMap<>();
  Map<Integer,Point> memory=new HashMap<>();
  Map<Point,Collection<Integer>> neighbors=new HashMap<>();
  int dimension=Integer.parseInt(source.getAttributes().getNamedItem(DIMENSION_NAME).getNodeValue());
  for (int i=0; i < size; i++) {
    Node pointNode=children.item(i);
    float[] dims=null;
    Collection<Integer> currentNeighbors=null;
    for (int j=0; j < pointNode.getChildNodes().getLength(); j++) {
switch (pointNode.getChildNodes().item(j).getNodeName()) {
case DATA_NAME:
        Node dataNode=pointNode.getChildNodes().item(j);
      if (dataNode.getChildNodes().getLength() != dimension) {
        throw new XMLFormatException(""String_Node_Str"");
      }
    dims=new float[dimension];
  for (int d=0; d < dataNode.getChildNodes().getLength(); d++) {
    dims[d]=FloatFactory.getObject(dataNode.getChildNodes().item(d).getFirstChild());
  }
break;
case NEIGHBORS_NAME:
currentNeighbors=new ArrayList<>();
Node neighborsNode=pointNode.getChildNodes().item(j);
for (int n=0; n < neighborsNode.getChildNodes().getLength(); n++) {
Node neighborNode=neighborsNode.getChildNodes().item(n);
currentNeighbors.add(Integer.parseInt(neighborNode.getAttributes().getNamedItem(ID_NAME).getNodeValue()));
}
break;
}
Point point=new ArrayPoint(0,dims);
if (pointNode.getAttributes().getNamedItem(ROBUSTNESS_NAME) != null) {
robustnesses.put(point,new SimpleRobustness(FloatFactory.getObject(pointNode.getAttributes().getNamedItem(ROBUSTNESS_NAME))));
}
if (currentNeighbors != null) {
neighbors.put(point,currentNeighbors);
}
}
}
PointWithNeighborhood[] points=new PointWithNeighborhood[robustnesses.size()];
Robustness[] robustnessesFinal=new Robustness[robustnesses.size()];
int index=0;
for (Entry<Point,Robustness> entry : robustnesses.entrySet()) {
PointWithNeighborhood point;
if (neighbors.containsKey(entry.getKey())) {
Collection<Point> neighborhood=new ArrayList<>();
for (Integer id : neighbors.get(entry.getKey())) {
neighborhood.add(memory.get(id));
}
point=new PointWithNeigborhoodWrapper(entry.getKey(),neighborhood);
}
 else {
point=new PointWithNeigborhoodWrapper(entry.getKey(),Collections.EMPTY_LIST);
}
points[index]=point;
robustnessesFinal[index]=entry.getValue();
index++;
}
return new ArrayVerificationResult(robustnesses.size(),points,robustnessesFinal);
}","@Override public VerificationResult getObject(Node source) throws XMLFormatException {
  NodeList children=source.getChildNodes();
  int size=children.getLength();
  if (size == 0) {
    return new ArrayVerificationResult(0,new PointWithNeighborhood[0],new Robustness[0]);
  }
  Map<Point,Robustness> robustnesses=new HashMap<>();
  Map<Integer,Point> memory=new HashMap<>();
  Map<Point,Collection<Integer>> neighbors=new HashMap<>();
  int dimension=Integer.parseInt(source.getAttributes().getNamedItem(DIMENSION_NAME).getNodeValue());
  for (int i=0; i < size; i++) {
    Node pointNode=children.item(i);
    float[] dims=null;
    Collection<Integer> currentNeighbors=null;
    for (int j=0; j < pointNode.getChildNodes().getLength(); j++) {
switch (pointNode.getChildNodes().item(j).getNodeName()) {
case DATA_NAME:
        Node dataNode=pointNode.getChildNodes().item(j);
      if (dataNode.getChildNodes().getLength() != dimension) {
        throw new XMLFormatException(""String_Node_Str"");
      }
    dims=new float[dimension];
  for (int d=0; d < dataNode.getChildNodes().getLength(); d++) {
    dims[d]=FloatFactory.getObject(dataNode.getChildNodes().item(d).getFirstChild());
  }
break;
case NEIGHBORS_NAME:
currentNeighbors=new ArrayList<>();
Node neighborsNode=pointNode.getChildNodes().item(j);
for (int n=0; n < neighborsNode.getChildNodes().getLength(); n++) {
Node neighborNode=neighborsNode.getChildNodes().item(n);
currentNeighbors.add(Integer.parseInt(neighborNode.getAttributes().getNamedItem(ID_NAME).getNodeValue()));
}
break;
}
Point point=new ArrayPoint(0,dims);
if (pointNode.getAttributes().getNamedItem(ROBUSTNESS_NAME) != null) {
robustnesses.put(point,new SimpleRobustness(FloatFactory.getObject(pointNode.getAttributes().getNamedItem(ROBUSTNESS_NAME))));
}
if (currentNeighbors != null) {
neighbors.put(point,currentNeighbors);
}
memory.put(Integer.parseInt(pointNode.getAttributes().getNamedItem(ID_NAME).getNodeValue()),point);
}
}
PointWithNeighborhood[] points=new PointWithNeighborhood[robustnesses.size()];
Robustness[] robustnessesFinal=new Robustness[robustnesses.size()];
int index=0;
for (Entry<Point,Robustness> entry : robustnesses.entrySet()) {
PointWithNeighborhood point;
if (neighbors.containsKey(entry.getKey())) {
Collection<Point> neighborhood=new ArrayList<>();
for (Integer id : neighbors.get(entry.getKey())) {
neighborhood.add(memory.get(id));
}
point=new PointWithNeigborhoodWrapper(entry.getKey(),neighborhood);
}
 else {
point=new PointWithNeigborhoodWrapper(entry.getKey(),Collections.EMPTY_LIST);
}
points[index]=point;
robustnessesFinal[index]=entry.getValue();
index++;
}
return new ArrayVerificationResult(robustnesses.size(),points,robustnessesFinal);
}",0.981252343457068
180307,"@Override public InitialSampling getObject(Node source) throws XMLFormatException {
  if (!source.getNodeName().equals(INITIAL_SAMPLING_NAME)) {
    throw new XMLFormatException(""String_Node_Str"" + INITIAL_SAMPLING_NAME + ""String_Node_Str""+ source.getNodeName()+ ""String_Node_Str"");
  }
  Map<String,Integer> varSampling=new HashMap<>();
  Map<String,Integer> paramSampling=new HashMap<>();
  Collection<Expression> toRelease=new ArrayList<>();
  NodeList children=source.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    Node child=children.item(i);
switch (child.getNodeName()) {
case VARIABLE_NAME:
{
        int s=Integer.parseInt(child.getAttributes().getNamedItem(ATTRIBUTE_SAMPLING).getTextContent());
        String name=child.getAttributes().getNamedItem(ATTRIBUTE_NAME).getTextContent();
        varSampling.put(name,s);
        break;
      }
case PARAMETER_NAME:
{
      int s=Integer.parseInt(child.getAttributes().getNamedItem(ATTRIBUTE_SAMPLING).getTextContent());
      String name=child.getAttributes().getNamedItem(ATTRIBUTE_NAME).getTextContent();
      paramSampling.put(name,s);
      toRelease.add(odeSystem.getAvailableParameters().get(name));
      break;
    }
default :
  throw new XMLFormatException(""String_Node_Str"" + child.getNodeName());
}
}
OdeSystem releasedOdeSystem=odeSystem.release(toRelease);
int[] sampling=new int[releasedOdeSystem.dimension()];
for (int dim=0; dim < releasedOdeSystem.dimension(); dim++) {
if (releasedOdeSystem.isVariable(dim)) {
Variable var=releasedOdeSystem.getVariable(dim);
sampling[dim]=varSampling.containsKey(var.getName()) ? varSampling.get(var.getName()) : 1;
}
 else {
Parameter param=releasedOdeSystem.getParameter(dim);
sampling[dim]=paramSampling.containsKey(param.getName()) ? paramSampling.get(param.getName()) : 1;
}
}
return new ArrayInitialSampling(releasedOdeSystem,sampling);
}","@Override public InitialSampling getObject(Node source) throws XMLFormatException {
  if (!source.getNodeName().equals(INITIAL_SAMPLING_NAME)) {
    throw new XMLFormatException(""String_Node_Str"" + INITIAL_SAMPLING_NAME + ""String_Node_Str""+ source.getNodeName()+ ""String_Node_Str"");
  }
  Map<String,Integer> varSampling=new HashMap<>();
  Map<String,Integer> paramSampling=new HashMap<>();
  Collection<Expression> toRelease=new ArrayList<>();
  NodeList children=source.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    Node child=children.item(i);
switch (child.getNodeName()) {
case VARIABLE_NAME:
{
        int s=Integer.parseInt(child.getAttributes().getNamedItem(ATTRIBUTE_SAMPLING).getTextContent());
        String name=child.getAttributes().getNamedItem(ATTRIBUTE_NAME).getTextContent();
        varSampling.put(name,s);
        break;
      }
case PARAMETER_NAME:
{
      int s=Integer.parseInt(child.getAttributes().getNamedItem(ATTRIBUTE_SAMPLING).getTextContent());
      String name=child.getAttributes().getNamedItem(ATTRIBUTE_NAME).getTextContent();
      paramSampling.put(name,s);
      Parameter parameter=odeSystem.getAvailableParameters().get(name);
      if (parameter.isSubstituted()) {
        toRelease.add(odeSystem.getAvailableParameters().get(name));
      }
      break;
    }
default :
  throw new XMLFormatException(""String_Node_Str"" + child.getNodeName());
}
}
OdeSystem releasedOdeSystem=odeSystem.release(toRelease);
int[] sampling=new int[releasedOdeSystem.dimension()];
for (int dim=0; dim < releasedOdeSystem.dimension(); dim++) {
if (releasedOdeSystem.isVariable(dim)) {
Variable var=releasedOdeSystem.getVariable(dim);
sampling[dim]=varSampling.containsKey(var.getName()) ? varSampling.get(var.getName()) : 1;
}
 else {
Parameter param=releasedOdeSystem.getParameter(dim);
sampling[dim]=paramSampling.containsKey(param.getName()) ? paramSampling.get(param.getName()) : 1;
}
}
return new ArrayInitialSampling(releasedOdeSystem,sampling);
}",0.9687741935483872
180308,"@Override public String toFormula(VariableRenderer renderer){
  StringBuilder builder=new StringBuilder();
  if (getLeft() instanceof BinaryOperator && ((BinaryOperator)getLeft()).getPriority() < getPriority()) {
    builder.append(""String_Node_Str"").append(getLeft().toFormula(renderer)).append(""String_Node_Str"");
  }
 else {
    builder.append(getLeft().toFormula(renderer));
  }
  builder.append(""String_Node_Str"").append(getSymbol()).append(""String_Node_Str"");
  if (getRight() instanceof BinaryOperator && ((BinaryOperator)getRight()).getPriority() < getPriority()) {
    builder.append(""String_Node_Str"").append(getRight().toFormula(renderer)).append(""String_Node_Str"");
  }
 else {
    builder.append(getRight().toFormula(renderer));
  }
  return builder.toString();
}","@Override public StringBuilder toFormula(StringBuilder builder,VariableRenderer renderer){
  if ((getLeft() instanceof BinaryOperator && ((BinaryOperator)getLeft()).getPriority() > getPriority()) || getLeft().getClass().equals(getClass()) || !(getLeft() instanceof BinaryOperator)) {
    getLeft().toFormula(builder,renderer);
  }
 else {
    builder.append(""String_Node_Str"");
    getLeft().toFormula(builder,renderer).append(""String_Node_Str"");
  }
  builder.append(""String_Node_Str"").append(getSymbol()).append(""String_Node_Str"");
  if ((getRight() instanceof BinaryOperator && ((BinaryOperator)getRight()).getPriority() > getPriority()) || getRight().getClass().equals(getClass()) || !(getRight() instanceof BinaryOperator)) {
    getRight().toFormula(builder,renderer);
  }
 else {
    builder.append(""String_Node_Str"");
    getRight().toFormula(builder,renderer).append(""String_Node_Str"");
  }
  return builder;
}",0.5404129793510325
180309,"@Override public String toFormula(VariableRenderer renderer){
  StringBuilder builder=new StringBuilder();
  if (getLeft() instanceof BinaryOperator) {
    builder.append(""String_Node_Str"").append(getLeft().toFormula(renderer)).append(""String_Node_Str"");
  }
 else {
    builder.append(getLeft().toFormula(renderer));
  }
  builder.append(""String_Node_Str"").append(getSymbol()).append(""String_Node_Str"");
  if (getRight() instanceof BinaryOperator) {
    builder.append(""String_Node_Str"").append(getRight().toFormula(renderer)).append(""String_Node_Str"");
  }
 else {
    builder.append(getRight().toFormula(renderer));
  }
  return builder.toString();
}","@Override public StringBuilder toFormula(StringBuilder builder,VariableRenderer renderer){
  if (getLeft() instanceof BinaryOperator) {
    builder.append(""String_Node_Str"");
    getLeft().toFormula(builder,renderer).append(""String_Node_Str"");
  }
 else {
    getLeft().toFormula(builder,renderer);
  }
  builder.append(""String_Node_Str"").append(getSymbol()).append(""String_Node_Str"");
  if (getRight() instanceof BinaryOperator) {
    builder.append(""String_Node_Str"");
    getRight().toFormula(builder,renderer).append(""String_Node_Str"");
  }
 else {
    getRight().toFormula(builder,renderer);
  }
  return builder;
}",0.8091123330714847
180310,String toFormula(VariableRenderer renderer);,"StringBuilder toFormula(StringBuilder builder,VariableRenderer renderer);",0.7521367521367521
180311,"@Override public String toFormula(VariableRenderer renderer){
  return ""String_Node_Str"" + expression.toFormula(renderer) + ""String_Node_Str"";
}","@Override public StringBuilder toFormula(StringBuilder builder,VariableRenderer renderer){
  builder.append(""String_Node_Str"");
  return expression.toFormula(builder,renderer).append(""String_Node_Str"");
}",0.7068965517241379
180312,"@Override public Parameter substitute(Collection<SubstitutionValue> substitutionValues){
  int indexBefore=0;
  SubstitutionValue toSubstitute=null;
  for (  SubstitutionValue v : substitutionValues) {
    if (!(v instanceof ParameterValue)) {
      if (v.getExpression() instanceof Indexable && ((Indexable)v.getExpression()).getIndex() < index) {
        indexBefore++;
      }
      continue;
    }
    ParameterValue paramValue=(ParameterValue)v;
    if (paramValue.getExpression().equals(this)) {
      toSubstitute=paramValue;
    }
    if (paramValue.getExpression().getIndex() < index) {
      indexBefore++;
    }
  }
  if (toSubstitute != null) {
    return new Parameter(name,index - indexBefore,originalIndex,toSubstitute);
  }
 else   if (indexBefore != 0) {
    if (this.substitution == null) {
      return new Parameter(name,index - indexBefore,originalIndex);
    }
 else {
      return new Parameter(name,index - indexBefore,originalIndex,substitution);
    }
  }
 else {
    return this;
  }
}","@Override public Parameter substitute(Collection<SubstitutionValue> substitutionValues){
  int indexBefore=0;
  SubstitutionValue toSubstitute=null;
  for (  SubstitutionValue v : substitutionValues) {
    if (v.getExpression() instanceof Indexable && ((Indexable)v.getExpression()).getOriginalIndex() < originalIndex) {
      indexBefore++;
    }
    if (v.getExpression().equals(this)) {
      toSubstitute=(ParameterValue)v;
    }
  }
  if (toSubstitute != null) {
    return new Parameter(name,index - indexBefore,originalIndex,toSubstitute);
  }
 else   if (indexBefore != 0) {
    if (this.substitution == null) {
      return new Parameter(name,index - indexBefore,originalIndex);
    }
 else {
      return new Parameter(name,index - indexBefore,originalIndex,substitution);
    }
  }
 else {
    return this;
  }
}",0.8196185286103542
180313,"@Override public String toFormula(VariableRenderer renderer){
  return substitution == null ? name : (substitution.getValue() >= 0 ? Float.toString(substitution.getValue()) : ""String_Node_Str"" + Float.toString(substitution.getValue()) + ""String_Node_Str"");
}","@Override public StringBuilder toFormula(StringBuilder builder,VariableRenderer renderer){
  return toFormula(builder);
}",0.4379947229551451
180314,"@Override public SpawnedDataBlock spawn(OrthogonalSpace space,InitialSampling initialSampling){
  float[] sampleDistances=new float[initialSampling.getDimension()];
  for (int dim=0; dim < sampleDistances.length; dim++) {
    if (initialSampling.getNumberOfSamples(dim) >= 1) {
      sampleDistances[dim]=Math.abs(space.getMinBounds().getValue(dim) - space.getMaxBounds().getValue(dim)) / (initialSampling.getNumberOfSamples(dim) - 1);
    }
 else {
      sampleDistances[dim]=-1;
    }
  }
  List<Point> primarySeeds=new ArrayList<>();
  primarySeeds.add(space.getMinBounds());
  for (int dim=0; dim < sampleDistances.length; dim++) {
    if (sampleDistances[dim] == -1) {
      continue;
    }
    int numOfOldSeeds=primarySeeds.size();
    for (int seed=0; seed < numOfOldSeeds; seed++) {
      for (int sample=1; sample < initialSampling.getNumberOfSamples(dim); sample++) {
        float[] newPoint=primarySeeds.get(seed).toArrayCopy();
        newPoint[dim]+=sample * sampleDistances[dim];
        Point newSeed=new ArrayPoint(primarySeeds.get(seed).getTime(),newPoint);
        primarySeeds.add(newSeed);
      }
    }
  }
  final List<TrajectoryWithNeighborhood> primaryTrajectories=new ArrayList<>(primarySeeds.size());
  Map<Point,Trajectory> cache=new HashMap<>();
  for (  Point p : primarySeeds) {
    List<Trajectory> neighborhood=new ArrayList<>();
    for (int dim=0; dim < sampleDistances.length; dim++) {
      if (sampleDistances[dim] == -1) {
        continue;
      }
      float[] positiveNeighborArray=p.toArrayCopy();
      float[] negativeNeighborArray=p.toArrayCopy();
      positiveNeighborArray[dim]+=sampleDistances[dim] / 2;
      negativeNeighborArray[dim]-=sampleDistances[dim] / 2;
      Point positiveNeighbor=new ArrayPoint(p.getTime(),positiveNeighborArray);
      Point negativeNeighbor=new ArrayPoint(p.getTime(),negativeNeighborArray);
      if (!cache.containsKey(positiveNeighbor)) {
        cache.put(positiveNeighbor,new PointTrajectory(positiveNeighbor));
      }
      if (!cache.containsKey(negativeNeighbor)) {
        cache.put(negativeNeighbor,new PointTrajectory(negativeNeighbor));
      }
      neighborhood.add(cache.get(positiveNeighbor));
      neighborhood.add(cache.get(negativeNeighbor));
    }
    primaryTrajectories.add(new PointTrajectory(new ListDataBlock<>(neighborhood),p));
  }
  List<Trajectory> secondaryTrajectories=new ArrayList<>(cache.values());
  return new SpawnedDataBlockWrapper(new ListDataBlock<>(primaryTrajectories),new AbstractConfiguration(initialSampling,space){
    @Override public int getStartIndex(    int index,    int neighborIndex){
      return 0;
    }
  }
,new ListDataBlock<>(secondaryTrajectories));
}","@Override public SpawnedDataBlock spawn(OrthogonalSpace space,InitialSampling initialSampling){
  float[] sampleDistances=new float[initialSampling.getDimension()];
  for (int dim=0; dim < sampleDistances.length; dim++) {
    if (initialSampling.getNumberOfSamples(dim) > 1) {
      sampleDistances[dim]=Math.abs(space.getMinBounds().getValue(dim) - space.getMaxBounds().getValue(dim)) / (initialSampling.getNumberOfSamples(dim) - 1);
    }
 else {
      sampleDistances[dim]=-1;
    }
  }
  List<Point> primarySeeds=new ArrayList<>();
  primarySeeds.add(space.getMinBounds());
  for (int dim=0; dim < sampleDistances.length; dim++) {
    if (sampleDistances[dim] == -1) {
      continue;
    }
    int numOfOldSeeds=primarySeeds.size();
    for (int seed=0; seed < numOfOldSeeds; seed++) {
      for (int sample=1; sample < initialSampling.getNumberOfSamples(dim); sample++) {
        float[] newPoint=primarySeeds.get(seed).toArrayCopy();
        newPoint[dim]+=sample * sampleDistances[dim];
        Point newSeed=new ArrayPoint(primarySeeds.get(seed).getTime(),newPoint);
        primarySeeds.add(newSeed);
      }
    }
  }
  final List<TrajectoryWithNeighborhood> primaryTrajectories=new ArrayList<>(primarySeeds.size());
  Map<Point,Trajectory> cache=new HashMap<>();
  for (  Point p : primarySeeds) {
    List<Trajectory> neighborhood=new ArrayList<>();
    for (int dim=0; dim < sampleDistances.length; dim++) {
      if (sampleDistances[dim] == -1) {
        continue;
      }
      float[] positiveNeighborArray=p.toArrayCopy();
      float[] negativeNeighborArray=p.toArrayCopy();
      positiveNeighborArray[dim]+=sampleDistances[dim] / 2;
      negativeNeighborArray[dim]-=sampleDistances[dim] / 2;
      Point positiveNeighbor=new ArrayPoint(p.getTime(),positiveNeighborArray);
      Point negativeNeighbor=new ArrayPoint(p.getTime(),negativeNeighborArray);
      if (!cache.containsKey(positiveNeighbor)) {
        cache.put(positiveNeighbor,new PointTrajectory(positiveNeighbor));
      }
      if (!cache.containsKey(negativeNeighbor)) {
        cache.put(negativeNeighbor,new PointTrajectory(negativeNeighbor));
      }
      neighborhood.add(cache.get(positiveNeighbor));
      neighborhood.add(cache.get(negativeNeighbor));
    }
    primaryTrajectories.add(new PointTrajectory(new ListDataBlock<>(neighborhood),p));
  }
  List<Trajectory> secondaryTrajectories=new ArrayList<>(cache.values());
  return new SpawnedDataBlockWrapper(new ListDataBlock<>(primaryTrajectories),new AbstractConfiguration(initialSampling,space){
    @Override public int getStartIndex(    int index,    int neighborIndex){
      return 0;
    }
  }
,new ListDataBlock<>(secondaryTrajectories));
}",0.9998145056575776
180315,"@Override public <T extends Trajectory>SimulatedDataBlock<T> simulate(AdaptiveStepConfiguration configuration,DataBlock<T> data){
  SimulationEngine simulationEngine=simulationEngineFactory.simulationEngine(configuration.getMaxNumberOfIterations(),configuration.getPrecisionConfiguration().getMaxRelativeError());
  try {
    List<T> trajectories=new ArrayList<>(data.size());
    Status[] statuses=new Status[data.size()];
    for (int i=0; i < data.size(); i++) {
      Trajectory simulated=simulationEngine.simulate(data.getTrajectory(i).getLastPoint(),configuration.getOdeSystem(),configuration.getPrecisionConfiguration().getTimeStep(),configuration.getSpace().getMaxBounds().getTime());
      LinkedTrajectory trajectory=data.getTrajectory(i) instanceof LinkedTrajectory ? (LinkedTrajectory)data.getTrajectory(i) : (data.getTrajectory(i) instanceof TrajectoryWithNeighborhood ? LinkedTrajectory.createAndUpdateReferenceWithNeighborhood((TrajectoryWithNeighborhood)data.getTrajectory(i)) : LinkedTrajectory.createAndUpdateReference(data.getTrajectory(i)));
      trajectory.append(simulated);
      trajectories.add((T)trajectory);
      if (simulated.getLastPoint().getTime() < configuration.getSpace().getMaxBounds().getTime()) {
        statuses[i]=Status.TIMEOUT;
      }
 else {
        statuses[i]=Status.OK;
      }
    }
    return new ArraySimulatedDataBlock<>(new ListDataBlock<>(trajectories),statuses);
  }
  finally {
    simulationEngine.close();
  }
}","@Override public <T extends Trajectory>SimulatedDataBlock<T> simulate(AdaptiveStepConfiguration configuration,DataBlock<T> data){
  SimulationEngine simulationEngine=simulationEngineFactory.simulationEngine(configuration.getMaxNumberOfIterations(),configuration.getPrecisionConfiguration().getMaxRelativeError());
  try {
    List<T> trajectories=new ArrayList<>(data.size());
    Status[] statuses=new Status[data.size()];
    for (int i=0; i < data.size(); i++) {
      Trajectory simulated=simulationEngine.simulate(data.getTrajectory(i).getLastPoint(),configuration.getOdeSystem(),configuration.getSpace().getMaxBounds().getTime(),configuration.getPrecisionConfiguration());
      LinkedTrajectory trajectory=data.getTrajectory(i) instanceof LinkedTrajectory ? (LinkedTrajectory)data.getTrajectory(i) : (data.getTrajectory(i) instanceof TrajectoryWithNeighborhood ? LinkedTrajectory.createAndUpdateReferenceWithNeighborhood((TrajectoryWithNeighborhood)data.getTrajectory(i)) : LinkedTrajectory.createAndUpdateReference(data.getTrajectory(i)));
      trajectory.append(simulated);
      trajectories.add((T)trajectory);
      if (simulated.getLastPoint().getTime() < configuration.getSpace().getMaxBounds().getTime()) {
        statuses[i]=Status.TIMEOUT;
      }
 else {
        statuses[i]=Status.OK;
      }
    }
    return new ArraySimulatedDataBlock<>(new ListDataBlock<>(trajectories),statuses);
  }
  finally {
    simulationEngine.close();
  }
}",0.9665300546448088
180316,"Trajectory simulate(Point point,OdeSystem odeSystem,double timeStep,double timeLimit);","Trajectory simulate(Point point,OdeSystem odeSystem,double timeLimit,PrecisionConfiguration configuration);",0.7253886010362695
180317,"@Override protected OctaveDouble rawSimulation(Point point,OctaveOdeSystem odeSystem,long numberOfIterations,double timeStep){
  getOctave().eval(odeSystem.octaveString(false));
  getOctave().eval(""String_Node_Str"" + Arrays.toString(point.toArray(odeSystem.getVariables().size())) + ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + point.getTime() + ""String_Node_Str""+ numberOfIterations * timeStep + ""String_Node_Str"" + numberOfIterations + ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + odeSystem.octaveName() + ""String_Node_Str"");
  return getOctave().get(OctaveDouble.class,""String_Node_Str"");
}","@Override protected OctaveDouble rawSimulation(Point point,OctaveOdeSystem odeSystem,long numberOfIterations,PrecisionConfiguration precision){
  if (absoluteToleranceIsSet(precision)) {
    float[] tolerance=new float[precision.getDimension()];
    for (int i=0; i < tolerance.length; i++) {
      tolerance[i]=precision.getMaxAbsoluteError(i);
    }
    getOctave().eval(""String_Node_Str"" + Arrays.toString(tolerance) + ""String_Node_Str"");
  }
  getOctave().eval(odeSystem.octaveString(false));
  getOctave().eval(""String_Node_Str"" + Arrays.toString(point.toArray(odeSystem.getVariables().size())) + ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + point.getTime() + ""String_Node_Str""+ numberOfIterations * precision.getTimeStep() + ""String_Node_Str"" + numberOfIterations + ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + odeSystem.octaveName() + ""String_Node_Str"");
  return getOctave().get(OctaveDouble.class,""String_Node_Str"");
}",0.149746192893401
180318,"protected abstract OctaveDouble rawSimulation(Point point,OctaveOdeSystem odeSystem,long numberOfIterations,double timeStep);","protected abstract OctaveDouble rawSimulation(Point point,OctaveOdeSystem odeSystem,long numberOfIterations,PrecisionConfiguration precision);",0.8614232209737828
180319,"@Override public Trajectory simulate(Point point,OdeSystem odeSystem,double timeStep,double timeLimit){
  List<ParameterValue> paramValues=loadParameterValues(point,odeSystem);
  OctaveOdeSystem octaveOdeSystem=paramValues.isEmpty() ? new OctaveOdeSystem(odeSystem) : new OctaveOdeSystem(odeSystem.substitute(paramValues));
  long numOfIterations=Math.min(Math.round((timeLimit - point.getTime()) / timeStep),getStepLimit());
  double[] loadedData=rawSimulation(point,octaveOdeSystem,numOfIterations,timeStep).getData();
  float[] data=new float[loadedData.length];
  for (int dim=0; dim < octaveOdeSystem.dimension(); dim++) {
    for (int i=0; i < loadedData.length / octaveOdeSystem.dimension(); i++) {
      data[dim + i * octaveOdeSystem.dimension()]=(float)loadedData[dim * (loadedData.length / octaveOdeSystem.dimension()) + i];
    }
  }
  float[] times=new float[loadedData.length / octaveOdeSystem.dimension()];
  float time=point.getTime();
  for (int i=0; i < times.length; i++) {
    time+=timeStep;
    times[i]=time;
  }
  if (paramValues.isEmpty()) {
    return new ArrayTrajectory(data,times,point.getDimension());
  }
 else {
    return new ArrayTrajectory(point,data,times,octaveOdeSystem.dimension());
  }
}","@Override public Trajectory simulate(Point point,OdeSystem odeSystem,double timeLimit,PrecisionConfiguration precision){
  List<ParameterValue> paramValues=loadParameterValues(point,odeSystem);
  OctaveOdeSystem octaveOdeSystem=paramValues.isEmpty() ? new OctaveOdeSystem(odeSystem) : new OctaveOdeSystem(odeSystem.substitute(paramValues));
  long numOfIterations=Math.min(Math.round((timeLimit - point.getTime()) / precision.getTimeStep()),getStepLimit());
  double[] loadedData=rawSimulation(point,octaveOdeSystem,numOfIterations,precision).getData();
  float[] data=new float[loadedData.length];
  for (int dim=0; dim < octaveOdeSystem.dimension(); dim++) {
    for (int i=0; i < loadedData.length / octaveOdeSystem.dimension(); i++) {
      data[dim + i * octaveOdeSystem.dimension()]=(float)loadedData[dim * (loadedData.length / octaveOdeSystem.dimension()) + i];
    }
  }
  float[] times=new float[loadedData.length / octaveOdeSystem.dimension()];
  float time=point.getTime();
  for (int i=0; i < times.length; i++) {
    time+=precision.getTimeStep();
    times[i]=time;
  }
  if (paramValues.isEmpty()) {
    return new ArrayTrajectory(data,times,point.getDimension());
  }
 else {
    return new ArrayTrajectory(point,data,times,octaveOdeSystem.dimension());
  }
}",0.9456434852118304
180320,"@Override protected OctaveDouble rawSimulation(Point point,OctaveOdeSystem odeSystem,long numberOfIterations,double timeStep){
  getOctave().eval(odeSystem.octaveString(true));
  getOctave().eval(""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + getRelativeTolerance() + ""String_Node_Str""+ Long.MAX_VALUE+ ""String_Node_Str""+ timeStep+ ""String_Node_Str""+ timeStep+ ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + function + ""String_Node_Str""+ point.getTime()+ ""String_Node_Str""+ (numberOfIterations * timeStep)+ ""String_Node_Str""+ Arrays.toString(point.toArray(odeSystem.getVariables().size()))+ ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"");
  return getOctave().get(OctaveDouble.class,""String_Node_Str"");
}","@Override protected OctaveDouble rawSimulation(Point point,OctaveOdeSystem odeSystem,long numberOfIterations,PrecisionConfiguration precision){
  getOctave().eval(odeSystem.octaveString(true));
  getOctave().eval(""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + getRelativeTolerance() + ""String_Node_Str""+ Long.MAX_VALUE+ ""String_Node_Str""+ precision.getTimeStep()+ ""String_Node_Str""+ precision.getTimeStep()+ ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + function + ""String_Node_Str""+ point.getTime()+ ""String_Node_Str""+ (numberOfIterations * precision.getTimeStep())+ ""String_Node_Str""+ Arrays.toString(point.toArray(odeSystem.getVariables().size()))+ ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"");
  return getOctave().get(OctaveDouble.class,""String_Node_Str"");
}",0.8831168831168831
180321,"@Override public Parameter release(Collection<Expression> expressions){
  int indexBefore=0;
  boolean release=false;
  for (  Expression e : expressions) {
    if (!(e instanceof Parameter)) {
      if (e instanceof Indexable && ((Indexable)e).getIndex() < originalIndex) {
        indexBefore++;
      }
    }
    if (e.equals(this)) {
      release=true;
    }
  }
  if (release && isSubstituted()) {
    return new Parameter(name,index + indexBefore,originalIndex);
  }
 else   if (indexBefore != 0) {
    if (substitution == null) {
      return new Parameter(name,index + indexBefore,originalIndex);
    }
 else {
      return new Parameter(name,index + indexBefore,originalIndex,substitution);
    }
  }
 else {
    return this;
  }
}","@Override public Parameter release(Collection<Expression> expressions){
  int indexBefore=0;
  boolean release=false;
  for (  Expression e : expressions) {
    if (e instanceof Indexable && ((Indexable)e).getOriginalIndex() < originalIndex) {
      indexBefore++;
    }
    if (e.equals(this)) {
      release=true;
    }
  }
  if (release && isSubstituted()) {
    return new Parameter(name,index + indexBefore,originalIndex);
  }
 else   if (indexBefore != 0) {
    if (substitution == null) {
      return new Parameter(name,index + indexBefore,originalIndex);
    }
 else {
      return new Parameter(name,index + indexBefore,originalIndex,substitution);
    }
  }
 else {
    return this;
  }
}",0.9604441360166552
180322,"@Override public Variable release(Collection<Expression> expressions){
  int indexBefore=0;
  boolean release=false;
  for (  Expression e : expressions) {
    if (!(e instanceof Variable)) {
      if (e instanceof Indexable && ((Indexable)e).getIndex() < originalIndex) {
        indexBefore++;
      }
    }
    if (e.equals(this)) {
      release=true;
    }
  }
  if ((release && isSubstituted()) || indexBefore != 0) {
    return new Variable(name,index + indexBefore,originalIndex);
  }
 else {
    return this;
  }
}","@Override public Variable release(Collection<Expression> expressions){
  int indexBefore=0;
  boolean release=false;
  for (  Expression e : expressions) {
    if (e instanceof Indexable && ((Indexable)e).getOriginalIndex() < originalIndex) {
      indexBefore++;
    }
    if (e.equals(this)) {
      release=true;
    }
  }
  if ((release && isSubstituted()) || indexBefore != 0) {
    return new Variable(name,index + indexBefore,originalIndex);
  }
 else {
    return this;
  }
}",0.9443339960238568
180323,"@Override public Integer getKey(String variableName){
  return odeSystem.getVariables().get(variableName).getIndex();
}","@Override public Integer getKey(String variableName){
  if (!odeSystem.getVariables().containsKey(variableName)) {
    throw new IllegalArgumentException(""String_Node_Str"" + variableName + ""String_Node_Str"");
  }
  return odeSystem.getVariables().get(variableName).getIndex();
}",0.5843828715365239
180324,"private static OdeSystem setup(Model model){
  Map<String,Variable> variablesMemory=new HashMap<>();
  Map<String,Parameter> parametersMemory=new HashMap<>();
  List<SubstitutionValue> substitutionValues=new ArrayList<>();
  Map<Variable,List<Expression>> positives=new HashMap<>();
  Map<Variable,List<Expression>> negatives=new HashMap<>();
  List<Variable> variables=new ArrayList<>();
  List<VariableValue> variableValues=new ArrayList<>();
  List<ParameterValue> parameterValues=new ArrayList<>();
  for (  Species species : model.getListOfSpecies()) {
    if (species.getId() == null || species.getId().isEmpty()) {
      LOGGER.warn(""String_Node_Str"");
      continue;
    }
    Variable var=new Variable(species.getName() == null || species.getName().isEmpty() ? species.getId() : species.getName(),variables.size());
    variablesMemory.put(species.getId(),var);
    variables.add(var);
    variableValues.add(new VariableValue(var,(float)species.getInitialConcentration()));
  }
  for (  org.sbml.jsbml.Parameter p : model.getListOfParameters()) {
    if (p.getId() == null || p.getId().isEmpty()) {
      LOGGER.warn(""String_Node_Str"");
      continue;
    }
    if (new Double(p.getValue()).equals(Double.NaN)) {
      throw new IllegalStateException(""String_Node_Str"" + p.getId() + ""String_Node_Str"");
    }
    Parameter param=new Parameter(p.getName() == null || p.getName().isEmpty() ? p.getId() : p.getName(),variables.size() + parametersMemory.size());
    parametersMemory.put(p.getId(),param);
    ParameterValue pv=new ParameterValue(param,(float)p.getValue());
    substitutionValues.add(pv);
    parameterValues.add(pv);
  }
  for (  Reaction reaction : model.getListOfReactions()) {
    String reactionName=reaction.getName() == null || reaction.getName().isEmpty() ? reaction.getId() : reaction.getName();
    Map<String,Parameter> localParameters=new HashMap<>();
    for (    org.sbml.jsbml.LocalParameter p : reaction.getKineticLaw().getListOfLocalParameters()) {
      if (p.getId() == null || p.getId().isEmpty()) {
        LOGGER.warn(""String_Node_Str"");
      }
      String paramLocalName=p.getName() == null || p.getName().isEmpty() ? p.getId() : p.getName();
      String paramGloabalName=reactionName + ""String_Node_Str"" + paramLocalName;
      if (new Double(p.getValue()).equals(Double.NaN)) {
        throw new IllegalStateException(""String_Node_Str"" + paramLocalName + ""String_Node_Str""+ reactionName+ ""String_Node_Str"");
      }
      if (parametersMemory.containsKey(paramGloabalName)) {
        throw new IllegalStateException(""String_Node_Str"" + paramLocalName + ""String_Node_Str""+ reactionName+ ""String_Node_Str""+ paramGloabalName+ ""String_Node_Str"");
      }
      Parameter parameter=new Parameter(paramGloabalName,variables.size() + parametersMemory.size());
      ParameterValue pv=new ParameterValue(parameter,(float)p.getValue());
      parameterValues.add(pv);
      substitutionValues.add(pv);
      localParameters.put(paramLocalName,parameter);
      parametersMemory.put(paramGloabalName,parameter);
    }
    Expression kineticLaw=createExpression(reaction.getKineticLaw().getMath(),variablesMemory,parametersMemory,localParameters);
    if (kineticLaw == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    for (    SpeciesReference speciesReference : reaction.getListOfReactants()) {
      if (speciesReference.getSpecies() == null || speciesReference.getSpecies().isEmpty()) {
        LOGGER.warn(""String_Node_Str"");
        continue;
      }
      Variable variable=variablesMemory.get(speciesReference.getSpecies());
      if (!negatives.containsKey(variable)) {
        negatives.put(variable,new ArrayList<Expression>());
      }
      negatives.get(variable).add(kineticLaw);
    }
    for (    SpeciesReference speciesReference : reaction.getListOfProducts()) {
      if (speciesReference.getSpecies() == null || speciesReference.getSpecies().isEmpty()) {
        LOGGER.warn(""String_Node_Str"");
        continue;
      }
      Variable variable=variablesMemory.get(speciesReference.getSpecies());
      if (!positives.containsKey(variable)) {
        positives.put(variable,new ArrayList<Expression>());
      }
      positives.get(variable).add(kineticLaw);
    }
    if (reaction.isReversible()) {
      LOGGER.warn(""String_Node_Str"");
    }
  }
  List<OdeSystemVariable> result=new ArrayList<>();
  for (  Variable variable : variables) {
    List<Expression> pos=positives.get(variable);
    List<Expression> neg=negatives.get(variable);
    Expression rs=null;
    if (pos != null) {
      for (      Expression e : pos) {
        if (rs == null) {
          rs=e;
        }
 else {
          rs=new Plus(rs,e);
        }
      }
    }
    if (neg != null) {
      for (      Expression e : neg) {
        if (rs == null) {
          rs=new Negation(e);
        }
 else {
          rs=new Minus(rs,e);
        }
      }
    }
    if (rs == null) {
      rs=new Constant(0);
    }
    result.add(new OdeSystemVariable(variable,rs.substitute(substitutionValues)));
  }
  return new SimpleOdeSystem(result,variableValues,parameterValues);
}","private static OdeSystem setup(Model model){
  Map<String,Variable> variablesMemory=new HashMap<>();
  Map<String,Parameter> parametersMemory=new HashMap<>();
  List<SubstitutionValue> substitutionValues=new ArrayList<>();
  Map<Variable,List<Expression>> positives=new HashMap<>();
  Map<Variable,List<Expression>> negatives=new HashMap<>();
  List<Variable> variables=new ArrayList<>();
  List<VariableValue> variableValues=new ArrayList<>();
  List<ParameterValue> parameterValues=new ArrayList<>();
  for (  Species species : model.getListOfSpecies()) {
    if (species.getId() == null || species.getId().isEmpty()) {
      LOGGER.warn(""String_Node_Str"");
      continue;
    }
    Variable var=new Variable(species.getName() == null || species.getName().isEmpty() ? species.getId() : species.getName(),variables.size());
    variablesMemory.put(species.getId(),var);
    variables.add(var);
    variableValues.add(new VariableValue(var,(float)species.getInitialConcentration()));
  }
  for (  org.sbml.jsbml.Parameter p : model.getListOfParameters()) {
    if (p.getId() == null || p.getId().isEmpty()) {
      LOGGER.warn(""String_Node_Str"");
      continue;
    }
    if (new Double(p.getValue()).equals(Double.NaN)) {
      throw new IllegalStateException(""String_Node_Str"" + p.getId() + ""String_Node_Str"");
    }
    Parameter param=new Parameter(p.getName() == null || p.getName().isEmpty() ? p.getId() : p.getName(),variables.size() + parametersMemory.size());
    parametersMemory.put(p.getId(),param);
    ParameterValue pv=new ParameterValue(param,(float)p.getValue());
    substitutionValues.add(pv);
    parameterValues.add(pv);
  }
  for (  Reaction reaction : model.getListOfReactions()) {
    String reactionName=reaction.getName() == null || reaction.getName().isEmpty() ? reaction.getId() : reaction.getName();
    Map<String,Parameter> localParameters=new HashMap<>();
    LOGGER.debug(""String_Node_Str"" + reaction.getId());
    for (    org.sbml.jsbml.LocalParameter p : reaction.getKineticLaw().getListOfLocalParameters()) {
      if (p.getId() == null || p.getId().isEmpty()) {
        LOGGER.warn(""String_Node_Str"" + reaction.getId() + ""String_Node_Str"");
      }
      String paramLocalName=p.getName() == null || p.getName().isEmpty() ? p.getId() : p.getName();
      String paramGloabalName=reactionName + ""String_Node_Str"" + paramLocalName;
      if (new Double(p.getValue()).equals(Double.NaN)) {
        throw new IllegalStateException(""String_Node_Str"" + paramLocalName + ""String_Node_Str""+ reactionName+ ""String_Node_Str"");
      }
      if (parametersMemory.containsKey(paramGloabalName)) {
        throw new IllegalStateException(""String_Node_Str"" + paramLocalName + ""String_Node_Str""+ reactionName+ ""String_Node_Str""+ paramGloabalName+ ""String_Node_Str"");
      }
      Parameter parameter=new Parameter(paramGloabalName,variables.size() + parametersMemory.size());
      ParameterValue pv=new ParameterValue(parameter,(float)p.getValue());
      parameterValues.add(pv);
      substitutionValues.add(pv);
      localParameters.put(paramLocalName,parameter);
      parametersMemory.put(paramGloabalName,parameter);
    }
    Expression kineticLaw=createExpression(reaction.getKineticLaw().getMath(),variablesMemory,parametersMemory,localParameters);
    if (kineticLaw == null) {
      throw new IllegalStateException(""String_Node_Str"" + reaction.getId() + ""String_Node_Str"");
    }
    for (    SpeciesReference speciesReference : reaction.getListOfReactants()) {
      if (speciesReference.getSpecies() == null || speciesReference.getSpecies().isEmpty()) {
        LOGGER.warn(""String_Node_Str"" + reaction.getId() + ""String_Node_Str"");
        continue;
      }
      Variable variable=variablesMemory.get(speciesReference.getSpecies());
      if (!negatives.containsKey(variable)) {
        negatives.put(variable,new ArrayList<Expression>());
      }
      negatives.get(variable).add(kineticLaw);
    }
    for (    SpeciesReference speciesReference : reaction.getListOfProducts()) {
      if (speciesReference.getSpecies() == null || speciesReference.getSpecies().isEmpty()) {
        LOGGER.warn(""String_Node_Str"");
        continue;
      }
      Variable variable=variablesMemory.get(speciesReference.getSpecies());
      if (!positives.containsKey(variable)) {
        positives.put(variable,new ArrayList<Expression>());
      }
      positives.get(variable).add(kineticLaw);
    }
    if (reaction.isReversible()) {
      LOGGER.warn(""String_Node_Str"");
    }
  }
  List<OdeSystemVariable> result=new ArrayList<>();
  for (  Variable variable : variables) {
    List<Expression> pos=positives.get(variable);
    List<Expression> neg=negatives.get(variable);
    Expression rs=null;
    if (pos != null) {
      for (      Expression e : pos) {
        if (rs == null) {
          rs=e;
        }
 else {
          rs=new Plus(rs,e);
        }
      }
    }
    if (neg != null) {
      for (      Expression e : neg) {
        if (rs == null) {
          rs=new Negation(e);
        }
 else {
          rs=new Minus(rs,e);
        }
      }
    }
    if (rs == null) {
      rs=new Constant(0);
    }
    result.add(new OdeSystemVariable(variable,rs.substitute(substitutionValues)));
  }
  return new SimpleOdeSystem(result,variableValues,parameterValues);
}",0.5971836382795287
180325,"private List<Robustness> precomputeRobustness(Monitor subMonitor,FormulaInterval interval){
  Deque<Robustness> lemireDeque=new LemireDeque<>(createComparator());
  List<Robustness> precomputed=new ArrayList<>();
  Iterator<Robustness> window=subMonitor.iterator();
  Iterator<Robustness> current=subMonitor.iterator();
  int currentIndex=0;
  float currentTime=current.next().getTime();
  while (window.hasNext()) {
    Robustness memory=null;
    boolean windowEndReached=false;
    while (window.hasNext() && !windowEndReached) {
      memory=window.next();
      if (memory.getTime() < currentTime + interval.getUpperBound()) {
        lemireDeque.offer(memory);
        memory=null;
      }
 else       if (memory.getTime() == currentTime + interval.getUpperBound()) {
        lemireDeque.offer(memory);
        memory=null;
        windowEndReached=true;
      }
 else {
        windowEndReached=true;
      }
    }
    if (!windowEndReached) {
      return precomputed;
    }
    while (!lemireDeque.isEmpty() && lemireDeque.peekFirst().getTime() < currentTime + interval.getLowerBound()) {
      lemireDeque.remove();
    }
    precomputed.add(lemireDeque.removeFirst());
    currentIndex++;
    currentTime=current.next().getTime();
    if (memory != null) {
      lemireDeque.offer(memory);
      memory=null;
    }
  }
  return precomputed;
}","private List<Robustness> precomputeRobustness(Monitor subMonitor,FormulaInterval interval){
  Deque<Robustness> lemireDeque=new LemireDeque<>(createComparator());
  List<Robustness> precomputed=new ArrayList<>();
  Iterator<Robustness> window=subMonitor.iterator();
  Iterator<Robustness> current=subMonitor.iterator();
  int currentIndex=0;
  float currentTime=current.next().getTime();
  while (window.hasNext()) {
    Robustness memory=null;
    boolean windowEndReached=false;
    while (window.hasNext() && !windowEndReached) {
      memory=window.next();
      if (memory.getTime() < currentTime + interval.getUpperBound()) {
        lemireDeque.offer(memory);
        memory=null;
      }
 else       if (memory.getTime() == currentTime + interval.getUpperBound()) {
        lemireDeque.offer(memory);
        memory=null;
        windowEndReached=true;
      }
 else {
        windowEndReached=true;
      }
    }
    if (!windowEndReached) {
      return precomputed;
    }
    while (!lemireDeque.isEmpty() && lemireDeque.peekFirst().getTime() < currentTime + interval.getLowerBound()) {
      lemireDeque.remove();
    }
    Robustness found=lemireDeque.peekFirst();
    precomputed.add(new SimpleRobustness(found.getValue(),currentTime,consideredDimensions));
    currentIndex++;
    currentTime=current.next().getTime();
    if (memory != null) {
      lemireDeque.offer(memory);
      memory=null;
    }
  }
  return precomputed;
}",0.9513938527519656
180326,"public AbstractUnaryTemporalMonitor(Property property,Monitor subMonitor,FormulaInterval interval){
  super(property);
  Validate.notNull(interval);
  Validate.notNull(subMonitor);
  this.suMonitor=subMonitor;
  this.robustnesses=precomputeRobustness(subMonitor,interval);
}","public AbstractUnaryTemporalMonitor(Property property,Monitor subMonitor,FormulaInterval interval,Collection<Integer> consideredDimensions){
  super(property);
  Validate.notNull(interval);
  Validate.notNull(subMonitor);
  Validate.notNull(consideredDimensions);
  this.suMonitor=subMonitor;
  this.robustnesses=precomputeRobustness(subMonitor,interval);
  this.consideredDimensions=consideredDimensions;
}",0.8046989720998532
180327,"public FutureMonitor(Property property,Monitor subMonitor,FormulaInterval interval){
  super(property,subMonitor,interval);
}","public FutureMonitor(Property property,Monitor subMonitor,FormulaInterval interval,Collection<Integer> consideredDimensions){
  super(property,subMonitor,interval,consideredDimensions);
}",0.8012820512820513
180328,"public GloballyMonitor(Property property,Monitor subMonitor,FormulaInterval interval){
  super(property,subMonitor,interval);
}","public GloballyMonitor(Property property,Monitor subMonitor,FormulaInterval interval,Collection<Integer> consideredDimensions){
  super(property,subMonitor,interval,consideredDimensions);
}",0.8037974683544303
180329,"@Override public Monitor createMonitor(Trajectory trajectory,Formula property){
  if (trajectory.getLastPoint().getTime() < property.getTimeNeeded()) {
    throw new IllegalArgumentException(""String_Node_Str"" + property.getTimeNeeded() + ""String_Node_Str""+ trajectory.getLastPoint().getTime()+ ""String_Node_Str"");
  }
  Collection<Integer> consideredDimensions=null;
  if (filterDimensions) {
    consideredDimensions=property.getVariableIndexes();
  }
switch (property.getType()) {
case AND:
    return new AndMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)),consideredDimensions);
case FUTURE:
  return new FutureMonitor(property,createMonitor(trajectory,property.getSubformula(0)),((FutureFormula)property).getInterval());
case GLOBALLY:
return new GloballyMonitor(property,createMonitor(trajectory,property.getSubformula(0)),((GloballyFormula)property).getInterval());
case NOT:
return new NotMonitor(property,createMonitor(trajectory,property.getSubformula(0)));
case OR:
return new OrMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)),consideredDimensions);
case PREDICATE:
return new PredicateMonitor(property,trajectory,(Predicate)property,consideredDimensions);
case UNTIL:
return new UntilMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)),((UntilFormula)property).getInterval(),consideredDimensions);
default :
throw new UnsupportedOperationException(""String_Node_Str"" + property.getType() + ""String_Node_Str"");
}
}","@Override public Monitor createMonitor(Trajectory trajectory,Formula property){
  if (trajectory.getLastPoint().getTime() < property.getTimeNeeded()) {
    throw new IllegalArgumentException(""String_Node_Str"" + property.getTimeNeeded() + ""String_Node_Str""+ trajectory.getLastPoint().getTime()+ ""String_Node_Str"");
  }
  Collection<Integer> consideredDimensions=null;
  if (filterDimensions) {
    consideredDimensions=property.getVariableIndexes();
  }
switch (property.getType()) {
case AND:
    return new AndMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)),consideredDimensions);
case FUTURE:
  return new FutureMonitor(property,createMonitor(trajectory,property.getSubformula(0)),((FutureFormula)property).getInterval(),consideredDimensions);
case GLOBALLY:
return new GloballyMonitor(property,createMonitor(trajectory,property.getSubformula(0)),((GloballyFormula)property).getInterval(),consideredDimensions);
case NOT:
return new NotMonitor(property,createMonitor(trajectory,property.getSubformula(0)));
case OR:
return new OrMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)),consideredDimensions);
case PREDICATE:
return new PredicateMonitor(property,trajectory,(Predicate)property,consideredDimensions);
case UNTIL:
return new UntilMonitor(property,createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)),((UntilFormula)property).getInterval(),consideredDimensions);
default :
throw new UnsupportedOperationException(""String_Node_Str"" + property.getType() + ""String_Node_Str"");
}
}",0.9873417721518988
180330,"@Test public void testFutureMonitorIncreasing(){
  Monitor subMonitor=createIncreasingTestMonitor(10,1);
  Monitor future=new FutureMonitor(EMPTY_PROPERTY,subMonitor,new TimeInterval(2,4,IntervalBoundaryType.CLOSED));
  Monitor expected=createTestMonitor(4,5,6,7,8,9);
  assertEquals(future.size(),expected.size(),""String_Node_Str"");
  for (int i=0; i < expected.size(); i++) {
    assertEquals(future.getRobustness(i).getValue(),expected.getRobustness(i).getValue(),""String_Node_Str"" + i + ""String_Node_Str"");
  }
}","@Test public void testFutureMonitorIncreasing(){
  Monitor subMonitor=createIncreasingTestMonitor(10,1);
  Monitor future=new FutureMonitor(EMPTY_PROPERTY,subMonitor,new TimeInterval(2,4,IntervalBoundaryType.CLOSED),Collections.EMPTY_LIST);
  Monitor expected=createTestMonitor(4,5,6,7,8,9);
  assertEquals(future.size(),expected.size(),""String_Node_Str"");
  for (int i=0; i < expected.size(); i++) {
    assertEquals(future.getRobustness(i).getValue(),expected.getRobustness(i).getValue(),""String_Node_Str"" + i + ""String_Node_Str"");
  }
}",0.9781990521327014
180331,"@Test public void testFutureMonitorDecreasing(){
  Monitor subMonitor=createDecreasingTestMonitor(10,1);
  Monitor future=new FutureMonitor(EMPTY_PROPERTY,subMonitor,new TimeInterval(2,4,IntervalBoundaryType.CLOSED));
  Monitor expected=createTestMonitor(7,6,5,4,3,2);
  assertEquals(future.size(),expected.size(),""String_Node_Str"");
  for (int i=0; i < expected.size(); i++) {
    assertEquals(future.getRobustness(i).getValue(),expected.getRobustness(i).getValue(),""String_Node_Str"" + i + ""String_Node_Str"");
  }
}","@Test public void testFutureMonitorDecreasing(){
  Monitor subMonitor=createDecreasingTestMonitor(10,1);
  Monitor future=new FutureMonitor(EMPTY_PROPERTY,subMonitor,new TimeInterval(2,4,IntervalBoundaryType.CLOSED),Collections.EMPTY_LIST);
  Monitor expected=createTestMonitor(7,6,5,4,3,2);
  assertEquals(future.size(),expected.size(),""String_Node_Str"");
  for (int i=0; i < expected.size(); i++) {
    assertEquals(future.getRobustness(i).getValue(),expected.getRobustness(i).getValue(),""String_Node_Str"" + i + ""String_Node_Str"");
  }
}",0.9781990521327014
180332,"@Test public void testGloballyMonitorDecreasing(){
  Monitor subMonitor=createDecreasingTestMonitor(10,1);
  Monitor future=new GloballyMonitor(EMPTY_PROPERTY,subMonitor,new TimeInterval(2,4,IntervalBoundaryType.CLOSED));
  Monitor expected=createTestMonitor(5,4,3,2,1,0);
  assertEquals(future.size(),expected.size(),""String_Node_Str"");
  for (int i=0; i < expected.size(); i++) {
    assertEquals(future.getRobustness(i).getValue(),expected.getRobustness(i).getValue(),""String_Node_Str"" + i + ""String_Node_Str"");
  }
}","@Test public void testGloballyMonitorDecreasing(){
  Monitor subMonitor=createDecreasingTestMonitor(10,1);
  Monitor future=new GloballyMonitor(EMPTY_PROPERTY,subMonitor,new TimeInterval(2,4,IntervalBoundaryType.CLOSED),Collections.EMPTY_LIST);
  Monitor expected=createTestMonitor(5,4,3,2,1,0);
  assertEquals(future.size(),expected.size(),""String_Node_Str"");
  for (int i=0; i < expected.size(); i++) {
    assertEquals(future.getRobustness(i).getValue(),expected.getRobustness(i).getValue(),""String_Node_Str"" + i + ""String_Node_Str"");
  }
}",0.9783631232361242
180333,"@Test public void testGloballyMonitorIncreasing(){
  Monitor subMonitor=createIncreasingTestMonitor(10,1);
  Monitor future=new GloballyMonitor(EMPTY_PROPERTY,subMonitor,new TimeInterval(2,4,IntervalBoundaryType.CLOSED));
  Monitor expected=createTestMonitor(2,3,4,5,6,7);
  assertEquals(future.size(),expected.size(),""String_Node_Str"");
  for (int i=0; i < expected.size(); i++) {
    assertEquals(future.getRobustness(i).getValue(),expected.getRobustness(i).getValue(),""String_Node_Str"" + i + ""String_Node_Str"");
  }
}","@Test public void testGloballyMonitorIncreasing(){
  Monitor subMonitor=createIncreasingTestMonitor(10,1);
  Monitor future=new GloballyMonitor(EMPTY_PROPERTY,subMonitor,new TimeInterval(2,4,IntervalBoundaryType.CLOSED),Collections.EMPTY_LIST);
  Monitor expected=createTestMonitor(2,3,4,5,6,7);
  assertEquals(future.size(),expected.size(),""String_Node_Str"");
  for (int i=0; i < expected.size(); i++) {
    assertEquals(future.getRobustness(i).getValue(),expected.getRobustness(i).getValue(),""String_Node_Str"" + i + ""String_Node_Str"");
  }
}",0.9783631232361242
180334,"public InitialSampling getObject(Node source) throws XMLFormatException {
  if (!source.getNodeName().equals(INITIAL_SAMPLING_NAME)) {
    throw new XMLFormatException(""String_Node_Str"" + INITIAL_SAMPLING_NAME + ""String_Node_Str""+ source.getNodeName()+ ""String_Node_Str"");
  }
  Map<String,Integer> varSampling=new HashMap<>();
  Map<String,Integer> paramSampling=new HashMap<>();
  Collection<Expression> toRelease=new ArrayList<>();
  NodeList children=source.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    Node child=children.item(i);
switch (child.getNodeName()) {
case VARIABLE_NAME:
{
        int s=Integer.parseInt(child.getAttributes().getNamedItem(ATTRIBUTE_SAMPLING).getTextContent());
        String name=child.getAttributes().getNamedItem(ATTRIBUTE_NAME).getTextContent();
        varSampling.put(name,s);
        break;
      }
case PARAMETER_NAME:
{
      int s=Integer.parseInt(child.getAttributes().getNamedItem(ATTRIBUTE_SAMPLING).getTextContent());
      String name=child.getAttributes().getNamedItem(ATTRIBUTE_NAME).getTextContent();
      paramSampling.put(name,s);
      toRelease.add(odeSystem.getAvailableParameters().get(name));
      break;
    }
default :
  throw new XMLFormatException(""String_Node_Str"" + child.getNodeName());
}
}
OdeSystem releasedOdeSystem=odeSystem.release(toRelease);
int[] sampling=new int[releasedOdeSystem.dimension()];
for (int dim=0; dim < odeSystem.dimension(); dim++) {
if (odeSystem.isVariable(dim)) {
Variable var=odeSystem.getVariable(dim);
sampling[dim]=varSampling.containsKey(var.getName()) ? varSampling.get(var.getName()) : 1;
}
 else {
Parameter param=odeSystem.getParameter(dim);
sampling[dim]=paramSampling.containsKey(param.getName()) ? paramSampling.get(param.getName()) : 1;
}
}
return new ArrayInitialSampling(releasedOdeSystem,sampling);
}","@Override public InitialSampling getObject(Node source) throws XMLFormatException {
  if (!source.getNodeName().equals(INITIAL_SAMPLING_NAME)) {
    throw new XMLFormatException(""String_Node_Str"" + INITIAL_SAMPLING_NAME + ""String_Node_Str""+ source.getNodeName()+ ""String_Node_Str"");
  }
  Map<String,Integer> varSampling=new HashMap<>();
  Map<String,Integer> paramSampling=new HashMap<>();
  Collection<Expression> toRelease=new ArrayList<>();
  NodeList children=source.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    Node child=children.item(i);
switch (child.getNodeName()) {
case VARIABLE_NAME:
{
        int s=Integer.parseInt(child.getAttributes().getNamedItem(ATTRIBUTE_SAMPLING).getTextContent());
        String name=child.getAttributes().getNamedItem(ATTRIBUTE_NAME).getTextContent();
        varSampling.put(name,s);
        break;
      }
case PARAMETER_NAME:
{
      int s=Integer.parseInt(child.getAttributes().getNamedItem(ATTRIBUTE_SAMPLING).getTextContent());
      String name=child.getAttributes().getNamedItem(ATTRIBUTE_NAME).getTextContent();
      paramSampling.put(name,s);
      toRelease.add(odeSystem.getAvailableParameters().get(name));
      break;
    }
default :
  throw new XMLFormatException(""String_Node_Str"" + child.getNodeName());
}
}
OdeSystem releasedOdeSystem=odeSystem.release(toRelease);
int[] sampling=new int[releasedOdeSystem.dimension()];
for (int dim=0; dim < odeSystem.dimension(); dim++) {
if (odeSystem.isVariable(dim)) {
Variable var=odeSystem.getVariable(dim);
sampling[dim]=varSampling.containsKey(var.getName()) ? varSampling.get(var.getName()) : 1;
}
 else {
Parameter param=odeSystem.getParameter(dim);
sampling[dim]=paramSampling.containsKey(param.getName()) ? paramSampling.get(param.getName()) : 1;
}
}
return new ArrayInitialSampling(releasedOdeSystem,sampling);
}",0.9972826086956522
180335,"public void register(ExtensionBuilder builder){
  builder.extension(SimulatorRegistrar.class);
  builder.extension(ConfigurationRegistrar.class);
}","@Override public void register(ExtensionBuilder builder){
  builder.extension(SimulatorRegistrar.class);
  builder.extension(ConfigurationRegistrar.class);
}",0.9671052631578948
180336,"@Provide public AdaptiveStepSimulator registerAdaptiveStepSimulator(ComputationSimulationConfiguration configuration){
  return new SimpleAdaptiveStepSimulator(new LsodeEngineFactory());
}","@Provide public AdaptiveStepSimulator registerAdaptiveStepSimulator(ComputationSimulationConfiguration configuration){
  if (configuration.getOdepkgFunction() == null) {
    LOGGER.debug(""String_Node_Str"");
    return new SimpleAdaptiveStepSimulator(new LsodeEngineFactory(configuration.getLsodeIntegrationMethod()));
  }
 else {
    if (configuration.getOdepkgFunction().isAvailable()) {
      LOGGER.debug(""String_Node_Str"" + configuration.getOdepkgFunction().name() + ""String_Node_Str"");
      return new SimpleAdaptiveStepSimulator(configuration.getOdepkgFunction());
    }
 else {
      LOGGER.warn(""String_Node_Str"" + configuration.getOdepkgFunction().name() + ""String_Node_Str"");
      return new SimpleAdaptiveStepSimulator(new LsodeEngineFactory(configuration.getLsodeIntegrationMethod()));
    }
  }
}",0.3763763763763764
180337,"@Override public <T extends Trajectory>SimulatedDataBlock<T> simulate(AdaptiveStepConfiguration configuration,DataBlock<T> data){
  SimulationEngine simulationEngine=simulationEngineFactory.simulationEngine(configuration.getMaxNumberOfIterations(),configuration.getPrecisionConfiguration().getMaxRelativeError());
  List<T> trajectories=new ArrayList<>(data.size());
  Status[] statuses=new Status[data.size()];
  for (int i=0; i < data.size(); i++) {
    Trajectory simulated=simulationEngine.simulate(data.getTrajectory(i).getLastPoint(),configuration.getOdeSystem(),configuration.getPrecisionConfiguration().getTimeStep(),configuration.getSpace().getMaxBounds().getTime());
    LinkedTrajectory trajectory=data.getTrajectory(i) instanceof LinkedTrajectory ? (LinkedTrajectory)data.getTrajectory(i) : (data.getTrajectory(i) instanceof TrajectoryWithNeighborhood ? LinkedTrajectory.createAndUpdateReferenceWithNeighborhood((TrajectoryWithNeighborhood)data.getTrajectory(i)) : LinkedTrajectory.createAndUpdateReference(data.getTrajectory(i)));
    trajectory.append(simulated);
    trajectories.add((T)trajectory);
    if (simulated.getLastPoint().getTime() < configuration.getSpace().getMaxBounds().getTime()) {
      statuses[i]=Status.TIMEOUT;
    }
 else {
      statuses[i]=Status.OK;
    }
  }
  simulationEngine.close();
  return new ArraySimulatedDataBlock<>(new ListDataBlock<>(trajectories),statuses);
}","@Override public <T extends Trajectory>SimulatedDataBlock<T> simulate(AdaptiveStepConfiguration configuration,DataBlock<T> data){
  SimulationEngine simulationEngine=simulationEngineFactory.simulationEngine(configuration.getMaxNumberOfIterations(),configuration.getPrecisionConfiguration().getMaxRelativeError());
  try {
    List<T> trajectories=new ArrayList<>(data.size());
    Status[] statuses=new Status[data.size()];
    for (int i=0; i < data.size(); i++) {
      Trajectory simulated=simulationEngine.simulate(data.getTrajectory(i).getLastPoint(),configuration.getOdeSystem(),configuration.getPrecisionConfiguration().getTimeStep(),configuration.getSpace().getMaxBounds().getTime());
      LinkedTrajectory trajectory=data.getTrajectory(i) instanceof LinkedTrajectory ? (LinkedTrajectory)data.getTrajectory(i) : (data.getTrajectory(i) instanceof TrajectoryWithNeighborhood ? LinkedTrajectory.createAndUpdateReferenceWithNeighborhood((TrajectoryWithNeighborhood)data.getTrajectory(i)) : LinkedTrajectory.createAndUpdateReference(data.getTrajectory(i)));
      trajectory.append(simulated);
      trajectories.add((T)trajectory);
      if (simulated.getLastPoint().getTime() < configuration.getSpace().getMaxBounds().getTime()) {
        statuses[i]=Status.TIMEOUT;
      }
 else {
        statuses[i]=Status.OK;
      }
    }
    return new ArraySimulatedDataBlock<>(new ListDataBlock<>(trajectories),statuses);
  }
  finally {
    simulationEngine.close();
  }
}",0.9618585298196948
180338,"@Override protected OctaveDouble rawSimulation(Point point,OctaveOdeSystem odeSystem,long numberOfIterations,double timeStep){
  getOctave().eval(odeSystem.octaveString());
  getOctave().eval(""String_Node_Str"" + Arrays.toString(point.toArray(odeSystem.dimension())) + ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + point.getTime() + ""String_Node_Str""+ numberOfIterations * timeStep + ""String_Node_Str"" + numberOfIterations + ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + odeSystem.octaveName() + ""String_Node_Str"");
  return getOctave().get(OctaveDouble.class,""String_Node_Str"");
}","@Override protected OctaveDouble rawSimulation(Point point,OctaveOdeSystem odeSystem,long numberOfIterations,double timeStep){
  getOctave().eval(odeSystem.octaveString(false));
  getOctave().eval(""String_Node_Str"" + Arrays.toString(point.toArray(odeSystem.getVariables().size())) + ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + point.getTime() + ""String_Node_Str""+ numberOfIterations * timeStep + ""String_Node_Str"" + numberOfIterations + ""String_Node_Str"");
  getOctave().eval(""String_Node_Str"" + odeSystem.octaveName() + ""String_Node_Str"");
  return getOctave().get(OctaveDouble.class,""String_Node_Str"");
}",0.9731051344743276
180339,"@Override public SimulationEngine simulationEngine(long stepLimit,double relativeTolerance){
  return new LsodeEngine(new OctaveEngineFactory().getScriptEngine(),stepLimit,relativeTolerance);
}","@Override public SimulationEngine simulationEngine(long stepLimit,double relativeTolerance){
  return new LsodeEngine(new OctaveEngineFactory().getScriptEngine(),integrationMethod,stepLimit,relativeTolerance);
}",0.9554455445544554
180340,"public LsodeEngine(OctaveEngine octave,long stepLimit,double relativeTolerance){
  super(octave,stepLimit,relativeTolerance);
  getOctave().eval(""String_Node_Str"" + stepLimit + ""String_Node_Str"");
  if (relativeTolerance > 0) {
    getOctave().eval(""String_Node_Str"" + relativeTolerance + ""String_Node_Str"");
  }
}","public LsodeEngine(OctaveEngine octave,IntegrationMethod integrationMethod,long stepLimit,double relativeTolerance){
  super(octave,stepLimit,relativeTolerance);
  getOctave().eval(""String_Node_Str"" + stepLimit + ""String_Node_Str"");
  if (relativeTolerance > 0) {
    getOctave().eval(""String_Node_Str"" + relativeTolerance + ""String_Node_Str"");
  }
  getOctave().eval(""String_Node_Str"" + integrationMethod.getName() + ""String_Node_Str"");
}",0.8339973439575034
180341,"@Test public void testSimulatorLoaded(){
  assertNotNull(manager.resolve(AdaptiveStepSimulator.class,Default.class,manager.getRootContext()));
}","@Test public void testSimulatorLoaded(){
  Context context=new AbstractContext(){
    @Override public Class<? extends Annotation> getScope(){
      return ComputationInstanceScope.class;
    }
  }
;
  manager.initializeContext(context);
  assertNotNull(manager.resolve(AdaptiveStepSimulator.class,Default.class,context));
}",0.5128205128205128
180342,"@Test public void testConfigurationLoaded(){
  Context context=new AbstractContext(){
    public Class<? extends Annotation> getScope(){
      return ComputationInstanceScope.class;
    }
  }
;
  manager.initializeContext(context);
  assertNotNull(manager.resolve(AdaptiveStepConfiguration.class,Default.class,context));
}","@Test public void testConfigurationLoaded(){
  Context context=new AbstractContext(){
    @Override public Class<? extends Annotation> getScope(){
      return ComputationInstanceScope.class;
    }
  }
;
  manager.initializeContext(context);
  assertNotNull(manager.resolve(AdaptiveStepConfiguration.class,Default.class,context));
}",0.9847094801223242
180343,"public Class<? extends Annotation> getScope(){
  return ComputationInstanceScope.class;
}","@Override public Class<? extends Annotation> getScope(){
  return ComputationInstanceScope.class;
}",0.946808510638298
180344,"@Override public FormulaInterval getObject(Node source) throws XMLFormatException {
  NodeList bounds=source.getChildNodes();
  float upper=0;
  float lower=0;
  IntervalBoundaryType upperType=null;
  IntervalBoundaryType lowerType=null;
  for (int index=0; index < bounds.getLength(); index++) {
    Node bound=bounds.item(index);
    if (bound.getNodeName().equals(LOWER_NAME)) {
      lower=FloatFactory.getObject(bound.getFirstChild());
      lowerType=getBoundaryType(bound);
    }
 else     if (bound.getNodeName().equals(UPPER_NAME)) {
      upper=FloatFactory.getObject(bound.getFirstChild());
      upperType=getBoundaryType(bound);
    }
 else {
      throw new XMLFormatException(""String_Node_Str"" + bound.getNodeName() + ""String_Node_Str""+ UPPER_NAME+ ""String_Node_Str""+ LOWER_NAME+ ""String_Node_Str"");
    }
  }
  if (upperType == null) {
    throw new XMLFormatException(""String_Node_Str"");
  }
  if (lowerType == null) {
    throw new XMLFormatException(""String_Node_Str"");
  }
  if (lower <= 0) {
    throw new XMLFormatException(""String_Node_Str"");
  }
  if (upper < lower) {
    throw new XMLFormatException(""String_Node_Str"");
  }
  return new TimeInterval(lower,upper,lowerType,upperType);
}","@Override public FormulaInterval getObject(Node source) throws XMLFormatException {
  NodeList bounds=source.getChildNodes();
  float upper=0;
  float lower=0;
  IntervalBoundaryType upperType=null;
  IntervalBoundaryType lowerType=null;
  for (int index=0; index < bounds.getLength(); index++) {
    Node bound=bounds.item(index);
    if (bound.getNodeName().equals(LOWER_NAME)) {
      lower=FloatFactory.getObject(bound.getFirstChild());
      lowerType=getBoundaryType(bound);
    }
 else     if (bound.getNodeName().equals(UPPER_NAME)) {
      upper=FloatFactory.getObject(bound.getFirstChild());
      upperType=getBoundaryType(bound);
    }
 else {
      throw new XMLFormatException(""String_Node_Str"" + bound.getNodeName() + ""String_Node_Str""+ UPPER_NAME+ ""String_Node_Str""+ LOWER_NAME+ ""String_Node_Str"");
    }
  }
  if (upperType == null) {
    throw new XMLFormatException(""String_Node_Str"");
  }
  if (lowerType == null) {
    throw new XMLFormatException(""String_Node_Str"");
  }
  if (lower < 0) {
    throw new XMLFormatException(""String_Node_Str"");
  }
  if (upper < lower) {
    throw new XMLFormatException(""String_Node_Str"");
  }
  return new TimeInterval(lower,upper,lowerType,upperType);
}",0.999586947542338
180345,"@Override public LimitedDistance distance(Point first,Point second){
  final Distance distance=EUCLIDEAN_METRIC.distance(first,second);
  return new LimitedDistance(){
    public boolean isValid(){
      return distance.value() >= Math.abs(value);
    }
    public float value(){
      return distance.value();
    }
  }
;
}","@Override public LimitedDistance distance(Point first,Point second){
  final Distance distance=EUCLIDEAN_METRIC.distance(first,second);
  return new LimitedDistance(){
    public boolean isValid(){
      return distance.value() <= Math.abs(value);
    }
    public float value(){
      return distance.value();
    }
  }
;
}",0.9969135802469136
180346,"public boolean isValid(){
  return distance.value() >= Math.abs(value);
}","public boolean isValid(){
  return distance.value() <= Math.abs(value);
}",0.9863013698630136
180347,"@Override public VerificationResult compute() throws ComputationFailedException {
  SpawnedDataBlock spawned=spawner.spawn(initialSpace,initialSampling);
  VerificationResult result=null;
  int iteration=0;
  while (spawned.size() != 0) {
    iteration++;
    LOGGER.info(""String_Node_Str"" + iteration + ""String_Node_Str""+ spawned.size()+ ""String_Node_Str"");
    SimulatedDataBlock simulated=simulator.simulate(simulationConfiguration,spawned);
    for (int i=0; i < spawned.size(); i++) {
      LinkedTrajectory.createAndUpdateReference(spawned.getTrajectory(i)).append(simulated.getTrajectory(i));
    }
    if (spawned.getSecondaryTrajectories().size() > 0) {
      SimulatedDataBlock simulatedSecondary=simulator.simulate(simulationConfiguration,spawned.getSecondaryTrajectories());
      for (int i=0; i < spawned.getSecondaryTrajectories().size(); i++) {
        LinkedTrajectory.createAndUpdateReference(spawned.getSecondaryTrajectories().getTrajectory(i)).append(simulatedSecondary.getTrajectory(i));
      }
    }
    VerifiedDataBlock<Trajectory> verified=verifier.verify(simulated,property);
    if (result == null) {
      result=new VerifiedDataBlockResultAdapter(verified);
    }
 else {
      result=result.merge(new VerifiedDataBlockResultAdapter(verified));
    }
    if (iterationLimit != 0 && iteration >= iterationLimit) {
      LOGGER.warn(""String_Node_Str"" + iterationLimit + ""String_Node_Str"");
      break;
    }
    DistanceCheckedDataBlock distanceChecked=distanceChecker.check(spawned.getConfiguration(),verified);
    spawned=spawner.spawn(spawned.getConfiguration(),distanceChecked);
  }
  if (LOGGER.isDebugEnabled()) {
    for (int i=0; i < result.size(); i++) {
      LOGGER.debug(""String_Node_Str"" + result.getPoint(i) + ""String_Node_Str""+ result.getRobustness(i).getValue());
    }
  }
  return result;
}","@Override public VerificationResult compute() throws ComputationFailedException {
  SpawnedDataBlock spawned=spawner.spawn(initialSpace,initialSampling);
  int batchSize=(int)Math.ceil(spawned.size() / (float)(threadId.maxId() + 1));
  int batchStart=batchSize * threadId.currentId();
  int batchEnd=Math.min(batchSize * (threadId.currentId() + 1),spawned.size());
  List<Trajectory> localSpawned=new ArrayList<>(batchSize);
  List<Trajectory> localSecondarySpawned=new ArrayList<>();
  for (int i=batchStart; i < batchEnd; i++) {
    localSpawned.add(spawned.getTrajectory(i));
    for (    Trajectory secondary : spawned.getConfiguration().getNeighborhood().getNeighbors(spawned.getTrajectory(i))) {
      localSecondarySpawned.add(secondary);
    }
  }
  spawned=new SpawnedDataBlockWrapper(new ListDataBlock<>(localSpawned),spawned.getConfiguration(),new ListDataBlock<>(localSecondarySpawned));
  VerificationResult result=null;
  int iteration=0;
  while (spawned.size() != 0) {
    iteration++;
    LOGGER.info(""String_Node_Str"" + threadId.currentId() + ""String_Node_Str""+ iteration+ ""String_Node_Str""+ spawned.size()+ ""String_Node_Str"");
    SimulatedDataBlock simulated=simulator.simulate(simulationConfiguration,spawned);
    for (int i=0; i < spawned.size(); i++) {
      LinkedTrajectory.createAndUpdateReference(spawned.getTrajectory(i)).append(simulated.getTrajectory(i));
    }
    if (spawned.getSecondaryTrajectories().size() > 0) {
      SimulatedDataBlock simulatedSecondary=simulator.simulate(simulationConfiguration,spawned.getSecondaryTrajectories());
      for (int i=0; i < spawned.getSecondaryTrajectories().size(); i++) {
        LinkedTrajectory.createAndUpdateReference(spawned.getSecondaryTrajectories().getTrajectory(i)).append(simulatedSecondary.getTrajectory(i));
      }
    }
    VerifiedDataBlock<Trajectory> verified=verifier.verify(simulated,property);
    if (result == null) {
      result=new VerifiedDataBlockResultAdapter(verified);
    }
 else {
      result=result.merge(new VerifiedDataBlockResultAdapter(verified));
    }
    if (iterationLimit != 0 && iteration == iterationLimit) {
      LOGGER.warn(""String_Node_Str"" + threadId.currentId() + ""String_Node_Str""+ iterationLimit+ ""String_Node_Str"");
      break;
    }
    DistanceCheckedDataBlock distanceChecked=distanceChecker.check(spawned.getConfiguration(),verified);
    spawned=spawner.spawn(spawned.getConfiguration(),distanceChecked);
  }
  return result;
}",0.7416879795396419
180348,"private void fireProcessing(ApplicationContext applicationContext) throws Exception {
  final Collection<Class<?>> newExtensions=new ArrayList<Class<?>>();
  final Collection<Class<? extends Context>> newContexts=new ArrayList<Class<? extends Context>>();
  fire(new ManagerProcessing(){
    public void extension(    Class<?> extension){
      if (extension == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      newExtensions.add(extension);
    }
    public Manager getManager(){
      return ManagerImpl.this;
    }
  }
,applicationContext);
  Map<Class<? extends Annotation>,Collection<Class<?>>> newExtensionsByScope=getScopedExtensions(newExtensions);
  for (  Entry<Class<? extends Annotation>,Collection<Class<?>>> entry : newExtensionsByScope.entrySet()) {
    if (!extensionsByScope.containsKey(entry.getKey())) {
      extensionsByScope.put(entry.getKey(),new ArrayList<Class<?>>());
    }
    extensionsByScope.get(entry.getKey()).addAll(entry.getValue());
  }
  extensionsByContext.get(applicationContext).addAll(createExtensions(newExtensions,applicationContext));
}","private void fireProcessing(ApplicationContext applicationContext) throws Exception {
  final Collection<Class<?>> newExtensions=new ArrayList<Class<?>>();
  final Collection<Class<? extends Context>> newContexts=new ArrayList<Class<? extends Context>>();
  fire(new ManagerProcessing(){
    public void extension(    Class<?> extension){
      if (extension == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      newExtensions.add(extension);
    }
    public Manager getManager(){
      return ManagerImpl.this;
    }
  }
,applicationContext);
  Map<Class<? extends Annotation>,Collection<Class<?>>> newExtensionsByScope=getScopedExtensions(newExtensions);
  for (  Entry<Class<? extends Annotation>,Collection<Class<?>>> entry : newExtensionsByScope.entrySet()) {
    if (!extensionsByScope.containsKey(entry.getKey())) {
      extensionsByScope.put(entry.getKey(),new ArrayList<Class<?>>());
    }
    extensionsByScope.get(entry.getKey()).addAll(entry.getValue());
  }
  if (newExtensionsByScope.get(ApplicationScope.class) != null) {
    extensionsByContext.get(applicationContext).addAll(createExtensions(newExtensionsByScope.get(ApplicationScope.class),applicationContext));
  }
}",0.9233404710920772
180349,"private void injectField(Object object,Field field,Context context){
  Class<? extends Annotation> qualifier=loadQualifier(field.getDeclaredAnnotations());
  Object service=null;
  if (qualifier != null) {
    service=getService(field.getType(),context,qualifier);
  }
 else {
    service=getService(field.getType(),context);
  }
  if (service == null) {
    throw new IllegalStateException(""String_Node_Str"" + field.getType().getName() + ""String_Node_Str""+ object.getClass().getName()+ ""String_Node_Str"");
  }
  field.setAccessible(true);
  try {
    field.set(object,field.getType().cast(service));
  }
 catch (  Exception ex) {
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
}","private void injectField(Object object,Field field,Context context){
  Class<? extends Annotation> qualifier=loadQualifier(field.getDeclaredAnnotations());
  Object service=null;
  if (qualifier != null) {
    service=getService(field.getType(),context,qualifier);
  }
 else {
    service=getService(field.getType(),context);
  }
  if (service == null) {
    throw new IllegalStateException(""String_Node_Str"" + field.getType().getName() + ""String_Node_Str""+ object.getClass().getName()+ ""String_Node_Str""+ context+ ""String_Node_Str"");
  }
  field.setAccessible(true);
  try {
    field.set(object,field.getType().cast(service));
  }
 catch (  Exception ex) {
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
}",0.9802538787023978
180350,"@Override public SpawnedDataBlock spawn(OrthogonalSpace space,InitialSampling initialSampling){
  if (space.getDimension() != initialSampling.getDimension()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  float[] distance=new float[space.getDimension()];
  int numOfSeeds=1;
  for (int dim=0; dim < space.getDimension(); dim++) {
    if (initialSampling.getNumberOfSamples(dim) > 1) {
      distance[dim]=space.getSize(dim) / (initialSampling.getNumberOfSamples(dim) - 1);
    }
 else {
      distance[dim]=0;
    }
    numOfSeeds*=initialSampling.getNumberOfSamples(dim);
  }
  List<Trajectory> seeds=new ArrayList<Trajectory>(numOfSeeds / 2);
  List<Trajectory> secondarySeeds=new ArrayList<Trajectory>(numOfSeeds / 2);
  List<Trajectory> allSeeds=new ArrayList<Trajectory>(numOfSeeds);
  Map<Trajectory,Boolean> allSeedsMap=new HashMap<Trajectory,Boolean>(numOfSeeds);
  Map<Trajectory,List<Trajectory>> neighborhoodLists=new HashMap<Trajectory,List<Trajectory>>(numOfSeeds / 2);
  Trajectory minBoundsTrajectory=new PointTrajectory(space.getMinBounds());
  allSeeds.add(minBoundsTrajectory);
  allSeedsMap.put(minBoundsTrajectory,Boolean.FALSE);
  neighborhoodLists.put(minBoundsTrajectory,new ArrayList<Trajectory>());
  for (int dim=0; dim < space.getDimension(); dim++) {
    int numOfOldSeeds=allSeeds.size();
    for (int seed=0; seed < numOfOldSeeds; seed++) {
      Trajectory toBeNeighbor=allSeeds.get(seed);
      for (int sample=1; sample < initialSampling.getNumberOfSamples(dim); sample++) {
        float[] newPoint=allSeeds.get(seed).getFirstPoint().toArrayCopy();
        newPoint[dim]+=sample * distance[dim];
        Trajectory newTrajectory=new PointTrajectory(new ArrayPoint(allSeeds.get(seed).getFirstPoint().getTime(),newPoint));
        allSeeds.add(newTrajectory);
        allSeedsMap.put(newTrajectory,!allSeedsMap.get(toBeNeighbor));
        neighborhoodLists.put(newTrajectory,new ArrayList<Trajectory>());
        neighborhoodLists.get(toBeNeighbor).add(newTrajectory);
        toBeNeighbor=newTrajectory;
      }
    }
  }
  for (  Entry<Trajectory,Boolean> entry : allSeedsMap.entrySet()) {
    if (entry.getValue()) {
      seeds.add(entry.getKey());
    }
 else {
      secondarySeeds.add(entry.getKey());
      for (      Trajectory master : neighborhoodLists.get(entry.getKey())) {
        neighborhoodLists.get(master).add(entry.getKey());
      }
      neighborhoodLists.remove(entry.getKey());
    }
  }
  final Map<Point,DataBlock<Trajectory>> neighborhoodDataBlocks=new HashMap<Point,DataBlock<Trajectory>>(neighborhoodLists.size());
  for (  Trajectory key : neighborhoodLists.keySet()) {
    neighborhoodDataBlocks.put(key.getFirstPoint(),new ListDataBlock<Trajectory>(neighborhoodLists.get(key)));
  }
  return new SpawnedDataBlockWrapper(new ListDataBlock<Trajectory>(seeds),new AbstractConfiguration(initialSampling,space){
    private TrajectoryNeighborhood trajectoryNeighborhood=new MapTrajectoryNeighborhood(neighborhoodDataBlocks);
    public int getStartIndex(    int index,    int neighborIndex){
      return 0;
    }
    public TrajectoryNeighborhood getNeighborhood(){
      return trajectoryNeighborhood;
    }
  }
,new ListDataBlock<Trajectory>(secondarySeeds));
}","@Override public SpawnedDataBlock spawn(OrthogonalSpace space,InitialSampling initialSampling){
  if (space.getDimension() != initialSampling.getDimension()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  float[] distance=new float[space.getDimension()];
  int numOfSeeds=1;
  for (int dim=0; dim < space.getDimension(); dim++) {
    if (initialSampling.getNumberOfSamples(dim) > 1) {
      distance[dim]=space.getSize(dim) / (initialSampling.getNumberOfSamples(dim) - 1);
    }
 else {
      distance[dim]=0;
    }
    numOfSeeds*=initialSampling.getNumberOfSamples(dim);
  }
  List<Trajectory> seeds=new ArrayList<>(numOfSeeds / 2);
  List<Trajectory> secondarySeeds=new ArrayList<>(numOfSeeds / 2);
  List<Trajectory> allSeeds=new ArrayList<>(numOfSeeds);
  Map<Trajectory,Boolean> allSeedsMap=new HashMap<>(numOfSeeds);
  Map<Trajectory,List<Trajectory>> neighborhoodLists=new HashMap<>(numOfSeeds / 2);
  Trajectory minBoundsTrajectory=new PointTrajectory(space.getMinBounds());
  allSeeds.add(minBoundsTrajectory);
  allSeedsMap.put(minBoundsTrajectory,Boolean.FALSE);
  neighborhoodLists.put(minBoundsTrajectory,new ArrayList<Trajectory>());
  for (int dim=0; dim < space.getDimension(); dim++) {
    int numOfOldSeeds=allSeeds.size();
    for (int seed=0; seed < numOfOldSeeds; seed++) {
      Trajectory toBeNeighbor=allSeeds.get(seed);
      for (int sample=1; sample < initialSampling.getNumberOfSamples(dim); sample++) {
        float[] newPoint=allSeeds.get(seed).getFirstPoint().toArrayCopy();
        newPoint[dim]+=sample * distance[dim];
        Trajectory newTrajectory=new PointTrajectory(new ArrayPoint(allSeeds.get(seed).getFirstPoint().getTime(),newPoint));
        allSeeds.add(newTrajectory);
        boolean primary=!allSeedsMap.get(toBeNeighbor);
        if (primary) {
          seeds.add(newTrajectory);
        }
        allSeedsMap.put(newTrajectory,primary);
        neighborhoodLists.put(newTrajectory,new ArrayList<Trajectory>());
        neighborhoodLists.get(toBeNeighbor).add(newTrajectory);
        toBeNeighbor=newTrajectory;
      }
    }
  }
  for (  Entry<Trajectory,Boolean> entry : allSeedsMap.entrySet()) {
    if (!entry.getValue()) {
      secondarySeeds.add(entry.getKey());
      for (      Trajectory master : neighborhoodLists.get(entry.getKey())) {
        neighborhoodLists.get(master).add(entry.getKey());
      }
      neighborhoodLists.remove(entry.getKey());
    }
  }
  final Map<Point,DataBlock<Trajectory>> neighborhoodDataBlocks=new HashMap<Point,DataBlock<Trajectory>>(neighborhoodLists.size());
  for (  Trajectory key : neighborhoodLists.keySet()) {
    neighborhoodDataBlocks.put(key.getFirstPoint(),new ListDataBlock<Trajectory>(neighborhoodLists.get(key)));
  }
  return new SpawnedDataBlockWrapper(new ListDataBlock<Trajectory>(seeds),new AbstractConfiguration(initialSampling,space){
    private TrajectoryNeighborhood trajectoryNeighborhood=new MapTrajectoryNeighborhood(neighborhoodDataBlocks);
    public int getStartIndex(    int index,    int neighborIndex){
      return 0;
    }
    public TrajectoryNeighborhood getNeighborhood(){
      return trajectoryNeighborhood;
    }
  }
,new ListDataBlock<Trajectory>(secondarySeeds));
}",0.9559301066955312
180351,"@Test public void testLoad() throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  Manager manager=ManagerImpl.create();
  manager.start();
  assertNotNull(manager.resolve(TrajectorySpawner.class,Default.class,manager.getRootContext()));
  assertNotNull(manager.resolve(DistanceChecker.class,Default.class,manager.getRootContext()));
}","@Test(enabled=false) public void testLoad() throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  Manager manager=ManagerImpl.create();
  manager.start();
  assertNotNull(manager.resolve(TrajectorySpawner.class,Default.class,manager.getRootContext()));
  assertNotNull(manager.resolve(DistanceChecker.class,Default.class,manager.getRootContext()));
}",0.9796472184531886
180352,"@Override protected SpawnedResult spawnTrajectories(Trajectory trajectory,Trajectory neighbor,Distance distance){
  int diffDimension=-1;
  for (int dim=0; dim < trajectory.getDimension(); dim++) {
    if (trajectory.getFirstPoint().getValue(dim) != neighbor.getFirstPoint().getValue(dim)) {
      if (diffDimension != -1) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      diffDimension=dim;
    }
  }
  float radius=Math.abs(trajectory.getFirstPoint().getValue(diffDimension) - neighbor.getFirstPoint().getValue(diffDimension)) / 2;
  float[] middleSeedData=trajectory.getFirstPoint().toArrayCopy();
  middleSeedData[diffDimension]=(trajectory.getFirstPoint().getValue(diffDimension) - neighbor.getFirstPoint().getValue(diffDimension)) / 2;
  Trajectory middleTrajectory=new PointTrajectory(trajectory.getFirstPoint().getTime(),middleSeedData);
  List<Trajectory> neighborTrajectories=new ArrayList<Trajectory>();
  List<Trajectory> spawnedSecondaryTrajectories=new ArrayList<Trajectory>();
  for (int dim=0; dim < trajectory.getDimension(); dim++) {
    if (dim == diffDimension) {
      continue;
    }
    for (int sign=-1; sign <= 1; sign+=2) {
      float[] newPointData=middleTrajectory.getFirstPoint().toArrayCopy();
      newPointData[dim]+=sign * radius;
      Trajectory newTrajectory=new PointTrajectory(trajectory.getFirstPoint().getTime(),newPointData);
      if (alreadySpawnedCollisionTrajectories.containsKey(newTrajectory.getFirstPoint())) {
        newTrajectory=alreadySpawnedCollisionTrajectories.get(newTrajectory.getFirstPoint());
      }
 else {
        alreadySpawnedCollisionTrajectories.put(newTrajectory.getFirstPoint(),newTrajectory);
        spawnedSecondaryTrajectories.add(newTrajectory);
      }
      neighborTrajectories.add(newTrajectory);
    }
  }
  Map<Point,DataBlock<Trajectory>> neighborhood=new HashMap<Point,DataBlock<Trajectory>>(neighborTrajectories.size() + 1);
  neighborhood.put(middleTrajectory.getFirstPoint(),new ListDataBlock<Trajectory>(neighborTrajectories));
  Collection<Trajectory> spawnedCol=new ArrayList<Trajectory>();
  spawnedCol.add(middleTrajectory);
  return new SpawnedResult(neighborhood,spawnedCol,spawnedSecondaryTrajectories);
}","@Override protected SpawnedResult spawnTrajectories(Trajectory trajectory,Trajectory neighbor,Distance distance){
  int diffDimension=-1;
  for (int dim=0; dim < trajectory.getDimension(); dim++) {
    if (trajectory.getFirstPoint().getValue(dim) != neighbor.getFirstPoint().getValue(dim)) {
      if (diffDimension != -1) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      diffDimension=dim;
    }
  }
  float radius=Math.abs(trajectory.getFirstPoint().getValue(diffDimension) - neighbor.getFirstPoint().getValue(diffDimension)) / 2;
  float[] middleSeedData=trajectory.getFirstPoint().toArrayCopy();
  middleSeedData[diffDimension]=(trajectory.getFirstPoint().getValue(diffDimension) + neighbor.getFirstPoint().getValue(diffDimension)) / 2;
  Trajectory middleTrajectory=new PointTrajectory(trajectory.getFirstPoint().getTime(),middleSeedData);
  List<Trajectory> neighborTrajectories=new ArrayList<Trajectory>();
  List<Trajectory> spawnedSecondaryTrajectories=new ArrayList<Trajectory>();
  for (int dim=0; dim < trajectory.getDimension(); dim++) {
    if (dim == diffDimension) {
      continue;
    }
    for (int sign=-1; sign <= 1; sign+=2) {
      float[] newPointData=middleTrajectory.getFirstPoint().toArrayCopy();
      newPointData[dim]+=sign * radius;
      Trajectory newTrajectory=new PointTrajectory(trajectory.getFirstPoint().getTime(),newPointData);
      if (alreadySpawnedCollisionTrajectories.containsKey(newTrajectory.getFirstPoint())) {
        newTrajectory=alreadySpawnedCollisionTrajectories.get(newTrajectory.getFirstPoint());
      }
 else {
        alreadySpawnedCollisionTrajectories.put(newTrajectory.getFirstPoint(),newTrajectory);
        spawnedSecondaryTrajectories.add(newTrajectory);
      }
      neighborTrajectories.add(newTrajectory);
    }
  }
  Map<Point,DataBlock<Trajectory>> neighborhood=new HashMap<Point,DataBlock<Trajectory>>(neighborTrajectories.size() + 1);
  neighborhood.put(middleTrajectory.getFirstPoint(),new ListDataBlock<Trajectory>(neighborTrajectories));
  Collection<Trajectory> spawnedCol=new ArrayList<Trajectory>();
  spawnedCol.add(middleTrajectory);
  return new SpawnedResult(neighborhood,spawnedCol,spawnedSecondaryTrajectories);
}",0.9995505617977528
180353,"@Override public Point getPoint(int index){
  return data.getTrajectory(index).getFirstPoint();
}","@Override public Point getPoint(int index){
  return data.getTrajectory(index).getReference().getTrajectory().getFirstPoint();
}",0.8622222222222222
180354,"@Override protected AdaptiveStepConfiguration createConfiguration(){
  final OdeSystem odeSystem=getOdeSystem(10);
  return new AdaptiveStepConfiguration(){
    private float[] maxAbsoluteError;
    private OrthogonalSpace space;
    private float[] steps;
    private PrecisionConfiguration precisionConfiguration=new PrecisionConfiguration(){
      public int getDimension(){
        return 10;
      }
      public float getMaxAbsoluteError(      int dim){
        if (maxAbsoluteError == null) {
          maxAbsoluteError=new float[getDimension()];
          for (int d=0; d < getDimension(); d++) {
            maxAbsoluteError[d]=1;
          }
        }
        return maxAbsoluteError[dim];
      }
      public float getMaxRelativeError(){
        return (float)0.1;
      }
      public Element toXML(      Document doc){
        throw new UnsupportedOperationException(""String_Node_Str"");
      }
    }
;
    @Override public int getDimension(){
      return 10;
    }
    @Override public int getMaxNumberOfIterations(){
      return 100;
    }
    @Override public OdeSystem getOdeSystem(){
      return odeSystem;
    }
    public OrthogonalSpace getSpace(){
      if (space == null) {
        float[] minBounds=new float[getDimension()];
        for (int dim=0; dim < getDimension(); dim++) {
          minBounds[dim]=0;
        }
        float[] maxBounds=new float[getDimension()];
        for (int dim=0; dim < getDimension(); dim++) {
          maxBounds[dim]=(dim + 1) * 10000;
        }
        space=new OrthogonalSpace(new ArrayPoint(0,minBounds),new ArrayPoint((float)100,maxBounds));
      }
      return space;
    }
    @Override public float[] getSteps(){
      if (steps == null) {
        steps=new float[getDimension()];
        for (int dim=0; dim < getDimension(); dim++) {
          steps[dim]=1;
        }
      }
      return steps;
    }
    @Override public float getTimeStep(){
      return (float)0.01;
    }
    public PrecisionConfiguration getPrecisionConfiguration(){
      return precisionConfiguration;
    }
  }
;
}","@Override protected AdaptiveStepConfiguration createConfiguration(){
  final OdeSystem odeSystem=getOdeSystem(10);
  return new AdaptiveStepConfiguration(){
    private float[] maxAbsoluteError;
    private OrthogonalSpace space;
    private float[] steps;
    private PrecisionConfiguration precisionConfiguration=new PrecisionConfiguration(){
      public int getDimension(){
        return 10;
      }
      public float getMaxAbsoluteError(      int dim){
        if (maxAbsoluteError == null) {
          maxAbsoluteError=new float[getDimension()];
          for (int d=0; d < getDimension(); d++) {
            maxAbsoluteError[d]=1;
          }
        }
        return maxAbsoluteError[dim];
      }
      public float getMaxRelativeError(){
        return (float)0.1;
      }
      public Element toXML(      Document doc){
        throw new UnsupportedOperationException(""String_Node_Str"");
      }
      public float getTimeStep(){
        return 0.01f;
      }
    }
;
    @Override public int getDimension(){
      return 10;
    }
    @Override public int getMaxNumberOfIterations(){
      return 100;
    }
    @Override public OdeSystem getOdeSystem(){
      return odeSystem;
    }
    public OrthogonalSpace getSpace(){
      if (space == null) {
        float[] minBounds=new float[getDimension()];
        for (int dim=0; dim < getDimension(); dim++) {
          minBounds[dim]=0;
        }
        float[] maxBounds=new float[getDimension()];
        for (int dim=0; dim < getDimension(); dim++) {
          maxBounds[dim]=(dim + 1) * 10000;
        }
        space=new OrthogonalSpace(new ArrayPoint(0,minBounds),new ArrayPoint((float)100,maxBounds));
      }
      return space;
    }
    @Override public float[] getSteps(){
      if (steps == null) {
        steps=new float[getDimension()];
        for (int dim=0; dim < getDimension(); dim++) {
          steps[dim]=1;
        }
      }
      return steps;
    }
    @Override public float getTimeStep(){
      return (float)0.01;
    }
    public PrecisionConfiguration getPrecisionConfiguration(){
      return precisionConfiguration;
    }
  }
;
}",0.98472553699284
180355,"public VerificationResult merge(VerificationResult toMerge){
  if (toMerge == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Robustness[] newRobustnesses=new Robustness[size() + toMerge.size()];
  Point[] newPoints=new Point[size() + size()];
  for (int i=0; i < size(); i++) {
    newPoints[i]=getPoint(i);
    newRobustnesses[i]=getRobustness(i);
  }
  for (int i=0; i < toMerge.size(); i++) {
    newPoints[size() + i]=toMerge.getPoint(i);
    newRobustnesses[size() + i]=toMerge.getRobustness(i);
  }
  return new ArrayVerificationResult(size() + size(),newPoints,newRobustnesses);
}","public VerificationResult merge(VerificationResult toMerge){
  if (toMerge == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Robustness[] newRobustnesses=new Robustness[size() + toMerge.size()];
  Point[] newPoints=new Point[size() + toMerge.size()];
  for (int i=0; i < size(); i++) {
    newPoints[i]=getPoint(i);
    newRobustnesses[i]=getRobustness(i);
  }
  for (int i=0; i < toMerge.size(); i++) {
    newPoints[size() + i]=toMerge.getPoint(i);
    newRobustnesses[size() + i]=toMerge.getRobustness(i);
  }
  return new ArrayVerificationResult(size() + toMerge.size(),newPoints,newRobustnesses);
}",0.9871175523349436
180356,"public VerificationResult merge(VerificationResult toMerge){
  if (toMerge == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Robustness[] newRobustnesses=new Robustness[size() + toMerge.size()];
  Point[] newPoints=new Point[size() + size()];
  System.arraycopy(points,0,newPoints,0,points.length);
  System.arraycopy(robustness,0,newRobustnesses,0,robustness.length);
  for (int i=0; i < toMerge.size(); i++) {
    newPoints[size() + i]=toMerge.getPoint(i);
    newRobustnesses[size() + i]=toMerge.getRobustness(i);
  }
  return new ArrayVerificationResult(size() + size(),newPoints,newRobustnesses);
}","public VerificationResult merge(VerificationResult toMerge){
  if (toMerge == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Robustness[] newRobustnesses=new Robustness[size() + toMerge.size()];
  Point[] newPoints=new Point[size() + toMerge.size()];
  System.arraycopy(points,0,newPoints,0,points.length);
  System.arraycopy(robustness,0,newRobustnesses,0,robustness.length);
  for (int i=0; i < toMerge.size(); i++) {
    newPoints[size() + i]=toMerge.getPoint(i);
    newRobustnesses[size() + i]=toMerge.getRobustness(i);
  }
  return new ArrayVerificationResult(size() + toMerge.size(),newPoints,newRobustnesses);
}",0.9874411302982732
180357,"public VerificationResult compute(){
  SpawnedDataBlock spawned=spawner.spawn(initialSpace,initialSampling);
  VerificationResult result=null;
  while (spawned.size() != 0) {
    LOGGER.debug(""String_Node_Str"" + spawned.size());
    LOGGER.debug(""String_Node_Str"" + spawned.getSecondaryTrajectories().size());
    SimulatedDataBlock simulated=simulator.simulate(simulationConfiguration,spawned);
    SimulatedDataBlock simulatedSecondary=simulator.simulate(simulationConfiguration,spawned.getSecondaryTrajectories());
    LOGGER.debug(""String_Node_Str"" + simulated.size());
    LOGGER.debug(""String_Node_Str"" + simulatedSecondary.size());
    for (int i=0; i < spawned.getSecondaryTrajectories().size(); i++) {
      LinkedTrajectory.createAndUpdateReference(spawned.getSecondaryTrajectories().getTrajectory(i)).append(simulatedSecondary.getTrajectory(i));
    }
    for (int i=0; i < spawned.size(); i++) {
      LinkedTrajectory.createAndUpdateReference(spawned.getTrajectory(i)).append(simulated.getTrajectory(i));
    }
    VerifiedDataBlock verified=verifier.verify(simulated,property);
    if (result == null) {
      result=new VerifiedDataBlockResultAdapter(verified);
    }
 else {
      result=result.merge(new VerifiedDataBlockResultAdapter(verified));
    }
    DistanceCheckedDataBlock distanceChecked=distanceChecker.check(spawned.getConfiguration(),verified);
    spawned=spawner.spawn(spawned.getConfiguration(),distanceChecked);
    LOGGER.debug(""String_Node_Str"");
  }
  return result;
}","public VerificationResult compute(){
  SpawnedDataBlock spawned=spawner.spawn(initialSpace,initialSampling);
  VerificationResult result=null;
  int iteration=0;
  while (spawned.size() != 0 && iteration < ITERATIONS) {
    LOGGER.debug(""String_Node_Str"" + spawned.size());
    LOGGER.debug(""String_Node_Str"" + spawned.getSecondaryTrajectories().size());
    SimulatedDataBlock simulated=simulator.simulate(simulationConfiguration,spawned);
    for (int i=0; i < spawned.size(); i++) {
      LinkedTrajectory.createAndUpdateReference(spawned.getTrajectory(i)).append(simulated.getTrajectory(i));
    }
    LOGGER.debug(""String_Node_Str"" + simulated.size());
    if (spawned.getSecondaryTrajectories().size() > 0) {
      SimulatedDataBlock simulatedSecondary=simulator.simulate(simulationConfiguration,spawned.getSecondaryTrajectories());
      LOGGER.debug(""String_Node_Str"" + simulatedSecondary.size());
      for (int i=0; i < spawned.getSecondaryTrajectories().size(); i++) {
        LinkedTrajectory.createAndUpdateReference(spawned.getSecondaryTrajectories().getTrajectory(i)).append(simulatedSecondary.getTrajectory(i));
      }
    }
    VerifiedDataBlock verified=verifier.verify(simulated,property);
    if (result == null) {
      result=new VerifiedDataBlockResultAdapter(verified);
    }
 else {
      result=result.merge(new VerifiedDataBlockResultAdapter(verified));
    }
    DistanceCheckedDataBlock distanceChecked=distanceChecker.check(spawned.getConfiguration(),verified);
    spawned=spawner.spawn(spawned.getConfiguration(),distanceChecked);
    LOGGER.debug(""String_Node_Str"" + spawned.size());
    LOGGER.debug(""String_Node_Str"" + spawned.size());
    LOGGER.debug(""String_Node_Str"" + iteration);
    iteration++;
  }
  if (LOGGER.isDebugEnabled()) {
    for (int i=0; i < result.size(); i++) {
      LOGGER.debug(""String_Node_Str"" + result.getPoint(i) + ""String_Node_Str""+ result.getRobustness(i).getValue());
    }
  }
  return result;
}",0.7076124567474048
180358,"@Override public float getValue(Point p){
  float leftSide=getLeftSideValue(p);
  float diff=Math.abs(leftSide - constant);
  if (isValid(leftSide,constant)) {
    diff=-diff;
  }
  return diff;
}","@Override public float getValue(Point p){
  float leftSide=getLeftSideValue(p);
  float diff=Math.abs(leftSide - constant);
  if (!isValid(leftSide,constant)) {
    diff=-diff;
  }
  return diff;
}",0.9974554707379136
180359,"public <T>T get(Class<T> type,Class<? extends Annotation> qualifier){
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Map<Class<? extends Annotation>,Object> qualifiedInstances=instances.get(type);
  if (qualifiedInstances == null) {
    return null;
  }
  if (qualifier.equals(Any.class)) {
    if (qualifiedInstances.size() > 1) {
      throw new AmbigousException(""String_Node_Str"" + type.getName() + ""String_Node_Str"");
    }
    for (    Object o : qualifiedInstances.values()) {
      return type.cast(o);
    }
  }
 else {
    Class<? extends Annotation> toFind=qualifier;
    while (!toFind.equals(Empty.class)) {
      if (Proxy.isProxyClass(toFind)) {
        toFind=(Class<? extends Annotation>)toFind.getInterfaces()[0];
      }
      Qualifier qualified=toFind.getAnnotation(Qualifier.class);
      if (qualified == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + toFind.getName() + ""String_Node_Str""+ Qualifier.class.getName()+ ""String_Node_Str""+ Arrays.toString(toFind.getAnnotations()));
      }
      Object o=qualifiedInstances.get(toFind);
      if (o != null) {
        return type.cast(o);
      }
 else {
        toFind=qualified.parent();
      }
    }
  }
  return type.cast(instances.get(type));
}","public <T>T get(Class<T> type,Class<? extends Annotation> qualifier){
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Map<Class<? extends Annotation>,Object> qualifiedInstances=instances.get(type);
  if (qualifiedInstances == null) {
    return null;
  }
  if (qualifier.equals(Any.class)) {
    if (qualifiedInstances.size() > 1) {
      throw new AmbigousException(""String_Node_Str"" + type.getName() + ""String_Node_Str"");
    }
    for (    Object o : qualifiedInstances.values()) {
      return type.cast(o);
    }
  }
 else {
    Class<? extends Annotation> toFind=qualifier;
    while (!toFind.equals(Empty.class)) {
      if (Proxy.isProxyClass(toFind)) {
        toFind=(Class<? extends Annotation>)toFind.getInterfaces()[0];
      }
      Qualifier qualified=toFind.getAnnotation(Qualifier.class);
      if (qualified == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + toFind.getName() + ""String_Node_Str""+ Qualifier.class.getName()+ ""String_Node_Str""+ Arrays.toString(toFind.getAnnotations()));
      }
      Object o=qualifiedInstances.get(toFind);
      if (o != null) {
        return type.cast(o);
      }
 else {
        toFind=qualified.parent();
      }
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"" + type.getName() + ""String_Node_Str""+ (Proxy.isProxyClass(qualifier) ? qualifier.getInterfaces()[0].getSimpleName() : qualifier.getSimpleName())+ ""String_Node_Str"");
}",0.913391557496361
180360,"public Object value(){
  Object[] params=new Object[getMethod().getParameterTypes().length];
  for (int i=0; i < params.length; i++) {
    params[i]=context.resolve(getMethod().getParameterTypes()[i],loadQualifier(getMethod().getParameterTypes()[i].getDeclaredAnnotations()));
    if (params[i] == null) {
      throw new InvocationException(""String_Node_Str"" + getMethod().getParameterTypes()[i].getName() + ""String_Node_Str"");
    }
  }
  try {
    if (!getMethod().isAccessible()) {
      getMethod().setAccessible(true);
    }
    return getMethod().invoke(getTarget(),params);
  }
 catch (  IllegalAccessException ex) {
    throw new InvocationException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new InvocationException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new InvocationException(ex);
  }
}","public Object value(){
  Object[] params=new Object[getMethod().getParameterTypes().length];
  for (int i=0; i < params.length; i++) {
    params[i]=context.resolve(getMethod().getParameterTypes()[i],loadQualifier(getMethod().getParameterAnnotations()[i]));
    if (params[i] == null) {
      throw new InvocationException(""String_Node_Str"" + getMethod().getParameterTypes()[i].getName() + ""String_Node_Str"");
    }
  }
  try {
    if (!getMethod().isAccessible()) {
      getMethod().setAccessible(true);
    }
    return getMethod().invoke(getTarget(),params);
  }
 catch (  IllegalAccessException ex) {
    throw new InvocationException(ex);
  }
catch (  IllegalArgumentException ex) {
    throw new InvocationException(ex);
  }
catch (  InvocationTargetException ex) {
    throw new InvocationException(ex);
  }
}",0.3750756200846944
180361,"public Monitor createMonitor(Trajectory trajectory,Formula property){
  if (trajectory.getLastPoint().getTime() < property.getTimeNeeded()) {
    throw new IllegalArgumentException(""String_Node_Str"" + property.getTimeNeeded() + ""String_Node_Str""+ trajectory.getLastPoint().getTime()+ ""String_Node_Str"");
  }
switch (property.getType()) {
case AND:
    return new AndMonitor(createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)));
case FUTURE:
  return new FutureMonitor(createMonitor(trajectory,property.getSubformula(0)),((FutureFormula)property).getInterval());
case GLOBALLY:
return new GloballyMonitor(createMonitor(trajectory,property.getSubformula(0)),((FutureFormula)property).getInterval());
case NOT:
return new NotMonitor(createMonitor(trajectory,property.getSubformula(0)));
case OR:
return new OrMonitor(createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)));
case PREDICATE:
return new PredicateMonitor(trajectory,(Predicate)property);
default :
throw new UnsupportedOperationException(""String_Node_Str"" + property.getType() + ""String_Node_Str"");
}
}","public Monitor createMonitor(Trajectory trajectory,Formula property){
  if (trajectory.getLastPoint().getTime() < property.getTimeNeeded()) {
    throw new IllegalArgumentException(""String_Node_Str"" + property.getTimeNeeded() + ""String_Node_Str""+ trajectory.getLastPoint().getTime()+ ""String_Node_Str"");
  }
switch (property.getType()) {
case AND:
    return new AndMonitor(createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)));
case FUTURE:
  return new FutureMonitor(createMonitor(trajectory,property.getSubformula(0)),((FutureFormula)property).getInterval());
case GLOBALLY:
return new GloballyMonitor(createMonitor(trajectory,property.getSubformula(0)),((GloballyFormula)property).getInterval());
case NOT:
return new NotMonitor(createMonitor(trajectory,property.getSubformula(0)));
case OR:
return new OrMonitor(createMonitor(trajectory,property.getSubformula(0)),createMonitor(trajectory,property.getSubformula(1)));
case PREDICATE:
return new PredicateMonitor(trajectory,(Predicate)property);
default :
throw new UnsupportedOperationException(""String_Node_Str"" + property.getType() + ""String_Node_Str"");
}
}",0.9939862542955328
180362,"public VerifiedDataBlock<Trajectory> verify(final DataBlock<Trajectory> trajectories,P property){
  final Robustness[] robustnesses=new Robustness[trajectories.size()];
  int counter=0;
  for (  Trajectory trajectory : trajectories) {
    robustnesses[counter]=monitorFactory.createMonitor(trajectory,property).getRobustness(0);
  }
  return new VerifiedDataBlock<Trajectory>(){
    public Robustness getRobustness(    int index){
      return robustnesses[index];
    }
    public Trajectory getTrajectory(    int index){
      return trajectories.getTrajectory(index);
    }
    public int size(){
      return trajectories.size();
    }
    public Iterator<Trajectory> iterator(){
      return trajectories.iterator();
    }
  }
;
}","public VerifiedDataBlock<Trajectory> verify(final DataBlock<Trajectory> trajectories,P property){
  final Robustness[] robustnesses=new Robustness[trajectories.size()];
  int counter=0;
  for (  Trajectory trajectory : trajectories) {
    robustnesses[counter]=monitorFactory.createMonitor(trajectory,property).getRobustness(0);
    counter++;
  }
  return new VerifiedDataBlock<Trajectory>(){
    public Robustness getRobustness(    int index){
      return robustnesses[index];
    }
    public Trajectory getTrajectory(    int index){
      return trajectories.getTrajectory(index);
    }
    public int size(){
      return trajectories.size();
    }
    public Iterator<Trajectory> iterator(){
      return trajectories.iterator();
    }
  }
;
}",0.98989898989899
180363,"public int size(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","public int size(){
  return trajectory.getLength();
}",0.4148148148148148
180364,PointDistanceMetric getDistanceMetric();,"/** 
 * @return metric used to determine whether two trajectories has valid/invalid distance
 */
PointDistanceMetric getDistanceMetric();",0.4519774011299435
180365,"public SpawnedDataBlockWrapper(DataBlock<Trajectory> trajectories,TrajectoryNeighborhood<Trajectory> neighborhood,DataBlock<Trajectory> secondaryTrajectories){
  if (trajectories == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (neighborhood == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (secondaryTrajectories == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.trajectories=trajectories;
  this.neighborhood=neighborhood;
  this.secondaryTrajectories=secondaryTrajectories;
}","public SpawnedDataBlockWrapper(DataBlock<Trajectory> trajectories,Configuration configuration,DataBlock<Trajectory> secondaryTrajectories){
  if (trajectories == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (configuration == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (secondaryTrajectories == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.trajectories=trajectories;
  this.configuration=configuration;
  this.secondaryTrajectories=secondaryTrajectories;
}",0.8652988403211418
180366,"/** 
 * Creates new trajectories in the given space. Number of trajectories is defined through the numOfSamples parameter.
 * @param configuration
 * @param space
 * @param numOfSamples
 */
SpawnedDataBlock spawn(OrthogonalSpace space,InitialSampling initialSampling);","/** 
 * Creates new trajectories in the given space.
 */
SpawnedDataBlock spawn(OrthogonalSpace space,InitialSampling initialSampling,PointDistanceMetric distanceMetric);",0.6164383561643836
180367,"public <T>T resolve(Class<T> type,Class<? extends Annotation> qualifier,Context context){
  return context.resolve(type,qualifier);
}","public <T>T resolve(Class<T> type,Class<? extends Annotation> qualifier,Context context){
  Class<? extends Annotation> nonProxyQualifier=(Class<? extends Annotation>)(Proxy.isProxyClass(qualifier) ? qualifier.getInterfaces()[0] : qualifier);
  T result=context.resolve(type,nonProxyQualifier);
  printIfVerbose(""String_Node_Str"" + type + ""String_Node_Str""+ nonProxyQualifier.getSimpleName()+ ""String_Node_Str""+ (result == null ? null : result.getClass())+ ""String_Node_Str""+ context.getClass().getSimpleName()+ ""String_Node_Str"");
  return result;
}",0.3396778916544656
180368,"public void start(){
  fire(new ManagerStarted(),applicationContext);
}","public void start(){
  fire(new ManagerStarted(),applicationContext);
  descriptor=resolve(ParasimDescriptor.class,Default.class,getRootContext());
  printIfVerbose(""String_Node_Str"");
  if (isVerbose()) {
    for (    Extension extension : extensionsByContext.get(applicationContext)) {
      printIfVerbose(""String_Node_Str"" + extension + ""String_Node_Str"");
    }
  }
}",0.3205417607223476
180369,"public <T>void bind(final Class<T> type,Class<? extends Annotation> qualifier,Context context,T value){
  context.getStorage().add(type,qualifier,value);
  fire(value,context);
}","public <T>void bind(final Class<T> type,Class<? extends Annotation> qualifier,Context context,T value){
  Class<? extends Annotation> nonProxyQualifier=(Class<? extends Annotation>)(Proxy.isProxyClass(qualifier) ? qualifier.getInterfaces()[0] : qualifier);
  printIfVerbose(""String_Node_Str"" + type + ""String_Node_Str""+ nonProxyQualifier.getSimpleName()+ ""String_Node_Str""+ value.getClass().getName()+ ""String_Node_Str""+ context.getClass().getSimpleName()+ ""String_Node_Str"");
  context.getStorage().add(type,nonProxyQualifier,value);
  fire(value,context);
}",0.4803256445047489
180370,"public void fire(Object event,Context context){
  if (event == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!context.isActive()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  Extension extension : extensionsByContext.get(context)) {
    for (    ObserverMethod method : extension.getObservers()) {
      if (getType(method.getType()).isAssignableFrom(event.getClass())) {
        try {
          method.invoke(this,event);
        }
 catch (        Exception e) {
          LOGGER.warn(""String_Node_Str"",e);
        }
      }
    }
  }
}","public void fire(Object event,Context context){
  if (event == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (context == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!context.isActive()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  Extension extension : extensionsByContext.get(context)) {
    for (    ObserverMethod method : extension.getObservers()) {
      if (getType(method.getType()).isAssignableFrom(event.getClass())) {
        try {
          printIfVerbose(""String_Node_Str"" + event + ""String_Node_Str""+ extension+ ""String_Node_Str""+ method.getMethod().getName()+ ""String_Node_Str"");
          method.invoke(this,event);
        }
 catch (        Exception e) {
          LOGGER.warn(""String_Node_Str"",e);
        }
      }
    }
  }
}",0.900131406044678
180371,"public void initializeContext(Context context){
  try {
    context.activate();
    if (!extensionsByContext.containsKey(context)) {
      extensionsByContext.put(context,new ArrayList<Extension>());
    }
    extensionsByContext.get(context).addAll(createExtensions(extensionsByScope.get(context.getScope()),context));
    if (!(context instanceof ApplicationContext)) {
      fire(Before.of(context),applicationContext);
    }
    for (    Extension extension : extensionsByContext.get(context)) {
      for (      ProvidingPoint providingPoint : extension.getProvidingPoints()) {
        ProviderImpl.bind(this,context,providingPoint,getType(providingPoint.getType()),providingPoint.getQualifier());
      }
    }
    fire(Before.of(context),context);
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}","public void initializeContext(Context context){
  try {
    context.activate();
    if (!extensionsByContext.containsKey(context)) {
      extensionsByContext.put(context,Collections.synchronizedList(new ArrayList<Extension>()));
    }
    extensionsByContext.get(context).addAll(createExtensions(extensionsByScope.get(context.getScope()),context));
    if (!(context instanceof ApplicationContext)) {
      fire(Before.of(context),applicationContext);
    }
    for (    Extension extension : extensionsByContext.get(context)) {
      for (      ProvidingPoint providingPoint : extension.getProvidingPoints()) {
        ProviderImpl.bind(this,context,providingPoint,getType(providingPoint.getType()),providingPoint.getQualifier());
      }
    }
    fire(Before.of(context),context);
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}",0.9825986078886312
180372,"public <T>T resolve(Class<T> type,Class<? extends Annotation> qualifier){
  if (this.isActive()) {
    T value=this.getStorage().get(type,qualifier);
    if (value != null) {
      return value;
    }
  }
  if (this.hasParent()) {
    return this.getParent().resolve(type,qualifier);
  }
  return null;
}","public <T>T resolve(Class<T> type,Class<? extends Annotation> qualifier){
  Validate.notNull(type);
  Validate.notNull(qualifier);
  if (this.isActive()) {
    T value=this.getStorage().get(type,qualifier);
    if (value != null) {
      return value;
    }
  }
  if (this.hasParent()) {
    return this.getParent().resolve(type,qualifier);
  }
  return null;
}",0.9142857142857144
180373,"public static ParasimDescriptor fromXMLFile(String propertyName,String defaultPath) throws IOException, SAXException {
  File configFile=loadFileDescriptor(propertyName,defaultPath);
  Document dom=getBuilder().parse(configFile);
  NodeList extensions=dom.getElementsByTagName(""String_Node_Str"");
  ParasimDescriptorImpl descriptor=new ParasimDescriptorImpl();
  for (int i=0; i < extensions.getLength(); i++) {
    String qualifier=extensions.item(i).getAttributes().getNamedItem(""String_Node_Str"").getTextContent();
    if (qualifier == null) {
      throw new IOException(""String_Node_Str"");
    }
    ExtensionDescriptor extensionDescriptor=new ExtensionDescriptorImpl(qualifier);
    for (int j=0; j < extensions.item(i).getChildNodes().getLength(); j++) {
      Node property=extensions.item(i).getChildNodes().item(j);
      if (!property.getNodeName().equals(""String_Node_Str"")) {
        continue;
      }
      String name=property.getAttributes().getNamedItem(""String_Node_Str"").getTextContent();
      if (name == null) {
        throw new IOException(""String_Node_Str"" + qualifier + ""String_Node_Str"");
      }
      if (isArray(property)) {
        List<String> values=new ArrayList<String>();
        for (int k=0; k < property.getChildNodes().getLength(); k++) {
          Node value=property.getChildNodes().item(k);
          if (!value.getNodeName().equals(""String_Node_Str"")) {
            continue;
          }
          values.add(value.getTextContent());
        }
        String[] valuesInArray=new String[values.size()];
        values.toArray(valuesInArray);
        extensionDescriptor.setProperty(name,valuesInArray);
      }
 else {
        String value=property.getTextContent();
        extensionDescriptor.setProperty(name,value);
      }
    }
    descriptor.extensions.put(qualifier,extensionDescriptor);
  }
  return descriptor;
}","public static ParasimDescriptor fromXMLFile(String propertyName,String defaultPath) throws IOException, SAXException {
  File configFile=loadFileDescriptor(propertyName,defaultPath);
  Document dom=getBuilder().parse(configFile);
  NodeList extensions=dom.getElementsByTagName(""String_Node_Str"");
  ParasimDescriptorImpl descriptor=new ParasimDescriptorImpl();
  for (int i=0; i < extensions.getLength(); i++) {
    String qualifier=extensions.item(i).getAttributes().getNamedItem(""String_Node_Str"").getTextContent();
    if (qualifier == null) {
      throw new IOException(""String_Node_Str"");
    }
    ExtensionDescriptor extensionDescriptor=new ExtensionDescriptorImpl(qualifier);
    for (int j=0; j < extensions.item(i).getChildNodes().getLength(); j++) {
      Node property=extensions.item(i).getChildNodes().item(j);
      if (!property.getNodeName().equals(""String_Node_Str"")) {
        continue;
      }
      String name=property.getAttributes().getNamedItem(""String_Node_Str"").getTextContent();
      if (name == null) {
        throw new IOException(""String_Node_Str"" + qualifier + ""String_Node_Str"");
      }
      if (isArray(property)) {
        List<String> values=new ArrayList<String>();
        for (int k=0; k < property.getChildNodes().getLength(); k++) {
          Node value=property.getChildNodes().item(k);
          if (!value.getNodeName().equals(""String_Node_Str"")) {
            continue;
          }
          values.add(value.getTextContent());
        }
        String[] valuesInArray=new String[values.size()];
        values.toArray(valuesInArray);
        extensionDescriptor.setProperty(name,valuesInArray);
      }
 else {
        String value=property.getTextContent().trim();
        extensionDescriptor.setProperty(name,value);
      }
    }
    descriptor.extensions.put(qualifier,extensionDescriptor);
  }
  return descriptor;
}",0.998126839710998
180374,"public void finalizeContext(Context context){
  if (context.hasParent()) {
    fire(After.of(context),context.getParent());
  }
  fire(After.of(context),context);
  context.destroy();
  extensionsByContext.get(context).clear();
  extensionsByContext.remove(context);
}","private void finalizeContext(Context context,boolean remove){
  if (context.hasParent()) {
    fire(After.of(context),context.getParent());
  }
  fire(After.of(context),context);
  context.destroy();
  extensionsByContext.get(context).clear();
  if (remove) {
    extensionsByContext.remove(context);
  }
}",0.794425087108014
180375,"public void shutdown(){
  try {
    fire(new ManagerStopping(),applicationContext);
  }
  finally {
    for (    Context context : extensionsByContext.keySet()) {
      if (context instanceof ApplicationContext) {
        continue;
      }
      finalizeContext(context);
    }
    finalizeContext(applicationContext);
    extensionsByContext.clear();
    extensionsByScope.clear();
  }
}","public void shutdown(){
  try {
    fire(new ManagerStopping(),applicationContext);
  }
  finally {
    for (    Context context : extensionsByContext.keySet()) {
      if (context instanceof ApplicationContext) {
        continue;
      }
      finalizeContext(context,false);
    }
    finalizeContext(applicationContext);
    extensionsByContext.clear();
    extensionsByScope.clear();
  }
}",0.9923273657289002
180376,"/** 
 * Returns distance between two given points. The method should hold that distance(A, B) == distance(B, A) and distance(A, A) = 0.
 * @param first
 * @param second
 * @return distance between two given points
 */
@Override Distance distance(Point first,Point second);","/** 
 * Returns distance between two given points. The method should hold that distance(A, B) == distance(B, A) and distance(A, A) = 0.
 * @param first
 * @param second
 * @return distance between two given points
 */
@Override LimitedDistance distance(Point first,Point second);",0.9872958257713248
180377,"public Distance distance(Point first,Point second){
  return distance(first.toArray(),second.toArray());
}","public LimitedDistance distance(Point first,Point second){
  return distance(first.toArray(),second.toArray());
}",0.9680365296803652
180378,"protected Configuration<Trajectory> createConfiguration(final float expectedDistance,final int dimension,final TrajectoryNeighborhood<Trajectory> neighborhood){
  return new Configuration<Trajectory>(){
    private float[] distance;
    private float[] getMaxAbsoluteDistance(){
      if (distance == null) {
        distance=new float[dimension];
        for (int dim=0; dim < dimension; dim++) {
          distance[dim]=expectedDistance;
        }
      }
      return distance;
    }
    @Override public TrajectoryNeighborhood<Trajectory> getNeighborhood(){
      return neighborhood;
    }
    public PointDistanceMetric getDistanceMetric(){
      return new PointDistanceMetric(){
        public Distance distance(        float[] first,        float[] second){
          final float[] distance=new float[first.length];
          float maxDistance=0;
          for (int dim=0; dim < first.length; dim++) {
            distance[dim]=Math.abs(first[dim] - second[dim]) / getMaxAbsoluteDistance()[dim];
            if (distance[dim] > maxDistance) {
              maxDistance=distance[dim];
            }
          }
          final float maxDistanceFinal=maxDistance;
          return new LimitedDistance(){
            public boolean isValid(){
              return value() < expectedDistance;
            }
            public boolean isValid(            int dimensionIndex){
              return value(dimensionIndex) < expectedDistance;
            }
            public float value(){
              return maxDistanceFinal;
            }
            public float value(            int dimensionIndex){
              return distance[dimensionIndex];
            }
          }
;
        }
        public Distance distance(        Point first,        Point second){
          return distance(first.toArray(),second.toArray());
        }
      }
;
    }
    public int getStartIndex(    int index,    int neighborIndex){
      return 0;
    }
  }
;
}","protected Configuration<Trajectory> createConfiguration(final float expectedDistance,final int dimension,final TrajectoryNeighborhood<Trajectory> neighborhood){
  return new Configuration<Trajectory>(){
    private float[] distance;
    private float[] getMaxAbsoluteDistance(){
      if (distance == null) {
        distance=new float[dimension];
        for (int dim=0; dim < dimension; dim++) {
          distance[dim]=expectedDistance;
        }
      }
      return distance;
    }
    @Override public TrajectoryNeighborhood<Trajectory> getNeighborhood(){
      return neighborhood;
    }
    public PointDistanceMetric getDistanceMetric(){
      return new PointDistanceMetric(){
        public LimitedDistance distance(        float[] first,        float[] second){
          final float[] distance=new float[first.length];
          float maxDistance=0;
          for (int dim=0; dim < first.length; dim++) {
            distance[dim]=Math.abs(first[dim] - second[dim]) / getMaxAbsoluteDistance()[dim];
            if (distance[dim] > maxDistance) {
              maxDistance=distance[dim];
            }
          }
          final float maxDistanceFinal=maxDistance;
          return new LimitedDistance(){
            public boolean isValid(){
              return value() < expectedDistance;
            }
            public boolean isValid(            int dimensionIndex){
              return value(dimensionIndex) < expectedDistance;
            }
            public float value(){
              return maxDistanceFinal;
            }
            public float value(            int dimensionIndex){
              return distance[dimensionIndex];
            }
          }
;
        }
        public LimitedDistance distance(        Point first,        Point second){
          return distance(first.toArray(),second.toArray());
        }
      }
;
    }
    public int getStartIndex(    int index,    int neighborIndex){
      return 0;
    }
  }
;
}",0.9964267483409904
180379,"public PointDistanceMetric getDistanceMetric(){
  return new PointDistanceMetric(){
    public Distance distance(    float[] first,    float[] second){
      final float[] distance=new float[first.length];
      float maxDistance=0;
      for (int dim=0; dim < first.length; dim++) {
        distance[dim]=Math.abs(first[dim] - second[dim]) / getMaxAbsoluteDistance()[dim];
        if (distance[dim] > maxDistance) {
          maxDistance=distance[dim];
        }
      }
      final float maxDistanceFinal=maxDistance;
      return new LimitedDistance(){
        public boolean isValid(){
          return value() < expectedDistance;
        }
        public boolean isValid(        int dimensionIndex){
          return value(dimensionIndex) < expectedDistance;
        }
        public float value(){
          return maxDistanceFinal;
        }
        public float value(        int dimensionIndex){
          return distance[dimensionIndex];
        }
      }
;
    }
    public Distance distance(    Point first,    Point second){
      return distance(first.toArray(),second.toArray());
    }
  }
;
}","public PointDistanceMetric getDistanceMetric(){
  return new PointDistanceMetric(){
    public LimitedDistance distance(    float[] first,    float[] second){
      final float[] distance=new float[first.length];
      float maxDistance=0;
      for (int dim=0; dim < first.length; dim++) {
        distance[dim]=Math.abs(first[dim] - second[dim]) / getMaxAbsoluteDistance()[dim];
        if (distance[dim] > maxDistance) {
          maxDistance=distance[dim];
        }
      }
      final float maxDistanceFinal=maxDistance;
      return new LimitedDistance(){
        public boolean isValid(){
          return value() < expectedDistance;
        }
        public boolean isValid(        int dimensionIndex){
          return value(dimensionIndex) < expectedDistance;
        }
        public float value(){
          return maxDistanceFinal;
        }
        public float value(        int dimensionIndex){
          return distance[dimensionIndex];
        }
      }
;
    }
    public LimitedDistance distance(    Point first,    Point second){
      return distance(first.toArray(),second.toArray());
    }
  }
;
}",0.9937219730941704
180380,"private OrthogonalSpace createOrthogonalSpace(float base,int dimension){
  float[] minBounds=new float[dimension];
  float[] maxBounds=new float[dimension];
  for (int dim=0; dim < dimension; dim++) {
    minBounds[dim]=0;
    maxBounds[dim]=(float)((dim + 1) * base);
  }
  return new OrthogonalSpace(new ArrayPoint(0,minBounds),new ArrayPoint(100,maxBounds));
}","protected OrthogonalSpace createOrthogonalSpace(float base,int dimension){
  float[] minBounds=new float[dimension];
  float[] maxBounds=new float[dimension];
  for (int dim=0; dim < dimension; dim++) {
    minBounds[dim]=0;
    maxBounds[dim]=(float)((dim + 1) * base);
  }
  return new OrthogonalSpace(new ArrayPoint(0,minBounds),new ArrayPoint(100,maxBounds));
}",0.9835164835164836
180381,"private SpawnedDataBlock<Trajectory> initialSpawn(OrthogonalSpace space,int numSpawn){
  TrajectorySpawner spawner=createTrajectorySpawner();
  int[] toSpawn=new int[space.getDimension()];
  for (int dim=0; dim < space.getDimension(); dim++) {
    toSpawn[dim]=numSpawn;
  }
  return spawner.spawn(space,toSpawn);
}","protected SpawnedDataBlock<Trajectory> initialSpawn(OrthogonalSpace space,int numSpawn){
  TrajectorySpawner spawner=createTrajectorySpawner();
  int[] toSpawn=new int[space.getDimension()];
  for (int dim=0; dim < space.getDimension(); dim++) {
    toSpawn[dim]=numSpawn;
  }
  return spawner.spawn(space,toSpawn);
}",0.981012658227848
180382,"@Override public void executeVoidMethod(Object o,Method method){
  Object[] paramValues=new Object[method.getParameterTypes().length];
  for (int i=0; i < method.getTypeParameters().length; i++) {
    if (!isServiceAvailable(method.getParameterTypes()[i])) {
      throw new IllegalStateException(""String_Node_Str"" + method.getParameterTypes()[i].getCanonicalName() + ""String_Node_Str""+ o.getClass().getCanonicalName()+ ""String_Node_Str"");
    }
    paramValues[i]=getService(method.getParameterTypes()[i]);
  }
  try {
    method.setAccessible(true);
    method.invoke(o,paramValues);
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}","@Override public void executeVoidMethod(Object o,Method method){
  Object[] paramValues=new Object[method.getParameterTypes().length];
  for (int i=0; i < method.getParameterTypes().length; i++) {
    if (!isServiceAvailable(method.getParameterTypes()[i])) {
      throw new IllegalStateException(""String_Node_Str"" + method.getParameterTypes()[i].getCanonicalName() + ""String_Node_Str""+ o.getClass().getCanonicalName()+ ""String_Node_Str"");
    }
    paramValues[i]=getService(method.getParameterTypes()[i]);
  }
  try {
    method.setAccessible(true);
    method.invoke(o,paramValues);
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}",0.986725663716814
180383,"@BeforeMethod public void beforeMethod(){
  factory=new MapCDIFactory();
  factory.addService(List.class,ArrayList.class);
  factory.addService(Set.class,new HashSet<Object>(Arrays.asList(new Object[]{new Object()})));
  factory.addService(Object.class,Object.class);
  factory.addService(null,null);
  o1=new TestedObject();
  o2=new TestedObject();
}","@BeforeMethod public void beforeMethod(){
  factory=new MapServiceFactory();
  factory.addService(List.class,ArrayList.class);
  factory.addService(Set.class,new HashSet<Object>(Arrays.asList(new Object[]{new Object()})));
  factory.addService(Object.class,Object.class);
  factory.addService(null,null);
  o1=new TestedObject();
  o2=new TestedObject();
}",0.9858757062146892
180384,"@Override public void setup(){
  super.setup();
  trajectories=new MutableDataBlock(new LotkaVolteraInitialDataBlock());
  simulator=new Rkf45Simulator();
  trajectories.append(simulator.simulate(new LotkaVolteraAdaptiveStepConfiguration(),trajectories));
  visualizer=new DataBlockVisualizer2D(trajectories,this,0,1,20,13);
}","@Override public void setup(){
  super.setup();
  trajectories=new ListMutableDataBlock(new LotkaVolteraInitialDataBlock());
  simulator=new Rkf45Simulator();
  trajectories.append(simulator.simulate(new LotkaVolteraAdaptiveStepConfiguration(),trajectories));
  visualizer=new DataBlockVisualizer2D(trajectories,this,0,1,20,13);
}",0.9939024390243902
180385,"private Point successor(Rkf45Computation computation,final Point point){
  float[] successorData=new float[point.getDimension()];
  float[] auxiliaryData=new float[point.getDimension()];
  float[] absoluteError=new float[point.getDimension()];
  float[] previousData=point.toArray();
  for (; computation.iteration < computation.configuration.getMaxNumberOfIterations(); computation.iteration++) {
    prepareCoefficents(computation,previousData);
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      absoluteError[dim]=Math.abs(R1 * computation.k1[dim] + R3 * computation.k3[dim] + R4 * computation.k4[dim] + R5 * computation.k5[dim] + R6 * computation.k6[dim]);
      if (computation.configuration.getMaxAbsoluteError()[dim] != 0 && absoluteError[dim] > computation.configuration.getMaxAbsoluteError()[dim]) {
        computation.timeStep/=2;
        if (computation.timeStep < MINIMAL_TIME_STEP) {
          computation.status=Status.PRECISION;
          return null;
        }
        continue;
      }
    }
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      successorData[dim]=previousData[dim] + N1 * computation.k1[dim] + N3 * computation.k3[dim] + N4 * computation.k4[dim] + N5 * computation.k5[dim];
    }
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      if (computation.configuration.getMaxRelativeError() != 0 && Math.abs(absoluteError[dim] / successorData[dim]) > computation.configuration.getMaxRelativeError()) {
        computation.timeStep/=2;
        if (computation.timeStep < MINIMAL_TIME_STEP) {
          computation.status=Status.PRECISION;
          return null;
        }
        continue;
      }
    }
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      if (Math.abs(successorData[dim] - previousData[dim]) > computation.configuration.getSteps()[dim]) {
        computation.timeStep/=2;
        if (computation.timeStep < MINIMAL_TIME_STEP) {
          computation.status=Status.PRECISION;
          return null;
        }
        continue;
      }
    }
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      if (successorData[dim] > computation.configuration.getMaxBounds()[dim] || successorData[dim] < computation.configuration.getMinBounds()[dim]) {
        computation.status=Status.BOUNDS;
        return null;
      }
    }
    return new ArrayPoint(successorData,point.getTime() + computation.timeStep);
  }
  return null;
}","private Point successor(Rkf45Computation computation,final Point point){
  float[] successorData=new float[point.getDimension()];
  float[] auxiliaryData=new float[point.getDimension()];
  float[] absoluteError=new float[point.getDimension()];
  float[] previousData=point.toArray();
  simulation:   for (; computation.iteration < computation.configuration.getMaxNumberOfIterations(); computation.iteration++) {
    prepareCoefficents(computation,previousData);
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      absoluteError[dim]=Math.abs(R1 * computation.k1[dim] + R3 * computation.k3[dim] + R4 * computation.k4[dim] + R5 * computation.k5[dim] + R6 * computation.k6[dim]);
      if (computation.configuration.getMaxAbsoluteError()[dim] != 0 && absoluteError[dim] > computation.configuration.getMaxAbsoluteError()[dim]) {
        computation.timeStep/=2;
        if (computation.timeStep < MINIMAL_TIME_STEP) {
          computation.status=Status.PRECISION;
          return null;
        }
        continue simulation;
      }
    }
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      successorData[dim]=previousData[dim] + N1 * computation.k1[dim] + N3 * computation.k3[dim] + N4 * computation.k4[dim] + N5 * computation.k5[dim];
    }
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      if (computation.configuration.getMaxRelativeError() != 0 && Math.abs(absoluteError[dim] / successorData[dim]) > computation.configuration.getMaxRelativeError()) {
        computation.timeStep/=2;
        if (computation.timeStep < MINIMAL_TIME_STEP) {
          computation.status=Status.PRECISION;
          return null;
        }
        continue simulation;
      }
    }
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      if (Math.abs(successorData[dim] - previousData[dim]) > computation.configuration.getSteps()[dim]) {
        System.out.println(""String_Node_Str"" + dim + ""String_Node_Str""+ computation.configuration.getSteps()[dim]+ ""String_Node_Str""+ Math.abs(successorData[dim] - previousData[dim])+ ""String_Node_Str""+ Arrays.toString(previousData)+ ""String_Node_Str""+ Arrays.toString(successorData));
        computation.timeStep/=2;
        if (computation.timeStep < MINIMAL_TIME_STEP) {
          computation.status=Status.PRECISION;
          return null;
        }
        continue simulation;
      }
    }
    for (int dim=0; dim < computation.configuration.getDimension(); dim++) {
      if (successorData[dim] > computation.configuration.getMaxBounds()[dim] || successorData[dim] < computation.configuration.getMinBounds()[dim]) {
        computation.status=Status.BOUNDS;
        return null;
      }
    }
    return new ArrayPoint(successorData,point.getTime() + computation.timeStep);
  }
  return null;
}",0.9378847229994404
180386,"private ArrayDataBlock<Trajectory> createDataBlock(int dim,int size){
  Trajectory[] trajectories=new Trajectory[size];
  for (int s=0; s < size; s++) {
    float[] data=new float[dim];
    for (int d=0; d < dim; d++) {
      data[d]=s * size + d;
    }
    trajectories[s]=new ArrayTrajectory(data,new float[]{(float)0},dim);
  }
  return new ArrayDataBlock<Trajectory>(trajectories);
}","protected DataBlock<Trajectory> createDataBlock(int dim,int size){
  Trajectory[] trajectories=new Trajectory[size];
  for (int s=0; s < size; s++) {
    float[] data=new float[dim];
    for (int d=0; d < dim; d++) {
      data[d]=s * size + d;
    }
    trajectories[s]=new ArrayTrajectory(data,new float[]{(float)0},dim);
  }
  return new ArrayDataBlock<Trajectory>(trajectories);
}",0.9753566796368353
180387,"private OdeSystem createOdeSystem(final int dim){
  int[] coefficientIndexes=new int[dim + 1];
  float[] coefficients=new float[dim];
  int[] factorIndexes=new int[dim + 1];
  int[] factors=new int[dim];
  for (int d=0; d < dim; d++) {
    coefficientIndexes[d]=d;
    coefficients[d]=(float)dim / (float)100;
    factorIndexes[d]=d;
    factors[d]=d;
  }
  coefficientIndexes[dim]=dim;
  factorIndexes[dim]=dim;
  return new DefaultOdeSystem(new ArrayOdeSystemEncoding(coefficientIndexes,coefficients,factorIndexes,factors));
}","private OdeSystem createOdeSystem(final int dim){
  int[] coefficientIndexes=new int[dim + 1];
  float[] coefficients=new float[dim];
  int[] factorIndexes=new int[dim + 1];
  int[] factors=new int[dim];
  for (int d=0; d < dim; d++) {
    coefficientIndexes[d]=d;
    coefficients[d]=(float)dim / (float)10;
    factorIndexes[d]=d;
    factors[d]=d;
  }
  coefficientIndexes[dim]=dim;
  factorIndexes[dim]=dim;
  return new DefaultOdeSystem(new ArrayOdeSystemEncoding(coefficientIndexes,coefficients,factorIndexes,factors));
}",0.9990521327014218
180388,"protected void testTimeStep(int size){
  SimulatedDataBlock<Trajectory> result=getSimulator().simulate(getConfiguration(),createDataBlock(getConfiguration().getDimension(),size));
  for (int s=0; s < size; s++) {
    Point previous=null;
    for (    Point p : result.getTrajectory(s)) {
      if (previous == null) {
        previous=p;
        continue;
      }
      assertEquals(p.getTime() - previous.getTime(),getConfiguration().getTimeStep(),getConfiguration().getTimeStep() / 1000,""String_Node_Str"");
      previous=p;
    }
  }
}","protected void testTimeStep(int size){
  SimulatedDataBlock<Trajectory> result=getSimulator().simulate(getConfiguration(),createDataBlock(getConfiguration().getDimension(),size));
  for (int s=0; s < size; s++) {
    Point previous=null;
    for (    Point p : result.getTrajectory(s)) {
      if (previous == null) {
        previous=p;
        continue;
      }
      assertTrue(Math.abs(p.getTime() - previous.getTime()) <= getConfiguration().getTimeStep() + getConfiguration().getTimeStep() / 1000,""String_Node_Str"" + Math.abs(p.getTime() - previous.getTime()) + ""String_Node_Str""+ getConfiguration().getTimeStep()+ ""String_Node_Str"");
      previous=p;
    }
  }
}",0.8666114333057167
180389,"public LotkaVolteraConfiguration(){
  super(new LotkaVolteraOdeSystem(),new OrthogonalSpace(new ArrayPoint(0,100,100),new ArrayPoint(100,0,0)));
}","public LotkaVolteraConfiguration(){
  super(new LotkaVolteraOdeSystem(),new OrthogonalSpace(new ArrayPoint(0,0,0),new ArrayPoint(100,100,100)));
}",0.9726027397260274
180390,"/** 
 * Returns position of point in array (position of the first dimension value) followed by other dimension values.
 * @param trajectoryIndex index of trajectory which the point belongs to
 * @param pointIndex point index
 * @return point index 
 */
int getPointPosition(int trajectoryIndex,int pointIndex);","/** 
 * Returns position of point in array (position of the first dimension value) followed by other dimension values.
 * @param pointIndex point index
 * @return point index 
 */
int getPointPosition(int pointIndex);",0.6375711574952562
180391,"/** 
 * Returns position of time value in array.
 * @param trajectoryIndex index of trajectory which the point belongs to
 * @param pointIndex index
 * @return time index
 */
int getTimePosition(int trajectoryIndex,int pointIndex);","/** 
 * Returns position of time value in array.
 * @param pointIndex index
 * @return time index
 */
int getTimePosition(int pointIndex);",0.7479674796747967
180392,"@Override public Point getPoint(int index){
  if (index < 0 || index >= getLength()) {
    throw new IllegalArgumentException(""String_Node_Str"" + (getLength() - 1) + ""String_Node_Str"");
  }
  return new ArrayPoint(points,times[pointLocator.getTimePosition(0,index)],pointLocator.getPointPosition(0,index),getDimension());
}","@Override public Point getPoint(int index){
  if (index < 0 || index >= getLength()) {
    throw new IllegalArgumentException(""String_Node_Str"" + (getLength() - 1) + ""String_Node_Str"");
  }
  return new ArrayPoint(points,times[pointLocator.getTimePosition(index)],pointLocator.getPointPosition(index),getDimension());
}",0.9750778816199376
180393,"public int getPointPosition(int trajectoryIndex,int pointIndex){
  return pointIndex * dimension;
}","public int getPointPosition(int pointIndex){
  return pointIndex * dimension;
}",0.8876404494382022
180394,"public int getTimePosition(int trajectoryIndex,int pointIndex){
  return pointIndex;
}","public int getTimePosition(int pointIndex){
  return pointIndex;
}",0.868421052631579
180395,"private void saveDataBlock(DataBlock<Trajectory> trajectories,int lengthLimit,boolean lengthLimitIsNeeded){
  if (trajectories == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int dimension=trajectories.getTrajectory(0).getLength();
  int length=lengthLimitIsNeeded ? lengthLimit : Math.min(getMaxDataBlockLength(trajectories),lengthLimit);
  if (!isInitialized() || trajectories.size() > hostLengths.length || trajectories.size() * length > hostTimes.length || trajectories.size() * length * dimension > hostPoints.length) {
    free();
    initialize(trajectories.size(),length,dimension);
  }
  int trajectoryIndex=0;
  int pointIndex;
  for (  Trajectory trajectory : trajectories) {
    if (dimension != trajectory.getDimension()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    hostLengths[trajectoryIndex]=trajectory.getLength();
    pointIndex=0;
    for (    Point point : trajectory) {
      if (pointIndex >= lengthLimit) {
        break;
      }
      for (int dim=0; dim < point.getDimension(); dim++) {
        System.arraycopy(point.toArray(),0,hostPoints,pointIndex * trajectories.size() * dimension + trajectoryIndex * dimension,point.getDimension());
        hostTimes[pointIndex * trajectories.size() + trajectoryIndex]=point.getTime();
      }
    }
    trajectoryIndex++;
  }
  Utils.checkErrorCode(JCuda.cudaMemcpy(devicePoints,Pointer.to(hostPoints),trajectories.size() * length * dimension* Sizeof.FLOAT,cudaMemcpyKind.cudaMemcpyHostToDevice));
  Utils.checkErrorCode(JCuda.cudaMemcpy(deviceTimes,Pointer.to(hostTimes),trajectories.size() * length * Sizeof.FLOAT,cudaMemcpyKind.cudaMemcpyHostToDevice));
  Utils.checkErrorCode(JCuda.cudaMemcpy(deviceLengths,Pointer.to(hostLengths),trajectories.size() * Sizeof.INT,cudaMemcpyKind.cudaMemcpyHostToDevice));
  savedDataBlock=trajectories;
}","private void saveDataBlock(DataBlock<Trajectory> trajectories,int lengthLimit,boolean lengthLimitIsNeeded){
  if (trajectories == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int dimension=trajectories.getTrajectory(0).getDimension();
  int length=lengthLimitIsNeeded ? lengthLimit : Math.min(getMaxDataBlockLength(trajectories),lengthLimit);
  if (!isInitialized() || trajectories.size() > hostLengths.length || trajectories.size() * length > hostTimes.length || trajectories.size() * length * dimension > hostPoints.length) {
    free();
    initialize(trajectories.size(),length,dimension);
  }
  int trajectoryIndex=0;
  int pointIndex;
  for (  Trajectory trajectory : trajectories) {
    if (dimension != trajectory.getDimension()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    hostLengths[trajectoryIndex]=trajectory.getLength();
    pointIndex=0;
    for (    Point point : trajectory) {
      if (pointIndex >= lengthLimit) {
        break;
      }
      System.out.println(""String_Node_Str"" + pointIndex + ""String_Node_Str""+ trajectoryIndex+ ""String_Node_Str""+ (pointIndex * trajectories.size() * dimension + trajectoryIndex * dimension));
      System.arraycopy(point.toArray(),0,hostPoints,pointIndex * trajectories.size() * dimension + trajectoryIndex * dimension,dimension);
      hostTimes[pointIndex * trajectories.size() + trajectoryIndex]=point.getTime();
      pointIndex++;
    }
    trajectoryIndex++;
  }
  Utils.checkErrorCode(JCuda.cudaMemcpy(devicePoints,Pointer.to(hostPoints),trajectories.size() * length * dimension* Sizeof.FLOAT,cudaMemcpyKind.cudaMemcpyHostToDevice));
  Utils.checkErrorCode(JCuda.cudaMemcpy(deviceTimes,Pointer.to(hostTimes),trajectories.size() * length * Sizeof.FLOAT,cudaMemcpyKind.cudaMemcpyHostToDevice));
  Utils.checkErrorCode(JCuda.cudaMemcpy(deviceLengths,Pointer.to(hostLengths),trajectories.size() * Sizeof.INT,cudaMemcpyKind.cudaMemcpyHostToDevice));
  savedDataBlock=trajectories;
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
}",0.9023586101952829
180396,"public void free(){
  if (!isInitialized()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  hostLengths=null;
  hostPoints=null;
  hostTimes=null;
  savedDataBlock=null;
  Utils.checkErrorCode(JCuda.cudaFree(deviceLengths));
  Utils.checkErrorCode(JCuda.cudaFree(devicePoints));
  Utils.checkErrorCode(JCuda.cudaFree(deviceTimes));
  initialized=false;
}","public void free(){
  if (!isInitialized()) {
    return;
  }
  hostLengths=null;
  hostPoints=null;
  hostTimes=null;
  savedDataBlock=null;
  Utils.checkErrorCode(JCuda.cudaFree(deviceLengths));
  Utils.checkErrorCode(JCuda.cudaFree(devicePoints));
  Utils.checkErrorCode(JCuda.cudaFree(deviceTimes));
  initialized=false;
}",0.9195402298850576
180397,"public DataBlock<Trajectory> loadDataBlock(){
  if (!isInitialized()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Utils.checkErrorCode(JCuda.cudaMemcpy(Pointer.to(hostLengths),deviceLengths,getSavedDataBlock().size() * Sizeof.INT,cudaMemcpyKind.cudaMemcpyDeviceToHost));
  int maxLength=0;
  for (int i=0; i < getSavedDataBlock().size(); i++) {
    if (hostLengths[i] > maxLength) {
      maxLength=hostLengths[i];
    }
  }
  int dimension=getSavedDataBlock().getTrajectory(0).getDimension();
  Utils.checkErrorCode(JCuda.cudaMemcpy(Pointer.to(hostPoints),devicePoints,getSavedDataBlock().size() * maxLength * Sizeof.FLOAT,cudaMemcpyKind.cudaMemcpyDeviceToHost));
  Utils.checkErrorCode(JCuda.cudaMemcpy(Pointer.to(hostTimes),deviceTimes,getSavedDataBlock().size() * maxLength * Sizeof.FLOAT,dimension));
  return dataBlockFactory.createDataBlock(hostPoints,hostTimes,hostLengths,dimension);
}","public DataBlock<Trajectory> loadDataBlock(){
  if (!isInitialized()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Utils.checkErrorCode(JCuda.cudaMemcpy(Pointer.to(hostLengths),deviceLengths,getSavedDataBlock().size() * Sizeof.INT,cudaMemcpyKind.cudaMemcpyDeviceToHost));
  int maxLength=0;
  for (int i=0; i < getSavedDataBlock().size(); i++) {
    if (hostLengths[i] > maxLength) {
      maxLength=hostLengths[i];
    }
  }
  int dimension=getSavedDataBlock().getTrajectory(0).getDimension();
  Utils.checkErrorCode(JCuda.cudaMemcpy(Pointer.to(hostPoints),devicePoints,getSavedDataBlock().size() * maxLength * getSavedDataBlock().getTrajectory(0).getDimension()* Sizeof.FLOAT,cudaMemcpyKind.cudaMemcpyDeviceToHost));
  Utils.checkErrorCode(JCuda.cudaMemcpy(Pointer.to(hostTimes),deviceTimes,getSavedDataBlock().size() * maxLength * Sizeof.FLOAT,cudaMemcpyKind.cudaMemcpyDeviceToHost));
  return dataBlockFactory.createDataBlock(hostPoints,hostTimes,hostLengths,dimension);
}",0.9481403876375064
180398,"public int getPointPosition(int trajectoryIndex,int pointIndex){
  return pointIndex * getSize() * dimension;
}","public int getPointPosition(int pointIndex){
  System.out.println(""String_Node_Str"" + pointIndex + ""String_Node_Str""+ trajectoryIndex+ ""String_Node_Str""+ (pointIndex * size() * dimension + trajectoryIndex * dimension));
  return pointIndex * size() * dimension + trajectoryIndex * dimension;
}",0.4455445544554455
180399,"public Trajectory getTrajectory(int index){
  if (index < 0 || index >= getSize()) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + 0 + ""String_Node_Str""+ (getSize() - 1)+ ""String_Node_Str"");
  }
  return new ArrayTrajectory(points,times,dimension,lengths[index],pointLocator);
}","public Trajectory getTrajectory(int index){
  if (index < 0 || index >= size()) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + 0 + ""String_Node_Str""+ (size() - 1)+ ""String_Node_Str"");
  }
  return new ArrayTrajectory(points,times,dimension,lengths[index],createPointLocator(index));
}",0.957698815566836
180400,"public int getTimePosition(int trajectoryIndex,int pointIndex){
  return pointIndex * getSize();
}","public int getTimePosition(int pointIndex){
  return pointIndex * size() + trajectoryIndex;
}",0.774869109947644
180401,"public WorkspaceDataBlock(float[] points,float[] times,int[] lengths,final int dimension){
  super(lengths.length);
  if (points == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (times == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (dimension <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.points=points;
  this.times=times;
  this.lengths=lengths;
  this.dimension=dimension;
  int maxLength=0;
  for (int i=0; i < lengths.length; i++) {
    if (lengths[i] > maxLength) {
      maxLength=lengths[i];
    }
  }
  pointLocator=new ArrayPointLocator(){
    public int getPointPosition(    int trajectoryIndex,    int pointIndex){
      return pointIndex * getSize() * dimension;
    }
    public int getTimePosition(    int trajectoryIndex,    int pointIndex){
      return pointIndex * getSize();
    }
  }
;
}","public WorkspaceDataBlock(float[] points,float[] times,int[] lengths,final int dimension){
  super(lengths.length);
  if (points == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (times == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (dimension <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.points=points;
  this.times=times;
  this.lengths=lengths;
  this.dimension=dimension;
}",0.6860888565185724
180402,"/** 
 * Appends the given trajectory on the end of this trajectory. After calling this method, the reference of the given trajectory will point to this trajectory.
 * @param trajectory the trajectory which will be appended
 */
public void append(Trajectory trajectory){
  if (trajectory == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (trajectory.getFirstPoint().getTime() < trajectories.get(trajectories.size()).getLastPoint().getTime()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  setLength(getLength() + trajectory.getLength());
  trajectories.add(trajectory);
  trajectory.getReference().setTrajectory(this);
}","/** 
 * Appends the given trajectory on the end of this trajectory. After calling this method, the reference of the given trajectory will point to this trajectory.
 * @param trajectory the trajectory which will be appended
 */
public void append(Trajectory trajectory){
  if (trajectory == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (trajectory.getFirstPoint().getTime() < trajectories.get(trajectories.size() - 1).getLastPoint().getTime()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  setLength(getLength() + trajectory.getLength());
  trajectories.add(trajectory);
  trajectory.getReference().setTrajectory(this);
}",0.9970149253731344
180403,"Out simulate(Conf configuration,DataBlock<Trajectory> trajectories);","Out simulate(Conf configuration,org.sybila.parasim.computation.DataBlock<Trajectory> trajectories);",0.8143712574850299
180404,"@Override public Point getPoint(int index){
  if (index <= 0 || index >= getLength()) {
    throw new IllegalArgumentException(""String_Node_Str"" + (getLength() - 1) + ""String_Node_Str"");
  }
  return new ArrayPoint(points,times[index],index * getDimension(),getDimension());
}","@Override public Point getPoint(int index){
  if (index < 0 || index >= getLength()) {
    throw new IllegalArgumentException(""String_Node_Str"" + (getLength() - 1) + ""String_Node_Str"");
  }
  return new ArrayPoint(points,times[index],index * getDimension(),getDimension());
}",0.998185117967332
180405,"/** 
 * Creates a new ListTrajectory with the given points.
 * @param points point sequence 
 */
public ListTrajectory(List<Point> points){
  super(points.get(0).getDimension(),points.size());
}","/** 
 * Creates a new ListTrajectory with the given points.
 * @param points point sequence 
 */
public ListTrajectory(List<Point> points){
  super(points.get(0).getDimension(),points.size());
  this.points=points;
}",0.946341463414634
180406,"private void writeAutoRelated(BufferedWriter writer,String category,String column,ZeroNullType dataZeroVsNulls) throws FishLinkException {
  String related=FishLinkConstants.autoRelatedCategory(category);
  if (related == null) {
    return;
  }
  String uri=categoryUris.get(related);
  if (uri == null) {
    return;
  }
  writeVocab(writer,related);
  writeUriOther(writer,uri,category,column,dataZeroVsNulls);
  try {
    writer.write(""String_Node_Str"");
    writer.newLine();
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
}","private void writeAutoRelated(BufferedWriter writer,String category,String column,ZeroNullType dataZeroVsNulls) throws FishLinkException {
  String related=FishLinkConstants.autoRelatedCategory(category);
  if (related == null) {
    return;
  }
  String uri=categoryUris.get(related);
  if (uri == null) {
    return;
  }
  writeVocab(writer,related);
  writeUriForOther(writer,related,column,dataZeroVsNulls);
  try {
    writer.write(""String_Node_Str"");
    writer.newLine();
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
}",0.9807692307692308
180407,"SheetWrite(NameChecker nameChecker,Sheet annotatedSheet,int sheetNumber,String url,String pid) throws FishLinkException {
  super(annotatedSheet);
  this.pid=pid;
  this.sheetNumber=sheetNumber;
  this.dataPath=url;
  this.masterNameChecker=nameChecker;
  idColumns=new HashMap<String,String>();
  categoryUris=new HashMap<String,String>();
  allColumns=new ArrayList<String>();
}","SheetWrite(NameChecker nameChecker,Sheet annotatedSheet,int sheetNumber,String url,String pid) throws FishLinkException {
  super(annotatedSheet);
  this.pid=pid;
  this.sheetNumber=sheetNumber;
  this.dataPath=url;
  this.masterNameChecker=nameChecker;
  idValueLinks=new HashMap<String,String>();
  categoryUris=new HashMap<String,String>();
  allColumns=new ArrayList<String>();
}",0.980340760157274
180408,"private boolean writeTemplateColumn(BufferedWriter writer,String column) throws FishLinkException {
  String category=getCellValue(column,categoryRow);
  String field=getCellValue(column,fieldRow);
  String idType=getCellValue(column,idTypeRow);
  String external=getExternal(column);
  if (category == null || category.toLowerCase().equals(""String_Node_Str"")) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  if (field == null) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  masterNameChecker.checkName(sheet.getSheetInfo(),category,field);
  if (field.equalsIgnoreCase(""String_Node_Str"") && !external.isEmpty()) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  if (idType != null && idType.equals(FishLinkConstants.ALL_LABEL)) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  ZeroNullType zeroNull=getZeroVsNull(column);
  writeUri(writer,category,field,idType,column,zeroNull);
  try {
    writer.write(""String_Node_Str"");
    writeType(writer,category);
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
  writeData(writer,category,column,zeroNull);
  writeAutoRelated(writer,category,column,zeroNull);
  writeAllRelated(writer,category,zeroNull);
  for (int row=firstConstant; row <= lastConstant; row++) {
    writeConstant(writer,category,column,row);
  }
  try {
    if (external.isEmpty()) {
      writeRdfType(writer,pid + ""String_Node_Str"" + sheet.getName()+ ""String_Node_Str""+ category);
    }
    writer.write(""String_Node_Str"");
    writer.newLine();
    writer.newLine();
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
  return true;
}","private boolean writeTemplateColumn(BufferedWriter writer,String column) throws FishLinkException {
  String category=getCellValue(column,categoryRow);
  String field=getCellValue(column,fieldRow);
  String idType=getCellValue(column,idTypeRow);
  String external=getExternal(column);
  if (category == null || category.toLowerCase().equals(""String_Node_Str"")) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  if (field == null) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  masterNameChecker.checkName(sheet.getSheetInfo(),category,field);
  if (field.equalsIgnoreCase(""String_Node_Str"") && !external.isEmpty()) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  if (idType != null && idType.equals(FishLinkConstants.ALL_LABEL)) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  ZeroNullType zeroNull=getZeroVsNull(column);
  writeUriForSubject(writer,category,field,idType,column,zeroNull);
  try {
    writer.write(""String_Node_Str"");
    writeType(writer,category);
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
  writeData(writer,category,column,zeroNull);
  writeAutoRelated(writer,category,column,zeroNull);
  writeAllRelated(writer,category,zeroNull);
  for (int row=firstConstant; row <= lastConstant; row++) {
    writeConstant(writer,category,column,row);
  }
  try {
    if (external.isEmpty()) {
      writeRdfType(writer,pid + ""String_Node_Str"" + sheet.getName()+ ""String_Node_Str""+ category);
    }
    writer.write(""String_Node_Str"");
    writer.newLine();
    writer.newLine();
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
  return true;
}",0.9972914409534128
180409,"private void findId(String category,String column) throws FishLinkException {
  String field=getCellValue(column,fieldRow);
  String id=idColumns.get(category);
  if (field.equalsIgnoreCase(""String_Node_Str"")) {
    if (id == null || id.equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(column + ""String_Node_Str"" + category+ ""String_Node_Str""+ column);
      idColumns.put(category,column);
      categoryUris.put(category,getUri(column,category));
    }
 else {
      throw new FishLinkException(""String_Node_Str"" + category);
    }
  }
 else {
    if (id == null) {
      System.out.println(column + ""String_Node_Str"" + category+ ""String_Node_Str"");
      idColumns.put(category,""String_Node_Str"");
    }
    if (categoryUris.get(category) == null) {
      categoryUris.put(category,getCatgerogyUri(category));
    }
  }
}","private void findId(String category,String column) throws FishLinkException {
  String field=getCellValue(column,fieldRow);
  String id=idValueLinks.get(category);
  if (field.equalsIgnoreCase(""String_Node_Str"")) {
    if (id == null || id.equalsIgnoreCase(""String_Node_Str"")) {
      System.out.println(column + ""String_Node_Str"" + category+ ""String_Node_Str""+ column);
      idValueLinks.put(category,column);
      categoryUris.put(category,getUri(column,category));
    }
 else {
      throw new FishLinkException(""String_Node_Str"" + category);
    }
  }
 else {
    if (id == null) {
      System.out.println(column + ""String_Node_Str"" + category+ ""String_Node_Str"");
      idValueLinks.put(category,""String_Node_Str"");
    }
    if (categoryUris.get(category) == null) {
      categoryUris.put(category,getCatgerogyUri(category));
    }
  }
}",0.973325429756965
180410,"private boolean writeTemplateColumn(BufferedWriter writer,String column) throws FishLinkException {
  String category=getCellValue(column,categoryRow);
  String field=getCellValue(column,fieldRow);
  String idType=getCellValue(column,idTypeRow);
  String external=getExternal(column);
  if (category == null || category.toLowerCase().equals(""String_Node_Str"")) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
  }
  if (field == null) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  masterNameChecker.checkName(sheet.getSheetInfo(),category,field);
  if (field.equalsIgnoreCase(""String_Node_Str"") && !external.isEmpty()) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  if (idType != null && idType.equals(FishLinkConstants.ALL_LABEL)) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  ZeroNullType zeroNull=getZeroVsNull(column);
  writeUri(writer,category,field,idType,column,zeroNull);
  try {
    writer.write(""String_Node_Str"");
    writeType(writer,category);
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
  writeData(writer,category,column,zeroNull);
  writeAutoRelated(writer,category,column,zeroNull);
  writeAllRelated(writer,category,zeroNull);
  for (int row=firstConstant; row <= lastConstant; row++) {
    writeConstant(writer,category,column,row);
  }
  try {
    if (external.isEmpty()) {
      writeRdfType(writer,pid + ""String_Node_Str"" + sheet.getName()+ ""String_Node_Str""+ category);
    }
    writer.write(""String_Node_Str"");
    writer.newLine();
    writer.newLine();
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
  return true;
}","private boolean writeTemplateColumn(BufferedWriter writer,String column) throws FishLinkException {
  String category=getCellValue(column,categoryRow);
  String field=getCellValue(column,fieldRow);
  String idType=getCellValue(column,idTypeRow);
  String external=getExternal(column);
  if (category == null || category.toLowerCase().equals(""String_Node_Str"")) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  if (field == null) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  masterNameChecker.checkName(sheet.getSheetInfo(),category,field);
  if (field.equalsIgnoreCase(""String_Node_Str"") && !external.isEmpty()) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  if (idType != null && idType.equals(FishLinkConstants.ALL_LABEL)) {
    FishLinkUtils.report(""String_Node_Str"" + column + ""String_Node_Str"");
    return false;
  }
  ZeroNullType zeroNull=getZeroVsNull(column);
  writeUri(writer,category,field,idType,column,zeroNull);
  try {
    writer.write(""String_Node_Str"");
    writeType(writer,category);
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
  writeData(writer,category,column,zeroNull);
  writeAutoRelated(writer,category,column,zeroNull);
  writeAllRelated(writer,category,zeroNull);
  for (int row=firstConstant; row <= lastConstant; row++) {
    writeConstant(writer,category,column,row);
  }
  try {
    if (external.isEmpty()) {
      writeRdfType(writer,pid + ""String_Node_Str"" + sheet.getName()+ ""String_Node_Str""+ category);
    }
    writer.write(""String_Node_Str"");
    writer.newLine();
    writer.newLine();
  }
 catch (  IOException ex) {
    throw new FishLinkException(""String_Node_Str"",ex);
  }
  return true;
}",0.9950873362445416
180411,"private boolean ignore(XLExprValue<?> expression,XLExprValue<?> zeroToNullExpr) throws XLWrapException {
  Object value;
  if (expression == null) {
    value=null;
  }
 else {
    value=expression.getValue();
  }
  String zeroToNullString=zeroToNullExpr.getValue().toString();
  ZeroNullType zeroNullType;
  try {
    zeroNullType=ZeroNullType.parse(zeroToNullString);
  }
 catch (  FishLinkException ex) {
    throw new XLWrapException(ex);
  }
switch (zeroNullType) {
case KEEP:
    return value == null;
case NULLS_AS_ZERO:
  return true;
case ZEROS_AS_NULLS:
return isZero(value);
default :
throw new XLWrapException(""String_Node_Str"" + zeroNullType);
}
}","private boolean ignore(XLExprValue<?> expression,XLExprValue<?> zeroToNullExpr) throws XLWrapException {
  Object value;
  if (expression == null) {
    value=null;
  }
 else {
    value=expression.getValue();
  }
  String zeroToNullString=zeroToNullExpr.getValue().toString();
  ZeroNullType zeroNullType;
  try {
    zeroNullType=ZeroNullType.parse(zeroToNullString);
  }
 catch (  FishLinkException ex) {
    throw new XLWrapException(ex);
  }
switch (zeroNullType) {
case KEEP:
    return value == null;
case NULLS_AS_ZERO:
  return true;
case ZEROS_AS_NULLS:
if (value == null) {
  return true;
}
return isZero(value);
default :
throw new XLWrapException(""String_Node_Str"" + zeroNullType);
}
}",0.9720176730486008
180412,"private boolean ignore(XLExprValue<?> expression,XLExprValue<?> zeroToNullExpr) throws XLWrapException {
  Object value;
  if (expression == null) {
    value=null;
  }
 else {
    value=expression.getValue();
  }
  String zeroToNullString=zeroToNullExpr.getValue().toString();
  ZeroNullType zeroNullType;
  try {
    zeroNullType=ZeroNullType.parse(zeroToNullString);
  }
 catch (  FishLinkException ex) {
    throw new XLWrapException(ex);
  }
switch (zeroNullType) {
case KEEP:
    return value == null;
case NULLS_AS_ZERO:
  return true;
case ZEROS_AS_NULLS:
if (value instanceof Number) {
  int i=((Number)value).intValue();
  return i == 0;
}
if (value instanceof String) {
return value.toString().equals(""String_Node_Str"");
}
if (value instanceof Boolean) {
return false;
}
if (value instanceof Date) {
return (((Date)value).getTime() == 0);
}
throw new XLWrapException(""String_Node_Str"" + value.getClass());
default :
throw new XLWrapException(""String_Node_Str"" + zeroNullType);
}
}","private boolean ignore(XLExprValue<?> expression,XLExprValue<?> zeroToNullExpr) throws XLWrapException {
  Object value;
  if (expression == null) {
    value=null;
  }
 else {
    value=expression.getValue();
  }
  String zeroToNullString=zeroToNullExpr.getValue().toString();
  ZeroNullType zeroNullType;
  try {
    zeroNullType=ZeroNullType.parse(zeroToNullString);
  }
 catch (  FishLinkException ex) {
    throw new XLWrapException(ex);
  }
switch (zeroNullType) {
case KEEP:
    return value == null;
case NULLS_AS_ZERO:
  return true;
case ZEROS_AS_NULLS:
if (value == null) {
  return false;
}
if (value instanceof Number) {
int i=((Number)value).intValue();
return i == 0;
}
if (value instanceof String) {
return value.toString().equals(""String_Node_Str"");
}
if (value instanceof Boolean) {
return false;
}
if (value instanceof Date) {
return (((Date)value).getTime() == 0);
}
throw new XLWrapException(""String_Node_Str"" + value.getClass());
default :
throw new XLWrapException(""String_Node_Str"" + zeroNullType);
}
}",0.978681209717402
180413,"@Override public XLExprValue<?> eval(ExecutionContext context) throws XLWrapException, XLWrapEOFException {
  XLExprValue<?> value=getArg(0).eval(context);
  if (FishLinkUtils.isZero(value.getValue())) {
    return null;
  }
  return value;
}","@Override public XLExprValue<?> eval(ExecutionContext context) throws XLWrapException, XLWrapEOFException {
  XLExprValue<?> value=getArg(0).eval(context);
  if (value == null) {
    return null;
  }
  if (FishLinkUtils.isZero(value.getValue())) {
    return null;
  }
  return value;
}",0.9166666666666666
180414,"public static void main(String[] args) throws XLWrapMapException {
  BrennRegister.register();
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
}","public static void main(String[] args) throws XLWrapMapException {
  BrennRegister.register();
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
  mapAndRdf(""String_Node_Str"",""String_Node_Str"");
}",0.6630727762803235
180415,"private void prepareSheet(Sheet masterSheet,FishLinkSheet metaSheet,Sheet dataSheet,Sheet copySheet) throws XLWrapMapException {
  int lastMetaRow=prepareColumnA(masterSheet,metaSheet,dataSheet);
  int lastColumn=dataSheet.getColumns();
  metaSheet.createFreezePane(""String_Node_Str"",lastMetaRow + 2);
  for (int zeroDataColumn=0; zeroDataColumn < lastColumn; zeroDataColumn++) {
    String metaColumn=FishLinkUtils.indexToAlpha(zeroDataColumn + 1);
    prepareDropDowns(masterSheet,lastMetaRow,metaSheet,metaColumn);
    copyData(lastMetaRow + 2,metaSheet,dataSheet,metaColumn);
  }
  if (copySheet != null) {
    copyMetaData(masterSheet,metaSheet,copySheet,lastMetaRow + 2,lastColumn);
  }
}","private void prepareSheet(Sheet masterSheet,FishLinkSheet metaSheet,Sheet dataSheet,Sheet copySheet) throws XLWrapMapException {
  int lastMetaRow=prepareColumnA(masterSheet,metaSheet,dataSheet);
  int lastColumn=dataSheet.getColumns();
  metaSheet.createFreezePane(""String_Node_Str"",lastMetaRow + 2);
  for (int zeroDataColumn=0; zeroDataColumn < lastColumn; zeroDataColumn++) {
    String metaColumn=FishLinkUtils.indexToAlpha(zeroDataColumn + 1);
    prepareDropDowns(masterSheet,lastMetaRow,metaSheet,metaColumn);
    copyData(lastMetaRow + 2,metaSheet,dataSheet,metaColumn);
  }
  if (copySheet != null) {
    copyMetaData(masterSheet,metaSheet,copySheet,lastMetaRow,lastColumn);
  }
}",0.9971098265895952
180416,"private void prepareMetaData(File metaFile,String pid,Workbook copyWorkbook) throws XLWrapMapException {
  Workbook dataWorkbook=FishLinkUtils.getWorkbookOnPid(pid);
  FishLinkWorkbook metaWorkbook=new FishLinkWorkbook();
  createNamedRanges(metaWorkbook);
  prepareSheets(metaWorkbook,dataWorkbook,copyWorkbook);
  metaWorkbook.write(metaFile);
}","private void prepareMetaData(File metaFile,String pid,Workbook copyWorkbook) throws XLWrapMapException {
  Workbook dataWorkbook=FishLinkUtils.getWorkbookOnPid(pid);
  FishLinkUtils.report(""String_Node_Str"" + dataWorkbook.getWorkbookInfo());
  FishLinkWorkbook metaWorkbook=new FishLinkWorkbook();
  createNamedRanges(metaWorkbook);
  prepareSheets(metaWorkbook,dataWorkbook,copyWorkbook);
  metaWorkbook.write(metaFile);
}",0.9012987012987012
180417,"void write(String filePath) throws XLWrapMapException {
  FileOutputStream fileOut;
  try {
    fileOut=new FileOutputStream(filePath);
  }
 catch (  IOException ex) {
    throw new XLWrapMapException(""String_Node_Str"",ex);
  }
  try {
    poiWorkbook.write(fileOut);
  }
 catch (  IOException ex) {
    throw new XLWrapMapException(""String_Node_Str"",ex);
  }
  try {
    fileOut.close();
  }
 catch (  IOException ex) {
    throw new XLWrapMapException(""String_Node_Str"",ex);
  }
}","void write(String filePath) throws XLWrapMapException {
  FileOutputStream fileOut;
  try {
    fileOut=new FileOutputStream(filePath);
  }
 catch (  IOException ex) {
    throw new XLWrapMapException(""String_Node_Str"" + filePath,ex);
  }
  try {
    poiWorkbook.write(fileOut);
  }
 catch (  IOException ex) {
    throw new XLWrapMapException(""String_Node_Str"" + filePath,ex);
  }
  try {
    fileOut.close();
  }
 catch (  IOException ex) {
    throw new XLWrapMapException(""String_Node_Str"" + filePath,ex);
  }
}",0.966900702106319
180418,"/** 
 * @param index zero-based numerical index
 * @return alpha index
 */
public static String indexToAlpha(int index){
  String reply=""String_Node_Str"";
  if (index != 26) {
    char first=(char)(index + 65);
    reply=first + ""String_Node_Str"";
  }
 else {
    char last=(char)(index - ((index / 26) * 26) + 65);
    String rest=indexToAlpha((index / 26));
    reply=rest + last;
  }
  if (index != alphaToIndex(reply)) {
    System.out.println(""String_Node_Str"" + index);
    System.out.println(""String_Node_Str"" + reply);
    System.out.println(""String_Node_Str"" + alphaToIndex(reply));
    int error=1 / 0;
  }
  return reply;
}","/** 
 * @param index zero-based numerical index
 * @return alpha index
 */
public static String indexToAlpha(int index){
  String reply=""String_Node_Str"";
  if (index < 26) {
    char first=(char)(index + 65);
    reply=first + ""String_Node_Str"";
  }
 else {
    char last=(char)(index - ((index / 26) * 26) + 65);
    String rest=indexToAlpha((index / 26) - 1);
    reply=rest + last;
  }
  if (index != alphaToIndex(reply)) {
    System.err.println(""String_Node_Str"" + index);
    System.err.println(""String_Node_Str"" + reply);
    System.err.println(""String_Node_Str"" + alphaToIndex(reply));
    throw new AssertionError(""String_Node_Str"");
  }
  return reply;
}",0.4649730561970747
180419,"public void writeMap() throws IOException, XLWrapMapException, XLWrapException, XLWrapEOFException {
  System.out.println(""String_Node_Str"");
  File mapFile=new File(MAP_FILE_ROOT + doi + ""String_Node_Str"");
  BufferedWriter mapWriter=new BufferedWriter(new FileWriter(mapFile));
  writePrefix(mapWriter);
  mapWriter.write(""String_Node_Str"");
  mapWriter.newLine();
  mapWriter.write(""String_Node_Str"");
  mapWriter.newLine();
  for (int i=0; i < sheetWrites.length; i++) {
    sheetWrites[i].writeMapping(mapWriter);
  }
  mapWriter.write(""String_Node_Str"");
  mapWriter.newLine();
  mapWriter.newLine();
  for (int i=0; i < sheetWrites.length; i++) {
    sheetWrites[i].writeTemplate(mapWriter);
  }
  mapWriter.close();
  System.out.println(""String_Node_Str"");
}","public void writeMap() throws IOException, XLWrapMapException, XLWrapException, XLWrapEOFException {
  System.out.println(""String_Node_Str"");
  File mapFile=new File(MAP_FILE_ROOT);
  if (!mapFile.exists()) {
    throw new XLWrapMapException(""String_Node_Str"" + MAP_FILE_ROOT + ""String_Node_Str"");
  }
  mapFile=new File(MAP_FILE_ROOT + doi + ""String_Node_Str"");
  BufferedWriter mapWriter=new BufferedWriter(new FileWriter(mapFile));
  writePrefix(mapWriter);
  mapWriter.write(""String_Node_Str"");
  mapWriter.newLine();
  mapWriter.write(""String_Node_Str"");
  mapWriter.newLine();
  for (int i=0; i < sheetWrites.length; i++) {
    sheetWrites[i].writeMapping(mapWriter);
  }
  mapWriter.write(""String_Node_Str"");
  mapWriter.newLine();
  mapWriter.newLine();
  for (int i=0; i < sheetWrites.length; i++) {
    sheetWrites[i].writeTemplate(mapWriter);
  }
  mapWriter.close();
  System.out.println(""String_Node_Str"");
}",0.9081209247184352
180420,"public void runMap() throws XLWrapException, IOException {
  System.out.println(""String_Node_Str"");
  XLWrapMapping map=MappingParser.parse(MAP_FILE_ROOT + doi + ""String_Node_Str"");
  XLWrapMaterializer mat=new XLWrapMaterializer();
  Model m=mat.generateModel(map);
  m.setNsPrefix(""String_Node_Str"",RDF_BASE_URL);
  File out=new File(RDF_FILE_ROOT + doi + ""String_Node_Str"");
  FileWriter writer=new FileWriter(out);
  m.write(writer,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + out.getAbsolutePath());
}","public void runMap() throws XLWrapException, IOException, XLWrapMapException {
  System.out.println(""String_Node_Str"");
  XLWrapMapping map=MappingParser.parse(MAP_FILE_ROOT + doi + ""String_Node_Str"");
  XLWrapMaterializer mat=new XLWrapMaterializer();
  Model m=mat.generateModel(map);
  m.setNsPrefix(""String_Node_Str"",RDF_BASE_URL);
  File out=new File(RDF_FILE_ROOT);
  if (!out.exists()) {
    throw new XLWrapMapException(""String_Node_Str"" + RDF_FILE_ROOT + ""String_Node_Str"");
  }
  out=new File(RDF_FILE_ROOT + doi + ""String_Node_Str"");
  FileWriter writer=new FileWriter(out);
  m.write(writer,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + out.getAbsolutePath());
}",0.8620974401321222
180421,"protected void writeTemplate(BufferedWriter writer) throws IOException, XLWrapException, XLWrapEOFException, XLWrapMapException {
  writer.write(""String_Node_Str"");
  writer.write(template());
  writer.write(""String_Node_Str"");
  writer.newLine();
  for (char meta='B'; meta < 'Y'; meta++) {
    int charValue=Character.valueOf(meta);
    String data=String.valueOf((char)(charValue + 1));
    System.out.println(meta + ""String_Node_Str"" + data);
    writeTemplateColumn(writer,""String_Node_Str"" + meta,data);
  }
  writer.write(""String_Node_Str"");
  writer.newLine();
}","protected void writeTemplate(BufferedWriter writer) throws IOException, XLWrapException, XLWrapEOFException, XLWrapMapException {
  writer.write(""String_Node_Str"");
  writer.write(template());
  writer.write(""String_Node_Str"");
  writer.newLine();
  for (char meta='B'; meta < 'Y'; meta++) {
    int charValue=Character.valueOf(meta);
    String data=String.valueOf((char)(charValue - 1));
    System.out.println(meta + ""String_Node_Str"" + data);
    writeTemplateColumn(writer,""String_Node_Str"" + meta,data);
  }
  writer.write(""String_Node_Str"");
  writer.newLine();
}",0.9982456140350876
180422,"private void writeTemplateColumn(BufferedWriter writer,String metaColumn,String dataColumn) throws IOException, XLWrapException, XLWrapEOFException, XLWrapMapException {
  String category=getCellValue(metaColumn,CATEGORY_ROW);
  if (category == null) {
    System.out.println(""String_Node_Str"" + metaColumn + ""String_Node_Str"");
    return;
  }
  String field=getCellValue(metaColumn,FIELD_ROW);
  if (field == null) {
    System.out.println(""String_Node_Str"" + metaColumn + ""String_Node_Str"");
    return;
  }
  String idType=getCellValue(metaColumn,ID_TYPE_ROW);
  writeURI(writer,category,field,idType,metaColumn);
  writer.write(""String_Node_Str"");
  writer.write(category);
  writer.write(""String_Node_Str"");
  writer.newLine();
  writer.write(""String_Node_Str"" + field + ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
  writer.newLine();
  for (int row=firstLink; row <= lastLink; row++) {
    writeLink(writer,metaColumn,dataColumn,row);
  }
  for (int row=firstConstant; row <= lastConstant; row++) {
    writeConstant(writer,metaColumn,row);
  }
  writer.write(""String_Node_Str"" + RDF_BASE_URL + ""String_Node_Str""+ doi+ category+ ""String_Node_Str"");
  writer.newLine();
  writer.write(""String_Node_Str"");
  writer.newLine();
  writer.newLine();
}","private void writeTemplateColumn(BufferedWriter writer,String metaColumn,String dataColumn) throws IOException, XLWrapException, XLWrapEOFException, XLWrapMapException {
  String category=getCellValue(metaColumn,CATEGORY_ROW);
  if (category == null) {
    System.out.println(""String_Node_Str"" + metaColumn + ""String_Node_Str"");
    return;
  }
  String field=getCellValue(metaColumn,FIELD_ROW);
  if (field == null) {
    System.out.println(""String_Node_Str"" + metaColumn + ""String_Node_Str"");
    return;
  }
  String idType=getCellValue(metaColumn,ID_TYPE_ROW);
  writeURI(writer,category,field,idType,dataColumn);
  writer.write(""String_Node_Str"");
  writer.write(category);
  writer.write(""String_Node_Str"");
  writer.newLine();
  writer.write(""String_Node_Str"" + field + ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
  writer.newLine();
  for (int row=firstLink; row <= lastLink; row++) {
    writeLink(writer,metaColumn,dataColumn,row);
  }
  for (int row=firstConstant; row <= lastConstant; row++) {
    writeConstant(writer,metaColumn,row);
  }
  writer.write(""String_Node_Str"" + RDF_BASE_URL + ""String_Node_Str""+ doi+ category+ ""String_Node_Str"");
  writer.newLine();
  writer.write(""String_Node_Str"");
  writer.newLine();
  writer.newLine();
}",0.9984251968503935
180423,"private void writeURI(BufferedWriter writer,String type,String feild,String idType,String dataColumn) throws IOException, XLWrapMapException {
  System.out.println(feild + ""String_Node_Str"" + idType+ ""String_Node_Str""+ dataColumn);
  if (feild.toLowerCase().equals(""String_Node_Str"")) {
    writer.write(""String_Node_Str"" + RDF_BASE_URL + type+ ""String_Node_Str""+ doi+ ""String_Node_Str""+ sheetInURI+ ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
    return;
  }
  if (feild.toLowerCase().equals(""String_Node_Str"")) {
    writer.write(""String_Node_Str"" + RDF_BASE_URL + type+ ""String_Node_Str""+ doi+ ""String_Node_Str""+ sheetInURI+ ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
    return;
  }
  if ((idType == null) || (idType.isEmpty())) {
    throw new XLWrapMapException(""String_Node_Str"" + dataColumn + ""String_Node_Str""+ metaSheet.getName()+ ""String_Node_Str"");
  }
  if (idType.equalsIgnoreCase(""String_Node_Str"")) {
    throw new XLWrapMapException(""String_Node_Str"" + dataColumn + ""String_Node_Str""+ metaSheet.getName()+ ""String_Node_Str"");
  }
  if (idType == null) {
    System.out.println(""String_Node_Str"" + dataColumn + ""String_Node_Str"");
  }
 else   if (idType.equalsIgnoreCase(""String_Node_Str"")) {
    writer.write(""String_Node_Str"" + RDF_BASE_URL + type+ ""String_Node_Str""+ doi+ ""String_Node_Str""+ sheetInURI+ ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
  }
 else {
    writer.write(""String_Node_Str"" + RDF_BASE_URL + type+ ""String_Node_Str""+ doi+ ""String_Node_Str""+ sheetInURI+ ""String_Node_Str""+ idType+ firstData+ ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
  }
}","private void writeURI(BufferedWriter writer,String type,String feild,String idType,String dataColumn) throws IOException, XLWrapMapException {
  System.out.println(type + ""String_Node_Str"" + feild+ ""String_Node_Str""+ idType+ ""String_Node_Str""+ dataColumn);
  if (feild.toLowerCase().equals(""String_Node_Str"")) {
    writer.write(""String_Node_Str"" + RDF_BASE_URL + type+ ""String_Node_Str""+ doi+ ""String_Node_Str""+ sheetInURI+ ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
    return;
  }
  if (feild.toLowerCase().equals(""String_Node_Str"")) {
    writer.write(""String_Node_Str"" + RDF_BASE_URL + type+ ""String_Node_Str""+ doi+ ""String_Node_Str""+ sheetInURI+ ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
    return;
  }
  if ((idType == null) || (idType.isEmpty())) {
    throw new XLWrapMapException(""String_Node_Str"" + dataColumn + ""String_Node_Str""+ metaSheet.getName()+ ""String_Node_Str"");
  }
  if (idType.equalsIgnoreCase(""String_Node_Str"")) {
    throw new XLWrapMapException(""String_Node_Str"" + dataColumn + ""String_Node_Str""+ metaSheet.getName()+ ""String_Node_Str"");
  }
  if (idType == null) {
    System.out.println(""String_Node_Str"" + dataColumn + ""String_Node_Str"");
  }
 else   if (idType.equalsIgnoreCase(""String_Node_Str"")) {
    writer.write(""String_Node_Str"" + RDF_BASE_URL + type+ ""String_Node_Str""+ doi+ ""String_Node_Str""+ sheetInURI+ ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
  }
 else {
    writer.write(""String_Node_Str"" + RDF_BASE_URL + type+ ""String_Node_Str""+ doi+ ""String_Node_Str""+ sheetInURI+ ""String_Node_Str""+ idType+ firstData+ ""String_Node_Str""+ dataColumn+ firstData+ ""String_Node_Str"");
  }
}",0.9798617373008716
180424,"public static void main(String[] args) throws Exception {
  String[] celebs=readFile(""String_Node_Str"").split(""String_Node_Str"");
  String[] celebXMLList=new String[celebs.length];
  int i=0;
  for (  String celeb : celebs) {
    celebXMLList[i++]=openURL(""String_Node_Str"" + celeb);
    System.out.println(""String_Node_Str"" + celebXMLList[i - 1]);
  }
}","public static void main(String[] args) throws Exception {
  String[] celebs=Utils.readFile(""String_Node_Str"").split(""String_Node_Str"");
  String[] celebXMLList=new String[celebs.length];
  int i=0;
  for (  String celeb : celebs) {
    celebXMLList[i++]=Utils.openURL(""String_Node_Str"" + celeb);
    System.out.println(""String_Node_Str"" + celebXMLList[i - 1]);
  }
}",0.9833333333333332
180425,"/** 
 * Resizes an image using a Graphics2D object backed by a BufferedImage.
 * @param srcImg - source image to scale
 * @param w - desired width
 * @param h - desired height
 * @return - the new resized image
 */
private Image getScaledImage(Image srcImg,int w,int h){
  BufferedImage resizedImg=new BufferedImage(w,h,BufferedImage.TYPE_INT_RGB);
  Graphics2D g2=resizedImg.createGraphics();
  g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
  g2.drawImage(srcImg,0,0,w,h,null);
  g2.dispose();
  return resizedImg;
}","/** 
 * Resizes an image using a Graphics2D object backed by a BufferedImage.
 * @param srcImg - source image to scale
 * @param w - desired width
 * @param h - desired height
 * @return - the new resized image
 */
private Image getScaledImage(BufferedImage srcImg,int w,int h){
  int srcWidth=srcImg.getWidth();
  int srcHeight=srcImg.getHeight();
  int diffWidth=maxWidth - srcWidth;
  int diffHeight=maxHeight - srcHeight;
  if (diffWidth > diffHeight) {
    w=maxWidth;
    double hf=((1.0 * maxHeight) * ((1.0 * srcWidth) / (1.0 * srcHeight)));
    h=(int)Math.round(hf);
  }
 else {
    double wf=((1.0 * maxWidth) * ((1.0 * srcHeight) / (1.0 * srcWidth)));
    w=(int)Math.round(wf);
    h=maxHeight;
  }
  BufferedImage resizedImg=new BufferedImage(w,h,BufferedImage.TYPE_INT_RGB);
  Graphics2D g2=resizedImg.createGraphics();
  g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
  g2.drawImage(srcImg,0,0,w,h,null);
  g2.dispose();
  return resizedImg;
}",0.7210626185958254
180426,"public SessionConfig parse(InputStream in) throws Exception {
  Map<?,?> value=mapper.readValue(in,Map.class);
  Object version=value.get(""String_Node_Str"");
  if (version != null && version instanceof String) {
    VersionConfigParser parser=versionParsers.get((String)version);
    return parser.parse(mapper,value);
  }
 else {
    return legacyParser.parse(mapper,value);
  }
}","public SessionConfig parse(InputStream in) throws Exception {
  Map<?,?> value;
  try {
    value=mapper.readValue(in,Map.class);
  }
 catch (  JsonParseException e) {
    String msg=getFriendlyError(e);
    throw new Exception(msg,e);
  }
  Object version=value.get(""String_Node_Str"");
  if (version != null && version instanceof String) {
    VersionConfigParser parser=versionParsers.get((String)version);
    return parser.parse(mapper,value);
  }
 else {
    return legacyParser.parse(mapper,value);
  }
}",0.8552188552188552
180427,"/** 
 * @param config
 * @return
 * @throws IOException
 */
protected CategoryItem[] parseItems(SessionConfig config) throws IOException {
  if (config == null) {
    return new CategoryItem[0];
  }
  ItemConfig[] confItems=config.getItems();
  CategoryItem[] rval=new CategoryItem[confItems.length];
  String base=config.getItemBase();
  for (int i=0; i < rval.length; ++i) {
    File imgFile=new File(base,confItems[i].visualSD);
    File audioSD=null;
    if (confItems[i].audioSD != null) {
      audioSD=new File(base,confItems[i].audioSD);
    }
    File audioPrompt=null;
    if (confItems[i].audioPrompt != null) {
      audioPrompt=new File(base,confItems[i].audioPrompt);
    }
    rval[i]=new CategoryItem(imgFile,audioSD,audioPrompt);
  }
  return rval;
}","/** 
 * @param config
 * @return
 * @throws IOException
 */
protected CategoryItem[] parseItems(SessionConfig config) throws IOException {
  if (config == null) {
    return new CategoryItem[0];
  }
  ItemConfig[] confItems=config.getItems();
  CategoryItem[] rval=new CategoryItem[confItems.length];
  String base=config.getItemBase();
  for (int i=0; i < rval.length; ++i) {
    if (confItems[i].visualSD == null) {
      throw new IOException(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
    }
    File imgFile=new File(base,confItems[i].visualSD);
    File audioSD=null;
    if (confItems[i].audioSD != null) {
      audioSD=new File(base,confItems[i].audioSD);
    }
    File audioPrompt=null;
    if (confItems[i].audioPrompt != null) {
      audioPrompt=new File(base,confItems[i].audioPrompt);
    }
    rval[i]=new CategoryItem(imgFile,audioSD,audioPrompt);
  }
  return rval;
}",0.924653405666064
180428,"public void startTimerTimeDelayAutoAdvance(int timeDelayAutoAdvance){
  Timer xxx=new Timer(timeDelayAutoAdvance * 1000,timerTimeDelayAutoAdvance);
  xxx.setRepeats(false);
  xxx.start();
  log.info(String.format(""String_Node_Str"",timeDelayAutoAdvance));
}","public void startTimerTimeDelayAutoAdvance(int timeDelayAutoAdvance){
  preBetweenTimer=new Timer(timeDelayAutoAdvance * 1000,timerTimeDelayAutoAdvance);
  preBetweenTimer.setRepeats(false);
  preBetweenTimer.start();
  log.info(String.format(""String_Node_Str"",timeDelayAutoAdvance));
}",0.8892988929889298
180429,"public void setupTimer(){
  if (null != timer) {
    timer.stop();
  }
  SessionConfig config=session.getConfig();
  int answerDelay=config.getTimeDelayAudioPrompt() + getPromptLen(currentItem.getAudioPrompt());
  timer=new Timer(answerDelay * 1000,timerAction);
  timer.setInitialDelay(config.getTimeDelayAudioSD() * 1000);
  timer.setRepeats(true);
  timer.start();
}","public void setupTimer(){
  if (null != timer) {
    timer.stop();
  }
  SessionConfig config=session.getConfig();
  int answerDelay=config.getTimeDelayAudioPrompt() + getSoundLen(currentItem.getAudioSD());
  timer=new Timer(answerDelay * 1000,timerAction);
  timer.setInitialDelay(config.getTimeDelayAudioSD() * 1000);
  timer.setRepeats(true);
  timer.start();
  log.info(String.format(""String_Node_Str"",config.getTimeDelayAudioSD(),answerDelay));
}",0.4439024390243902
180430,"public void stopTimer(){
  if (timer != null) {
    timer.stop();
  }
}","public void stopTimer(){
  if (timer != null) {
    timer.stop();
  }
  if (preBetweenTimer != null) {
    preBetweenTimer.stop();
  }
}",0.6859903381642513
180431,"private void timer(){
  if (playPrompt) {
    playPrompt=false;
    startSound(item.getAudioSD(),-1);
  }
 else {
    playPrompt=true;
    startSound(item.getAudioPrompt(),item.getItemNumber());
    gui.stopTimer();
    int timeDelayAutoAdvance=gui.getSession().getConfig().getTimeDelayAutoAdvance();
    if (timeDelayAutoAdvance > 0) {
      int audioPromptLen=gui.getPromptLen(item.getAudioPrompt());
      timeDelayAutoAdvance+=audioPromptLen;
      if (timeDelayAutoAdvance > 0) {
        gui.startTimerTimeDelayAutoAdvance(timeDelayAutoAdvance);
      }
 else {
        log.error(""String_Node_Str"");
      }
    }
  }
}","private void timer(){
  if (playPrompt) {
    playPrompt=false;
    startSound(item.getAudioSD(),-1);
  }
 else {
    playPrompt=true;
    startSound(item.getAudioPrompt(),item.getItemNumber());
    gui.stopTimer();
    int timeDelayAutoAdvance=gui.getSession().getConfig().getTimeDelayAutoAdvance();
    if (timeDelayAutoAdvance > 0) {
      int audioPromptLen=gui.getSoundLen(item.getAudioPrompt());
      timeDelayAutoAdvance+=audioPromptLen;
      if (timeDelayAutoAdvance > 0) {
        gui.startTimerTimeDelayAutoAdvance(timeDelayAutoAdvance);
      }
 else {
        log.error(""String_Node_Str"");
      }
    }
  }
}",0.9911788291900562
180432,"public void useNewSession(){
  if (bDebounce) {
    return;
  }
  bDebounce=true;
  centerButton.removeActionListener(this);
  clickToStartButton.setEnabled(false);
  clickToStartButton.setForeground(Color.white);
  if (null != session) {
    CategoryItem[] copy=Arrays.copyOf(session.getItems(),session.getItems().length);
    SessionConfig config=session.getConfig();
    for (int i=0; i < config.getShuffleCount(); ++i) {
      Shuffler.shuffle(copy);
    }
    itemQueue=new ConcurrentLinkedQueue<CategoryItem>();
    for (    CategoryItem item : copy) {
      itemQueue.add(item);
    }
    itemQueue.add(copy[copy.length - 1]);
    totalItemCount=itemQueue.size() - 1;
    mediator.setSession(session);
    setupCenterButton();
    setFrameTitle();
    refreshGui();
    setupBetweenTimer();
    enableButtons();
    mediator.execute(Mediator.BETWEEN_TIMER);
  }
}","public void useNewSession(){
  if (bDebounce) {
    return;
  }
  bDebounce=true;
  shownItemCount=0;
  centerButton.removeActionListener(this);
  clickToStartButton.setEnabled(false);
  clickToStartButton.setForeground(Color.white);
  if (null != session) {
    CategoryItem[] copy=Arrays.copyOf(session.getItems(),session.getItems().length);
    SessionConfig config=session.getConfig();
    for (int i=0; i < config.getShuffleCount(); ++i) {
      Shuffler.shuffle(copy);
    }
    itemQueue=new ConcurrentLinkedQueue<CategoryItem>();
    for (    CategoryItem item : copy) {
      itemQueue.add(item);
    }
    itemQueue.add(copy[copy.length - 1]);
    totalItemCount=itemQueue.size() - 1;
    mediator.setSession(session);
    setupCenterButton();
    setFrameTitle();
    refreshGui();
    setupBetweenTimer();
    enableButtons();
    mediator.execute(Mediator.BETWEEN_TIMER);
  }
}",0.9886363636363636
180433,"private void setupActions(MediatorListener mediator){
  Properties hotKeysProperties=null;
  String fileName=""String_Node_Str"";
  try {
    hotKeysProperties=readPropertiesFromClassPath(fileName);
  }
 catch (  Exception e) {
    hotKeysProperties=new Properties();
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    log.warn(String.format(""String_Node_Str"",fileName,hotKeysProperties),e);
  }
  String hk=(String)hotKeysProperties.get(""String_Node_Str"");
  attendingAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F1),KeyStroke.getKeyStroke(hk),Mediator.ATTENDING,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  independentAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F2),KeyStroke.getKeyStroke(hk),Mediator.INDEPENDENT,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  verbalAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F3),KeyStroke.getKeyStroke(hk),Mediator.VERBAL,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  modelingAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F4),KeyStroke.getKeyStroke(hk),Mediator.MODELING,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  noAnswerAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F5),KeyStroke.getKeyStroke(hk),Mediator.NO_ANSWER,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  wrongAnswerAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F5),KeyStroke.getKeyStroke(hk),Mediator.WRONG_ANSWER,mediator);
  toggleButtonsAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.TOGGLE_BUTTONS,mediator);
  quitAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.QUIT,mediator);
  timerAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,""String_Node_Str"",new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.TIMER,mediator);
  timerBetweenAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,""String_Node_Str"",new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.BETWEEN_TIMER,mediator);
  timerTimeDelayAutoAdvance=new ActionRecorder(Messages.getString(""String_Node_Str""),null,""String_Node_Str"",new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.CHANGE_DELAY_TIMER,mediator);
  openAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.OPEN,mediator);
  openHttpAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.OPEN_HTTP,mediator);
  showLoggingFrameAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.SHOW_LOGGING_FRAME,mediator);
}","private void setupActions(MediatorListener mediator){
  Properties hotKeysProperties=null;
  String fileName=""String_Node_Str"";
  try {
    hotKeysProperties=readPropertiesFromClassPath(fileName);
  }
 catch (  Exception e) {
    hotKeysProperties=new Properties();
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    hotKeysProperties.put(""String_Node_Str"",""String_Node_Str"");
    log.warn(String.format(""String_Node_Str"",fileName,hotKeysProperties),e);
  }
  String hk=(String)hotKeysProperties.get(""String_Node_Str"");
  attendingAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F1),KeyStroke.getKeyStroke(hk),Mediator.ATTENDING,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  independentAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F2),KeyStroke.getKeyStroke(hk),Mediator.INDEPENDENT,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  verbalAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F3),KeyStroke.getKeyStroke(hk),Mediator.VERBAL,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  modelingAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F4),KeyStroke.getKeyStroke(hk),Mediator.MODELING,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  noAnswerAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F5),KeyStroke.getKeyStroke(hk),Mediator.NO_ANSWER,mediator);
  hk=(String)hotKeysProperties.get(""String_Node_Str"");
  wrongAnswerAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_F5),KeyStroke.getKeyStroke(hk),Mediator.WRONG_ANSWER,mediator);
  toggleButtonsAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.TOGGLE_BUTTONS,mediator);
  quitAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.QUIT,mediator);
  timerAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,""String_Node_Str"",new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.TIMER,mediator);
  timerBetweenAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,""String_Node_Str"",new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.BETWEEN_TIMER,mediator);
  timerTimeDelayAutoAdvance=new ActionRecorder(Messages.getString(""String_Node_Str""),null,""String_Node_Str"",new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.CHANGE_DELAY_TIMER,mediator);
  openAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.OPEN,mediator);
  showLoggingFrameAction=new ActionRecorder(Messages.getString(""String_Node_Str""),null,Messages.getString(""String_Node_Str""),new Integer(KeyEvent.VK_L),KeyStroke.getKeyStroke(""String_Node_Str""),Mediator.SHOW_LOGGING_FRAME,mediator);
}",0.9721434098529792
180434,"/** 
 * @param config
 * @return
 * @throws IOException
 */
protected CategoryItem[] parseItems(SessionConfig config) throws IOException {
  if (config == null) {
    return new CategoryItem[0];
  }
  ItemConfig[] confItems=config.getItems();
  CategoryItem[] rval=new CategoryItem[confItems.length];
  String base=config.getItemBase();
  for (int i=0; i < rval.length; ++i) {
    File imgFile=new File(base,confItems[i].visualSD);
    File audioSD=new File(base,confItems[i].audioSD);
    File audioPrompt=new File(base,confItems[i].audioPrompt);
    rval[i]=new CategoryItem(imgFile,audioSD,audioPrompt);
  }
  return rval;
}","/** 
 * @param config
 * @return
 * @throws IOException
 */
protected CategoryItem[] parseItems(SessionConfig config) throws IOException {
  if (config == null) {
    return new CategoryItem[0];
  }
  ItemConfig[] confItems=config.getItems();
  CategoryItem[] rval=new CategoryItem[confItems.length];
  String base=config.getItemBase();
  for (int i=0; i < rval.length; ++i) {
    File imgFile=new File(base,confItems[i].visualSD);
    File audioSD=null;
    if (confItems[i].audioSD != null) {
      audioSD=new File(base,confItems[i].audioSD);
    }
    File audioPrompt=null;
    if (confItems[i].audioPrompt != null) {
      audioPrompt=new File(base,confItems[i].audioPrompt);
    }
    rval[i]=new CategoryItem(imgFile,audioSD,audioPrompt);
  }
  return rval;
}",0.8723098995695839
180435,"private int getPromptLen(File sndFile){
  AudioInputStream audioInputStream;
  try {
    audioInputStream=AudioSystem.getAudioInputStream(sndFile);
    AudioFormat format=audioInputStream.getFormat();
    long frames=audioInputStream.getFrameLength();
    audioInputStream.close();
    return (int)(frames / format.getFrameRate());
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return 0;
  }
}","private int getPromptLen(File sndFile){
  if (sndFile == null) {
    return 0;
  }
  AudioInputStream audioInputStream;
  try {
    audioInputStream=AudioSystem.getAudioInputStream(sndFile);
    AudioFormat format=audioInputStream.getFormat();
    long frames=audioInputStream.getFrameLength();
    audioInputStream.close();
    return (int)(frames / format.getFrameRate());
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return 0;
  }
}",0.9508571428571428
180436,"public void execute(int action){
  boolean hit=false;
switch (action) {
case ATTENDING:
    break;
case INDEPENDENT:
  if (!waiting) {
    collector.addResponse(item,gui.getAttending().isSelected(),RespType.INDEPENDANT);
    hit=true;
  }
break;
case VERBAL:
if (!waiting) {
collector.addResponse(item,gui.getAttending().isSelected(),RespType.VERBAL);
hit=true;
}
break;
case MODELING:
if (!waiting) {
collector.addResponse(item,gui.getAttending().isSelected(),RespType.MODEL);
hit=true;
}
break;
case NO_ANSWER:
if (!waiting) {
collector.addResponse(item,gui.getAttending().isSelected(),RespType.NONE);
hit=true;
}
break;
case QUIT:
System.exit(0);
break;
case TIMER:
timer();
break;
case BETWEEN_TIMER:
hit=true;
waiting=false;
justWaited=true;
break;
case SHOW_LOGGING_FRAME:
gui.showLoggingFrame();
break;
case OPEN:
gui.openSession();
break;
case OPEN_HTTP:
gui.openHttpSession();
break;
}
if (hit) {
gui.getTimer().stop();
stopSound();
playPrompt=true;
if (gui.getItemQueue().size() == 0) {
gui.populateSessionName();
gui.populateSessionDataFile();
collector.setSessionName(gui.getSession().getSessionName());
File csvFile=null;
try {
csvFile=gui.getSession().getSessionDataFile();
boolean writeHeader=!csvFile.exists();
CSVWriter csvWriter=new CSVWriter(new FileWriter(csvFile,true));
SessionData data=collector.getData();
if (writeHeader) {
data.writeSummaryHeader(csvWriter);
}
data.writeSummary(csvWriter);
csvWriter.close();
String sessionCsvName=data.getOverall().getName() + ""String_Node_Str"" + data.getSessionName()+ ""String_Node_Str"";
File session=new File(csvFile.getParentFile(),sessionCsvName);
CSVWriter writer=new CSVWriter(new FileWriter(session));
data.writeSessionFile(writer);
writer.close();
System.out.println(""String_Node_Str"" + csvFile);
}
 catch (IOException e) {
log.error(String.format(""String_Node_Str"",csvFile.getAbsolutePath()),e);
e.printStackTrace();
}
gui.backToStartScreen();
gui.getTimer().stop();
}
 else {
if (justWaited) {
item=gui.getItemQueue().remove();
log.info(String.format(""String_Node_Str"",item.getImgFile(),item.getItemNumber()));
gui.switchImage(item.getImg());
gui.getTimer().start();
justWaited=false;
}
 else {
gui.clearImage();
gui.getBetweenTimer().start();
waiting=true;
}
}
}
}","public void execute(int action){
  boolean hit=false;
switch (action) {
case ATTENDING:
    break;
case INDEPENDENT:
  if (!waiting) {
    collector.addResponse(item,gui.getAttending().isSelected(),RespType.INDEPENDENT);
    hit=true;
  }
break;
case VERBAL:
if (!waiting) {
collector.addResponse(item,gui.getAttending().isSelected(),RespType.VERBAL);
hit=true;
}
break;
case MODELING:
if (!waiting) {
collector.addResponse(item,gui.getAttending().isSelected(),RespType.MODEL);
hit=true;
}
break;
case NO_ANSWER:
if (!waiting) {
collector.addResponse(item,gui.getAttending().isSelected(),RespType.NONE);
hit=true;
}
break;
case QUIT:
System.exit(0);
break;
case TIMER:
timer();
break;
case BETWEEN_TIMER:
hit=true;
waiting=false;
justWaited=true;
break;
case SHOW_LOGGING_FRAME:
gui.showLoggingFrame();
break;
case OPEN:
gui.openSession();
break;
case OPEN_HTTP:
gui.openHttpSession();
break;
}
if (hit) {
gui.getTimer().stop();
stopSound();
playPrompt=true;
if (gui.getItemQueue().size() == 0) {
gui.populateSessionName();
gui.populateSessionDataFile();
collector.setSessionName(gui.getSession().getSessionName());
File csvFile=null;
try {
csvFile=gui.getSession().getSessionDataFile();
boolean writeHeader=!csvFile.exists();
CSVWriter csvWriter=new CSVWriter(new FileWriter(csvFile,true));
SessionData data=collector.getData();
if (writeHeader) {
data.writeSummaryHeader(csvWriter);
}
data.writeSummary(csvWriter);
csvWriter.close();
String sessionCsvName=data.getOverall().getName() + ""String_Node_Str"" + data.getSessionName()+ ""String_Node_Str"";
File session=new File(csvFile.getParentFile(),sessionCsvName);
CSVWriter writer=new CSVWriter(new FileWriter(session));
data.writeSessionFile(writer);
writer.close();
System.out.println(""String_Node_Str"" + csvFile);
}
 catch (IOException e) {
log.error(String.format(""String_Node_Str"",csvFile.getAbsolutePath()),e);
e.printStackTrace();
}
gui.backToStartScreen();
gui.getTimer().stop();
}
 else {
if (justWaited) {
item=gui.getItemQueue().remove();
log.info(String.format(""String_Node_Str"",item.getImgFile(),item.getItemNumber()));
gui.switchImage(item.getImg());
gui.getTimer().start();
justWaited=false;
}
 else {
gui.clearImage();
gui.getBetweenTimer().start();
waiting=true;
}
}
}
}",0.9995527728085868
180437,"@Test public void percentTest(){
  SessionDataCollector collector=new SessionDataCollector(session,desc);
  collector.addResponse(item1,true,RespType.INDEPENDANT);
  collector.addResponse(item1,false,RespType.MODEL);
  collector.addResponse(item2,true,RespType.VERBAL);
  collector.addResponse(item2,false,RespType.NONE);
  SessionData data=collector.getData();
  assertNotNull(data);
  Stats overall=data.getOverall();
  assertEquals(25,overall.getPercentIndep(),0);
  assertEquals(25,overall.getPercentVerbal(),0);
  assertEquals(25,overall.getPercentModel(),0);
  assertEquals(session,overall.getName());
}","@Test public void percentTest(){
  SessionDataCollector collector=new SessionDataCollector(session,desc);
  collector.addResponse(item1,true,RespType.INDEPENDENT);
  collector.addResponse(item1,false,RespType.MODEL);
  collector.addResponse(item2,true,RespType.VERBAL);
  collector.addResponse(item2,false,RespType.NONE);
  SessionData data=collector.getData();
  assertNotNull(data);
  Stats overall=data.getOverall();
  assertEquals(25,overall.getPercentIndep(),0);
  assertEquals(25,overall.getPercentVerbal(),0);
  assertEquals(25,overall.getPercentModel(),0);
  assertEquals(session,overall.getName());
}",0.9983579638752051
180438,"protected String getAudioString(String base,String imgStr){
  File imgFile=new File(base,imgStr);
  String rval=null;
  File audioFile=getAudio(imgFile);
  if (audioFile != null) {
    String absPath=audioFile.getAbsolutePath();
    if (base != null) {
      rval=absPath.substring(base.length());
    }
  }
  return rval;
}","protected String getAudioString(String base,String imgStr){
  File imgFile=new File(base,imgStr);
  String rval=null;
  File audioFile=getAudio(imgFile);
  if (audioFile != null) {
    String absPath=audioFile.getAbsolutePath();
    if (base != null) {
      rval=absPath.substring(absPath.indexOf(base) + base.length());
    }
  }
  return rval;
}",0.9523809523809524
180439,"public void useNewSession(){
  if (bDebounce) {
    return;
  }
  bDebounce=true;
  centerButton.removeActionListener(this);
  clickToStartButton.setEnabled(false);
  clickToStartButton.setForeground(Color.white);
  if (null != session) {
    CategoryItem[] copy=Arrays.copyOf(session.getItems(),session.getItems().length);
    for (int i=0; i < session.getShuffleCount(); ++i) {
      Shuffler.shuffle(copy);
    }
    itemQueue=new ConcurrentLinkedQueue<CategoryItem>();
    for (    CategoryItem item : copy) {
      itemQueue.add(item);
    }
    itemQueue.add(copy[copy.length - 1]);
    totalItemCount=itemQueue.size() - 1;
    mediator.setSession(session);
    setupCenterButton();
    setFrameTitle();
    refreshGui();
    setupTimer();
    setupBetweenTimer();
    enableButtons();
  }
}","public void useNewSession(){
  if (bDebounce) {
    return;
  }
  bDebounce=true;
  centerButton.removeActionListener(this);
  clickToStartButton.setEnabled(false);
  clickToStartButton.setForeground(Color.white);
  if (null != session) {
    CategoryItem[] copy=Arrays.copyOf(session.getItems(),session.getItems().length);
    for (int i=0; i < session.getShuffleCount(); ++i) {
      Shuffler.shuffle(copy);
    }
    itemQueue=new ConcurrentLinkedQueue<CategoryItem>();
    for (    CategoryItem item : copy) {
      itemQueue.add(item);
    }
    itemQueue.add(copy[copy.length - 1]);
    totalItemCount=itemQueue.size() - 1;
    mediator.setSession(session);
    setupCenterButton();
    setFrameTitle();
    refreshGui();
    setupTimer();
    setupBetweenTimer();
    enableButtons();
    mediator.execute(Mediator.BETWEEN_TIMER);
  }
}",0.9719512195121952
180440,"public void setupCenterButton(){
  CategoryItem first=itemQueue.remove();
  log.info(String.format(""String_Node_Str"",first.getImgFile(),first.getItemNumber()));
  imgIconCenter=new ImageIcon(first.getImg());
  centerButton.setIcon(imgIconCenter);
  Dimension max=session.getMaxDimensions();
  centerButton.setPreferredSize(max);
  int width=(int)max.getWidth();
  int height=(int)max.getHeight();
  clearImage=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
  Graphics g=clearImage.getGraphics();
  g.setColor(Color.WHITE);
  g.fillRect(0,0,width,height);
  g.dispose();
}","public void setupCenterButton(){
  Dimension max=session.getMaxDimensions();
  centerButton.setPreferredSize(max);
  int width=(int)max.getWidth();
  int height=(int)max.getHeight();
  clearImage=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
  Graphics g=clearImage.getGraphics();
  g.setColor(Color.WHITE);
  g.fillRect(0,0,width,height);
  g.dispose();
}",0.7756813417190775
180441,"public void useNewSession(){
  if (null != session) {
    CategoryItem[] copy=Arrays.copyOf(session.getItems(),session.getItems().length);
    for (int i=0; i < session.getShuffleCount(); ++i) {
      Shuffler.shuffle(copy);
    }
    itemQueue=new ConcurrentLinkedQueue<CategoryItem>();
    for (    CategoryItem item : copy) {
      itemQueue.add(item);
    }
    mediator.setSession(session);
    setupCenterButton();
    setFrameTitle();
    refreshGui();
    setupTimer();
  }
}","public void useNewSession(){
  if (null != session) {
    CategoryItem[] copy=Arrays.copyOf(session.getItems(),session.getItems().length);
    for (int i=0; i < session.getShuffleCount(); ++i) {
      Shuffler.shuffle(copy);
    }
    itemQueue=new ConcurrentLinkedQueue<CategoryItem>();
    for (    CategoryItem item : copy) {
      itemQueue.add(item);
    }
    mediator.setSession(session);
    setupCenterButton();
    setFrameTitle();
    refreshGui();
    setupTimer();
    enableButtons();
  }
}",0.9787234042553192
180442,"private JPanel setupMainPanel(){
  JPanel panel=new JPanel();
  panel.setLayout(new BorderLayout());
  JPanel southPanel=new JPanel();
  attending=new JCheckBox(attendingAction);
  southPanel.add(attending);
  JButton responseButton=new JButton(independentAction);
  southPanel.add(responseButton);
  responseButton=new JButton(verbalAction);
  southPanel.add(responseButton);
  responseButton=new JButton(modelingAction);
  southPanel.add(responseButton);
  responseButton=new JButton(noAnswerAction);
  southPanel.add(responseButton);
  panel.add(southPanel,BorderLayout.SOUTH);
  byte[] imageData=null;
  try {
    imageData=readImageDataFromClasspath(""String_Node_Str"",17833);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  ImageIcon ii=null;
  if (null != imageData) {
    ii=new ImageIcon(imageData);
  }
  if (null == imageData) {
    try {
      ii=new ImageIcon(new URL(""String_Node_Str""));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  centerButton=new JButton(ii);
  panel.add(centerButton,BorderLayout.CENTER);
  return panel;
}","private JPanel setupMainPanel(){
  JPanel panel=new JPanel();
  panel.setLayout(new BorderLayout());
  JPanel southPanel=new JPanel();
  attending=new JCheckBox(attendingAction);
  southPanel.add(attending);
  lstButtons=new ArrayList<JComponent>();
  lstButtons.add(attending);
  addButton(southPanel,independentAction);
  addButton(southPanel,verbalAction);
  addButton(southPanel,modelingAction);
  addButton(southPanel,noAnswerAction);
  panel.add(southPanel,BorderLayout.SOUTH);
  byte[] imageData=null;
  try {
    imageData=readImageDataFromClasspath(""String_Node_Str"",17833);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
  iiSmilingFace=null;
  if (null != imageData) {
    iiSmilingFace=new ImageIcon(imageData);
  }
  if (null == imageData) {
    try {
      iiSmilingFace=new ImageIcon(new URL(""String_Node_Str""));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  centerButton=new JButton(iiSmilingFace);
  panel.add(centerButton,BorderLayout.CENTER);
  return panel;
}",0.6648326455754241
180443,"public Gui(){
  String tmpDirStr=""String_Node_Str"";
  tmpDir=new File(tmpDirStr);
  tmpDir.mkdirs();
  mediator=new Mediator(this);
  setupActions(mediator);
  mainPanel=setupMainPanel();
  frame=new JFrame(frameTitle);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.getContentPane().add(mainPanel);
  setupMenus();
}","public Gui(){
  String tmpDirStr=""String_Node_Str"";
  tmpDir=new File(tmpDirStr);
  tmpDir.mkdirs();
  mediator=new Mediator(this);
  setupActions(mediator);
  mainPanel=setupMainPanel();
  frame=new JFrame(frameTitle);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.getContentPane().add(mainPanel);
  setupMenus();
  disableButtons();
}",0.9709302325581396
180444,"public void setupTimer(){
  timer=new Timer(session.getTimeDelayAnswer(),timerAction);
  timer.setInitialDelay(session.getTimeDelayPrompt());
  timer.setRepeats(true);
  timer.start();
}","public void setupTimer(){
  timer=new Timer(session.getTimeDelayAnswer() * 1000,timerAction);
  timer.setInitialDelay(session.getTimeDelayPrompt() * 1000);
  timer.setRepeats(true);
  timer.start();
}",0.9637305699481864
180445,"public void execute(int action){
  boolean hit=false;
switch (action) {
case ATTENDING:
    break;
case INDEPENDENT:
  collector.addResponse(item,gui.getAttending().isSelected(),RespType.INDEPENDANT);
hit=true;
break;
case VERBAL:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.VERBAL);
hit=true;
break;
case MODELING:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.MODEL);
hit=true;
break;
case NO_ANSWER:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.NONE);
hit=true;
break;
case QUIT:
System.exit(0);
break;
case TIMER:
timer();
break;
case OPEN:
gui.openSession();
break;
case OPEN_HTTP:
gui.openHttpSession();
break;
}
if (hit) {
if (gui.getItemQueue().size() == 0) {
String fileName=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
try {
File csvFile=new File(fileName);
CSVWriter csvWriter=new CSVWriter(new FileWriter(csvFile,true));
SessionData data=collector.getData();
data.write(csvWriter);
csvWriter.close();
System.out.println(""String_Node_Str"" + csvFile);
}
 catch (IOException e) {
log.error(String.format(""String_Node_Str"",fileName),e);
e.printStackTrace();
}
System.exit(0);
}
 else {
item=gui.getItemQueue().remove();
gui.switchImage(item.getImgFile());
gui.getTimer().start();
}
}
}","public void execute(int action){
  boolean hit=false;
switch (action) {
case ATTENDING:
    break;
case INDEPENDENT:
  collector.addResponse(item,gui.getAttending().isSelected(),RespType.INDEPENDANT);
hit=true;
break;
case VERBAL:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.VERBAL);
hit=true;
break;
case MODELING:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.MODEL);
hit=true;
break;
case NO_ANSWER:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.NONE);
hit=true;
break;
case QUIT:
System.exit(0);
break;
case TIMER:
timer();
break;
case OPEN:
gui.openSession();
break;
case OPEN_HTTP:
gui.openHttpSession();
break;
}
if (hit) {
if (gui.getItemQueue().size() == 0) {
String fileName=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
try {
File csvFile=new File(fileName);
CSVWriter csvWriter=new CSVWriter(new FileWriter(csvFile,true));
SessionData data=collector.getData();
data.write(csvWriter);
csvWriter.close();
System.out.println(""String_Node_Str"" + csvFile);
}
 catch (IOException e) {
log.error(String.format(""String_Node_Str"",fileName),e);
e.printStackTrace();
}
gui.backToStartScreen();
}
 else {
item=gui.getItemQueue().remove();
gui.switchImage(item.getImgFile());
gui.getTimer().start();
}
}
}",0.9863334634908238
180446,"public void backToStartScreen(){
  centerButton.setIcon(iiSmilingFace);
  refreshGui();
  disableButtons();
}","public void backToStartScreen(){
  frame.setTitle(frameTitle);
  centerButton.setIcon(iiSmilingFace);
  refreshGui();
  disableButtons();
}",0.8790322580645161
180447,"public void setupTimer(){
  timer=new Timer(session.getTimeDelayAnswer() * 1000,timerAction);
  timer.setInitialDelay(session.getTimeDelayPrompt() * 1000);
  timer.setRepeats(true);
  timer.start();
}","public void setupTimer(){
  if (null != timer) {
    timer.stop();
  }
  timer=new Timer(session.getTimeDelayAnswer() * 1000,timerAction);
  timer.setInitialDelay(session.getTimeDelayPrompt() * 1000);
  timer.setRepeats(true);
  timer.start();
}",0.898876404494382
180448,"private void displayClickToBegin(){
  centerButton.setEnabled(true);
  centerButton.setIcon(iiSmilingFaceClickToBegin);
  centerButton.setText(""String_Node_Str"");
  centerButton.invalidate();
  refreshGui();
}","private void displayClickToBegin(){
  centerButton.setEnabled(true);
  centerButton.addActionListener(this);
  centerButton.setIcon(iiSmilingFaceClickToBegin);
  centerButton.setText(""String_Node_Str"");
  centerButton.invalidate();
  refreshGui();
}",0.9126637554585152
180449,"public void execute(int action){
  boolean hit=false;
switch (action) {
case ATTENDING:
    break;
case INDEPENDENT:
  collector.addResponse(item,gui.getAttending().isSelected(),RespType.INDEPENDANT);
hit=true;
break;
case VERBAL:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.VERBAL);
hit=true;
break;
case MODELING:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.MODEL);
hit=true;
break;
case NO_ANSWER:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.NONE);
hit=true;
break;
case QUIT:
System.exit(0);
break;
case TIMER:
timer();
break;
case OPEN:
gui.openSession();
break;
case OPEN_HTTP:
gui.openHttpSession();
break;
}
if (hit) {
if (gui.getItemQueue().size() == 0) {
String fileName=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
try {
File csvFile=new File(fileName);
CSVWriter csvWriter=new CSVWriter(new FileWriter(csvFile,true));
SessionData data=collector.getData();
data.write(csvWriter);
csvWriter.close();
System.out.println(""String_Node_Str"" + csvFile);
}
 catch (IOException e) {
log.error(String.format(""String_Node_Str"",fileName),e);
e.printStackTrace();
}
gui.backToStartScreen();
}
 else {
item=gui.getItemQueue().remove();
gui.switchImage(item.getImgFile());
gui.getTimer().start();
}
}
}","public void execute(int action){
  boolean hit=false;
switch (action) {
case ATTENDING:
    break;
case INDEPENDENT:
  collector.addResponse(item,gui.getAttending().isSelected(),RespType.INDEPENDANT);
hit=true;
break;
case VERBAL:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.VERBAL);
hit=true;
break;
case MODELING:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.MODEL);
hit=true;
break;
case NO_ANSWER:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.NONE);
hit=true;
break;
case QUIT:
System.exit(0);
break;
case TIMER:
timer();
break;
case OPEN:
gui.openSession();
break;
case OPEN_HTTP:
gui.openHttpSession();
break;
}
if (hit) {
gui.getTimer().stop();
if (gui.getItemQueue().size() == 0) {
String fileName=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
try {
File csvFile=new File(fileName);
CSVWriter csvWriter=new CSVWriter(new FileWriter(csvFile,true));
SessionData data=collector.getData();
data.write(csvWriter);
csvWriter.close();
System.out.println(""String_Node_Str"" + csvFile);
}
 catch (IOException e) {
log.error(String.format(""String_Node_Str"",fileName),e);
e.printStackTrace();
}
gui.backToStartScreen();
gui.getTimer().stop();
}
 else {
item=gui.getItemQueue().remove();
gui.switchImage(item.getImgFile());
gui.getTimer().start();
}
}
}",0.9824159021406728
180450,"public void execute(int action){
  boolean hit=false;
switch (action) {
case ATTENDING:
    break;
case INDEPENDENT:
  collector.addResponse(item,gui.getAttending().isSelected(),RespType.INDEPENDANT);
hit=true;
break;
case VERBAL:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.VERBAL);
hit=true;
break;
case MODELING:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.MODEL);
hit=true;
break;
case NO_ANSWER:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.NONE);
hit=true;
break;
case QUIT:
System.exit(0);
break;
case TIMER:
timer();
break;
case SHOW_LOGGING_FRAME:
gui.showLoggingFrame();
break;
case OPEN:
gui.openSession();
break;
case OPEN_HTTP:
gui.openHttpSession();
break;
}
if (hit) {
gui.getTimer().stop();
stopSound();
if (gui.getItemQueue().size() == 0) {
gui.populateSessionName();
gui.populateSessionDataFile();
File csvFile=null;
try {
csvFile=gui.getSession().getSessionDataFile();
boolean writeHeader=!csvFile.exists();
CSVWriter csvWriter=new CSVWriter(new FileWriter(csvFile,true));
SessionData data=collector.getData();
if (writeHeader) {
data.writeSummaryHeader(csvWriter);
}
data.writeSummary(csvWriter);
csvWriter.close();
File session=new File(csvFile.getParentFile(),data.getOverall().getName() + ""String_Node_Str"");
CSVWriter writer=new CSVWriter(new FileWriter(session));
data.writeSessionFile(writer);
writer.close();
System.out.println(""String_Node_Str"" + csvFile);
}
 catch (IOException e) {
log.error(String.format(""String_Node_Str"",csvFile.getAbsolutePath()),e);
e.printStackTrace();
}
gui.backToStartScreen();
gui.getTimer().stop();
}
 else {
item=gui.getItemQueue().remove();
gui.switchImage(item.getImg());
gui.getTimer().start();
}
}
}","public void execute(int action){
  boolean hit=false;
switch (action) {
case ATTENDING:
    break;
case INDEPENDENT:
  collector.addResponse(item,gui.getAttending().isSelected(),RespType.INDEPENDANT);
hit=true;
break;
case VERBAL:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.VERBAL);
hit=true;
break;
case MODELING:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.MODEL);
hit=true;
break;
case NO_ANSWER:
collector.addResponse(item,gui.getAttending().isSelected(),RespType.NONE);
hit=true;
break;
case QUIT:
System.exit(0);
break;
case TIMER:
timer();
break;
case SHOW_LOGGING_FRAME:
gui.showLoggingFrame();
break;
case OPEN:
gui.openSession();
break;
case OPEN_HTTP:
gui.openHttpSession();
break;
}
if (hit) {
gui.getTimer().stop();
stopSound();
playPrompt=true;
if (gui.getItemQueue().size() == 0) {
gui.populateSessionName();
gui.populateSessionDataFile();
File csvFile=null;
try {
csvFile=gui.getSession().getSessionDataFile();
boolean writeHeader=!csvFile.exists();
CSVWriter csvWriter=new CSVWriter(new FileWriter(csvFile,true));
SessionData data=collector.getData();
if (writeHeader) {
data.writeSummaryHeader(csvWriter);
}
data.writeSummary(csvWriter);
csvWriter.close();
File session=new File(csvFile.getParentFile(),data.getOverall().getName() + ""String_Node_Str"");
CSVWriter writer=new CSVWriter(new FileWriter(session));
data.writeSessionFile(writer);
writer.close();
System.out.println(""String_Node_Str"" + csvFile);
}
 catch (IOException e) {
log.error(String.format(""String_Node_Str"",csvFile.getAbsolutePath()),e);
e.printStackTrace();
}
gui.backToStartScreen();
gui.getTimer().stop();
}
 else {
item=gui.getItemQueue().remove();
gui.switchImage(item.getImg());
gui.getTimer().start();
}
}
}",0.9951163458776212
180451,"public void useNewSession(){
  centerButton.removeActionListener(this);
  clickToStartButton.setEnabled(false);
  clickToStartButton.setForeground(Color.white);
  if (null != session) {
    CategoryItem[] copy=Arrays.copyOf(session.getItems(),session.getItems().length);
    for (int i=0; i < session.getShuffleCount(); ++i) {
      Shuffler.shuffle(copy);
    }
    itemQueue=new ConcurrentLinkedQueue<CategoryItem>();
    for (    CategoryItem item : copy) {
      itemQueue.add(item);
    }
    mediator.setSession(session);
    setupCenterButton();
    setFrameTitle();
    refreshGui();
    setupTimer();
    enableButtons();
  }
}","public void useNewSession(){
  if (bDebounce) {
    return;
  }
  bDebounce=true;
  centerButton.removeActionListener(this);
  clickToStartButton.setEnabled(false);
  clickToStartButton.setForeground(Color.white);
  if (null != session) {
    CategoryItem[] copy=Arrays.copyOf(session.getItems(),session.getItems().length);
    for (int i=0; i < session.getShuffleCount(); ++i) {
      Shuffler.shuffle(copy);
    }
    itemQueue=new ConcurrentLinkedQueue<CategoryItem>();
    for (    CategoryItem item : copy) {
      itemQueue.add(item);
    }
    itemQueue.add(copy[copy.length - 1]);
    totalItemCount=itemQueue.size() - 1;
    mediator.setSession(session);
    setupCenterButton();
    setFrameTitle();
    refreshGui();
    setupTimer();
    enableButtons();
  }
}",0.9034090909090908
180452,"private void setFrameTitle(){
  frame.setTitle(frameTitle + String.format(""String_Node_Str"",itemQueue.size() + 1,session.getItems().length));
}","private void setFrameTitle(){
  frame.setTitle(frameTitle + String.format(""String_Node_Str"",shownItemCount++,totalItemCount));
}",0.7970479704797048
180453,"public void actionPerformed(ActionEvent e){
  if (clickToStartButton == e.getSource()) {
    useNewSession();
  }
 else   if (BROWSE_SESSION_DATA_FILE.equals(e.getActionCommand())) {
    chooseSessionDataFile();
  }
}","public void actionPerformed(ActionEvent e){
  if ((clickToStartButton == e.getSource()) || (centerButton == e.getSource())) {
    useNewSession();
  }
 else   if (BROWSE_SESSION_DATA_FILE.equals(e.getActionCommand())) {
    chooseSessionDataFile();
  }
}",0.921443736730361
180454,"public void openHttpSession(){
  String[] possibilities={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  if (null != codeBaseUrl) {
    possibilities=readPossiblitiesFromUrl(codeBaseUrl,""String_Node_Str"");
  }
  String s=(String)JOptionPane.showInputDialog(frame,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,possibilities,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + s);
  unpackToTempDirectory(s);
}","public void openHttpSession(){
  bDebounce=false;
  String[] possibilities={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  if (null != codeBaseUrl) {
    possibilities=readPossiblitiesFromUrl(codeBaseUrl,""String_Node_Str"");
  }
  String s=(String)JOptionPane.showInputDialog(frame,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,possibilities,""String_Node_Str"");
  System.out.println(""String_Node_Str"" + s);
  unpackToTempDirectory(s);
}",0.9808274470232088
180455,"private void displayClickToBegin(){
  centerButton.setEnabled(true);
  centerButton.setIcon(iiSmilingFaceClickToBegin);
  centerButton.invalidate();
  clickToStartButton.setEnabled(true);
  clickToStartButton.setForeground(Color.red);
  refreshGui();
}","private void displayClickToBegin(){
  centerButton.setEnabled(true);
  centerButton.addActionListener(this);
  centerButton.setIcon(iiSmilingFaceClickToBegin);
  centerButton.invalidate();
  clickToStartButton.setEnabled(true);
  clickToStartButton.setForeground(Color.red);
  refreshGui();
}",0.9264705882352942
180456,"public void openSession(){
  File file;
  JFileChooser chooser=new JFileChooser(new File(""String_Node_Str""));
  int returnVal=chooser.showOpenDialog(frame);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    file=chooser.getSelectedFile();
    try {
      readSessionFile(file);
    }
 catch (    Exception e) {
      JOptionPane.showMessageDialog(frame,String.format(""String_Node_Str"",file,e));
      e.printStackTrace();
    }
  }
  displayClickToBegin();
}","public void openSession(){
  bDebounce=false;
  File file;
  JFileChooser chooser=new JFileChooser(new File(""String_Node_Str""));
  int returnVal=chooser.showOpenDialog(frame);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    file=chooser.getSelectedFile();
    try {
      readSessionFile(file);
    }
 catch (    Exception e) {
      JOptionPane.showMessageDialog(frame,String.format(""String_Node_Str"",file,e));
      e.printStackTrace();
    }
  }
  displayClickToBegin();
}",0.9798515376458112
180457,"public static void main(String[] args) throws Exception {
  Logging.setLoggingDefaults(Level.WARN);
  CommandLineParser parser=new PosixParser();
  Options options=createCommandLineOptions();
  String deviceType=null;
  String port=null;
  Map<String,String> configuration=newHashMap();
  DeviceMacReferenceMap deviceMacReferenceMap=null;
  boolean use16BitMode=true;
  try {
    CommandLine line=parser.parse(options,args,true);
    if (line.hasOption('h')) {
      printUsageAndExit(DeviceMacReaderCLI.class,options,0);
    }
    if (line.hasOption('v')) {
      org.apache.log4j.Logger.getRootLogger().setLevel(Level.DEBUG);
    }
    if (line.hasOption('l')) {
      Level level=Level.toLevel(line.getOptionValue('l'));
      org.apache.log4j.Logger.getRootLogger().setLevel(level);
    }
    if (line.hasOption('c')) {
      final String configurationFileString=line.getOptionValue('c');
      final File configurationFile=new File(configurationFileString);
      final Properties configurationProperties=new Properties();
      configurationProperties.load(new FileReader(configurationFile));
      for (      Map.Entry<Object,Object> entry : configurationProperties.entrySet()) {
        configuration.put((String)entry.getKey(),(String)entry.getValue());
      }
    }
    if (line.hasOption('r')) {
      deviceMacReferenceMap=readDeviceMacReferenceMap(line.getOptionValue('r'));
    }
    assertParametersPresent(line,'t','p');
    deviceType=line.getOptionValue('t');
    port=line.getOptionValue('p');
    use16BitMode=!line.hasOption('x');
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e);
    printUsageAndExit(DeviceMacReaderCLI.class,options,EXIT_CODE_INVALID_ARGUMENTS);
  }
  ExecutorService executorService=Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(""String_Node_Str"").build());
  final Injector injector=Guice.createInjector(new DeviceMacReaderModule(executorService,deviceMacReferenceMap,use16BitMode));
  final DeviceMacReader deviceMacReader=injector.getInstance(DeviceMacReader.class);
  String reference=null;
  if (deviceMacReferenceMap != null) {
    final DeviceObserver deviceObserver=injector.getInstance(DeviceObserver.class);
    final ImmutableList<DeviceEvent> events=deviceObserver.getEvents(null);
    for (    DeviceEvent event : events) {
      final boolean samePort=port.equals(event.getDeviceInfo().getPort());
      if (samePort) {
        reference=event.getDeviceInfo().getReference();
      }
    }
  }
  try {
    final MacAddress macAddress=deviceMacReader.readMac(port,deviceType,configuration,reference);
    log.info(""String_Node_Str"",new Object[]{deviceType,port,macAddress});
    System.out.println(macAddress.toHexString());
    System.exit(0);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e,e);
    System.exit(1);
  }
}","public static void main(String[] args) throws Exception {
  Logging.setLoggingDefaults(Level.WARN);
  CommandLineParser parser=new PosixParser();
  Options options=createCommandLineOptions();
  String deviceType=null;
  String port=null;
  Map<String,String> configuration=newHashMap();
  DeviceMacReferenceMap deviceMacReferenceMap=null;
  boolean use16BitMode=true;
  try {
    CommandLine line=parser.parse(options,args,true);
    if (line.hasOption('h')) {
      printUsageAndExit(DeviceMacReaderCLI.class,options,0);
    }
    if (line.hasOption('v')) {
      org.apache.log4j.Logger.getRootLogger().setLevel(Level.DEBUG);
    }
    if (line.hasOption('l')) {
      Level level=Level.toLevel(line.getOptionValue('l'));
      org.apache.log4j.Logger.getRootLogger().setLevel(level);
    }
    if (line.hasOption('c')) {
      final String configurationFileString=line.getOptionValue('c');
      final File configurationFile=new File(configurationFileString);
      final Properties configurationProperties=new Properties();
      configurationProperties.load(new FileReader(configurationFile));
      for (      Map.Entry<Object,Object> entry : configurationProperties.entrySet()) {
        configuration.put((String)entry.getKey(),(String)entry.getValue());
      }
    }
    if (line.hasOption('r')) {
      deviceMacReferenceMap=readDeviceMacReferenceMap(line.getOptionValue('r'));
    }
    assertParametersPresent(line,'t','p');
    deviceType=line.getOptionValue('t');
    port=line.getOptionValue('p');
    use16BitMode=!line.hasOption('x');
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e);
    printUsageAndExit(DeviceMacReaderCLI.class,options,EXIT_CODE_INVALID_ARGUMENTS);
  }
  ExecutorService executorService=Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(""String_Node_Str"").build());
  final Injector injector=Guice.createInjector(new DeviceFactoryModule(),new DeviceMacReaderModule(executorService,deviceMacReferenceMap,use16BitMode));
  final DeviceMacReader deviceMacReader=injector.getInstance(DeviceMacReader.class);
  String reference=null;
  if (deviceMacReferenceMap != null) {
    final DeviceObserver deviceObserver=injector.getInstance(DeviceObserver.class);
    final ImmutableList<DeviceEvent> events=deviceObserver.getEvents(null);
    for (    DeviceEvent event : events) {
      final boolean samePort=port.equals(event.getDeviceInfo().getPort());
      if (samePort) {
        reference=event.getDeviceInfo().getReference();
      }
    }
  }
  try {
    final MacAddress macAddress=deviceMacReader.readMac(port,deviceType,configuration,reference);
    log.info(""String_Node_Str"",new Object[]{deviceType,port,macAddress});
    System.out.println(macAddress.toHexString());
    System.exit(0);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e,e);
    System.exit(1);
  }
}",0.995438596491228
180458,"public static void main(String[] args) throws Exception {
  Logging.setLoggingDefaults(Level.WARN);
  CommandLineParser parser=new PosixParser();
  Options options=createCommandLineOptions();
  String deviceType=null;
  String port=null;
  String macAddressLower16String=null;
  Map<String,String> configuration=newHashMap();
  boolean use16BitMode=true;
  try {
    CommandLine line=parser.parse(options,args,true);
    if (line.hasOption('h')) {
      printUsageAndExit(DeviceMacWriterCLI.class,options,0);
    }
    if (line.hasOption('v')) {
      org.apache.log4j.Logger.getRootLogger().setLevel(Level.DEBUG);
    }
    if (line.hasOption('l')) {
      Level level=Level.toLevel(line.getOptionValue('l'));
      org.apache.log4j.Logger.getRootLogger().setLevel(level);
    }
    if (line.hasOption('c')) {
      final String configurationFileString=line.getOptionValue('c');
      final File configurationFile=new File(configurationFileString);
      final Properties configurationProperties=new Properties();
      configurationProperties.load(new FileReader(configurationFile));
      for (      Map.Entry<Object,Object> entry : configurationProperties.entrySet()) {
        configuration.put((String)entry.getKey(),(String)entry.getValue());
      }
    }
    assertParametersPresent(line,'t','p','m');
    deviceType=line.getOptionValue('t');
    port=line.getOptionValue('p');
    macAddressLower16String=line.getOptionValue('m');
    use16BitMode=!line.hasOption('x');
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e);
    printUsageAndExit(DeviceMacWriterCLI.class,options,1);
  }
  long macAddressLower16=StringUtils.parseHexOrDecLong(macAddressLower16String);
  final MacAddress macAddress=new MacAddress(new byte[]{0,0,0,0,0,0,(byte)(0xFF & (macAddressLower16 >> 8)),(byte)(0xFF & (macAddressLower16))});
  final ExecutorService executorService=Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(""String_Node_Str"").build());
  final Injector injector=Guice.createInjector(new DeviceUtilsModule(executorService,null,use16BitMode));
  final Device device=injector.getInstance(DeviceFactory.class).create(executorService,deviceType,configuration);
  device.connect(port);
  if (!device.isConnected()) {
    throw new RuntimeException(""String_Node_Str"" + args[1] + ""String_Node_Str"");
  }
  final String finalDeviceType=deviceType;
  final String finalPort=port;
  OperationListener<Void> callback=new OperationListener<Void>(){
    private int lastProgress=-1;
    @Override public void onProgressChange(    float fraction){
      int newProgress=(int)Math.floor(fraction * 100);
      if (lastProgress < newProgress) {
        lastProgress=newProgress;
        log.info(""String_Node_Str"",newProgress);
      }
    }
    @Override public void onSuccess(    Void result){
      log.info(""String_Node_Str"",new Object[]{macAddress,finalDeviceType,finalPort});
    }
    @Override public void onFailure(    Throwable throwable){
      log.error(""String_Node_Str"" + throwable,throwable);
    }
    @Override public void onExecute(){
      log.info(""String_Node_Str"");
    }
    @Override public void onCancel(){
      log.info(""String_Node_Str"");
    }
    @Override public void beforeStateChanged(    final StateChangedEvent<Void> stateChangedEvent){
      log.info(""String_Node_Str"",stateChangedEvent);
    }
    @Override public void afterStateChanged(    final StateChangedEvent<Void> stateChangedEvent){
      log.info(""String_Node_Str"",stateChangedEvent);
    }
  }
;
  try {
    device.writeMac(macAddress,120000,callback).get();
  }
  finally {
    closeConnection(device,executorService);
  }
}","public static void main(String[] args) throws Exception {
  Logging.setLoggingDefaults(Level.WARN);
  CommandLineParser parser=new PosixParser();
  Options options=createCommandLineOptions();
  String deviceType=null;
  String port=null;
  String macAddressLower16String=null;
  Map<String,String> configuration=newHashMap();
  boolean use16BitMode=true;
  try {
    CommandLine line=parser.parse(options,args,true);
    if (line.hasOption('h')) {
      printUsageAndExit(DeviceMacWriterCLI.class,options,0);
    }
    if (line.hasOption('v')) {
      org.apache.log4j.Logger.getRootLogger().setLevel(Level.DEBUG);
    }
    if (line.hasOption('l')) {
      Level level=Level.toLevel(line.getOptionValue('l'));
      org.apache.log4j.Logger.getRootLogger().setLevel(level);
    }
    if (line.hasOption('c')) {
      final String configurationFileString=line.getOptionValue('c');
      final File configurationFile=new File(configurationFileString);
      final Properties configurationProperties=new Properties();
      configurationProperties.load(new FileReader(configurationFile));
      for (      Map.Entry<Object,Object> entry : configurationProperties.entrySet()) {
        configuration.put((String)entry.getKey(),(String)entry.getValue());
      }
    }
    assertParametersPresent(line,'t','p','m');
    deviceType=line.getOptionValue('t');
    port=line.getOptionValue('p');
    macAddressLower16String=line.getOptionValue('m');
    use16BitMode=!line.hasOption('x');
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e);
    printUsageAndExit(DeviceMacWriterCLI.class,options,1);
  }
  long macAddressLower16=StringUtils.parseHexOrDecLong(macAddressLower16String);
  final MacAddress macAddress=new MacAddress(new byte[]{0,0,0,0,0,0,(byte)(0xFF & (macAddressLower16 >> 8)),(byte)(0xFF & (macAddressLower16))});
  final ExecutorService executorService=Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(""String_Node_Str"").build());
  final Injector injector=Guice.createInjector(new DeviceFactoryModule(),new DeviceUtilsModule(executorService,null,use16BitMode));
  final Device device=injector.getInstance(DeviceFactory.class).create(executorService,deviceType,configuration);
  device.connect(port);
  if (!device.isConnected()) {
    throw new RuntimeException(""String_Node_Str"" + args[1] + ""String_Node_Str"");
  }
  final String finalDeviceType=deviceType;
  final String finalPort=port;
  OperationListener<Void> callback=new OperationListener<Void>(){
    private int lastProgress=-1;
    @Override public void onProgressChange(    float fraction){
      int newProgress=(int)Math.floor(fraction * 100);
      if (lastProgress < newProgress) {
        lastProgress=newProgress;
        log.info(""String_Node_Str"",newProgress);
      }
    }
    @Override public void onSuccess(    Void result){
      log.info(""String_Node_Str"",new Object[]{macAddress,finalDeviceType,finalPort});
    }
    @Override public void onFailure(    Throwable throwable){
      log.error(""String_Node_Str"" + throwable,throwable);
    }
    @Override public void onExecute(){
      log.info(""String_Node_Str"");
    }
    @Override public void onCancel(){
      log.info(""String_Node_Str"");
    }
    @Override public void beforeStateChanged(    final StateChangedEvent<Void> stateChangedEvent){
      log.info(""String_Node_Str"",stateChangedEvent);
    }
    @Override public void afterStateChanged(    final StateChangedEvent<Void> stateChangedEvent){
      log.info(""String_Node_Str"",stateChangedEvent);
    }
  }
;
  try {
    device.writeMac(macAddress,120000,callback).get();
  }
  finally {
    closeConnection(device,executorService);
  }
}",0.996448087431694
180459,"private MacAddress readMacFromDevice(final String port,final DeviceType deviceType) throws Exception {
  final Connection connection=connectionFactory.create(deviceType);
  connection.connect(port);
  if (!connection.isConnected()) {
    throw new Exception(""String_Node_Str"" + port + ""String_Node_Str"");
  }
  try {
    final Device device=deviceFactory.create(deviceType,connection);
    final ReadMacAddressOperation readMacAddressOperation=device.createReadMacAddressOperation();
    MacAddress macAddress=readMacAddressOperation.execute(new RootProgressManager(new Monitor(){
      private int lastProgress=-1;
      @Override public void onProgressChange(      final float fraction){
        int newProgress=(int)Math.floor(fraction * 100);
        if (lastProgress < newProgress) {
          lastProgress=newProgress;
          log.debug(""String_Node_Str"",newProgress);
        }
      }
    }
));
    if (use16BitMode) {
      macAddress=macAddress.to16BitMacAddress();
    }
    return macAddress;
  }
  finally {
    Closeables.closeQuietly(connection);
  }
}","private MacAddress readMacFromDevice(final String port,final DeviceType deviceType) throws Exception {
  final Connection connection=connectionFactory.create(deviceType);
  try {
    connection.connect(port);
  }
 catch (  Exception e) {
    throw new Exception(""String_Node_Str"" + port + ""String_Node_Str""+ e.getMessage());
  }
  if (!connection.isConnected()) {
    throw new Exception(""String_Node_Str"" + port + ""String_Node_Str"");
  }
  try {
    final Device device=deviceFactory.create(deviceType,connection);
    final ReadMacAddressOperation readMacAddressOperation=device.createReadMacAddressOperation();
    MacAddress macAddress=readMacAddressOperation.execute(new RootProgressManager(new Monitor(){
      private int lastProgress=-1;
      @Override public void onProgressChange(      final float fraction){
        int newProgress=(int)Math.floor(fraction * 100);
        if (lastProgress < newProgress) {
          lastProgress=newProgress;
          log.debug(""String_Node_Str"",newProgress);
        }
      }
    }
));
    if (use16BitMode) {
      macAddress=macAddress.to16BitMacAddress();
    }
    return macAddress;
  }
  finally {
    Closeables.closeQuietly(connection);
  }
}",0.9426807760141094
180460,"@Override public void actionPerformed(ActionEvent ae){
  Transformer<P2PVertex,Shape> shapeTransformer=getRenderContext().getVertexShapeTransformer();
  if (shapeTransformer.getClass().equals(P2PVertexShapeTransformer.class)) {
    P2PVertexShapeTransformer<P2PVertex,P2PConnection> scalableTransformer=(P2PVertexShapeTransformer<P2PVertex,P2PConnection>)shapeTransformer;
    if (((JCheckBox)ae.getSource()).isSelected()) {
      scalableTransformer.setScaling(true);
    }
 else {
      scalableTransformer.setScaling(false);
    }
  }
  repaint();
}","@Override public void actionPerformed(ActionEvent ae){
  setScaling(((JCheckBox)ae.getSource()).isSelected());
}",0.3313253012048193
180461,"public void setCollapsedPeerAndDocumentView(){
  setName(""String_Node_Str"");
  getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(getPickedVertexState()));
  getRenderContext().setVertexIncludePredicate(new ExclusiveVertexInOtherGraphPredicate(graph.getDynamicGraph(),PeerDocumentVertex.class));
  setSpecialTransformers(VertexShapeType.ELLIPSE,VertexShapeType.PENTAGON,VertexShapeType.RECTANGLE,EdgeShapeType.QUAD_CURVE,EdgeShapeType.CUBIC_CURVE,EdgeShapeType.LINE,EdgeShapeType.LINE);
  repaint();
}","public void setCollapsedPeerAndDocumentView(){
  setName(""String_Node_Str"");
  getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(getPickedVertexState()));
  getRenderContext().setVertexIncludePredicate(new ExclusiveVertexInOtherGraphPredicate(graph.getDynamicGraph(),PeerDocumentVertex.class));
  setSpecialTransformers(VertexShapeType.ELLIPSE,VertexShapeType.PENTAGON,VertexShapeType.RECTANGLE,EdgeShapeType.QUAD_CURVE,EdgeShapeType.CUBIC_CURVE,EdgeShapeType.LINE,EdgeShapeType.LINE);
  setScaling();
  repaint();
}",0.9722735674676524
180462,"public void setCollapsedPeerView(){
  setName(""String_Node_Str"");
  getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(getPickedVertexState()));
  getRenderContext().setVertexIncludePredicate(new ExclusiveVertexInOtherGraphPredicate(graph.getDynamicGraph(),DocumentVertex.class));
  setSpecialTransformers(VertexShapeType.ELLIPSE,VertexShapeType.PENTAGON,VertexShapeType.RECTANGLE,EdgeShapeType.QUAD_CURVE,EdgeShapeType.CUBIC_CURVE,EdgeShapeType.LINE,EdgeShapeType.LINE);
  repaint();
}","public void setCollapsedPeerView(){
  setName(""String_Node_Str"");
  getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(getPickedVertexState()));
  getRenderContext().setVertexIncludePredicate(new ExclusiveVertexInOtherGraphPredicate(graph.getDynamicGraph(),DocumentVertex.class));
  setSpecialTransformers(VertexShapeType.ELLIPSE,VertexShapeType.PENTAGON,VertexShapeType.RECTANGLE,EdgeShapeType.QUAD_CURVE,EdgeShapeType.CUBIC_CURVE,EdgeShapeType.LINE,EdgeShapeType.LINE);
  setScaling();
  repaint();
}",0.9714828897338404
180463,"public void setCollapsedDocumentView(){
  setName(""String_Node_Str"");
  getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(getPickedVertexState(),Color.RED,Color.YELLOW,Color.MAGENTA,Color.RED,Color.RED,Color.BLUE));
  getRenderContext().setVertexShapeTransformer(new P2PVertexShapeTransformer<P2PVertex,P2PConnection>(graph.getReferenceGraph(),VertexShapeType.ELLIPSE,VertexShapeType.PENTAGON,VertexShapeType.ELLIPSE,P2PVertexShapeTransformer.PEER_SIZE,P2PVertexShapeTransformer.DOC_SIZE,P2PVertexShapeTransformer.PEER_SIZE));
  getRenderContext().setEdgeShapeTransformer(new P2PEdgeShapeTransformer(EdgeShapeType.QUAD_CURVE,EdgeShapeType.CUBIC_CURVE,EdgeShapeType.LINE,EdgeShapeType.LINE));
  getRenderContext().setVertexIncludePredicate(new ExclusiveVertexInOtherGraphPredicate(graph.getDynamicGraph(),PeerVertex.class));
  repaint();
}","public void setCollapsedDocumentView(){
  setName(""String_Node_Str"");
  getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(getPickedVertexState(),Color.RED,Color.YELLOW,Color.MAGENTA,Color.RED,Color.RED,Color.BLUE));
  getRenderContext().setVertexShapeTransformer(new P2PVertexShapeTransformer<P2PVertex,P2PConnection>(graph.getReferenceGraph(),VertexShapeType.ELLIPSE,VertexShapeType.PENTAGON,VertexShapeType.ELLIPSE,P2PVertexShapeTransformer.PEER_SIZE,P2PVertexShapeTransformer.DOC_SIZE,P2PVertexShapeTransformer.PEER_SIZE));
  getRenderContext().setEdgeShapeTransformer(new P2PEdgeShapeTransformer(EdgeShapeType.QUAD_CURVE,EdgeShapeType.CUBIC_CURVE,EdgeShapeType.LINE,EdgeShapeType.LINE));
  getRenderContext().setVertexIncludePredicate(new ExclusiveVertexInOtherGraphPredicate(graph.getDynamicGraph(),PeerVertex.class));
  setScaling();
  repaint();
}",0.9908987485779296
180464,"public JPanel getOptionsPanel(){
  ButtonGroup buttonGroup=new ButtonGroup();
  JPanel viewPanel=new JPanel(new GridLayout(4,1));
  viewPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  ChangeViewListener changeViewListener=new ChangeViewListener(this);
  JRadioButton fullView=new JRadioButton(""String_Node_Str"");
  fullView.addActionListener(changeViewListener);
  viewPanel.add(fullView);
  buttonGroup.add(fullView);
  JRadioButton collapsedPeerView=new JRadioButton(""String_Node_Str"");
  collapsedPeerView.addActionListener(changeViewListener);
  viewPanel.add(collapsedPeerView);
  buttonGroup.add(collapsedPeerView);
  JRadioButton collapsedDocumentView=new JRadioButton(""String_Node_Str"");
  collapsedDocumentView.addActionListener(changeViewListener);
  viewPanel.add(collapsedDocumentView);
  buttonGroup.add(collapsedDocumentView);
  JRadioButton collapsedPeerAndDocumentView=new JRadioButton(""String_Node_Str"");
  collapsedPeerAndDocumentView.addActionListener(changeViewListener);
  viewPanel.add(collapsedPeerAndDocumentView);
  buttonGroup.add(collapsedPeerAndDocumentView);
  if (getName().equals(fullView.getText())) {
    fullView.setSelected(true);
  }
 else   if (getName().equals(collapsedPeerView.getText())) {
    collapsedPeerView.setSelected(true);
  }
 else   if (getName().equals(collapsedDocumentView.getText())) {
    collapsedDocumentView.setSelected(true);
  }
 else   if (getName().equals(collapsedPeerAndDocumentView.getText())) {
    collapsedPeerAndDocumentView.setSelected(true);
  }
  JPanel visualInfo=new JPanel(new GridLayout(1,1));
  visualInfo.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JCheckBox scaleButton=new JCheckBox(""String_Node_Str"");
  scaleButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      Transformer<P2PVertex,Shape> shapeTransformer=getRenderContext().getVertexShapeTransformer();
      if (shapeTransformer.getClass().equals(P2PVertexShapeTransformer.class)) {
        P2PVertexShapeTransformer<P2PVertex,P2PConnection> scalableTransformer=(P2PVertexShapeTransformer<P2PVertex,P2PConnection>)shapeTransformer;
        if (((JCheckBox)ae.getSource()).isSelected()) {
          scalableTransformer.setScaling(true);
        }
 else {
          scalableTransformer.setScaling(false);
        }
      }
      repaint();
    }
  }
);
  visualInfo.add(scaleButton);
  JPanel optionsPanel=new JPanel(new BorderLayout());
  optionsPanel.add(viewPanel,BorderLayout.NORTH);
  optionsPanel.add(visualInfo,BorderLayout.CENTER);
  return optionsPanel;
}","public JPanel getOptionsPanel(){
  ButtonGroup buttonGroup=new ButtonGroup();
  JPanel viewPanel=new JPanel(new GridLayout(4,1));
  viewPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  ChangeViewListener changeViewListener=new ChangeViewListener(this);
  JRadioButton fullView=new JRadioButton(""String_Node_Str"");
  fullView.addActionListener(changeViewListener);
  viewPanel.add(fullView);
  buttonGroup.add(fullView);
  JRadioButton collapsedPeerView=new JRadioButton(""String_Node_Str"");
  collapsedPeerView.addActionListener(changeViewListener);
  viewPanel.add(collapsedPeerView);
  buttonGroup.add(collapsedPeerView);
  JRadioButton collapsedDocumentView=new JRadioButton(""String_Node_Str"");
  collapsedDocumentView.addActionListener(changeViewListener);
  viewPanel.add(collapsedDocumentView);
  buttonGroup.add(collapsedDocumentView);
  JRadioButton collapsedPeerAndDocumentView=new JRadioButton(""String_Node_Str"");
  collapsedPeerAndDocumentView.addActionListener(changeViewListener);
  viewPanel.add(collapsedPeerAndDocumentView);
  buttonGroup.add(collapsedPeerAndDocumentView);
  if (getName().equals(fullView.getText())) {
    fullView.setSelected(true);
  }
 else   if (getName().equals(collapsedPeerView.getText())) {
    collapsedPeerView.setSelected(true);
  }
 else   if (getName().equals(collapsedDocumentView.getText())) {
    collapsedDocumentView.setSelected(true);
  }
 else   if (getName().equals(collapsedPeerAndDocumentView.getText())) {
    collapsedPeerAndDocumentView.setSelected(true);
  }
  JPanel visualInfo=new JPanel(new GridLayout(1,1));
  visualInfo.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JCheckBox scaleButton=new JCheckBox(""String_Node_Str"");
  scaleButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      setScaling(((JCheckBox)ae.getSource()).isSelected());
    }
  }
);
  visualInfo.add(scaleButton);
  JPanel optionsPanel=new JPanel(new BorderLayout());
  optionsPanel.add(viewPanel,BorderLayout.NORTH);
  optionsPanel.add(visualInfo,BorderLayout.CENTER);
  return optionsPanel;
}",0.8957365977205572
180465,"public void setFullView(){
  setName(""String_Node_Str"");
  getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(getPickedVertexState()));
  getRenderContext().setVertexIncludePredicate(new VertexIsInTheOtherGraphPredicate(graph.getDynamicGraph()));
  setSpecialTransformers(VertexShapeType.ELLIPSE,VertexShapeType.PENTAGON,VertexShapeType.RECTANGLE,EdgeShapeType.QUAD_CURVE,EdgeShapeType.CUBIC_CURVE,EdgeShapeType.LINE,EdgeShapeType.LINE);
  repaint();
}","public void setFullView(){
  setName(""String_Node_Str"");
  getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(getPickedVertexState()));
  getRenderContext().setVertexIncludePredicate(new VertexIsInTheOtherGraphPredicate(graph.getDynamicGraph()));
  setSpecialTransformers(VertexShapeType.ELLIPSE,VertexShapeType.PENTAGON,VertexShapeType.RECTANGLE,EdgeShapeType.QUAD_CURVE,EdgeShapeType.CUBIC_CURVE,EdgeShapeType.LINE,EdgeShapeType.LINE);
  setScaling();
  repaint();
}",0.9695121951219512
180466,"/** 
 * Handles popup menu button clicks
 * @param text The text of the button that was just clicked
 */
public void popupMenuEvent(String text){
  if (text.contains((""String_Node_Str""))) {
    PersonalizedVisualizationViewer currentViewer=applet.getCurrentViewer();
    Layout<P2PVertex,P2PConnection> graphLayout=null;
    P2PNetworkGraph graph=applet.getGraph().getReferenceGraph();
    if (text.equals(""String_Node_Str"")) {
      graphLayout=new FRLayout<P2PVertex,P2PConnection>(graph,currentViewer.getSize());
    }
 else     if (text.equals(""String_Node_Str"")) {
      graphLayout=new ISOMLayout<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      graphLayout=new KKLayout<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      graphLayout=new BalloonLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else     if (text.equals(""String_Node_Str"")) {
      graphLayout=new TreeLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else {
      graphLayout=new CircleLayout<P2PVertex,P2PConnection>(graph);
    }
    currentViewer.getModel().setGraphLayout(graphLayout);
    for (    P2PVertex v : graphLayout.getGraph().getVertices()) {
      graphLayout.lock(v,true);
    }
  }
 else   if (text.equals(""String_Node_Str"")) {
    gm.setMode(Mode.PICKING);
  }
 else   if (text.equals(""String_Node_Str"")) {
    gm.setMode(Mode.TRANSFORMING);
  }
 else {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + text,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  setVisible(false);
  setEnabled(false);
}","/** 
 * Handles popup menu button clicks
 * @param text The text of the button that was just clicked
 */
public void popupMenuEvent(String text){
  if (text.contains((""String_Node_Str""))) {
    VisualizationViewer<P2PVertex,P2PConnection> currentViewer=applet.getCurrentViewer();
    Layout<P2PVertex,P2PConnection> currentLayout=currentViewer.getGraphLayout();
    Layout<P2PVertex,P2PConnection> newLayout=null;
    P2PNetworkGraph graph=applet.getGraph().getReferenceGraph();
    if (text.equals(""String_Node_Str"")) {
      newLayout=new FRLayout<P2PVertex,P2PConnection>(graph,currentViewer.getSize());
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new ISOMLayout<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new KKLayout<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new SpringLayout2<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new BalloonLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new RadialTreeLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new TreeLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else {
      newLayout=new CircleLayout<P2PVertex,P2PConnection>(graph);
    }
    newLayout.setInitializer(currentViewer.getGraphLayout());
    newLayout.setSize(currentViewer.getSize());
    LayoutTransition<P2PVertex,P2PConnection> transition=new LayoutTransition<P2PVertex,P2PConnection>(currentViewer,currentLayout,newLayout);
    Animator transitionAnimator=new Animator(transition);
    transitionAnimator.start();
    stopAnimateTimer.schedule(new StopAnimateTask(transitionAnimator,newLayout),5000);
    currentViewer.getRenderContext().getMultiLayerTransformer().setToIdentity();
    currentViewer.repaint();
  }
 else   if (text.equals(""String_Node_Str"")) {
    gm.setMode(Mode.PICKING);
  }
 else   if (text.equals(""String_Node_Str"")) {
    gm.setMode(Mode.TRANSFORMING);
  }
 else {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + text,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  setVisible(false);
  setEnabled(false);
}",0.7132970835392981
180467,"/** 
 * Shows the popup menu on the current viewer
 */
public void showPopupMenu(int x,int y){
  setEnabled(true);
  PersonalizedVisualizationViewer currentViewer=applet.getCurrentViewer();
  if (!currentViewer.getName().equals(""String_Node_Str"")) {
    remove(balloonLayout);
    remove(treeLayout);
  }
 else {
    add(balloonLayout);
    add(treeLayout);
  }
  show(currentViewer,x,y);
}","/** 
 * Shows the popup menu on the current viewer
 */
public void showPopupMenu(int x,int y){
  setEnabled(true);
  PersonalizedVisualizationViewer currentViewer=applet.getCurrentViewer();
  if (!currentViewer.getName().equals(""String_Node_Str"")) {
    remove(treeSeparator);
    remove(balloonLayout);
    remove(treeLayout);
    remove(radialTreeLayout);
  }
 else {
    add(treeSeparator);
    add(balloonLayout);
    add(treeLayout);
    add(radialTreeLayout);
  }
  show(currentViewer,x,y);
}",0.8783783783783784
180468,"public GraphPopupMenu(P2PGraphViewer applet,final DefaultModalGraphMouse<P2PVertex,P2PConnection> gm,ActionListener listener){
  this.applet=applet;
  this.gm=gm;
  JMenuItem picking=new JMenuItem(""String_Node_Str"");
  JMenuItem transforming=new JMenuItem(""String_Node_Str"");
  JMenuItem kkLayout=new JMenuItem(""String_Node_Str"");
  JMenuItem frLayout=new JMenuItem(""String_Node_Str"");
  JMenuItem isomLayout=new JMenuItem(""String_Node_Str"");
  JMenuItem circleLayout=new JMenuItem(""String_Node_Str"");
  balloonLayout=new JMenuItem(""String_Node_Str"");
  treeLayout=new JMenuItem(""String_Node_Str"");
  picking.addActionListener(listener);
  transforming.addActionListener(listener);
  kkLayout.addActionListener(listener);
  frLayout.addActionListener(listener);
  isomLayout.addActionListener(listener);
  circleLayout.addActionListener(listener);
  balloonLayout.addActionListener(listener);
  treeLayout.addActionListener(listener);
  add(""String_Node_Str"").setEnabled(false);
  add(picking);
  add(transforming);
  addSeparator();
  add(""String_Node_Str"").setEnabled(false);
  add(circleLayout);
  add(frLayout);
  add(isomLayout);
  add(kkLayout);
}","public GraphPopupMenu(P2PGraphViewer applet,final DefaultModalGraphMouse<P2PVertex,P2PConnection> gm,ActionListener listener){
  this.applet=applet;
  this.gm=gm;
  JMenuItem picking=new JMenuItem(""String_Node_Str"");
  JMenuItem transforming=new JMenuItem(""String_Node_Str"");
  JMenuItem circleLayout=new JMenuItem(""String_Node_Str"");
  JMenuItem frLayout=new JMenuItem(""String_Node_Str"");
  JMenuItem isomLayout=new JMenuItem(""String_Node_Str"");
  JMenuItem kkLayout=new JMenuItem(""String_Node_Str"");
  JMenuItem springLayout=new JMenuItem(""String_Node_Str"");
  radialTreeLayout=new JMenuItem(""String_Node_Str"");
  balloonLayout=new JMenuItem(""String_Node_Str"");
  treeLayout=new JMenuItem(""String_Node_Str"");
  treeSeparator=new JMenuItem(""String_Node_Str"");
  treeSeparator.setEnabled(false);
  picking.addActionListener(listener);
  transforming.addActionListener(listener);
  kkLayout.addActionListener(listener);
  frLayout.addActionListener(listener);
  isomLayout.addActionListener(listener);
  circleLayout.addActionListener(listener);
  springLayout.addActionListener(listener);
  balloonLayout.addActionListener(listener);
  treeLayout.addActionListener(listener);
  radialTreeLayout.addActionListener(listener);
  add(""String_Node_Str"").setEnabled(false);
  add(picking);
  add(transforming);
  addSeparator();
  add(""String_Node_Str"").setEnabled(false);
  add(circleLayout);
  add(frLayout);
  add(isomLayout);
  add(kkLayout);
  add(springLayout);
  stopAnimateTimer=new Timer(""String_Node_Str"",true);
}",0.6749063670411986
180469,"/** 
 * @param eventToAdd
 * @param events
 */
private void addEventAtProperTime(LogEvent eventToAdd,List<LogEvent> events){
  if (events.isEmpty()) {
    events.add(0,eventToAdd);
  }
 else {
    ListIterator<LogEvent> li=events.listIterator(events.size());
    int index=events.size();
    while (li.hasPrevious()) {
      LogEvent evt=li.previous();
      index--;
      if (evt.getTime() < eventToAdd.getTime() || index == 0) {
        events.add(index,eventToAdd);
        break;
      }
    }
  }
}","/** 
 * Helper method places the passed event into the properly sorted position. ensures the event is placed in the proper position in the list (times match up)
 * @param eventToAdd The event to place into the list.
 * @param events The list which the event will be added to
 */
private static void addEventAtProperTime(LogEvent eventToAdd,List<LogEvent> events){
synchronized (events) {
    if (events.isEmpty()) {
      events.add(0,eventToAdd);
    }
 else {
      ListIterator<LogEvent> li=events.listIterator(events.size());
      int index=events.size();
      while (li.hasPrevious()) {
        LogEvent evt=li.previous();
        if (evt.getTime() < eventToAdd.getTime() || index == 0) {
          events.add(index,eventToAdd);
          break;
        }
        index--;
      }
    }
  }
}",0.5940138142747505
180470,"/** 
 * Helper method adds an ""online"" event into the list of LogEvents The method checks to make sure the event is in the proper position in the list (times match up and index does not go out of bounds)
 * @param events		 The list of LogEvents modifying the graph
 * @param timeToAddEvent The time the event takes place
 * @param peerNumber	 The peer to add the event for
 */
private void addPeerOnlineEvent(List<LogEvent> events,long timeToAddEvent,int peerNumber){
  try {
    LogEvent eventToAdd=new LogEvent(timeToAddEvent,""String_Node_Str"",peerNumber,0,0);
    addEventAtProperTime(eventToAdd,events);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
}","/** 
 * Helper method adds an ""online"" event into the list of LogEvents
 * @param events		 The list of LogEvents modifying the graph
 * @param timeToAddEvent The time the event takes place
 * @param peerNumber	 The peer to add the event for
 */
private static void addPeerOnlineEvent(List<LogEvent> events,long timeToAddEvent,int peerNumber){
  try {
    LogEvent eventToAdd=new LogEvent(timeToAddEvent,""String_Node_Str"",peerNumber,0,0);
    addEventAtProperTime(eventToAdd,events);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
}",0.8926640926640926
180471,"/** 
 * Helper method adds a ""publish"" event into the list of LogEvents The method checks to make sure the event is in the proper position in the list (times match up and index does not go out of bounds)
 * @param events		 The list of LogEvents modifying the graph
 * @param currentIndex	 The index which the current event is located 
 * @param timeToAddEvent The time the event takes place
 * @param peerNumber	 The peer who publishes the document in the event
 * @param documentNumber the Document to be published in the event
 */
private void addDocumentPublish(List<LogEvent> events,long timeToAddEvent,int peerNumber,int documentNumber){
  try {
    LogEvent eventToAdd=new LogEvent(timeToAddEvent,""String_Node_Str"",peerNumber,documentNumber,0);
    addEventAtProperTime(eventToAdd,events);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
}","/** 
 * Helper method adds a ""publish"" event into the list of LogEvents
 * @param events		 The list of LogEvents modifying the graph
 * @param timeToAddEvent The time the event takes place
 * @param peerNumber	 The peer who publishes the document in the event
 * @param documentNumber the Document to be published in the event
 */
private static void addDocumentPublish(List<LogEvent> events,long timeToAddEvent,int peerNumber,int documentNumber){
  try {
    LogEvent eventToAdd=new LogEvent(timeToAddEvent,""String_Node_Str"",peerNumber,documentNumber,0);
    addEventAtProperTime(eventToAdd,events);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
}",0.8694565896314803
180472,"@Override public synchronized void incomingLogEvents(InputStream inStream){
  try {
    eventThread.pause();
    List<LogEvent> events;
synchronized (fullGraph) {
      events=P2PNetworkGraphLoader.buildLogs(inStream,networkClient,fullGraph);
    }
    if (!events.isEmpty()) {
      networkClient.setLatestTime(events.get(events.size() - 1).getTime());
      events.add(LogEvent.getEndEvent(events.get(events.size() - 1)));
      for (int i=0; i < events.size(); i++) {
        fullGraph.robustGraphEvent(events,i);
      }
      eventThread.addEvents(events);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Override public synchronized void incomingLogEvents(InputStream inStream){
  try {
    eventThread.pause();
    List<LogEvent> events;
synchronized (fullGraph) {
      events=P2PNetworkGraphLoader.buildLogs(inStream,networkClient,fullGraph);
    }
    if (!events.isEmpty()) {
      for (int i=0; i < events.size(); i++) {
        fullGraph.robustGraphEvent(events,i);
      }
      events.add(LogEvent.getEndEvent(events.get(events.size() - 1)));
      eventThread.addEvents(events);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.8149405772495756
180473,"public static P2PNetworkGraphLoader buildGraph(InputStream inStream,HTTPClient client) throws JDOMException, IOException {
  SAXBuilder parser=new SAXBuilder();
  Document doc=parser.build(inStream);
  client.setLatestTime(doc.getRootElement().getAttribute(""String_Node_Str"").getLongValue());
  P2PNetworkGraphLoader loader=new P2PNetworkGraphLoader();
  loader.logList.add(0,LogEvent.getStartEvent());
  loader.logList.add(LogEvent.getEndEvent(loader.logList.get(loader.logList.size() - 1)));
  loader.graphBuilder(doc);
  return loader;
}","public static P2PNetworkGraphLoader buildGraph(InputStream inStream,HTTPClient client) throws JDOMException, IOException {
  SAXBuilder parser=new SAXBuilder();
  Document doc=parser.build(inStream);
  long currentTime=doc.getRootElement().getAttribute(""String_Node_Str"").getLongValue();
  client.setZeroTime(currentTime);
  P2PNetworkGraphLoader loader=new P2PNetworkGraphLoader();
  loader.logList.add(0,LogEvent.getStartEvent());
  loader.logList.add(LogEvent.getEndEvent(loader.logList.get(loader.logList.size() - 1)));
  loader.graphBuilder(doc);
  return loader;
}",0.9441441441441442
180474,"public static List<LogEvent> buildLogs(InputStream inStream,HTTPClient client,P2PNetworkGraph fullGraph) throws JDOMException, IOException {
  SAXBuilder parser=new SAXBuilder();
  Document doc=parser.build(inStream);
  client.setLatestTime(doc.getRootElement().getAttribute(""String_Node_Str"").getLongValue());
  P2PNetworkGraphLoader loader=new P2PNetworkGraphLoader();
  loader.fullGraph=fullGraph;
  loader.addEventsToGraph(doc);
  return loader.logList;
}","public static List<LogEvent> buildLogs(InputStream inStream,HTTPClient client,P2PNetworkGraph fullGraph) throws JDOMException, IOException {
  SAXBuilder parser=new SAXBuilder();
  Document doc=parser.build(inStream);
  long requestTime=doc.getRootElement().getAttribute(""String_Node_Str"").getIntValue();
  long currentTime=doc.getRootElement().getAttribute(""String_Node_Str"").getLongValue();
  client.setLatestTime(currentTime);
  P2PNetworkGraphLoader loader=new P2PNetworkGraphLoader();
  loader.fullGraph=fullGraph;
  loader.addEventsToGraph(doc,requestTime);
  return loader.logList;
}",0.8274547187797903
180475,"private void addEventsToGraph(Document networkDoc){
  if (networkDoc.getRootElement().getName().equals(""String_Node_Str"")) {
    int edgeCounter=fullGraph.getEdgeCount();
    Element networkElem=networkDoc.getRootElement();
    Element logElem=networkElem.getChild(""String_Node_Str"");
    if (logElem != null) {
      taskChanged(logElem.getChildren().size(),""String_Node_Str"");
      for (      Object o : logElem.getChildren()) {
        Element event=(Element)o;
        String type=event.getAttribute(""String_Node_Str"").getValue();
        if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
          continue;
        }
        long timeDifference=Integer.parseInt(event.getChildText(""String_Node_Str""));
        int paramOne=Integer.parseInt(event.getChildText(""String_Node_Str""));
        int paramTwo=0;
        int paramThree=0;
        if (LogEvent.typeHasParamTwo(type)) {
          paramTwo=Integer.parseInt(event.getChildText(""String_Node_Str""));
        }
        if (LogEvent.typeHasParamThree(type)) {
          paramThree=Integer.parseInt(event.getChildText(""String_Node_Str""));
        }
        LogEvent evt=new LogEvent(timeDifference,type,paramOne,paramTwo,paramThree);
        if (evt.isConstructing()) {
          if (evt.getType().equals(""String_Node_Str"")) {
            fullGraph.addVertex(new PeerVertex(evt.getParam(1)));
          }
 else           if (evt.getType().equals(""String_Node_Str"")) {
            P2PVertex from=fullGraph.getVertexInGraph(new PeerVertex(evt.getParam(1)));
            P2PVertex to=fullGraph.getVertexInGraph(new PeerVertex(evt.getParam(2)));
            if (fullGraph.findEdge(to,from) == null) {
              P2PConnection edgeOne=new P2PConnection(P2PConnection.P2P,edgeCounter);
              edgeCounter++;
              P2PConnection edgeTwo=new P2PConnection(P2PConnection.P2P,edgeCounter);
              edgeCounter++;
              fullGraph.addEdge(edgeOne,from,to);
              fullGraph.addEdge(edgeTwo,to,from);
            }
          }
 else           if (evt.getType().equals(""String_Node_Str"")) {
            P2PVertex document=new DocumentVertex(evt.getParam(2));
            P2PVertex peerDocument=new PeerDocumentVertex(evt.getParam(1),evt.getParam(2));
            P2PVertex peer=fullGraph.getVertexInGraph(new PeerVertex(evt.getParam(1)));
            if (!fullGraph.containsVertex(document)) {
              fullGraph.addVertex(document);
            }
 else {
              document=fullGraph.getVertexInGraph(document);
            }
            fullGraph.addVertex(peerDocument);
            if (fullGraph.findEdge(peer,document) == null) {
              fullGraph.addEdge(new P2PConnection(P2PConnection.P2DOC,edgeCounter),peer,document);
              edgeCounter++;
            }
            if (fullGraph.findEdge(peer,peerDocument) == null) {
              fullGraph.addEdge(new P2PConnection(P2PConnection.P2PDOC,edgeCounter),peer,peerDocument);
              edgeCounter++;
            }
            if (fullGraph.findEdge(peerDocument,document) == null) {
              fullGraph.addEdge(new P2PConnection(P2PConnection.DOC2PDOC,edgeCounter),peerDocument,document);
              edgeCounter++;
            }
          }
 else           if (evt.getType().equals(""String_Node_Str"")) {
            P2PVertex documentOne=fullGraph.getVertexInGraph(new DocumentVertex(evt.getParam(1)));
            P2PVertex documentTwo=fullGraph.getVertexInGraph(new DocumentVertex(evt.getParam(2)));
            if (fullGraph.findEdge(documentOne,documentTwo) == null) {
              fullGraph.addEdge(new P2PConnection(P2PConnection.DOC2DOC,edgeCounter),documentOne,documentTwo);
              edgeCounter++;
            }
          }
        }
        logList.add(evt);
      }
    }
  }
}","private void addEventsToGraph(Document networkDoc,long timeOffset){
  if (networkDoc.getRootElement().getName().equals(""String_Node_Str"")) {
    int edgeCounter=fullGraph.getEdgeCount();
    Element networkElem=networkDoc.getRootElement();
    Element logElem=networkElem.getChild(""String_Node_Str"");
    if (logElem != null) {
      taskChanged(logElem.getChildren().size(),""String_Node_Str"");
      for (      Object o : logElem.getChildren()) {
        Element event=(Element)o;
        String type=event.getAttribute(""String_Node_Str"").getValue();
        if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
          continue;
        }
        long timeDifference=Integer.parseInt(event.getChildText(""String_Node_Str""));
        long eventTime=timeDifference + timeOffset;
        int paramOne=Integer.parseInt(event.getChildText(""String_Node_Str""));
        int paramTwo=0;
        int paramThree=0;
        if (LogEvent.typeHasParamTwo(type)) {
          paramTwo=Integer.parseInt(event.getChildText(""String_Node_Str""));
        }
        if (LogEvent.typeHasParamThree(type)) {
          paramThree=Integer.parseInt(event.getChildText(""String_Node_Str""));
        }
        LogEvent evt=new LogEvent(eventTime,type,paramOne,paramTwo,paramThree);
        if (evt.isConstructing()) {
          if (evt.getType().equals(""String_Node_Str"")) {
            fullGraph.addVertex(new PeerVertex(evt.getParam(1)));
          }
 else           if (evt.getType().equals(""String_Node_Str"")) {
            P2PVertex from=fullGraph.getVertexInGraph(new PeerVertex(evt.getParam(1)));
            P2PVertex to=fullGraph.getVertexInGraph(new PeerVertex(evt.getParam(2)));
            if (fullGraph.findEdge(to,from) == null) {
              P2PConnection edgeOne=new P2PConnection(P2PConnection.P2P,edgeCounter);
              edgeCounter++;
              P2PConnection edgeTwo=new P2PConnection(P2PConnection.P2P,edgeCounter);
              edgeCounter++;
              fullGraph.addEdge(edgeOne,from,to);
              fullGraph.addEdge(edgeTwo,to,from);
            }
          }
 else           if (evt.getType().equals(""String_Node_Str"")) {
            P2PVertex document=new DocumentVertex(evt.getParam(2));
            P2PVertex peerDocument=new PeerDocumentVertex(evt.getParam(1),evt.getParam(2));
            P2PVertex peer=fullGraph.getVertexInGraph(new PeerVertex(evt.getParam(1)));
            if (!fullGraph.containsVertex(document)) {
              fullGraph.addVertex(document);
            }
 else {
              document=fullGraph.getVertexInGraph(document);
            }
            fullGraph.addVertex(peerDocument);
            if (fullGraph.findEdge(peer,document) == null) {
              fullGraph.addEdge(new P2PConnection(P2PConnection.P2DOC,edgeCounter),peer,document);
              edgeCounter++;
            }
            if (fullGraph.findEdge(peer,peerDocument) == null) {
              fullGraph.addEdge(new P2PConnection(P2PConnection.P2PDOC,edgeCounter),peer,peerDocument);
              edgeCounter++;
            }
            if (fullGraph.findEdge(peerDocument,document) == null) {
              fullGraph.addEdge(new P2PConnection(P2PConnection.DOC2PDOC,edgeCounter),peerDocument,document);
              edgeCounter++;
            }
          }
 else           if (evt.getType().equals(""String_Node_Str"")) {
            P2PVertex documentOne=fullGraph.getVertexInGraph(new DocumentVertex(evt.getParam(1)));
            P2PVertex documentTwo=fullGraph.getVertexInGraph(new DocumentVertex(evt.getParam(2)));
            if (fullGraph.findEdge(documentOne,documentTwo) == null) {
              fullGraph.addEdge(new P2PConnection(P2PConnection.DOC2DOC,edgeCounter),documentOne,documentTwo);
              edgeCounter++;
            }
          }
        }
        logList.add(evt);
      }
    }
  }
}",0.9883492603743944
180476,"public static String saveGraphForWeb(P2PNetworkGraph graph,long simulationTime){
  P2PNetworkGraphSaver saver=new P2PNetworkGraphSaver(graph);
  Document doc=saver.buildDoc();
  doc.getRootElement().setAttribute(""String_Node_Str"",Long.toString(simulationTime));
  XMLOutputter outputter=new XMLOutputter();
  try {
    return outputter.outputString(doc);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return ""String_Node_Str"";
}","public static String saveGraphForWeb(P2PNetworkGraph graph,long simulationTime){
  P2PNetworkGraphSaver saver=new P2PNetworkGraphSaver(graph);
  Document doc=saver.buildDoc();
  doc.getRootElement().setAttribute(""String_Node_Str"",Long.toString(simulationTime));
  XMLOutputter outputter=new XMLOutputter();
  try {
    return outputter.outputString(doc);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return ""String_Node_Str"" + simulationTime + ""String_Node_Str"";
}",0.9598262757871878
180477,"public static String saveEventsForWeb(List<LogEvent> events,long simulationTime){
  if (!events.isEmpty()) {
    try {
      P2PNetworkGraphSaver saver=new P2PNetworkGraphSaver(events,events.get(0).getTime());
      Document doc=saver.buildDoc();
      doc.getRootElement().setAttribute(""String_Node_Str"",Long.toString(simulationTime));
      XMLOutputter outputter=new XMLOutputter();
      return outputter.outputString(doc);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return ""String_Node_Str"";
}","public static String saveEventsForWeb(List<LogEvent> events,long requestTime,long simulationTime){
  if (!events.isEmpty()) {
    try {
      P2PNetworkGraphSaver saver=new P2PNetworkGraphSaver(events,requestTime);
      Document doc=saver.buildDoc();
      doc.getRootElement().setAttribute(""String_Node_Str"",Long.toString(requestTime));
      doc.getRootElement().setAttribute(""String_Node_Str"",Long.toString(simulationTime));
      XMLOutputter outputter=new XMLOutputter();
      return outputter.outputString(doc);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return ""String_Node_Str"" + requestTime + ""String_Node_Str""+ simulationTime+ ""String_Node_Str"";
}",0.8296296296296296
180478,"/** 
 * Notify all Listeners that a message has been receieved which contains Log Events.
 * @param inStream InputStream containing the Log Event XML file as it's payload.
 */
protected void notifyIncomingLogEvents(InputStream inStream){
  System.out.println(""String_Node_Str"");
  for (  NetworkGraphListener l : networkListeners) {
    l.incomingLogEvents(inStream);
  }
}","/** 
 * Notify all Listeners that a message has been receieved which contains Log Events.
 * @param inStream InputStream containing the Log Event XML file as it's payload.
 */
protected void notifyIncomingLogEvents(InputStream inStream){
  for (  NetworkGraphListener l : networkListeners) {
    l.incomingLogEvents(inStream);
  }
}",0.7092198581560284
180479,"@Override public void actionPerformed(ActionEvent arg0){
  if (connected) {
    try {
      getLogEvents();
      connected=false;
    }
 catch (    IOException e) {
      connected=false;
      e.printStackTrace();
    }
catch (    Exception e) {
      connected=false;
      e.printStackTrace();
    }
  }
}","@Override public void actionPerformed(ActionEvent arg0){
  if (connected) {
    try {
      getLogEvents();
    }
 catch (    IOException e) {
      connected=false;
      e.printStackTrace();
    }
catch (    Exception e) {
      connected=false;
      e.printStackTrace();
    }
  }
}",0.7294117647058823
180480,"/** 
 * Notify all Listeners that a message has been receieved which contains a Graph.
 * @param inStream InputStream containing the Network Graph XML file as it's payload.
 */
protected void notifyIncomingGraph(InputStream inStream){
  System.out.println(""String_Node_Str"");
  for (  NetworkGraphListener l : networkListeners) {
    l.incomingGraph(inStream);
  }
}","/** 
 * Notify all Listeners that a message has been receieved which contains a Graph.
 * @param inStream InputStream containing the Network Graph XML file as it's payload.
 */
protected void notifyIncomingGraph(InputStream inStream){
  for (  NetworkGraphListener l : networkListeners) {
    l.incomingGraph(inStream);
  }
}",0.7149059334298119
180481,"@Override public synchronized void incomingLogEvents(InputStream inStream){
  try {
    eventThread.pause();
    List<LogEvent> events;
synchronized (graph.getReferenceGraph()) {
      events=P2PNetworkGraphLoader.buildLogs(inStream,networkClient,graph);
    }
    if (!events.isEmpty()) {
      for (int i=0; i < events.size(); i++) {
        graph.getReferenceGraph().robustGraphEvent(events,i);
      }
      events.add(LogEvent.getEndEvent(events.get(events.size() - 1)));
      eventThread.addEvents(events);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Override public synchronized void incomingLogEvents(InputStream inStream){
  try {
    List<LogEvent> events;
synchronized (graph.getReferenceGraph()) {
      events=P2PNetworkGraphLoader.buildLogs(inStream,networkClient,graph);
    }
    if (!events.isEmpty()) {
      for (int i=0; i < events.size(); i++) {
        graph.getReferenceGraph().robustGraphEvent(events,i);
      }
      events.add(LogEvent.getEndEvent(events.get(events.size() - 1)));
      eventThread.addEvents(events);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9779346866725508
180482,"@Override public void doRepaint(){
  fullViewViewer.repaint();
  collapsedDocumentViewViewer.repaint();
  collapsedPeerViewViewer.repaint();
  collapsedPeerAndDocumentViewViewer.repaint();
}","@Override public void doRepaint(){
  currentViewer.repaint();
}",0.4822134387351778
180483,"public void startNetwork(String serverURL){
  this.serverURL=serverURL;
  try {
    getGraph();
    connected=true;
  }
 catch (  Exception e) {
    connected=false;
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
  if (connected) {
    networkScheduler.start();
  }
}","public void startNetwork(String serverURL){
  this.serverURL=serverURL;
  Thread starterThread=new Thread(new Runnable(){
    @Override public void run(){
      try {
        getGraph();
        connected=true;
      }
 catch (      Exception e) {
        connected=false;
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
      if (connected) {
        networkScheduler.start();
      }
    }
  }
);
  starterThread.start();
}",0.7619047619047619
180484,"public EventPlayer(ReferencedNetworkGraph graph){
  this.graph=graph;
  this.playbackSlider=null;
  myEventList=new ArrayList<LogEvent>();
  current_index=0;
  state=PlayState.PAUSE;
  timeCounter=new TimeCounter(0,0,0,0);
  my_listeners=new LinkedList<EventPlayerListener>();
  playable=false;
}","public EventPlayer(ReferencedNetworkGraph graph){
  this.graph=graph;
  this.playbackSlider=null;
  myEventList=new ArrayList<LogEvent>();
  current_index=0;
  state=PlayState.PAUSE;
  prevState=PlayState.PAUSE;
  timeCounter=new TimeCounter(0,0,0,0);
  my_listeners=new LinkedList<EventPlayerListener>();
  playable=false;
}",0.9533011272141708
180485,"public synchronized void addEvents(List<LogEvent> events){
  myEventList.remove(myEventList.size() - 1);
  myEventList.addAll(events);
  playbackSlider.setMaximum((int)myEventList.get(myEventList.size() - 1).getTime());
  timeCounter.setUpperBound(myEventList.get(myEventList.size() - 1).getTime());
}","public synchronized void addEvents(List<LogEvent> events){
  myEventList.remove(myEventList.size() - 1);
  myEventList.addAll(events);
  playbackSlider.setMaximum((int)myEventList.get(myEventList.size() - 1).getTime());
  timeCounter.setUpperBound(myEventList.get(myEventList.size() - 1).getTime());
  if (state.equals(PlayState.PAUSE)) {
    for (    EventPlayerListener epl : my_listeners) {
      epl.playbackPause();
    }
  }
}",0.8212824010914052
180486,"/** 
 */
public void fastReverse(){
  for (  EventPlayerListener epl : my_listeners) {
    epl.playbackFastReverse();
  }
  if (state != PlayState.FASTREVERSE) {
    PlayState prevState=state;
    state=PlayState.FASTREVERSE;
    timeCounter.setIncrement(-speed * fastMultiplier);
    wakeup(prevState);
  }
}","/** 
 */
public void fastReverse(){
  for (  EventPlayerListener epl : my_listeners) {
    epl.playbackFastReverse();
  }
  if (state != PlayState.FASTREVERSE) {
    prevState=state;
    state=PlayState.FASTREVERSE;
    timeCounter.setIncrement(-speed * fastMultiplier);
    wakeup(prevState);
  }
}",0.9835526315789472
180487,"public void forward(){
  for (  EventPlayerListener epl : my_listeners) {
    epl.playbackForward();
  }
  if (state != PlayState.FORWARD) {
    PlayState prevState=state;
    state=PlayState.FORWARD;
    timeCounter.setIncrement(speed);
    wakeup(prevState);
  }
}","public void forward(){
  for (  EventPlayerListener epl : my_listeners) {
    epl.playbackForward();
  }
  if (state != PlayState.FORWARD) {
    prevState=state;
    state=PlayState.FORWARD;
    timeCounter.setIncrement(speed);
    wakeup(prevState);
  }
}",0.9808429118773946
180488,"public void reverse(){
  for (  EventPlayerListener epl : my_listeners) {
    epl.playbackReverse();
  }
  if (state != PlayState.REVERSE) {
    PlayState prevState=state;
    state=PlayState.REVERSE;
    timeCounter.setIncrement(-speed);
    wakeup(prevState);
  }
}","public void reverse(){
  for (  EventPlayerListener epl : my_listeners) {
    epl.playbackReverse();
  }
  if (state != PlayState.REVERSE) {
    prevState=state;
    state=PlayState.REVERSE;
    timeCounter.setIncrement(-speed);
    wakeup(prevState);
  }
}",0.9809160305343512
180489,"public synchronized void pause(){
  for (  EventPlayerListener epl : my_listeners) {
    epl.playbackPause();
  }
  if (state != PlayState.PAUSE) {
    state=PlayState.PAUSE;
    notify();
  }
}","public synchronized void pause(){
  for (  EventPlayerListener epl : my_listeners) {
    epl.playbackPause();
  }
  if (state != PlayState.PAUSE) {
    prevState=state;
    state=PlayState.PAUSE;
    notify();
  }
}",0.9486552567237164
180490,"/** 
 * Handles popup menu button clicks
 * @param text The text of the button that was just clicked
 */
public void popupMenuEvent(String text){
  if (text.contains((""String_Node_Str""))) {
    VisualizationViewer<P2PVertex,P2PConnection> currentViewer=applet.getCurrentViewer();
    Layout<P2PVertex,P2PConnection> currentLayout=currentViewer.getGraphLayout();
    Layout<P2PVertex,P2PConnection> newLayout=null;
    P2PNetworkGraph graph=applet.getGraph().getReferenceGraph();
    if (text.equals(""String_Node_Str"")) {
      newLayout=new FRLayout<P2PVertex,P2PConnection>(graph,currentViewer.getSize());
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new ISOMLayout<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new KKLayout<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new SpringLayout2<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new BalloonLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new RadialTreeLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new TreeLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else {
      newLayout=new CircleLayout<P2PVertex,P2PConnection>(graph);
    }
    newLayout.setInitializer(currentViewer.getGraphLayout());
    newLayout.setSize(currentViewer.getSize());
    LayoutTransition<P2PVertex,P2PConnection> transition=new LayoutTransition<P2PVertex,P2PConnection>(currentViewer,currentLayout,newLayout);
    Animator transitionAnimator=new Animator(transition);
    transitionAnimator.start();
    stopAnimateTimer.schedule(new StopAnimateTask<P2PVertex,P2PConnection>(transitionAnimator,newLayout),5000);
    currentViewer.getRenderContext().getMultiLayerTransformer().setToIdentity();
    currentViewer.repaint();
  }
 else   if (text.equals(""String_Node_Str"")) {
    gm.setMode(Mode.PICKING);
  }
 else   if (text.equals(""String_Node_Str"")) {
    gm.setMode(Mode.TRANSFORMING);
  }
 else {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + text,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  setVisible(false);
  setEnabled(false);
}","/** 
 * Handles popup menu button clicks
 * @param text The text of the button that was just clicked
 */
public void popupMenuEvent(String text){
  if (text.contains((""String_Node_Str""))) {
    VisualizationViewer<P2PVertex,P2PConnection> currentViewer=applet.getCurrentViewer();
    Layout<P2PVertex,P2PConnection> currentLayout=currentViewer.getGraphLayout();
    Layout<P2PVertex,P2PConnection> newLayout=null;
    P2PNetworkGraph graph=applet.getGraph().getReferenceGraph();
    if (text.equals(""String_Node_Str"")) {
      newLayout=new FRLayout<P2PVertex,P2PConnection>(graph,currentViewer.getSize());
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new ISOMLayout<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new KKLayout<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new SpringLayout2<P2PVertex,P2PConnection>(graph);
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new BalloonLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new RadialTreeLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else     if (text.equals(""String_Node_Str"")) {
      newLayout=new TreeLayout<P2PVertex,P2PConnection>(P2PNetworkGraph.makeTreeGraph(graph));
    }
 else {
      newLayout=new CircleLayout<P2PVertex,P2PConnection>(graph);
    }
    newLayout.setInitializer(currentViewer.getGraphLayout());
    if (!newLayout.getClass().equals(TreeLayout.class)) {
      newLayout.setSize(currentViewer.getSize());
    }
    LayoutTransition<P2PVertex,P2PConnection> transition=new LayoutTransition<P2PVertex,P2PConnection>(currentViewer,currentLayout,newLayout);
    Animator transitionAnimator=new Animator(transition);
    transitionAnimator.start();
    stopAnimateTimer.schedule(new StopAnimateTask<P2PVertex,P2PConnection>(transitionAnimator,newLayout),5000);
    currentViewer.getRenderContext().getMultiLayerTransformer().setToIdentity();
    currentViewer.repaint();
  }
 else   if (text.equals(""String_Node_Str"")) {
    gm.setMode(Mode.PICKING);
  }
 else   if (text.equals(""String_Node_Str"")) {
    gm.setMode(Mode.TRANSFORMING);
  }
 else {
    JOptionPane.showMessageDialog(this,""String_Node_Str"" + text,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    return;
  }
  setVisible(false);
  setEnabled(false);
}",0.9865196078431372
180491,"/** 
 * applet initialization
 */
public void init(){
  System.out.println(""String_Node_Str"");
  SpringLayout<P2PVertex,P2PConnection> sp_layout=null;
  try {
    BufferedReader in;
    if (ontheweb) {
      URL yahoo=new URL(DEF_LOG_URL);
      in=new BufferedReader(new InputStreamReader(yahoo.openStream()));
    }
 else {
      if (mylogfile == null)       in=new BufferedReader(new FileReader(DEF_LOG_FILE));
 else {
        in=new BufferedReader(new FileReader(mylogfile));
        System.out.println(""String_Node_Str"" + mylogfile.getAbsolutePath());
      }
    }
    myGraphEvolution=new LinkedList<LogEvent>();
    hiddenGraph=new P2PNetworkGraph();
    sp_layout=new SpringLayout<P2PVertex,P2PConnection>(hiddenGraph,new P2PNetEdgeLengthFunction());
    sp_layout.setSize(new Dimension(DEFWIDTH,DEFHEIGHT));
    sp_layout.setForceMultiplier(0.6);
    sp_layout.setInitializer(new P2PVertexPlacer(sp_layout,new Dimension(DEFWIDTH,DEFHEIGHT)));
    sp_layout.initialize();
    String str;
    List<LogEvent> colouringEvents=new LinkedList<LogEvent>();
    List<P2PVertex> queryPeers=new LinkedList<P2PVertex>();
    int totalLines=Integer.parseInt(in.readLine());
    int lineCount=0;
    myGraphEvolution.add(new LogEvent(""String_Node_Str""));
    while ((str=in.readLine()) != null) {
      lineCount++;
      LogEvent gev=new LogEvent(str);
      if (gev.isConstructing()) {
        graphConstructionEvent(gev,hiddenGraph);
        sp_layout.step();
        sp_layout.step();
      }
      if (gev.getType().equals(""String_Node_Str"") || gev.getType().equals(""String_Node_Str"")) {
        colouringEvents.add(LogEvent.createOpposingLogEvent(gev,2000));
        if (gev.getType().equals(""String_Node_Str"")) {
          queryPeers.add(new PeerVertex(gev.getParam(1)));
        }
      }
 else       if (gev.getType().equals(""String_Node_Str"")) {
        colouringEvents.add(LogEvent.createOpposingLogEvent(gev,750));
        P2PVertex queriedPeer=new PeerVertex(gev.getParam(1));
        for (        P2PVertex querySender : queryPeers) {
          if (hiddenGraph.findEdge(querySender,queriedPeer) != null) {
            LogEvent ev=new LogEvent(gev.getTime() + 1,""String_Node_Str"",querySender.getKey(),queriedPeer.getKey());
            colouringEvents.add(ev);
            colouringEvents.add(LogEvent.createOpposingLogEvent(ev,750));
            break;
          }
        }
        queryPeers.add(queriedPeer);
      }
      Collections.sort(colouringEvents);
      for (Iterator<LogEvent> iter=colouringEvents.iterator(); iter.hasNext(); ) {
        LogEvent event=(LogEvent)iter.next();
        if (event.getTime() < gev.getTime()) {
          myGraphEvolution.addLast(event);
          iter.remove();
        }
 else {
          break;
        }
      }
      myGraphEvolution.addLast(gev);
    }
    myGraphEvolution.add(new LogEvent((myGraphEvolution.getLast().getTime()) + ""String_Node_Str""));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  layout=sp_layout;
  visibleGraph=new P2PNetworkGraph();
  vv=new VisualizationViewer<P2PVertex,P2PConnection>(layout,new Dimension(DEFWIDTH,DEFHEIGHT));
  JRootPane rp=this.getRootPane();
  rp.putClientProperty(""String_Node_Str"",Boolean.TRUE);
  getContentPane().setLayout(new BorderLayout());
  getContentPane().setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  getContentPane().setBounds(0,0,DEFWIDTH,DEFHEIGHT);
  DefaultModalGraphMouse<P2PVertex,P2PConnection> gm=new DefaultModalGraphMouse<P2PVertex,P2PConnection>();
  vv.setGraphMouse(gm);
  vv.getRenderer().getVertexLabelRenderer().setPosition(Renderer.VertexLabel.Position.CNTR);
  vv.getRenderContext().setVertexLabelTransformer(new ToStringLabeller<P2PVertex>());
  vv.getRenderContext().setVertexShapeTransformer(new P2PVertexShapeTransformer());
  vv.getRenderContext().setEdgeStrokeTransformer(new P2PEdgeStrokeTransformer());
  vv.getRenderContext().setEdgeShapeTransformer(new P2PEdgeShapeTransformer());
  vv.getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(vv.getPickedVertexState()));
  vv.getRenderContext().setVertexStrokeTransformer(new P2PVertexStrokeTransformer());
  vv.setForeground(Color.white);
  eventthread=new EventPlayingThread(myGraphEvolution);
  vv.addComponentListener(new ComponentAdapter(){
    /** 
 * @see java.awt.event.ComponentAdapter#componentResized(java.awt.event.ComponentEvent)
 */
    @Override public void componentResized(    ComponentEvent arg0){
      super.componentResized(arg0);
      layout.setSize(arg0.getComponent().getSize());
    }
  }
);
  JPanel graphsPanel=new JPanel();
  graphsPanel.add(vv);
  Relaxer relaxer=new VisRunner((IterativeContext)layout);
  relaxer.stop();
  relaxer.setSleepTime(80L);
  relaxer.relax();
  relaxerButton=new JButton(""String_Node_Str"");
  relaxerButton.addActionListener(new relaxerButtonListener(relaxer));
  stopButton=new JButton(""String_Node_Str"");
  stopButton.addActionListener(new StopButtonListener());
  fastReverseButton=new JButton(""String_Node_Str"");
  fastReverseButton.addActionListener(new FastReverseButtonListener());
  reverseButton=new JButton(""String_Node_Str"");
  reverseButton.addActionListener(new ReverseButtonListener());
  pauseButton=new JButton(""String_Node_Str"");
  pauseButton.addActionListener(new PauseButtonListener());
  forwardButton=new JButton(""String_Node_Str"");
  forwardButton.addActionListener(new ForwardButtonListener());
  fastforwardButton=new JButton(""String_Node_Str"");
  fastforwardButton.addActionListener(new FastforwardButtonListener());
  playbackSlider=new JSlider(JSlider.HORIZONTAL,0,(int)myGraphEvolution.getLast().getTime(),0);
  playbackSlider.addChangeListener(new SliderListener());
  playbackSlider.setMajorTickSpacing(playbackSlider.getExtent() / 4);
  playbackSlider.setMajorTickSpacing(playbackSlider.getExtent() / 8);
  playbackSlider.setPaintTicks(true);
  playbackSlider.setPaintLabels(false);
  playbackSlider.setBackground(Color.GRAY);
  playbackSlider.setForeground(Color.BLUE);
  GridBagLayout southLayout=new GridBagLayout();
  GridBagConstraints southConstraints=new GridBagConstraints();
  JPanel south=new JPanel();
  south.setBackground(Color.GRAY);
  south.setLayout(new GridLayout(2,1));
  JPanel buttonPanel=new JPanel();
  buttonPanel.setBackground(Color.GRAY);
  buttonPanel.setLayout(southLayout);
  buttonPanel.add(fastReverseButton);
  buttonPanel.add(reverseButton);
  buttonPanel.add(pauseButton);
  buttonPanel.add(forwardButton);
  southConstraints.gridwidth=GridBagConstraints.REMAINDER;
  southLayout.setConstraints(fastforwardButton,southConstraints);
  buttonPanel.add(fastforwardButton);
  south.add(buttonPanel);
  south.add(playbackSlider);
  stopButton.setEnabled(false);
  fastReverseButton.setEnabled(false);
  reverseButton.setEnabled(false);
  pauseButton.setEnabled(false);
  forwardButton.setEnabled(false);
  fastforwardButton.setEnabled(false);
  playbackSlider.setEnabled(false);
  GridBagLayout westLayout=new GridBagLayout();
  GridBagConstraints westConstraints=new GridBagConstraints();
  JPanel west=new JPanel();
  west.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  west.setBackground(Color.GRAY);
  west.setLayout(westLayout);
  JPanel p=new JPanel();
  p.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  p.setBackground(Color.GRAY);
  p.add(gm.getModeComboBox());
  westConstraints.gridwidth=GridBagConstraints.REMAINDER;
  westLayout.setConstraints(p,westConstraints);
  west.add(p);
  westLayout.setConstraints(relaxerButton,westConstraints);
  west.add(relaxerButton);
  westLayout.setConstraints(stopButton,westConstraints);
  west.add(stopButton);
  getContentPane().add(graphsPanel,BorderLayout.CENTER);
  getContentPane().add(south,BorderLayout.SOUTH);
  getContentPane().add(west,BorderLayout.WEST);
}","/** 
 * applet initialization
 */
public void init(){
  System.out.println(""String_Node_Str"");
  SpringLayout<P2PVertex,P2PConnection> sp_layout=null;
  try {
    BufferedReader in;
    if (ontheweb) {
      URL yahoo=new URL(DEF_LOG_URL);
      in=new BufferedReader(new InputStreamReader(yahoo.openStream()));
    }
 else {
      if (mylogfile == null)       in=new BufferedReader(new FileReader(DEF_LOG_FILE));
 else {
        in=new BufferedReader(new FileReader(mylogfile));
        System.out.println(""String_Node_Str"" + mylogfile.getAbsolutePath());
      }
    }
    myGraphEvolution=new LinkedList<LogEvent>();
    hiddenGraph=new P2PNetworkGraph();
    sp_layout=new SpringLayout<P2PVertex,P2PConnection>(hiddenGraph,new P2PNetEdgeLengthFunction());
    sp_layout.setSize(new Dimension(DEFWIDTH,DEFHEIGHT));
    sp_layout.setForceMultiplier(0.6);
    sp_layout.setInitializer(new P2PVertexPlacer(sp_layout,new Dimension(DEFWIDTH,DEFHEIGHT)));
    sp_layout.initialize();
    String str;
    List<LogEvent> colouringEvents=new LinkedList<LogEvent>();
    List<P2PVertex> queryPeers=new LinkedList<P2PVertex>();
    int totalLines=Integer.parseInt(in.readLine());
    int lineCount=0;
    myGraphEvolution.add(new LogEvent(""String_Node_Str""));
    while ((str=in.readLine()) != null) {
      lineCount++;
      LogEvent gev=new LogEvent(str);
      if (gev.isConstructing()) {
        graphConstructionEvent(gev,hiddenGraph);
        sp_layout.step();
        sp_layout.step();
      }
      if (gev.getType().equals(""String_Node_Str"") || gev.getType().equals(""String_Node_Str"")) {
        colouringEvents.add(LogEvent.createOpposingLogEvent(gev,2000));
        if (gev.getType().equals(""String_Node_Str"")) {
          queryPeers.add(new PeerVertex(gev.getParam(1)));
        }
      }
 else       if (gev.getType().equals(""String_Node_Str"")) {
        colouringEvents.add(LogEvent.createOpposingLogEvent(gev,750));
        P2PVertex queriedPeer=new PeerVertex(gev.getParam(1));
        for (        P2PVertex querySender : queryPeers) {
          if (hiddenGraph.findEdge(querySender,queriedPeer) != null) {
            LogEvent ev=new LogEvent(gev.getTime() + 1,""String_Node_Str"",querySender.getKey(),queriedPeer.getKey());
            colouringEvents.add(ev);
            colouringEvents.add(LogEvent.createOpposingLogEvent(ev,750));
            break;
          }
        }
        queryPeers.add(queriedPeer);
      }
      Collections.sort(colouringEvents);
      for (Iterator<LogEvent> iter=colouringEvents.iterator(); iter.hasNext(); ) {
        LogEvent event=(LogEvent)iter.next();
        if (event.getTime() < gev.getTime()) {
          myGraphEvolution.addLast(event);
          iter.remove();
        }
 else {
          break;
        }
      }
      myGraphEvolution.addLast(gev);
    }
    myGraphEvolution.add(new LogEvent((myGraphEvolution.getLast().getTime()) + ""String_Node_Str""));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  layout=sp_layout;
  visibleGraph=new P2PNetworkGraph();
  vv=new VisualizationViewer<P2PVertex,P2PConnection>(layout,new Dimension(DEFWIDTH,DEFHEIGHT));
  JRootPane rp=this.getRootPane();
  rp.putClientProperty(""String_Node_Str"",Boolean.TRUE);
  getContentPane().setLayout(new BorderLayout());
  getContentPane().setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  getContentPane().setBounds(0,0,DEFWIDTH,DEFHEIGHT);
  DefaultModalGraphMouse<P2PVertex,P2PConnection> gm=new DefaultModalGraphMouse<P2PVertex,P2PConnection>();
  vv.setGraphMouse(gm);
  vv.getRenderer().getVertexLabelRenderer().setPosition(Renderer.VertexLabel.Position.CNTR);
  vv.getRenderContext().setVertexLabelTransformer(new ToStringLabeller<P2PVertex>());
  vv.getRenderContext().setVertexShapeTransformer(new P2PVertexShapeTransformer());
  vv.getRenderContext().setEdgeStrokeTransformer(new P2PEdgeStrokeTransformer());
  vv.getRenderContext().setEdgeShapeTransformer(new P2PEdgeShapeTransformer());
  vv.getRenderContext().setVertexFillPaintTransformer(new P2PVertexFillPaintTransformer(vv.getPickedVertexState()));
  vv.getRenderContext().setVertexStrokeTransformer(new P2PVertexStrokeTransformer());
  vv.setForeground(Color.white);
  eventthread=new EventPlayingThread(myGraphEvolution);
  vv.addComponentListener(new ComponentAdapter(){
    /** 
 * @see java.awt.event.ComponentAdapter#componentResized(java.awt.event.ComponentEvent)
 */
    @Override public void componentResized(    ComponentEvent arg0){
      super.componentResized(arg0);
      layout.setSize(arg0.getComponent().getSize());
    }
  }
);
  JPanel graphsPanel=new JPanel();
  graphsPanel.add(vv);
  Relaxer relaxer=new VisRunner((IterativeContext)layout);
  relaxer.stop();
  relaxer.setSleepTime(80L);
  relaxer.relax();
  relaxerButton=new JButton(""String_Node_Str"");
  relaxerButton.addActionListener(new relaxerButtonListener(relaxer));
  stopButton=new JButton(""String_Node_Str"");
  stopButton.addActionListener(new StopButtonListener());
  fastReverseButton=new JButton(""String_Node_Str"");
  fastReverseButton.addActionListener(new FastReverseButtonListener());
  reverseButton=new JButton(""String_Node_Str"");
  reverseButton.addActionListener(new ReverseButtonListener());
  pauseButton=new JButton(""String_Node_Str"");
  pauseButton.addActionListener(new PauseButtonListener());
  forwardButton=new JButton(""String_Node_Str"");
  forwardButton.addActionListener(new ForwardButtonListener());
  fastforwardButton=new JButton(""String_Node_Str"");
  fastforwardButton.addActionListener(new FastforwardButtonListener());
  playbackSlider=new JSlider(JSlider.HORIZONTAL,0,(int)myGraphEvolution.getLast().getTime(),0);
  SliderListener s=new SliderListener();
  playbackSlider.addChangeListener(s);
  playbackSlider.addMouseListener(s);
  playbackSlider.setMajorTickSpacing(playbackSlider.getExtent() / 4);
  playbackSlider.setMajorTickSpacing(playbackSlider.getExtent() / 8);
  playbackSlider.setPaintTicks(true);
  playbackSlider.setPaintLabels(false);
  playbackSlider.setBackground(Color.GRAY);
  playbackSlider.setForeground(Color.BLUE);
  GridBagLayout southLayout=new GridBagLayout();
  GridBagConstraints southConstraints=new GridBagConstraints();
  JPanel south=new JPanel();
  south.setBackground(Color.GRAY);
  south.setLayout(new GridLayout(2,1));
  JPanel buttonPanel=new JPanel();
  buttonPanel.setBackground(Color.GRAY);
  buttonPanel.setLayout(southLayout);
  buttonPanel.add(fastReverseButton);
  buttonPanel.add(reverseButton);
  buttonPanel.add(pauseButton);
  buttonPanel.add(forwardButton);
  southConstraints.gridwidth=GridBagConstraints.REMAINDER;
  southLayout.setConstraints(fastforwardButton,southConstraints);
  buttonPanel.add(fastforwardButton);
  south.add(buttonPanel);
  south.add(playbackSlider);
  stopButton.setEnabled(false);
  fastReverseButton.setEnabled(false);
  reverseButton.setEnabled(false);
  pauseButton.setEnabled(false);
  forwardButton.setEnabled(false);
  fastforwardButton.setEnabled(false);
  playbackSlider.setEnabled(false);
  GridBagLayout westLayout=new GridBagLayout();
  GridBagConstraints westConstraints=new GridBagConstraints();
  JPanel west=new JPanel();
  west.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  west.setBackground(Color.GRAY);
  west.setLayout(westLayout);
  JPanel p=new JPanel();
  p.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  p.setBackground(Color.GRAY);
  p.add(gm.getModeComboBox());
  westConstraints.gridwidth=GridBagConstraints.REMAINDER;
  westLayout.setConstraints(p,westConstraints);
  west.add(p);
  westLayout.setConstraints(relaxerButton,westConstraints);
  west.add(relaxerButton);
  westLayout.setConstraints(stopButton,westConstraints);
  west.add(stopButton);
  getContentPane().add(graphsPanel,BorderLayout.CENTER);
  getContentPane().add(south,BorderLayout.SOUTH);
  getContentPane().add(west,BorderLayout.WEST);
}",0.9936265137029956
180492,"@Override public void stateChanged(ChangeEvent ce){
  JSlider source=(JSlider)ce.getSource();
  eventthread.schedule.stop();
  eventthread.goToTime(source.getValue());
}","@Override public void stateChanged(ChangeEvent ce){
  JSlider source=(JSlider)ce.getSource();
  eventthread.goToTime(source.getValue());
}",0.8990228013029316
180493,"public void run(){
  long myTimeNow=0L;
  long nextTime;
  boolean oldDirection;
  schedule=new Timer(speed,timeCounter);
  schedule.start();
  while (playing) {
    if (timeCounter.getTime() == myTimeNow) {
      try {
        Thread.sleep(20);
        continue;
      }
 catch (      InterruptedException e) {
      }
    }
    if (state != PlayState.PAUSE && !playbackSlider.getValueIsAdjusting()) {
      nextTime=timeCounter.getTime();
      oldDirection=isForward();
      if (atAnEnd()) {
        pauseButton.doClick();
      }
      for (      LogEvent evt : getLogEventsUntil(nextTime)) {
        if (oldDirection == isForward()) {
          handleLogEvent(evt);
        }
 else {
          break;
        }
      }
      myTimeNow=nextTime;
      playbackSlider.setValue((int)myTimeNow);
      vv.repaint();
    }
 else {
      try {
synchronized (this) {
          while (state == PlayState.PAUSE) {
            wait();
          }
        }
      }
 catch (      InterruptedException e) {
      }
    }
  }
}","public void run(){
  long myTimeNow=0L;
  long nextTime;
  boolean oldDirection;
  schedule=new Timer(speed,timeCounter);
  schedule.start();
  while (playing) {
    if (timeCounter.getTime() == myTimeNow) {
      try {
        Thread.sleep(20);
        continue;
      }
 catch (      InterruptedException e) {
      }
    }
    if (state != PlayState.PAUSE && !playbackSlider.getValueIsAdjusting()) {
      nextTime=timeCounter.getTime();
      oldDirection=isForward();
      if (atAnEnd()) {
        pause();
      }
      for (      LogEvent evt : getLogEventsUntil(nextTime)) {
        if (oldDirection == isForward()) {
          handleLogEvent(evt);
        }
 else {
          break;
        }
      }
      myTimeNow=nextTime;
      playbackSlider.setValue((int)myTimeNow);
      vv.repaint();
    }
 else {
      try {
synchronized (this) {
          while (state == PlayState.PAUSE) {
            wait();
          }
        }
      }
 catch (      InterruptedException e) {
      }
    }
  }
}",0.9930898321816388
180494,"private synchronized void wakeup(PlayState previousState){
  if (this.getState().equals(Thread.State.TIMED_WAITING)) {
    interrupt();
  }
  if (previousState == PlayState.PAUSE) {
    schedule.start();
    notify();
  }
}","private synchronized void wakeup(PlayState previousState){
  if (previousState == PlayState.PAUSE) {
    if (atAnEnd()) {
      timeCounter.doIncrement();
    }
    schedule.start();
    notify();
  }
  if (this.getState().equals(Thread.State.TIMED_WAITING)) {
    interrupt();
  }
}",0.5533596837944664
180495,"public void fastForward(){
  if (state != PlayState.FASTFORWARD) {
    fastReverseButton.setEnabled(true);
    reverseButton.setEnabled(true);
    pauseButton.setEnabled(true);
    forwardButton.setEnabled(true);
    fastforwardButton.setEnabled(false);
    PlayState prevState=state;
    state=PlayState.FASTFORWARD;
    wakeup(prevState);
    timeCounter.setIncrement(speed * ffMultiplier);
  }
}","public void fastForward(){
  if (state != PlayState.FASTFORWARD) {
    fastReverseButton.setEnabled(true);
    reverseButton.setEnabled(true);
    pauseButton.setEnabled(true);
    forwardButton.setEnabled(true);
    fastforwardButton.setEnabled(false);
    PlayState prevState=state;
    state=PlayState.FASTFORWARD;
    timeCounter.setIncrement(speed * ffMultiplier);
    wakeup(prevState);
  }
}",0.8693467336683417
180496,"/** 
 */
public void fastReverse(){
  if (state != PlayState.FASTREVERSE) {
    fastReverseButton.setEnabled(false);
    reverseButton.setEnabled(true);
    pauseButton.setEnabled(true);
    forwardButton.setEnabled(true);
    fastforwardButton.setEnabled(true);
    PlayState prevState=state;
    state=PlayState.FASTREVERSE;
    wakeup(prevState);
    timeCounter.setIncrement(-speed * ffMultiplier);
  }
}","/** 
 */
public void fastReverse(){
  if (state != PlayState.FASTREVERSE) {
    fastReverseButton.setEnabled(false);
    reverseButton.setEnabled(true);
    pauseButton.setEnabled(true);
    forwardButton.setEnabled(true);
    fastforwardButton.setEnabled(true);
    PlayState prevState=state;
    state=PlayState.FASTREVERSE;
    timeCounter.setIncrement(-speed * ffMultiplier);
    wakeup(prevState);
  }
}",0.8700980392156863
180497,"public void forward(){
  if (state != PlayState.FORWARD) {
    fastReverseButton.setEnabled(true);
    reverseButton.setEnabled(true);
    pauseButton.setEnabled(true);
    forwardButton.setEnabled(false);
    fastforwardButton.setEnabled(true);
    PlayState prevState=state;
    state=PlayState.FORWARD;
    wakeup(prevState);
    timeCounter.setIncrement(speed);
  }
}","public void forward(){
  if (state != PlayState.FORWARD) {
    fastReverseButton.setEnabled(true);
    reverseButton.setEnabled(true);
    pauseButton.setEnabled(true);
    forwardButton.setEnabled(false);
    fastforwardButton.setEnabled(true);
    PlayState prevState=state;
    state=PlayState.FORWARD;
    timeCounter.setIncrement(speed);
    wakeup(prevState);
  }
}",0.9380053908355797
180498,"public void reverse(){
  if (state != PlayState.REVERSE) {
    fastReverseButton.setEnabled(true);
    reverseButton.setEnabled(false);
    pauseButton.setEnabled(true);
    forwardButton.setEnabled(true);
    fastforwardButton.setEnabled(true);
    PlayState prevState=state;
    state=PlayState.REVERSE;
    wakeup(prevState);
    timeCounter.setIncrement(-speed);
  }
}","public void reverse(){
  if (state != PlayState.REVERSE) {
    fastReverseButton.setEnabled(true);
    reverseButton.setEnabled(false);
    pauseButton.setEnabled(true);
    forwardButton.setEnabled(true);
    fastforwardButton.setEnabled(true);
    PlayState prevState=state;
    state=PlayState.REVERSE;
    timeCounter.setIncrement(-speed);
    wakeup(prevState);
  }
}",0.9381720430107529
180499,"public String toString(){
  return (time + ""String_Node_Str"" + type+ ""String_Node_Str""+ param1+ ""String_Node_Str""+ param2+ ""String_Node_Str"");
}","@Override public String toString(){
  return (time + ""String_Node_Str"" + type+ ""String_Node_Str""+ param1+ ""String_Node_Str""+ param2+ ""String_Node_Str"");
}",0.9664429530201344
180500,"@Override public void mousePressed(MouseEvent arg0){
  prevState=eventthread.state;
  pauseButton.doClick();
}","@Override public void mousePressed(MouseEvent arg0){
  prevState=eventthread.state;
  eventthread.pause();
}",0.8807339449541285
180501,"public synchronized void pause(){
  if (state != PlayState.PAUSE) {
    if (eventthread.atFront()) {
      fastReverseButton.setEnabled(false);
      reverseButton.setEnabled(false);
    }
 else {
      fastReverseButton.setEnabled(true);
      reverseButton.setEnabled(true);
    }
    pauseButton.setEnabled(false);
    if (eventthread.atBack()) {
      forwardButton.setEnabled(false);
      fastforwardButton.setEnabled(false);
    }
 else {
      forwardButton.setEnabled(true);
      fastforwardButton.setEnabled(true);
    }
    state=PlayState.PAUSE;
    notify();
    schedule.stop();
    vv.repaint();
  }
}","public synchronized void pause(){
  if (eventthread.atFront()) {
    fastReverseButton.setEnabled(false);
    reverseButton.setEnabled(false);
  }
 else {
    fastReverseButton.setEnabled(true);
    reverseButton.setEnabled(true);
  }
  pauseButton.setEnabled(false);
  if (eventthread.atBack()) {
    forwardButton.setEnabled(false);
    fastforwardButton.setEnabled(false);
  }
 else {
    forwardButton.setEnabled(true);
    fastforwardButton.setEnabled(true);
  }
  if (state != PlayState.PAUSE) {
    state=PlayState.PAUSE;
    notify();
    schedule.stop();
    vv.repaint();
  }
}",0.2541528239202658
180502,"@Override public void mouseReleased(MouseEvent arg0){
  if (prevState == PlayState.FASTREVERSE) {
    fastReverseButton.doClick();
  }
 else   if (prevState == PlayState.REVERSE) {
    reverseButton.doClick();
  }
 else   if (prevState == PlayState.FORWARD) {
    forwardButton.doClick();
  }
 else   if (prevState == PlayState.FASTFORWARD) {
    fastforwardButton.doClick();
  }
}","@Override public void mouseReleased(MouseEvent arg0){
  if (prevState == PlayState.FASTREVERSE) {
    eventthread.fastReverse();
  }
 else   if (prevState == PlayState.REVERSE) {
    eventthread.reverse();
  }
 else   if (prevState == PlayState.FORWARD) {
    eventthread.forward();
  }
 else   if (prevState == PlayState.FASTFORWARD) {
    eventthread.fastForward();
  }
 else   if (prevState == PlayState.PAUSE) {
    eventthread.pause();
  }
}",0.7327690447400241
180503,"public void goToTime(int value){
  PlayState prevState=state;
  if (value < timeCounter.getTime()) {
    state=PlayState.REVERSE;
  }
 else {
    state=PlayState.FORWARD;
  }
  for (  LogEvent evt : getLogEventsUntil(value)) {
    handleLogEvent(evt);
  }
  vv.repaint();
  timeCounter.setTime(value);
  wakeup(prevState);
  state=prevState;
  schedule.start();
}","public void goToTime(int value){
  PlayState prevState=state;
  if (value < timeCounter.getTime()) {
    state=PlayState.REVERSE;
  }
 else {
    state=PlayState.FORWARD;
  }
  for (  LogEvent evt : getLogEventsUntil(value)) {
    handleLogEvent(evt);
  }
  vv.repaint();
  timeCounter.setTime(value);
  state=prevState;
}",0.94014598540146
180504,"public static RemoteViews buildView(int appWidgetId) throws ServiceUnavailableException, ParsingError {
  Document doc;
  try {
    FileInputStream inputStream=MyApp.getContext().openFileInput(""String_Node_Str"" + appWidgetId);
    doc=Jsoup.parse(inputStream,""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    throw new Error(e);
  }
  List<String> sectionLabels=getSectionLabels(doc);
  if (!doc.select(""String_Node_Str"").isEmpty()) {
    throw new ServiceUnavailableException();
  }
  if (!doc.select(""String_Node_Str"").isEmpty()) {
    throw new ServiceUnavailableException();
  }
  if (sectionLabels.equals(Arrays.asList(new String[]{""String_Node_Str""}))) {
    return callingCardView(doc);
  }
 else   if (sectionLabels.equals(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}))) {
    return smartPhoneView(doc);
  }
 else {
    throw new ParsingError(""String_Node_Str"");
  }
}","public static RemoteViews buildView(int appWidgetId) throws ServiceUnavailableException, ParsingError {
  Document doc;
  try {
    FileInputStream inputStream=MyApp.getContext().openFileInput(""String_Node_Str"" + appWidgetId);
    doc=Jsoup.parse(inputStream,""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    throw new Error(e);
  }
  List<String> sectionLabels=getSectionLabels(doc);
  if (!doc.select(""String_Node_Str"").isEmpty()) {
    throw new ServiceUnavailableException();
  }
  if (!doc.select(""String_Node_Str"").isEmpty()) {
    throw new ServiceUnavailableException();
  }
  if (sectionLabels.equals(Arrays.asList(new String[]{""String_Node_Str""}))) {
    return callingCardView(doc);
  }
 else   if (sectionLabels.equals(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}))) {
    return smartPhoneView(doc);
  }
 else   if (sectionLabels.equals(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}))) {
    return smartPhoneView(doc);
  }
 else {
    throw new ParsingError(""String_Node_Str"");
  }
}",0.9120982986767486
180505,"private void showScraperState(){
switch (scraperThread.result) {
case SCRAPE_IN_PROGRESS:
    if (progressDialog == null) {
      progressDialog=ProgressDialog.show(this,null,getString(R.string.configure_loading));
    }
  break;
case SCRAPE_COMPLETE:
dismissDialogs();
if (scraperThread.subscribers != null) {
if (pickSubscriberDialog == null) {
  final String[] phoneNumbers=scraperThread.subscribers;
  pickSubscriberDialog=new AlertDialog.Builder(this).setTitle(R.string.pick_phone_number).setCancelable(false).setItems(phoneNumbers,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int item){
      PreferencesData preferences=TelusWidgetPreferences.getPreferences(appWidgetId);
      preferences.subscriber=phoneNumbers[item];
      preferences.lastUpdateTime=-1;
      preferences.save();
      scraperThreadsMap.remove(appWidgetId);
      finishOk();
    }
  }
).show();
}
}
 else {
finishOk();
}
break;
case SCRAPE_ERROR:
dismissDialogs();
if (errorDialog == null) {
errorDialog=new AlertDialog.Builder(this).setTitle(R.string.unable_to_add_widget).setMessage(scraperThread.errorMessageId).setCancelable(false).setPositiveButton(R.string.okay,new AlertDialog.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
TelusWidgetPreferences.deletePreferences(appWidgetId);
scraperThreadsMap.remove(appWidgetId);
dismissDialogs();
}
}
).show();
}
break;
}
}","private void showScraperState(){
}",0.046639231824417
180506,"@Override public void handleMessage(Message msg){
  if (scraperThread.result == SCRAPE_PARSING_ERROR) {
    Intent intent=new Intent(ConfigureActivity.this,ReportAccountErrorActivity.class);
    intent.setAction(getPackageName() + ""String_Node_Str"");
    intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetId);
    startActivity(intent);
  }
 else {
    showScraperState();
  }
}","public void handleMessage(Message msg){
  if (!isFinishing()) {
    showScraperState();
  }
}",0.3651452282157676
180507,"@Override public void run(){
  int r=SCRAPE_COMPLETE;
  try {
    TelusReportFetcher.retriveUsageSummaryData(appWidgetId);
    subscribers=ReportParser.subscribers(appWidgetId);
  }
 catch (  TelusReportFetcher.InvalidCredentialsException e) {
    r=SCRAPE_ERROR;
    errorMessageId=R.string.invalid_credentials;
  }
catch (  TelusReportFetcher.NetworkErrorException e) {
    r=SCRAPE_ERROR;
    errorMessageId=R.string.network_error;
  }
catch (  ReportParser.ServiceUnavailableException e) {
    r=SCRAPE_ERROR;
    errorMessageId=R.string.widget_service_unavailable;
  }
catch (  ReportParser.ParsingError e) {
    r=SCRAPE_PARSING_ERROR;
  }
  result=r;
  Handler handler=scraperCompletedHandler;
  if (handler != null)   handler.sendEmptyMessage(0);
}","@Override public void run(){
  ScrapeResult r=ScrapeResult.COMPLETE;
  try {
    TelusReportFetcher.retriveUsageSummaryData(appWidgetId);
    subscribers=ReportParser.subscribers(appWidgetId);
  }
 catch (  TelusReportFetcher.InvalidCredentialsException e) {
    r=ScrapeResult.ERROR;
    errorMessageId=R.string.invalid_credentials;
  }
catch (  TelusReportFetcher.NetworkErrorException e) {
    r=ScrapeResult.ERROR;
    errorMessageId=R.string.network_error;
  }
catch (  ReportParser.ServiceUnavailableException e) {
    r=ScrapeResult.ERROR;
    errorMessageId=R.string.widget_service_unavailable;
  }
catch (  ReportParser.ParsingError e) {
    r=ScrapeResult.PARSING_ERROR;
  }
  result=r;
  Handler handler=scraperCompletedHandler;
  if (handler != null)   handler.sendEmptyMessage(0);
}",0.7595099935525468
180508,"private void registerScraperCompletedHandler(){
  Handler handler=new Handler(){
    @Override public void handleMessage(    Message msg){
      if (scraperThread.result == SCRAPE_PARSING_ERROR) {
        Intent intent=new Intent(ConfigureActivity.this,ReportAccountErrorActivity.class);
        intent.setAction(getPackageName() + ""String_Node_Str"");
        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetId);
        startActivity(intent);
      }
 else {
        showScraperState();
      }
    }
  }
;
  scraperThread.scraperCompletedHandler=handler;
}","private void registerScraperCompletedHandler(){
  Handler handler=new Handler(){
    public void handleMessage(    Message msg){
      if (!isFinishing()) {
        showScraperState();
      }
    }
  }
;
  scraperThread.scraperCompletedHandler=handler;
}",0.5811138014527845
180509,"@Override public void handleMessage(Message msg){
  showPostState();
}","public void handleMessage(Message msg){
  if (!isFinishing()) {
    showPostState();
  }
}",0.75
180510,"@Override public void run(){
  String url=""String_Node_Str"" + ""String_Node_Str"" + MyApp.getVersionCode();
  final DefaultHttpClient httpclient=new DefaultHttpClient();
  HttpPost httpPost=new HttpPost(url);
  httpPost.setEntity(new InputStreamEntity(dataStream,-1));
  int r=POST_COMPLETE;
  try {
    httpclient.execute(httpPost);
  }
 catch (  Exception e) {
    r=POST_ERROR;
  }
  result=r;
  Handler handler=postCompletedHandler;
  if (handler != null)   handler.sendEmptyMessage(0);
}","@Override public void run(){
  String url=""String_Node_Str"" + ""String_Node_Str"" + MyApp.getVersionCode();
  final DefaultHttpClient httpclient=new DefaultHttpClient();
  HttpPost httpPost=new HttpPost(url);
  httpPost.setEntity(new InputStreamEntity(dataStream,-1));
  PostResult r=PostResult.COMPLETE;
  try {
    httpclient.execute(httpPost);
  }
 catch (  Exception e) {
    r=PostResult.ERROR;
  }
  result=r;
  Handler handler=postCompletedHandler;
  if (handler != null)   handler.sendEmptyMessage(0);
}",0.950950950950951
180511,"private void showPostState(){
switch (postDataThread.result) {
case POST_IN_PROGRESS:
    if (progressDialog == null) {
      progressDialog=ProgressDialog.show(this,null,getString(R.string.sending_data));
    }
  break;
case POST_COMPLETE:
dismissDialogs();
if (completeDialog == null) {
completeDialog=new AlertDialog.Builder(this).setMessage(R.string.report_sent).setCancelable(false).setPositiveButton(R.string.okay,new AlertDialog.OnClickListener(){
  public void onClick(  DialogInterface dialog,  int which){
    postDataThreadsMap.remove(appWidgetId);
    finish();
  }
}
).show();
}
break;
case POST_ERROR:
dismissDialogs();
if (errorDialog == null) {
errorDialog=new AlertDialog.Builder(this).setMessage(R.string.unable_to_send_data).setCancelable(false).setPositiveButton(R.string.okay,new AlertDialog.OnClickListener(){
public void onClick(DialogInterface dialog,int which){
postDataThreadsMap.remove(appWidgetId);
dismissDialogs();
}
}
).show();
}
break;
}
}","private void showPostState(){
}",0.06187624750499
180512,"private void registerPostCompletedHandler(){
  Handler handler=new Handler(){
    @Override public void handleMessage(    Message msg){
      showPostState();
    }
  }
;
  postDataThread.postCompletedHandler=handler;
}","private void registerPostCompletedHandler(){
  Handler handler=new Handler(){
    public void handleMessage(    Message msg){
      if (!isFinishing()) {
        showPostState();
      }
    }
  }
;
  postDataThread.postCompletedHandler=handler;
}",0.8969957081545065
180513,"private RemoteViews networkErrorRemoteViews(PreferencesData prefData){
  RemoteViews updateViews=new RemoteViews(getPackageName(),R.layout.widget_network_error);
  Intent defineIntent=new Intent(this,TelusWidgetUpdateService.class);
  defineIntent.setAction(ACTION_UPDATE_WIDGET);
  defineIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,prefData.appWidgetId);
  PendingIntent pendingIntent=PendingIntent.getService(this,prefData.appWidgetId,defineIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  updateViews.setOnClickPendingIntent(R.id.widget,pendingIntent);
  return updateViews;
}","private RemoteViews networkErrorRemoteViews(PreferencesData prefData){
  RemoteViews updateViews=new RemoteViews(getPackageName(),R.layout.widget_network_error);
  Intent defineIntent=new Intent(this,TelusWidgetProvider.class);
  defineIntent.setAction(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  defineIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS,new int[]{prefData.appWidgetId});
  PendingIntent pendingIntent=PendingIntent.getBroadcast(this,prefData.appWidgetId,defineIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  updateViews.setOnClickPendingIntent(R.id.widget,pendingIntent);
  return updateViews;
}",0.8066945606694561
180514,"public void run(){
  try {
    updateWidget(appWidgetId);
    stopSelf(startId);
  }
  finally {
    widgetThreads.remove(appWidgetId);
    wakeLock.release();
  }
}","public void run(){
  try {
    updateWidget(appWidgetId);
synchronized (TelusWidgetUpdateService.this) {
      taskCount--;
      if (taskCount == 0)       stopSelf(lastTaskId);
    }
  }
  finally {
synchronized (TelusWidgetUpdateService.this) {
      widgetThreads.remove(appWidgetId);
    }
    wakeLock.release();
  }
}",0.6147540983606558
180515,"@Override public void onStart(Intent intent,final int startId){
  if (!intent.getAction().equals(ACTION_UPDATE_WIDGET)) {
    stopSelf(startId);
    return;
  }
  Bundle extra=intent.getExtras();
  final int appWidgetId=extra.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
  Thread thread=new Thread(TelusWidgetUpdateService.class.toString() + appWidgetId){
    public void run(){
      try {
        updateWidget(appWidgetId);
        stopSelf(startId);
      }
  finally {
        widgetThreads.remove(appWidgetId);
        wakeLock.release();
      }
    }
  }
;
  Thread previousThread=widgetThreads.putIfAbsent(appWidgetId,thread);
  if (previousThread == null) {
    thread.start();
  }
}","@Override public void onStart(Intent intent,final int startId){
  if (!intent.getAction().equals(ACTION_UPDATE_WIDGET)) {
    stopSelf(startId);
    return;
  }
  Bundle extra=intent.getExtras();
  final int appWidgetId=extra.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
synchronized (this) {
    lastTaskId=startId;
    if (!widgetThreads.containsKey(appWidgetId)) {
      Thread thread=createWidgetThread(appWidgetId);
      widgetThreads.put(appWidgetId,thread);
      taskCount++;
      thread.start();
    }
  }
}",0.4743801652892562
180516,"private String extract8ASignature(){
  String s1=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{12,15,16});
  String s2=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{3,8,9,10,11,12,13,14,17});
  String s3=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{4,5});
  String s4=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{4,5,6,7,8});
  String s5=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15});
  return s1 + s2 + s3+ s4+ s5;
}","private String extract8ASignature() throws Exception {
  String s1=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{12,15,16});
  String s2=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{3,8,9,10,11,12,13,14,17});
  String s3=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{4,5});
  String s4=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{4,5,6,7,8});
  String s5=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15});
  return s1 + s2 + s3+ s4+ s5;
}",0.9842381786339754
180517,"public String getStachelhausCode(){
  return this.sigstach;
}","public String getStachelhausCode() throws Exception {
  return extractStachelhausSignature();
}",0.6794871794871795
180518,"public void run(){
  removeToplineIndels();
  sig8a=extract8ASignature();
  sigstach=extractStachelhausSignature();
}","public void run(){
  removeToplineIndels();
}",0.5555555555555556
180519,"public static void main(String[] args){
  ADomSigExtractor e=new ADomSigExtractor();
  e.setADomainTopline(""String_Node_Str"");
  e.setADomainDownline(""String_Node_Str"");
  e.setLysDomainTopline(""String_Node_Str"");
  e.setLysDomainDownline(""String_Node_Str"");
  e.run();
  System.out.println(e.get8ASignature());
  System.out.println(e.getStachelhausCode());
}","public static void main(String[] args) throws Exception {
  ADomSigExtractor e=new ADomSigExtractor();
  e.setADomainTopline(""String_Node_Str"");
  e.setADomainDownline(""String_Node_Str"");
  e.setLysDomainTopline(""String_Node_Str"");
  e.setLysDomainDownline(""String_Node_Str"");
  e.run();
  System.out.println(e.get8ASignature());
  System.out.println(e.getStachelhausCode());
}",0.9103260869565216
180520,"private String extractStachelhausSignature(){
  String s2=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{9,10,13});
  String s3=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{4});
  String s4=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{4,6});
  String s5=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{3,11,12});
  String s6=extractCharacters(lys_topline,lys_downline,""String_Node_Str"",new int[]{13});
  return s2 + s3 + s4+ s5+ (s6.equals(""String_Node_Str"") ? ""String_Node_Str"" : s6);
}","private String extractStachelhausSignature() throws Exception {
  String s2=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{9,10,13});
  String s3=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{4});
  String s4=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{4,6});
  String s5=extractCharacters(a_topline,a_downline,""String_Node_Str"",new int[]{3,11,12});
  String s6=""String_Node_Str"";
  if (!lys_topline.equals(""String_Node_Str""))   s6=extractCharacters(lys_topline,lys_downline,""String_Node_Str"",new int[]{13});
  return s2 + s3 + s4+ s5+ s6;
}",0.88
180521,"private String extractCharacters(String target,String source,String anchor_pattern,int[] idxs){
  int start_idx=target.indexOf(anchor_pattern);
  String ret=""String_Node_Str"";
  if (start_idx < 0)   return ret;
  for (  Integer idx : idxs) {
    ret+=source.charAt(start_idx + idx);
  }
  return ret;
}","private String extractCharacters(String target,String source,String anchor_pattern,int[] idxs) throws Exception {
  int start_idx=target.indexOf(anchor_pattern);
  String ret=""String_Node_Str"";
  if (start_idx < 0)   throw new Exception(""String_Node_Str"");
  for (  Integer idx : idxs) {
    ret+=source.charAt(start_idx + idx);
  }
  return ret;
}",0.8984615384615384
180522,"public String get8ASignature(){
  return this.sig8a;
}","public String get8ASignature() throws Exception {
  return extract8ASignature();
}",0.7058823529411765
180523,"private static void extractSigs(String infile) throws Exception {
  HMMPfam hmmpfam=new HMMPfam();
  File model=Helper.deployFile(ResourceManager.class.getResourceAsStream(""String_Node_Str""));
  hmmpfam.run(0.00001,model,new File(infile));
  List<QueryResult> res=hmmpfam.getResults();
  ADomain cur_adom=null;
  for (  QueryResult qr : res) {
    List<DomainHit> hits=qr.getHits();
    List<DomainAlignment> alis=qr.getAlignments();
    int N=hits.size();
    for (int i=0; i < N; i+=2) {
      DomainAlignment adom=alis.get(i);
      DomainHit adom_hit=hits.get(i);
      String a_topline=adom.target;
      String a_downline=adom.query;
      String l_topline=""String_Node_Str"";
      String l_downline=""String_Node_Str"";
      if ((i + 1) < alis.size()) {
        DomainAlignment lys=alis.get(i + 1);
        l_topline=lys.target;
        l_downline=lys.query;
      }
      ADomSigExtractor e=new ADomSigExtractor();
      e.setADomainTopline(a_topline);
      e.setADomainDownline(a_downline);
      e.setLysDomainTopline(l_topline);
      e.setLysDomainDownline(l_downline);
      e.run();
      cur_adom=new ADomain();
      cur_adom.sig8a=e.get8ASignature();
      cur_adom.sigstach=e.getStachelhausCode();
      cur_adom.sid=qr.getQueryId();
      cur_adom.startPos=adom_hit.seqfrom;
      cur_adom.endPos=adom_hit.seqto;
      cur_adom.pfamscore=adom_hit.score;
      adoms.add(cur_adom);
    }
  }
}","private static void extractSigs(String infile) throws Exception {
  HMMPfam hmmpfam=new HMMPfam();
  File model=Helper.deployFile(ResourceManager.class.getResourceAsStream(""String_Node_Str""));
  hmmpfam.run(evalue,model,new File(infile));
  List<QueryResult> res=hmmpfam.getResults();
  ADomain cur_adom=null;
  for (  QueryResult qr : res) {
    List<DomainHit> hits=qr.getHits();
    List<DomainAlignment> alis=qr.getAlignments();
    int N=hits.size();
    List<DomainHit> a_hits=new ArrayList<DomainHit>();
    List<DomainAlignment> a_alis=new ArrayList<DomainAlignment>();
    List<DomainHit> l_hits=new ArrayList<DomainHit>();
    List<DomainAlignment> l_alis=new ArrayList<DomainAlignment>();
    for (int i=0; i < N; i++) {
      DomainHit hit=hits.get(i);
      DomainAlignment ali=alis.get(i);
      if (hit.hmmname.equals(""String_Node_Str"")) {
        a_alis.add(ali);
        a_hits.add(hit);
      }
      if (hit.hmmname.equals(""String_Node_Str"")) {
        l_alis.add(ali);
        l_hits.add(hit);
      }
    }
    int A=a_hits.size();
    int L=l_hits.size();
    Map<Integer,Integer> aIdx2lIdx=new HashMap<Integer,Integer>();
    int J=0;
    for (int i=0; i < A; i++) {
      DomainHit adom_hit=a_hits.get(i);
      int Aend=adom_hit.seqto;
      for (int j=J; j < L; j++) {
        DomainHit lys_hit=l_hits.get(j);
        int Lstart=lys_hit.seqfrom;
        if ((Aend + 200) > Lstart && (Aend < Lstart)) {
          debug(""String_Node_Str"" + i + ""String_Node_Str""+ j);
          aIdx2lIdx.put(i,j);
          J++;
          break;
        }
      }
    }
    for (int i=0; i < A; i++) {
      DomainHit adom_hit=a_hits.get(i);
      DomainAlignment adom_ali=a_alis.get(i);
      DomainAlignment ldom_ali=null;
      Integer mIdx=aIdx2lIdx.get(i);
      if (mIdx != null) {
        ldom_ali=l_alis.get(aIdx2lIdx.get(i));
      }
      ADomSigExtractor e=new ADomSigExtractor();
      e.setADomain(adom_ali);
      e.setLDomain(ldom_ali);
      e.run();
      cur_adom=new ADomain();
      try {
        cur_adom.sig8a=e.get8ASignature();
        cur_adom.sigstach=e.getStachelhausCode();
      }
 catch (      Exception ex) {
        continue;
      }
      debug(cur_adom.sig8a + ""String_Node_Str"" + cur_adom.sigstach);
      cur_adom.sid=qr.getQueryId();
      cur_adom.startPos=adom_hit.seqfrom;
      cur_adom.endPos=adom_hit.seqto;
      cur_adom.pfamscore=adom_hit.score;
      adoms.add(cur_adom);
    }
  }
}",0.12006237006237
180524,"public static void banner(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
}","public static void banner(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (debug)   System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
}",0.8531684698608965
180525,"public static void parseCommandline(String[] argv){
  fillPrecs();
  Getopt g=new Getopt(""String_Node_Str"",argv,""String_Node_Str"");
  int c;
  String arg;
  while ((c=g.getopt()) != -1) {
switch (c) {
case 's':
      arg=g.getOptarg();
    if (arg.equals(""String_Node_Str""))     extractsigs=false;
 else     extractsigs=true;
  break;
case 'b':
arg=g.getOptarg();
if (arg.equals(""String_Node_Str"")) bacterialMode=true;
 else bacterialMode=false;
break;
case 'i':
arg=g.getOptarg();
inputfile=arg;
break;
case 'r':
arg=g.getOptarg();
reportfile=arg;
break;
case 'o':
arg=g.getOptarg();
outputfile=arg;
break;
default :
break;
}
}
}","public static void parseCommandline(String[] argv){
  fillPrecs();
  Getopt g=new Getopt(""String_Node_Str"",argv,""String_Node_Str"");
  int c;
  String arg;
  while ((c=g.getopt()) != -1) {
switch (c) {
case 's':
      arg=g.getOptarg();
    if (arg.equals(""String_Node_Str""))     extractsigs=false;
 else     extractsigs=true;
  break;
case 'b':
arg=g.getOptarg();
if (arg.equals(""String_Node_Str"")) bacterialMode=true;
 else bacterialMode=false;
break;
case 'i':
arg=g.getOptarg();
inputfile=arg;
break;
case 'r':
arg=g.getOptarg();
reportfile=arg;
break;
case 'o':
arg=g.getOptarg();
outputfile=arg;
break;
case 'd':
debug=true;
debug(""String_Node_Str"");
break;
default :
break;
}
}
}",0.9460076045627376
180526,"public static void main(String[] argv) throws Exception {
  Locale locale=new Locale(""String_Node_Str"",""String_Node_Str"");
  Locale.setDefault(locale);
  try {
    datadir=System.getProperty(""String_Node_Str"",datadir);
    if (argv.length == 0) {
      banner();
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
    initSigDB();
    parseCommandline(argv);
    banner();
    if (extractsigs) {
      System.out.println(""String_Node_Str"");
      extractSigs(inputfile);
    }
 else {
      System.out.println(""String_Node_Str"");
      parseSigs(inputfile);
    }
    System.out.println(""String_Node_Str"" + adoms.size() + ""String_Node_Str"");
    if (bacterialMode) {
      System.out.println(""String_Node_Str"");
      bacterialPrediction();
    }
 else {
      System.out.println(""String_Node_Str"");
      fungalPrediction();
    }
    if (outputfile != null)     store(outputfile,adoms);
    if (reportfile != null)     report(reportfile,adoms);
  }
 catch (  Throwable e) {
    e.printStackTrace();
    System.exit(1);
  }
}","public static void main(String[] argv) throws Exception {
  Locale locale=new Locale(""String_Node_Str"",""String_Node_Str"");
  Locale.setDefault(locale);
  try {
    datadir=System.getProperty(""String_Node_Str"",datadir);
    evalue=Double.parseDouble(System.getProperty(""String_Node_Str"",""String_Node_Str""));
    if (argv.length == 0) {
      banner();
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
    initSigDB();
    parseCommandline(argv);
    banner();
    if (extractsigs) {
      System.out.println(""String_Node_Str"");
      extractSigs(inputfile);
    }
 else {
      System.out.println(""String_Node_Str"");
      parseSigs(inputfile);
    }
    System.out.println(""String_Node_Str"" + adoms.size() + ""String_Node_Str"");
    if (bacterialMode) {
      System.out.println(""String_Node_Str"");
      bacterialPrediction();
    }
 else {
      System.out.println(""String_Node_Str"");
      fungalPrediction();
    }
    if (outputfile != null)     store(outputfile,adoms);
    if (reportfile != null)     report(reportfile,adoms);
  }
 catch (  Throwable e) {
    e.printStackTrace();
    System.exit(1);
  }
}",0.9654088050314464
180527,"public void doExport(HttpServletRequest req,HttpServletResponse resp) throws IOException, ServletException {
  IFileStore source=NewFileServlet.getFileStore(sourcePath);
  try {
    if (source.fetchInfo().isDirectory() && source.childNames(EFS.NONE,null).length == 0) {
      resp.sendError(HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"");
      return;
    }
    ZipOutputStream zout=new ZipOutputStream(resp.getOutputStream());
    write(source,Path.EMPTY,zout);
    zout.finish();
  }
 catch (  CoreException e) {
    throw new ServletException(e);
  }
}","public void doExport(HttpServletRequest req,HttpServletResponse resp) throws IOException, ServletException {
  IFileStore source=NewFileServlet.getFileStore(sourcePath);
  try {
    if (source.fetchInfo().isDirectory() && source.childNames(EFS.NONE,null).length == 0) {
      resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED,""String_Node_Str"");
      return;
    }
    ZipOutputStream zout=new ZipOutputStream(resp.getOutputStream());
    write(source,Path.EMPTY,zout);
    zout.finish();
  }
 catch (  CoreException e) {
    throw new ServletException(e);
  }
}",0.9849690539345712
180528,"private void addTransferLinks(URI resource,JSONObject representation) throws URISyntaxException, JSONException {
  URI location=new URI(representation.getString(ProtocolConstants.KEY_LOCATION));
  IPath targetPath=new Path(location.getPath()).removeFirstSegments(1).removeTrailingSeparator();
  IPath path=new Path(""String_Node_Str"").append(targetPath);
  URI link=new URI(resource.getScheme(),resource.getAuthority(),path.toString(),null,null);
  representation.put(ProtocolConstants.KEY_IMPORT_LOCATION,link);
  if (isEmptyDirectory(targetPath))   return;
  path=new Path(""String_Node_Str"").append(targetPath).addFileExtension(""String_Node_Str"");
  link=new URI(resource.getScheme(),resource.getAuthority(),path.toString(),null,null);
  representation.put(ProtocolConstants.KEY_EXPORT_LOCATION,link);
}","private void addTransferLinks(URI resource,JSONObject representation) throws URISyntaxException, JSONException {
  URI location=new URI(representation.getString(ProtocolConstants.KEY_LOCATION));
  IPath targetPath=new Path(location.getPath()).removeFirstSegments(1).removeTrailingSeparator();
  IPath path=new Path(""String_Node_Str"").append(targetPath);
  URI link=new URI(resource.getScheme(),resource.getAuthority(),path.toString(),null,null);
  representation.put(ProtocolConstants.KEY_IMPORT_LOCATION,link);
  path=new Path(""String_Node_Str"").append(targetPath).addFileExtension(""String_Node_Str"");
  link=new URI(resource.getScheme(),resource.getAuthority(),path.toString(),null,null);
  representation.put(ProtocolConstants.KEY_EXPORT_LOCATION,link);
}",0.970550576184379
180529,"public static void writeJSONResponse(HttpServletRequest req,HttpServletResponse resp,Object result) throws IOException {
  Assert.isLegal(result instanceof JSONObject || result instanceof JSONArray);
  resp.setStatus(HttpServletResponse.SC_OK);
  resp.setHeader(""String_Node_Str"",""String_Node_Str"");
  if (result instanceof JSONObject) {
    decorateResponse(req,(JSONObject)result);
    removeOwnProtocolHostPort((JSONObject)result,req.getScheme(),req.getServerName(),req.getServerPort());
  }
  resp.setContentType(ProtocolConstants.CONTENT_TYPE_JSON);
  String response=prettyPrint(result);
  resp.getWriter().print(response);
  LoggerFactory.getLogger(OrionServlet.class).debug(response);
}","public static void writeJSONResponse(HttpServletRequest req,HttpServletResponse resp,Object result) throws IOException {
  Assert.isLegal(result instanceof JSONObject || result instanceof JSONArray);
  resp.setStatus(HttpServletResponse.SC_OK);
  resp.setHeader(""String_Node_Str"",""String_Node_Str"");
  if (result instanceof JSONObject) {
    decorateResponse(req,(JSONObject)result);
  }
  resp.setContentType(ProtocolConstants.CONTENT_TYPE_JSON);
  String response=prettyPrint(result);
  resp.getWriter().print(response);
  LoggerFactory.getLogger(OrionServlet.class).debug(response);
}",0.9164715066354412
180530,"private void addGitLinks(URI location,JSONObject representation) throws URISyntaxException, JSONException, CoreException, IOException {
  JSONObject gitSection=new JSONObject();
  IPath targetPath=new Path(location.getPath());
  IPath path=new Path(GitServlet.GIT_URI + '/' + GitConstants.DIFF_RESOURCE+ '/'+ GitConstants.KEY_DIFF_DEFAULT).append(targetPath);
  URI link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_DIFF,link.toString());
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.STATUS_RESOURCE).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_STATUS,link.toString());
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.INDEX_RESOURCE).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_INDEX,link.toString());
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.COMMIT_RESOURCE).append(Constants.HEAD).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_COMMIT,link.toString());
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.REMOTE_RESOURCE).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_REMOTE,link.toString());
  File gitDir=GitUtils.getGitDir(targetPath);
  Repository db=new FileRepository(gitDir);
  for (  Entry<String,Ref> refEntry : db.getRefDatabase().getRefs(Constants.R_REMOTES).entrySet()) {
    if (!refEntry.getValue().isSymbolic()) {
      Ref ref=refEntry.getValue();
      String shortName=Repository.shortenRefName(ref.getName());
      if (db.getBranch().equals(shortName.substring(Constants.DEFAULT_REMOTE_NAME.length() + 1))) {
        link=new URI(location.getScheme(),location.getAuthority(),GitRemoteHandlerV1.baseToRemoteLocation(link,2,shortName).getPath(),null,null);
        gitSection.put(GitConstants.KEY_DEFAULT_REMOTE_BRANCH,link);
        break;
      }
    }
  }
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.TAG_RESOURCE).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_TAG,link.toString());
  representation.put(GitConstants.KEY_GIT,gitSection);
}","private void addGitLinks(URI location,JSONObject representation) throws URISyntaxException, JSONException, CoreException, IOException {
  JSONObject gitSection=new JSONObject();
  IPath targetPath=new Path(location.getPath());
  IPath path=new Path(GitServlet.GIT_URI + '/' + GitConstants.DIFF_RESOURCE+ '/'+ GitConstants.KEY_DIFF_DEFAULT).append(targetPath);
  URI link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_DIFF,link);
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.STATUS_RESOURCE).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_STATUS,link);
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.INDEX_RESOURCE).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_INDEX,link);
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.COMMIT_RESOURCE).append(Constants.HEAD).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_COMMIT,link);
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.REMOTE_RESOURCE).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_REMOTE,link);
  File gitDir=GitUtils.getGitDir(targetPath);
  Repository db=new FileRepository(gitDir);
  for (  Entry<String,Ref> refEntry : db.getRefDatabase().getRefs(Constants.R_REMOTES).entrySet()) {
    if (!refEntry.getValue().isSymbolic()) {
      Ref ref=refEntry.getValue();
      String shortName=Repository.shortenRefName(ref.getName());
      if (db.getBranch().equals(shortName.substring(Constants.DEFAULT_REMOTE_NAME.length() + 1))) {
        link=new URI(location.getScheme(),location.getAuthority(),GitRemoteHandlerV1.baseToRemoteLocation(link,2,shortName).getPath(),null,null);
        gitSection.put(GitConstants.KEY_DEFAULT_REMOTE_BRANCH,link);
        break;
      }
    }
  }
  path=new Path(GitServlet.GIT_URI + '/' + GitConstants.TAG_RESOURCE).append(targetPath);
  link=new URI(location.getScheme(),location.getAuthority(),path.toString(),null,null);
  gitSection.put(GitConstants.KEY_TAG,link);
  representation.put(GitConstants.KEY_GIT,gitSection);
}",0.986425339366516
180531,"public void addAtributesFor(HttpServletRequest request,URI resource,JSONObject representation){
  IPath resourcePath=new Path(resource.getPath());
  if (resourcePath.segmentCount() == 0)   return;
  String service=resourcePath.segment(0);
  if (!(""String_Node_Str"".equals(service) || ""String_Node_Str"".equals(service)))   return;
  try {
    URI result=new URI(resource.getScheme(),resource.getUserInfo(),resource.getHost(),resource.getPort(),""String_Node_Str"",""String_Node_Str"",null);
    representation.put(ProtocolConstants.KEY_SEARCH_LOCATION,result.toString());
  }
 catch (  URISyntaxException e) {
    LogHelper.log(e);
  }
catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}","public void addAtributesFor(HttpServletRequest request,URI resource,JSONObject representation){
  IPath resourcePath=new Path(resource.getPath());
  if (resourcePath.segmentCount() == 0)   return;
  String service=resourcePath.segment(0);
  if (!(""String_Node_Str"".equals(service) || ""String_Node_Str"".equals(service)))   return;
  try {
    URI result=new URI(resource.getScheme(),resource.getUserInfo(),resource.getHost(),resource.getPort(),""String_Node_Str"",""String_Node_Str"",null);
    representation.put(ProtocolConstants.KEY_SEARCH_LOCATION,result);
  }
 catch (  URISyntaxException e) {
    LogHelper.log(e);
  }
catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}",0.9920692141312184
180532,"public static JSONObject toJSON(IFileStore store,IFileInfo info,URI location){
  JSONObject result=new JSONObject();
  try {
    result.put(ProtocolConstants.KEY_NAME,info.getName());
    result.put(ProtocolConstants.KEY_LOCAL_TIMESTAMP,info.getLastModified());
    result.put(ProtocolConstants.KEY_DIRECTORY,info.isDirectory());
    result.put(ProtocolConstants.KEY_LENGTH,info.getLength());
    if (location != null) {
      result.put(ProtocolConstants.KEY_LOCATION,location);
      if (info.isDirectory())       result.put(ProtocolConstants.KEY_CHILDREN_LOCATION,location + ""String_Node_Str"");
    }
    result.put(ProtocolConstants.KEY_ATTRIBUTES,getAttributes(store,info));
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  return result;
}","public static JSONObject toJSON(IFileStore store,IFileInfo info,URI location){
  JSONObject result=new JSONObject();
  try {
    result.put(ProtocolConstants.KEY_NAME,info.getName());
    result.put(ProtocolConstants.KEY_LOCAL_TIMESTAMP,info.getLastModified());
    result.put(ProtocolConstants.KEY_DIRECTORY,info.isDirectory());
    result.put(ProtocolConstants.KEY_LENGTH,info.getLength());
    if (location != null) {
      result.put(ProtocolConstants.KEY_LOCATION,location);
      if (info.isDirectory())       try {
        result.put(ProtocolConstants.KEY_CHILDREN_LOCATION,new URI(location.getScheme(),location.getUserInfo(),location.getHost(),location.getPort(),location.getPath(),""String_Node_Str"",location.getFragment()));
      }
 catch (      URISyntaxException e) {
        throw new RuntimeException(e);
      }
    }
    result.put(ProtocolConstants.KEY_ATTRIBUTES,getAttributes(store,info));
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  return result;
}",0.8558507631430187
180533,"/** 
 * @param baseLocation The URI of the SiteConfigurationServlet.
 * @return Representation of <code>site</code> as a JSONObject.
 */
public static JSONObject toJSON(SiteConfiguration site,URI baseLocation){
  JSONObject result=WebElementResourceHandler.toJSON(site);
  try {
    result.put(ProtocolConstants.KEY_LOCATION,URIUtil.append(baseLocation,site.getId()).toString());
    result.putOpt(SiteConfigurationConstants.KEY_HOST_HINT,site.getHostHint());
    result.putOpt(SiteConfigurationConstants.KEY_WORKSPACE,site.getWorkspace());
    result.put(SiteConfigurationConstants.KEY_MAPPINGS,site.getMappingsJSON());
  }
 catch (  JSONException e) {
  }
  return result;
}","/** 
 * @param baseLocation The URI of the SiteConfigurationServlet.
 * @return Representation of <code>site</code> as a JSONObject.
 */
public static JSONObject toJSON(SiteConfiguration site,URI baseLocation){
  JSONObject result=WebElementResourceHandler.toJSON(site);
  try {
    result.put(ProtocolConstants.KEY_LOCATION,URIUtil.append(baseLocation,site.getId()));
    result.putOpt(SiteConfigurationConstants.KEY_HOST_HINT,site.getHostHint());
    result.putOpt(SiteConfigurationConstants.KEY_WORKSPACE,site.getWorkspace());
    result.put(SiteConfigurationConstants.KEY_MAPPINGS,site.getMappingsJSON());
  }
 catch (  JSONException e) {
  }
  return result;
}",0.9917971662938104
180534,"/** 
 * Adds a parent resource representation to the parent array
 */
private void addParent(JSONArray parents,String name,URI location) throws JSONException {
  JSONObject parent=new JSONObject();
  parent.put(ProtocolConstants.KEY_NAME,name);
  parent.put(ProtocolConstants.KEY_LOCATION,location);
  String childLocation=location.toString() + ""String_Node_Str"";
  parent.put(ProtocolConstants.KEY_CHILDREN_LOCATION,childLocation);
  parents.put(parent);
}","/** 
 * Adds a parent resource representation to the parent array
 */
private void addParent(JSONArray parents,String name,URI location) throws JSONException {
  JSONObject parent=new JSONObject();
  parent.put(ProtocolConstants.KEY_NAME,name);
  parent.put(ProtocolConstants.KEY_LOCATION,location);
  URI childLocation;
  try {
    childLocation=new URI(location.getScheme(),location.getUserInfo(),location.getHost(),location.getPort(),location.getPath(),""String_Node_Str"",location.getFragment());
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e);
  }
  parent.put(ProtocolConstants.KEY_CHILDREN_LOCATION,childLocation);
  parents.put(parent);
}",0.7602131438721137
180535,"/** 
 * Returns the location of the project's content (conforming to File REST API).
 */
static String computeProjectContentLocation(URI parentLocation,WebProject project){
  URI contentLocation=project.getContentLocation();
  if (!contentLocation.isAbsolute() || ""String_Node_Str"".equals(contentLocation.getScheme())) {
    IPath contentPath=new Path(contentLocation.getPath());
    if (contentPath.isAbsolute())     contentPath=new Path(project.getId());
    contentLocation=URIUtil.append(parentLocation,""String_Node_Str"" + Activator.LOCATION_FILE_SERVLET + contentPath.makeAbsolute().toString());
  }
  String locationString=contentLocation.toString();
  if (!locationString.endsWith(""String_Node_Str""))   locationString+=""String_Node_Str"";
  return locationString;
}","/** 
 * Returns the location of the project's content (conforming to File REST API).
 */
static URI computeProjectContentLocation(URI parentLocation,WebProject project){
  URI contentLocation=project.getContentLocation();
  if (!contentLocation.isAbsolute() || ""String_Node_Str"".equals(contentLocation.getScheme())) {
    IPath contentPath=new Path(contentLocation.getPath());
    if (contentPath.isAbsolute())     contentPath=new Path(project.getId());
    String contentPathString=contentPath.makeAbsolute().toString();
    if (!contentPathString.endsWith(""String_Node_Str""))     contentPathString+=""String_Node_Str"";
    contentLocation=URIUtil.append(parentLocation,""String_Node_Str"" + Activator.LOCATION_FILE_SERVLET + contentPathString);
  }
  if (!contentLocation.getPath().endsWith(""String_Node_Str"")) {
    try {
      contentLocation=new URI(contentLocation.getScheme(),contentLocation.getUserInfo(),contentLocation.getHost(),contentLocation.getPort(),contentLocation.getPath() + ""String_Node_Str"",contentLocation.getQuery(),contentLocation.getFragment());
    }
 catch (    URISyntaxException e) {
      throw new RuntimeException(e);
    }
  }
  return contentLocation;
}",0.5997952917093142
180536,"/** 
 * Returns a JSON representation of the workspace, conforming to EclipseWeb workspace API protocol.
 * @param workspace The workspace to store
 * @param baseLocation The base location for the workspace servlet
 */
public static JSONObject toJSON(WebWorkspace workspace,URI baseLocation){
  JSONObject result=WebElementResourceHandler.toJSON(workspace);
  JSONArray projects=workspace.getProjectsJSON();
  URI workspaceLocation=URIUtil.append(baseLocation,workspace.getId());
  URI projectBaseLocation=URIUtil.append(workspaceLocation,""String_Node_Str"");
  if (projects == null)   projects=new JSONArray();
  for (int i=0; i < projects.length(); i++) {
    try {
      JSONObject project=(JSONObject)projects.get(i);
      project.put(ProtocolConstants.KEY_LOCATION,URIUtil.append(projectBaseLocation,project.getString(ProtocolConstants.KEY_ID)));
    }
 catch (    JSONException e) {
    }
  }
  try {
    result.put(ProtocolConstants.KEY_LOCATION,workspaceLocation.toString());
    result.put(ProtocolConstants.KEY_CHILDREN_LOCATION,workspaceLocation.toString());
    result.put(ProtocolConstants.KEY_PROJECTS,projects);
    result.put(ProtocolConstants.KEY_DIRECTORY,""String_Node_Str"");
  }
 catch (  JSONException e) {
  }
  JSONArray children=new JSONArray();
  for (int i=0; i < projects.length(); i++) {
    try {
      WebProject project=WebProject.fromId(projects.getJSONObject(i).getString(ProtocolConstants.KEY_ID));
      JSONObject child=new JSONObject();
      child.put(ProtocolConstants.KEY_NAME,project.getName());
      child.put(ProtocolConstants.KEY_DIRECTORY,true);
      String contentLocation=computeProjectContentLocation(baseLocation,project);
      child.put(ProtocolConstants.KEY_LOCATION,contentLocation);
      child.put(ProtocolConstants.KEY_CHILDREN_LOCATION,contentLocation + ""String_Node_Str"");
      child.put(ProtocolConstants.KEY_ID,project.getId());
      children.put(child);
    }
 catch (    JSONException e) {
    }
  }
  try {
    result.put(ProtocolConstants.KEY_CHILDREN,children);
  }
 catch (  JSONException e) {
  }
  return result;
}","/** 
 * Returns a JSON representation of the workspace, conforming to EclipseWeb workspace API protocol.
 * @param workspace The workspace to store
 * @param baseLocation The base location for the workspace servlet
 */
public static JSONObject toJSON(WebWorkspace workspace,URI baseLocation){
  JSONObject result=WebElementResourceHandler.toJSON(workspace);
  JSONArray projects=workspace.getProjectsJSON();
  URI workspaceLocation=URIUtil.append(baseLocation,workspace.getId());
  URI projectBaseLocation=URIUtil.append(workspaceLocation,""String_Node_Str"");
  if (projects == null)   projects=new JSONArray();
  for (int i=0; i < projects.length(); i++) {
    try {
      JSONObject project=(JSONObject)projects.get(i);
      project.put(ProtocolConstants.KEY_LOCATION,URIUtil.append(projectBaseLocation,project.getString(ProtocolConstants.KEY_ID)));
    }
 catch (    JSONException e) {
    }
  }
  try {
    result.put(ProtocolConstants.KEY_LOCATION,workspaceLocation);
    result.put(ProtocolConstants.KEY_CHILDREN_LOCATION,workspaceLocation);
    result.put(ProtocolConstants.KEY_PROJECTS,projects);
    result.put(ProtocolConstants.KEY_DIRECTORY,""String_Node_Str"");
  }
 catch (  JSONException e) {
  }
  JSONArray children=new JSONArray();
  for (int i=0; i < projects.length(); i++) {
    try {
      WebProject project=WebProject.fromId(projects.getJSONObject(i).getString(ProtocolConstants.KEY_ID));
      JSONObject child=new JSONObject();
      child.put(ProtocolConstants.KEY_NAME,project.getName());
      child.put(ProtocolConstants.KEY_DIRECTORY,true);
      URI contentLocation=computeProjectContentLocation(baseLocation,project);
      child.put(ProtocolConstants.KEY_LOCATION,contentLocation);
      try {
        child.put(ProtocolConstants.KEY_CHILDREN_LOCATION,new URI(contentLocation.getScheme(),contentLocation.getUserInfo(),contentLocation.getHost(),contentLocation.getPort(),contentLocation.getPath(),""String_Node_Str"",contentLocation.getFragment()));
      }
 catch (      URISyntaxException e) {
        throw new RuntimeException(e);
      }
      child.put(ProtocolConstants.KEY_ID,project.getId());
      children.put(child);
    }
 catch (    JSONException e) {
    }
  }
  try {
    result.put(ProtocolConstants.KEY_CHILDREN,children);
  }
 catch (  JSONException e) {
  }
  return result;
}",0.9240190519392152
180537,"private void transferWithExceptions() throws ServletException, IOException, URISyntaxException, JSONException {
  String host, remotePath, user, passphrase;
  int port;
  try {
    JSONObject requestInfo=OrionServlet.readJSONRequest(request);
    host=requestInfo.getString(ProtocolConstants.KEY_HOST);
    remotePath=requestInfo.getString(ProtocolConstants.KEY_PATH);
    port=requestInfo.optInt(ProtocolConstants.KEY_PORT,22);
    user=requestInfo.getString(ProtocolConstants.KEY_USER_NAME);
    passphrase=requestInfo.getString(ProtocolConstants.KEY_PASSPHRASE);
  }
 catch (  Exception e) {
    handleException(""String_Node_Str"",e,HttpServletResponse.SC_BAD_REQUEST);
    return;
  }
  File localFile;
  try {
    localFile=localRoot.toLocalFile(EFS.NONE,null);
  }
 catch (  CoreException e) {
    handleException(NLS.bind(""String_Node_Str"",localRoot.toString()),e,HttpServletResponse.SC_NOT_IMPLEMENTED);
    return;
  }
  SFTPTransferJob job;
  if (TransferServlet.PREFIX_IMPORT.equals(new Path(request.getPathInfo()).segment(0))) {
    job=new SFTPImportJob(localFile,host,port,new Path(remotePath),user,passphrase,options);
  }
 else {
    job=new SFTPExportJob(localFile,host,port,new Path(remotePath),user,passphrase,options);
  }
  job.schedule();
  TaskInfo task=job.getTask();
  JSONObject result=task.toJSON();
  URI requestLocation=ServletResourceHandler.getURI(request);
  URI taskLocation=new URI(requestLocation.getScheme(),requestLocation.getAuthority(),""String_Node_Str"" + task.getTaskId(),null,null);
  result.put(ProtocolConstants.KEY_LOCATION,taskLocation.toString());
  response.setHeader(ProtocolConstants.HEADER_LOCATION,taskLocation.toString());
  OrionServlet.writeJSONResponse(request,response,result);
  response.setStatus(HttpServletResponse.SC_CREATED);
}","private void transferWithExceptions() throws ServletException, IOException, URISyntaxException, JSONException {
  String host, remotePath, user, passphrase;
  int port;
  try {
    JSONObject requestInfo=OrionServlet.readJSONRequest(request);
    host=requestInfo.getString(ProtocolConstants.KEY_HOST);
    remotePath=requestInfo.getString(ProtocolConstants.KEY_PATH);
    port=requestInfo.optInt(ProtocolConstants.KEY_PORT,22);
    user=requestInfo.getString(ProtocolConstants.KEY_USER_NAME);
    passphrase=requestInfo.getString(ProtocolConstants.KEY_PASSPHRASE);
  }
 catch (  Exception e) {
    handleException(""String_Node_Str"",e,HttpServletResponse.SC_BAD_REQUEST);
    return;
  }
  File localFile;
  try {
    localFile=localRoot.toLocalFile(EFS.NONE,null);
  }
 catch (  CoreException e) {
    handleException(NLS.bind(""String_Node_Str"",localRoot.toString()),e,HttpServletResponse.SC_NOT_IMPLEMENTED);
    return;
  }
  SFTPTransferJob job;
  if (TransferServlet.PREFIX_IMPORT.equals(new Path(request.getPathInfo()).segment(0))) {
    job=new SFTPImportJob(localFile,host,port,new Path(remotePath),user,passphrase,options);
  }
 else {
    job=new SFTPExportJob(localFile,host,port,new Path(remotePath),user,passphrase,options);
  }
  job.schedule();
  TaskInfo task=job.getTask();
  JSONObject result=task.toJSON();
  URI requestLocation=ServletResourceHandler.getURI(request);
  URI taskLocation=new URI(requestLocation.getScheme(),requestLocation.getAuthority(),""String_Node_Str"" + task.getTaskId(),null,null);
  result.put(ProtocolConstants.KEY_LOCATION,taskLocation);
  response.setHeader(ProtocolConstants.HEADER_LOCATION,taskLocation.toString());
  OrionServlet.writeJSONResponse(request,response,result);
  response.setStatus(HttpServletResponse.SC_CREATED);
}",0.9969144460028052
180538,"private void addTransferLinks(URI resource,JSONObject representation) throws URISyntaxException, JSONException {
  URI location=new URI(representation.getString(ProtocolConstants.KEY_LOCATION));
  IPath targetPath=new Path(location.getPath()).removeFirstSegments(1).removeTrailingSeparator();
  IPath path=new Path(""String_Node_Str"").append(targetPath);
  URI link=new URI(resource.getScheme(),resource.getAuthority(),path.toString(),null,null);
  representation.put(ProtocolConstants.KEY_IMPORT_LOCATION,link.toString());
  path=new Path(""String_Node_Str"").append(targetPath).addFileExtension(""String_Node_Str"");
  link=new URI(resource.getScheme(),resource.getAuthority(),path.toString(),null,null);
  representation.put(ProtocolConstants.KEY_EXPORT_LOCATION,link.toString());
}","private void addTransferLinks(URI resource,JSONObject representation) throws URISyntaxException, JSONException {
  URI location=new URI(representation.getString(ProtocolConstants.KEY_LOCATION));
  IPath targetPath=new Path(location.getPath()).removeFirstSegments(1).removeTrailingSeparator();
  IPath path=new Path(""String_Node_Str"").append(targetPath);
  URI link=new URI(resource.getScheme(),resource.getAuthority(),path.toString(),null,null);
  representation.put(ProtocolConstants.KEY_IMPORT_LOCATION,link);
  path=new Path(""String_Node_Str"").append(targetPath).addFileExtension(""String_Node_Str"");
  link=new URI(resource.getScheme(),resource.getAuthority(),path.toString(),null,null);
  representation.put(ProtocolConstants.KEY_EXPORT_LOCATION,link);
}",0.9856957087126138
180539,"public static void writeJSONResponse(HttpServletRequest req,HttpServletResponse resp,Object result) throws IOException {
  Assert.isLegal(result instanceof JSONObject || result instanceof JSONArray);
  resp.setStatus(HttpServletResponse.SC_OK);
  resp.setHeader(""String_Node_Str"",""String_Node_Str"");
  if (result instanceof JSONObject)   decorateResponse(req,(JSONObject)result);
  resp.setContentType(ProtocolConstants.CONTENT_TYPE_JSON);
  String response=prettyPrint(result);
  resp.getWriter().print(response);
  LoggerFactory.getLogger(OrionServlet.class).debug(response);
}","public static void writeJSONResponse(HttpServletRequest req,HttpServletResponse resp,Object result) throws IOException {
  Assert.isLegal(result instanceof JSONObject || result instanceof JSONArray);
  resp.setStatus(HttpServletResponse.SC_OK);
  resp.setHeader(""String_Node_Str"",""String_Node_Str"");
  if (result instanceof JSONObject) {
    decorateResponse(req,(JSONObject)result);
    removeOwnProtocolHostPort((JSONObject)result,req.getScheme(),req.getServerName(),req.getServerPort());
  }
  resp.setContentType(ProtocolConstants.CONTENT_TYPE_JSON);
  String response=prettyPrint(result);
  resp.getWriter().print(response);
  LoggerFactory.getLogger(OrionServlet.class).debug(response);
}",0.9096622152395916
180540,"@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String pathInfo=req.getPathInfo();
  IPath path=pathInfo == null ? Path.EMPTY : new Path(pathInfo);
  if (path.segmentCount() != 2 || !""String_Node_Str"".equals(path.segment(0))) {
    handleException(resp,""String_Node_Str"" + path,null,HttpServletResponse.SC_BAD_REQUEST);
    return;
  }
  ITaskService taskService=taskTracker.getService();
  if (taskService == null) {
    handleException(resp,""String_Node_Str"",null);
    return;
  }
  String taskId=path.segment(1);
  TaskInfo task=taskService.getTask(taskId);
  if (task == null) {
    handleException(resp,""String_Node_Str"" + taskId,null,HttpServletResponse.SC_NOT_FOUND);
    return;
  }
  JSONObject result=task.toJSON();
  try {
    if (result.optString(ProtocolConstants.KEY_LOCATION,""String_Node_Str"").isEmpty())     result.put(ProtocolConstants.KEY_LOCATION,getURI(req).toString());
  }
 catch (  JSONException e) {
  }
  writeJSONResponse(req,resp,result);
}","@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String pathInfo=req.getPathInfo();
  IPath path=pathInfo == null ? Path.EMPTY : new Path(pathInfo);
  if (path.segmentCount() != 2 || !""String_Node_Str"".equals(path.segment(0))) {
    handleException(resp,""String_Node_Str"" + path,null,HttpServletResponse.SC_BAD_REQUEST);
    return;
  }
  ITaskService taskService=taskTracker.getService();
  if (taskService == null) {
    handleException(resp,""String_Node_Str"",null);
    return;
  }
  String taskId=path.segment(1);
  TaskInfo task=taskService.getTask(taskId);
  if (task == null) {
    handleException(resp,""String_Node_Str"" + taskId,null,HttpServletResponse.SC_NOT_FOUND);
    return;
  }
  JSONObject result=task.toJSON();
  try {
    if (result.optString(ProtocolConstants.KEY_LOCATION,""String_Node_Str"").equals(""String_Node_Str""))     result.put(ProtocolConstants.KEY_LOCATION,getURI(req).toString());
  }
 catch (  JSONException e) {
  }
  writeJSONResponse(req,resp,result);
}",0.984747378455672
180541,"private void addEditHeaders(HttpServletResponse resp,IHostedSite site,IPath path){
  resp.addHeader(""String_Node_Str"",site.getEditServerUrl() + ""String_Node_Str"");
  resp.addHeader(""String_Node_Str"",path.toString());
}","private void addEditHeaders(HttpServletResponse resp,IHostedSite site,IPath path){
  resp.addHeader(""String_Node_Str"",site.getEditServerUrl() + ""String_Node_Str"");
  resp.addHeader(""String_Node_Str"",FILE_SERVLET_ALIAS + path.toString());
}",0.9540481400437636
180542,"private void serveOrionFile(HttpServletRequest req,HttpServletResponse resp,IHostedSite site,IPath path) throws ServletException {
  String userName=site.getUserName();
  String workspaceId=site.getWorkspaceId();
  String workspaceUri=WORKSPACE_SERVLET_ALIAS + workspaceId;
  boolean allow=false;
  try {
    if (AuthorizationService.checkRights(userName,workspaceUri,""String_Node_Str"")) {
      allow=true;
    }
  }
 catch (  JSONException e) {
    throw new ServletException(e);
  }
  if (allow) {
    String pathInfo=path.toString();
    IPath filePath=pathInfo == null ? Path.ROOT : new Path(pathInfo);
    IFileStore file=tempGetFileStore(filePath,userName);
    if (file == null) {
      handleException(resp,new ServerStatus(IStatus.ERROR,404,NLS.bind(""String_Node_Str"",filePath),null));
    }
    if (fileSerializer.handleRequest(req,resp,file)) {
    }
    if (file != null) {
      addEditHeaders(resp,site,path);
    }
  }
 else {
    String msg=NLS.bind(""String_Node_Str"",workspaceUri);
    handleException(resp,new ServerStatus(IStatus.ERROR,HttpServletResponse.SC_FORBIDDEN,msg,null));
  }
}","private void serveOrionFile(HttpServletRequest req,HttpServletResponse resp,IHostedSite site,IPath path) throws ServletException {
  String userName=site.getUserName();
  String workspaceId=site.getWorkspaceId();
  String workspaceUri=WORKSPACE_SERVLET_ALIAS + ""String_Node_Str"" + workspaceId;
  boolean allow=false;
  try {
    if (AuthorizationService.checkRights(userName,workspaceUri,""String_Node_Str"")) {
      allow=true;
    }
  }
 catch (  JSONException e) {
    throw new ServletException(e);
  }
  if (allow) {
    String pathInfo=path.toString();
    IPath filePath=pathInfo == null ? Path.ROOT : new Path(pathInfo);
    IFileStore file=tempGetFileStore(filePath,userName);
    if (file == null) {
      handleException(resp,new ServerStatus(IStatus.ERROR,404,NLS.bind(""String_Node_Str"",filePath),null));
    }
    if (fileSerializer.handleRequest(req,resp,file)) {
    }
    if (file != null) {
      addEditHeaders(resp,site,path);
    }
  }
 else {
    String msg=NLS.bind(""String_Node_Str"",workspaceUri);
    handleException(resp,new ServerStatus(IStatus.ERROR,HttpServletResponse.SC_FORBIDDEN,msg,null));
  }
}",0.9910394265232976
180543,"@Test public void testCloneAndLink() throws IOException, SAXException, JSONException, URISyntaxException {
  URIish uri=new URIish(gitDir.toURL());
  String name=null;
  WebRequest request=getPostGitCloneRequest(uri,name);
  WebResponse response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_CREATED,response.getResponseCode());
  String location=response.getHeaderField(ProtocolConstants.HEADER_LOCATION);
  assertNotNull(location);
  JSONObject clone=new JSONObject(response.getText());
  String contentLocation=clone.getString(ProtocolConstants.KEY_CONTENT_LOCATION);
  assertNotNull(contentLocation);
  URI workspaceLocation=createWorkspace(getMethodName());
  ServletTestingSupport.allowedPrefixes=contentLocation;
  String projectName=getMethodName();
  JSONObject body=new JSONObject();
  body.put(ProtocolConstants.KEY_CONTENT_LOCATION,contentLocation);
  InputStream in=new StringBufferInputStream(body.toString());
  request=new PostMethodWebRequest(workspaceLocation.toString(),in,""String_Node_Str"");
  if (projectName != null)   request.setHeaderField(ProtocolConstants.HEADER_SLUG,projectName);
  request.setHeaderField(ProtocolConstants.HEADER_ORION_VERSION,""String_Node_Str"");
  setAuthentication(request);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_CREATED,response.getResponseCode());
  JSONObject newProject=new JSONObject(response.getText());
  String projectContentLocation=newProject.getString(ProtocolConstants.KEY_CONTENT_LOCATION);
  assertNotNull(projectContentLocation);
  request=getGetFilesRequest(projectContentLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  JSONObject project=new JSONObject(response.getText());
  String childrenLocation=project.getString(ProtocolConstants.KEY_CHILDREN_LOCATION);
  assertNotNull(childrenLocation);
  request=getGetFilesRequest(childrenLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  List<JSONObject> children=getDirectoryChildren(new JSONObject(response.getText()));
  String[] expectedChildren=new String[]{Constants.DOT_GIT,""String_Node_Str"",""String_Node_Str""};
  assertEquals(""String_Node_Str"",expectedChildren.length,children.size());
  assertEquals(expectedChildren[0],children.get(0).getString(ProtocolConstants.KEY_NAME));
  assertEquals(expectedChildren[1],children.get(1).getString(ProtocolConstants.KEY_NAME));
  assertEquals(expectedChildren[2],children.get(2).getString(ProtocolConstants.KEY_NAME));
}","@Test public void testCloneAndLink() throws IOException, SAXException, JSONException, URISyntaxException {
  URIish uri=new URIish(gitDir.toURL());
  String name=null;
  WebRequest request=getPostGitCloneRequest(uri,name);
  WebResponse response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_CREATED,response.getResponseCode());
  String location=response.getHeaderField(ProtocolConstants.HEADER_LOCATION);
  assertNotNull(location);
  JSONObject clone=new JSONObject(response.getText());
  String contentLocation=clone.getString(ProtocolConstants.KEY_CONTENT_LOCATION);
  assertNotNull(contentLocation);
  URI workspaceLocation=createWorkspace(getMethodName());
  ServletTestingSupport.allowedPrefixes=contentLocation;
  String projectName=getMethodName();
  JSONObject body=new JSONObject();
  body.put(ProtocolConstants.KEY_CONTENT_LOCATION,contentLocation);
  InputStream in=new StringBufferInputStream(body.toString());
  request=new PostMethodWebRequest(workspaceLocation.toString(),in,""String_Node_Str"");
  if (projectName != null)   request.setHeaderField(ProtocolConstants.HEADER_SLUG,projectName);
  request.setHeaderField(ProtocolConstants.HEADER_ORION_VERSION,""String_Node_Str"");
  setAuthentication(request);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_CREATED,response.getResponseCode());
  JSONObject newProject=new JSONObject(response.getText());
  String projectContentLocation=newProject.getString(ProtocolConstants.KEY_CONTENT_LOCATION);
  assertNotNull(projectContentLocation);
  request=getGetFilesRequest(projectContentLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  JSONObject project=new JSONObject(response.getText());
  String childrenLocation=project.getString(ProtocolConstants.KEY_CHILDREN_LOCATION);
  assertNotNull(childrenLocation);
  request=getGetFilesRequest(childrenLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  List<JSONObject> children=getDirectoryChildren(new JSONObject(response.getText()));
  String[] expectedChildren=new String[]{Constants.DOT_GIT,""String_Node_Str"",""String_Node_Str""};
  assertEquals(""String_Node_Str"",expectedChildren.length,children.size());
  assertNotNull(getChildByName(children,expectedChildren[0]));
  assertNotNull(getChildByName(children,expectedChildren[1]));
  assertNotNull(getChildByName(children,expectedChildren[2]));
}",0.9379604497867392
180544,"@Test public void testGitUrisInContentLocation() throws Exception {
  URI workspaceLocation=createWorkspace(getMethodName());
  String projectName=getMethodName();
  WebResponse response=createProjectWithContentLocation(workspaceLocation,projectName,gitDir.toString());
  assertEquals(HttpURLConnection.HTTP_CREATED,response.getResponseCode());
  JSONObject newProject=new JSONObject(response.getText());
  assertEquals(projectName,newProject.getString(ProtocolConstants.KEY_NAME));
  String projectId=newProject.optString(ProtocolConstants.KEY_ID,null);
  assertNotNull(projectId);
  String contentLocation=newProject.optString(ProtocolConstants.KEY_CONTENT_LOCATION,null);
  assertNotNull(contentLocation);
  WebRequest request=getGetFilesRequest(contentLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  JSONObject project=new JSONObject(response.getText());
  JSONObject gitSection=project.optJSONObject(GitConstants.KEY_GIT);
  assertNotNull(gitSection);
  assertNotNull(gitSection.optString(GitConstants.KEY_STATUS,null));
  assertNotNull(gitSection.optString(GitConstants.KEY_DIFF,null));
  assertNotNull(gitSection.optString(GitConstants.KEY_INDEX,null));
  String childrenLocation=project.getString(ProtocolConstants.KEY_CHILDREN_LOCATION);
  assertNotNull(childrenLocation);
  request=getGetFilesRequest(childrenLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  List<JSONObject> children=getDirectoryChildren(new JSONObject(response.getText()));
  String[] expectedChildren=new String[]{Constants.DOT_GIT,""String_Node_Str"",""String_Node_Str""};
  assertEquals(""String_Node_Str"",expectedChildren.length,children.size());
  for (  JSONObject child : children) {
    gitSection=child.optJSONObject(GitConstants.KEY_GIT);
    assertNotNull(gitSection);
    assertNotNull(gitSection.optString(GitConstants.KEY_STATUS,null));
    assertNotNull(gitSection.optString(GitConstants.KEY_DIFF,null));
    assertNotNull(gitSection.optString(GitConstants.KEY_INDEX,null));
  }
  childrenLocation=children.get(1).getString(ProtocolConstants.KEY_CHILDREN_LOCATION);
  request=getGetFilesRequest(childrenLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  children=getDirectoryChildren(new JSONObject(response.getText()));
  expectedChildren=new String[]{""String_Node_Str""};
  assertEquals(""String_Node_Str"",expectedChildren.length,children.size());
  for (  JSONObject child : children) {
    gitSection=child.optJSONObject(GitConstants.KEY_GIT);
    assertNotNull(gitSection);
    assertNotNull(gitSection.optString(GitConstants.KEY_STATUS,null));
    assertNotNull(gitSection.optString(GitConstants.KEY_DIFF,null));
    assertNotNull(gitSection.optString(GitConstants.KEY_INDEX,null));
  }
}","@Test public void testGitUrisInContentLocation() throws Exception {
  URI workspaceLocation=createWorkspace(getMethodName());
  String projectName=getMethodName();
  WebResponse response=createProjectWithContentLocation(workspaceLocation,projectName,gitDir.toString());
  assertEquals(HttpURLConnection.HTTP_CREATED,response.getResponseCode());
  JSONObject newProject=new JSONObject(response.getText());
  assertEquals(projectName,newProject.getString(ProtocolConstants.KEY_NAME));
  String projectId=newProject.optString(ProtocolConstants.KEY_ID,null);
  assertNotNull(projectId);
  String contentLocation=newProject.optString(ProtocolConstants.KEY_CONTENT_LOCATION,null);
  assertNotNull(contentLocation);
  WebRequest request=getGetFilesRequest(contentLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  JSONObject project=new JSONObject(response.getText());
  JSONObject gitSection=project.optJSONObject(GitConstants.KEY_GIT);
  assertNotNull(gitSection);
  assertNotNull(gitSection.optString(GitConstants.KEY_STATUS,null));
  assertNotNull(gitSection.optString(GitConstants.KEY_DIFF,null));
  assertNotNull(gitSection.optString(GitConstants.KEY_INDEX,null));
  String childrenLocation=project.getString(ProtocolConstants.KEY_CHILDREN_LOCATION);
  assertNotNull(childrenLocation);
  request=getGetFilesRequest(childrenLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  List<JSONObject> children=getDirectoryChildren(new JSONObject(response.getText()));
  String[] expectedChildren=new String[]{Constants.DOT_GIT,""String_Node_Str"",""String_Node_Str""};
  assertEquals(""String_Node_Str"",expectedChildren.length,children.size());
  for (  JSONObject child : children) {
    gitSection=child.optJSONObject(GitConstants.KEY_GIT);
    assertNotNull(gitSection);
    assertNotNull(gitSection.optString(GitConstants.KEY_STATUS,null));
    assertNotNull(gitSection.optString(GitConstants.KEY_DIFF,null));
    assertNotNull(gitSection.optString(GitConstants.KEY_INDEX,null));
  }
  childrenLocation=getChildByName(children,""String_Node_Str"").getString(ProtocolConstants.KEY_CHILDREN_LOCATION);
  request=getGetFilesRequest(childrenLocation);
  response=webConversation.getResponse(request);
  assertEquals(HttpURLConnection.HTTP_OK,response.getResponseCode());
  children=getDirectoryChildren(new JSONObject(response.getText()));
  expectedChildren=new String[]{""String_Node_Str""};
  assertEquals(""String_Node_Str"",expectedChildren.length,children.size());
  for (  JSONObject child : children) {
    gitSection=child.optJSONObject(GitConstants.KEY_GIT);
    assertNotNull(gitSection);
    assertNotNull(gitSection.optString(GitConstants.KEY_STATUS,null));
    assertNotNull(gitSection.optString(GitConstants.KEY_DIFF,null));
    assertNotNull(gitSection.optString(GitConstants.KEY_INDEX,null));
  }
}",0.9920108788033316
180545,"@Override public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  if (siteHostingService != null) {
    HttpServletRequest httpReq=(HttpServletRequest)req;
    String host=httpReq.getHeader(""String_Node_Str"");
    String requestUri=httpReq.getRequestURI();
    if (siteHostingService.isHosted(host) && !requestUri.startsWith(HOSTED_SITE_ALIAS)) {
      RequestDispatcher rd=httpReq.getRequestDispatcher(HOSTED_SITE_ALIAS + ""String_Node_Str"" + host+ requestUri);
      rd.forward(req,resp);
      return;
    }
  }
  chain.doFilter(req,resp);
}","@Override public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  if (siteHostingService != null) {
    HttpServletRequest httpReq=(HttpServletRequest)req;
    String host=getHostWithoutPort(httpReq);
    if (host != null) {
      String requestUri=httpReq.getRequestURI();
      if (siteHostingService.isHosted(host) && !requestUri.startsWith(HOSTED_SITE_ALIAS)) {
        RequestDispatcher rd=httpReq.getRequestDispatcher(HOSTED_SITE_ALIAS + ""String_Node_Str"" + host+ requestUri);
        rd.forward(req,resp);
        return;
      }
    }
  }
  chain.doFilter(req,resp);
}",0.8630904723779024
180546,"@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  traceRequest(req);
  String pathInfo=req.getPathInfo();
  IPath path=new Path(pathInfo == null ? ""String_Node_Str"" : pathInfo);
  if (path.segmentCount() > 0) {
    String hostedHost=path.segment(0);
    URL url=this.getMappedURL(path.removeFirstSegments(1));
    serve(req,resp,url);
  }
 else {
    super.doGet(req,resp);
  }
}","@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  traceRequest(req);
  String pathInfo=req.getPathInfo();
  IPath path=new Path(pathInfo == null ? ""String_Node_Str"" : pathInfo);
  if (path.segmentCount() > 0) {
    String hostedHost=path.segment(0);
    HostedSite site=HostingActivator.getDefault().getHostingService().get(hostedHost);
    if (site != null) {
      URL url=getMappedURL(site,path.removeFirstSegments(1).makeAbsolute());
      serve(req,resp,url);
    }
 else {
    }
  }
 else {
    super.doGet(req,resp);
  }
}",0.8419047619047619
180547,"/** 
 * @param pathInfo
 * @return The pathInfo
 * @throws MalformedURLException
 */
private URL getMappedURL(IPath pathInfo) throws MalformedURLException {
  Map<String,String> map=getMap();
  IPath originalPath=pathInfo;
  IPath path=originalPath;
  String base=null;
  String rest=null;
  int count=path.segmentCount();
  for (int i=0; i <= count; i++) {
    base=map.get(path.toString());
    if (base != null) {
      rest=originalPath.removeFirstSegments(count - i).toString();
      break;
    }
    path=path.removeLastSegments(1);
  }
  if (base != null) {
    String result=base + (rest.length() == 0 || rest.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + rest;
    return new URL(result);
  }
  return null;
}","/** 
 * Returns a URL  rewriting pathInfo using the most-specific
 * @param site
 * @param pathInfo
 * @return
 * @throws MalformedURLException If the target mapping is not valid URL
 */
private URL getMappedURL(HostedSite site,IPath pathInfo) throws MalformedURLException {
  Map<String,String> map=site.getMappings();
  IPath originalPath=pathInfo;
  IPath path=originalPath;
  String base=null;
  String rest=null;
  int count=path.segmentCount();
  for (int i=0; i <= count; i++) {
    base=map.get(path.toString());
    if (base != null) {
      rest=originalPath.removeFirstSegments(count - i).toString();
      break;
    }
    path=path.removeLastSegments(1);
  }
  if (base != null) {
    String result=base + (rest.length() == 0 || rest.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + rest;
    return new URL(result);
  }
  return null;
}",0.9049382716049382
180548,"/** 
 * Adds status field to a representation of a site configuration.
 */
private void addStatus(JSONObject siteConfigJson) throws JSONException {
  String id=siteConfigJson.getString(ProtocolConstants.KEY_ID);
  SiteConfiguration siteConfiguration=SiteConfiguration.fromId(id);
  boolean isHosted=HostingActivator.getDefault().getHostingService().isRunning(siteConfiguration);
  if (isHosted) {
    siteConfigJson.put(SiteConfigurationConstants.KEY_STATE,""String_Node_Str"");
  }
 else {
    siteConfigJson.put(SiteConfigurationConstants.KEY_STATE,""String_Node_Str"");
  }
}","/** 
 * Adds status field to a representation of a site configuration.
 */
private void addStatus(JSONObject siteConfigJson) throws JSONException {
  String id=siteConfigJson.getString(ProtocolConstants.KEY_ID);
  SiteConfiguration siteConfiguration=SiteConfiguration.fromId(id);
  SiteHostingService hostingService=HostingActivator.getDefault().getHostingService();
  HostedSite site=hostingService.get(siteConfiguration);
  JSONObject status=new JSONObject();
  if (site != null) {
    status.put(SiteConfigurationConstants.KEY_STATUS,""String_Node_Str"");
    status.put(""String_Node_Str"",site.getHost());
  }
 else {
    status.put(SiteConfigurationConstants.KEY_STATUS,""String_Node_Str"");
  }
  siteConfigJson.put(SiteConfigurationConstants.KEY_STATUS,status);
}",0.7393577296489918
180549,"public void stop(SiteConfiguration siteConfig,WebUser user){
  Key key=createKey(siteConfig);
synchronized (table) {
    HostedSite site=table.get(key);
    if (site == null) {
      throw new SiteHostingException(""String_Node_Str"");
    }
    table.remove(key);
    releaseHost(site.host);
  }
}","public void stop(SiteConfiguration siteConfig,WebUser user){
  Key key=createKey(siteConfig);
synchronized (table) {
    HostedSite site=table.get(key);
    if (site == null) {
      throw new SiteHostingException(""String_Node_Str"");
    }
    releaseHost(site.getHost());
    table.remove(key);
  }
}",0.8844221105527639
180550,"@Override public boolean isRunning(SiteConfiguration siteConfig){
synchronized (table) {
    return table.containsKey(createKey(siteConfig));
  }
}","@Override public boolean isRunning(SiteConfiguration siteConfig){
  return get(siteConfig) != null;
}",0.7338709677419355
180551,"private void releaseHost(String host){
  String lastByteStr=host.substring(host.lastIndexOf(""String_Node_Str""));
  int lastByte=Integer.parseInt(lastByteStr);
synchronized (hostLock) {
    allocated.clear(lastByte);
    hosts.remove(host);
  }
}","private void releaseHost(String host){
  String lastByteStr=host.substring(host.lastIndexOf(""String_Node_Str"") + 1);
  int lastByte=Integer.parseInt(lastByteStr);
synchronized (hostLock) {
    allocated.clear(lastByte);
    hosts.remove(host);
  }
}",0.9919028340080972
180552,"public boolean removeRole(String name){
  throw new UnsupportedOperationException();
}","public boolean removeRole(String name){
  return false;
}",0.6853146853146853
180553,"private User internalCreateOrUpdateUser(ISecurePreferences userPrefs,User user) throws StorageException, IOException {
  userPrefs.put(USER_NAME,user.getName(),false);
  userPrefs.put(USER_PASSWORD,user.getPassword(),true);
  if (user.getRoles().size() > 0) {
    ISecurePreferences rolesPrefs=userPrefs.node(USER_ROLES);
    for (Iterator i=user.getRoles().iterator(); i.hasNext(); ) {
      Role role=(Role)i.next();
      rolesPrefs.node(role.getName());
    }
  }
  userPrefs.flush();
  return user;
}","private User internalCreateOrUpdateUser(ISecurePreferences userPrefs,User user) throws StorageException, IOException {
  userPrefs.put(USER_NAME,user.getName(),false);
  userPrefs.put(USER_PASSWORD,user.getPassword(),true);
  ISecurePreferences rolesPrefs=userPrefs.node(USER_ROLES);
  for (  String roleName : rolesPrefs.childrenNames()) {
    rolesPrefs.node(roleName).removeNode();
  }
  if (user.getRoles().size() > 0) {
    for (Iterator i=user.getRoles().iterator(); i.hasNext(); ) {
      Role role=(Role)i.next();
      rolesPrefs.node(role.getName());
    }
  }
  userPrefs.flush();
  return user;
}",0.839173405211141
180554,"public User getUser(String key,String value){
  if (key.equals(USER_LOGIN)) {
    ISecurePreferences prefs=SecurePreferencesFactory.getDefault().node(ORION_SERVER_NODE);
    if (!prefs.nodeExists(USERS + ""String_Node_Str"" + value)) {
      return null;
    }
    ISecurePreferences userPrefs=prefs.node(USERS + ""String_Node_Str"" + value);
    try {
      return new User(value,userPrefs.get(USER_NAME,""String_Node_Str""),userPrefs.get(USER_PASSWORD,""String_Node_Str""));
    }
 catch (    StorageException e) {
      LogHelper.log(new Status(IStatus.ERROR,Activator.PI_USER_SECURESTORAGE,IStatus.ERROR,""String_Node_Str"",e));
    }
  }
  return null;
}","public User getUser(String key,String value){
  if (key.equals(USER_LOGIN)) {
    ISecurePreferences prefs=SecurePreferencesFactory.getDefault().node(ORION_SERVER_NODE);
    if (!prefs.nodeExists(USERS + ""String_Node_Str"" + value)) {
      return null;
    }
    ISecurePreferences userPrefs=prefs.node(USERS + ""String_Node_Str"" + value);
    try {
      User user=new User(value,userPrefs.get(USER_NAME,""String_Node_Str""),userPrefs.get(USER_PASSWORD,""String_Node_Str""));
      ISecurePreferences roles=userPrefs.node(USER_ROLES);
      for (      String roleName : roles.childrenNames()) {
        user.addRole(getRole(roleName));
      }
      return user;
    }
 catch (    StorageException e) {
      LogHelper.log(new Status(IStatus.ERROR,Activator.PI_USER_SECURESTORAGE,IStatus.ERROR,""String_Node_Str"",e));
    }
  }
  return null;
}",0.8629032258064516
180555,"public Role getRole(String name){
  throw new UnsupportedOperationException();
}","public Role getRole(String name){
  return roles.get(name);
}",0.6382978723404256
180556,"public SecureStorageUserAdmin(){
}","public SecureStorageUserAdmin(){
  roles.put(""String_Node_Str"",new Role(""String_Node_Str"",Role.ROLE));
  roles.put(""String_Node_Str"",new Role(""String_Node_Str"",Role.ROLE));
  roles.put(""String_Node_Str"",new Role(""String_Node_Str"",Role.ROLE));
}",0.2446043165467626
180557,"public Collection<User> getUsers(){
  ISecurePreferences prefs=SecurePreferencesFactory.getDefault().node(ORION_SERVER_NODE);
  if (!prefs.nodeExists(USERS)) {
    return null;
  }
  ISecurePreferences usersPrefs=prefs.node(USERS);
  Collection<User> users=null;
  try {
    for (    String childName : usersPrefs.childrenNames()) {
      if (users == null)       users=new ArrayList<User>();
      ISecurePreferences userPrefs=usersPrefs.node(childName);
      users.add(new User(childName,userPrefs.get(USER_NAME,""String_Node_Str""),""String_Node_Str""));
    }
    return users;
  }
 catch (  StorageException e) {
    LogHelper.log(new Status(IStatus.ERROR,Activator.PI_USER_SECURESTORAGE,IStatus.ERROR,""String_Node_Str"",e));
  }
  return null;
}","public Collection<User> getUsers(){
  ISecurePreferences prefs=SecurePreferencesFactory.getDefault().node(ORION_SERVER_NODE);
  if (!prefs.nodeExists(USERS)) {
    return null;
  }
  ISecurePreferences usersPrefs=prefs.node(USERS);
  Collection<User> users=null;
  try {
    for (    String childName : usersPrefs.childrenNames()) {
      if (users == null)       users=new ArrayList<User>();
      ISecurePreferences userPrefs=usersPrefs.node(childName);
      User user=new User(childName,userPrefs.get(USER_NAME,""String_Node_Str""),""String_Node_Str"");
      ISecurePreferences roles=userPrefs.node(USER_ROLES);
      for (      String roleName : roles.childrenNames()) {
        user.addRole(getRole(roleName));
      }
      users.add(user);
    }
    return users;
  }
 catch (  StorageException e) {
    LogHelper.log(new Status(IStatus.ERROR,Activator.PI_USER_SECURESTORAGE,IStatus.ERROR,""String_Node_Str"",e));
  }
  return null;
}",0.8752969121140143
180558,"public Role[] getRoles(String filter) throws InvalidSyntaxException {
  throw new UnsupportedOperationException();
}","public Role[] getRoles(String filter) throws InvalidSyntaxException {
  return (Role[])roles.values().toArray();
}",0.7565217391304347
180559,"@Override protected void doPut(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String pathString=req.getPathInfo();
  if (pathString.startsWith(""String_Node_Str"")) {
    String login=pathString.substring(""String_Node_Str"".length());
    User user=(User)getUserAdmin().getUser(""String_Node_Str"",login);
    if (user == null) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
      return;
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      String roles=req.getParameter(""String_Node_Str"");
      if (roles != null) {
        StringTokenizer tokenizer=new StringTokenizer(roles,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String role=tokenizer.nextToken();
          user.addRole(getUserAdmin().getRole(role));
        }
      }
    }
  }
 else   if (pathString.startsWith(""String_Node_Str"")) {
    String login=pathString.substring(1);
    OrionUserAdmin userAdmin;
    try {
      userAdmin=req.getParameter(""String_Node_Str"") == null ? getUserAdmin() : getUserAdmin(req.getParameter(""String_Node_Str""));
    }
 catch (    UnsupportedUserStoreException e) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"" + req.getParameter(""String_Node_Str""));
      return;
    }
    User user=(User)userAdmin.getUser(""String_Node_Str"",login);
    if (user == null) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
      return;
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      user.setLogin(req.getParameter(""String_Node_Str""));
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      user.setName(req.getParameter(""String_Node_Str""));
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      user.setPassword(req.getParameter(""String_Node_Str""));
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      user.getRoles().clear();
      String roles=req.getParameter(""String_Node_Str"");
      if (roles != null) {
        StringTokenizer tokenizer=new StringTokenizer(roles,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String role=tokenizer.nextToken();
          user.addRole(userAdmin.getRole(role));
        }
      }
    }
    userAdmin.updateUser(login,user);
  }
}","@Override protected void doPut(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String pathString=req.getPathInfo();
  OrionUserAdmin userAdmin;
  try {
    userAdmin=req.getParameter(""String_Node_Str"") == null ? getUserAdmin() : getUserAdmin(req.getParameter(""String_Node_Str""));
  }
 catch (  UnsupportedUserStoreException e) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"" + req.getParameter(""String_Node_Str""));
    return;
  }
  String login=null;
  User user=null;
  if (pathString.startsWith(""String_Node_Str"")) {
    login=pathString.substring(""String_Node_Str"".length());
    user=(User)userAdmin.getUser(""String_Node_Str"",login);
    if (user == null) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
      return;
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      user.getRoles().clear();
      String roles=req.getParameter(""String_Node_Str"");
      if (roles != null) {
        StringTokenizer tokenizer=new StringTokenizer(roles,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String role=tokenizer.nextToken();
          user.addRole(userAdmin.getRole(role));
        }
      }
    }
  }
 else   if (pathString.startsWith(""String_Node_Str"")) {
    login=pathString.substring(1);
    user=(User)userAdmin.getUser(""String_Node_Str"",login);
    if (user == null) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
      return;
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      user.setLogin(req.getParameter(""String_Node_Str""));
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      user.setName(req.getParameter(""String_Node_Str""));
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      user.setPassword(req.getParameter(""String_Node_Str""));
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      user.getRoles().clear();
      String roles=req.getParameter(""String_Node_Str"");
      if (roles != null) {
        StringTokenizer tokenizer=new StringTokenizer(roles,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String role=tokenizer.nextToken();
          user.addRole(userAdmin.getRole(role));
        }
      }
    }
  }
  userAdmin.updateUser(login,user);
}",0.5980985306828004
180560,"@Override protected void doDelete(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String pathString=req.getPathInfo();
  if (pathString.startsWith(""String_Node_Str"")) {
    String login=pathString.substring(""String_Node_Str"".length());
    User user=(User)getUserAdmin().getUser(""String_Node_Str"",login);
    if (user == null) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      String roles=req.getParameter(""String_Node_Str"");
      if (roles != null) {
        StringTokenizer tokenizer=new StringTokenizer(roles,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String role=tokenizer.nextToken();
          user.removeRole(getUserAdmin().getRole(role));
        }
      }
    }
  }
 else   if (pathString.startsWith(""String_Node_Str"")) {
    String login=pathString.substring(1);
    OrionUserAdmin userAdmin;
    try {
      userAdmin=req.getParameter(""String_Node_Str"") == null ? getUserAdmin() : getUserAdmin(req.getParameter(""String_Node_Str""));
    }
 catch (    UnsupportedUserStoreException e) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"" + req.getParameter(""String_Node_Str""));
      return;
    }
    if (userAdmin.deleteUser((User)userAdmin.getUser(""String_Node_Str"",login)) == false) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
    }
  }
}","@Override protected void doDelete(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String pathString=req.getPathInfo();
  OrionUserAdmin userAdmin;
  try {
    userAdmin=req.getParameter(""String_Node_Str"") == null ? getUserAdmin() : getUserAdmin(req.getParameter(""String_Node_Str""));
  }
 catch (  UnsupportedUserStoreException e) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"" + req.getParameter(""String_Node_Str""));
    return;
  }
  if (pathString.startsWith(""String_Node_Str"")) {
    String login=pathString.substring(""String_Node_Str"".length());
    User user=(User)userAdmin.getUser(""String_Node_Str"",login);
    if (user == null) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
    }
    if (req.getParameter(""String_Node_Str"") != null) {
      String roles=req.getParameter(""String_Node_Str"");
      if (roles != null) {
        StringTokenizer tokenizer=new StringTokenizer(roles,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String role=tokenizer.nextToken();
          user.removeRole(userAdmin.getRole(role));
        }
      }
    }
    userAdmin.updateUser(login,user);
  }
 else   if (pathString.startsWith(""String_Node_Str"")) {
    String login=pathString.substring(1);
    if (userAdmin.deleteUser((User)userAdmin.getUser(""String_Node_Str"",login)) == false) {
      resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
    }
  }
}",0.4171159029649596
180561,"/** 
 * Generate a name for the file including the current chunk id, and based on the   {@link VideoCaptureActivity#BASE_PATH} and the base name{@link VideoCaptureActivity#BASE_NAME}
 * @return the path
 */
private String createFilePath(){
  return new String(BASE_PATH + BASE_NAME + ""String_Node_Str""+ currentChunkId+ ""String_Node_Str"");
}","/** 
 * Generate a name for the file including the current chunk id, and based on the   {@link VideoCaptureActivity#BASE_PATH} and the base name{@link VideoCaptureActivity#BASE_NAME}
 * @return the path
 */
private String createFilePath(){
  return new String(BASE_PATH + BASE_NAME + ""String_Node_Str""+ currentChunkId+++ ""String_Node_Str"");
}",0.997067448680352
180562,"/** 
 * Checks the if AST for presence of the specified property guard variables (At least 1 occurrence inside if statement list)
 * @param ast the method AST
 * @param ifAST the if AST
 */
private boolean checkGuardVar(DetailAST ifAST,String m){
  found=new boolean[guardVars.length];
  DetailAST ifSlist=ifAST.findFirstToken(TokenTypes.SLIST);
  treeTraversal(ifSlist,TokenTypes.EXPR);
  boolean foundAllGV=true;
  for (int i=0; i < found.length; i++) {
    if (!found[i]) {
      log(ifSlist.getLineNo(),""String_Node_Str"" + m + ""String_Node_Str""+ guardVars[i]);
      foundAllGV=false;
    }
  }
  return foundAllGV;
}","/** 
 * Checks the if AST for presence of the specified property guard variables (At least 1 occurrence inside if statement list)
 * @param ast the method AST
 * @param ifAST the if AST
 * @return true if all the guard variables have been found, false otherwise
 */
private boolean checkGuardVar(DetailAST ifAST,String m){
  found=new boolean[guardVars.length];
  DetailAST ifSlist=ifAST.findFirstToken(TokenTypes.SLIST);
  treeTraversal(ifSlist,TokenTypes.EXPR);
  boolean foundAllGV=true;
  for (int i=0; i < found.length; i++) {
    if (!found[i]) {
      log(ifSlist.getLineNo(),""String_Node_Str"" + m + ""String_Node_Str""+ guardVars[i]);
      foundAllGV=false;
    }
  }
  return foundAllGV;
}",0.9423368740515932
180563,"/** 
 * Checks the method AST for presence of an else statement.
 * @param ast the method AST to be checked
 * @param mName the method AST name
 */
private boolean checkElse(DetailAST ast){
  return ast.branchContains(TokenTypes.LITERAL_ELSE);
}","/** 
 * Checks the method AST for presence of an else statement.
 * @param ast the method AST to be checked
 * @return true if the branch does not contain an else statement, false otherwise
 */
private boolean checkElse(DetailAST ast){
  return !ast.branchContains(TokenTypes.LITERAL_ELSE);
}",0.8007448789571695
180564,"/** 
 * Checks the method for expressions present outside the if statement block.
 * @param ast the method AST
 */
private boolean checkOutsideIf(DetailAST ast){
  return ast.findFirstToken(TokenTypes.SLIST).getChildCount(TokenTypes.EXPR) > 0;
}","/** 
 * Checks the method for expressions present outside the if statement block.
 * @param ast the method AST
 * @return true if there are no expressions present outside the if statement, false otherwise
 */
private boolean checkOutsideIf(DetailAST ast){
  return ast.findFirstToken(TokenTypes.SLIST).getChildCount(TokenTypes.EXPR) == 0;
}",0.8341880341880342
180565,"/** 
 * This can be used to update the resource set's package registry with all needed EPackages.
 * @param resourceSet The resource set which registry has to be updated.
 * @generated
 */
@Override public void registerPackages(ResourceSet resourceSet){
  super.registerPackages(resourceSet);
}","/** 
 * This can be used to update the resource set's package registry with all needed EPackages.
 * @param resourceSet The resource set which registry has to be updated.
 * @generated
 */
@Override public void registerPackages(ResourceSet resourceSet){
  super.registerPackages(resourceSet);
  if (!isInWorkspace(org.macjariel.karel.karel.KarelPackage.class)) {
    resourceSet.getPackageRegistry().put(org.macjariel.karel.karel.KarelPackage.eINSTANCE.getNsURI(),org.macjariel.karel.karel.KarelPackage.eINSTANCE);
  }
}",0.7223587223587223
180566,"private LdapSecurityManager(){
  mGroupCache=new TimerCacheHashMap<String,Collection<String>>();
}","public LdapSecurityManager(){
  mGroupCache=new TimerCacheHashMap<String,Collection<String>>();
}",0.953846153846154
180567,"public void addNetworkEvent(Event event){
  event.setTime(event.getTime() + network.generateDelay());
  queue.add(event);
}","public void addNetworkEvent(Event event){
  long delayedTime=event.getTime() + network.generateDelay();
  event.setTime(delayedTime);
  queue.add(event);
}",0.8273381294964028
180568,"public static Map<String,Class<? extends Event>> createEvents(){
  Map<String,Class<? extends Event>> events=new HashMap<String,Class<? extends Event>>();
  events.put(ADD_JOB,AddJobEvent.class);
  events.put(CANCEL_JOB,CancelJobEvent.class);
  events.put(SET_GRID,SetGridEvent.class);
  events.put(BROKER_DOWN,BrokerDownEvent.class);
  events.put(BROKER_UP,BrokerUpEvent.class);
  events.put(BROKER_LOGGED,BrokerLoggedEvent.class);
  events.put(HERE_IS_EXECUTION_RESULT,HereIsExecutionResultEvent.class);
  events.put(HERE_IS_WORKER,HereIsWorkerEvent.class);
  events.put(PEER_AVAILABLE,PeerAvailableEvent.class);
  events.put(PEER_FAILED,PeerFailedEvent.class);
  events.put(SCHEDULE,ScheduleEvent.class);
  events.put(WORKER_FAILED,WorkerFailedEvent.class);
  events.put(WORKER_AVAILABLE,WorkerAvailableEvent.class);
  return events;
}","public static Map<String,Class<? extends Event>> createEvents(){
  Map<String,Class<? extends Event>> events=new HashMap<String,Class<? extends Event>>();
  events.put(ADD_JOB,AddJobEvent.class);
  events.put(CANCEL_JOB,CancelJobEvent.class);
  events.put(SET_GRID,SetGridEvent.class);
  events.put(BROKER_DOWN,BrokerDownEvent.class);
  events.put(BROKER_UP,BrokerUpEvent.class);
  events.put(BROKER_LOGGED,BrokerLoggedEvent.class);
  events.put(HERE_IS_EXECUTION_RESULT,HereIsExecutionResultEvent.class);
  events.put(HERE_IS_WORKER,HereIsWorkerEvent.class);
  events.put(PEER_AVAILABLE,PeerAvailableEvent.class);
  events.put(PEER_FAILED,PeerFailedEvent.class);
  events.put(SCHEDULE,ScheduleEvent.class);
  events.put(WORKER_FAILED,WorkerFailedEvent.class);
  events.put(WORKER_AVAILABLE,WorkerAvailableEvent.class);
  events.put(WORKER_PREEMPTED,WorkerPreemptedEvent.class);
  return events;
}",0.9659942363112392
180569,"@Override public void process(OurSim ourSim){
  Peer peer=ourSim.getGrid().getObject(peerId);
  peer.setWorkerState(workerId,WorkerState.IDLE);
  peer.addAllocation(new Allocation(workerId,peerId));
}","@Override public void process(OurSim ourSim){
  Peer peer=ourSim.getGrid().getObject(peerId);
  peer.addAllocation(new Allocation(workerId,peerId));
  WorkerDistributionHelper.redistributeIdleWorker(getTime(),peer,workerId,ourSim);
}",0.5542725173210161
180570,"@Override public void process(OurSim ourSim){
  ourSim.addNetworkEvent(ourSim.createEvent(BrokerEvents.HERE_IS_WORKER,getTime(),workerId,requestSpec));
}","@Override public void process(OurSim ourSim){
  Peer peer=ourSim.getGrid().getObject(peerId);
  PeerRequest request=peer.getRequest(requestSpec.getId());
  if (request == null || !request.getAllocatedWorkers().contains(workerId)) {
    return;
  }
  ourSim.addNetworkEvent(ourSim.createEvent(BrokerEvents.HERE_IS_WORKER,getTime(),workerId,requestSpec));
}",0.6023622047244095
180571,"public WorkerInUseEvent(RequestSpec requestSpec,String workerId){
  super(Event.DEF_PRIORITY);
  this.requestSpec=requestSpec;
  this.workerId=workerId;
}","public WorkerInUseEvent(RequestSpec requestSpec,String workerId,String peerId){
  super(Event.DEF_PRIORITY);
  this.requestSpec=requestSpec;
  this.workerId=workerId;
  this.peerId=peerId;
}",0.8953488372093024
180572,"public static void redistributeWorker(long time,Peer peer,String workerId,OurSim ourSim){
  Allocation workerAllocation=peer.getAllocation(workerId);
  if (workerAllocation == null) {
    return;
  }
  PeerRequest request=workerAllocation.getRequest();
  request.removeAllocatedWorker(workerId);
  peer.setWorkerState(workerId,WorkerState.IDLE);
  workerAllocation.setRequest(null);
  workerAllocation.setConsumer(null);
  workerAllocation.setLastAssign(time);
  if (workerAllocation.isWorkerLocal()) {
    redistributeLocalWorker(time,peer,workerId,ourSim);
  }
 else {
    redistributeRemoteWorker(time,peer,workerId,ourSim);
  }
  if (request != null) {
    request.removeAllocatedWorker(workerId);
    if (!request.isPaused() && request.getNeededWorkers() > 0) {
      Event requestWorkersEvent=ourSim.createEvent(PeerEvents.REQUEST_WORKERS,time + ourSim.getLongProperty(Configuration.PROP_REQUEST_REPETITION_INTERVAL),peer.getId(),request.getSpec(),true);
      ourSim.addEvent(requestWorkersEvent);
    }
  }
}","public static void redistributeWorker(long time,Peer peer,String workerId,OurSim ourSim){
  Allocation workerAllocation=peer.getAllocation(workerId);
  if (workerAllocation == null) {
    return;
  }
  PeerRequest request=workerAllocation.getRequest();
  if (request != null) {
    request.removeAllocatedWorker(workerId);
  }
  peer.setWorkerState(workerId,WorkerState.IDLE);
  workerAllocation.setRequest(null);
  workerAllocation.setConsumer(null);
  workerAllocation.setLastAssign(time);
  if (workerAllocation.isWorkerLocal()) {
    redistributeLocalWorker(time,peer,workerId,ourSim);
  }
 else {
    redistributeRemoteWorker(time,peer,workerId,ourSim);
  }
  if (request != null && !request.isPaused() && request.getNeededWorkers() > 0) {
    Event requestWorkersEvent=ourSim.createEvent(PeerEvents.REQUEST_WORKERS,time + ourSim.getLongProperty(Configuration.PROP_REQUEST_REPETITION_INTERVAL),peer.getId(),request.getSpec(),true);
    ourSim.addEvent(requestWorkersEvent);
  }
}",0.93
180573,"public static void cleanWorker(long time,Worker worker,boolean releaseRemotePeer,OurSim ourSim){
  String oldConsumer=worker.getConsumer();
  if (oldConsumer != null) {
    ourSim.addEvent(ourSim.createEvent(FailureDetectionEvents.RELEASE,time,worker.getId(),oldConsumer));
    worker.setConsumer(null);
  }
  WorkAccounting workAccounting=worker.getCurrentWorkAccounting();
  if (worker.getRemotePeer() != null && workAccounting != null) {
    workAccounting.setCPUTime(time - workAccounting.getInitCPUtime());
    worker.addWorkAccounting(workAccounting);
    worker.setCurrentWorkAccounting(null);
  }
  if (releaseRemotePeer && worker.getRemotePeer() != null) {
    ourSim.addEvent(ourSim.createEvent(FailureDetectionEvents.RELEASE,time,worker.getId(),worker.getRemotePeer()));
    worker.setRemotePeer(null);
  }
}","public static void cleanWorker(long time,Worker worker,boolean releaseRemotePeer,OurSim ourSim){
  String oldConsumer=worker.getConsumer();
  if (oldConsumer != null) {
    ourSim.addEvent(ourSim.createEvent(BrokerEvents.WORKER_PREEMPTED,time,oldConsumer,worker.getId()));
    ourSim.addEvent(ourSim.createEvent(FailureDetectionEvents.RELEASE,time,worker.getId(),oldConsumer));
    worker.setConsumer(null);
  }
  WorkAccounting workAccounting=worker.getCurrentWorkAccounting();
  if (worker.getRemotePeer() != null && workAccounting != null) {
    workAccounting.setCPUTime(time - workAccounting.getInitCPUtime());
    worker.addWorkAccounting(workAccounting);
    worker.setCurrentWorkAccounting(null);
  }
  if (releaseRemotePeer && worker.getRemotePeer() != null) {
    ourSim.addEvent(ourSim.createEvent(FailureDetectionEvents.RELEASE,time,worker.getId(),worker.getRemotePeer()));
    worker.setRemotePeer(null);
  }
}",0.9402985074626866
180574,"@Override public void process(OurSim ourSim){
  Worker worker=ourSim.getGrid().getObject(workerId);
  CleanWorkerHelper.cleanWorker(getTime(),worker,false,ourSim);
  worker.setConsumer(consumer);
  ourSim.addNetworkEvent(ourSim.createEvent(PeerEvents.WORKER_IN_USE,getTime(),requestSpec,workerId));
  if (worker.getRemotePeer() != null) {
    WorkAccounting accounting=new WorkAccounting(worker.getId(),worker.getRemotePeer());
    worker.setCurrentWorkAccounting(accounting);
  }
}","@Override public void process(OurSim ourSim){
  Worker worker=ourSim.getGrid().getObject(workerId);
  CleanWorkerHelper.cleanWorker(getTime(),worker,false,ourSim);
  worker.setConsumer(consumer);
  String peerId=worker.getPeer();
  ourSim.addNetworkEvent(ourSim.createEvent(PeerEvents.WORKER_IN_USE,getTime(),requestSpec,workerId,peerId));
  if (worker.getRemotePeer() != null) {
    WorkAccounting accounting=new WorkAccounting(worker.getId(),worker.getRemotePeer());
    worker.setCurrentWorkAccounting(accounting);
  }
}",0.9592039800995024
180575,"@Override public Grid createGrid(){
  JSONObject gridJson=null;
  try {
    String gridStr=IOUtils.toString(inputStream);
    gridJson=JSONUtils.asJSON(gridStr);
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(e);
  }
  Grid grid=new Grid();
  JSONObject dsJson=JSONUtils.getJSONObject(gridJson,""String_Node_Str"");
  DiscoveryService ds=new DiscoveryService();
  ds.setId(JSONUtils.getJSONString(dsJson,""String_Node_Str""));
  grid.addObject(ds);
  JSONArray peersArray=JSONUtils.getJSONArray(gridJson,""String_Node_Str"");
  for (int i=0; i < peersArray.length(); i++) {
    try {
      JSONObject peerJson=(JSONObject)peersArray.get(i);
      grid.addObject(createPeer(peerJson,grid));
    }
 catch (    JSONException e) {
      throw new IllegalArgumentException(e);
    }
  }
  JSONArray brokersArray=JSONUtils.getJSONArray(gridJson,""String_Node_Str"");
  for (int i=0; i < brokersArray.length(); i++) {
    try {
      JSONObject brokerJson=(JSONObject)brokersArray.get(i);
      grid.addObject(createBroker(brokerJson));
    }
 catch (    JSONException e) {
      throw new IllegalArgumentException(e);
    }
  }
  configureFailureDetectors(grid);
  return grid;
}","@Override public Grid createGrid(){
  JSONObject gridJson=null;
  try {
    String gridStr=IOUtils.toString(inputStream);
    gridJson=JSONUtils.asJSON(gridStr);
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(e);
  }
  Grid grid=new Grid();
  JSONObject dsJson=JSONUtils.getJSONObject(gridJson,""String_Node_Str"");
  DiscoveryService ds=new DiscoveryService();
  ds.setId(JSONUtils.getJSONString(dsJson,""String_Node_Str""));
  grid.addObject(ds);
  JSONArray peersArray=JSONUtils.getJSONArray(gridJson,""String_Node_Str"");
  for (int i=0; i < peersArray.length(); i++) {
    try {
      JSONObject peerJson=(JSONObject)peersArray.get(i);
      grid.addObject(createPeer(peerJson,grid));
    }
 catch (    JSONException e) {
      throw new IllegalArgumentException(e);
    }
  }
  JSONArray brokersArray=JSONUtils.getJSONArray(gridJson,""String_Node_Str"");
  for (int i=0; i < brokersArray.length(); i++) {
    try {
      JSONObject brokerJson=(JSONObject)brokersArray.get(i);
      grid.addObject(createBroker(brokerJson));
    }
 catch (    JSONException e) {
      throw new IllegalArgumentException(e);
    }
  }
  new FailureDetectorOptInjector().inject(grid,properties);
  return grid;
}",0.9603671255736336
180576,"public List<ReplicaAccounting> getReplicaAccountings(long requestId){
  return replicaAccountings.get(requestId);
}","public List<ReplicaAccounting> getReplicaAccountings(long requestId){
  return replicaAccountings.containsKey(requestId) ? new LinkedList<ReplicaAccounting>(replicaAccountings.get(requestId)) : new LinkedList<ReplicaAccounting>();
}",0.6455331412103746
180577,"public void updateStatusReceived(String monitored,Long time){
  getMonitor(monitored).setUp(true);
  getMonitor(monitored).setCreatingConnection(false);
  fd.messageReceived(monitored,time,MessageType.PING);
}","public void updateStatusReceived(String monitored,Long time){
  getMonitor(monitored).setUp(true);
  getMonitor(monitored).setCreatingConnection(false);
  if (fd != null) {
    fd.messageReceived(monitored,time,MessageType.PING);
  }
}",0.9414414414414416
180578,"public void isItAliveSent(String monitored,Long time){
  fd.messageSent(monitored,time,MessageType.PING);
}","public void isItAliveSent(String monitored,Long time){
  if (fd != null) {
    fd.messageSent(monitored,time,MessageType.PING);
  }
}",0.8916666666666667
180579,"public static void sendIsItAlive(OurSim ourSim,Long time,String interested,String monitored){
  ActiveEntity interestedObj=ourSim.getGrid().getObject(interested);
  Monitor monitor=interestedObj.getMonitor(monitored);
  if (monitor == null) {
    return;
  }
  Event isItAliveReceivedEvent=ourSim.createEvent(FailureDetectionEvents.IS_IT_ALIVE_RECEIVED,time,interested,monitored,monitor.isCreatingConnection());
  interestedObj.isItAliveSent(monitored,time);
  ourSim.addNetworkEvent(isItAliveReceivedEvent);
  Event isItAliveSentEvent=ourSim.createEvent(FailureDetectionEvents.IS_IT_ALIVE_SENT,time + interestedObj.getTimeToNextPing(monitored,time),interested,monitored);
  ourSim.addEvent(isItAliveSentEvent);
}","public static void sendIsItAlive(OurSim ourSim,Long time,String interested,String monitored){
  ActiveEntity interestedObj=ourSim.getGrid().getObject(interested);
  Monitor monitor=interestedObj.getMonitor(monitored);
  if (monitor == null) {
    return;
  }
  Event isItAliveReceivedEvent=ourSim.createEvent(FailureDetectionEvents.IS_IT_ALIVE_RECEIVED,time,interested,monitored,monitor.isCreatingConnection());
  interestedObj.isItAliveSent(monitored,time);
  ourSim.addNetworkEvent(isItAliveReceivedEvent);
  if (ourSim.getBooleanProperty(Configuration.PROP_USE_FAILURE_DETECTOR)) {
    Event isItAliveSentEvent=ourSim.createEvent(FailureDetectionEvents.IS_IT_ALIVE_SENT,time + interestedObj.getTimeToNextPing(monitored,time),interested,monitored);
    ourSim.addEvent(isItAliveSentEvent);
  }
}",0.9443708609271524
180580,"public static Monitor registerMonitored(OurSim ourSim,Long time,String interested,String monitored,Event callbackAliveEvent,Event callbackDownEvent,boolean isUp){
  ActiveEntity interestedObj=ourSim.getGrid().getObject(interested);
  ActiveEntity monitoredObj=ourSim.getGrid().getObject(monitored);
  Monitor monitor=new Monitor(monitoredObj,callbackAliveEvent,callbackDownEvent);
  monitor.setUp(isUp);
  interestedObj.addMonitor(monitor,time);
  if (ourSim.getBooleanProperty(Configuration.PROP_USE_FAILURE_DETECTOR)) {
    sendIsItAlive(ourSim,time,interested,monitored);
  }
  return monitor;
}","public static Monitor registerMonitored(OurSim ourSim,Long time,String interested,String monitored,Event callbackAliveEvent,Event callbackDownEvent,boolean isUp){
  ActiveEntity interestedObj=ourSim.getGrid().getObject(interested);
  ActiveEntity monitoredObj=ourSim.getGrid().getObject(monitored);
  Monitor monitor=new Monitor(monitoredObj,callbackAliveEvent,callbackDownEvent);
  monitor.setUp(isUp);
  interestedObj.addMonitor(monitor,time);
  sendIsItAlive(ourSim,time,interested,monitored);
  return monitor;
}",0.8078994614003591
180581,"@Override public void process(OurSim ourSim){
  ActiveEntity interestedObj=ourSim.getGrid().getObject(interested);
  Monitor monitor=interestedObj.getMonitor(monitored);
  if (monitor == null) {
    return;
  }
  boolean wasUp=monitor.isUp();
  interestedObj.updateStatusReceived(monitored,getTime());
  Monitor monitoredRef=monitor;
  if (!wasUp) {
    Event callbackAliveEvent=monitoredRef.getCallbackAliveEvent();
    if (callbackAliveEvent != null) {
      callbackAliveEvent.setTime(getTime());
      ourSim.addEvent(callbackAliveEvent);
    }
  }
  MonitorUtil.checkLiveness(ourSim,getTime(),interested,monitored);
}","@Override public void process(OurSim ourSim){
  ActiveEntity interestedObj=ourSim.getGrid().getObject(interested);
  Monitor monitor=interestedObj.getMonitor(monitored);
  if (monitor == null) {
    return;
  }
  boolean wasUp=monitor.isUp();
  interestedObj.updateStatusReceived(monitored,getTime());
  Monitor monitoredRef=monitor;
  if (!wasUp) {
    Event callbackAliveEvent=monitoredRef.getCallbackAliveEvent();
    if (callbackAliveEvent != null) {
      callbackAliveEvent.setTime(getTime());
      ourSim.addEvent(callbackAliveEvent);
    }
  }
  if (ourSim.getBooleanProperty(Configuration.PROP_USE_FAILURE_DETECTOR)) {
    MonitorUtil.checkLiveness(ourSim,getTime(),interested,monitored);
  }
}",0.93815987933635
180582,"private int map(GrammarRule grammarRule,NonTerminalSymbol parseNode,int depth,Chromosome chromosome,int currentCodon){
  if (depth + 1 > maxDepth - 1) {
    return -1;
  }
  int noProductions=grammarRule.getNoProductions();
  GrammarProduction production;
  if (noProductions == 1) {
    production=grammarRule.getProduction(0);
  }
 else {
    Codon codon=chromosome.getCodon(currentCodon++);
    if (codon == null) {
      return -1;
    }
    int productionChoice=(int)Math.abs(codon.value() % noProductions);
    production=grammarRule.getProduction(productionChoice);
  }
  for (  GrammarNode s : production.getGrammarNodes()) {
    if (s instanceof GrammarLiteral) {
      parseNode.addChild(new TerminalSymbol((GrammarLiteral)s));
    }
 else {
      GrammarRule nextGrammarRule=(GrammarRule)s;
      NonTerminalSymbol nextParseNode=new NonTerminalSymbol(nextGrammarRule);
      parseNode.addChild(nextParseNode);
      currentCodon=map(nextGrammarRule,nextParseNode,depth + 1,chromosome,currentCodon);
      if (currentCodon == -1) {
        return -1;
      }
    }
  }
  return currentCodon;
}","private int map(GrammarRule grammarRule,NonTerminalSymbol parseNode,int depth,Chromosome chromosome,int currentCodon){
  if (depth + 1 > maxDepth) {
    return -1;
  }
  int noProductions=grammarRule.getNoProductions();
  GrammarProduction production;
  if (noProductions == 1) {
    production=grammarRule.getProduction(0);
  }
 else {
    Codon codon=chromosome.getCodon(currentCodon++);
    if (codon == null) {
      return -1;
    }
    int productionChoice=(int)Math.abs(codon.value() % noProductions);
    production=grammarRule.getProduction(productionChoice);
  }
  for (  GrammarNode s : production.getGrammarNodes()) {
    if (s instanceof GrammarLiteral) {
      parseNode.addChild(new TerminalSymbol((GrammarLiteral)s));
    }
 else {
      GrammarRule nextGrammarRule=(GrammarRule)s;
      NonTerminalSymbol nextParseNode=new NonTerminalSymbol(nextGrammarRule);
      parseNode.addChild(nextParseNode);
      currentCodon=map(nextGrammarRule,nextParseNode,depth + 1,chromosome,currentCodon);
      if (currentCodon == -1) {
        return -1;
      }
    }
  }
  return currentCodon;
}",0.9981834695731152
180583,"public CachedSourceGenerator(SourceGenerator<T> delegate){
  this.delegate=delegate;
}","public CachedSourceGenerator(SourceGenerator<T> delegate){
  this.delegate=delegate;
  cache=new HashMap<Object,String>();
}",0.819047619047619
180584,"@Override public String getSource(T program){
  return delegate.getSource(program);
}","@Override public String getSource(T individual){
  Object key=key(individual);
  String source=cache.get(key);
  if (source == null) {
    source=delegate.getSource(individual);
    cache.put(key,source);
  }
  return source;
}",0.2435897435897435
180585,"/** 
 * Returns a clone of this individual with a copy of its fitness assigned
 * @return an individual which is a copy of this individual
 */
@Override public AbstractIndividual clone(){
  try {
    AbstractIndividual clone=(AbstractIndividual)super.clone();
    clone.fitness=fitness.clone();
    return clone;
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalError();
  }
}","/** 
 * Returns a clone of this individual with a copy of its fitness assigned
 * @return an individual which is a copy of this individual
 */
@Override public AbstractIndividual clone(){
  try {
    AbstractIndividual clone=(AbstractIndividual)super.clone();
    if (fitness != null) {
      clone.fitness=fitness.clone();
    }
    return clone;
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalError();
  }
}",0.9575757575757576
180586,"/** 
 * Returns a string representation of the generation population.
 * @return a string representation of the generation population.
 */
@Override public String toString(){
  return population.toString();
}","/** 
 * Returns a string representation of the generation population.
 * @return a string representation of the generation population.
 */
@Override public String toString(){
  StringBuffer buffer=new StringBuffer();
  boolean sep=false;
  for (  Individual individual : population) {
    if (sep) {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(individual);
    sep=true;
  }
  return buffer.toString();
}",0.5664556962025317
180587,"/** 
 * Appends multiple codons to the end of the chromosome
 * @param codons a list of codons to append
 */
public void appendCodons(List<Codon> codons){
  codons.addAll(codons);
}","/** 
 * Appends multiple codons to the end of the chromosome
 * @param newCodons a list of codons to append
 */
public void appendCodons(List<Codon> newCodons){
  codons.addAll(newCodons);
}",0.9595687331536388
180588,"/** 
 * Sets up the given template with the benchmark config settings
 * @param template a map to be filled with the template config
 */
@Override protected void fill(Map<ConfigKey<?>,Object> template){
  super.fill(template);
  template.put(Population.SIZE,100);
  List<TerminationCriteria> criteria=new ArrayList<TerminationCriteria>();
  criteria.add(new TerminationFitness(new DoubleFitness.Minimise(0.0)));
  criteria.add(new MaximumGenerations());
  template.put(EvolutionaryStrategy.TERMINATION_CRITERIA,criteria);
  template.put(MaximumGenerations.MAXIMUM_GENERATIONS,50);
  template.put(GEIndividual.MAXIMUM_DEPTH,17);
  template.put(Breeder.SELECTOR,new TournamentSelector());
  template.put(TournamentSelector.TOURNAMENT_SIZE,7);
  List<Operator> operators=new ArrayList<Operator>();
  operators.add(new OnePointCrossover());
  operators.add(new PointMutation());
  template.put(Breeder.OPERATORS,operators);
  template.put(OnePointCrossover.PROBABILITY,0.0);
  template.put(PointMutation.PROBABILITY,1.0);
  template.put(Initialiser.METHOD,new Grow());
  RandomSequence randomSequence=new MersenneTwisterFast();
  template.put(RandomSequence.RANDOM_SEQUENCE,randomSequence);
  String grammarStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  AntLandscape landscape=new AntLandscape(LANDSCAPE_SIZE,null);
  Ant ant=new Ant(MAXIMUM_TIMESTEPS,landscape);
  template.put(Grammar.GRAMMAR,new Grammar(grammarStr));
  template.put(CodonFactory.CODON_FACTORY,new IntegerCodonFactory());
  template.put(CFGFitnessFunction.INTERPRETER,new EpoxInterpreter<GEIndividual>(new GESourceGenerator()));
  template.put(MappingComponent.MAPPER,new DepthFirstMapper());
  template.put(FitnessEvaluator.FUNCTION,new FoodLocationCount(ant,landscape));
  template.put(FoodLocationCount.FOOD_LOCATIONS,FOOD_LOCATIONS);
  template.put(FoodLocationCount.MAXIMUM_TIMESTEPS,MAXIMUM_TIMESTEPS);
}","/** 
 * Sets up the given template with the benchmark config settings
 * @param template a map to be filled with the template config
 */
@Override protected void fill(Map<ConfigKey<?>,Object> template){
  super.fill(template);
  template.put(Population.SIZE,100);
  List<TerminationCriteria> criteria=new ArrayList<TerminationCriteria>();
  criteria.add(new TerminationFitness(new DoubleFitness.Minimise(0.0)));
  criteria.add(new MaximumGenerations());
  template.put(EvolutionaryStrategy.TERMINATION_CRITERIA,criteria);
  template.put(MaximumGenerations.MAXIMUM_GENERATIONS,50);
  template.put(CFGIndividual.MAXIMUM_DEPTH,17);
  template.put(Breeder.SELECTOR,new TournamentSelector());
  template.put(TournamentSelector.TOURNAMENT_SIZE,7);
  List<Operator> operators=new ArrayList<Operator>();
  operators.add(new SubtreeCrossover());
  operators.add(new SubtreeMutation());
  template.put(Breeder.OPERATORS,operators);
  template.put(SubtreeCrossover.PROBABILITY,0.0);
  template.put(SubtreeMutation.PROBABILITY,1.0);
  template.put(Initialiser.METHOD,new Grow());
  RandomSequence randomSequence=new MersenneTwisterFast();
  template.put(RandomSequence.RANDOM_SEQUENCE,randomSequence);
  String grammarStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  AntLandscape landscape=new AntLandscape(LANDSCAPE_SIZE,null);
  Ant ant=new Ant(MAXIMUM_TIMESTEPS,landscape);
  template.put(Grammar.GRAMMAR,new Grammar(grammarStr));
  template.put(CFGFitnessFunction.INTERPRETER,new EpoxInterpreter<CFGIndividual>(new CFGSourceGenerator()));
  template.put(FitnessEvaluator.FUNCTION,new FoodLocationCount(ant,landscape));
  template.put(FoodLocationCount.FOOD_LOCATIONS,FOOD_LOCATIONS);
  template.put(FoodLocationCount.MAXIMUM_TIMESTEPS,MAXIMUM_TIMESTEPS);
}",0.9110002625360988
180589,"/** 
 * Sets up the given template with the benchmark config settings
 * @param template a map to be filled with the template config
 */
@Override protected void fill(Map<ConfigKey<?>,Object> template){
  super.fill(template);
  template.put(Population.SIZE,100);
  List<TerminationCriteria> criteria=new ArrayList<TerminationCriteria>();
  criteria.add(new TerminationFitness(new DoubleFitness.Minimise(0.0)));
  criteria.add(new MaximumGenerations());
  template.put(EvolutionaryStrategy.TERMINATION_CRITERIA,criteria);
  template.put(MaximumGenerations.MAXIMUM_GENERATIONS,50);
  template.put(GEIndividual.MAXIMUM_DEPTH,17);
  template.put(Breeder.SELECTOR,new TournamentSelector());
  template.put(TournamentSelector.TOURNAMENT_SIZE,7);
  List<Operator> operators=new ArrayList<Operator>();
  operators.add(new OnePointCrossover());
  operators.add(new PointMutation());
  template.put(Breeder.OPERATORS,operators);
  template.put(OnePointCrossover.PROBABILITY,0.0);
  template.put(PointMutation.PROBABILITY,1.0);
  template.put(Initialiser.METHOD,new Grow());
  RandomSequence randomSequence=new MersenneTwisterFast();
  template.put(RandomSequence.RANDOM_SEQUENCE,randomSequence);
  String grammarStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  AntLandscape landscape=new AntLandscape(LANDSCAPE_SIZE,null);
  Ant ant=new Ant(MAXIMUM_TIMESTEPS,landscape);
  template.put(Grammar.GRAMMAR,new Grammar(grammarStr));
  template.put(CodonFactory.CODON_FACTORY,new IntegerCodonFactory());
  template.put(CFGFitnessFunction.INTERPRETER,new EpoxInterpreter<GEIndividual>(new GESourceGenerator()));
  template.put(MappingComponent.MAPPER,new DepthFirstMapper());
  template.put(FitnessEvaluator.FUNCTION,new FoodLocationCount(ant,landscape));
  template.put(FoodLocationCount.FOOD_LOCATIONS,FOOD_LOCATIONS);
  template.put(FoodLocationCount.MAXIMUM_TIMESTEPS,MAXIMUM_TIMESTEPS);
}","/** 
 * Sets up the given template with the benchmark config settings
 * @param template a map to be filled with the template config
 */
@Override protected void fill(Map<ConfigKey<?>,Object> template){
  super.fill(template);
  template.put(Population.SIZE,100);
  List<TerminationCriteria> criteria=new ArrayList<TerminationCriteria>();
  criteria.add(new TerminationFitness(new DoubleFitness.Minimise(0.0)));
  criteria.add(new MaximumGenerations());
  template.put(EvolutionaryStrategy.TERMINATION_CRITERIA,criteria);
  template.put(MaximumGenerations.MAXIMUM_GENERATIONS,50);
  template.put(CFGIndividual.MAXIMUM_DEPTH,17);
  template.put(Breeder.SELECTOR,new TournamentSelector());
  template.put(TournamentSelector.TOURNAMENT_SIZE,7);
  List<Operator> operators=new ArrayList<Operator>();
  operators.add(new SubtreeCrossover());
  operators.add(new SubtreeMutation());
  template.put(Breeder.OPERATORS,operators);
  template.put(SubtreeCrossover.PROBABILITY,0.0);
  template.put(SubtreeMutation.PROBABILITY,1.0);
  template.put(Initialiser.METHOD,new Grow());
  RandomSequence randomSequence=new MersenneTwisterFast();
  template.put(RandomSequence.RANDOM_SEQUENCE,randomSequence);
  String grammarStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  AntLandscape landscape=new AntLandscape(LANDSCAPE_SIZE,null);
  Ant ant=new Ant(MAXIMUM_TIMESTEPS,landscape);
  template.put(Grammar.GRAMMAR,new Grammar(grammarStr));
  template.put(CFGFitnessFunction.INTERPRETER,new EpoxInterpreter<CFGIndividual>(new CFGSourceGenerator()));
  template.put(FitnessEvaluator.FUNCTION,new FoodLocationCount(ant,landscape));
  template.put(FoodLocationCount.FOOD_LOCATIONS,FOOD_LOCATIONS);
  template.put(FoodLocationCount.MAXIMUM_TIMESTEPS,MAXIMUM_TIMESTEPS);
}",0.9110002625360988
180590,"/** 
 * Sets up the given template with the benchmark config settings
 * @param template a map to be filled with the template config
 */
@Override protected void fill(Map<ConfigKey<?>,Object> template){
  super.fill(template);
  template.put(Population.SIZE,100);
  List<TerminationCriteria> criteria=new ArrayList<TerminationCriteria>();
  criteria.add(new TerminationFitness(new DoubleFitness.Minimise(0.0)));
  criteria.add(new MaximumGenerations());
  template.put(EvolutionaryStrategy.TERMINATION_CRITERIA,criteria);
  template.put(MaximumGenerations.MAXIMUM_GENERATIONS,50);
  template.put(GEIndividual.MAXIMUM_DEPTH,17);
  template.put(Breeder.SELECTOR,new TournamentSelector());
  template.put(TournamentSelector.TOURNAMENT_SIZE,7);
  List<Operator> operators=new ArrayList<Operator>();
  operators.add(new OnePointCrossover());
  operators.add(new PointMutation());
  template.put(Breeder.OPERATORS,operators);
  template.put(OnePointCrossover.PROBABILITY,0.0);
  template.put(PointMutation.PROBABILITY,1.0);
  template.put(Initialiser.METHOD,new Grow());
  RandomSequence randomSequence=new MersenneTwisterFast();
  template.put(RandomSequence.RANDOM_SEQUENCE,randomSequence);
  String grammarStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  AntLandscape landscape=new AntLandscape(LANDSCAPE_SIZE,null);
  Ant ant=new Ant(MAXIMUM_TIMESTEPS,landscape);
  template.put(Grammar.GRAMMAR,new Grammar(grammarStr));
  template.put(CodonFactory.CODON_FACTORY,new IntegerCodonFactory());
  template.put(CFGFitnessFunction.INTERPRETER,new EpoxInterpreter<GEIndividual>(new GESourceGenerator()));
  template.put(MappingComponent.MAPPER,new DepthFirstMapper());
  template.put(FitnessEvaluator.FUNCTION,new FoodLocationCount(ant,landscape));
  template.put(FoodLocationCount.FOOD_LOCATIONS,FOOD_LOCATIONS);
  template.put(FoodLocationCount.MAXIMUM_TIMESTEPS,MAXIMUM_TIMESTEPS);
}","/** 
 * Sets up the given template with the benchmark config settings
 * @param template a map to be filled with the template config
 */
@Override protected void fill(Map<ConfigKey<?>,Object> template){
  super.fill(template);
  template.put(Population.SIZE,100);
  List<TerminationCriteria> criteria=new ArrayList<TerminationCriteria>();
  criteria.add(new TerminationFitness(new DoubleFitness.Minimise(0.0)));
  criteria.add(new MaximumGenerations());
  template.put(EvolutionaryStrategy.TERMINATION_CRITERIA,criteria);
  template.put(MaximumGenerations.MAXIMUM_GENERATIONS,50);
  template.put(CFGIndividual.MAXIMUM_DEPTH,17);
  template.put(Breeder.SELECTOR,new TournamentSelector());
  template.put(TournamentSelector.TOURNAMENT_SIZE,7);
  List<Operator> operators=new ArrayList<Operator>();
  operators.add(new SubtreeCrossover());
  operators.add(new SubtreeMutation());
  template.put(Breeder.OPERATORS,operators);
  template.put(SubtreeCrossover.PROBABILITY,0.0);
  template.put(SubtreeMutation.PROBABILITY,1.0);
  template.put(Initialiser.METHOD,new Grow());
  RandomSequence randomSequence=new MersenneTwisterFast();
  template.put(RandomSequence.RANDOM_SEQUENCE,randomSequence);
  String grammarStr=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  AntLandscape landscape=new AntLandscape(LANDSCAPE_SIZE,null);
  Ant ant=new Ant(MAXIMUM_TIMESTEPS,landscape);
  template.put(Grammar.GRAMMAR,new Grammar(grammarStr));
  template.put(CFGFitnessFunction.INTERPRETER,new EpoxInterpreter<CFGIndividual>(new CFGSourceGenerator()));
  template.put(FitnessEvaluator.FUNCTION,new FoodLocationCount(ant,landscape));
  template.put(FoodLocationCount.FOOD_LOCATIONS,FOOD_LOCATIONS);
  template.put(FoodLocationCount.MAXIMUM_TIMESTEPS,MAXIMUM_TIMESTEPS);
}",0.9110002625360988
180591,"/** 
 * Returns a clone of this individual with a copy of its fitness assigned
 * @return an individual which is a copy of this individual
 */
public AbstractIndividual clone(){
  try {
    AbstractIndividual clone=(AbstractIndividual)super.clone();
    clone.fitness=fitness.clone();
    return clone;
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalError();
  }
}","/** 
 * Returns a clone of this individual with a copy of its fitness assigned
 * @return an individual which is a copy of this individual
 */
public AbstractIndividual clone(){
  try {
    AbstractIndividual clone=(AbstractIndividual)super.clone();
    if (fitness != null) {
      clone.fitness=fitness.clone();
    }
    return clone;
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalError();
  }
}",0.9565217391304348
180592,"/** 
 * Parses an Epox program string as an executable <code>Node</code> tree. The given <code>source</code> parameter must contain a valid Epox program string, comprised only of nodes that have been declared. The data-types  of each function's inputs must correspond to valid data-types, otherwise  a <code>MalformedProgramException</code> will be thrown.
 * @param source the program string to be parsed as an Epox program.
 * @return a <code>Node</code> which is the root of a tree which isequivalent to the provided source string. A <code>null</code> value will be returned if the <code>source</code> parameter is <code>null</code>.
 * @throws MalformedProgramException if the given string does not representa valid Epox program.
 */
public Node parse(String source) throws MalformedProgramException {
  if (source == null) {
    return null;
  }
  int openingBracket=source.indexOf('(');
  String identifier=null;
  List<String> args=null;
  if (openingBracket == -1) {
    identifier=source;
    args=new ArrayList<String>();
  }
 else {
    identifier=source.substring(0,openingBracket).trim();
    int closingBracket=source.lastIndexOf(')');
    String argumentStr=source.substring(openingBracket + 1,closingBracket);
    args=splitArguments(argumentStr);
  }
  Node node=nodes.get(identifier).newInstance();
  if (node == null) {
    throw new MalformedProgramException(""String_Node_Str"" + identifier);
  }
 else   if (node.getArity() != args.size()) {
    throw new MalformedProgramException(""String_Node_Str"" + identifier + ""String_Node_Str""+ node.getArity()+ ""String_Node_Str""+ args.size()+ ""String_Node_Str"");
  }
 else {
    for (int i=0; i < args.size(); i++) {
      node.setChild(i,parse(args.get(i)));
    }
    if (node.dataType() == null) {
      if (node.isNonTerminal()) {
        throw new MalformedProgramException(""String_Node_Str"" + identifier + ""String_Node_Str"");
      }
 else {
        throw new MalformedProgramException(""String_Node_Str"" + identifier + ""String_Node_Str"");
      }
    }
  }
  return node;
}","/** 
 * Parses an Epox program string as an executable <code>Node</code> tree. The given <code>source</code> parameter must contain a valid Epox program string, comprised only of nodes that have been declared. The data-types  of each function's inputs must correspond to valid data-types, otherwise  a <code>MalformedProgramException</code> will be thrown.
 * @param source the program string to be parsed as an Epox program.
 * @return a <code>Node</code> which is the root of a tree which isequivalent to the provided source string. A <code>null</code> value will be returned if the <code>source</code> parameter is <code>null</code>.
 * @throws MalformedProgramException if the given string does not representa valid Epox program.
 */
public Node parse(String source) throws MalformedProgramException {
  if (source == null) {
    return null;
  }
  int openingBracket=source.indexOf('(');
  String identifier=null;
  List<String> args=null;
  if (openingBracket == -1) {
    identifier=source;
    args=new ArrayList<String>();
  }
 else {
    identifier=source.substring(0,openingBracket).trim();
    int closingBracket=source.lastIndexOf(')');
    String argumentStr=source.substring(openingBracket + 1,closingBracket);
    args=splitArguments(argumentStr);
  }
  Node node=nodes.get(identifier);
  if (node == null) {
    throw new MalformedProgramException(""String_Node_Str"" + identifier);
  }
 else   if (node.getArity() != args.size()) {
    throw new MalformedProgramException(""String_Node_Str"" + identifier + ""String_Node_Str""+ node.getArity()+ ""String_Node_Str""+ args.size()+ ""String_Node_Str"");
  }
 else {
    node=node.newInstance();
    for (int i=0; i < args.size(); i++) {
      node.setChild(i,parse(args.get(i)));
    }
    if (node.dataType() == null) {
      if (node.isNonTerminal()) {
        throw new MalformedProgramException(""String_Node_Str"" + identifier + ""String_Node_Str"");
      }
 else {
        throw new MalformedProgramException(""String_Node_Str"" + identifier + ""String_Node_Str"");
      }
    }
  }
  return node;
}",0.8409479599315905
180593,"/** 
 * Evaluates any valid Epox expression which may optionally contain the use of any argument named in the <code>argNames</code> array which will be pre-declared and assigned to the associated value taken from the <code>argValues</code> array.  The expression will be evaluated once for each set of <code>argValues</code>.  The object array returned will contain the result of each of these  evaluations in order. Any functions or terminals (except the input variables) which are not  part of the built-in language, must be declared in the EpoxParser before being used here.
 * @param expression an individual representing a valid Epox expression that is to be evaluated.
 * @param argNames {@inheritDoc}
 * @param argValues {@inheritDoc}
 * @return the return values from evaluating the expression. The runtimetype of the returned Objects may vary from program to program. If the program does not return a value then this method will return an array of nulls.
 */
@Override public Object[] eval(T program,String[] argNames,Object[][] argValues) throws MalformedProgramException {
  int noParamSets=argValues.length;
  int noParams=argNames.length;
  VariableNode[] declaredVariables=new VariableNode[noParams];
  String expression=generator.getSource(program);
  Object[] results=new Object[noParamSets];
  if (expression == null) {
    throw new MalformedProgramException(""String_Node_Str"");
  }
 else   if (noParamSets > 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int j=0; j < noParams; j++) {
    declaredVariables[j]=new VariableNode(new Variable(argNames[j],argValues[0][j]));
    parser.declare(declaredVariables[j]);
  }
  Node parseTree=parser.parse(expression);
  for (int i=0; i < noParamSets; i++) {
    Object[] paramSet=argValues[i];
    for (int j=0; j < noParams; j++) {
      declaredVariables[j].getVariable().setValue(paramSet[j]);
    }
    results[i]=parseTree.evaluate();
  }
  for (int j=0; j < noParams; j++) {
    parser.undeclare(declaredVariables[j]);
  }
  return results;
}","/** 
 * Evaluates any valid Epox expression which may optionally contain the use of any argument named in the <code>argNames</code> array which will be pre-declared and assigned to the associated value taken from the <code>argValues</code> array.  The expression will be evaluated once for each set of <code>argValues</code>.  The object array returned will contain the result of each of these  evaluations in order. Any functions or terminals (except the input variables) which are not  part of the built-in language, must be declared in the EpoxParser before being used here.
 * @param expression an individual representing a valid Epox expression that is to be evaluated.
 * @param argNames {@inheritDoc}
 * @param argValues {@inheritDoc}
 * @return the return values from evaluating the expression. The runtimetype of the returned Objects may vary from program to program. If the program does not return a value then this method will return an array of nulls.
 */
@Override public Object[] eval(T program,String[] argNames,Object[][] argValues) throws MalformedProgramException {
  int noParamSets=argValues.length;
  int noParams=argNames.length;
  VariableNode[] declaredVariables=new VariableNode[noParams];
  String expression=generator.getSource(program);
  Object[] results=new Object[noParamSets];
  if (expression == null) {
    throw new MalformedProgramException(""String_Node_Str"");
  }
 else   if (noParamSets <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (int j=0; j < noParams; j++) {
    declaredVariables[j]=new VariableNode(new Variable(argNames[j],argValues[0][j]));
    parser.declare(declaredVariables[j]);
  }
  Node parseTree=parser.parse(expression);
  for (int i=0; i < noParamSets; i++) {
    Object[] paramSet=argValues[i];
    for (int j=0; j < noParams; j++) {
      declaredVariables[j].getVariable().setValue(paramSet[j]);
    }
    results[i]=parseTree.evaluate();
  }
  for (int j=0; j < noParams; j++) {
    parser.undeclare(declaredVariables[j]);
  }
  return results;
}",0.9992638036809816
180594,"/** 
 * Constructs an <code>IntegerCodonFactory</code> with control parameters initially loaded from the config. If the <code>autoConfig</code> argument is set to <code>true</code> then the configuration will be automatically updated when the config is modified.
 * @param autoConfig whether this operator should automatically update itsconfiguration settings from the config
 */
public IntegerCodonFactory(boolean autoConfig){
  maxCodon=Long.MAX_VALUE;
  minCodon=Long.MIN_VALUE;
  setup();
  if (autoConfig) {
    EventManager.getInstance().add(ConfigEvent.class,this);
  }
}","/** 
 * Constructs an <code>IntegerCodonFactory</code> with control parameters initially loaded from the config. If the <code>autoConfig</code> argument is set to <code>true</code> then the configuration will be automatically updated when the config is modified.
 * @param autoConfig whether this operator should automatically update itsconfiguration settings from the config
 */
public IntegerCodonFactory(boolean autoConfig){
  maxCodon=Long.MAX_VALUE;
  minCodon=0L;
  setup();
  if (autoConfig) {
    EventManager.getInstance().add(ConfigEvent.class,this);
  }
}",0.9877622377622378
180595,"/** 
 * Sets up this operator with the appropriate configuration settings. This method is called whenever a <code>ConfigEvent</code> occurs for a change in any of the following configuration parameters: <ul> <li>  {@link RandomSequence#RANDOM_SEQUENCE}<li>  {@link Codon#MAXIMUM_VALUE}<li>  {@link Codon#MINIMUM_VALUE}</ul>
 */
protected void setup(){
  random=Config.getInstance().get(RANDOM_SEQUENCE);
  maxCodon=Config.getInstance().get(MAXIMUM_VALUE,maxCodon);
  minCodon=Config.getInstance().get(MINIMUM_VALUE,minCodon);
  codonRange=maxCodon - minCodon;
}","/** 
 * Sets up this operator with the appropriate configuration settings. This method is called whenever a <code>ConfigEvent</code> occurs for a change in any of the following configuration parameters: <ul> <li>  {@link RandomSequence#RANDOM_SEQUENCE}<li>  {@link Codon#MAXIMUM_VALUE}<li>  {@link Codon#MINIMUM_VALUE}</ul>
 */
protected void setup(){
  random=Config.getInstance().get(RANDOM_SEQUENCE);
  maxCodon=Config.getInstance().get(MAXIMUM_VALUE,maxCodon);
  minCodon=Config.getInstance().get(MINIMUM_VALUE,minCodon);
  if (minCodon < 0) {
    new IllegalStateException(""String_Node_Str"");
  }
 else   if (maxCodon <= minCodon) {
    new IllegalStateException(""String_Node_Str"");
  }
  codonRange=maxCodon - minCodon;
}",0.8711180124223602
180596,"/** 
 * Sets the number of individuals to be generated in a population created by the <tt>createPopulation</tt> method. If automatic configuration is enabled thenAny value set here will be overwritten by the  {@link Population#SIZE} configuration setting on the next config event.
 * @param size the size of the populations generated
 */
public void setPopulationSize(int size){
  this.populationSize=size;
}","/** 
 * Sets the number of individuals to be generated in a population created by the <tt>createPopulation</tt> method. If automatic configuration is enabled then any value set here will be overwritten by the  {@link Population#SIZE} configuration setting on the next config event.
 * @param size the size of the populations generated
 */
public void setPopulationSize(int size){
  this.populationSize=size;
}",0.996328029375765
180597,"/** 
 * Constructs a new <tt>STGPIndividual</tt> instance with a program tree composed of nodes provided by the   {@link STGPIndividual#SYNTAX} configparameter. A grow or a full initialisation method is used, select at random
 * @return a new individual
 */
@Override public STGPIndividual createIndividual(){
  if (random.nextBoolean()) {
    return grow.createIndividual();
  }
 else {
    return full.createIndividual();
  }
}","/** 
 * Constructs a new <tt>STGPIndividual</tt> instance with a program tree composed of nodes provided by the   {@link STGPIndividual#SYNTAX} configparameter. A grow or a full initialisation method is used, selected at random
 * @return a new individual
 */
@Override public STGPIndividual createIndividual(){
  if (random.nextBoolean()) {
    return grow.createIndividual();
  }
 else {
    return full.createIndividual();
  }
}",0.9976744186046512
180598,public abstract AbstractIndividual clone();,"public AbstractIndividual clone(){
  try {
    return (AbstractIndividual)super.clone();
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalError();
  }
}",0.3177570093457944
180599,"/** 
 * Compares this individual to another based on their fitness. It returns a negative integer, zero, or a positive integer as this instance represents the quality of an individual that is less fit, equally fit, or more fit than the specified object. The individuals do not need to be of the same object type, but must have comparable <tt>Fitness</tt> instances.
 * @param other an individual to compare against
 * @return a negative integer, zero, or a positive integer as this object isless fit than, equally fit as, or fitter than the specified object
 */
@Override public int compareTo(Individual other){
  return fitness.compareTo(other.getFitness());
}","/** 
 * Compares this individual to another based on their fitness. It returns a negative integer, zero, or a positive integer as this instance represents the quality of an individual that is less fit, equally fit, or more fit than the specified object. The individuals do not need to be of the same object type, but must have non-null, comparable <tt>Fitness</tt> instances.
 * @param other an individual to compare against
 * @return a negative integer, zero, or a positive integer as this object isless fit than, equally fit as, or fitter than the specified object
 */
@Override public int compareTo(Individual other){
  return getFitness().compareTo(other.getFitness());
}",0.9783096484667164
180600,"@Override public int hashCode(){
  int hash=1;
  hash=hash * 13 + (root == null ? 0 : root.hashCode());
  return hash;
}","/** 
 * Returns a hash code value for the object.
 * @return a hash code value for this object
 */
@Override public int hashCode(){
  int hash=1;
  hash=hash * 13 + (root == null ? 0 : root.hashCode());
  return hash;
}",0.7079646017699115
180601,"/** 
 * Compares the given object to this instance for equality. Equivalence is defined as them both being instances of <tt>STGPIndividual</tt> and having equal program trees according to <tt>getRoot().equals(obj)</tt>.
 * @param obj an object to be compared for equivalence.
 * @return true if this individual is equivalent to the specified object andfalse otherwise.
 */
@Override public boolean equals(Object obj){
  boolean equal=false;
  if ((obj != null) && (obj instanceof STGPIndividual)) {
    STGPIndividual p=(STGPIndividual)obj;
    if (ObjectUtils.equals(root,p.root)) {
      equal=true;
    }
  }
  return equal;
}","/** 
 * Compares the given object to this instance for equality. Equivalence is defined as them both being instances of <tt>STGPIndividual</tt> and having equal program trees according to <tt>getRoot().equals(obj)</tt> (or if both root nodes are <tt>null</tt>).
 * @param obj an object to be compared for equivalence.
 * @return true if this individual is equivalent to the specified object andfalse otherwise.
 */
@Override public boolean equals(Object obj){
  boolean equal=false;
  if ((obj != null) && (obj instanceof STGPIndividual)) {
    STGPIndividual p=(STGPIndividual)obj;
    if (ObjectUtils.equals(root,p.root)) {
      equal=true;
    }
  }
  return equal;
}",0.9676923076923076
180602,"/** 
 * Creates and returns a copy of this program. The copied individual has a deep clone of the program tree.
 * @return a clone of this <tt>STGPIndividual</tt> instance
 */
@Override public STGPIndividual clone(){
  STGPIndividual clone=null;
  try {
    clone=(STGPIndividual)super.clone();
  }
 catch (  CloneNotSupportedException e) {
    e.printStackTrace();
  }
  if (root == null) {
    clone.root=null;
  }
 else {
    clone.root=root.clone();
  }
  return clone;
}","/** 
 * Creates and returns a copy of this program. The copied individual has a deep clone of the program tree. The clone is not assigned this individual's fitness.
 * @return a clone of this <tt>STGPIndividual</tt> instance
 */
@Override public STGPIndividual clone(){
  STGPIndividual clone=(STGPIndividual)super.clone();
  if (root == null) {
    clone.root=null;
  }
 else {
    clone.root=root.clone();
  }
  return clone;
}",0.6570796460176991
180603,"/** 
 * Returns a string representation of this individual
 * @return a string representation of this individual
 */
@Override public String toString(){
  if (root == null) {
    return null;
  }
 else {
    return root.toString();
  }
}","/** 
 * Returns a string representation of this individual. The string representation is the Epox source code of the program tree.
 * @return a string representation of this individual
 */
@Override public String toString(){
  if (root == null) {
    return null;
  }
 else {
    return root.toString();
  }
}",0.8681318681318682
180604,"/** 
 * Evaluates the strongly typed program tree this individual represents and returns the value returned from the root
 * @return the result of evaluating the program tree
 */
public Object evaluate(){
  return root.evaluate();
}","/** 
 * Evaluates the strongly typed program tree this individual represents and returns the value returned from the root. If no root node has been set then  an exception will be thrown.
 * @return the result of evaluating the program tree
 */
public Object evaluate(){
  return root.evaluate();
}",0.8771266540642723
180605,"/** 
 * {@inheritDoc}
 */
@Override public Object[] eval(T program,Parameters params) throws MalformedProgramException {
  int noParamSets=params.getNoParameterSets();
  int noParams=params.getNoParameters();
  String expression=generator.getSource(program);
  Object[] results=new Object[noParamSets];
  for (int i=0; i < noParamSets; i++) {
    parser.undeclareAllVariables();
    Object[] paramSet=params.getParameterSet(i);
    for (int j=0; j < noParams; j++) {
      parser.declareVariable(new Variable(params.getIdentifier(j),paramSet[j]));
    }
    final Node programTree=parser.parse(expression);
    results[i]=programTree.evaluate();
  }
  return results;
}","/** 
 * {@inheritDoc}
 */
@Override public Object[] eval(T program,Parameters params) throws MalformedProgramException {
  int noParamSets=params.getNoParameterSets();
  int noParams=params.getNoParameters();
  VariableNode[] declaredVariables=new VariableNode[noParams];
  String expression=generator.getSource(program);
  Object[] results=new Object[noParamSets];
  for (int i=0; i < noParamSets; i++) {
    for (int j=0; j < noParams; j++) {
      parser.undeclare(declaredVariables[j]);
    }
    Object[] paramSet=params.getParameterSet(i);
    for (int j=0; j < noParams; j++) {
      declaredVariables[j]=new VariableNode(new Variable(params.getIdentifier(j),paramSet[j]));
      parser.declare(declaredVariables[j]);
    }
    final Node programTree=parser.parse(expression);
    results[i]=programTree.evaluate();
  }
  return results;
}",0.6415841584158416
180606,"/** 
 * Sets the array of nodes to generate program trees from. If automatic configuration is enabled then any value set here will be overwritten by  the   {@link STGPIndividual#SYNTAX} configuration setting on the next config event.
 * @param syntax an array of nodes to generate new program trees from
 */
public void setSyntax(Node[] syntax){
  this.syntax=syntax;
  updateSyntax();
}","/** 
 * Sets the array of nodes to generate program trees from. If automatic configuration is enabled then any value set here will be overwritten by the   {@link STGPIndividual#SYNTAX} configuration setting on the nextconfig event.
 * @param syntax an array of nodes to generate new program trees from
 */
public void setSyntax(Node[] syntax){
  this.syntax=syntax;
  updateSyntax();
}",0.9974093264248703
180607,"/** 
 * Sets the random number sequence to use. If automatic configuration is  enabled thenAny value set here will be overwritten by the   {@link RandomSequence#RANDOM_SEQUENCE} configuration setting on the next config event.
 * @param random the random number generator to set
 */
public void setRandomSequence(RandomSequence random){
  this.random=random;
}","/** 
 * Sets the random number sequence to use. If automatic configuration is enabled thenAny value set here will be overwritten by the  {@link RandomSequence#RANDOM_SEQUENCE} configuration setting on the nextconfig event.
 * @param random the random number generator to set
 */
public void setRandomSequence(RandomSequence random){
  this.random=random;
}",0.9958041958041958
180608,"/** 
 * Sets the number of individuals to be generated in a population created by the <tt>createPopulation</tt> method. If automatic configuration is  enabled thenAny value set here will be overwritten by the   {@link Population#SIZE} configuration setting on the next config event.
 * @param size the size of the populations generated
 */
public void setPopulationSize(int size){
  this.populationSize=size;
}","/** 
 * Sets the number of individuals to be generated in a population created by the <tt>createPopulation</tt> method. If automatic configuration is enabled thenAny value set here will be overwritten by the  {@link Population#SIZE} configuration setting on the next config event.
 * @param size the size of the populations generated
 */
public void setPopulationSize(int size){
  this.populationSize=size;
}",0.9975550122249388
180609,"/** 
 * Sets the required data-type of the program trees generated. If automatic configuration is enabled then any value set here will be overwritten by  the   {@link STGPIndividual#RETURN_TYPE} configuration setting on the next config event.
 * @param returnType the data-type of the generated programs
 */
public void setReturnType(final Class<?> returnType){
  this.returnType=returnType;
  dataTypesTable=null;
}","/** 
 * Sets the required data-type of the program trees generated. If automatic configuration is enabled then any value set here will be overwritten by the   {@link STGPIndividual#RETURN_TYPE} configuration setting on the nextconfig event.
 * @param returnType the data-type of the generated programs
 */
public void setReturnType(final Class<?> returnType){
  this.returnType=returnType;
  dataTypesTable=null;
}",0.9975903614457832
180610,"/** 
 * Constructs a <tt>FullInitialisation</tt> with control parameters initially loaded from the config. If the <tt>autoConfig</tt> argument is set to <tt>true</tt> then the configuration will be automatically updated when the config is modified.
 * @param autoConfig whether this operator should automatically update itsconfiguration settings from the config
 */
public FullInitialisation(boolean autoConfig){
  setup();
  if (autoConfig) {
    EventManager.getInstance().add(ConfigEvent.class,this);
  }
}","/** 
 * Constructs a <tt>FullInitialisation</tt> with control parameters initially loaded from the config. If the <tt>autoConfig</tt> argument is set to <tt>true</tt> then the configuration will be automatically updated when the config is modified.
 * @param autoConfig whether this operator should automatically update itsconfiguration settings from the config
 */
public FullInitialisation(boolean autoConfig){
  setup();
  updateSyntax();
  if (autoConfig) {
    EventManager.getInstance().add(ConfigEvent.class,this);
  }
}",0.9826254826254828
180611,"/** 
 * Sets up this operator with the appropriate configuration settings. This method is called whenever a <tt>ConfigEvent</tt> occurs for a change in any of the following configuration parameters: <ul> <li>  {@link RandomSequence#RANDOM_SEQUENCE}<li>  {@link Population#SIZE}<li>  {@link STGPIndividual#SYNTAX}<li>  {@link STGPIndividual#RETURN_TYPE}<li>  {@link STGPIndividual#MAXIMUM_DEPTH}<li>  {@link STGPInitialisation#MAXIMUM_INITIAL_DEPTH}<li>  {@link InitialisationMethod#ALLOW_DUPLICATES}</ul>
 */
protected void setup(){
  random=Config.getInstance().get(RANDOM_SEQUENCE);
  populationSize=Config.getInstance().get(SIZE);
  syntax=Config.getInstance().get(SYNTAX);
  returnType=Config.getInstance().get(RETURN_TYPE);
  allowDuplicates=Config.getInstance().get(ALLOW_DUPLICATES);
  Integer maxDepth=Config.getInstance().get(MAXIMUM_DEPTH);
  Integer maxInitialDepth=Config.getInstance().get(MAXIMUM_INITIAL_DEPTH);
  if (maxInitialDepth != null && (maxDepth == null || maxInitialDepth < maxDepth)) {
    depth=maxInitialDepth;
  }
 else {
    depth=maxDepth;
  }
}","/** 
 * Sets up this operator with the appropriate configuration settings. This method is called whenever a <tt>ConfigEvent</tt> occurs for a change in any of the following configuration parameters: <ul> <li>  {@link RandomSequence#RANDOM_SEQUENCE}<li>  {@link Population#SIZE}<li>  {@link STGPIndividual#SYNTAX}<li>  {@link STGPIndividual#RETURN_TYPE}<li>  {@link STGPIndividual#MAXIMUM_DEPTH}<li>  {@link STGPInitialisation#MAXIMUM_INITIAL_DEPTH}<li>  {@link InitialisationMethod#ALLOW_DUPLICATES} (default: <tt>true</tt>)</ul>
 */
protected void setup(){
  random=Config.getInstance().get(RANDOM_SEQUENCE);
  populationSize=Config.getInstance().get(SIZE);
  syntax=Config.getInstance().get(SYNTAX);
  returnType=Config.getInstance().get(RETURN_TYPE);
  allowDuplicates=Config.getInstance().get(ALLOW_DUPLICATES,true);
  Integer maxDepth=Config.getInstance().get(MAXIMUM_DEPTH);
  Integer maxInitialDepth=Config.getInstance().get(MAXIMUM_INITIAL_DEPTH);
  if (maxInitialDepth != null && (maxDepth == null || maxInitialDepth < maxDepth)) {
    depth=maxInitialDepth;
  }
 else {
    depth=(maxDepth == null) ? -1 : maxDepth;
  }
}",0.9746146872166818
180612,"/** 
 * Sets the depth of the program trees created by the <tt>createIndividual</tt> method. If automatic configuration is enabled  then any value set here will be overwritten by the   {@link STGPInitialisation#MAXIMUM_INITIAL_DEPTH} configuration setting onthe next config event, or the  {@link STGPIndividual#MAXIMUM_DEPTH} setting if no initial maximum depth is set.
 * @param depth the depth of all program trees generated
 */
public void setDepth(int depth){
  if (depth > dataTypesTable.length) {
    dataTypesTable=null;
  }
  this.depth=depth;
}","/** 
 * Sets the depth of the program trees created by the <tt>createIndividual</tt> method. If automatic configuration is enabled then any value set here will be overwritten by the  {@link STGPInitialisation#MAXIMUM_INITIAL_DEPTH} configuration setting onthe next config event, or the  {@link STGPIndividual#MAXIMUM_DEPTH}setting if no initial maximum depth is set.
 * @param depth the depth of all program trees generated
 */
public void setDepth(int depth){
  if (dataTypesTable != null && depth > dataTypesTable.length) {
    dataTypesTable=null;
  }
  this.depth=depth;
}",0.9743135518157662
180613,"/** 
 * Sets the maximum depth of the program trees created by the <tt>createIndividual</tt> method. If automatic configuration is enabled  then any value set here will be overwritten by the   {@link STGPInitialisation#MAXIMUM_INITIAL_DEPTH} configuration setting onthe next config event, or the  {@link STGPIndividual#MAXIMUM_DEPTH} setting if no initial maximum depth is set.
 * @param maxDepth the maximum depth of all program trees generated
 */
public void setMaximumDepth(int maxDepth){
  if (maxDepth > dataTypesTable.length) {
    dataTypesTable=null;
  }
  this.maxDepth=maxDepth;
}","/** 
 * Sets the maximum depth of the program trees created by the <tt>createIndividual</tt> method. If automatic configuration is enabled  then any value set here will be overwritten by the   {@link STGPInitialisation#MAXIMUM_INITIAL_DEPTH} configuration setting onthe next config event, or the  {@link STGPIndividual#MAXIMUM_DEPTH} setting if no initial maximum depth is set.
 * @param maxDepth the maximum depth of all program trees generated
 */
public void setMaximumDepth(int maxDepth){
  if (dataTypesTable != null && maxDepth > dataTypesTable.length) {
    dataTypesTable=null;
  }
  this.maxDepth=maxDepth;
}",0.9784768211920528
180614,"/** 
 * Sets up this operator with the appropriate configuration settings. This method is called whenever a <tt>ConfigEvent</tt> occurs for a change in any of the following configuration parameters: <ul> <li>  {@link RandomSequence#RANDOM_SEQUENCE}<li>  {@link Population#SIZE}<li>  {@link STGPIndividual#SYNTAX}<li>  {@link STGPIndividual#RETURN_TYPE}<li>  {@link STGPIndividual#MAXIMUM_DEPTH}<li>  {@link STGPInitialisation#MAXIMUM_INITIAL_DEPTH}<li>  {@link InitialisationMethod#ALLOW_DUPLICATES}</ul>
 */
protected void setup(){
  random=Config.getInstance().get(RANDOM_SEQUENCE);
  populationSize=Config.getInstance().get(SIZE);
  syntax=Config.getInstance().get(SYNTAX);
  returnType=Config.getInstance().get(RETURN_TYPE);
  allowDuplicates=Config.getInstance().get(ALLOW_DUPLICATES);
  Integer maxDepth=Config.getInstance().get(MAXIMUM_DEPTH);
  Integer maxInitialDepth=Config.getInstance().get(MAXIMUM_INITIAL_DEPTH);
  if (maxInitialDepth != null && (maxDepth == null || maxInitialDepth < maxDepth)) {
    this.maxDepth=maxInitialDepth;
  }
 else {
    this.maxDepth=maxDepth;
  }
}","/** 
 * Sets up this operator with the appropriate configuration settings. This method is called whenever a <tt>ConfigEvent</tt> occurs for a change in any of the following configuration parameters: <ul> <li>  {@link RandomSequence#RANDOM_SEQUENCE}<li>  {@link Population#SIZE}<li>  {@link STGPIndividual#SYNTAX}<li>  {@link STGPIndividual#RETURN_TYPE}<li>  {@link STGPIndividual#MAXIMUM_DEPTH}<li>  {@link STGPInitialisation#MAXIMUM_INITIAL_DEPTH}<li>  {@link InitialisationMethod#ALLOW_DUPLICATES} (default: <tt>true</tt>)</ul>
 */
protected void setup(){
  random=Config.getInstance().get(RANDOM_SEQUENCE);
  populationSize=Config.getInstance().get(SIZE);
  syntax=Config.getInstance().get(SYNTAX);
  returnType=Config.getInstance().get(RETURN_TYPE);
  allowDuplicates=Config.getInstance().get(ALLOW_DUPLICATES,true);
  Integer maxDepth=Config.getInstance().get(MAXIMUM_DEPTH);
  Integer maxInitialDepth=Config.getInstance().get(MAXIMUM_INITIAL_DEPTH);
  if (maxInitialDepth != null && (maxDepth == null || maxInitialDepth < maxDepth)) {
    this.maxDepth=maxInitialDepth;
  }
 else {
    this.maxDepth=(maxDepth == null) ? -1 : maxDepth;
  }
}",0.9749776586237712
180615,"/** 
 * Constructs a <tt>GrowInitialisation</tt> with control parameters  initially loaded from the config. If the <tt>autoConfig</tt> argument is  set to <tt>true</tt> then the configuration will be automatically updated when the config is modified.
 * @param autoConfig whether this operator should automatically update itsconfiguration settings from the config
 */
public GrowInitialisation(boolean autoConfig){
  setup();
  if (autoConfig) {
    EventManager.getInstance().add(ConfigEvent.class,this);
  }
}","/** 
 * Constructs a <tt>GrowInitialisation</tt> with control parameters  initially loaded from the config. If the <tt>autoConfig</tt> argument is  set to <tt>true</tt> then the configuration will be automatically updated when the config is modified.
 * @param autoConfig whether this operator should automatically update itsconfiguration settings from the config
 */
public GrowInitialisation(boolean autoConfig){
  setup();
  updateSyntax();
  if (autoConfig) {
    EventManager.getInstance().add(ConfigEvent.class,this);
  }
}",0.9826923076923076
180616,"/** 
 * Attempts to parse the given string as a number, and wraps it in a new <code>Literal</code> instance that is returned. If unable to parse the  given string as a number, then this method will return <code>null</code>. <p>The string will be parsed as follows: <ul> <li>If the string contains a numeric value (with or without decimal)  followed by a 'd' or 'D' character, then the literal will have a Double value.</li> <li>If the string contains a numeric value (with or without decimal)  followed by an 'f' or 'F' character, then the literal will have a Float value.</li> <li>If the string contains a numeric value followed by an 'l' or 'L'  character, or if the value is an integer value out of range of the Java int type, then the literal will have a Long value.</li> <li>If the string contains an integer value in range of the Java int type then the literal will have an Integer value.</li> </ul>
 * @param numericStr a string containing a numeric value to be parsed as a <code>Literal</code>.
 * @return a new <code>Literal</code> with a numeric value. Or <code>null</code> if the given <code>numericStr</code> could not be  parsed as a numeric value.
 */
protected Literal parseNumericLiteral(String numericStr){
  Literal literal=null;
  final Number n=NumberFormat.getInstance().parse(numericStr,new ParsePosition(0));
  if (n instanceof Long) {
    if (numericStr.endsWith(""String_Node_Str"") || numericStr.endsWith(""String_Node_Str"")) {
      literal=new Literal(n.doubleValue());
    }
 else     if (numericStr.endsWith(""String_Node_Str"") || numericStr.endsWith(""String_Node_Str"")) {
      literal=new Literal(n.floatValue());
    }
 else     if (!numericStr.endsWith(""String_Node_Str"") && !numericStr.endsWith(""String_Node_Str"")) {
      long longValue=n.longValue();
      if ((longValue <= Integer.MAX_VALUE) && (longValue >= Integer.MIN_VALUE)) {
        literal=new Literal(n.intValue());
      }
    }
  }
 else   if (n instanceof Double) {
    if (numericStr.endsWith(""String_Node_Str"") || numericStr.endsWith(""String_Node_Str"")) {
      literal=new Literal(n.floatValue());
    }
  }
  if ((literal == null) && (n != null)) {
    literal=new Literal(n);
  }
  return literal;
}","/** 
 * Attempts to parse the given string as a number, and wraps it in a new <code>Literal</code> instance that is returned. If unable to parse the  given string as a number, then this method will return <code>null</code>. <p>The string will be parsed as follows: <ul> <li>If the string contains a numeric value (with or without decimal)  followed by a 'd' or 'D' character, then the literal will have a Double value.</li> <li>If the string contains a numeric value (with or without decimal)  followed by an 'f' or 'F' character, then the literal will have a Float value.</li> <li>If the string contains a numeric value followed by an 'l' or 'L'  character, or if the value is an integer value out of range of the Java int type, then the literal will have a Long value.</li> <li>If the string contains an integer value in range of the Java int type then the literal will have an Integer value.</li> </ul>
 * @param numericStr a string containing a numeric value to be parsed as a <code>Literal</code>.
 * @return a new <code>Literal</code> with a numeric value. Or <code>null</code> if the given <code>numericStr</code> could not be  parsed as a numeric value.
 */
protected Literal parseNumericLiteral(String numericStr){
  Literal literal=null;
  final Number n=NumberFormat.getInstance().parse(numericStr,new ParsePosition(0));
  if (n instanceof Long) {
    if (numericStr.endsWith(""String_Node_Str"") || numericStr.endsWith(""String_Node_Str"")) {
      literal=new Literal(n.floatValue());
    }
 else     if (numericStr.endsWith(""String_Node_Str"") || numericStr.endsWith(""String_Node_Str"") || numericStr.contains(""String_Node_Str"")) {
      literal=new Literal(n.doubleValue());
    }
 else     if (!numericStr.endsWith(""String_Node_Str"") && !numericStr.endsWith(""String_Node_Str"")) {
      long longValue=n.longValue();
      if ((longValue <= Integer.MAX_VALUE) && (longValue >= Integer.MIN_VALUE)) {
        literal=new Literal(n.intValue());
      }
    }
  }
 else   if (n instanceof Double) {
    if (numericStr.endsWith(""String_Node_Str"") || numericStr.endsWith(""String_Node_Str"")) {
      literal=new Literal(n.floatValue());
    }
  }
  if ((literal == null) && (n != null)) {
    literal=new Literal(n);
  }
  return literal;
}",0.9855920756416028
180617,"/** 
 * Returns the life cycle manager for all models undergoing evolution.
 * @return the Life instance that is managing life cycle events for the models undergoing evolution.
 */
public Life getLife(){
  return null;
}","/** 
 * Returns the life cycle manager for all models undergoing evolution.
 * @return the Life instance that is managing life cycle events for the models undergoing evolution.
 */
public Life getLife(){
  return life;
}",0.9818181818181818
180618,"/** 
 * Adds the given model to the end of the queue of models to be executed.
 * @param model a model to be executed.
 */
public void enqueue(Model model){
  models.add(model);
}","/** 
 * Adds the given model to the end of the queue of models to be executed.
 * @param model a model to be executed.
 */
public void enqueue(Model model){
  models.add(model);
  stats.put(model,new Stats(model,life));
}",0.895
180619,"@Override public int compare(T o1,T o2){
  double fitness1=evaluator.getFitness(o1);
  double fitness2=evaluator.getFitness(o2);
  if (fitness1 > fitness2) {
    return -1;
  }
 else   if (fitness1 == fitness2) {
    return 0;
  }
 else {
    return 1;
  }
}","@Override public int compare(T o1,T o2){
  double fitness1=evaluator.getFitness(o1);
  double fitness2=evaluator.getFitness(o2);
  if (fitness1 > fitness2) {
    return reverse ? 1 : -1;
  }
 else   if (fitness1 == fitness2) {
    return 0;
  }
 else {
    return reverse ? -1 : 1;
  }
}",0.9174311926605504
180620,"public FitnessComparator(FitnessEvaluator<T> evaluator){
  this.evaluator=evaluator;
}","public FitnessComparator(FitnessEvaluator<T> evaluator,boolean reverse){
  this.evaluator=evaluator;
  this.reverse=reverse;
}",0.8113207547169812
180621,"@Override public void setSelectionPool(final List<CandidateProgram> pool){
  if ((pool == null) || pool.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.pool=pool;
  if (overSelection) {
    Collections.sort(pool,Collections.reverseOrder());
  }
  overSelectionProportion=getOverSelectionProportion(pool.size());
  final double[] adjusted=new double[pool.size()];
  double adjustedSum=0.0;
  for (int i=0; i < adjusted.length; i++) {
    final double adjustedFitness=fitnessEvaluator.getFitness(pool.get(i));
    adjusted[i]=adjustedFitness;
    adjustedSum+=adjustedFitness;
  }
  normalised=new double[pool.size()];
  double normalisedSum=0.0;
  for (int i=0; i < normalised.length; i++) {
    normalisedSum+=(adjusted[i] / adjustedSum);
    normalised[i]=normalisedSum;
  }
  normalised[normalised.length - 1]=1.0;
}","@Override public void setSelectionPool(final List<CandidateProgram> pool){
  if ((pool == null) || pool.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.pool=pool;
  if (overSelection) {
    Collections.sort(pool,new FitnessComparator(fitnessEvaluator,false));
  }
  overSelectionProportion=getOverSelectionProportion(pool.size());
  final double[] adjusted=new double[pool.size()];
  double adjustedSum=0.0;
  for (int i=0; i < adjusted.length; i++) {
    final double adjustedFitness=fitnessEvaluator.getFitness(pool.get(i));
    adjusted[i]=adjustedFitness;
    adjustedSum+=adjustedFitness;
  }
  normalised=new double[pool.size()];
  double normalisedSum=0.0;
  for (int i=0; i < normalised.length; i++) {
    normalisedSum+=(adjusted[i] / adjustedSum);
    normalised[i]=normalisedSum;
  }
  normalised[normalised.length - 1]=1.0;
}",0.9643059490084984
180622,"/** 
 * Tests Santa Fe trail with standard setup. Expecting success rate between % and %.
 */
@Test public void testSantaFeTrail(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  final AntTrail model=new SantaFeTrail(getEvolver(),600);
  setupModel(model);
  int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests Santa Fe trail with standard setup. Expecting success rate between % and %.
 */
@Test public void testSantaFeTrail(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  final AntTrail model=new SantaFeTrail(getEvolver(),600);
  setupModel(model);
  int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9846153846153848
180623,"/** 
 * Tests even 3 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven3Parity(){
  final int LOWER_SUCCESS=99;
  final int UPPER_SUCCESS=100;
  final EvenParity model=new EvenParity(getEvolver(),3);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests even 3 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven3Parity(){
  final int LOWER_SUCCESS=99;
  final int UPPER_SUCCESS=100;
  final EvenParity model=new EvenParity(getEvolver(),3);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9848101265822784
180624,"/** 
 * Tests standard setup except: - Program selector of TournamentSelector (size 7) Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityTournament7Selection(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new TournamentSelector(evolver,7));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Program selector of TournamentSelector (size 7) Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityTournament7Selection(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new TournamentSelector(evolver,7));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.989010989010989
180625,"/** 
 * Tests even 5 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven5Parity(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  final EvenParity model=new EvenParity(getEvolver(),5);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests even 5 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven5Parity(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  final EvenParity model=new EvenParity(getEvolver(),5);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9846938775510204
180626,"/** 
 * Tests standard setup except: - Crossover operator of OnePointCrossover Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityOnePointCrossover(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setCrossover(new OnePointCrossover(evolver));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Crossover operator of OnePointCrossover Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityOnePointCrossover(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setCrossover(new OnePointCrossover(evolver));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.988593155893536
180627,"/** 
 * Tests standard setup except: - Program selector of LinearRankSelector Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityLinearRankSelection(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new LinearRankSelector(evolver));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Program selector of LinearRankSelector Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityLinearRankSelection(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new LinearRankSelector(evolver));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9887640449438202
180628,"/** 
 * Tests standard setup except: - Mutation operator of SinglePointMutation Expecting success rate between % and %.
 */
@Test public void testEven4ParitySinglePointMutation(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setMutation(new SinglePointMutation(evolver));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Mutation operator of SinglePointMutation Expecting success rate between % and %.
 */
@Test public void testEven4ParitySinglePointMutation(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setMutation(new SinglePointMutation(evolver));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.988593155893536
180629,"/** 
 * Tests even 4 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven4Parity(){
  final int LOWER_SUCCESS=40;
  final int UPPER_SUCCESS=50;
  final EvenParity model=new EvenParity(getEvolver(),4);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests even 4 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven4Parity(){
  final int LOWER_SUCCESS=40;
  final int UPPER_SUCCESS=50;
  final EvenParity model=new EvenParity(getEvolver(),4);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9847715736040608
180630,"/** 
 * Tests 11-bit multiplexer with standard setup except: - Population size of 4000 - Program selector of FitnessProportionateSelector with over-selection Expecting success rate between % and %.
 */
@Test public void testMultiplexer11Bit(){
  final int LOWER_SUCCESS=35;
  final int UPPER_SUCCESS=45;
  Evolver evolver=getEvolver();
  final Multiplexer model=new Multiplexer(evolver,11);
  setupModel(model);
  model.setProgramSelector(new FitnessProportionateSelector(evolver));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests 11-bit multiplexer with standard setup except: - Population size of 4000 - Program selector of FitnessProportionateSelector with over-selection Expecting success rate between % and %.
 */
@Test public void testMultiplexer11Bit(){
  final int LOWER_SUCCESS=35;
  final int UPPER_SUCCESS=45;
  Evolver evolver=getEvolver();
  final Multiplexer model=new Multiplexer(evolver,11);
  setupModel(model);
  model.setProgramSelector(new FitnessProportionateSelector(evolver));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9901477832512317
180631,"/** 
 * Tests 6-bit multiplexer with standard setup. Expecting success rate between % and %.
 */
@Test public void testMultiplexer6Bit(){
  final int LOWER_SUCCESS=37;
  final int UPPER_SUCCESS=47;
  final Multiplexer model=new Multiplexer(getEvolver(),6);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests 6-bit multiplexer with standard setup. Expecting success rate between % and %.
 */
@Test public void testMultiplexer6Bit(){
  final int LOWER_SUCCESS=37;
  final int UPPER_SUCCESS=47;
  final Multiplexer model=new Multiplexer(getEvolver(),6);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9851485148514852
180632,"/** 
 * Tests quartic symbolic regression with standard setup. Expecting success rate between % and %.
 */
@Test public void testQuartic(){
  final int LOWER_SUCCESS=45;
  final int UPPER_SUCCESS=55;
  final QuarticRegression model=new QuarticRegression(getEvolver(),20);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests quartic symbolic regression with standard setup. Expecting success rate between % and %.
 */
@Test public void testQuartic(){
  final int LOWER_SUCCESS=45;
  final int UPPER_SUCCESS=55;
  final QuarticRegression model=new QuarticRegression(getEvolver(),20);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9856801909307876
180633,"/** 
 * Tests Santa Fe trail with standard setup. Koza's success rate: 16% (p202). OR: 14%/50%/46% with full/grow/RH+H (p599). Expecting success rate between 12% and 20%.
 */
@Test public void testSantaFeTrail(){
  final int LOWER_SUCCESS=12;
  final int UPPER_SUCCESS=20;
  final SantaFeTrail model=new SantaFeTrail(getEvolver(),600);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests Santa Fe trail with standard setup. Koza's success rate: 16% (p202). OR: 14%/50%/46% with full/grow/RH+H (p599). Expecting success rate between 12% and 20%.
 */
@Test public void testSantaFeTrail(){
  final int LOWER_SUCCESS=12;
  final int UPPER_SUCCESS=20;
  final SantaFeTrail model=new SantaFeTrail(getEvolver(),600);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9875776397515528
180634,"/** 
 * Tests even 3 parity with standard setup. Koza's success rate: 100% (p531). Expecting success rate between 99% and 100%.
 */
@Test public void testEven3Parity(){
  final int LOWER_SUCCESS=99;
  final int UPPER_SUCCESS=100;
  final EvenParity model=new EvenParity(getEvolver(),3);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests even 3 parity with standard setup. Koza's success rate: 100% (p531). Expecting success rate between 99% and 100%.
 */
@Test public void testEven3Parity(){
  final int LOWER_SUCCESS=99;
  final int UPPER_SUCCESS=100;
  final EvenParity model=new EvenParity(getEvolver(),3);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,true);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9873125720876584
180635,"/** 
 * Tests standard setup except: - Program selector of TournamentSelector (size 7) Expecting success rate between 90% and 100%.
 */
@Test public void testEven4ParityTournament7Selection(){
  final int LOWER_SUCCESS=90;
  final int UPPER_SUCCESS=100;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new TournamentSelector(evolver,7));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Program selector of TournamentSelector (size 7) Expecting success rate between 90% and 100%.
 */
@Test public void testEven4ParityTournament7Selection(){
  final int LOWER_SUCCESS=90;
  final int UPPER_SUCCESS=100;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new TournamentSelector(evolver,7));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9890510948905108
180636,"private void setupModel(final EvenParity model){
  Evolver evolver=getEvolver();
  model.setNoRuns(100);
  model.setPopulationSize(4000);
  model.setNoGenerations(51);
  model.setCrossoverProbability(0.9);
  model.setMutationProbability(0.0);
  model.setReproductionProbability(0.1);
  model.setCrossover(new KozaCrossover(evolver));
  model.setMaxDepth(16);
  model.setMaxInitialDepth(5);
  model.setInitialiser(new RampedHalfAndHalfInitialiser(evolver,1,false));
  model.setPoolSelector(null);
  model.setProgramSelector(new FitnessProportionateSelector(evolver,true));
  model.setNoElites(0);
  model.setTerminationFitness(0.0);
}","private void setupModel(final EvenParity model){
  Evolver evolver=getEvolver();
  model.setNoRuns(100);
  model.setPopulationSize(4000);
  model.setNoGenerations(51);
  model.setCrossoverProbability(0.9);
  model.setMutationProbability(0.0);
  model.setReproductionProbability(0.1);
  model.setCrossover(new KozaCrossover(evolver));
  model.setMaxDepth(16);
  model.setMaxInitialDepth(5);
  model.setInitialiser(new RampedHalfAndHalfInitialiser(evolver,1,false));
  model.setPoolSelector(null);
  model.setProgramSelector(new FitnessProportionateSelector(evolver,true));
  model.setNoElites(1);
  model.setTerminationFitness(0.0);
}",0.9984202211690364
180637,"/** 
 * Tests standard setup except: - Reproduction probability of 0.0 - Mutation probability of 0.1 - Mutation operator of PointMutation Expecting success rate between 90% and 100%.
 */
@Test public void testEven4ParityPointMutation(){
  final int LOWER_SUCCESS=90;
  final int UPPER_SUCCESS=100;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setMutationProbability(0.1);
  model.setReproductionProbability(0.0);
  model.setMutation(new PointMutation(evolver));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Reproduction probability of 0.0 - Mutation probability of 0.1 - Mutation operator of PointMutation Expecting success rate between 90% and 100%.
 */
@Test public void testEven4ParityPointMutation(){
  final int LOWER_SUCCESS=90;
  final int UPPER_SUCCESS=100;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setMutationProbability(0.1);
  model.setReproductionProbability(0.0);
  model.setMutation(new PointMutation(evolver));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9908536585365854
180638,"/** 
 * Tests even 5 parity with standard setup. Expecting success rate between 70% and 80%.
 */
@Test public void testEven5Parity(){
  final int LOWER_SUCCESS=70;
  final int UPPER_SUCCESS=80;
  final EvenParity model=new EvenParity(getEvolver(),5);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests even 5 parity with standard setup. Expecting success rate between 70% and 80%.
 */
@Test public void testEven5Parity(){
  final int LOWER_SUCCESS=70;
  final int UPPER_SUCCESS=80;
  final EvenParity model=new EvenParity(getEvolver(),5);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.984924623115578
180639,"/** 
 * Tests standard setup except: - Crossover operator of SubtreeCrossover Expecting success rate between 70% and 80%.
 */
@Test public void testEven4ParitySubtreeCrossover(){
  final int LOWER_SUCCESS=70;
  final int UPPER_SUCCESS=80;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setCrossover(new SubtreeCrossover(evolver));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Crossover operator of SubtreeCrossover Expecting success rate between 70% and 80%.
 */
@Test public void testEven4ParitySubtreeCrossover(){
  final int LOWER_SUCCESS=70;
  final int UPPER_SUCCESS=80;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setCrossover(new SubtreeCrossover(evolver));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.988527724665392
180640,"/** 
 * Tests standard setup except: - Crossover operator of OnePointCrossover - Mutation operator of SubtreeMutation (because one-point crossover needs mutation). - Reproduction probability of 0.0 - Mutation probability of 0.3 - Crossover probability of 0.7 - Program selector of TournamentSelector 7. Expecting success rate between 10% and 20%.
 */
@Test public void testEven4ParityOnePointCrossover(){
  final int LOWER_SUCCESS=10;
  final int UPPER_SUCCESS=20;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setCrossover(new OnePointCrossover(evolver));
  model.setMutation(new SubtreeMutation(evolver));
  model.setProgramSelector(new TournamentSelector(evolver,7));
  model.setMutationProbability(0.3);
  model.setReproductionProbability(0.0);
  model.setCrossoverProbability(0.7);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Crossover operator of OnePointCrossover - Mutation operator of SubtreeMutation (because one-point crossover needs mutation). - Reproduction probability of 0.0 - Mutation probability of 0.3 - Crossover probability of 0.7 - Program selector of TournamentSelector 7. Expecting success rate between 10% and 20%.
 */
@Test public void testEven4ParityOnePointCrossover(){
  final int LOWER_SUCCESS=10;
  final int UPPER_SUCCESS=20;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setCrossover(new OnePointCrossover(evolver));
  model.setMutation(new SubtreeMutation(evolver));
  model.setProgramSelector(new TournamentSelector(evolver,7));
  model.setMutationProbability(0.3);
  model.setReproductionProbability(0.0);
  model.setCrossoverProbability(0.7);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9938775510204082
180641,"/** 
 * Tests standard setup except: - Program selector of LinearRankSelector Expecting success rate between 0% and 0%.
 */
@Test public void testEven4ParityLinearRankSelection(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new LinearRankSelector(evolver));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Program selector of LinearRankSelector Expecting success rate between 0% and 0%.
 */
@Test public void testEven4ParityLinearRankSelection(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new LinearRankSelector(evolver));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9886792452830188
180642,"/** 
 * Tests even 4 parity with standard setup. Koza's success rate: 45% (p531). Expecting success rate between 85% and 95%.
 */
@Test public void testEven4Parity(){
  final int LOWER_SUCCESS=85;
  final int UPPER_SUCCESS=95;
  final EvenParity model=new EvenParity(getEvolver(),4);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests even 4 parity with standard setup. Koza's success rate: 45% (p531). Expecting success rate between 85% and 95%.
 */
@Test public void testEven4Parity(){
  final int LOWER_SUCCESS=85;
  final int UPPER_SUCCESS=95;
  final EvenParity model=new EvenParity(getEvolver(),4);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,true);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9872241579558652
180643,"/** 
 * Tests standard setup except: - Reproduction probability of 0.0 - Mutation probability of 0.1 - Mutation operator of SubtreeMutation Expecting success rate between 85% and 95%.
 */
@Test public void testEven4ParitySubtreeMutation(){
  final int LOWER_SUCCESS=85;
  final int UPPER_SUCCESS=95;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setMutationProbability(0.1);
  model.setReproductionProbability(0.0);
  model.setMutation(new SubtreeMutation(evolver));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Reproduction probability of 0.0 - Mutation probability of 0.1 - Mutation operator of SubtreeMutation Expecting success rate between 85% and 95%.
 */
@Test public void testEven4ParitySubtreeMutation(){
  final int LOWER_SUCCESS=85;
  final int UPPER_SUCCESS=95;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setMutationProbability(0.1);
  model.setReproductionProbability(0.0);
  model.setMutation(new SubtreeMutation(evolver));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.990909090909091
180644,"/** 
 * Tests 11-bit multiplexer with standard setup except: - Population size of 4000 - Program selector of FitnessProportionateSelector with over-selection Expecting success rate between 90% and 100%.
 */
@Test public void testMultiplexer11Bit(){
  final int LOWER_SUCCESS=90;
  final int UPPER_SUCCESS=100;
  Evolver evolver=getEvolver();
  final Multiplexer model=new Multiplexer(evolver,11);
  setupModel(model);
  model.setPopulationSize(4000);
  model.setProgramSelector(new FitnessProportionateSelector(evolver,true));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests 11-bit multiplexer with standard setup except: - Population size of 4000 - Program selector of FitnessProportionateSelector with over-selection Expecting success rate between 90% and 100%.
 */
@Test public void testMultiplexer11Bit(){
  final int LOWER_SUCCESS=90;
  final int UPPER_SUCCESS=100;
  Evolver evolver=getEvolver();
  final Multiplexer model=new Multiplexer(evolver,11);
  setupModel(model);
  model.setPopulationSize(4000);
  model.setProgramSelector(new FitnessProportionateSelector(evolver,true));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.990811638591118
180645,"/** 
 * Tests 6-bit multiplexer with standard setup. Koza's success rate: 63% (p572). OR: 28% (p195). Expecting success rate between 37% and 47%.
 */
@Test public void testMultiplexer6Bit(){
  final int LOWER_SUCCESS=37;
  final int UPPER_SUCCESS=47;
  final Multiplexer model=new Multiplexer(getEvolver(),6);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests 6-bit multiplexer with standard setup. Koza's success rate: 63% (p572). OR: 28% (p195). Expecting success rate between 37% and 47%.
 */
@Test public void testMultiplexer6Bit(){
  final int LOWER_SUCCESS=37;
  final int UPPER_SUCCESS=47;
  final Multiplexer model=new Multiplexer(getEvolver(),6);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.986870897155361
180646,"/** 
 * Tests quartic symbolic regression with standard setup. Koza's success rate: 23% (p586). OR 35% (p203). Expecting success rate between 45% and 55%.
 */
@Test public void testQuartic(){
  final int LOWER_SUCCESS=45;
  final int UPPER_SUCCESS=55;
  final QuarticRegression model=new QuarticRegression(getEvolver(),20);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests quartic symbolic regression with standard setup. Koza's success rate: 23% (p586). OR 35% (p203). Expecting success rate between 45% and 55%.
 */
@Test public void testQuartic(){
  final int LOWER_SUCCESS=45;
  final int UPPER_SUCCESS=55;
  final QuarticRegression model=new QuarticRegression(getEvolver(),20);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9872611464968152
180647,"/** 
 * Tests Santa Fe trail with standard setup. Expecting success rate between % and %.
 */
@Test public void testSantaFeTrail(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  final AntTrail model=new SantaFeTrail(getEvolver(),600);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests Santa Fe trail with standard setup. Expecting success rate between % and %.
 */
@Test public void testSantaFeTrail(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  final AntTrail model=new SantaFeTrail(getEvolver(),600);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9848484848484848
180648,"/** 
 * Tests even 3 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven3Parity(){
  final int LOWER_SUCCESS=99;
  final int UPPER_SUCCESS=100;
  final EvenParity model=new EvenParity(getEvolver(),3);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests even 3 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven3Parity(){
  final int LOWER_SUCCESS=99;
  final int UPPER_SUCCESS=100;
  final EvenParity model=new EvenParity(getEvolver(),3);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9848101265822784
180649,"/** 
 * Tests standard setup except: - Program selector of TournamentSelector (size 7) Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityTournament7Selection(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new TournamentSelector(evolver,7));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Program selector of TournamentSelector (size 7) Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityTournament7Selection(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new TournamentSelector(evolver,7));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.989010989010989
180650,"/** 
 * Tests even 5 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven5Parity(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  final EvenParity model=new EvenParity(getEvolver(),5);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests even 5 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven5Parity(){
  final int LOWER_SUCCESS=0;
  final int UPPER_SUCCESS=0;
  final EvenParity model=new EvenParity(getEvolver(),5);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9846938775510204
180651,"/** 
 * Tests standard setup except: - Program selector of LinearRankSelector Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityLinearRankSelection(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new LinearRankSelector(evolver));
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests standard setup except: - Program selector of LinearRankSelector Expecting success rate between 40% and 50%.
 */
@Test public void testEven4ParityLinearRankSelection(){
  final int LOWER_SUCCESS=50;
  final int UPPER_SUCCESS=50;
  Evolver evolver=getEvolver();
  final EvenParity model=new EvenParity(evolver,4);
  setupModel(model);
  model.setProgramSelector(new LinearRankSelector(evolver));
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9887640449438202
180652,"/** 
 * Tests even 4 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven4Parity(){
  final int LOWER_SUCCESS=40;
  final int UPPER_SUCCESS=50;
  final EvenParity model=new EvenParity(getEvolver(),4);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}","/** 
 * Tests even 4 parity with standard setup. Expecting success rate between % and %.
 */
@Test public void testEven4Parity(){
  final int LOWER_SUCCESS=40;
  final int UPPER_SUCCESS=50;
  final EvenParity model=new EvenParity(getEvolver(),4);
  setupModel(model);
  final int noSuccess=getNoSuccesses(model,false,false);
  assertBetween(""String_Node_Str"",LOWER_SUCCESS,UPPER_SUCCESS,noSuccess);
}",0.9847715736040608
180653,"/** 
 * Returns true if the given collection contains an element which represents a class which is the same as or is a sub type of the given class.
 * @param collection the collection to seach for a class that is assignablefrom amongst.
 * @param cls the class that is being searched against the given collection.
 * @return true if the given collection contains a Class which is the sameas or a subtype of the given class parameter. It returns false otherwise.
 */
public static boolean containsSub(final Class<?>[] collection,final Class<?> cls){
  for (  final Class<?> c : collection) {
    if (ClassUtils.isAssignable(cls,c)) {
      return true;
    }
  }
  return false;
}","/** 
 * Returns true if the given collection contains an element which represents a class which is the same as or is a sub type of the given class.
 * @param collection the collection to seach for a class that is assignablefrom amongst.
 * @param cls the class that is being searched against the given collection.
 * @return true if the given collection contains a Class which is the sameas or a subtype of the given class parameter. It returns false otherwise.
 */
public static boolean containsSub(final Class<?>[] collection,final Class<?> cls){
  for (  final Class<?> c : collection) {
    if (ClassUtils.isAssignable(c,cls)) {
      return true;
    }
  }
  return false;
}",0.9970544918998528
180654,"public static boolean containsSuper(final Class<?>[] collection,final Class<?> cls){
  for (  final Class<?> c : collection) {
    if (ClassUtils.isAssignable(c,cls)) {
      return true;
    }
  }
  return false;
}","public static boolean containsSuper(final Class<?>[] collection,final Class<?> cls){
  for (  final Class<?> c : collection) {
    if (ClassUtils.isAssignable(cls,c)) {
      return true;
    }
  }
  return false;
}",0.9906976744186048
180655,"/** 
 * Returns whichever class is the super class of the other, or null if neither are a super class of the other.
 * @return
 */
public static Class<?> getSuper(final boolean autobox,final Class<?>... classes){
  outer:   for (  final Class<?> cls1 : classes) {
    for (    final Class<?> cls2 : classes) {
      if (!ClassUtils.isAssignable(cls2,cls2,autobox)) {
        continue outer;
      }
    }
    return cls1;
  }
  return null;
}","/** 
 * Returns whichever class is the super class of the other, or null if neither are a super class of the other.
 * @return
 */
public static Class<?> getSuper(final boolean autobox,final Class<?>... classes){
  outer:   for (  final Class<?> cls1 : classes) {
    for (    final Class<?> cls2 : classes) {
      if (!ClassUtils.isAssignable(cls2,cls1,autobox)) {
        continue outer;
      }
    }
    return cls1;
  }
  return null;
}",0.997737556561086
180656,"public static boolean allSub(final Class<?>[] collection,final Class<?> cls){
  for (  final Class<?> c : collection) {
    if (!ClassUtils.isAssignable(cls,c)) {
      return false;
    }
  }
  return true;
}","public static boolean allSub(final Class<?>[] collection,final Class<?> cls){
  for (  final Class<?> c : collection) {
    if (!ClassUtils.isAssignable(c,cls)) {
      return false;
    }
  }
  return true;
}",0.9904306220095692
180657,"public static boolean allSuper(final Class<?>[] collection,final Class<?> cls){
  for (  final Class<?> c : collection) {
    if (!ClassUtils.isAssignable(c,cls)) {
      return false;
    }
  }
  return true;
}","public static boolean allSuper(final Class<?>[] collection,final Class<?> cls){
  for (  final Class<?> c : collection) {
    if (!ClassUtils.isAssignable(cls,c)) {
      return false;
    }
  }
  return true;
}",0.990521327014218
180658,"private Node getNodeTree(Class<?> requiredType,int currentDepth){
  List<Node> validNodes=getValidNodes(depth - currentDepth,requiredType);
  if (validNodes.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final int randomIndex=rng.nextInt(validNodes.size());
  Node root=validNodes.get(randomIndex).newInstance();
  int arity=root.getArity();
  if (arity > 0) {
    Class<?>[][] argTypeSets=getPossibleArgTypes(arity,validDepthTypes[depth - currentDepth]);
    List<Class<?>[]> validArgTypeSets=new ArrayList<Class<?>[]>();
    for (    Class<?>[] argTypes : argTypeSets) {
      Class<?> type=root.getReturnType(argTypes);
      if (type != null && requiredType.isAssignableFrom(type)) {
        validArgTypeSets.add(argTypes);
      }
    }
    if (validArgTypeSets.isEmpty()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    Class<?>[] argTypes=validArgTypeSets.get(rng.nextInt(validArgTypeSets.size()));
    for (int i=0; i < arity; i++) {
      root.setChild(i,getNodeTree(argTypes[i],currentDepth + 1));
    }
  }
  return root;
}","private Node getNodeTree(Class<?> requiredType,int currentDepth){
  List<Node> validNodes=getValidNodes(depth - currentDepth,requiredType);
  if (validNodes.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final int randomIndex=rng.nextInt(validNodes.size());
  Node root=validNodes.get(randomIndex).newInstance();
  int arity=root.getArity();
  if (arity > 0) {
    Class<?>[][] argTypeSets=getPossibleArgTypes(arity,validDepthTypes[depth - currentDepth - 1]);
    List<Class<?>[]> validArgTypeSets=new ArrayList<Class<?>[]>();
    for (    Class<?>[] argTypes : argTypeSets) {
      Class<?> type=root.getReturnType(argTypes);
      if (type != null && requiredType.isAssignableFrom(type)) {
        validArgTypeSets.add(argTypes);
      }
    }
    if (validArgTypeSets.isEmpty()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    Class<?>[] argTypes=validArgTypeSets.get(rng.nextInt(validArgTypeSets.size()));
    for (int i=0; i < arity; i++) {
      root.setChild(i,getNodeTree(argTypes[i],currentDepth + 1));
    }
  }
  return root;
}",0.998158379373849
180659,"/** 
 * Builds a grown node tree with a maximum depth as given. The nodes that form the tree will be randomly selected from the nodes provided as the syntax attribute.
 * @param maxDepth The maximum depth of the node tree to be grown, wherethe depth is the number of nodes from the root.
 * @return The root node of a randomly generated node tree.
 */
public Node getGrownNodeTree(final int maxDepth){
  if (rng == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else   if (maxDepth < 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else   if (terminals.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final int randomIndex=rng.nextInt(syntax.size());
  final Node root=syntax.get(randomIndex).clone();
  this.fillChildren(root,0,maxDepth);
  return root;
}","/** 
 * Builds a grown node tree with a maximum depth as given. The nodes that form the tree will be randomly selected from the nodes provided as the syntax attribute.
 * @param maxDepth The maximum depth of the node tree to be grown, wherethe depth is the number of nodes from the root.
 * @return The root node of a randomly generated node tree.
 */
public Node getGrownNodeTree(final int maxDepth){
  if (rng == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else   if (maxDepth < 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else   if (terminals.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Node root;
  if (maxDepth == 0) {
    final int randomIndex=rng.nextInt(terminals.size());
    root=terminals.get(randomIndex).clone();
  }
 else {
    final int randomIndex=rng.nextInt(syntax.size());
    root=syntax.get(randomIndex).clone();
    this.fillChildren(root,0,maxDepth);
  }
  return root;
}",0.905849582172702
180660,"public Node parse(final String source) throws MalformedProgramException {
  if (source == null) {
    return null;
  }
  final int openingBracket=source.indexOf('(');
  String identifier=null;
  List<String> args=null;
  if (openingBracket == -1) {
    identifier=source;
    args=new ArrayList<String>();
  }
 else {
    identifier=source.substring(0,openingBracket);
    final int closingBracket=source.lastIndexOf(')');
    final String argumentStr=source.substring(openingBracket + 1,closingBracket);
    args=splitArguments(argumentStr);
  }
  Node node=initialiseFunction(identifier);
  if (node == null) {
    node=parseTerminal(identifier);
  }
  if ((node == null) || (node.getArity() != args.size())) {
    throw new MalformedProgramException();
  }
 else {
    for (int i=0; i < args.size(); i++) {
      node.setChild(i,parse(args.get(i)));
    }
  }
  return node;
}","public Node parse(final String source) throws MalformedProgramException {
  if (source == null) {
    return null;
  }
  final int openingBracket=source.indexOf('(');
  String identifier=null;
  List<String> args=null;
  boolean terminal=false;
  if (openingBracket == -1) {
    identifier=source;
    args=new ArrayList<String>();
    terminal=true;
  }
 else {
    identifier=source.substring(0,openingBracket);
    final int closingBracket=source.lastIndexOf(')');
    final String argumentStr=source.substring(openingBracket + 1,closingBracket);
    args=splitArguments(argumentStr);
  }
  Node node;
  if (terminal) {
    node=parseTerminal(identifier);
  }
 else {
    node=initialiseFunction(identifier);
  }
  if ((node == null) || (node.getArity() != args.size())) {
    throw new MalformedProgramException();
  }
 else {
    for (int i=0; i < args.size(); i++) {
      node.setChild(i,parse(args.get(i)));
    }
  }
  return node;
}",0.9017023613399232
180661,"/** 
 * Compare an object for equality. If the given object is a Node then it may be equal if each Node in the tree is equal. Equality of individual Nodes is dependant on the specific node type but typically will be whether they are the same type and have the same children for function nodes and whether they have the same value or are the same variable for terminal nodes.
 * @param obj an object to be compared for equivalence.
 * @return true if this node tree is the same as the obj argument;false otherwise.
 */
@Override public boolean equals(final Object obj){
  boolean equal=true;
  if (obj instanceof Node) {
    final Node n=(Node)obj;
    if (n.getArity() != this.getArity()) {
      equal=false;
    }
 else     if (n.getIdentifier() != this.getIdentifier()) {
      equal=false;
    }
 else {
      for (int i=0; (i < n.getArity()) && equal; i++) {
        final Node thatChild=n.getChild(i);
        final Node thisChild=this.getChild(i);
        if ((thisChild != null) ^ (thatChild != null)) {
          equal=false;
        }
 else {
          equal=(((thisChild == null) && (thatChild == null)) || thisChild.equals(thatChild));
        }
      }
    }
  }
 else {
    equal=false;
  }
  return equal;
}","/** 
 * Compare an object for equality. If the given object is a Node then it may be equal if each Node in the tree is equal. Equality of individual Nodes is dependant on the specific node type but typically will be whether they are the same type and have the same children for function nodes and whether they have the same value or are the same variable for terminal nodes.
 * @param obj an object to be compared for equivalence.
 * @return true if this node tree is the same as the obj argument;false otherwise.
 */
@Override public boolean equals(final Object obj){
  boolean equal=true;
  if (obj instanceof Node) {
    final Node n=(Node)obj;
    if (n.getArity() != this.getArity()) {
      equal=false;
    }
 else     if (!this.getIdentifier().equals(n.getIdentifier())) {
      equal=false;
    }
 else {
      for (int i=0; (i < n.getArity()) && equal; i++) {
        final Node thatChild=n.getChild(i);
        final Node thisChild=this.getChild(i);
        if ((thisChild != null) ^ (thatChild != null)) {
          equal=false;
        }
 else {
          equal=(((thisChild == null) && (thatChild == null)) || thisChild.equals(thatChild));
        }
      }
    }
  }
 else {
    equal=false;
  }
  return equal;
}",0.990204081632653
180662,"/** 
 * Tests that the eval method can handle multiple simple expressions.
 */
public void testMultiEval() throws MalformedProgramException {
  final Interpreter interpreter=new EpoxInterpreter();
  String expression=""String_Node_Str"";
  String[] args={""String_Node_Str"",""String_Node_Str""};
  Object[][] values={{true,3},{false,4}};
  Object[] result=interpreter.eval(expression,args,values);
  assertEquals(""String_Node_Str"",true,result[0]);
  assertEquals(""String_Node_Str"",false,result[1]);
  expression=""String_Node_Str"";
  args=new String[]{""String_Node_Str""};
  values=new Object[][]{{1.0},{2.0}};
  result=interpreter.eval(expression,args,values);
  assertEquals(""String_Node_Str"",3.0,result[0]);
  assertEquals(""String_Node_Str"",6.0,result[1]);
}","/** 
 * Tests that the eval method can handle multiple simple expressions.
 */
public void testMultiEval() throws MalformedProgramException {
  final Interpreter interpreter=new EpoxInterpreter();
  String expression=""String_Node_Str"";
  String[] args={""String_Node_Str"",""String_Node_Str""};
  Object[][] values={{true,3.0},{false,4.0}};
  Object[] result=interpreter.eval(expression,args,values);
  assertEquals(""String_Node_Str"",true,result[0]);
  assertEquals(""String_Node_Str"",false,result[1]);
  expression=""String_Node_Str"";
  args=new String[]{""String_Node_Str""};
  values=new Object[][]{{1.0},{2.0}};
  result=interpreter.eval(expression,args,values);
  assertEquals(""String_Node_Str"",3.0,result[0]);
  assertEquals(""String_Node_Str"",6.0,result[1]);
}",0.9973544973544972
180663,"/** 
 * Evaluating a <code>ModuloFunction</code> involves dividing the evaluated first child, by the second child with the result being the remainder.
 */
@Override public Double evaluate(){
  final double c1=((Double)getChild(0).evaluate()).doubleValue();
  final double c2=((Double)getChild(1).evaluate()).doubleValue();
  return c1 % c2;
}","/** 
 * Evaluating a <code>ModuloFunction</code> involves dividing the evaluated first child, by the second child with the result being the remainder. If the second child evaluates to <code>0</code>, then the result will be  whatever the first child evaluated to.
 */
@Override public Double evaluate(){
  final double c1=((Double)getChild(0).evaluate()).doubleValue();
  final double c2=((Double)getChild(1).evaluate()).doubleValue();
  if (c2 == 0) {
    return c1;
  }
 else {
    return c1 % c2;
  }
}",0.807556080283353
180664,"/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x;
}","/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x + x * x * x* x;
}",0.9517684887459807
180665,"/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x;
}","/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x + x * x * x* x;
}",0.9517684887459807
180666,"/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x;
}","/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x + x * x * x* x;
}",0.9517684887459807
180667,"/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x;
}","/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x + x * x * x* x;
}",0.9517684887459807
180668,"/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x;
}","/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x + x * x * x* x;
}",0.9517684887459807
180669,"/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x;
}","/** 
 * The actual function we are trying to evolve.
 */
@Override public double getCorrectResult(final double x){
  return x + x * x + x * x * x + x * x * x* x;
}",0.9517684887459807
180670,"/** 
 * Calculates and returns the fitness of the given program. The fitness of a  program is calculated as the number of food pieces that the ant did not manage to reach. That is, a fitness of 0.0 means the ant found every food item.
 * @param p {@inheritDoc}
 * @return the calculated fitness for the given program.
 */
@Override public double getFitness(final CandidateProgram p){
  final GPCandidateProgram program=(GPCandidateProgram)p;
  landscape.setFoodLocations(foodLocations);
  ant.reset(allowedTimeSteps,landscape);
  while (ant.getTimesteps() < ant.getMaxMoves()) {
    program.evaluate();
  }
  return (double)(foodLocations.size() - ant.getFoodEaten());
}","/** 
 * Calculates and returns the fitness of the given program. The fitness of a  program is calculated as the number of food pieces that the ant did not manage to reach. That is, a fitness of 0.0 means the ant found every food item.
 * @param p {@inheritDoc}
 * @return the calculated fitness for the given program.
 */
@Override public double getFitness(final CandidateProgram p){
  final GPCandidateProgram program=(GPCandidateProgram)p;
  landscape.setFoodLocations(new ArrayList<Point>(foodLocations));
  ant.reset(allowedTimeSteps,landscape);
  while (ant.getTimesteps() < ant.getMaxMoves()) {
    program.evaluate();
  }
  return (double)(foodLocations.size() - ant.getFoodEaten());
}",0.9662261380323054
180671,"/** 
 * Constructs a new AntTrail with the given <code>FOOD_LOCATIONS</code> which must all be positioned at points within the given <code>landscapeSize </code>. 
 * @param FOOD_LOCATIONS the points on the landscape which will be occupied by food
 * @param landscapeSize the dimensions of the landscape that the ant will operate within
 * @param allowedTimeSteps the number of moves and turns the ant will be allowed to collect the food before timing out.
 */
public AntTrail(final Point[] foodLocations,final Dimension landscapeSize,final int allowedTimeSteps){
  this.foodLocations=new ArrayList<Point>(Arrays.asList(foodLocations));
  this.allowedTimeSteps=allowedTimeSteps;
  landscape=new AntLandscape(landscapeSize,null);
  ant=new Ant(allowedTimeSteps,landscape);
  final List<Node> syntax=new ArrayList<Node>();
  syntax.add(new IfFoodAheadFunction(ant));
  syntax.add(new Seq2Function());
  syntax.add(new Seq3Function());
  syntax.add(new AntMoveAction(ant));
  syntax.add(new AntTurnLeftAction(ant));
  syntax.add(new AntTurnRightAction(ant));
  setSyntax(syntax);
}","/** 
 * Constructs a new AntTrail with the given <code>FOOD_LOCATIONS</code> which must all be positioned at points within the given <code>landscapeSize </code>. 
 * @param FOOD_LOCATIONS the points on the landscape which will be occupied by food
 * @param landscapeSize the dimensions of the landscape that the ant will operate within
 * @param allowedTimeSteps the number of moves and turns the ant will be allowed to collect the food before timing out.
 */
public AntTrail(final Point[] foodLocations,final Dimension landscapeSize,final int allowedTimeSteps){
  this.foodLocations=Arrays.asList(foodLocations);
  this.allowedTimeSteps=allowedTimeSteps;
  landscape=new AntLandscape(landscapeSize,null);
  ant=new Ant(allowedTimeSteps,landscape);
  final List<Node> syntax=new ArrayList<Node>();
  syntax.add(new IfFoodAheadFunction(ant));
  syntax.add(new Seq2Function());
  syntax.add(new Seq3Function());
  syntax.add(new AntMoveAction(ant));
  syntax.add(new AntTurnLeftAction(ant));
  syntax.add(new AntTurnRightAction(ant));
  setSyntax(syntax);
}",0.9690431519699813
180672,"/** 
 * Overwrites the default pool size value.
 * @param poolSize the new size of the mating pool to use.
 */
public void setPoolSize(final int poolSize){
  if (poolSize >= 1) {
    this.poolSize=poolSize;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  assert(this.poolSize >= 1);
}","/** 
 * Overwrites the default pool size value.
 * @param poolSize the new size of the mating pool to use.
 */
public void setPoolSize(final int poolSize){
  if (poolSize == -1 || poolSize >= 1) {
    this.poolSize=poolSize;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  assert(this.poolSize >= 1);
}",0.9720496894409938
180673,"/** 
 * Compare an object for equality. If the given object is a Node then it  may be equal if each Node in the tree is equal. Equality of individual  Nodes is dependant on the specific node type but typically will be  whether they are the same type and have the same children for function nodes and whether they have the same value or are the same variable for  terminal nodes.
 * @param obj an object to be compared for equivalence.
 * @return true if this node tree is the same as the obj argument; false otherwise.
 */
@Override public boolean equals(Object obj){
  boolean equal=true;
  if (obj instanceof Node) {
    Node n=(Node)obj;
    if (n.getArity() != this.getArity()) {
      equal=false;
    }
    for (int i=0; i < n.getArity() && equal; i++) {
      Node thatChild=n.getChild(i);
      Node thisChild=this.getChild(i);
      if ((thisChild != null) ^ (thatChild != null)) {
        equal=false;
      }
 else {
        equal=((thisChild == null) && (thatChild == null) || thisChild.equals(thatChild));
      }
    }
  }
 else {
    equal=false;
  }
  return equal;
}","/** 
 * Compare an object for equality. If the given object is a Node then it  may be equal if each Node in the tree is equal. Equality of individual  Nodes is dependant on the specific node type but typically will be  whether they are the same type and have the same children for function nodes and whether they have the same value or are the same variable for  terminal nodes.
 * @param obj an object to be compared for equivalence.
 * @return true if this node tree is the same as the obj argument; false otherwise.
 */
@Override public boolean equals(Object obj){
  boolean equal=true;
  if (obj instanceof Node) {
    Node n=(Node)obj;
    if (n.getArity() != this.getArity()) {
      equal=false;
    }
 else     if (n.getIdentifier() != this.getIdentifier()) {
      equal=false;
    }
 else {
      for (int i=0; i < n.getArity() && equal; i++) {
        Node thatChild=n.getChild(i);
        Node thisChild=this.getChild(i);
        if ((thisChild != null) ^ (thatChild != null)) {
          equal=false;
        }
 else {
          equal=((thisChild == null) && (thatChild == null) || thisChild.equals(thatChild));
        }
      }
    }
  }
 else {
    equal=false;
  }
  return equal;
}",0.9377738825591586
180674,"@Override public boolean equals(Object obj){
  if (obj != null && obj instanceof NonTerminalSymbol) {
    NonTerminalSymbol otherSymbol=(NonTerminalSymbol)obj;
    return this.getGrammarRule() == otherSymbol.getGrammarRule();
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object obj){
  boolean equal=true;
  if (obj != null && obj instanceof NonTerminalSymbol) {
    NonTerminalSymbol otherSymbol=(NonTerminalSymbol)obj;
    if (this.getGrammarRule() == otherSymbol.getGrammarRule()) {
      for (int i=0; i < children.size(); i++) {
        Symbol thatChild=otherSymbol.getChild(i);
        Symbol thisChild=this.getChild(i);
        if (!ObjectUtils.equals(thisChild,thatChild)) {
          equal=false;
          break;
        }
      }
    }
 else {
      equal=false;
    }
  }
 else {
    equal=false;
  }
  return equal;
}",0.5093896713615024
180675,"/** 
 * Construct a RampedHalfAndHalfInitialiser.
 * @param model The model being assessed
 */
public RampedHalfAndHalfInitialiser(GPModel model){
  this.model=model;
  grow=new GrowInitialiser(model);
  full=new FullInitialiser(model);
  model.getLifeCycleManager().addConfigListener(new ConfigAdapter(){
    @Override public void onConfigure(){
      configure();
    }
  }
);
}","/** 
 * Construct a RampedHalfAndHalfInitialiser.
 * @param model The model being assessed
 */
public RampedHalfAndHalfInitialiser(GPModel model,int minDepth){
  this.model=model;
  this.minDepth=minDepth;
  grow=new GrowInitialiser(model);
  full=new FullInitialiser(model);
  model.getLifeCycleManager().addConfigListener(new ConfigAdapter(){
    @Override public void onConfigure(){
      configure();
    }
  }
);
}",0.951188986232791
180676,"/** 
 * Compares the given argument for equivalence to this GECandidateProgram. Two candidate programs are equal if they have equal genotypes, or if  they have equal (but non-null) phenotypes.
 * @return true if the object is an equivalent candidate program, false otherwise.
 */
@Override public boolean equals(Object o){
  GRCandidateProgram prog=(GRCandidateProgram)o;
  Symbol thisParseTree=this.parseTree;
  Symbol progParseTree=prog.parseTree;
  if (thisParseTree == null && progParseTree == null) {
    return true;
  }
 else {
    return thisParseTree.equals(progParseTree);
  }
}","/** 
 * Compares the given argument for equivalence to this GECandidateProgram. Two GR candidate programs are equal if they have equal syntax regardless of grammar rules used or if both have a null parse tree.
 * @return true if the object is an equivalent candidate program, false otherwise.
 */
@Override public boolean equals(Object o){
  if (o instanceof GRCandidateProgram) {
    GRCandidateProgram prog=(GRCandidateProgram)o;
    return prog.toString().equals(this.toString());
  }
 else {
    return false;
  }
}",0.6052393857271906
180677,"public static int max(int[] values){
  int min=Integer.MIN_VALUE;
  for (int i=0; i < values.length; i++) {
    if (values[i] < min) {
      min=values[i];
    }
  }
  return min;
}","public static int max(int[] values){
  int max=Integer.MIN_VALUE;
  for (int i=0; i < values.length; i++) {
    if (values[i] > max) {
      max=values[i];
    }
  }
  return max;
}",0.9502762430939228
180678,"/** 
 * Construct a GEModel with a set of sensible defaults. See the appropriate accessor method for information of each default value.
 */
public GEModel(){
  mapper=new DepthFirstMapper(this);
  codonGenerator=new StandardGenerator(this);
  grammar=null;
  maxDepth=14;
  maxInitialDepth=8;
  maxCodonSize=Integer.MAX_VALUE;
  maxChromosomeLength=-1;
  cacheSource=true;
  setInitialiser(new RampedHalfAndHalfInitialiser(this));
  setCrossover(new OnePointCrossover(this));
  setMutation(new PointMutation(this));
}","/** 
 * Construct a GEModel with a set of sensible defaults. See the appropriate accessor method for information of each default value.
 */
public GEModel(){
  getStatsManager().setStatsEngine(new GEStatsEngine(this));
  mapper=new DepthFirstMapper(this);
  codonGenerator=new StandardGenerator(this);
  grammar=null;
  maxDepth=14;
  maxInitialDepth=8;
  maxCodonSize=Integer.MAX_VALUE;
  maxChromosomeLength=-1;
  cacheSource=true;
  setInitialiser(new RampedHalfAndHalfInitialiser(this));
  setCrossover(new OnePointCrossover(this));
  setMutation(new PointMutation(this));
}",0.9442922374429225
180679,"/** 
 * Construct a GPModel with a set of sensible defaults. See the appropriate accessor method for information of each default value.
 */
public GPModel(){
  maxInitialDepth=6;
  maxProgramDepth=12;
  setInitialiser(new FullInitialiser(this));
  setCrossover(new UniformPointCrossover(this));
  setMutation(new SubtreeMutation(this));
}","/** 
 * Construct a GPModel with a set of sensible defaults. See the appropriate accessor method for information of each default value.
 */
public GPModel(){
  getStatsManager().setStatsEngine(new GPStatsEngine(this));
  maxInitialDepth=6;
  maxProgramDepth=12;
  setInitialiser(new FullInitialiser(this));
  setCrossover(new UniformPointCrossover(this));
  setMutation(new SubtreeMutation(this));
}",0.9172320217096336
180680,"/** 
 * Requests the controlling model to calculate the fitness of this  <code>GPCandidateProgram</code>.
 * @return the fitness of this candidate program according to the model.
 */
public double getFitness(){
  String source=null;
  if (model.cacheFitness()) {
    source=rootNode.toString();
  }
  if (!model.cacheFitness() || !source.equals(sourceCache)) {
    fitness=model.getFitness(this);
    sourceCache=source;
  }
  return fitness;
}","/** 
 * Requests the controlling model to calculate the fitness of this  <code>GPCandidateProgram</code>.
 * @return the fitness of this candidate program according to the model.
 */
@Override public double getFitness(){
  String source=null;
  if (model.cacheFitness()) {
    source=rootNode.toString();
  }
  if (!model.cacheFitness() || !source.equals(sourceCache)) {
    fitness=model.getFitness(this);
    sourceCache=source;
  }
  return fitness;
}",0.9888641425389756
180681,"private void setNthNode(int n,Node newNode,int current){
  int arity=getArity();
  for (int i=0; i < arity; i++) {
    if (current + 1 == n) {
      setChild(i,newNode);
      return;
    }
    Node child=getChild(i);
    int childLength=child.getLength();
    if (n <= childLength + current) {
      child.setNthNode(n,newNode,current + 1);
    }
    current+=childLength;
  }
  throw new IndexOutOfBoundsException(""String_Node_Str"");
}","private void setNthNode(int n,Node newNode,int current){
  int arity=getArity();
  for (int i=0; i < arity; i++) {
    if (current + 1 == n) {
      setChild(i,newNode);
      return;
    }
    Node child=getChild(i);
    int childLength=child.getLength();
    if (n <= childLength + current) {
      child.setNthNode(n,newNode,current + 1);
      return;
    }
    current+=childLength;
  }
  throw new IndexOutOfBoundsException(""String_Node_Str"");
}",0.9842342342342344
180682,"/** 
 * Construct a GRModel with a set of sensible defaults. See the appropriate accessor method for information of each default value.
 */
public GRModel(){
  grammar=null;
  maxDepth=14;
  maxInitialDepth=8;
  setInitialiser(new RampedHalfAndHalfInitialiser(this));
  setCrossover(new WhighamCrossover(this));
  setMutation(new WhighamMutation(this));
}","/** 
 * Construct a GRModel with a set of sensible defaults. See the appropriate accessor method for information of each default value.
 */
public GRModel(){
  getStatsManager().setStatsEngine(new GRStatsEngine(this));
  grammar=null;
  maxDepth=14;
  maxInitialDepth=8;
  setInitialiser(new RampedHalfAndHalfInitialiser(this));
  setCrossover(new WhighamCrossover(this));
  setMutation(new WhighamMutation(this));
}",0.920881971465629
180683,"/** 
 * Returns the location of one move on from the given location in the  direction of the provided orientation. The landscape is a torus so this  method is required to calculate the necessary wrapping.
 * @param location the current location to calculate the next move from.
 * @param orientation the direction of the move.
 * @return the next location one move on from the given location in the direction of the provided orientation.
 */
public Point getNextLocation(Point location,Orientation orientation){
  Point newLocation=new Point(location);
switch (orientation) {
case NORTH:
    newLocation.y=(location.y > 0) ? (location.y - 1) : (size.height - 1);
  break;
case EAST:
newLocation.x=(location.x < size.width - 1) ? (location.x + 1) : 0;
break;
case SOUTH:
newLocation.y=(location.y < size.height - 1) ? (location.y + 1) : 0;
break;
case WEST:
newLocation.x=(location.x > 0) ? (location.y - 1) : (size.width - 1);
break;
default :
break;
}
return newLocation;
}","/** 
 * Returns the location of one move on from the given location in the  direction of the provided orientation. The landscape is a torus so this  method is required to calculate the necessary wrapping.
 * @param location the current location to calculate the next move from.
 * @param orientation the direction of the move.
 * @return the next location one move on from the given location in the direction of the provided orientation.
 */
public Point getNextLocation(Point location,Orientation orientation){
  Point newLocation=new Point(location);
switch (orientation) {
case NORTH:
    newLocation.y=(location.y > 0) ? (location.y - 1) : (size.height - 1);
  break;
case EAST:
newLocation.x=(location.x < size.width - 1) ? (location.x + 1) : 0;
break;
case SOUTH:
newLocation.y=(location.y < size.height - 1) ? (location.y + 1) : 0;
break;
case WEST:
newLocation.x=(location.x > 0) ? (location.x - 1) : (size.width - 1);
break;
default :
break;
}
return newLocation;
}",0.9989733059548256
180684,"/** 
 * Constructs an instance of <code>LinearRankSelector</code>.
 * @param model
 * @param gradient
 */
public LinearRankSelector(final Model model,final double gradient){
  this.model=model;
  setGradient(gradient);
  model.getLifeCycleManager().addConfigListener(new ConfigAdapter(){
    @Override public void onConfigure(){
      configure();
    }
  }
);
}","/** 
 * Constructs an instance of <code>LinearRankSelector</code>.
 * @param model
 * @param gradient
 */
public LinearRankSelector(final Model model,final double gradient){
  this.model=model;
  setGradient(gradient);
  programSelection=new ProgramLinearRankSelector();
  poolSelection=new ProgramLinearRankSelector();
  model.getLifeCycleManager().addConfigListener(new ConfigAdapter(){
    @Override public void onConfigure(){
      configure();
    }
  }
);
}",0.8775757575757576
180685,"/** 
 * Executes a single evolutionary run of this <code>RunManager's</code>  <code>Model</code>.
 * @param runNo the sequential number which identifies this run out of the set of runs being performed.
 */
public void run(final int runNo){
  LifeCycleManager.getLifeCycleManager().onRunStart();
  final long startTime=System.nanoTime();
  StatsManager.getStatsManager().addRunData(RUN_NUMBER,runNo);
  List<CandidateProgram> pop=initialisation.initialise();
  updateBestProgram(pop);
  for (int gen=1; gen <= model.getNoGenerations(); gen++) {
    pop=generation.generation(gen,pop);
    updateBestProgram(pop);
    if (bestFitness <= model.getTerminationFitness()) {
      LifeCycleManager.getLifeCycleManager().onSuccess();
      break;
    }
  }
  LifeCycleManager.getLifeCycleManager().onRunEnd();
  final long runtime=System.nanoTime() - startTime;
  StatsManager.getStatsManager().addRunData(RUN_TIME,runtime);
}","/** 
 * Executes a single evolutionary run of this <code>RunManager's</code>  <code>Model</code>.
 * @param runNo the sequential number which identifies this run out of the set of runs being performed.
 */
public void run(final int runNo){
  setup();
  LifeCycleManager.getLifeCycleManager().onRunStart();
  final long startTime=System.nanoTime();
  StatsManager.getStatsManager().addRunData(RUN_NUMBER,runNo);
  List<CandidateProgram> pop=initialisation.initialise();
  updateBestProgram(pop);
  for (int gen=1; gen <= model.getNoGenerations(); gen++) {
    pop=generation.generation(gen,pop);
    updateBestProgram(pop);
    if (bestFitness <= model.getTerminationFitness()) {
      LifeCycleManager.getLifeCycleManager().onSuccess();
      break;
    }
  }
  LifeCycleManager.getLifeCycleManager().onRunEnd();
  final long runtime=System.nanoTime() - startTime;
  StatsManager.getStatsManager().addRunData(RUN_TIME,runtime);
}",0.994044396318354
180686,"/** 
 * Constructs an instance of RunManager to be controlled by parameters  retrieved from the given <code>Model</code>. Fitness evaluation will  also be diverted to the given model.
 * @param model the model which will control the run with the parameters and fitness function to use.
 */
public RunManager(final Model model){
  this.model=model;
  bestProgram=null;
  bestFitness=Double.POSITIVE_INFINITY;
  generation=new GenerationManager(model);
  initialisation=new InitialisationManager(model);
}","/** 
 * Constructs an instance of RunManager to be controlled by parameters  retrieved from the given <code>Model</code>. Fitness evaluation will  also be diverted to the given model.
 * @param model the model which will control the run with the parameters and fitness function to use.
 */
public RunManager(final Model model){
  this.model=model;
  generation=new GenerationManager(model);
  initialisation=new InitialisationManager(model);
}",0.9365750528541226
180687,"/** 
 * Construct a GRModel with a set of sensible defaults. See the appropriate accessor method for information of each default value.
 */
public GRAbstractModel(){
  maxDepth=20;
  maxInitialDepth=8;
  initialiser=new RampedHalfAndHalfInitialiser(this);
  crossover=new WhighamCrossover(this);
  mutator=new WhighamMutation(this);
  setStatsEngine(new GRStatsEngine());
}","/** 
 * Construct a GRModel with a set of sensible defaults. See the appropriate accessor method for information of each default value.
 */
public GRAbstractModel(){
  maxDepth=12;
  maxInitialDepth=8;
  initialiser=new RampedHalfAndHalfInitialiser(this);
  crossover=new WhighamCrossover(this);
  mutator=new WhighamMutation(this);
  setStatsEngine(new GRStatsEngine());
}",0.9973190348525468
180688,"public Node parse(String source){
  if (source == null) {
    return null;
  }
  int openingBracket=source.indexOf('(');
  String identifier=null;
  List<String> args=null;
  if (openingBracket == -1) {
    identifier=source;
    args=new ArrayList<String>();
  }
 else {
    identifier=source.substring(0,openingBracket);
    String argumentStr=source.substring(openingBracket + 1,source.length() - 1);
    args=splitArguments(argumentStr);
  }
  Node node=initialiseFunction(identifier);
  if (node == null) {
    node=parseTerminal(identifier);
  }
  if (node == null || node.getArity() != args.size()) {
    throw new MalformedProgramException();
  }
 else {
    for (int i=0; i < args.size(); i++) {
      node.setChild(i,parse(args.get(i)));
    }
  }
  return node;
}","public Node parse(String source){
  if (source == null) {
    return null;
  }
  int openingBracket=source.indexOf('(');
  String identifier=null;
  List<String> args=null;
  if (openingBracket == -1) {
    identifier=source;
    args=new ArrayList<String>();
  }
 else {
    identifier=source.substring(0,openingBracket);
    int closingBracket=source.lastIndexOf(')');
    String argumentStr=source.substring(openingBracket + 1,closingBracket);
    args=splitArguments(argumentStr);
  }
  Node node=initialiseFunction(identifier);
  if (node == null) {
    node=parseTerminal(identifier);
  }
  if (node == null || node.getArity() != args.size()) {
    throw new MalformedProgramException();
  }
 else {
    for (int i=0; i < args.size(); i++) {
      node.setChild(i,parse(args.get(i)));
    }
  }
  return node;
}",0.949088623507228
180689,"/** 
 * Constructs an instance of CrossoverManager which will setup the crossover  operation. Note that the actual crossover operation will be performed by  the subclass of <code>Crossover</code> returned by the models  getCrossover() method.
 * @param model the Model which defines the Crossover operator and ProgramSelector to use to perform one act of crossover on  a population.
 * @see Crossover
 */
public CrossoverManager(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs an instance of CrossoverManager which will setup the crossover  operation. Note that the actual crossover operation will be performed by  the subclass of <code>Crossover</code> returned by the models  getCrossover() method.
 * @param model the Model which defines the Crossover operator and ProgramSelector to use to perform one act of crossover on  a population.
 * @see Crossover
 */
public CrossoverManager(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.7452907452907452
180690,"/** 
 * Constructs an instance of <code>Elitism</code> which will perform the  evolutionary operation of elitism. 
 * @param model the Model which defines the run parameters such as numberof elites to use.
 */
public ElitismManager(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs an instance of <code>Elitism</code> which will perform the  evolutionary operation of elitism. 
 * @param model the Model which defines the run parameters such as numberof elites to use.
 */
public ElitismManager(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9794437726723096
180691,"/** 
 * Performs one generation of an evolutionary run. The method receives the  previous population and then performs one generation and returns the  resultant population.  <p> A generation consists of the following sequence of events: <ol> <li>Select the elites and put them into the next population.</li> <li>Select a breeding pool of programs.</li> <li>Randomly choose an operator based upon probablities from the model: <ul> <li>Crossover - pass control to crossover component.</li> <li>Mutation - pass control to mutation component.</li> <li>Reproduction - pass control to reproduction component.</li> </ul> </li> <li>Insert the result of the operator into the next population.</li> <li>Start back at 3. until the next population is full.</li> <li>Return the new population.</li> </ol> <p> The necessary events trigger life cycle events.
 * @param previousPop the previous population which will undergo manipulation to create the next population.
 * @return the population derived from performing genetic operations on theprevious population.
 */
public List<CandidateProgram> generation(final int generationNumber,final List<CandidateProgram> previousPop){
  updateModel();
  LifeCycleManager.getLifeCycleManager().onGenerationStart();
  final long startTime=System.nanoTime();
  StatsManager.getStatsManager().addGenerationData(GEN_NUMBER,generationNumber);
  List<CandidateProgram> pop=new ArrayList<CandidateProgram>(popSize);
  do {
    pop.addAll(elitism.elitism(previousPop));
    final List<CandidateProgram> pool=poolSelection.getPool(previousPop);
    programSelector.setSelectionPool(pool);
    while (pop.size() < popSize) {
      final double random=rng.nextDouble();
      if (random < crossoverProbability) {
        final CandidateProgram[] children=crossover.crossover();
        for (        final CandidateProgram c : children) {
          if (pop.size() < popSize) {
            pop.add(c);
          }
        }
      }
 else       if (random < crossoverProbability + mutationProbability) {
        pop.add(mutation.mutate());
      }
 else {
        pop.add(reproduction.reproduce());
      }
    }
    pop=LifeCycleManager.getLifeCycleManager().onGeneration(pop);
    if (pop == null) {
      reversions++;
    }
  }
 while (pop == null);
  StatsManager.getStatsManager().addGenerationData(GEN_REVERSIONS,reversions);
  StatsManager.getStatsManager().addGenerationData(GEN_POPULATION,pop);
  StatsManager.getStatsManager().addGenerationData(GEN_TIME,(System.nanoTime() - startTime));
  LifeCycleManager.getLifeCycleManager().onGenerationEnd();
  return pop;
}","/** 
 * Performs one generation of an evolutionary run. The method receives the  previous population and then performs one generation and returns the  resultant population.  <p> A generation consists of the following sequence of events: <ol> <li>Select the elites and put them into the next population.</li> <li>Select a breeding pool of programs.</li> <li>Randomly choose an operator based upon probablities from the model: <ul> <li>Crossover - pass control to crossover component.</li> <li>Mutation - pass control to mutation component.</li> <li>Reproduction - pass control to reproduction component.</li> </ul> </li> <li>Insert the result of the operator into the next population.</li> <li>Start back at 3. until the next population is full.</li> <li>Return the new population.</li> </ol> <p> The necessary events trigger life cycle events.
 * @param previousPop the previous population which will undergo manipulation to create the next population.
 * @return the population derived from performing genetic operations on theprevious population.
 */
public List<CandidateProgram> generation(final int generationNumber,final List<CandidateProgram> previousPop){
  LifeCycleManager.getLifeCycleManager().onGenerationStart();
  final long startTime=System.nanoTime();
  StatsManager.getStatsManager().addGenerationData(GEN_NUMBER,generationNumber);
  List<CandidateProgram> pop=new ArrayList<CandidateProgram>(popSize);
  do {
    pop.addAll(elitism.elitism(previousPop));
    final List<CandidateProgram> pool=poolSelection.getPool(previousPop);
    programSelector.setSelectionPool(pool);
    while (pop.size() < popSize) {
      final double random=rng.nextDouble();
      if (random < crossoverProbability) {
        final CandidateProgram[] children=crossover.crossover();
        for (        final CandidateProgram c : children) {
          if (pop.size() < popSize) {
            pop.add(c);
          }
        }
      }
 else       if (random < crossoverProbability + mutationProbability) {
        pop.add(mutation.mutate());
      }
 else {
        pop.add(reproduction.reproduce());
      }
    }
    pop=LifeCycleManager.getLifeCycleManager().onGeneration(pop);
    if (pop == null) {
      reversions++;
    }
  }
 while (pop == null);
  StatsManager.getStatsManager().addGenerationData(GEN_REVERSIONS,reversions);
  StatsManager.getStatsManager().addGenerationData(GEN_POPULATION,pop);
  StatsManager.getStatsManager().addGenerationData(GEN_TIME,(System.nanoTime() - startTime));
  LifeCycleManager.getLifeCycleManager().onGenerationEnd();
  return pop;
}",0.9967047877495638
180692,"/** 
 * Constructs an instance of <code>InitialisationManager</code> which will  setup the initialisation operation.
 * @param model the model which defines the Initialiser operator and any other control parameters.
 * @see Initialiser
 */
public InitialisationManager(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs an instance of <code>InitialisationManager</code> which will  setup the initialisation operation.
 * @param model the model which defines the Initialiser operator and any other control parameters.
 * @see Initialiser
 */
public InitialisationManager(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.981132075471698
180693,"/** 
 * Constructs an instance of MutationManager which will setup the mutation  operation. Note that the actual mutation operation will be performed by  the subclass of <code>Mutation</code> returned by the model's  <code>getMutation()</code> method.
 * @param model the Model which defines the Mutation operator and ProgramSelector to use to perform one act of mutation on  an individual in the population.
 * @see Mutation
 */
public MutationManager(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs an instance of MutationManager which will setup the mutation  operation. Note that the actual mutation operation will be performed by  the subclass of <code>Mutation</code> returned by the model's  <code>getMutation()</code> method.
 * @param model the Model which defines the Mutation operator and ProgramSelector to use to perform one act of mutation on  an individual in the population.
 * @see Mutation
 */
public MutationManager(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.7549251379038613
180694,"/** 
 * Constructs an instance of PoolSelectionManager which will setup the  breeding pool selection operation.
 * @param model the Model which defines the PoolSelector operator and anyother control parameters.
 * @see PoolSelector
 */
public PoolSelectionManager(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs an instance of PoolSelectionManager which will setup the  breeding pool selection operation.
 * @param model the Model which defines the PoolSelector operator and anyother control parameters.
 * @see PoolSelector
 */
public PoolSelectionManager(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9809203142536476
180695,"/** 
 * Constructs an instance of ReproductionManager which will setup the  reproduction operation. The selection of the program to be reproduced is performed by the parent selector obtained from a call to the model's  <code>getParentSelector()</code> method.
 * @param model the model which defines the ProgramSelector to use to select the program to be reproduced.
 */
public ReproductionManager(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs an instance of ReproductionManager which will setup the  reproduction operation. The selection of the program to be reproduced is performed by the parent selector obtained from a call to the model's  <code>getParentSelector()</code> method.
 * @param model the model which defines the ProgramSelector to use to select the program to be reproduced.
 */
public ReproductionManager(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9853321829163072
180696,"public LinearRankSelector(double gradient){
  this.gradient=gradient;
  nMinus=2 / (gradient + 1);
  nPlus=(2 * gradient) / (gradient + 1);
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","public LinearRankSelector(double gradient){
  this.gradient=gradient;
  nMinus=2 / (gradient + 1);
  nPlus=(2 * gradient) / (gradient + 1);
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9733124018838304
180697,"/** 
 */
public RandomSelector(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 */
public RandomSelector(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.96
180698,"/** 
 * Construct a StandardGenerator.
 * @param model the model that controls the run, providing the maximum codon size.
 */
public StandardGenerator(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Construct a StandardGenerator.
 * @param model the model that controls the run, providing the maximum codon size.
 */
public StandardGenerator(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.974436090225564
180699,"/** 
 * Constructs an instance of BreadthFirstMapper.
 * @param model the controlling model providing configuration details such as the Grammar.
 */
public BreadthFirstMapper(){
  wrapping=false;
  extending=true;
  removingUnusedCodons=true;
  noMappedCodons=-1;
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs an instance of BreadthFirstMapper.
 * @param model the controlling model providing configuration details such as the Grammar.
 */
public BreadthFirstMapper(){
  wrapping=false;
  extending=true;
  removingUnusedCodons=true;
  noMappedCodons=-1;
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9807909604519774
180700,"/** 
 * Constructs an instance of DepthFirstMapper.
 * @param model the controlling model providing configuration details such as the Grammar.
 */
public DepthFirstMapper(){
  wrapping=true;
  extending=false;
  maxWraps=3;
  removingUnusedCodons=true;
  noMappedCodons=-1;
  noWraps=0;
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs an instance of DepthFirstMapper.
 * @param model the controlling model providing configuration details such as the Grammar.
 */
public DepthFirstMapper(){
  wrapping=true;
  extending=false;
  maxWraps=3;
  removingUnusedCodons=true;
  noMappedCodons=-1;
  noWraps=0;
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9817400644468314
180701,"/** 
 * Constructs an instance of FixedPointCrossover.
 * @param model the current controlling model.
 */
public FixedPointCrossover(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs an instance of FixedPointCrossover.
 * @param model the current controlling model.
 */
public FixedPointCrossover(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.972972972972973
180702,"public OnePointCrossover(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","public OnePointCrossover(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9588377723970944
180703,"private void updateModel(){
  popSize=((GEModel)Controller.getModel()).getPopulationSize();
}","private void updateModel(){
  model=(GEModel)Controller.getModel();
  popSize=model.getPopulationSize();
}",0.864321608040201
180704,"/** 
 * Generate a population of new CandidatePrograms constructed by randomly  generating their chromosomes. The size of the population will be equal  to the result of calling getPopulationSize() on the controlling model.  All programs in the population will be unique. Each candidate program  will have a chromosome length equal to the initialLength provided to the  constructor.
 * @return A List of newly generated CandidatePrograms which will form the initial population for a GE run.
 */
@Override public List<CandidateProgram> getInitialPopulation(){
  List<CandidateProgram> firstGen=new ArrayList<CandidateProgram>(popSize);
  int i=0;
  while (i < popSize) {
    GECandidateProgram candidate=new GECandidateProgram();
    candidate.appendNewCodons(initialLength);
    firstGen.add(candidate);
    i++;
  }
  return firstGen;
}","/** 
 * Generate a population of new CandidatePrograms constructed by randomly  generating their chromosomes. The size of the population will be equal  to the result of calling getPopulationSize() on the controlling model.  All programs in the population will be unique. Each candidate program  will have a chromosome length equal to the initialLength provided to the  constructor.
 * @return A List of newly generated CandidatePrograms which will form the initial population for a GE run.
 */
@Override public List<CandidateProgram> getInitialPopulation(){
  List<CandidateProgram> firstGen=new ArrayList<CandidateProgram>(popSize);
  int i=0;
  while (i < popSize) {
    GECandidateProgram candidate=new GECandidateProgram(model);
    candidate.appendNewCodons(initialLength);
    firstGen.add(candidate);
    i++;
  }
  return firstGen;
}",0.9970184853905784
180705,"/** 
 * Constructs a RandomInitialiser.
 * @param model The GE model that will provide any required control parameters such as the desired population size.
 * @param initialLength The initial length that chromosomes should be generated to.
 */
public FixedLengthInitialiser(int initialLength){
  this.initialLength=initialLength;
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs a RandomInitialiser.
 * @param model The GE model that will provide any required control parameters such as the desired population size.
 * @param initialLength The initial length that chromosomes should be generated to.
 */
public FixedLengthInitialiser(int initialLength){
  this.initialLength=initialLength;
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.6941986234021632
180706,"private void updateModel(){
  GEModel model=(GEModel)Controller.getModel();
  rng=model.getRNG();
  grammar=model.getGrammar();
  popSize=model.getPopulationSize();
  maxInitialProgramDepth=model.getMaxInitialProgramDepth();
  maxCodonSize=model.getMaxCodonSize();
}","private void updateModel(){
  model=(GEModel)Controller.getModel();
  rng=model.getRNG();
  grammar=model.getGrammar();
  popSize=model.getPopulationSize();
  maxInitialProgramDepth=model.getMaxInitialProgramDepth();
  maxCodonSize=model.getMaxCodonSize();
}",0.9847328244274808
180707,"/** 
 * Constructs a full initialiser.
 * @param model
 */
public FullInitialiser(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs a full initialiser.
 * @param model
 */
public FullInitialiser(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.967741935483871
180708,"public GECandidateProgram getInitialProgram(int depth){
  GrammarNode start=grammar.getStartRule();
  List<Integer> codons=new ArrayList<Integer>();
  buildDerivationTree(codons,start,0,depth);
  return new GECandidateProgram(codons);
}","public GECandidateProgram getInitialProgram(int depth){
  GrammarNode start=grammar.getStartRule();
  List<Integer> codons=new ArrayList<Integer>();
  buildDerivationTree(codons,start,0,depth);
  return new GECandidateProgram(model,codons);
}",0.98744769874477
180709,"/** 
 * Constructs a grow initialiser.
 * @param model
 */
public GrowInitialiser(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs a grow initialiser.
 * @param model
 */
public GrowInitialiser(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.967741935483871
180710,"private void updateModel(){
  GEModel model=(GEModel)Controller.getModel();
  rng=model.getRNG();
  grammar=model.getGrammar();
  popSize=model.getPopulationSize();
  maxInitialProgramDepth=model.getMaxInitialProgramDepth();
  maxCodonSize=model.getMaxCodonSize();
}","private void updateModel(){
  model=(GEModel)Controller.getModel();
  rng=model.getRNG();
  grammar=model.getGrammar();
  popSize=model.getPopulationSize();
  maxInitialProgramDepth=model.getMaxInitialProgramDepth();
  maxCodonSize=model.getMaxCodonSize();
}",0.9847328244274808
180711,"public GECandidateProgram getInitialProgram(int depth){
  GrammarNode start=grammar.getStartRule();
  int minDepth=0;
  if (start instanceof GrammarRule) {
    minDepth=((GrammarRule)start).getMinDepth();
  }
  if (minDepth > depth) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Integer> codons=new ArrayList<Integer>();
  buildDerivationTree(codons,start,0,depth);
  return new GECandidateProgram(codons);
}","public GECandidateProgram getInitialProgram(int depth){
  GrammarNode start=grammar.getStartRule();
  int minDepth=0;
  if (start instanceof GrammarRule) {
    minDepth=((GrammarRule)start).getMinDepth();
  }
  if (minDepth > depth) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Integer> codons=new ArrayList<Integer>();
  buildDerivationTree(codons,start,0,depth);
  return new GECandidateProgram(model,codons);
}",0.9931350114416476
180712,"/** 
 * Construct a RampedHalfAndHalfInitialiser.
 * @param model The model being assessed
 */
public RampedHalfAndHalfInitialiser(){
  grow=new GrowInitialiser();
  full=new FullInitialiser();
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Construct a RampedHalfAndHalfInitialiser.
 * @param model The model being assessed
 */
public RampedHalfAndHalfInitialiser(){
  grow=new GrowInitialiser();
  full=new FullInitialiser();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9771812080536912
180713,"/** 
 * Construct a point mutation with user specified point probability.
 * @param model The current controlling model. Parameters such as the codongenerator to use will come from here.
 * @param pointProbability The probability each node in a selected program has of undergoing a mutation. 1.0 would result in all nodes  being changed, and 0.0 would mean no nodes were changed. A  typical value would be 0.01.
 */
public PointMutation(double pointProbability){
  this.pointProbability=pointProbability;
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Construct a point mutation with user specified point probability.
 * @param model The current controlling model. Parameters such as the codongenerator to use will come from here.
 * @param pointProbability The probability each node in a selected program has of undergoing a mutation. 1.0 would result in all nodes  being changed, and 0.0 would mean no nodes were changed. A  typical value would be 0.01.
 */
public PointMutation(double pointProbability){
  this.pointProbability=pointProbability;
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.7724945135332846
180714,"/** 
 * Construct a single point mutation.
 * @param model The current controlling model. Parameters such as the codongenerator to use will come from here.
 */
public SinglePointMutation(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Construct a single point mutation.
 * @param model The current controlling model. Parameters such as the codongenerator to use will come from here.
 */
public SinglePointMutation(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9769335142469472
180715,"/** 
 * Constructs a new program individual with the specified codons as the  genotypic chromosome.
 * @param codons the program's initial genotypic chromosome.
 * @param model the controlling model which provides the configuration parameters for the run. 				
 */
public GECandidateProgram(List<Integer> codons){
  this.codons=codons;
  parseTree=null;
  mapped=false;
  fitness=-1;
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","/** 
 * Constructs a new program individual with the specified codons as the  genotypic chromosome.
 * @param codons the program's initial genotypic chromosome.
 * @param model the controlling model which provides the configuration parameters for the run. 				
 */
public GECandidateProgram(GEModel model,List<Integer> codons){
  this.model=model;
  this.codons=codons;
  parseTree=null;
  mapped=false;
  fitness=-1;
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9559965487489216
180716,"public UniformPointCrossover(){
  updateModel();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}","public UniformPointCrossover(){
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      updateModel();
    }
  }
);
}",0.9596199524940616
180717,"private Symbol getNthSymbol(int n,int current){
  if (n == current) {
    return this;
  }
  for (  Symbol child : children) {
    if (child instanceof NonTerminalSymbol) {
      NonTerminalSymbol nt=(NonTerminalSymbol)child;
      Symbol nth=nt.getNthSymbol(n,current + 1);
      if (nth != null) {
        return nth;
      }
      current+=nt.getNoSymbols();
    }
 else {
      if (n == current++) {
        return child;
      }
    }
  }
  return null;
}","private Symbol getNthSymbol(int n,int current){
  if (n == current) {
    return this;
  }
  for (  Symbol child : children) {
    if (child instanceof NonTerminalSymbol) {
      NonTerminalSymbol nt=(NonTerminalSymbol)child;
      Symbol nth=nt.getNthSymbol(n,current + 1);
      if (nth != null) {
        return nth;
      }
      current+=nt.getNoSymbols();
    }
 else {
      if (n == ++current) {
        return child;
      }
    }
  }
  return null;
}",0.9847826086956522
180718,"/** 
 * Constructor for the full initialiser.
 * @param model The current controlling model. Run parameters such as the population size will be obtained from this.
 */
public FullInitialiser(GPModel model){
  this.model=model;
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      reset();
    }
  }
);
}","/** 
 * Constructor for the full initialiser.
 * @param model The current controlling model. Run parameters such as the population size will be obtained from this.
 */
public FullInitialiser(GPModel model){
  this.model=model;
  terminals=new ArrayList<Node>();
  functions=new ArrayList<Node>();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      reset();
    }
  }
);
}",0.9178403755868544
180719,"private void reset(){
  rng=model.getRNG();
  terminals.clear();
  functions.clear();
  syntax=model.getSyntax();
  maxInitialDepth=model.getInitialMaxDepth();
  for (  Node n : syntax) {
    if (n.getArity() == 0) {
      terminals.add(n);
    }
 else {
      functions.add(n);
    }
  }
}","private void reset(){
  rng=model.getRNG();
  terminals.clear();
  functions.clear();
  syntax=model.getSyntax();
  maxInitialDepth=model.getInitialMaxDepth();
  popSize=model.getPopulationSize();
  for (  Node n : syntax) {
    if (n.getArity() == 0) {
      terminals.add(n);
    }
 else {
      functions.add(n);
    }
  }
}",0.940032414910859
180720,"/** 
 * Constructor for the grow initialiser.
 * @param model The current controlling model. Run parameters such as the population size will be obtained from this.
 */
public GrowInitialiser(GPModel model){
  this.model=model;
  terminals=new ArrayList<Node>();
  functions=new ArrayList<Node>();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      reset();
    }
  }
);
}","/** 
 * Constructor for the grow initialiser.
 * @param model The current controlling model. Run parameters such as the population size will be obtained from this.
 */
public GrowInitialiser(GPModel model){
  this.model=model;
  terminals=new ArrayList<Node>();
  functions=new ArrayList<Node>();
  reset();
  LifeCycleManager.getLifeCycleManager().addGenerationListener(new GenerationAdapter(){
    @Override public void onGenerationStart(){
      reset();
    }
  }
);
}",0.9882100750267953
180721,"/** 
 * Evaluating an <code>IfFunction</code> involves evaluating the first child,  if it evaluates to true then the second child is evaluated as the result.  Otherwise the third child is evaluated and returned.
 */
@Override public Boolean evaluate(){
  boolean c1=((Boolean)getChild(0).evaluate()).booleanValue();
  if (c1) {
    return ((Boolean)getChild(1).evaluate()).booleanValue();
  }
 else {
    return ((Boolean)getChild(2).evaluate()).booleanValue();
  }
}","/** 
 * Evaluating an <code>IfFunction</code> involves evaluating the first child,  if it evaluates to true then the second child is evaluated as the result.  Otherwise the third child is evaluated and returned.
 */
@Override public Boolean evaluate(){
  boolean c1=((Boolean)getChild(0).evaluate()).booleanValue();
  if (c1) {
    return (Boolean)getChild(1).evaluate();
  }
 else {
    return (Boolean)getChild(2).evaluate();
  }
}",0.9622222222222222
180722,"@Override public GRCandidateProgram mutate(CandidateProgram program){
  GRCandidateProgram mutatedProgram=(GRCandidateProgram)program;
  NonTerminalSymbol parseTree=mutatedProgram.getParseTree();
  List<NonTerminalSymbol> nonTerminals=parseTree.getNonTerminalSymbols();
  int selection=rng.nextInt(nonTerminals.size());
  NonTerminalSymbol point=nonTerminals.get(selection);
  int originalDepth=point.getDepth();
  GrammarRule rule=point.getGrammarRule();
  NonTerminalSymbol replacement=init.growParseTree(originalDepth,rule);
  point.setChildren(replacement.removeChildren());
  return mutatedProgram;
}","@Override public GRCandidateProgram mutate(CandidateProgram program){
  GRCandidateProgram mutatedProgram=(GRCandidateProgram)program.clone();
  NonTerminalSymbol parseTree=mutatedProgram.getParseTree();
  List<Integer> nonTerminals=parseTree.getNonTerminalIndexes();
  int selection=nonTerminals.get(rng.nextInt(nonTerminals.size()));
  NonTerminalSymbol point=(NonTerminalSymbol)parseTree.getNthSymbol(selection);
  int originalDepth=point.getDepth();
  GrammarRule rule=point.getGrammarRule();
  NonTerminalSymbol replacement=init.growParseTree(originalDepth,rule);
  if (selection == 0) {
    mutatedProgram.setParseTree(replacement);
  }
 else {
    parseTree.setNthSymbol(selection,replacement);
  }
  FunctionParser parser=new FunctionParser();
  try {
    parser.parse(parseTree.toString());
  }
 catch (  MalformedProgramException e) {
    System.out.println(""String_Node_Str"");
  }
  return mutatedProgram;
}",0.5449770190413658
180723,"@Override public GRCandidateProgram[] crossover(CandidateProgram p1,CandidateProgram p2){
  GRCandidateProgram program1=(GRCandidateProgram)p1;
  GRCandidateProgram program2=(GRCandidateProgram)p2;
  GRCandidateProgram child1=(GRCandidateProgram)program1.clone();
  GRCandidateProgram child2=(GRCandidateProgram)program2.clone();
  NonTerminalSymbol parseTree1=child1.getParseTree();
  NonTerminalSymbol parseTree2=child2.getParseTree();
  List<NonTerminalSymbol> nonTerminals1=parseTree1.getNonTerminalSymbols();
  List<NonTerminalSymbol> nonTerminals2=parseTree2.getNonTerminalSymbols();
  int selection=rng.nextInt(nonTerminals1.size());
  NonTerminalSymbol point1=nonTerminals1.get(selection);
  List<NonTerminalSymbol> matchingNonTerminals=new ArrayList<NonTerminalSymbol>();
  for (  NonTerminalSymbol nt : nonTerminals2) {
    if (nt.equals(point1)) {
      matchingNonTerminals.add(nt);
    }
  }
  if (matchingNonTerminals.isEmpty()) {
    return null;
  }
 else {
    selection=rng.nextInt(matchingNonTerminals.size());
    NonTerminalSymbol point2=matchingNonTerminals.get(selection);
    if (point1.getNoChildren() != point2.getNoChildren()) {
      System.out.println(""String_Node_Str"");
    }
    for (int i=0; i < point1.getNoChildren(); i++) {
      Symbol child=point1.getChild(i);
      point1.setChild(i,point2.getChild(i));
      point2.setChild(i,child);
    }
  }
  return new GRCandidateProgram[]{child1,child2};
}","@Override public GRCandidateProgram[] crossover(CandidateProgram p1,CandidateProgram p2){
  GRCandidateProgram program1=(GRCandidateProgram)p1;
  GRCandidateProgram program2=(GRCandidateProgram)p2;
  GRCandidateProgram child1=(GRCandidateProgram)program1.clone();
  GRCandidateProgram child2=(GRCandidateProgram)program2.clone();
  NonTerminalSymbol parseTree1=child1.getParseTree();
  NonTerminalSymbol parseTree2=child2.getParseTree();
  List<NonTerminalSymbol> nonTerminals1=parseTree1.getNonTerminalSymbols();
  List<NonTerminalSymbol> nonTerminals2=parseTree2.getNonTerminalSymbols();
  int selection=rng.nextInt(nonTerminals1.size());
  NonTerminalSymbol point1=nonTerminals1.get(selection);
  List<NonTerminalSymbol> matchingNonTerminals=new ArrayList<NonTerminalSymbol>();
  for (  NonTerminalSymbol nt : nonTerminals2) {
    if (nt.equals(point1)) {
      matchingNonTerminals.add(nt);
    }
  }
  if (matchingNonTerminals.isEmpty()) {
    return null;
  }
 else {
    selection=rng.nextInt(matchingNonTerminals.size());
    NonTerminalSymbol point2=matchingNonTerminals.get(selection);
    List<Symbol> temp=point1.getChildren();
    point1.setChildren(point2.getChildren());
    point2.setChildren(temp);
  }
  return new GRCandidateProgram[]{child1,child2};
}",0.8581979320531757
180724,"@Override public List<CandidateProgram<Action>> getInitialPopulation(){
  return generatePopulation();
}","@Override public List<CandidateProgram<Object>> getInitialPopulation(){
  return generatePopulation();
}",0.9615384615384616
180725,"/** 
 * Construcor for AA hybrid SDI method
 * @param model The GP model in use
 * @param semMod The relevant semantic module
 */
public AntHybridSemanticallyDrivenInitialiser(GPModel<Action> model,SemanticModule<Action> semMod){
  this.model=model;
  this.semMod=(AntSemanticModule)semMod;
}","/** 
 * Construcor for AA hybrid SDI method
 * @param model The GP model in use
 * @param semMod The relevant semantic module
 */
public AntHybridSemanticallyDrivenInitialiser(GPModel<Object> model,SemanticModule<Object> semMod){
  this.model=model;
  this.semMod=(AntSemanticModule)semMod;
}",0.958904109589041
180726,"private List<CandidateProgram<Action>> generatePopulation(){
  Random rGen=new Random();
  ArrayList<ArrayList<String>> storage=new ArrayList<ArrayList<String>>();
  FullInitialiser<Action> f=new FullInitialiser<Action>(model);
  List<CandidateProgram<Action>> firstPass=f.getInitialPopulation();
  for (  CandidateProgram<Action> c : firstPass) {
    AntRepresentation b=(AntRepresentation)semMod.codeToBehaviour(c.getRootNode());
    if (!b.isConstant()) {
      storage.add(b.getAntRepresentation());
    }
  }
  ArrayList<String> result;
  String oB=(""String_Node_Str"");
  String cB=(""String_Node_Str"");
  int partSize=10;
  while (storage.size() < model.getPopulationSize()) {
    int cFunc=rGen.nextInt(model.getFunctions().size());
    result=new ArrayList<String>();
    if (cFunc == 0) {
      ArrayList<String> part1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> part2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(part1) > partSize) {
        part1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(part2) > partSize) {
        part2=storage.get(rGen.nextInt(storage.size()));
      }
      result.add(oB);
      for (      String p : part1) {
        result.add(p);
      }
      result.add(cB);
      result.add(oB);
      for (      String p : part2) {
        result.add(p);
      }
      result.add(cB);
    }
 else     if (cFunc == 1) {
      ArrayList<String> p1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> p2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p1) > partSize) {
        p1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(p2) > partSize) {
        p2=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(p1,p2,""String_Node_Str"");
    }
 else     if (cFunc == 2) {
      ArrayList<String> p1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> p2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p1) > partSize) {
        p1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(p2) > partSize) {
        p2=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(p1,p2,""String_Node_Str"");
      ArrayList<String> p3=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p3) > partSize) {
        p3=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(result,p3,""String_Node_Str"");
    }
    result=semMod.condenseAntRep(result);
    if (!storage.contains(result) && result.size() > 2) {
      storage.add(result);
    }
  }
  List<CandidateProgram<Action>> firstGen=new ArrayList<CandidateProgram<Action>>();
  int i=1;
  for (  ArrayList<String> toProg : storage) {
    Node<Action> holder=semMod.behaviourToCode(new AntRepresentation(toProg));
    firstGen.add(new CandidateProgram<Action>(holder,model));
    i++;
  }
  storage=null;
  return firstGen;
}","private List<CandidateProgram<Object>> generatePopulation(){
  Random rGen=new Random();
  ArrayList<ArrayList<String>> storage=new ArrayList<ArrayList<String>>();
  FullInitialiser<Object> f=new FullInitialiser<Object>(model);
  List<CandidateProgram<Object>> firstPass=f.getInitialPopulation();
  for (  CandidateProgram<Object> c : firstPass) {
    AntRepresentation b=(AntRepresentation)semMod.codeToBehaviour(c.getRootNode());
    if (!b.isConstant()) {
      storage.add(b.getAntRepresentation());
    }
  }
  ArrayList<String> result;
  String oB=(""String_Node_Str"");
  String cB=(""String_Node_Str"");
  int partSize=10;
  while (storage.size() < model.getPopulationSize()) {
    int cFunc=rGen.nextInt(model.getFunctions().size());
    result=new ArrayList<String>();
    if (cFunc == 0) {
      ArrayList<String> part1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> part2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(part1) > partSize) {
        part1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(part2) > partSize) {
        part2=storage.get(rGen.nextInt(storage.size()));
      }
      result.add(oB);
      for (      String p : part1) {
        result.add(p);
      }
      result.add(cB);
      result.add(oB);
      for (      String p : part2) {
        result.add(p);
      }
      result.add(cB);
    }
 else     if (cFunc == 1) {
      ArrayList<String> p1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> p2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p1) > partSize) {
        p1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(p2) > partSize) {
        p2=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(p1,p2,""String_Node_Str"");
    }
 else     if (cFunc == 2) {
      ArrayList<String> p1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> p2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p1) > partSize) {
        p1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(p2) > partSize) {
        p2=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(p1,p2,""String_Node_Str"");
      ArrayList<String> p3=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p3) > partSize) {
        p3=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(result,p3,""String_Node_Str"");
    }
    result=semMod.condenseAntRep(result);
    if (!storage.contains(result) && result.size() > 2) {
      storage.add(result);
    }
  }
  List<CandidateProgram<Object>> firstGen=new ArrayList<CandidateProgram<Object>>();
  int i=1;
  for (  ArrayList<String> toProg : storage) {
    Node<Object> holder=semMod.behaviourToCode(new AntRepresentation(toProg));
    firstGen.add(new CandidateProgram<Object>(holder,model));
    i++;
  }
  storage=null;
  return firstGen;
}",0.9878337276106792
180727,"/** 
 * Constructor for semantically driven initialisation for artificial ant
 * @param model The GP model in use
 * @param semMod The semantic module on use
 */
public AntSemanticallyDrivenInitialiser(GPModel<Action> model,SemanticModule<Action> semMod){
  this.model=model;
  this.semMod=(AntSemanticModule)semMod;
}","/** 
 * Constructor for semantically driven initialisation for artificial ant
 * @param model The GP model in use
 * @param semMod The semantic module on use
 */
public AntSemanticallyDrivenInitialiser(GPModel<Object> model,SemanticModule<Object> semMod){
  this.model=model;
  this.semMod=(AntSemanticModule)semMod;
}",0.9622641509433962
180728,"@Override public List<CandidateProgram<Action>> getInitialPopulation(){
  return generatePopulation();
}","@Override public List<CandidateProgram<Object>> getInitialPopulation(){
  return generatePopulation();
}",0.9615384615384616
180729,"private List<CandidateProgram<Action>> generatePopulation(){
  Random rGen=new Random();
  ArrayList<ArrayList<String>> storage=new ArrayList<ArrayList<String>>();
  ArrayList<ArrayList<String>> seed=makeAntBaseMoves();
  for (  ArrayList<String> s : seed) {
    storage.add(s);
  }
  seed=null;
  ArrayList<String> result;
  String oB=(""String_Node_Str"");
  String cB=(""String_Node_Str"");
  int partSize=10;
  while (storage.size() < model.getPopulationSize()) {
    int cFunc=rGen.nextInt(model.getFunctions().size());
    result=new ArrayList<String>();
    if (cFunc == 0) {
      ArrayList<String> part1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> part2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(part1) > partSize) {
        part1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(part2) > partSize) {
        part2=storage.get(rGen.nextInt(storage.size()));
      }
      result.add(oB);
      for (      String p : part1) {
        result.add(p);
      }
      result.add(cB);
      result.add(oB);
      for (      String p : part2) {
        result.add(p);
      }
      result.add(cB);
    }
 else     if (cFunc == 1) {
      ArrayList<String> p1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> p2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p1) > partSize) {
        p1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(p2) > partSize) {
        p2=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(p1,p2,""String_Node_Str"");
    }
 else     if (cFunc == 2) {
      ArrayList<String> p1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> p2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p1) > partSize) {
        p1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(p2) > partSize) {
        p2=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(p1,p2,""String_Node_Str"");
      ArrayList<String> p3=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p3) > partSize) {
        p3=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(result,p3,""String_Node_Str"");
    }
    result=semMod.condenseAntRep(result);
    if (!storage.contains(result) && result.size() > 2) {
      storage.add(result);
    }
  }
  List<CandidateProgram<Action>> firstGen=new ArrayList<CandidateProgram<Action>>();
  int i=1;
  for (  ArrayList<String> toProg : storage) {
    Node<Action> holder=semMod.behaviourToCode(new AntRepresentation(toProg));
    firstGen.add(new CandidateProgram<Action>(holder,model));
    i++;
  }
  storage=null;
  return firstGen;
}","private List<CandidateProgram<Object>> generatePopulation(){
  Random rGen=new Random();
  ArrayList<ArrayList<String>> storage=new ArrayList<ArrayList<String>>();
  ArrayList<ArrayList<String>> seed=makeAntBaseMoves();
  for (  ArrayList<String> s : seed) {
    storage.add(s);
  }
  seed=null;
  ArrayList<String> result;
  String oB=(""String_Node_Str"");
  String cB=(""String_Node_Str"");
  int partSize=10;
  while (storage.size() < model.getPopulationSize()) {
    int cFunc=rGen.nextInt(model.getFunctions().size());
    result=new ArrayList<String>();
    if (cFunc == 0) {
      ArrayList<String> part1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> part2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(part1) > partSize) {
        part1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(part2) > partSize) {
        part2=storage.get(rGen.nextInt(storage.size()));
      }
      result.add(oB);
      for (      String p : part1) {
        result.add(p);
      }
      result.add(cB);
      result.add(oB);
      for (      String p : part2) {
        result.add(p);
      }
      result.add(cB);
    }
 else     if (cFunc == 1) {
      ArrayList<String> p1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> p2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p1) > partSize) {
        p1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(p2) > partSize) {
        p2=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(p1,p2,""String_Node_Str"");
    }
 else     if (cFunc == 2) {
      ArrayList<String> p1=storage.get(rGen.nextInt(storage.size()));
      ArrayList<String> p2=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p1) > partSize) {
        p1=storage.get(rGen.nextInt(storage.size()));
      }
      while (getMoves(p2) > partSize) {
        p2=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(p1,p2,""String_Node_Str"");
      ArrayList<String> p3=storage.get(rGen.nextInt(storage.size()));
      while (getMoves(p3) > partSize) {
        p3=storage.get(rGen.nextInt(storage.size()));
      }
      result=semMod.joinPaths(result,p3,""String_Node_Str"");
    }
    result=semMod.condenseAntRep(result);
    if (!storage.contains(result) && result.size() > 2) {
      storage.add(result);
    }
  }
  List<CandidateProgram<Object>> firstGen=new ArrayList<CandidateProgram<Object>>();
  int i=1;
  for (  ArrayList<String> toProg : storage) {
    Node<Object> holder=semMod.behaviourToCode(new AntRepresentation(toProg));
    firstGen.add(new CandidateProgram<Object>(holder,model));
    i++;
  }
  storage=null;
  return firstGen;
}",0.9927033929222912
180730,"@Override public List<CandidateProgram<TYPE>> getInitialPopulation(){
  int popSize=model.getPopulationSize();
  List<CandidateProgram<TYPE>> firstGen=new ArrayList<CandidateProgram<TYPE>>(popSize);
  this.semanticModule.start();
  for (int i=0; i < popSize; i++) {
    CandidateProgram<TYPE> candidate;
    Representation representation;
    do {
      candidate=new CandidateProgram<TYPE>(full.buildFullNodeTree(model.getInitialMaxDepth()),model);
      representation=semanticModule.codeToBehaviour(candidate);
    }
 while (firstGen.contains(candidate) || representation.isConstant());
    firstGen.add(candidate);
  }
  this.semanticModule.stop();
  return firstGen;
}","@Override public List<CandidateProgram<TYPE>> getInitialPopulation(){
  int popSize=model.getPopulationSize();
  List<CandidateProgram<TYPE>> firstGen=new ArrayList<CandidateProgram<TYPE>>(popSize);
  this.semanticModule.start();
  for (int i=0; i < popSize; i++) {
    CandidateProgram<TYPE> candidate;
    Representation representation;
    do {
      candidate=new CandidateProgram<TYPE>(full.buildFullNodeTree(model.getInitialMaxDepth()),model);
      representation=semanticModule.codeToBehaviour(candidate.getRootNode());
    }
 while (firstGen.contains(candidate) || representation.isConstant());
    firstGen.add(candidate);
  }
  this.semanticModule.stop();
  return firstGen;
}",0.9897058823529412
180731,"@Override public List<CandidateProgram<TYPE>> getInitialPopulation(){
  int popSize=model.getPopulationSize();
  List<CandidateProgram<TYPE>> firstGen=new ArrayList<CandidateProgram<TYPE>>(popSize);
  this.semanticModule.start();
  for (int i=0; i < popSize; i++) {
    CandidateProgram<TYPE> candidate;
    Representation representation;
    do {
      candidate=new CandidateProgram<TYPE>(full.buildFullNodeTree(model.getInitialMaxDepth()),model);
      representation=semanticModule.codeToBehaviour(candidate);
    }
 while (firstGen.contains(candidate) || representation.isConstant());
    firstGen.add(candidate);
  }
  for (int i=0; i < popSize; i++) {
    CandidateProgram<TYPE> candidate;
    Representation representation;
    Node<TYPE> reducedCandidate;
    candidate=firstGen.get(i);
    representation=semanticModule.codeToBehaviour(candidate);
    reducedCandidate=semanticModule.behaviourToCode(representation);
    firstGen.set(i,new CandidateProgram<TYPE>(reducedCandidate,model));
  }
  this.semanticModule.stop();
  return firstGen;
}","@Override public List<CandidateProgram<TYPE>> getInitialPopulation(){
  int popSize=model.getPopulationSize();
  List<CandidateProgram<TYPE>> firstGen=new ArrayList<CandidateProgram<TYPE>>(popSize);
  this.semanticModule.start();
  for (int i=0; i < popSize; i++) {
    CandidateProgram<TYPE> candidate;
    Representation representation;
    do {
      candidate=new CandidateProgram<TYPE>(full.buildFullNodeTree(model.getInitialMaxDepth()),model);
      representation=semanticModule.codeToBehaviour(candidate.getRootNode());
    }
 while (firstGen.contains(candidate) || representation.isConstant());
    firstGen.add(candidate);
  }
  for (int i=0; i < popSize; i++) {
    CandidateProgram<TYPE> candidate;
    Representation representation;
    Node<TYPE> reducedCandidate;
    candidate=firstGen.get(i);
    representation=semanticModule.codeToBehaviour(candidate.getRootNode());
    reducedCandidate=semanticModule.behaviourToCode(representation);
    firstGen.set(i,new CandidateProgram<TYPE>(reducedCandidate,model));
  }
  this.semanticModule.stop();
  return firstGen;
}",0.986879100281162
180732,"/** 
 * Runs the bias analyser
 * @param args No input parameters
 */
public static void main(String[] args){
  RegressionModelCUBIC model=new RegressionModelCUBIC();
  SemanticModule semMod=model.getSemanticModule();
  semMod.start();
  ArrayList<BehaviourManager> storage=new ArrayList<BehaviourManager>();
  for (int i=0; i < 100; i++) {
    RampedHalfAndHalfInitialiser rhh=new RampedHalfAndHalfInitialiser(model);
    model.setPopulationSize(1000);
    List<CandidateProgram> testPop=rhh.getInitialPopulation();
    for (    CandidateProgram prog : testPop) {
      Representation progRep=semMod.codeToBehaviour(prog);
      boolean match=false;
      for (      BehaviourManager bddMan : storage) {
        if (bddMan.getBehaviour().equals(progRep)) {
          match=true;
          bddMan.addProgram(prog);
        }
      }
      if (match == false) {
        BehaviourManager bddMan=new BehaviourManager(progRep);
        bddMan.addProgram(prog);
        storage.add(bddMan);
      }
    }
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + storage.size());
  ArrayList<String> output=new ArrayList<String>();
  BehaviourManager example=storage.get(0);
  if (example.getBehaviour() instanceof BooleanRepresentation) {
    output.add(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (example.getBehaviour() instanceof AntRepresentation) {
    output.add(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (example.getBehaviour() instanceof RegressionRepresentation) {
    output.add(""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < storage.size(); i++) {
    BehaviourManager thisOne=storage.get(i);
    if (thisOne.getBehaviour() instanceof BooleanRepresentation) {
      output.add(i + ""String_Node_Str"" + ((double)thisOne.getFrequency() / 100)+ ""String_Node_Str""+ ((BooleanRepresentation)thisOne.getBehaviour()).getBDD().nodeCount()+ ""String_Node_Str""+ ((BooleanRepresentation)thisOne.getBehaviour()).getBDD().satCount()+ ""String_Node_Str"");
    }
 else     if (thisOne.getBehaviour() instanceof AntRepresentation) {
      output.add(i + ""String_Node_Str"" + ((double)thisOne.getFrequency() / 100)+ ""String_Node_Str""+ countMoves(((AntRepresentation)thisOne.getBehaviour()).getAntRepresentation())+ ""String_Node_Str""+ getLastO(((AntRepresentation)thisOne.getBehaviour()).getAntRepresentation())+ ""String_Node_Str"");
    }
 else     if (thisOne.getBehaviour() instanceof RegressionRepresentation) {
      output.add(i + ""String_Node_Str"" + ((double)thisOne.getFrequency() / 100)+ ""String_Node_Str""+ ((RegressionRepresentation)thisOne.getBehaviour()).getRegressionRepresentation().size()+ ""String_Node_Str""+ ((RegressionRepresentation)thisOne.getBehaviour()).isConstant()+ ""String_Node_Str"");
    }
  }
  FileManip.doOutput(new File(""String_Node_Str""),output,""String_Node_Str"",false);
  semMod.stop();
}","/** 
 * Runs the bias analyser
 * @param args No input parameters
 */
public static void main(String[] args){
  RegressionModelCUBIC model=new RegressionModelCUBIC();
  SemanticModule semMod=model.getSemanticModule();
  semMod.start();
  ArrayList<BehaviourManager> storage=new ArrayList<BehaviourManager>();
  for (int i=0; i < 100; i++) {
    RampedHalfAndHalfInitialiser rhh=new RampedHalfAndHalfInitialiser(model);
    model.setPopulationSize(1000);
    List<CandidateProgram> testPop=rhh.getInitialPopulation();
    for (    CandidateProgram prog : testPop) {
      Representation progRep=semMod.codeToBehaviour(prog.getRootNode());
      boolean match=false;
      for (      BehaviourManager bddMan : storage) {
        if (bddMan.getBehaviour().equals(progRep)) {
          match=true;
          bddMan.addProgram(prog);
        }
      }
      if (match == false) {
        BehaviourManager bddMan=new BehaviourManager(progRep);
        bddMan.addProgram(prog);
        storage.add(bddMan);
      }
    }
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + storage.size());
  ArrayList<String> output=new ArrayList<String>();
  BehaviourManager example=storage.get(0);
  if (example.getBehaviour() instanceof BooleanRepresentation) {
    output.add(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (example.getBehaviour() instanceof AntRepresentation) {
    output.add(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (example.getBehaviour() instanceof RegressionRepresentation) {
    output.add(""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < storage.size(); i++) {
    BehaviourManager thisOne=storage.get(i);
    if (thisOne.getBehaviour() instanceof BooleanRepresentation) {
      output.add(i + ""String_Node_Str"" + ((double)thisOne.getFrequency() / 100)+ ""String_Node_Str""+ ((BooleanRepresentation)thisOne.getBehaviour()).getBDD().nodeCount()+ ""String_Node_Str""+ ((BooleanRepresentation)thisOne.getBehaviour()).getBDD().satCount()+ ""String_Node_Str"");
    }
 else     if (thisOne.getBehaviour() instanceof AntRepresentation) {
      output.add(i + ""String_Node_Str"" + ((double)thisOne.getFrequency() / 100)+ ""String_Node_Str""+ countMoves(((AntRepresentation)thisOne.getBehaviour()).getAntRepresentation())+ ""String_Node_Str""+ getLastO(((AntRepresentation)thisOne.getBehaviour()).getAntRepresentation())+ ""String_Node_Str"");
    }
 else     if (thisOne.getBehaviour() instanceof RegressionRepresentation) {
      output.add(i + ""String_Node_Str"" + ((double)thisOne.getFrequency() / 100)+ ""String_Node_Str""+ ((RegressionRepresentation)thisOne.getBehaviour()).getRegressionRepresentation().size()+ ""String_Node_Str""+ ((RegressionRepresentation)thisOne.getBehaviour()).isConstant()+ ""String_Node_Str"");
    }
  }
  FileManip.doOutput(new File(""String_Node_Str""),output,""String_Node_Str"",false);
  semMod.stop();
}",0.9975677553856844
180733,"/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  SantaFeTrail model=new SantaFeTrail();
  String modelName=""String_Node_Str"";
  model.setInitialMaxDepth(4);
  SemanticModule semMod=new AntSemanticModule(model.getTerminals(),model,model.getAnt(),model.getAntLandScape());
  FullInitialiser initialiser=new FullInitialiser(model);
  String genType=""String_Node_Str"";
  File place=new File(""String_Node_Str"");
  ArrayList<Integer> sizes=new ArrayList<Integer>();
  sizes.add(new Integer(500));
  sizes.add(new Integer(1000));
  sizes.add(new Integer(1500));
  sizes.add(new Integer(2000));
  sizes.add(new Integer(2500));
  sizes.add(new Integer(3000));
  sizes.add(new Integer(3500));
  sizes.add(new Integer(4000));
  sizes.add(new Integer(4500));
  sizes.add(new Integer(5000));
  ArrayList<Representation> behaviours;
  ArrayList<CandidateProgram> progs, newPop;
  ArrayList<String> dump;
  int syntaxSame, semanticSame;
  Representation specimin;
  for (  Integer size : sizes) {
    System.out.println(""String_Node_Str"" + size.toString());
    model.setPopulationSize(size);
    dump=new ArrayList<String>();
    dump.add(""String_Node_Str"" + genType + ""String_Node_Str""+ size.toString()+ ""String_Node_Str""+ modelName+ ""String_Node_Str"");
    dump.add(""String_Node_Str"");
    for (int i=0; i < 100; i++) {
      newPop=(ArrayList<CandidateProgram>)initialiser.getInitialPopulation();
      behaviours=new ArrayList<Representation>();
      progs=new ArrayList<CandidateProgram>();
      semMod.start();
      syntaxSame=0;
      semanticSame=0;
      for (      CandidateProgram testProg : newPop) {
        if (progs.contains(testProg)) {
          syntaxSame++;
        }
 else {
          progs.add(testProg);
        }
        specimin=semMod.codeToBehaviour(testProg);
        boolean marker=false;
        for (        Representation b : behaviours) {
          if (b.equals(specimin)) {
            semanticSame++;
            marker=true;
            break;
          }
        }
        if (!marker) {
          behaviours.add(specimin);
        }
      }
      dump.add(i + ""String_Node_Str"" + syntaxSame+ ""String_Node_Str""+ progs.size()+ ""String_Node_Str""+ semanticSame+ ""String_Node_Str""+ behaviours.size()+ ""String_Node_Str""+ size.toString()+ ""String_Node_Str"");
      semMod.stop();
      newPop=null;
      behaviours=null;
      progs=null;
      semMod=null;
      System.gc();
    }
    String name=genType + ""String_Node_Str"" + size.toString()+ ""String_Node_Str""+ modelName+ ""String_Node_Str"";
    FileManip.doOutput(place,dump,name,false);
    dump=null;
    System.gc();
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  SantaFeTrail model=new SantaFeTrail();
  String modelName=""String_Node_Str"";
  model.setInitialMaxDepth(4);
  SemanticModule semMod=new AntSemanticModule(model.getTerminals(),model.getAnt());
  FullInitialiser initialiser=new FullInitialiser(model);
  String genType=""String_Node_Str"";
  File place=new File(""String_Node_Str"");
  ArrayList<Integer> sizes=new ArrayList<Integer>();
  sizes.add(new Integer(500));
  sizes.add(new Integer(1000));
  sizes.add(new Integer(1500));
  sizes.add(new Integer(2000));
  sizes.add(new Integer(2500));
  sizes.add(new Integer(3000));
  sizes.add(new Integer(3500));
  sizes.add(new Integer(4000));
  sizes.add(new Integer(4500));
  sizes.add(new Integer(5000));
  ArrayList<Representation> behaviours;
  ArrayList<CandidateProgram> progs, newPop;
  ArrayList<String> dump;
  int syntaxSame, semanticSame;
  Representation specimin;
  for (  Integer size : sizes) {
    System.out.println(""String_Node_Str"" + size.toString());
    model.setPopulationSize(size);
    dump=new ArrayList<String>();
    dump.add(""String_Node_Str"" + genType + ""String_Node_Str""+ size.toString()+ ""String_Node_Str""+ modelName+ ""String_Node_Str"");
    dump.add(""String_Node_Str"");
    for (int i=0; i < 100; i++) {
      newPop=(ArrayList<CandidateProgram>)initialiser.getInitialPopulation();
      behaviours=new ArrayList<Representation>();
      progs=new ArrayList<CandidateProgram>();
      semMod.start();
      syntaxSame=0;
      semanticSame=0;
      for (      CandidateProgram testProg : newPop) {
        if (progs.contains(testProg)) {
          syntaxSame++;
        }
 else {
          progs.add(testProg);
        }
        specimin=semMod.codeToBehaviour(testProg.getRootNode());
        boolean marker=false;
        for (        Representation b : behaviours) {
          if (b.equals(specimin)) {
            semanticSame++;
            marker=true;
            break;
          }
        }
        if (!marker) {
          behaviours.add(specimin);
        }
      }
      dump.add(i + ""String_Node_Str"" + syntaxSame+ ""String_Node_Str""+ progs.size()+ ""String_Node_Str""+ semanticSame+ ""String_Node_Str""+ behaviours.size()+ ""String_Node_Str""+ size.toString()+ ""String_Node_Str"");
      semMod.stop();
      newPop=null;
      behaviours=null;
      progs=null;
      semMod=null;
      System.gc();
    }
    String name=genType + ""String_Node_Str"" + size.toString()+ ""String_Node_Str""+ modelName+ ""String_Node_Str"";
    FileManip.doOutput(place,dump,name,false);
    dump=null;
    System.gc();
  }
  System.out.println(""String_Node_Str"");
}",0.9919028340080972
180734,"/** 
 * Constructor for Ant Semantic Module
 * @param list List of terminal nodes
 * @param model The GPModel object
 * @param ant The Ant object
 * @param antLandscape The AntLanscape object
 */
public AntSemanticModule(List<TerminalNode<Action>> list,GPModel<Action> model,Ant ant,AntLandscape landscape){
  this.model=model;
  this.ant=ant;
  this.landscape=landscape;
}","/** 
 * Constructor for Ant Semantic Module
 * @param list List of terminal nodes
 * @param model The GPModel object
 * @param ant The Ant object
 * @param antLandscape The AntLanscape object
 */
public AntSemanticModule(List<TerminalNode<Action>> list,Ant ant,AntLandscape landscape){
  this.ant=ant;
  this.landscape=landscape;
}",0.8721590909090909
180735,"/** 
 * Build a full node tree with a given depth. As the node tree will be full  the maximum and minimum depths of the returned node tree should be equal  to the depth argument. The internal and leaf nodes will be selected from  the function and terminal sets respectively, as provided by the model.
 * @param depth The depth of the full node tree, where the depth is the number of nodes from the root.
 * @return The root node of a randomly generated full node tree of the requested depth.
 */
public Node<TYPE> buildFullNodeTree(int depth){
  int randomIndex=(int)Math.floor(Math.random() * model.getFunctions().size());
  Node<TYPE> root=(Node<TYPE>)model.getFunctions().get(randomIndex).clone();
  fillChildren(root,0,depth);
  return root;
}","/** 
 * Build a full node tree with a given depth. As the node tree will be full  the maximum and minimum depths of the returned node tree should be equal  to the depth argument. The internal and leaf nodes will be selected from  the function and terminal sets respectively, as provided by the model.
 * @param depth The depth of the full node tree, where the depth is the number of nodes from the root.
 * @return The root node of a randomly generated full node tree of the requested depth.
 */
public Node<TYPE> buildFullNodeTree(int depth){
  Node<TYPE> root;
  if (depth == 0) {
    int randomIndex=(int)Math.floor(Math.random() * model.getTerminals().size());
    root=(Node<TYPE>)model.getTerminals().get(randomIndex).clone();
  }
 else {
    int randomIndex=(int)Math.floor(Math.random() * model.getFunctions().size());
    root=(Node<TYPE>)model.getFunctions().get(randomIndex).clone();
    fillChildren(root,0,depth);
  }
  return root;
}",0.7874852420306966
180736,"/** 
 * Perform point mutation on the given CandidateProgram. Each node in the  program tree is considered in turn, with each having the given  probability of actually being exchanged. Given that a node is chosen  then a new function or terminal node of the same arity is used to  replace it.
 * @param program The CandidateProgram selected to undergo this mutation operation.
 * @return A CandidateProgram that was the result of a point mutation on the provided CandidateProgram.
 */
@Override public CandidateProgram<TYPE> mutate(CandidateProgram<TYPE> program){
  List<Node<TYPE>> syntax=model.getSyntax();
  int length=program.getProgramLength();
  for (int i=0; i < length; i++) {
    if (Math.random() < pointProbability) {
      Node<TYPE> node=(Node<TYPE>)program.getNthNode(i);
      int arity=node.getArity();
      int rand=(int)Math.floor(Math.random() * syntax.size());
      for (int j=0; j < syntax.size(); j++) {
        int index=(j + rand) % syntax.size();
        Node<TYPE> n=syntax.get(index);
        if (n.getArity() == arity) {
          n=(Node<TYPE>)n.clone();
          for (int k=0; k < arity; k++) {
            n.setChild(k,node.getChild(k));
          }
          program.setNthNode(i,n);
          break;
        }
      }
    }
  }
  return program;
}","/** 
 * Perform point mutation on the given CandidateProgram. Each node in the  program tree is considered in turn, with each having the given  probability of actually being exchanged. Given that a node is chosen  then a new function or terminal node of the same arity is used to  replace it.
 * @param program The CandidateProgram selected to undergo this mutation operation.
 * @return A CandidateProgram that was the result of a point mutation on the provided CandidateProgram.
 */
@Override public CandidateProgram<TYPE> mutate(CandidateProgram<TYPE> program){
  List<Node<TYPE>> syntax=model.getSyntax();
  int length=program.getProgramLength();
  for (int i=0; i < length; i++) {
    if (Math.random() < pointProbability) {
      Node<TYPE> node=(Node<TYPE>)program.getNthNode(i);
      int arity=node.getArity();
      int rand=(int)Math.floor(Math.random() * syntax.size());
      for (int j=0; j < syntax.size(); j++) {
        int index=(j + rand) % syntax.size();
        Node<TYPE> n=syntax.get(index);
        if ((n.getArity() == arity) && !nodesEqual(node,n)) {
          n=(Node<TYPE>)n.clone();
          for (int k=0; k < arity; k++) {
            n.setChild(k,node.getChild(k));
          }
          program.setNthNode(i,n);
          break;
        }
      }
    }
  }
  return program;
}",0.9903586579251832
180737,"private void run(){
  List<CandidateProgram<TYPE>> pop=model.getInitialiser().getInitialPopulation();
  genStats.addGen(pop,0,0,0,0);
  genloop:   for (int i=1; i <= model.getNoGenerations(); i++) {
    long genStartTime=System.nanoTime();
    int popSize=model.getPopulationSize();
    List<CandidateProgram<TYPE>> nextPop=new ArrayList<CandidateProgram<TYPE>>(popSize);
    int noElites=model.getNoElites();
    noElites=(noElites < popSize) ? noElites : popSize;
    nextPop.addAll(GPElitism.getElites(pop,noElites));
    List<CandidateProgram<TYPE>> pool=model.getPoolSelector().getPool(pop,model.getPoolSize());
    int crossoverReversions=0;
    int mutationReversions=0;
    model.getProgramSelector().onGenerationStart(pool);
    while (nextPop.size() < model.getPopulationSize()) {
      double random=model.getRNG().nextDouble();
      double pm=model.getMutationProbability();
      double pe=model.getCrossoverProbability();
      if (random < pe) {
        CandidateProgram<TYPE>[] children=crossover.crossover();
        for (        CandidateProgram<TYPE> c : children) {
          if (nextPop.size() < model.getPopulationSize())           nextPop.add(c);
        }
        crossoverReversions+=crossover.getRevertedCount();
      }
 else       if (random < pe + pm) {
        nextPop.add(mutation.mutate());
        mutationReversions+=mutation.getRevertedCount();
      }
 else {
        nextPop.add(pool.get(model.getRNG().nextInt(pool.size())));
      }
    }
    for (    CandidateProgram<TYPE> p : pop) {
      double fitness=model.getFitness(p);
      if (fitness < bestFitness) {
        bestFitness=fitness;
        bestProgram=p;
        if (bestFitness <= model.getTerminationFitness()) {
          break genloop;
        }
      }
    }
    long runtime=System.nanoTime() - genStartTime;
    genStats.addGen(nextPop,i,runtime,crossoverReversions,mutationReversions);
    pop=nextPop;
  }
  runEndTime=System.nanoTime();
}","private void run(){
  List<CandidateProgram<TYPE>> pop=model.getInitialiser().getInitialPopulation();
  genStats.addGen(pop,0,0,0,0);
  genloop:   for (int i=1; i <= model.getNoGenerations(); i++) {
    long genStartTime=System.nanoTime();
    int popSize=model.getPopulationSize();
    List<CandidateProgram<TYPE>> nextPop=new ArrayList<CandidateProgram<TYPE>>(popSize);
    int noElites=model.getNoElites();
    noElites=(noElites < popSize) ? noElites : popSize;
    nextPop.addAll(GPElitism.getElites(pop,noElites));
    List<CandidateProgram<TYPE>> pool=model.getPoolSelector().getPool(pop,model.getPoolSize());
    int crossoverReversions=0;
    int mutationReversions=0;
    model.getProgramSelector().onGenerationStart(pool);
    while (nextPop.size() < model.getPopulationSize()) {
      double random=model.getRNG().nextDouble();
      double pm=model.getMutationProbability();
      double pe=model.getCrossoverProbability();
      if (random < pe) {
        CandidateProgram<TYPE>[] children=crossover.crossover();
        for (        CandidateProgram<TYPE> c : children) {
          if (nextPop.size() < model.getPopulationSize())           nextPop.add(c);
        }
        crossoverReversions+=crossover.getRevertedCount();
      }
 else       if (random < pe + pm) {
        nextPop.add(mutation.mutate());
        mutationReversions+=mutation.getRevertedCount();
      }
 else {
        nextPop.add(pool.get(model.getRNG().nextInt(pool.size())));
      }
    }
    for (    CandidateProgram<TYPE> p : nextPop) {
      double fitness=model.getFitness(p);
      if (fitness < bestFitness) {
        bestFitness=fitness;
        bestProgram=p;
        if (bestFitness <= model.getTerminationFitness()) {
          break genloop;
        }
      }
    }
    long runtime=System.nanoTime() - genStartTime;
    genStats.addGen(nextPop,i,runtime,crossoverReversions,mutationReversions);
    pop=nextPop;
  }
  runEndTime=System.nanoTime();
}",0.9984615384615384
180738,"/** 
 * Evaluating an <code>IfFoodAheadFunction</code> involves identifying the  next location the ant would move to on the landscape were it to be moved.  If this position contains a food item then the first child is evaluated  and executed, else the second child is evaluated and executed. <p>One of the children will thus have been evaluated (triggering  execution of actions at the <code>TerminalNodes</code>) and then this  method which must return an Action, returns Action.DO_NOTHING which any   functions higher up in the program tree will execute, but with no  effect.</p>
 */
@Override public Action evaluate(){
  Point ahead=landscape.getNextLocation(ant.getLocation(),ant.getOrientation());
  if (landscape.isFoodLocation(ahead)) {
    ((Action)getChild(0).evaluate()).execute();
  }
 else {
    ((Action)getChild(1).evaluate()).execute();
  }
  return Action.DO_NOTHING;
}","/** 
 * Evaluating an <code>IfFoodAheadFunction</code> involves identifying the  next location the ant would move to on the landscape were it to be moved.  If this position contains a food item then the first child is evaluated  and executed, else the second child is evaluated and executed. <p>One of the children will thus have been evaluated (triggering  execution of actions at the <code>TerminalNodes</code>) and then this  method which must return an Action, returns Action.DO_NOTHING which any   functions higher up in the program tree will execute, but with no  effect.</p>
 */
@Override public Action evaluate(){
  if (ant.isFoodAhead()) {
    ((Action)getChild(0).evaluate()).execute();
  }
 else {
    ((Action)getChild(1).evaluate()).execute();
  }
  return Action.DO_NOTHING;
}",0.9277611940298508
180739,"private void gatherDistinctFunctionStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_AVE) || stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_STDEV) || stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_MAX)|| stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_MIN)) {
    double[] noDFunctions=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      noDFunctions[i]=pop.get(i).getNoDistinctFunctions();
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_AVE)) {
      stats.put(GenerationStatField.NO_DISTINCT_FUNCTIONS_AVE,Double.toString(ave(noDFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_STDEV)) {
      stats.put(GenerationStatField.NO_DISTINCT_FUNCTIONS_STDEV,Double.toString(stdev(noDFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_MAX)) {
      stats.put(GenerationStatField.NO_DISTINCT_FUNCTIONS_MAX,Double.toString(max(noDFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_MIN)) {
      stats.put(GenerationStatField.NO_DISTINCT_FUNCTIONS_MIN,Double.toString(min(noDFunctions)));
    }
  }
}","private void gatherDistinctFunctionStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_AVE) || stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_STDEV) || stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_MAX)|| stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_MIN)) {
    double[] noDFunctions=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      noDFunctions[i]=pop.get(i).getNoDistinctFunctions();
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_AVE)) {
      stats.put(GenerationStatField.NO_DISTINCT_FUNCTIONS_AVE,new Double(ave(noDFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_STDEV)) {
      stats.put(GenerationStatField.NO_DISTINCT_FUNCTIONS_STDEV,new Double(stdev(noDFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_MAX)) {
      stats.put(GenerationStatField.NO_DISTINCT_FUNCTIONS_MAX,new Double(max(noDFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_FUNCTIONS_MIN)) {
      stats.put(GenerationStatField.NO_DISTINCT_FUNCTIONS_MIN,new Double(min(noDFunctions)));
    }
  }
}",0.979591836734694
180740,"private void gatherDepthStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.DEPTH_AVE) || stats.containsKey(GenerationStatField.DEPTH_STDEV) || stats.containsKey(GenerationStatField.DEPTH_MAX)|| stats.containsKey(GenerationStatField.DEPTH_MIN)|| stats.containsKey(GenerationStatField.AVE_NODES_PER_DEPTH)) {
    double[] depths=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      depths[i]=pop.get(i).getProgramDepth();
    }
    if (stats.containsKey(GenerationStatField.DEPTH_AVE)) {
      stats.put(GenerationStatField.DEPTH_AVE,Double.toString(ave(depths)));
    }
    if (stats.containsKey(GenerationStatField.DEPTH_STDEV)) {
      stats.put(GenerationStatField.DEPTH_STDEV,Double.toString(stdev(depths)));
    }
    if (stats.containsKey(GenerationStatField.DEPTH_MAX)) {
      stats.put(GenerationStatField.DEPTH_MAX,Double.toString(max(depths)));
    }
    if (stats.containsKey(GenerationStatField.DEPTH_MIN)) {
      stats.put(GenerationStatField.DEPTH_MIN,Double.toString(min(depths)));
    }
    if (stats.containsKey(GenerationStatField.AVE_NODES_PER_DEPTH)) {
      stats.put(GenerationStatField.AVE_NODES_PER_DEPTH,getAveNodesPerDepth(pop));
    }
  }
}","private void gatherDepthStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.DEPTH_AVE) || stats.containsKey(GenerationStatField.DEPTH_STDEV) || stats.containsKey(GenerationStatField.DEPTH_MAX)|| stats.containsKey(GenerationStatField.DEPTH_MIN)|| stats.containsKey(GenerationStatField.AVE_NODES_PER_DEPTH)) {
    double[] depths=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      depths[i]=pop.get(i).getProgramDepth();
    }
    if (stats.containsKey(GenerationStatField.DEPTH_AVE)) {
      stats.put(GenerationStatField.DEPTH_AVE,new Double(ave(depths)));
    }
    if (stats.containsKey(GenerationStatField.DEPTH_STDEV)) {
      stats.put(GenerationStatField.DEPTH_STDEV,new Double(stdev(depths)));
    }
    if (stats.containsKey(GenerationStatField.DEPTH_MAX)) {
      stats.put(GenerationStatField.DEPTH_MAX,new Double(max(depths)));
    }
    if (stats.containsKey(GenerationStatField.DEPTH_MIN)) {
      stats.put(GenerationStatField.DEPTH_MIN,new Double(min(depths)));
    }
    if (stats.containsKey(GenerationStatField.AVE_NODES_PER_DEPTH)) {
      stats.put(GenerationStatField.AVE_NODES_PER_DEPTH,getAveNodesPerDepth(pop));
    }
  }
}",0.9791666666666666
180741,"private void gatherDistinctTerminalStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_AVE) || stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_STDEV) || stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_MAX)|| stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_MIN)) {
    double[] noDTerminals=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      noDTerminals[i]=pop.get(i).getNoDistinctTerminals();
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_AVE)) {
      stats.put(GenerationStatField.NO_DISTINCT_TERMINALS_AVE,Double.toString(ave(noDTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_STDEV)) {
      stats.put(GenerationStatField.NO_DISTINCT_TERMINALS_STDEV,Double.toString(stdev(noDTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_MAX)) {
      stats.put(GenerationStatField.NO_DISTINCT_TERMINALS_MAX,Double.toString(max(noDTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_MIN)) {
      stats.put(GenerationStatField.NO_DISTINCT_TERMINALS_MIN,Double.toString(min(noDTerminals)));
    }
  }
}","private void gatherDistinctTerminalStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_AVE) || stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_STDEV) || stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_MAX)|| stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_MIN)) {
    double[] noDTerminals=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      noDTerminals[i]=pop.get(i).getNoDistinctTerminals();
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_AVE)) {
      stats.put(GenerationStatField.NO_DISTINCT_TERMINALS_AVE,new Double(ave(noDTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_STDEV)) {
      stats.put(GenerationStatField.NO_DISTINCT_TERMINALS_STDEV,new Double(stdev(noDTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_MAX)) {
      stats.put(GenerationStatField.NO_DISTINCT_TERMINALS_MAX,new Double(max(noDTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_DISTINCT_TERMINALS_MIN)) {
      stats.put(GenerationStatField.NO_DISTINCT_TERMINALS_MIN,new Double(min(noDTerminals)));
    }
  }
}",0.979591836734694
180742,"private void gatherFunctionStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_AVE) || stats.containsKey(GenerationStatField.NO_FUNCTIONS_STDEV) || stats.containsKey(GenerationStatField.NO_FUNCTIONS_MAX)|| stats.containsKey(GenerationStatField.NO_FUNCTIONS_MIN)) {
    double[] noFunctions=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      noFunctions[i]=pop.get(i).getNoFunctions();
    }
    if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_AVE)) {
      stats.put(GenerationStatField.NO_FUNCTIONS_AVE,Double.toString(ave(noFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_STDEV)) {
      stats.put(GenerationStatField.NO_FUNCTIONS_STDEV,Double.toString(stdev(noFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_MAX)) {
      stats.put(GenerationStatField.NO_FUNCTIONS_MAX,Double.toString(max(noFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_MIN)) {
      stats.put(GenerationStatField.NO_FUNCTIONS_MIN,Double.toString(min(noFunctions)));
    }
  }
}","private void gatherFunctionStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_AVE) || stats.containsKey(GenerationStatField.NO_FUNCTIONS_STDEV) || stats.containsKey(GenerationStatField.NO_FUNCTIONS_MAX)|| stats.containsKey(GenerationStatField.NO_FUNCTIONS_MIN)) {
    double[] noFunctions=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      noFunctions[i]=pop.get(i).getNoFunctions();
    }
    if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_AVE)) {
      stats.put(GenerationStatField.NO_FUNCTIONS_AVE,new Double(ave(noFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_STDEV)) {
      stats.put(GenerationStatField.NO_FUNCTIONS_STDEV,new Double(stdev(noFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_MAX)) {
      stats.put(GenerationStatField.NO_FUNCTIONS_MAX,new Double(max(noFunctions)));
    }
    if (stats.containsKey(GenerationStatField.NO_FUNCTIONS_MIN)) {
      stats.put(GenerationStatField.NO_FUNCTIONS_MIN,new Double(min(noFunctions)));
    }
  }
}",0.9772727272727272
180743,"private void gatherFitnessStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.FITNESS_AVE) || stats.containsKey(GenerationStatField.FITNESS_STDEV) || stats.containsKey(GenerationStatField.FITNESS_MAX)|| stats.containsKey(GenerationStatField.FITNESS_MIN)|| stats.containsKey(GenerationStatField.FITNESS_MEDIAN)|| stats.containsKey(GenerationStatField.BEST_PROGRAM)|| stats.containsKey(GenerationStatField.FITNESS_CI_95)) {
    double[] fitnesses=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      fitnesses[i]=pop.get(i).getFitness();
    }
    int maxIndex=-1;
    int minIndex=-1;
    double stdev=-1;
    if (stats.containsKey(GenerationStatField.FITNESS_AVE)) {
      stats.put(GenerationStatField.FITNESS_AVE,Double.toString(ave(fitnesses)));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_STDEV)) {
      stdev=stdev(fitnesses);
      stats.put(GenerationStatField.FITNESS_STDEV,Double.toString(stdev));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_MAX)) {
      maxIndex=maxIndex(fitnesses);
      stats.put(GenerationStatField.FITNESS_MAX,Double.toString(fitnesses[maxIndex]));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_MIN)) {
      stats.put(GenerationStatField.FITNESS_MIN,Double.toString(min(fitnesses)));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_MEDIAN)) {
      stats.put(GenerationStatField.FITNESS_MEDIAN,Double.toString(median(fitnesses)));
    }
    if (stats.containsKey(GenerationStatField.BEST_PROGRAM)) {
      if (minIndex == -1) {
        minIndex=minIndex(fitnesses);
      }
      stats.put(GenerationStatField.BEST_PROGRAM,pop.get(minIndex));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_CI_95)) {
      if (stdev == -1) {
        stdev=stdev(fitnesses);
      }
      double ci=1.96 * (stdev / Math.sqrt(fitnesses.length));
      stats.put(GenerationStatField.FITNESS_CI_95,Double.toString(ci));
    }
  }
}","private void gatherFitnessStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.FITNESS_AVE) || stats.containsKey(GenerationStatField.FITNESS_STDEV) || stats.containsKey(GenerationStatField.FITNESS_MAX)|| stats.containsKey(GenerationStatField.FITNESS_MIN)|| stats.containsKey(GenerationStatField.FITNESS_MEDIAN)|| stats.containsKey(GenerationStatField.BEST_PROGRAM)|| stats.containsKey(GenerationStatField.FITNESS_CI_95)) {
    double[] fitnesses=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      fitnesses[i]=pop.get(i).getFitness();
    }
    int maxIndex=-1;
    int minIndex=-1;
    double stdev=-1;
    if (stats.containsKey(GenerationStatField.FITNESS_AVE)) {
      stats.put(GenerationStatField.FITNESS_AVE,new Double(ave(fitnesses)));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_STDEV)) {
      stdev=stdev(fitnesses);
      stats.put(GenerationStatField.FITNESS_STDEV,new Double(stdev));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_MAX)) {
      maxIndex=maxIndex(fitnesses);
      stats.put(GenerationStatField.FITNESS_MAX,new Double(fitnesses[maxIndex]));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_MIN)) {
      stats.put(GenerationStatField.FITNESS_MIN,new Double(min(fitnesses)));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_MEDIAN)) {
      stats.put(GenerationStatField.FITNESS_MEDIAN,new Double(median(fitnesses)));
    }
    if (stats.containsKey(GenerationStatField.BEST_PROGRAM)) {
      if (minIndex == -1) {
        minIndex=minIndex(fitnesses);
      }
      stats.put(GenerationStatField.BEST_PROGRAM,pop.get(minIndex));
    }
    if (stats.containsKey(GenerationStatField.FITNESS_CI_95)) {
      if (stdev == -1) {
        stdev=stdev(fitnesses);
      }
      double ci=1.96 * (stdev / Math.sqrt(fitnesses.length));
      stats.put(GenerationStatField.FITNESS_CI_95,new Double(ci));
    }
  }
}",0.9804020100502512
180744,"private void gatherLengthStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.LENGTH_AVE) || stats.containsKey(GenerationStatField.LENGTH_STDEV) || stats.containsKey(GenerationStatField.LENGTH_MAX)|| stats.containsKey(GenerationStatField.LENGTH_MIN)) {
    double[] lengths=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      lengths[i]=pop.get(i).getProgramLength();
    }
    if (stats.containsKey(GenerationStatField.LENGTH_AVE)) {
      stats.put(GenerationStatField.LENGTH_AVE,Double.toString(ave(lengths)));
    }
    if (stats.containsKey(GenerationStatField.LENGTH_STDEV)) {
      stats.put(GenerationStatField.LENGTH_STDEV,Double.toString(stdev(lengths)));
    }
    if (stats.containsKey(GenerationStatField.LENGTH_MAX)) {
      stats.put(GenerationStatField.LENGTH_MAX,Double.toString(max(lengths)));
    }
    if (stats.containsKey(GenerationStatField.LENGTH_MIN)) {
      stats.put(GenerationStatField.LENGTH_MIN,Double.toString(min(lengths)));
    }
  }
}","private void gatherLengthStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.LENGTH_AVE) || stats.containsKey(GenerationStatField.LENGTH_STDEV) || stats.containsKey(GenerationStatField.LENGTH_MAX)|| stats.containsKey(GenerationStatField.LENGTH_MIN)) {
    double[] lengths=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      lengths[i]=pop.get(i).getProgramLength();
    }
    if (stats.containsKey(GenerationStatField.LENGTH_AVE)) {
      stats.put(GenerationStatField.LENGTH_AVE,new Double(ave(lengths)));
    }
    if (stats.containsKey(GenerationStatField.LENGTH_STDEV)) {
      stats.put(GenerationStatField.LENGTH_STDEV,new Double(stdev(lengths)));
    }
    if (stats.containsKey(GenerationStatField.LENGTH_MAX)) {
      stats.put(GenerationStatField.LENGTH_MAX,new Double(max(lengths)));
    }
    if (stats.containsKey(GenerationStatField.LENGTH_MIN)) {
      stats.put(GenerationStatField.LENGTH_MIN,new Double(min(lengths)));
    }
  }
}",0.9751908396946564
180745,"private void gatherTerminalStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.NO_TERMINALS_AVE) || stats.containsKey(GenerationStatField.NO_TERMINALS_STDEV) || stats.containsKey(GenerationStatField.NO_TERMINALS_MAX)|| stats.containsKey(GenerationStatField.NO_TERMINALS_MIN)) {
    double[] noTerminals=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      noTerminals[i]=pop.get(i).getNoTerminals();
    }
    if (stats.containsKey(GenerationStatField.NO_TERMINALS_AVE)) {
      stats.put(GenerationStatField.NO_TERMINALS_AVE,Double.toString(ave(noTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_TERMINALS_STDEV)) {
      stats.put(GenerationStatField.NO_TERMINALS_STDEV,Double.toString(stdev(noTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_TERMINALS_MAX)) {
      stats.put(GenerationStatField.NO_TERMINALS_MAX,Double.toString(max(noTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_TERMINALS_MIN)) {
      stats.put(GenerationStatField.NO_TERMINALS_MIN,Double.toString(min(noTerminals)));
    }
  }
}","private void gatherTerminalStats(Map<GenerationStatField,Object> stats,List<CandidateProgram<TYPE>> pop){
  if (stats.containsKey(GenerationStatField.NO_TERMINALS_AVE) || stats.containsKey(GenerationStatField.NO_TERMINALS_STDEV) || stats.containsKey(GenerationStatField.NO_TERMINALS_MAX)|| stats.containsKey(GenerationStatField.NO_TERMINALS_MIN)) {
    double[] noTerminals=new double[pop.size()];
    for (int i=0; i < pop.size(); i++) {
      noTerminals[i]=pop.get(i).getNoTerminals();
    }
    if (stats.containsKey(GenerationStatField.NO_TERMINALS_AVE)) {
      stats.put(GenerationStatField.NO_TERMINALS_AVE,new Double(ave(noTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_TERMINALS_STDEV)) {
      stats.put(GenerationStatField.NO_TERMINALS_STDEV,new Double(stdev(noTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_TERMINALS_MAX)) {
      stats.put(GenerationStatField.NO_TERMINALS_MAX,new Double(max(noTerminals)));
    }
    if (stats.containsKey(GenerationStatField.NO_TERMINALS_MIN)) {
      stats.put(GenerationStatField.NO_TERMINALS_MIN,new Double(min(noTerminals)));
    }
  }
}",0.9772727272727272
180746,"/** 
 * Moves the ant's position one place in the direction it is currently  facing based upon its orientation. If the ant's new location on the  landscape contains a food pellet then the ant will attempt to eat it.  If the ant has reached its maximum number of allowed time steps then  this method will do nothing.
 */
public void move(){
  if (moves >= maxMoves) {
    return;
  }
  if (orientation == EAST) {
    if (xLocation < 31) {
      xLocation++;
    }
 else {
      xLocation=0;
    }
  }
 else   if (orientation == NORTH) {
    if (yLocation > 0) {
      yLocation--;
    }
 else {
      yLocation=31;
    }
  }
 else   if (orientation == WEST) {
    if (xLocation > 0) {
      xLocation--;
    }
 else {
      xLocation=31;
    }
  }
 else   if (orientation == SOUTH) {
    if (yLocation < 31) {
      yLocation++;
    }
 else {
      yLocation=0;
    }
  }
  moves++;
  if (landscape.isFoodLocation(getLocation())) {
    this.eatFood();
    landscape.removeFoodLocation(getLocation());
  }
}","/** 
 * Moves the ant's position one place in the direction it is currently  facing based upon its orientation. If the ant's new location on the  landscape contains a food pellet then the ant will attempt to eat it.  If the ant has reached its maximum number of allowed time steps then  this method will do nothing.
 */
public void move(){
  if (timesteps >= maxTimesteps) {
    return;
  }
  if (orientation == EAST) {
    if (xLocation < 31) {
      xLocation++;
    }
 else {
      xLocation=0;
    }
  }
 else   if (orientation == NORTH) {
    if (yLocation > 0) {
      yLocation--;
    }
 else {
      yLocation=31;
    }
  }
 else   if (orientation == WEST) {
    if (xLocation > 0) {
      xLocation--;
    }
 else {
      xLocation=31;
    }
  }
 else   if (orientation == SOUTH) {
    if (yLocation < 31) {
      yLocation++;
    }
 else {
      yLocation=0;
    }
  }
  timesteps++;
  if (landscape.isFoodLocation(getLocation())) {
    this.eatFood();
    landscape.removeFoodLocation(getLocation());
  }
}",0.9821958456973294
180747,"/** 
 * Turn the ant to the right relative to its current orientation. For  example, if calling getOrientation() returns EAST before calling this  method it will return SOUTH after calling this method. If the ant  has reached its maximum number of allowed time steps then this method  will do nothing.
 */
public void turnRight(){
  if (moves >= maxMoves) {
    return;
  }
  if (orientation == EAST) {
    orientation=SOUTH;
  }
 else   if (orientation == SOUTH) {
    orientation=WEST;
  }
 else   if (orientation == WEST) {
    orientation=NORTH;
  }
 else   if (orientation == NORTH) {
    orientation=EAST;
  }
  moves++;
}","/** 
 * Turn the ant to the right relative to its current orientation. For  example, if calling getOrientation() returns EAST before calling this  method it will return SOUTH after calling this method. If the ant  has reached its maximum number of allowed time steps then this method  will do nothing.
 */
public void turnRight(){
  if (timesteps >= maxTimesteps) {
    return;
  }
  if (orientation == EAST) {
    orientation=SOUTH;
  }
 else   if (orientation == SOUTH) {
    orientation=WEST;
  }
 else   if (orientation == WEST) {
    orientation=NORTH;
  }
 else   if (orientation == NORTH) {
    orientation=EAST;
  }
  timesteps++;
}",0.9716088328075708
180748,"/** 
 * Increments the number of food pellets the ant has eaten.
 */
public void eatFood(){
  if (moves >= maxMoves) {
    return;
  }
  foodEaten++;
}","/** 
 * Increments the number of food pellets the ant has eaten.
 */
public void eatFood(){
  if (timesteps >= maxTimesteps) {
    return;
  }
  foodEaten++;
}",0.9419354838709676
180749,"/** 
 * Skipping will cause the ant to fill one timestep without moving in its  ant landscape. This is required for the skip algorithm to prevent the  ant falling into dead ends.
 */
public void skip(){
  moves++;
}","/** 
 * Skipping will cause the ant to fill one timestep without moving in its  ant landscape. This is required for the skip algorithm to prevent the  ant falling into dead ends.
 */
public void skip(){
  timesteps++;
}",0.9723502304147466
180750,"/** 
 * Turn the ant to the left relative to its current orientation. For  example, if calling getOrientation() returns EAST before calling this  method it will return NORTH after calling this method. If the ant  has reached its maximum number of allowed time steps then this method  will do nothing.
 */
public void turnLeft(){
  if (moves >= maxMoves) {
    return;
  }
  if (orientation == EAST) {
    orientation=NORTH;
  }
 else   if (orientation == NORTH) {
    orientation=WEST;
  }
 else   if (orientation == WEST) {
    orientation=SOUTH;
  }
 else   if (orientation == SOUTH) {
    orientation=EAST;
  }
  moves++;
}","/** 
 * Turn the ant to the left relative to its current orientation. For  example, if calling getOrientation() returns EAST before calling this  method it will return NORTH after calling this method. If the ant  has reached its maximum number of allowed time steps then this method  will do nothing.
 */
public void turnLeft(){
  if (timesteps >= maxTimesteps) {
    return;
  }
  if (orientation == EAST) {
    orientation=NORTH;
  }
 else   if (orientation == NORTH) {
    orientation=WEST;
  }
 else   if (orientation == WEST) {
    orientation=SOUTH;
  }
 else   if (orientation == SOUTH) {
    orientation=EAST;
  }
  timesteps++;
}",0.971518987341772
180751,"/** 
 * Reset the ant using the same number of time steps and on the same  <code>AntLandscape</code>.
 */
public void reset(){
  orientation=EAST;
  moves=0;
  xLocation=0;
  yLocation=0;
  foodEaten=0;
}","/** 
 * Reset the ant using the same number of time steps and on the same  <code>AntLandscape</code>.
 */
public void reset(){
  orientation=EAST;
  timesteps=0;
  xLocation=0;
  yLocation=0;
  foodEaten=0;
}",0.970873786407767
180752,"/** 
 * Returns the maximum number of time steps the ant is allowed to  move. Turning, moving and skipping all count as one time step.
 * @return the maximum number of time steps the ant is allowed to move
 */
public int getMaxMoves(){
  return maxMoves;
}","/** 
 * Returns the maximum number of time steps the ant is allowed to  move. Turning, moving and skipping all count as one time step.
 * @return the maximum number of time steps the ant is allowed to move
 */
public int getMaxMoves(){
  return maxTimesteps;
}",0.9767441860465116
180753,"@Override public String toString(){
  return xLocation + ""String_Node_Str"" + yLocation+ ""String_Node_Str""+ orientation+ ""String_Node_Str""+ moves;
}","@Override public String toString(){
  return xLocation + ""String_Node_Str"" + yLocation+ ""String_Node_Str""+ orientation+ ""String_Node_Str""+ timesteps;
}",0.9731543624161074
180754,"/** 
 * Gets the number of time steps the ant has completed. Turning, moving and  skipping all count as one time step.
 * @return The number of time steps the ant has gone through.
 */
public int getMoves(){
  return moves;
}","/** 
 * Gets the number of time steps the ant has completed. Turning, moving and  skipping all count as one time step.
 * @return The number of time steps the ant has gone through.
 */
public int getMoves(){
  return timesteps;
}",0.973568281938326
180755,"/** 
 * Selects two parents by calling <code>getProgramSelector()</code> on the  instance of <code>GPModel</code> given at construction and submits them  to the <code>Crossover</code> operator which is obtained by calling  <code>getCrossover()</code> on the model.  <p>After a crossover is made, the controlling model is requested to  confirm the crossover by a call to <code>acceptCrossover()</code>. This  gives the model total control over whether a crossover is allowed to  proceed. If <code>acceptCrossover()</code> returns <code>false</code>  then the children are discarded and two new parents are selected and  attempted for crossover. The number of times the crossover was reverted  before being accepted is available through a call to  <code>getRevertedCount()</code>. <p>Even after a crossover has been accepted by the model, it may still  be prevented from proceeding if the program depth of either of the  children exceeds the max depth that the model defines. In the case that  the children do exceed the limit then the parents are returned as the  result. This does not count towards the number of reversions.
 * @return an array of CandidatePrograms generated through crossover. This is typically 2 child programs, but could in theory be any number  as returned by the Crossover operator in use.
 */
public CandidateProgram<TYPE>[] crossover(){
  long crossoverStartTime=System.nanoTime();
  CandidateProgram<TYPE> parent1;
  CandidateProgram<TYPE> parent2;
  CandidateProgram<TYPE> clone1;
  CandidateProgram<TYPE> clone2;
  CandidateProgram<TYPE>[] parents=null;
  CandidateProgram<TYPE>[] children=null;
  reversions=-1;
  boolean accepted=true;
  do {
    parent1=programSelector.getProgram();
    parent2=programSelector.getProgram();
    clone1=(CandidateProgram<TYPE>)parent1.clone();
    clone2=(CandidateProgram<TYPE>)parent2.clone();
    parents=new CandidateProgram[]{parent1,parent2};
    children=crossover.crossover(clone1,clone2);
    accepted=model.acceptCrossover(parents,children);
    reversions++;
  }
 while (!accepted);
  for (int i=0; i < children.length; i++) {
    if (children[i].getProgramDepth() > model.getMaxDepth()) {
      children[i]=(CandidateProgram<TYPE>)parents[i].clone();
    }
  }
  long runtime=System.nanoTime() - crossoverStartTime;
  crossoverStats.addCrossover(parents,children,runtime);
  return children;
}","/** 
 * Selects two parents by calling <code>getProgramSelector()</code> on the  instance of <code>GPModel</code> given at construction and submits them  to the <code>Crossover</code> operator which is obtained by calling  <code>getCrossover()</code> on the model.  <p>After a crossover is made, the controlling model is requested to  confirm the crossover by a call to <code>acceptCrossover()</code>. This  gives the model total control over whether a crossover is allowed to  proceed. If <code>acceptCrossover()</code> returns <code>false</code>  then the children are discarded and two new parents are selected and  attempted for crossover. The number of times the crossover was reverted  before being accepted is available through a call to  <code>getRevertedCount()</code>. <p>Even after a crossover has been accepted by the model, it may still  be prevented from proceeding if the program depth of either of the  children exceeds the max depth that the model defines. In the case that  the children do exceed the limit then the parents are returned as the  result. This does not count towards the number of reversions.
 * @return an array of CandidatePrograms generated through crossover. This is typically 2 child programs, but could in theory be any number  as returned by the Crossover operator in use.
 */
public CandidateProgram<TYPE>[] crossover(){
  long crossoverStartTime=System.nanoTime();
  CandidateProgram<TYPE> parent1;
  CandidateProgram<TYPE> parent2;
  CandidateProgram<TYPE> clone1;
  CandidateProgram<TYPE> clone2;
  CandidateProgram<TYPE>[] parents=null;
  CandidateProgram<TYPE>[] children=null;
  reversions=-1;
  boolean accepted=true;
  do {
    parent1=programSelector.getProgram();
    parent2=programSelector.getProgram();
    clone1=(CandidateProgram<TYPE>)parent1.clone();
    clone2=(CandidateProgram<TYPE>)parent2.clone();
    parents=new CandidateProgram[]{parent1,parent2};
    children=crossover.crossover(clone1,clone2);
    accepted=model.acceptCrossover(parents,children);
    reversions++;
  }
 while (!accepted);
  int replacement=0;
  for (int i=0; i < children.length; i++) {
    if (children[i].getProgramDepth() > model.getMaxDepth()) {
      if (replacement >= parents.length) {
        replacement=0;
      }
      children[i]=(CandidateProgram<TYPE>)parents[replacement].clone();
      replacement++;
    }
  }
  long runtime=System.nanoTime() - crossoverStartTime;
  crossoverStats.addCrossover(parents,children,runtime);
  return children;
}",0.9736842105263158
180756,"/** 
 * Crossover the two <code>CandidatePrograms</code> provided as arguments  using Koza crossover. The crossover points will be chosen from the  function or terminal sets with the probability assigned at construction  or the default value of 90% function node.
 * @param program1 The first CandidateProgram selected to undergo Koza crossover.
 * @param program2 The second CandidateProgram selected to undergo Koza crossover.
 */
@Override public CandidateProgram<TYPE>[] crossover(CandidateProgram<TYPE> program1,CandidateProgram<TYPE> program2){
  int swapPoint1=getCrossoverPoint(program1);
  int swapPoint2=getCrossoverPoint(program2);
  Node<TYPE> subtree1=(Node<TYPE>)program1.getNthNode(swapPoint1).clone();
  Node<TYPE> subtree2=(Node<TYPE>)program2.getNthNode(swapPoint2).clone();
  program1.setNthNode(swapPoint1,subtree2);
  program2.setNthNode(swapPoint2,subtree1);
  return new CandidateProgram[]{program1,program2};
}","/** 
 * Crossover the two <code>CandidatePrograms</code> provided as arguments  using Koza crossover. The crossover points will be chosen from the  function or terminal sets with the probability assigned at construction  or the default value of 90% function node.
 * @param program1 The first CandidateProgram selected to undergo Koza crossover.
 * @param program2 The second CandidateProgram selected to undergo Koza crossover.
 */
@Override public CandidateProgram<TYPE>[] crossover(CandidateProgram<TYPE> program1,CandidateProgram<TYPE> program2){
  int swapPoint1=getCrossoverPoint(program1);
  int swapPoint2=getCrossoverPoint(program2);
  Node<TYPE> subtree1=(Node<TYPE>)program1.getNthNode(swapPoint1);
  Node<TYPE> subtree2=(Node<TYPE>)program2.getNthNode(swapPoint2);
  program1.setNthNode(swapPoint1,subtree2);
  program2.setNthNode(swapPoint2,subtree1);
  return new CandidateProgram[]{program1,program2};
}",0.9913606911447084
180757,"/** 
 * Crossover the two <code>CandidatePrograms</code> provided as arguments  using uniform swap points. Random crossover points are chosen at random  in both programs, the genetic material at the points are then exchanged. The resulting programs are returned as new CandidateProgram objects.
 * @param program1 The first CandidateProgram selected to undergo uniform  point crossover.
 * @param program2 The second CandidateProgram selected to undergo uniform  point crossover.
 */
@Override public CandidateProgram<TYPE>[] crossover(CandidateProgram<TYPE> program1,CandidateProgram<TYPE> program2){
  int swapPoint1=(int)Math.floor(Math.random() * program1.getProgramLength());
  int swapPoint2=(int)Math.floor(Math.random() * program2.getProgramLength());
  Node<TYPE> subTree1=(Node<TYPE>)program1.getNthNode(swapPoint1).clone();
  Node<TYPE> subTree2=(Node<TYPE>)program2.getNthNode(swapPoint2).clone();
  program1.setNthNode(swapPoint1,subTree2);
  program2.setNthNode(swapPoint2,subTree1);
  return new CandidateProgram[]{program1,program2};
}","/** 
 * Crossover the two <code>CandidatePrograms</code> provided as arguments  using uniform swap points. Random crossover points are chosen at random  in both programs, the genetic material at the points are then exchanged. The resulting programs are returned as new CandidateProgram objects.
 * @param program1 The first CandidateProgram selected to undergo uniform  point crossover.
 * @param program2 The second CandidateProgram selected to undergo uniform  point crossover.
 */
@Override public CandidateProgram<TYPE>[] crossover(CandidateProgram<TYPE> program1,CandidateProgram<TYPE> program2){
  int swapPoint1=(int)Math.floor(Math.random() * program1.getProgramLength());
  int swapPoint2=(int)Math.floor(Math.random() * program2.getProgramLength());
  Node<TYPE> subTree1=(Node<TYPE>)program1.getNthNode(swapPoint1);
  Node<TYPE> subTree2=(Node<TYPE>)program2.getNthNode(swapPoint2);
  program1.setNthNode(swapPoint1,subTree2);
  program2.setNthNode(swapPoint2,subTree1);
  return new CandidateProgram[]{program1,program2};
}",0.9923298178331736
180758,"/** 
 * Will use grow initialisation on half the population and full on the other half. If  the population size is an odd number then the extra individual will be initialised with grow.
 */
public List<CandidateProgram<TYPE>> getInitialPopulation(){
  int popSize=model.getPopulationSize();
  List<CandidateProgram<TYPE>> firstGen=new ArrayList<CandidateProgram<TYPE>>(popSize);
  int startDepth=2;
  int endDepth=model.getInitialMaxDepth();
  if (endDepth < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  double programsPerDepth=(double)popSize / (endDepth - startDepth + 1);
  for (int i=0; i < popSize; i++) {
    int depth=(int)Math.floor((firstGen.size() / programsPerDepth) + startDepth);
    System.out.println(depth);
    CandidateProgram<TYPE> program;
    do {
      Node<TYPE> rootNode;
      if ((i % 2) == 0) {
        rootNode=grow.buildGrowNodeTree(depth);
      }
 else {
        rootNode=full.buildFullNodeTree(depth);
      }
      program=new CandidateProgram<TYPE>(rootNode,model);
    }
 while (firstGen.contains(program));
    firstGen.add(program);
  }
  return firstGen;
}","/** 
 * Will use grow initialisation on half the population and full on the other half. If  the population size is an odd number then the extra individual will be initialised with grow.
 */
public List<CandidateProgram<TYPE>> getInitialPopulation(){
  int popSize=model.getPopulationSize();
  List<CandidateProgram<TYPE>> firstGen=new ArrayList<CandidateProgram<TYPE>>(popSize);
  int startDepth=2;
  int endDepth=model.getInitialMaxDepth();
  if (endDepth < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  double programsPerDepth=(double)popSize / (endDepth - startDepth + 1);
  for (int i=0; i < popSize; i++) {
    int depth=(int)Math.floor((firstGen.size() / programsPerDepth) + startDepth);
    CandidateProgram<TYPE> program;
    do {
      Node<TYPE> rootNode;
      if ((i % 2) == 0) {
        rootNode=grow.buildGrowNodeTree(depth);
      }
 else {
        rootNode=full.buildFullNodeTree(depth);
      }
      program=new CandidateProgram<TYPE>(rootNode,model);
    }
 while (firstGen.contains(program));
    firstGen.add(program);
  }
  return firstGen;
}",0.9859537834164024
180759,"private void fillChildren(Node<TYPE> topNode,int currentDepth,int maxDepth){
  int arity=topNode.getArity();
  if (currentDepth < maxDepth) {
    for (int i=0; i < arity; i++) {
      int randomIndex=(int)Math.floor(Math.random() * model.getFunctions().size());
      Node<TYPE> child=(Node<TYPE>)model.getFunctions().get(randomIndex).clone();
      topNode.setChild(child,i);
      fillChildren(child,(currentDepth + 1),maxDepth);
    }
  }
 else {
    for (int i=0; i < arity; i++) {
      int randomIndex=(int)Math.floor(Math.random() * model.getTerminals().size());
      Node<TYPE> child=(Node<TYPE>)model.getTerminals().get(randomIndex).clone();
      topNode.setChild(child,i);
    }
  }
}","private void fillChildren(Node<TYPE> topNode,int currentDepth,int maxDepth){
  int arity=topNode.getArity();
  if (currentDepth < maxDepth - 1) {
    for (int i=0; i < arity; i++) {
      int randomIndex=(int)Math.floor(Math.random() * model.getFunctions().size());
      Node<TYPE> child=(Node<TYPE>)model.getFunctions().get(randomIndex).clone();
      topNode.setChild(child,i);
      fillChildren(child,(currentDepth + 1),maxDepth);
    }
  }
 else {
    for (int i=0; i < arity; i++) {
      int randomIndex=(int)Math.floor(Math.random() * model.getTerminals().size());
      Node<TYPE> child=(Node<TYPE>)model.getTerminals().get(randomIndex).clone();
      topNode.setChild(child,i);
    }
  }
}",0.997134670487106
180760,"private void fillChildren(Node<TYPE> topNode,int currentDepth,int maxDepth){
  int arity=topNode.getArity();
  if (arity > 0) {
    if (currentDepth < maxDepth) {
      for (int i=0; i < arity; i++) {
        int randomIndex=(int)Math.floor(Math.random() * model.getSyntax().size());
        Node<TYPE> child=(Node<TYPE>)model.getSyntax().get(randomIndex).clone();
        topNode.setChild(child,i);
        this.fillChildren(child,(currentDepth + 1),maxDepth);
      }
    }
 else {
      for (int i=0; i < arity; i++) {
        int randomIndex=(int)Math.floor(Math.random() * model.getTerminals().size());
        Node<TYPE> child=(Node<TYPE>)model.getTerminals().get(randomIndex).clone();
        topNode.setChild(child,i);
      }
    }
  }
}","private void fillChildren(Node<TYPE> topNode,int currentDepth,int maxDepth){
  int arity=topNode.getArity();
  if (arity > 0) {
    if (currentDepth < maxDepth - 1) {
      for (int i=0; i < arity; i++) {
        int randomIndex=(int)Math.floor(Math.random() * model.getSyntax().size());
        Node<TYPE> child=(Node<TYPE>)model.getSyntax().get(randomIndex).clone();
        topNode.setChild(child,i);
        this.fillChildren(child,(currentDepth + 1),maxDepth);
      }
    }
 else {
      for (int i=0; i < arity; i++) {
        int randomIndex=(int)Math.floor(Math.random() * model.getTerminals().size());
        Node<TYPE> child=(Node<TYPE>)model.getTerminals().get(randomIndex).clone();
        topNode.setChild(child,i);
      }
    }
  }
}",0.997326203208556
180761,"public int getDepth(){
  return countDepth(this,1,0);
}","public int getDepth(){
  return countDepth(this,0,0);
}",0.9818181818181818
180762,"/** 
 * Build a FULL node tree
 * @param depth The maximum depth of the node tree
 * @return The FULL node tree
 */
public Node<TYPE> buildFullNodeTree(int depth){
  int randomIndex=(int)Math.floor(Math.random() * model.getFunctions().size());
  Node<TYPE> top=(Node<TYPE>)model.getFunctions().get(randomIndex).clone();
  fillChildren(top,0,model.getInitialMaxDepth());
  return top;
}","/** 
 * Build a FULL node tree
 * @param depth The maximum depth of the node tree
 * @return The FULL node tree
 */
public Node<TYPE> buildFullNodeTree(int depth){
  int randomIndex=(int)Math.floor(Math.random() * model.getFunctions().size());
  Node<TYPE> top=(Node<TYPE>)model.getFunctions().get(randomIndex).clone();
  fillChildren(top,0,depth);
  return top;
}",0.958611481975968
180763,"/** 
 * Build a FULL node tree
 * @param depth The maximum depth of the node tree
 * @return The FULL node tree
 */
public Node<TYPE> buildFullNodeTree(int depth){
  int randomIndex=(int)Math.floor(Math.random() * model.getFunctions().size());
  Node<TYPE> top=(Node<TYPE>)model.getFunctions().get(randomIndex).clone();
  fillChildren(top,1,model.getInitialMaxDepth());
  return top;
}","/** 
 * Build a FULL node tree
 * @param depth The maximum depth of the node tree
 * @return The FULL node tree
 */
public Node<TYPE> buildFullNodeTree(int depth){
  int randomIndex=(int)Math.floor(Math.random() * model.getFunctions().size());
  Node<TYPE> top=(Node<TYPE>)model.getFunctions().get(randomIndex).clone();
  fillChildren(top,0,model.getInitialMaxDepth());
  return top;
}",0.9974025974025974
180764,"/** 
 * Builds a GROW generated node tree
 * @param depth The maximum depth of the node tree
 * @return The node tree
 */
public Node<TYPE> buildGrowNodeTree(int depth){
  int randomIndex=(int)Math.floor(Math.random() * model.getSyntax().size());
  Node<TYPE> top=(Node<TYPE>)model.getSyntax().get(randomIndex).clone();
  this.fillChildren(top,1,depth);
  return top;
}","/** 
 * Builds a GROW generated node tree
 * @param depth The maximum depth of the node tree
 * @return The node tree
 */
public Node<TYPE> buildGrowNodeTree(int depth){
  int randomIndex=(int)Math.floor(Math.random() * model.getSyntax().size());
  Node<TYPE> top=(Node<TYPE>)model.getSyntax().get(randomIndex).clone();
  this.fillChildren(top,0,depth);
  return top;
}",0.997289972899729
180765,"/** 
 * @param model The model being assessed
 * @param semMod The semantic module for this model
 */
public RampedHalfAndHalfInitialiser(GPModel<TYPE> model){
  this.model=model;
  grow=new GrowInitialiser<TYPE>(model);
  full=new FullInitialiser<TYPE>(model);
  if (model.getInitialMaxDepth() >= 6) {
    this.depth=model.getInitialMaxDepth() - 4;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * @param model The model being assessed
 * @param semMod The semantic module for this model
 */
public RampedHalfAndHalfInitialiser(GPModel<TYPE> model){
  this.model=model;
  grow=new GrowInitialiser<TYPE>(model);
  full=new FullInitialiser<TYPE>(model);
}",0.7634252539912917
180766,"/** 
 * Will use grow initialisation on half the population and full on the other half. If  the population size is an odd number then the extra individual will be initialised with grow.
 */
public List<CandidateProgram<TYPE>> getInitialPopulation(){
  int popSize=model.getPopulationSize();
  List<CandidateProgram<TYPE>> firstGen=new ArrayList<CandidateProgram<TYPE>>(popSize);
  int split=popSize / 5;
  int marker=popSize / 5;
  for (int i=0; i < popSize; i++) {
    if (i > split) {
      depth++;
      split=split + marker;
    }
    if (((i % 2) == 0)) {
      candidate=new CandidateProgram<TYPE>(grow.buildGrowNodeTree(depth),model);
      while (firstGen.contains(candidate)) {
        candidate=new CandidateProgram<TYPE>(grow.buildGrowNodeTree(depth),model);
      }
    }
 else {
      candidate=new CandidateProgram<TYPE>(full.buildFullNodeTree(depth),model);
      while (firstGen.contains(candidate)) {
        candidate=new CandidateProgram<TYPE>(full.buildFullNodeTree(depth),model);
      }
    }
    firstGen.add(candidate);
  }
  return firstGen;
}","/** 
 * Will use grow initialisation on half the population and full on the other half. If  the population size is an odd number then the extra individual will be initialised with grow.
 */
public List<CandidateProgram<TYPE>> getInitialPopulation(){
  if (model.getInitialMaxDepth() >= 6) {
    this.depth=model.getInitialMaxDepth() - 4;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int popSize=model.getPopulationSize();
  List<CandidateProgram<TYPE>> firstGen=new ArrayList<CandidateProgram<TYPE>>(popSize);
  int split=popSize / 5;
  int marker=popSize / 5;
  for (int i=0; i < popSize; i++) {
    if (i > split) {
      depth++;
      split=split + marker;
    }
    if (((i % 2) == 0)) {
      candidate=new CandidateProgram<TYPE>(grow.buildGrowNodeTree(depth),model);
      while (firstGen.contains(candidate)) {
        candidate=new CandidateProgram<TYPE>(grow.buildGrowNodeTree(depth),model);
      }
    }
 else {
      candidate=new CandidateProgram<TYPE>(full.buildFullNodeTree(depth),model);
      while (firstGen.contains(candidate)) {
        candidate=new CandidateProgram<TYPE>(full.buildFullNodeTree(depth),model);
      }
    }
    firstGen.add(candidate);
  }
  return firstGen;
}",0.92916123424598
180767,"/** 
 * Gets the best CandidatePrograms from the given population and returns  them. The number of programs returned will be either noElites or pop.size() if the size of the given population is smaller than noElites. Elites in  are defined as the very best programs in a population.
 * @param < TYPE > 	the return type of the CandidatePrograms being used.
 * @param pop	 	the population from which elites need to be retrieved.
 * @param noElites	the number of elites to obtain.
 * @return a list containing the noElites best CandidatePrograms determined by fitness. If noElites is less than the population  size then the returned list will contain all CandidatePrograms  from the population.
 */
public static <TYPE>List<CandidateProgram<TYPE>> getElites(List<CandidateProgram<TYPE>> pop,int noElites){
  List<CandidateProgram<TYPE>> elites=new ArrayList<CandidateProgram<TYPE>>(noElites);
  if (noElites > 0) {
    Collections.sort(pop);
    elites.addAll(pop.subList(pop.size() - noElites,pop.size() - 1));
  }
  return elites;
}","/** 
 * Gets the best CandidatePrograms from the given population and returns  them. The number of programs returned will be either noElites or pop.size() if the size of the given population is smaller than noElites. Elites in  are defined as the very best programs in a population.
 * @param < TYPE > 	the return type of the CandidatePrograms being used.
 * @param pop	 	the population from which elites need to be retrieved.
 * @param noElites	the number of elites to obtain.
 * @return a list containing the noElites best CandidatePrograms determined by fitness. If noElites is less than the population  size then the returned list will contain all CandidatePrograms  from the population.
 */
public static <TYPE>List<CandidateProgram<TYPE>> getElites(List<CandidateProgram<TYPE>> pop,int noElites){
  List<CandidateProgram<TYPE>> elites=new ArrayList<CandidateProgram<TYPE>>(noElites);
  if (noElites > 0) {
    Collections.sort(pop);
    elites.addAll(pop.subList(pop.size() - noElites,pop.size()));
  }
  return elites;
}",0.9980563654033042
180768,"/** 
 * Adds to signed polynomials to the simplification tool
 * @param polynomialToAdd
 */
public void addPolynomial(CoefficientVariablePowerFunction polynomialToAdd){
  listOfPolynomials.add(polynomialToAdd);
}","/** 
 * Adds to signed polynomials to the simplification tool
 * @param polynomialToAdd
 */
public void addPolynomial(CoefficientExponentFunction polynomialToAdd){
  listOfPolynomials.add(polynomialToAdd);
}",0.9498806682577564
180769,"/** 
 * Constructor for RegressionCVPSimplificationTool
 */
public RegressionCVPSimplificationTool(){
  listOfPolynomials=new ArrayList<CoefficientVariablePowerFunction>();
}","/** 
 * Constructor for RegressionCVPSimplificationTool
 */
public RegressionCVPSimplificationTool(){
  listOfPolynomials=new ArrayList<CoefficientExponentFunction>();
}",0.9446064139941692
180770,"private Node<Double> reduceToCVPFormat(Node<Double> rootNode){
  int arity=rootNode.getArity();
  if (arity > 0) {
    Node[] children=rootNode.getChildren();
    for (int i=0; i < arity; i++) {
      rootNode.setChild(this.reduceToCVPFormat(children[i]),i);
    }
    if (rootNode instanceof MultiplyFunction) {
      if ((children[0] instanceof Variable) && (children[1] instanceof TerminalNode)) {
        rootNode=new CoefficientVariablePowerFunction(children[1],children[0],new TerminalNode<Double>(1d));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof Variable)) {
        rootNode=new CoefficientVariablePowerFunction(children[0],children[1],new TerminalNode<Double>(1d));
      }
 else       if ((children[0] instanceof PowerFunction) && (children[1] instanceof TerminalNode)) {
        rootNode=new CoefficientVariablePowerFunction(children[1],children[0].getChild(0),children[0].getChild(1));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof PowerFunction)) {
        rootNode=new CoefficientVariablePowerFunction(children[0],children[1].getChild(0),children[1].getChild(1));
      }
 else       if ((children[0] instanceof CoefficientVariablePowerFunction) && (children[1] instanceof TerminalNode)) {
        double coefficient=(Double)children[0].getChild(0).evaluate();
        double terminal=(Double)children[1].evaluate();
        double newCoefficient=coefficient * terminal;
        rootNode=new CoefficientVariablePowerFunction(new TerminalNode<Double>(newCoefficient),children[0].getChild(1),children[0].getChild(2));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof CoefficientVariablePowerFunction)) {
        double coefficient=(Double)children[1].getChild(0).evaluate();
        double terminal=(Double)children[0].evaluate();
        double newCoefficient=coefficient * terminal;
        rootNode=new CoefficientVariablePowerFunction(new TerminalNode<Double>(newCoefficient),children[1].getChild(1),children[1].getChild(2));
      }
    }
 else     if (rootNode instanceof ProtectedDivisionFunction) {
      if ((children[0] instanceof Variable) && (children[1] instanceof TerminalNode)) {
        double terminal=(Double)children[1].evaluate();
        double newCoefficient=1 / terminal;
        rootNode=new CoefficientVariablePowerFunction(new TerminalNode<Double>(newCoefficient),children[0],new TerminalNode<Double>(1d));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof Variable)) {
        rootNode=new CoefficientVariablePowerFunction(children[0],children[1],new TerminalNode<Double>(-1d));
      }
 else       if ((children[0] instanceof PowerFunction) && (children[1] instanceof TerminalNode)) {
        double terminal=(Double)children[1].evaluate();
        double newCoefficient=1 / terminal;
        rootNode=new CoefficientVariablePowerFunction(new TerminalNode<Double>(newCoefficient),children[0].getChild(0),children[0].getChild(1));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof PowerFunction)) {
        double power=(Double)children[1].getChild(1).evaluate();
        double newPower=power * -1;
        rootNode=new CoefficientVariablePowerFunction(children[0],children[1].getChild(0),new TerminalNode<Double>(newPower));
      }
 else       if ((children[0] instanceof CoefficientVariablePowerFunction) && (children[1] instanceof TerminalNode)) {
        double coefficient=(Double)children[0].getChild(0).evaluate();
        double terminal=(Double)children[1].evaluate();
        double newCoefficient=coefficient / terminal;
        rootNode=new CoefficientVariablePowerFunction(new TerminalNode<Double>(newCoefficient),children[0].getChild(1),children[0].getChild(2));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof CoefficientVariablePowerFunction)) {
        double coefficient=(Double)children[1].getChild(0).evaluate();
        double terminal=(Double)children[0].evaluate();
        double newCoefficient=terminal / coefficient;
        double power=(Double)children[1].getChild(2).evaluate();
        double newPower=power * -1;
        rootNode=new CoefficientVariablePowerFunction(new TerminalNode<Double>(newCoefficient),children[1].getChild(1),new TerminalNode<Double>(newPower));
      }
    }
  }
  return rootNode;
}","private Node<Double> reduceToCVPFormat(Node<Double> rootNode){
  int arity=rootNode.getArity();
  if (arity > 0) {
    Node[] children=rootNode.getChildren();
    for (int i=0; i < arity; i++) {
      rootNode.setChild(this.reduceToCVPFormat(children[i]),i);
    }
    if (rootNode instanceof MultiplyFunction) {
      if ((children[0] instanceof Variable) && (children[1] instanceof TerminalNode)) {
        rootNode=new CoefficientExponentFunction(children[1],children[0],new TerminalNode<Double>(1d));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof Variable)) {
        rootNode=new CoefficientExponentFunction(children[0],children[1],new TerminalNode<Double>(1d));
      }
 else       if ((children[0] instanceof PowerFunction) && (children[1] instanceof TerminalNode)) {
        rootNode=new CoefficientExponentFunction(children[1],children[0].getChild(0),children[0].getChild(1));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof PowerFunction)) {
        rootNode=new CoefficientExponentFunction(children[0],children[1].getChild(0),children[1].getChild(1));
      }
 else       if ((children[0] instanceof CoefficientExponentFunction) && (children[1] instanceof TerminalNode)) {
        double coefficient=(Double)children[0].getChild(0).evaluate();
        double terminal=(Double)children[1].evaluate();
        double newCoefficient=coefficient * terminal;
        rootNode=new CoefficientExponentFunction(new TerminalNode<Double>(newCoefficient),children[0].getChild(1),children[0].getChild(2));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof CoefficientExponentFunction)) {
        double coefficient=(Double)children[1].getChild(0).evaluate();
        double terminal=(Double)children[0].evaluate();
        double newCoefficient=coefficient * terminal;
        rootNode=new CoefficientExponentFunction(new TerminalNode<Double>(newCoefficient),children[1].getChild(1),children[1].getChild(2));
      }
    }
 else     if (rootNode instanceof ProtectedDivisionFunction) {
      if ((children[0] instanceof Variable) && (children[1] instanceof TerminalNode)) {
        double terminal=(Double)children[1].evaluate();
        double newCoefficient=1 / terminal;
        rootNode=new CoefficientExponentFunction(new TerminalNode<Double>(newCoefficient),children[0],new TerminalNode<Double>(1d));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof Variable)) {
        rootNode=new CoefficientExponentFunction(children[0],children[1],new TerminalNode<Double>(-1d));
      }
 else       if ((children[0] instanceof PowerFunction) && (children[1] instanceof TerminalNode)) {
        double terminal=(Double)children[1].evaluate();
        double newCoefficient=1 / terminal;
        rootNode=new CoefficientExponentFunction(new TerminalNode<Double>(newCoefficient),children[0].getChild(0),children[0].getChild(1));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof PowerFunction)) {
        double power=(Double)children[1].getChild(1).evaluate();
        double newPower=power * -1;
        rootNode=new CoefficientExponentFunction(children[0],children[1].getChild(0),new TerminalNode<Double>(newPower));
      }
 else       if ((children[0] instanceof CoefficientExponentFunction) && (children[1] instanceof TerminalNode)) {
        double coefficient=(Double)children[0].getChild(0).evaluate();
        double terminal=(Double)children[1].evaluate();
        double newCoefficient=coefficient / terminal;
        rootNode=new CoefficientExponentFunction(new TerminalNode<Double>(newCoefficient),children[0].getChild(1),children[0].getChild(2));
      }
 else       if ((children[0] instanceof TerminalNode) && (children[1] instanceof CoefficientExponentFunction)) {
        double coefficient=(Double)children[1].getChild(0).evaluate();
        double terminal=(Double)children[0].evaluate();
        double newCoefficient=terminal / coefficient;
        double power=(Double)children[1].getChild(2).evaluate();
        double newPower=power * -1;
        rootNode=new CoefficientExponentFunction(new TerminalNode<Double>(newCoefficient),children[1].getChild(1),new TerminalNode<Double>(newPower));
      }
    }
  }
  return rootNode;
}",0.9617050376111238
180771,"public GPConfig(){
  noRuns=1;
  noGenerations=1;
  populationSize=10;
  maxDepth=4;
  crossoverProbability=1;
  reproductionProbability=0;
  terminals=new ArrayList<TerminalNode<?>>();
  functions=new ArrayList<FunctionNode<?>>();
  initialiser=new FullInitialiser(this);
  crossover=new UniformPointCrossover(this);
}","public GPConfig(){
  noRuns=1;
  noGenerations=10;
  populationSize=10;
  maxDepth=4;
  crossoverProbability=1;
  reproductionProbability=0;
  terminals=new ArrayList<TerminalNode<?>>();
  functions=new ArrayList<FunctionNode<?>>();
  initialiser=new FullInitialiser(this);
  crossover=new UniformPointCrossover(this);
}",0.9984350547730828
180772,"public static int getProgramLength(Node rootNode){
  return GPProgramAnalyser.countLength(rootNode,0);
}","/** 
 * ALTERNATIVE IMPLEMENTATION Calculates the length - that is the number of nodes - of the program.
 * @param prog The program to be measured
 * @return The length of the program
 */
public static int getProgramLength(Node rootNode){
  return GPProgramAnalyser.countLength(rootNode,0);
}",0.5252525252525253
180773,"private void outputProgram(CandidateProgram program){
  System.out.println(""String_Node_Str"");
  System.out.println(program);
  System.out.println(model.getFitness(program));
  System.out.println(""String_Node_Str"" + GPProgramAnalyser.getProgramDepth(program));
  System.out.println(""String_Node_Str"" + GPProgramAnalyser.getProgramLength(program));
}","private void outputProgram(CandidateProgram program){
  System.out.println(""String_Node_Str"");
  System.out.println(program);
  System.out.println(""String_Node_Str"" + model.getFitness(program));
  System.out.println(""String_Node_Str"" + GPProgramAnalyser.getProgramDepth(program));
  System.out.println(""String_Node_Str"" + GPProgramAnalyser.getProgramLength(program));
}",0.9721448467966574
180774,"@Override public CandidateProgram[] crossover(CandidateProgram parent1,CandidateProgram parent2){
  CandidateProgram child1=null;
  CandidateProgram child2=null;
  try {
    child1=(CandidateProgram)parent1.clone();
    child2=(CandidateProgram)parent2.clone();
  }
 catch (  CloneNotSupportedException e1) {
    e1.printStackTrace();
  }
  if (Math.random() < config.getCrossoverProbability()) {
    int swapPoint1=(int)Math.floor(Math.random() * GPProgramAnalyser.getProgramLength(parent1));
    int swapPoint2=(int)Math.floor(Math.random() * GPProgramAnalyser.getProgramLength(parent2));
    if (swapPoint1 == 0 || swapPoint2 == 0) {
      System.out.println(""String_Node_Str"");
    }
    try {
      Node subTree1=(Node)child1.getNthNode(swapPoint1).clone();
      Node subTree2=(Node)child2.getNthNode(swapPoint2).clone();
      child1.setNthNode(subTree2,swapPoint1);
      child2.setNthNode(subTree1,swapPoint2);
    }
 catch (    CloneNotSupportedException e) {
      e.printStackTrace();
    }
    int pDepth1=GPProgramAnalyser.getProgramDepth(child1);
    int pDepth2=GPProgramAnalyser.getProgramDepth(child2);
    if (pDepth1 > config.getMaxDepth()) {
      try {
        child1=(CandidateProgram)parent1.clone();
      }
 catch (      CloneNotSupportedException e) {
        e.printStackTrace();
      }
    }
    if (pDepth2 > config.getMaxDepth()) {
      try {
        child2=(CandidateProgram)parent2.clone();
      }
 catch (      CloneNotSupportedException e) {
        e.printStackTrace();
      }
    }
  }
  return new CandidateProgram[]{child1,child2};
}","@Override public CandidateProgram[] crossover(CandidateProgram parent1,CandidateProgram parent2){
  CandidateProgram child1=null;
  CandidateProgram child2=null;
  try {
    child1=(CandidateProgram)parent1.clone();
    child2=(CandidateProgram)parent2.clone();
  }
 catch (  CloneNotSupportedException e1) {
    e1.printStackTrace();
  }
  if (Math.random() < config.getCrossoverProbability()) {
    int swapPoint1=(int)Math.floor(Math.random() * GPProgramAnalyser.getProgramLength(parent1));
    int swapPoint2=(int)Math.floor(Math.random() * GPProgramAnalyser.getProgramLength(parent2));
    try {
      Node subTree1=(Node)child1.getNthNode(swapPoint1).clone();
      Node subTree2=(Node)child2.getNthNode(swapPoint2).clone();
      child1.setNthNode(subTree2,swapPoint1);
      child2.setNthNode(subTree1,swapPoint2);
    }
 catch (    CloneNotSupportedException e) {
      e.printStackTrace();
    }
    int pDepth1=GPProgramAnalyser.getProgramDepth(child1);
    int pDepth2=GPProgramAnalyser.getProgramDepth(child2);
    if (pDepth1 > config.getMaxDepth()) {
      try {
        child1=(CandidateProgram)parent1.clone();
      }
 catch (      CloneNotSupportedException e) {
        e.printStackTrace();
      }
    }
    if (pDepth2 > config.getMaxDepth()) {
      try {
        child2=(CandidateProgram)parent2.clone();
      }
 catch (      CloneNotSupportedException e) {
        e.printStackTrace();
      }
    }
  }
  return new CandidateProgram[]{child1,child2};
}",0.9682487725040916
180775,"private void fillChildren(Node topNode,int currentDepth,int maxDepth){
  int arity=topNode.getArity();
  if (currentDepth < maxDepth - 1) {
    for (int i=0; i < arity; i++) {
      int randomIndex=(int)Math.floor(Math.random() * config.getFunctions().size());
      Node child=null;
      try {
        child=(Node)config.getFunctions().get(randomIndex).clone();
      }
 catch (      CloneNotSupportedException e) {
        e.printStackTrace();
      }
      topNode.setChild(child,i);
      this.fillChildren(child,(currentDepth + 1),maxDepth);
    }
  }
 else {
    for (int i=0; i < arity; i++) {
      int randomIndex=(int)Math.floor(Math.random() * config.getTerminals().size());
      Node child=null;
      try {
        child=(Node)config.getTerminals().get(randomIndex).clone();
      }
 catch (      CloneNotSupportedException e) {
        e.printStackTrace();
      }
      topNode.setChild(child,i);
    }
  }
}","private void fillChildren(Node topNode,int currentDepth,int maxDepth){
  int arity=topNode.getArity();
  if (currentDepth < maxDepth - 1) {
    for (int i=0; i < arity; i++) {
      int randomIndex=(int)Math.floor(Math.random() * config.getFunctions().size());
      Node child=null;
      try {
        child=(Node)config.getFunctions().get(randomIndex).clone();
      }
 catch (      CloneNotSupportedException e) {
        e.printStackTrace();
      }
      topNode.setChild(child,i);
      fillChildren(child,(currentDepth + 1),maxDepth);
    }
  }
 else {
    for (int i=0; i < arity; i++) {
      int randomIndex=(int)Math.floor(Math.random() * config.getTerminals().size());
      Node child=null;
      try {
        child=(Node)config.getTerminals().get(randomIndex).clone();
      }
 catch (      CloneNotSupportedException e) {
        e.printStackTrace();
      }
      topNode.setChild(child,i);
    }
  }
}",0.997289972899729
180776,"@Override public Object clone() throws CloneNotSupportedException {
  Node<TYPE> clone=(Node<TYPE>)super.clone();
  clone.setChildren(this.children.clone());
  return clone;
}","@Override public Object clone() throws CloneNotSupportedException {
  Node<TYPE> clone=(Node<TYPE>)super.clone();
  clone.children=this.children.clone();
  for (int i=0; i < children.length; i++) {
    clone.children[i]=this.children[i];
    if (clone.children[i] != null)     clone.children[i]=(Node<?>)clone.children[i].clone();
  }
  return clone;
}",0.5199240986717267
180777,"public void run(GPModel<TYPE> model){
  this.model=model;
  GPCrossover crossover=new GPCrossover(model);
  Initialiser init=model.getInitialiser();
  List<CandidateProgram<TYPE>> pop=init.getInitialPopulation();
  double bestFitness=Double.POSITIVE_INFINITY;
  CandidateProgram<?> bestProgram=null;
  for (int i=1; i <= model.getNoGenerations(); i++) {
    List<CandidateProgram<TYPE>> nextPop=new ArrayList<CandidateProgram<TYPE>>();
    List<CandidateProgram<TYPE>> poule=model.getPouleSelector().getPoule(pop,model.getPouleSize());
    while (nextPop.size() < model.getPopulationSize()) {
      double random=Math.random();
      double pr=model.getReproductionProbability();
      double pe=model.getCrossoverProbability();
      if (random < pr) {
        nextPop.add(poule.get((int)Math.floor(Math.random() * poule.size())));
      }
 else       if (random < pr + pe) {
        CandidateProgram<TYPE>[] children=crossover.crossover(poule);
        for (        CandidateProgram<TYPE> c : children) {
          if (nextPop.size() < model.getPopulationSize())           nextPop.add(c);
        }
      }
 else {
      }
    }
    for (    CandidateProgram<TYPE> p : pop) {
      double fitness=model.getFitness(p);
      if (fitness < bestFitness) {
        bestFitness=fitness;
        bestProgram=p;
      }
    }
    pop=nextPop;
  }
  System.out.println(""String_Node_Str"" + bestProgram);
  System.out.println(""String_Node_Str"" + bestFitness);
  System.out.println();
}","public void run(GPModel<TYPE> model){
  this.model=model;
  GPCrossover<TYPE> crossover=new GPCrossover<TYPE>(model);
  Initialiser<TYPE> init=model.getInitialiser();
  List<CandidateProgram<TYPE>> pop=init.getInitialPopulation();
  double bestFitness=Double.POSITIVE_INFINITY;
  CandidateProgram<?> bestProgram=null;
  for (int i=1; i <= model.getNoGenerations(); i++) {
    List<CandidateProgram<TYPE>> nextPop=new ArrayList<CandidateProgram<TYPE>>();
    List<CandidateProgram<TYPE>> poule=model.getPouleSelector().getPoule(pop,model.getPouleSize());
    while (nextPop.size() < model.getPopulationSize()) {
      double random=Math.random();
      double pr=model.getReproductionProbability();
      double pe=model.getCrossoverProbability();
      if (random < pr) {
        nextPop.add(poule.get((int)Math.floor(Math.random() * poule.size())));
      }
 else       if (random < pr + pe) {
        CandidateProgram<TYPE>[] children=crossover.crossover(poule);
        for (        CandidateProgram<TYPE> c : children) {
          if (nextPop.size() < model.getPopulationSize())           nextPop.add(c);
        }
      }
 else {
      }
    }
    for (    CandidateProgram<TYPE> p : pop) {
      double fitness=model.getFitness(p);
      if (fitness < bestFitness) {
        bestFitness=fitness;
        bestProgram=p;
      }
    }
    pop=nextPop;
  }
  System.out.println(""String_Node_Str"" + bestProgram);
  System.out.println(""String_Node_Str"" + bestFitness);
  System.out.println();
}",0.993943472409152
180778,"@Override public TYPE evaluate(){
  return value;
}","@Override public TYPE evaluate(){
  return getValue();
}",0.9345794392523364
180779,"@Override public List<TerminalNode<?>> getTerminals(){
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  List<TerminalNode<?>> terminals=new ArrayList<TerminalNode<?>>();
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  return terminals;
}","@Override public List<TerminalNode<?>> getTerminals(){
  List<TerminalNode<?>> terminals=new ArrayList<TerminalNode<?>>();
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  terminals.add(variables.get(""String_Node_Str""));
  return terminals;
}",0.6607929515418502
180780,"public void configure(){
  setPopulationSize(500);
  setNoGenerations(50);
  setCrossoverProbability(0.9);
  setReproductionProbability(0.1);
  setNoRuns(10);
  setPouleSize(50);
  setNoElites(50);
  setMaxDepth(4);
  setPouleSelector(new TournamentSelector<Boolean>(7,this));
  setParentSelector(new RandomParentSelector<Boolean>());
  setCrossover(new UniformPointCrossover<Boolean>(this));
}","public void configure(){
  setPopulationSize(500);
  setNoGenerations(50);
  setCrossoverProbability(0.9);
  setReproductionProbability(0.1);
  setNoRuns(10);
  setPouleSize(50);
  setNoElites(50);
  setMaxDepth(6);
  setPouleSelector(new TournamentSelector<Boolean>(7,this));
  setParentSelector(new RandomParentSelector<Boolean>());
  setCrossover(new UniformPointCrossover<Boolean>(this));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
  variables.put(""String_Node_Str"",new Variable<Boolean>(""String_Node_Str""));
}",0.6288
180781,"public Node buildFullNodeTree(int depth){
  int randomIndex=(int)Math.floor(Math.random() * config.getFunctions().size());
  Node top=config.getFunctions().get(randomIndex);
  fillChildren(top,1,config.getDepth());
  return top;
}","public Node buildFullNodeTree(int depth){
  int randomIndex=(int)Math.floor(Math.random() * config.getFunctions().size());
  Node top=null;
  try {
    top=(Node)config.getFunctions().get(randomIndex).clone();
  }
 catch (  CloneNotSupportedException e) {
    e.printStackTrace();
  }
  fillChildren(top,1,config.getDepth());
  return top;
}",0.8021015761821366
180782,"@Override public Object clone() throws CloneNotSupportedException {
  Node<TYPE> clone=(Node<TYPE>)super.clone();
  clone.setChildren(children.clone());
  return clone;
}","@Override public Object clone() throws CloneNotSupportedException {
  Node<TYPE> clone=(Node<TYPE>)super.clone();
  clone.setChildren(this.children.clone());
  return clone;
}",0.9855072463768116
180783,"private void processAppUsage(){
  SensorManager sensorManager=(SensorManager)getSystemService(Context.SENSOR_SERVICE);
  final int which=mStatsType;
  final int speedSteps=mPowerProfile.getNumSpeedSteps();
  final double[] powerCpuNormal=new double[speedSteps];
  final long[] cpuSpeedStepTimes=new long[speedSteps];
  for (int p=0; p < speedSteps; p++) {
    powerCpuNormal[p]=mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_ACTIVE,p);
  }
  final double averageCostPerByte=getAverageDataCost();
  long uSecTime=mStats.computeBatteryRealtime(SystemClock.elapsedRealtime() * 1000,which);
  mStatsPeriod=uSecTime;
  updateStatsPeriod(uSecTime);
  SparseArray<? extends Uid> uidStats=mStats.getUidStats();
  final int NU=uidStats.size();
  for (int iu=0; iu < NU; iu++) {
    Uid u=uidStats.valueAt(iu);
    double power=0;
    double highestDrain=0;
    String packageWithHighestDrain=null;
    Map<String,? extends BatteryStats.Uid.Proc> processStats=u.getProcessStats();
    long cpuTime=0;
    long cpuFgTime=0;
    long wakelockTime=0;
    long gpsTime=0;
    if (processStats.size() > 0) {
      for (      Map.Entry<String,? extends BatteryStats.Uid.Proc> ent : processStats.entrySet()) {
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + ent.getKey());
        Uid.Proc ps=ent.getValue();
        final long userTime=ps.getUserTime(which);
        final long systemTime=ps.getSystemTime(which);
        final long foregroundTime=ps.getForegroundTime(which);
        cpuFgTime+=foregroundTime * 10;
        final long tmpCpuTime=(userTime + systemTime) * 10;
        int totalTimeAtSpeeds=0;
        for (int step=0; step < speedSteps; step++) {
          cpuSpeedStepTimes[step]=ps.getTimeAtCpuSpeedStep(step,which);
          totalTimeAtSpeeds+=cpuSpeedStepTimes[step];
        }
        if (totalTimeAtSpeeds == 0)         totalTimeAtSpeeds=1;
        double processPower=0;
        for (int step=0; step < speedSteps; step++) {
          double ratio=(double)cpuSpeedStepTimes[step] / totalTimeAtSpeeds;
          processPower+=ratio * tmpCpuTime * powerCpuNormal[step];
        }
        cpuTime+=tmpCpuTime;
        power+=processPower;
        if (packageWithHighestDrain == null || packageWithHighestDrain.startsWith(""String_Node_Str"")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
 else         if (highestDrain < processPower && !ent.getKey().startsWith(""String_Node_Str"")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
      }
      if (DEBUG)       Log.i(TAG,""String_Node_Str"" + highestDrain + ""String_Node_Str""+ packageWithHighestDrain);
    }
    if (cpuFgTime > cpuTime) {
      if (DEBUG && cpuFgTime > cpuTime + 10000) {
        Log.i(TAG,""String_Node_Str"");
      }
      cpuTime=cpuFgTime;
    }
    power/=1000;
    Map<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
    for (    Map.Entry<String,? extends BatteryStats.Uid.Wakelock> wakelockEntry : wakelockStats.entrySet()) {
      Uid.Wakelock wakelock=wakelockEntry.getValue();
      BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
      if (timer != null) {
        wakelockTime+=timer.getTotalTimeLocked(uSecTime,which);
      }
    }
    wakelockTime/=1000;
    long tcpBytesReceived=u.getTcpBytesReceived(mStatsType);
    long tcpBytesSent=u.getTcpBytesSent(mStatsType);
    power+=(tcpBytesReceived + tcpBytesSent) * averageCostPerByte;
    long wifiRunningTimeMs=u.getWifiRunningTime(uSecTime,which) / 1000;
    mAppWifiRunning+=wifiRunningTimeMs;
    power+=(wifiRunningTimeMs * mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_ON)) / 1000;
    Map<Integer,? extends BatteryStats.Uid.Sensor> sensorStats=u.getSensorStats();
    for (    Map.Entry<Integer,? extends BatteryStats.Uid.Sensor> sensorEntry : sensorStats.entrySet()) {
      Uid.Sensor sensor=sensorEntry.getValue();
      int sensorType=sensor.getHandle();
      BatteryStats.Timer timer=sensor.getSensorTime();
      long sensorTime=timer.getTotalTimeLocked(uSecTime,which) / 1000;
      double multiplier=0;
switch (sensorType) {
case Uid.Sensor.GPS:
        multiplier=mPowerProfile.getAveragePower(PowerProfile.POWER_GPS_ON);
      gpsTime=sensorTime;
    break;
default :
  android.hardware.Sensor sensorData=sensorManager.getDefaultSensor(sensorType);
if (sensorData != null) {
  multiplier=sensorData.getPower();
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + sensorData.getName() + ""String_Node_Str""+ multiplier);
  }
}
}
power+=(multiplier * sensorTime) / 1000;
}
if (DEBUG) Log.i(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ power);
if (power != 0) {
BatterySipper app=new BatterySipper(this,mRequestQueue,mHandler,packageWithHighestDrain,DrainType.APP,0,u,new double[]{power});
app.cpuTime=cpuTime;
app.gpsTime=gpsTime;
app.wifiRunningTime=wifiRunningTimeMs;
app.cpuFgTime=cpuFgTime;
app.wakeLockTime=wakelockTime;
app.tcpBytesReceived=tcpBytesReceived;
app.tcpBytesSent=tcpBytesSent;
if (u.getUid() == Process.WIFI_UID) {
mWifiSippers.add(app);
}
 else if (u.getUid() == Process.BLUETOOTH_GID) {
mBluetoothSippers.add(app);
}
 else {
mUsageList.add(app);
}
}
if (u.getUid() == Process.WIFI_UID) {
mWifiPower+=power;
}
 else if (u.getUid() == Process.BLUETOOTH_GID) {
mBluetoothPower+=power;
}
 else {
if (power > mMaxPower) mMaxPower=power;
mTotalPower+=power;
}
if (DEBUG) Log.i(TAG,""String_Node_Str"" + power);
}
}","private void processAppUsage(){
  SensorManager sensorManager=(SensorManager)getSystemService(Context.SENSOR_SERVICE);
  final int which=mStatsType;
  final int speedSteps=mPowerProfile.getNumSpeedSteps();
  final double[] powerCpuNormal=new double[speedSteps];
  final long[] cpuSpeedStepTimes=new long[speedSteps];
  for (int p=0; p < speedSteps; p++) {
    powerCpuNormal[p]=mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_ACTIVE,p);
  }
  final double averageCostPerByte=getAverageDataCost();
  long uSecTime=mStats.computeBatteryRealtime(SystemClock.elapsedRealtime() * 1000,which);
  mStatsPeriod=uSecTime;
  updateStatsPeriod(uSecTime);
  SparseArray<? extends Uid> uidStats=mStats.getUidStats();
  final int NU=uidStats.size();
  for (int iu=0; iu < NU; iu++) {
    Uid u=uidStats.valueAt(iu);
    double power=0;
    double highestDrain=0;
    String packageWithHighestDrain=null;
    Map<String,? extends BatteryStats.Uid.Proc> processStats=u.getProcessStats();
    long cpuTime=0;
    long cpuFgTime=0;
    long wakelockTime=0;
    long gpsTime=0;
    if (processStats.size() > 0) {
      for (      Map.Entry<String,? extends BatteryStats.Uid.Proc> ent : processStats.entrySet()) {
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + ent.getKey());
        Uid.Proc ps=ent.getValue();
        final long userTime=ps.getUserTime(which);
        final long systemTime=ps.getSystemTime(which);
        final long foregroundTime=ps.getForegroundTime(which);
        cpuFgTime+=foregroundTime * 10;
        final long tmpCpuTime=(userTime + systemTime) * 10;
        int totalTimeAtSpeeds=0;
        for (int step=0; step < speedSteps; step++) {
          cpuSpeedStepTimes[step]=ps.getTimeAtCpuSpeedStep(step,which);
          totalTimeAtSpeeds+=cpuSpeedStepTimes[step];
        }
        if (totalTimeAtSpeeds == 0)         totalTimeAtSpeeds=1;
        double processPower=0;
        for (int step=0; step < speedSteps; step++) {
          double ratio=(double)cpuSpeedStepTimes[step] / totalTimeAtSpeeds;
          processPower+=ratio * tmpCpuTime * powerCpuNormal[step];
        }
        cpuTime+=tmpCpuTime;
        power+=processPower;
        if (packageWithHighestDrain == null || packageWithHighestDrain.startsWith(""String_Node_Str"")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
 else         if (highestDrain < processPower && !ent.getKey().startsWith(""String_Node_Str"")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
      }
      if (DEBUG)       Log.i(TAG,""String_Node_Str"" + highestDrain + ""String_Node_Str""+ packageWithHighestDrain);
    }
    if (cpuFgTime > cpuTime) {
      if (DEBUG && cpuFgTime > cpuTime + 10000) {
        Log.i(TAG,""String_Node_Str"");
      }
      cpuTime=cpuFgTime;
    }
    power/=1000;
    Map<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
    for (    Map.Entry<String,? extends BatteryStats.Uid.Wakelock> wakelockEntry : wakelockStats.entrySet()) {
      Uid.Wakelock wakelock=wakelockEntry.getValue();
      BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
      if (timer != null) {
        wakelockTime+=timer.getTotalTimeLocked(uSecTime,which);
      }
    }
    wakelockTime/=1000;
    power+=(wakelockTime * mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_AWAKE)) / 1000;
    long tcpBytesReceived=u.getTcpBytesReceived(mStatsType);
    long tcpBytesSent=u.getTcpBytesSent(mStatsType);
    power+=(tcpBytesReceived + tcpBytesSent) * averageCostPerByte;
    long wifiRunningTimeMs=u.getWifiRunningTime(uSecTime,which) / 1000;
    mAppWifiRunning+=wifiRunningTimeMs;
    power+=(wifiRunningTimeMs * mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_ON)) / 1000;
    Map<Integer,? extends BatteryStats.Uid.Sensor> sensorStats=u.getSensorStats();
    for (    Map.Entry<Integer,? extends BatteryStats.Uid.Sensor> sensorEntry : sensorStats.entrySet()) {
      Uid.Sensor sensor=sensorEntry.getValue();
      int sensorType=sensor.getHandle();
      BatteryStats.Timer timer=sensor.getSensorTime();
      long sensorTime=timer.getTotalTimeLocked(uSecTime,which) / 1000;
      double multiplier=0;
switch (sensorType) {
case Uid.Sensor.GPS:
        multiplier=mPowerProfile.getAveragePower(PowerProfile.POWER_GPS_ON);
      gpsTime=sensorTime;
    break;
default :
  android.hardware.Sensor sensorData=sensorManager.getDefaultSensor(sensorType);
if (sensorData != null) {
  multiplier=sensorData.getPower();
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + sensorData.getName() + ""String_Node_Str""+ multiplier);
  }
}
}
power+=(multiplier * sensorTime) / 1000;
}
if (DEBUG) Log.i(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ power);
if (power != 0) {
BatterySipper app=new BatterySipper(this,mRequestQueue,mHandler,packageWithHighestDrain,DrainType.APP,0,u,new double[]{power});
app.cpuTime=cpuTime;
app.gpsTime=gpsTime;
app.wifiRunningTime=wifiRunningTimeMs;
app.cpuFgTime=cpuFgTime;
app.wakeLockTime=wakelockTime;
app.tcpBytesReceived=tcpBytesReceived;
app.tcpBytesSent=tcpBytesSent;
if (u.getUid() == Process.WIFI_UID) {
mWifiSippers.add(app);
}
 else if (u.getUid() == Process.BLUETOOTH_GID) {
mBluetoothSippers.add(app);
}
 else {
mUsageList.add(app);
}
}
if (u.getUid() == Process.WIFI_UID) {
mWifiPower+=power;
}
 else if (u.getUid() == Process.BLUETOOTH_GID) {
mBluetoothPower+=power;
}
 else {
if (power > mMaxPower) mMaxPower=power;
mTotalPower+=power;
}
if (DEBUG) Log.i(TAG,""String_Node_Str"" + power);
}
}",0.991304347826087
180784,"private void processAppUsage(){
  SensorManager sensorManager=(SensorManager)getSystemService(Context.SENSOR_SERVICE);
  final int which=mStatsType;
  final int speedSteps=mPowerProfile.getNumSpeedSteps();
  final double[] powerCpuNormal=new double[speedSteps];
  final long[] cpuSpeedStepTimes=new long[speedSteps];
  for (int p=0; p < speedSteps; p++) {
    powerCpuNormal[p]=mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_ACTIVE,p);
  }
  final double averageCostPerByte=getAverageDataCost();
  long uSecTime=mStats.computeBatteryRealtime(SystemClock.elapsedRealtime() * 1000,which);
  mStatsPeriod=uSecTime;
  updateStatsPeriod(uSecTime);
  SparseArray<? extends Uid> uidStats=mStats.getUidStats();
  final int NU=uidStats.size();
  for (int iu=0; iu < NU; iu++) {
    Uid u=uidStats.valueAt(iu);
    double power=0;
    double highestDrain=0;
    String packageWithHighestDrain=null;
    Map<String,? extends BatteryStats.Uid.Proc> processStats=u.getProcessStats();
    long cpuTime=0;
    long cpuFgTime=0;
    long wakelockTime=0;
    long gpsTime=0;
    if (processStats.size() > 0) {
      for (      Map.Entry<String,? extends BatteryStats.Uid.Proc> ent : processStats.entrySet()) {
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + ent.getKey());
        Uid.Proc ps=ent.getValue();
        final long userTime=ps.getUserTime(which);
        final long systemTime=ps.getSystemTime(which);
        final long foregroundTime=ps.getForegroundTime(which);
        cpuFgTime+=foregroundTime * 10;
        final long tmpCpuTime=(userTime + systemTime) * 10;
        int totalTimeAtSpeeds=0;
        for (int step=0; step < speedSteps; step++) {
          cpuSpeedStepTimes[step]=ps.getTimeAtCpuSpeedStep(step,which);
          totalTimeAtSpeeds+=cpuSpeedStepTimes[step];
        }
        if (totalTimeAtSpeeds == 0)         totalTimeAtSpeeds=1;
        double processPower=0;
        for (int step=0; step < speedSteps; step++) {
          double ratio=(double)cpuSpeedStepTimes[step] / totalTimeAtSpeeds;
          processPower+=ratio * tmpCpuTime * powerCpuNormal[step];
        }
        cpuTime+=tmpCpuTime;
        power+=processPower;
        if (packageWithHighestDrain == null || packageWithHighestDrain.startsWith(""String_Node_Str"")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
 else         if (highestDrain < processPower && !ent.getKey().startsWith(""String_Node_Str"")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
      }
      if (DEBUG)       Log.i(TAG,""String_Node_Str"" + highestDrain + ""String_Node_Str""+ packageWithHighestDrain);
    }
    if (cpuFgTime > cpuTime) {
      if (DEBUG && cpuFgTime > cpuTime + 10000) {
        Log.i(TAG,""String_Node_Str"");
      }
      cpuTime=cpuFgTime;
    }
    power/=1000;
    Map<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
    for (    Map.Entry<String,? extends BatteryStats.Uid.Wakelock> wakelockEntry : wakelockStats.entrySet()) {
      Uid.Wakelock wakelock=wakelockEntry.getValue();
      BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
      if (timer != null) {
        wakelockTime+=timer.getTotalTimeLocked(uSecTime,which);
      }
    }
    wakelockTime/=1000;
    long tcpBytesReceived=u.getTcpBytesReceived(mStatsType);
    long tcpBytesSent=u.getTcpBytesSent(mStatsType);
    power+=(tcpBytesReceived + tcpBytesSent) * averageCostPerByte;
    long wifiRunningTimeMs=u.getWifiRunningTime(uSecTime,which) / 1000;
    mAppWifiRunning+=wifiRunningTimeMs;
    power+=(wifiRunningTimeMs * mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_ON)) / 1000;
    Map<Integer,? extends BatteryStats.Uid.Sensor> sensorStats=u.getSensorStats();
    for (    Map.Entry<Integer,? extends BatteryStats.Uid.Sensor> sensorEntry : sensorStats.entrySet()) {
      Uid.Sensor sensor=sensorEntry.getValue();
      int sensorType=sensor.getHandle();
      BatteryStats.Timer timer=sensor.getSensorTime();
      long sensorTime=timer.getTotalTimeLocked(uSecTime,which) / 1000;
      double multiplier=0;
switch (sensorType) {
case Uid.Sensor.GPS:
        multiplier=mPowerProfile.getAveragePower(PowerProfile.POWER_GPS_ON);
      gpsTime=sensorTime;
    break;
default :
  android.hardware.Sensor sensorData=sensorManager.getDefaultSensor(sensorType);
if (sensorData != null) {
  multiplier=sensorData.getPower();
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + sensorData.getName() + ""String_Node_Str""+ multiplier);
  }
}
}
power+=(multiplier * sensorTime) / 1000;
}
if (DEBUG) Log.i(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ power);
if (power != 0) {
BatterySipper app=new BatterySipper(this,mRequestQueue,mHandler,packageWithHighestDrain,DrainType.APP,0,u,new double[]{power});
app.cpuTime=cpuTime;
app.gpsTime=gpsTime;
app.wifiRunningTime=wifiRunningTimeMs;
app.cpuFgTime=cpuFgTime;
app.wakeLockTime=wakelockTime;
app.tcpBytesReceived=tcpBytesReceived;
app.tcpBytesSent=tcpBytesSent;
if (u.getUid() == Process.WIFI_UID) {
mWifiSippers.add(app);
}
 else if (u.getUid() == Process.BLUETOOTH_GID) {
mBluetoothSippers.add(app);
}
 else {
mUsageList.add(app);
}
}
if (u.getUid() == Process.WIFI_UID) {
mWifiPower+=power;
}
 else if (u.getUid() == Process.BLUETOOTH_GID) {
mBluetoothPower+=power;
}
 else {
if (power > mMaxPower) mMaxPower=power;
mTotalPower+=power;
}
if (DEBUG) Log.i(TAG,""String_Node_Str"" + power);
}
}","private void processAppUsage(){
  SensorManager sensorManager=(SensorManager)getSystemService(Context.SENSOR_SERVICE);
  final int which=mStatsType;
  final int speedSteps=mPowerProfile.getNumSpeedSteps();
  final double[] powerCpuNormal=new double[speedSteps];
  final long[] cpuSpeedStepTimes=new long[speedSteps];
  for (int p=0; p < speedSteps; p++) {
    powerCpuNormal[p]=mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_ACTIVE,p);
  }
  final double averageCostPerByte=getAverageDataCost();
  long uSecTime=mStats.computeBatteryRealtime(SystemClock.elapsedRealtime() * 1000,which);
  mStatsPeriod=uSecTime;
  updateStatsPeriod(uSecTime);
  SparseArray<? extends Uid> uidStats=mStats.getUidStats();
  final int NU=uidStats.size();
  for (int iu=0; iu < NU; iu++) {
    Uid u=uidStats.valueAt(iu);
    double power=0;
    double highestDrain=0;
    String packageWithHighestDrain=null;
    Map<String,? extends BatteryStats.Uid.Proc> processStats=u.getProcessStats();
    long cpuTime=0;
    long cpuFgTime=0;
    long wakelockTime=0;
    long gpsTime=0;
    if (processStats.size() > 0) {
      for (      Map.Entry<String,? extends BatteryStats.Uid.Proc> ent : processStats.entrySet()) {
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + ent.getKey());
        Uid.Proc ps=ent.getValue();
        final long userTime=ps.getUserTime(which);
        final long systemTime=ps.getSystemTime(which);
        final long foregroundTime=ps.getForegroundTime(which);
        cpuFgTime+=foregroundTime * 10;
        final long tmpCpuTime=(userTime + systemTime) * 10;
        int totalTimeAtSpeeds=0;
        for (int step=0; step < speedSteps; step++) {
          cpuSpeedStepTimes[step]=ps.getTimeAtCpuSpeedStep(step,which);
          totalTimeAtSpeeds+=cpuSpeedStepTimes[step];
        }
        if (totalTimeAtSpeeds == 0)         totalTimeAtSpeeds=1;
        double processPower=0;
        for (int step=0; step < speedSteps; step++) {
          double ratio=(double)cpuSpeedStepTimes[step] / totalTimeAtSpeeds;
          processPower+=ratio * tmpCpuTime * powerCpuNormal[step];
        }
        cpuTime+=tmpCpuTime;
        power+=processPower;
        if (packageWithHighestDrain == null || packageWithHighestDrain.startsWith(""String_Node_Str"")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
 else         if (highestDrain < processPower && !ent.getKey().startsWith(""String_Node_Str"")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
      }
      if (DEBUG)       Log.i(TAG,""String_Node_Str"" + highestDrain + ""String_Node_Str""+ packageWithHighestDrain);
    }
    if (cpuFgTime > cpuTime) {
      if (DEBUG && cpuFgTime > cpuTime + 10000) {
        Log.i(TAG,""String_Node_Str"");
      }
      cpuTime=cpuFgTime;
    }
    power/=1000;
    Map<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
    for (    Map.Entry<String,? extends BatteryStats.Uid.Wakelock> wakelockEntry : wakelockStats.entrySet()) {
      Uid.Wakelock wakelock=wakelockEntry.getValue();
      BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
      if (timer != null) {
        wakelockTime+=timer.getTotalTimeLocked(uSecTime,which);
      }
    }
    wakelockTime/=1000;
    power+=(wakelockTime * mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_AWAKE)) / 1000;
    long tcpBytesReceived=u.getTcpBytesReceived(mStatsType);
    long tcpBytesSent=u.getTcpBytesSent(mStatsType);
    power+=(tcpBytesReceived + tcpBytesSent) * averageCostPerByte;
    long wifiRunningTimeMs=u.getWifiRunningTime(uSecTime,which) / 1000;
    mAppWifiRunning+=wifiRunningTimeMs;
    power+=(wifiRunningTimeMs * mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_ON)) / 1000;
    Map<Integer,? extends BatteryStats.Uid.Sensor> sensorStats=u.getSensorStats();
    for (    Map.Entry<Integer,? extends BatteryStats.Uid.Sensor> sensorEntry : sensorStats.entrySet()) {
      Uid.Sensor sensor=sensorEntry.getValue();
      int sensorType=sensor.getHandle();
      BatteryStats.Timer timer=sensor.getSensorTime();
      long sensorTime=timer.getTotalTimeLocked(uSecTime,which) / 1000;
      double multiplier=0;
switch (sensorType) {
case Uid.Sensor.GPS:
        multiplier=mPowerProfile.getAveragePower(PowerProfile.POWER_GPS_ON);
      gpsTime=sensorTime;
    break;
default :
  android.hardware.Sensor sensorData=sensorManager.getDefaultSensor(sensorType);
if (sensorData != null) {
  multiplier=sensorData.getPower();
  if (DEBUG) {
    Log.i(TAG,""String_Node_Str"" + sensorData.getName() + ""String_Node_Str""+ multiplier);
  }
}
}
power+=(multiplier * sensorTime) / 1000;
}
if (DEBUG) Log.i(TAG,""String_Node_Str"" + u.getUid() + ""String_Node_Str""+ power);
if (power != 0) {
BatterySipper app=new BatterySipper(this,mRequestQueue,mHandler,packageWithHighestDrain,DrainType.APP,0,u,new double[]{power});
app.cpuTime=cpuTime;
app.gpsTime=gpsTime;
app.wifiRunningTime=wifiRunningTimeMs;
app.cpuFgTime=cpuFgTime;
app.wakeLockTime=wakelockTime;
app.tcpBytesReceived=tcpBytesReceived;
app.tcpBytesSent=tcpBytesSent;
if (u.getUid() == Process.WIFI_UID) {
mWifiSippers.add(app);
}
 else if (u.getUid() == Process.BLUETOOTH_GID) {
mBluetoothSippers.add(app);
}
 else {
mUsageList.add(app);
}
}
if (u.getUid() == Process.WIFI_UID) {
mWifiPower+=power;
}
 else if (u.getUid() == Process.BLUETOOTH_GID) {
mBluetoothPower+=power;
}
 else {
if (power > mMaxPower) mMaxPower=power;
mTotalPower+=power;
}
if (DEBUG) Log.i(TAG,""String_Node_Str"" + power);
}
}",0.991304347826087
180785,"void init(int width){
  if (width > 0) {
    mTicks=new int[width + 2];
  }
 else {
    mTicks=null;
  }
  mNumTicks=0;
  mLastBin=0;
}","void init(int width){
  if (width > 0) {
    mTicks=new int[width * 2];
  }
 else {
    mTicks=null;
  }
  mNumTicks=0;
  mLastBin=0;
}",0.9925925925925926
180786,"void addTick(int x,int bin){
  if (bin != mLastBin) {
    mTicks[mNumTicks]=x | bin << CHART_DATA_BIN_SHIFT;
    mNumTicks++;
    mLastBin=bin;
  }
}","void addTick(int x,int bin){
  if (bin != mLastBin && mNumTicks < mTicks.length) {
    mTicks[mNumTicks]=x | bin << CHART_DATA_BIN_SHIFT;
    mNumTicks++;
    mLastBin=bin;
  }
}",0.91131498470948
180787,"void removePackage(String pkgName){
synchronized (mEntriesMap) {
    int idx=indexOfApplicationInfoLocked(pkgName);
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ idx);
    if (idx >= 0) {
      AppEntry entry=mEntriesMap.get(pkgName);
      if (DEBUG)       Log.i(TAG,""String_Node_Str"" + entry);
      if (entry != null) {
        mEntriesMap.remove(pkgName);
        mAppEntries.remove(entry);
      }
      mApplications.remove(idx);
      if (!mMainHandler.hasMessages(MainHandler.MSG_PACKAGE_LIST_CHANGED)) {
        mMainHandler.sendEmptyMessage(MainHandler.MSG_PACKAGE_LIST_CHANGED);
      }
    }
  }
}","void removePackage(String pkgName){
synchronized (mEntriesMap) {
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
    int idx=indexOfApplicationInfoLocked(pkgName);
    if (DEBUG)     Log.i(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ idx);
    if (idx >= 0) {
      AppEntry entry=mEntriesMap.get(pkgName);
      if (DEBUG)       Log.i(TAG,""String_Node_Str"" + entry);
      if (entry != null) {
        mEntriesMap.remove(pkgName);
        mAppEntries.remove(entry);
      }
      mApplications.remove(idx);
      if (!mMainHandler.hasMessages(MainHandler.MSG_PACKAGE_LIST_CHANGED)) {
        mMainHandler.sendEmptyMessage(MainHandler.MSG_PACKAGE_LIST_CHANGED);
      }
    }
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
  }
}",0.9183381088825217
180788,"private ApplicationsState(Application app){
  mContext=app;
  mPm=mContext.getPackageManager();
  mThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_BACKGROUND);
  mThread.start();
  mBackgroundHandler=new BackgroundHandler(mThread.getLooper());
}","private ApplicationsState(Application app){
  mContext=app;
  mPm=mContext.getPackageManager();
  mThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_BACKGROUND);
  mThread.start();
  mBackgroundHandler=new BackgroundHandler(mThread.getLooper());
synchronized (mEntriesMap) {
    try {
      mEntriesMap.wait(1);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.8148148148148148
180789,"void addPackage(String pkgName){
  try {
synchronized (mEntriesMap) {
      if (DEBUG)       Log.i(TAG,""String_Node_Str"" + pkgName);
      if (!mResumed) {
        return;
      }
      if (indexOfApplicationInfoLocked(pkgName) >= 0) {
        if (DEBUG)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      ApplicationInfo info=mPm.getApplicationInfo(pkgName,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      mApplications.add(info);
      if (!mBackgroundHandler.hasMessages(BackgroundHandler.MSG_LOAD_ENTRIES)) {
        mBackgroundHandler.sendEmptyMessage(BackgroundHandler.MSG_LOAD_ENTRIES);
      }
      if (!mMainHandler.hasMessages(MainHandler.MSG_PACKAGE_LIST_CHANGED)) {
        mMainHandler.sendEmptyMessage(MainHandler.MSG_PACKAGE_LIST_CHANGED);
      }
    }
  }
 catch (  NameNotFoundException e) {
  }
}","void addPackage(String pkgName){
  try {
synchronized (mEntriesMap) {
      if (DEBUG_LOCKING)       Log.v(TAG,""String_Node_Str"");
      if (DEBUG)       Log.i(TAG,""String_Node_Str"" + pkgName);
      if (!mResumed) {
        if (DEBUG_LOCKING)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      if (indexOfApplicationInfoLocked(pkgName) >= 0) {
        if (DEBUG)         Log.i(TAG,""String_Node_Str"");
        if (DEBUG_LOCKING)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      ApplicationInfo info=mPm.getApplicationInfo(pkgName,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
      mApplications.add(info);
      if (!mBackgroundHandler.hasMessages(BackgroundHandler.MSG_LOAD_ENTRIES)) {
        mBackgroundHandler.sendEmptyMessage(BackgroundHandler.MSG_LOAD_ENTRIES);
      }
      if (!mMainHandler.hasMessages(MainHandler.MSG_PACKAGE_LIST_CHANGED)) {
        mMainHandler.sendEmptyMessage(MainHandler.MSG_PACKAGE_LIST_CHANGED);
      }
      if (DEBUG_LOCKING)       Log.v(TAG,""String_Node_Str"");
    }
  }
 catch (  NameNotFoundException e) {
  }
}",0.8608608608608609
180790,"void handleRebuildList(){
  AppFilter filter;
  Comparator<AppEntry> comparator;
synchronized (mRebuildSync) {
    if (!mRebuildRequested) {
      return;
    }
    filter=mRebuildFilter;
    comparator=mRebuildComparator;
    mRebuildRequested=false;
    mRebuildFilter=null;
    mRebuildComparator=null;
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  if (filter != null) {
    filter.init();
  }
  List<ApplicationInfo> apps;
synchronized (mEntriesMap) {
    apps=new ArrayList<ApplicationInfo>(mApplications);
  }
  ArrayList<AppEntry> filteredApps=new ArrayList<AppEntry>();
  if (DEBUG)   Log.i(TAG,""String_Node_Str"");
  for (int i=0; i < apps.size(); i++) {
    ApplicationInfo info=apps.get(i);
    if (filter == null || filter.filterApp(info)) {
synchronized (mEntriesMap) {
        AppEntry entry=getEntryLocked(info);
        entry.ensureLabel(mContext);
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + info.packageName + ""String_Node_Str""+ entry);
        filteredApps.add(entry);
      }
    }
  }
  Collections.sort(filteredApps,comparator);
synchronized (mRebuildSync) {
    if (!mRebuildRequested) {
      if (!mRebuildAsync) {
        mRebuildResult=filteredApps;
        mRebuildSync.notifyAll();
      }
 else {
        if (!mMainHandler.hasMessages(MainHandler.MSG_REBUILD_COMPLETE)) {
          Message msg=mMainHandler.obtainMessage(MainHandler.MSG_REBUILD_COMPLETE,filteredApps);
          mMainHandler.sendMessage(msg);
        }
      }
    }
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}","void handleRebuildList(){
  AppFilter filter;
  Comparator<AppEntry> comparator;
synchronized (mRebuildSync) {
    if (!mRebuildRequested) {
      return;
    }
    filter=mRebuildFilter;
    comparator=mRebuildComparator;
    mRebuildRequested=false;
    mRebuildFilter=null;
    mRebuildComparator=null;
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  if (filter != null) {
    filter.init();
  }
  List<ApplicationInfo> apps;
synchronized (mEntriesMap) {
    apps=new ArrayList<ApplicationInfo>(mApplications);
  }
  ArrayList<AppEntry> filteredApps=new ArrayList<AppEntry>();
  if (DEBUG)   Log.i(TAG,""String_Node_Str"");
  for (int i=0; i < apps.size(); i++) {
    ApplicationInfo info=apps.get(i);
    if (filter == null || filter.filterApp(info)) {
synchronized (mEntriesMap) {
        if (DEBUG_LOCKING)         Log.v(TAG,""String_Node_Str"");
        AppEntry entry=getEntryLocked(info);
        entry.ensureLabel(mContext);
        if (DEBUG)         Log.i(TAG,""String_Node_Str"" + info.packageName + ""String_Node_Str""+ entry);
        filteredApps.add(entry);
        if (DEBUG_LOCKING)         Log.v(TAG,""String_Node_Str"");
      }
    }
  }
  Collections.sort(filteredApps,comparator);
synchronized (mRebuildSync) {
    if (!mRebuildRequested) {
      if (!mRebuildAsync) {
        mRebuildResult=filteredApps;
        mRebuildSync.notifyAll();
      }
 else {
        if (!mMainHandler.hasMessages(MainHandler.MSG_REBUILD_COMPLETE)) {
          Message msg=mMainHandler.obtainMessage(MainHandler.MSG_REBUILD_COMPLETE,filteredApps);
          mMainHandler.sendMessage(msg);
        }
      }
    }
  }
  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}",0.8685015290519877
180791,"long sumCacheSizes(){
  long sum=0;
synchronized (mEntriesMap) {
    for (int i=mAppEntries.size() - 1; i >= 0; i--) {
      sum+=mAppEntries.get(i).cacheSize;
    }
  }
  return sum;
}","long sumCacheSizes(){
  long sum=0;
  if (DEBUG_LOCKING)   Log.v(TAG,""String_Node_Str"");
synchronized (mEntriesMap) {
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
    for (int i=mAppEntries.size() - 1; i >= 0; i--) {
      sum+=mAppEntries.get(i).cacheSize;
    }
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
  }
  return sum;
}",0.6890130353817505
180792,"AppEntry getEntry(String packageName){
synchronized (mEntriesMap) {
    AppEntry entry=mEntriesMap.get(packageName);
    if (entry == null) {
      for (int i=0; i < mApplications.size(); i++) {
        ApplicationInfo info=mApplications.get(i);
        if (packageName.equals(info.packageName)) {
          entry=getEntryLocked(info);
          break;
        }
      }
    }
    return entry;
  }
}","AppEntry getEntry(String packageName){
  if (DEBUG_LOCKING)   Log.v(TAG,""String_Node_Str"");
synchronized (mEntriesMap) {
    AppEntry entry=mEntriesMap.get(packageName);
    if (entry == null) {
      for (int i=0; i < mApplications.size(); i++) {
        ApplicationInfo info=mApplications.get(i);
        if (packageName.equals(info.packageName)) {
          entry=getEntryLocked(info);
          break;
        }
      }
    }
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
    return entry;
  }
}",0.8791208791208791
180793,"void resume(Callbacks callbacks){
synchronized (mEntriesMap) {
    mCurCallbacks=callbacks;
    mResumed=true;
    if (mPackageIntentReceiver == null) {
      mPackageIntentReceiver=new PackageIntentReceiver();
      mPackageIntentReceiver.registerReceiver();
    }
    mApplications=mPm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
    if (mApplications == null) {
      mApplications=new ArrayList<ApplicationInfo>();
    }
    for (int i=0; i < mAppEntries.size(); i++) {
      mAppEntries.get(i).sizeStale=true;
    }
    for (int i=0; i < mApplications.size(); i++) {
      final ApplicationInfo info=mApplications.get(i);
      final AppEntry entry=mEntriesMap.get(info.packageName);
      if (entry != null) {
        entry.info=info;
      }
    }
    mCurComputingSizePkg=null;
    if (!mBackgroundHandler.hasMessages(BackgroundHandler.MSG_LOAD_ENTRIES)) {
      mBackgroundHandler.sendEmptyMessage(BackgroundHandler.MSG_LOAD_ENTRIES);
    }
  }
}","void resume(Callbacks callbacks){
  if (DEBUG_LOCKING)   Log.v(TAG,""String_Node_Str"");
synchronized (mEntriesMap) {
    mCurCallbacks=callbacks;
    mResumed=true;
    if (mPackageIntentReceiver == null) {
      mPackageIntentReceiver=new PackageIntentReceiver();
      mPackageIntentReceiver.registerReceiver();
    }
    mApplications=mPm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
    if (mApplications == null) {
      mApplications=new ArrayList<ApplicationInfo>();
    }
    for (int i=0; i < mAppEntries.size(); i++) {
      mAppEntries.get(i).sizeStale=true;
    }
    for (int i=0; i < mApplications.size(); i++) {
      final ApplicationInfo info=mApplications.get(i);
      final AppEntry entry=mEntriesMap.get(info.packageName);
      if (entry != null) {
        entry.info=info;
      }
    }
    mCurComputingSizePkg=null;
    if (!mBackgroundHandler.hasMessages(BackgroundHandler.MSG_LOAD_ENTRIES)) {
      mBackgroundHandler.sendEmptyMessage(BackgroundHandler.MSG_LOAD_ENTRIES);
    }
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
  }
}",0.9487895716945997
180794,"@Override public void handleMessage(Message msg){
  handleRebuildList();
switch (msg.what) {
case MSG_REBUILD_LIST:
{
    }
  break;
case MSG_LOAD_ENTRIES:
{
  int numDone=0;
synchronized (mEntriesMap) {
    for (int i=0; i < mApplications.size() && numDone < 6; i++) {
      if (!mRunning) {
        mRunning=true;
        Message m=mMainHandler.obtainMessage(MainHandler.MSG_RUNNING_STATE_CHANGED,1);
        mMainHandler.sendMessage(m);
      }
      ApplicationInfo info=mApplications.get(i);
      if (mEntriesMap.get(info.packageName) == null) {
        numDone++;
        getEntryLocked(info);
      }
    }
  }
  if (numDone >= 6) {
    sendEmptyMessage(MSG_LOAD_ENTRIES);
  }
 else {
    sendEmptyMessage(MSG_LOAD_ICONS);
  }
}
break;
case MSG_LOAD_ICONS:
{
int numDone=0;
synchronized (mEntriesMap) {
for (int i=0; i < mAppEntries.size() && numDone < 2; i++) {
  AppEntry entry=mAppEntries.get(i);
  if (entry.icon == null || !entry.mounted) {
synchronized (entry) {
      if (entry.ensureIconLocked(mContext,mPm)) {
        if (!mRunning) {
          mRunning=true;
          Message m=mMainHandler.obtainMessage(MainHandler.MSG_RUNNING_STATE_CHANGED,1);
          mMainHandler.sendMessage(m);
        }
        numDone++;
      }
    }
  }
}
}
if (numDone > 0) {
if (!mMainHandler.hasMessages(MainHandler.MSG_PACKAGE_ICON_CHANGED)) {
  mMainHandler.sendEmptyMessage(MainHandler.MSG_PACKAGE_ICON_CHANGED);
}
}
if (numDone >= 2) {
sendEmptyMessage(MSG_LOAD_ICONS);
}
 else {
sendEmptyMessage(MSG_LOAD_SIZES);
}
}
break;
case MSG_LOAD_SIZES:
{
synchronized (mEntriesMap) {
if (mCurComputingSizePkg != null) {
return;
}
long now=SystemClock.uptimeMillis();
for (int i=0; i < mAppEntries.size(); i++) {
AppEntry entry=mAppEntries.get(i);
if (entry.size == SIZE_UNKNOWN || entry.sizeStale) {
if (entry.sizeLoadStart == 0 || (entry.sizeLoadStart < (now - 20 * 1000))) {
  if (!mRunning) {
    mRunning=true;
    Message m=mMainHandler.obtainMessage(MainHandler.MSG_RUNNING_STATE_CHANGED,1);
    mMainHandler.sendMessage(m);
  }
  entry.sizeLoadStart=now;
  mCurComputingSizePkg=entry.info.packageName;
  mPm.getPackageSizeInfo(mCurComputingSizePkg,mStatsObserver);
}
return;
}
}
if (!mMainHandler.hasMessages(MainHandler.MSG_ALL_SIZES_COMPUTED)) {
mMainHandler.sendEmptyMessage(MainHandler.MSG_ALL_SIZES_COMPUTED);
mRunning=false;
Message m=mMainHandler.obtainMessage(MainHandler.MSG_RUNNING_STATE_CHANGED,0);
mMainHandler.sendMessage(m);
}
}
}
break;
}
}","@Override public void handleMessage(Message msg){
  handleRebuildList();
switch (msg.what) {
case MSG_REBUILD_LIST:
{
    }
  break;
case MSG_LOAD_ENTRIES:
{
  int numDone=0;
synchronized (mEntriesMap) {
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
    for (int i=0; i < mApplications.size() && numDone < 6; i++) {
      if (!mRunning) {
        mRunning=true;
        Message m=mMainHandler.obtainMessage(MainHandler.MSG_RUNNING_STATE_CHANGED,1);
        mMainHandler.sendMessage(m);
      }
      ApplicationInfo info=mApplications.get(i);
      if (mEntriesMap.get(info.packageName) == null) {
        numDone++;
        getEntryLocked(info);
      }
    }
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
  }
  if (numDone >= 6) {
    sendEmptyMessage(MSG_LOAD_ENTRIES);
  }
 else {
    sendEmptyMessage(MSG_LOAD_ICONS);
  }
}
break;
case MSG_LOAD_ICONS:
{
int numDone=0;
synchronized (mEntriesMap) {
if (DEBUG_LOCKING) Log.v(TAG,""String_Node_Str"");
for (int i=0; i < mAppEntries.size() && numDone < 2; i++) {
  AppEntry entry=mAppEntries.get(i);
  if (entry.icon == null || !entry.mounted) {
synchronized (entry) {
      if (entry.ensureIconLocked(mContext,mPm)) {
        if (!mRunning) {
          mRunning=true;
          Message m=mMainHandler.obtainMessage(MainHandler.MSG_RUNNING_STATE_CHANGED,1);
          mMainHandler.sendMessage(m);
        }
        numDone++;
      }
    }
  }
}
if (DEBUG_LOCKING) Log.v(TAG,""String_Node_Str"");
}
if (numDone > 0) {
if (!mMainHandler.hasMessages(MainHandler.MSG_PACKAGE_ICON_CHANGED)) {
  mMainHandler.sendEmptyMessage(MainHandler.MSG_PACKAGE_ICON_CHANGED);
}
}
if (numDone >= 2) {
sendEmptyMessage(MSG_LOAD_ICONS);
}
 else {
sendEmptyMessage(MSG_LOAD_SIZES);
}
}
break;
case MSG_LOAD_SIZES:
{
synchronized (mEntriesMap) {
if (DEBUG_LOCKING) Log.v(TAG,""String_Node_Str"");
if (mCurComputingSizePkg != null) {
if (DEBUG_LOCKING) Log.v(TAG,""String_Node_Str"");
return;
}
long now=SystemClock.uptimeMillis();
for (int i=0; i < mAppEntries.size(); i++) {
AppEntry entry=mAppEntries.get(i);
if (entry.size == SIZE_UNKNOWN || entry.sizeStale) {
if (entry.sizeLoadStart == 0 || (entry.sizeLoadStart < (now - 20 * 1000))) {
  if (!mRunning) {
    mRunning=true;
    Message m=mMainHandler.obtainMessage(MainHandler.MSG_RUNNING_STATE_CHANGED,1);
    mMainHandler.sendMessage(m);
  }
  entry.sizeLoadStart=now;
  mCurComputingSizePkg=entry.info.packageName;
  mPm.getPackageSizeInfo(mCurComputingSizePkg,mStatsObserver);
}
if (DEBUG_LOCKING) Log.v(TAG,""String_Node_Str"");
return;
}
}
if (!mMainHandler.hasMessages(MainHandler.MSG_ALL_SIZES_COMPUTED)) {
mMainHandler.sendEmptyMessage(MainHandler.MSG_ALL_SIZES_COMPUTED);
mRunning=false;
Message m=mMainHandler.obtainMessage(MainHandler.MSG_RUNNING_STATE_CHANGED,0);
mMainHandler.sendMessage(m);
}
if (DEBUG_LOCKING) Log.v(TAG,""String_Node_Str"");
}
}
break;
}
}",0.9234234234234234
180795,"void pause(){
synchronized (mEntriesMap) {
    mCurCallbacks=null;
    mResumed=false;
  }
}","void pause(){
  if (DEBUG_LOCKING)   Log.v(TAG,""String_Node_Str"");
synchronized (mEntriesMap) {
    mCurCallbacks=null;
    mResumed=false;
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
  }
}",0.6258503401360545
180796,"public void onGetStatsCompleted(PackageStats stats,boolean succeeded){
  boolean sizeChanged=false;
synchronized (mEntriesMap) {
    AppEntry entry=mEntriesMap.get(stats.packageName);
    if (entry != null) {
synchronized (entry) {
        entry.sizeStale=false;
        entry.sizeLoadStart=0;
        long newSize=getTotalSize(stats);
        if (entry.size != newSize || entry.cacheSize != stats.cacheSize || entry.codeSize != stats.codeSize || entry.dataSize != stats.dataSize) {
          entry.size=newSize;
          entry.cacheSize=stats.cacheSize;
          entry.codeSize=stats.codeSize;
          entry.dataSize=stats.dataSize;
          entry.sizeStr=getSizeStr(entry.size);
          if (DEBUG)           Log.i(TAG,""String_Node_Str"" + entry.label + ""String_Node_Str""+ entry+ ""String_Node_Str""+ entry.sizeStr);
          sizeChanged=true;
        }
      }
      if (sizeChanged) {
        Message msg=mMainHandler.obtainMessage(MainHandler.MSG_PACKAGE_SIZE_CHANGED,stats.packageName);
        mMainHandler.sendMessage(msg);
      }
    }
    if (mCurComputingSizePkg == null || mCurComputingSizePkg.equals(stats.packageName)) {
      mCurComputingSizePkg=null;
      sendEmptyMessage(MSG_LOAD_SIZES);
    }
  }
}","public void onGetStatsCompleted(PackageStats stats,boolean succeeded){
  boolean sizeChanged=false;
synchronized (mEntriesMap) {
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
    AppEntry entry=mEntriesMap.get(stats.packageName);
    if (entry != null) {
synchronized (entry) {
        entry.sizeStale=false;
        entry.sizeLoadStart=0;
        long newSize=getTotalSize(stats);
        if (entry.size != newSize || entry.cacheSize != stats.cacheSize || entry.codeSize != stats.codeSize || entry.dataSize != stats.dataSize) {
          entry.size=newSize;
          entry.cacheSize=stats.cacheSize;
          entry.codeSize=stats.codeSize;
          entry.dataSize=stats.dataSize;
          entry.sizeStr=getSizeStr(entry.size);
          if (DEBUG)           Log.i(TAG,""String_Node_Str"" + entry.label + ""String_Node_Str""+ entry+ ""String_Node_Str""+ entry.sizeStr);
          sizeChanged=true;
        }
      }
      if (sizeChanged) {
        Message msg=mMainHandler.obtainMessage(MainHandler.MSG_PACKAGE_SIZE_CHANGED,stats.packageName);
        mMainHandler.sendMessage(msg);
      }
    }
    if (mCurComputingSizePkg == null || mCurComputingSizePkg.equals(stats.packageName)) {
      mCurComputingSizePkg=null;
      sendEmptyMessage(MSG_LOAD_SIZES);
    }
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
  }
}",0.955503512880562
180797,"void requestSize(String packageName){
synchronized (mEntriesMap) {
    AppEntry entry=mEntriesMap.get(packageName);
    if (entry != null) {
      mPm.getPackageSizeInfo(packageName,mBackgroundHandler.mStatsObserver);
    }
  }
}","void requestSize(String packageName){
  if (DEBUG_LOCKING)   Log.v(TAG,""String_Node_Str"");
synchronized (mEntriesMap) {
    AppEntry entry=mEntriesMap.get(packageName);
    if (entry != null) {
      mPm.getPackageSizeInfo(packageName,mBackgroundHandler.mStatsObserver);
    }
    if (DEBUG_LOCKING)     Log.v(TAG,""String_Node_Str"");
  }
}",0.8063380281690141
180798,"@Override public void onRebuildComplete(ArrayList<AppEntry> apps){
  mListContainer.setVisibility(View.VISIBLE);
  mLoadingContainer.setVisibility(View.GONE);
  mWaitingForData=false;
  mBaseEntries=apps;
  mEntries=applyPrefixFilter(mCurFilterPrefix,mBaseEntries);
  notifyDataSetChanged();
  updateStorageUsage();
}","@Override public void onRebuildComplete(ArrayList<AppEntry> apps){
  if (mLoadingContainer.getVisibility() == View.VISIBLE) {
    mLoadingContainer.startAnimation(AnimationUtils.loadAnimation(ManageApplications.this,android.R.anim.fade_out));
    mListContainer.startAnimation(AnimationUtils.loadAnimation(ManageApplications.this,android.R.anim.fade_in));
  }
  mListContainer.setVisibility(View.VISIBLE);
  mLoadingContainer.setVisibility(View.GONE);
  mWaitingForData=false;
  mBaseEntries=apps;
  mEntries=applyPrefixFilter(mCurFilterPrefix,mBaseEntries);
  notifyDataSetChanged();
  updateStorageUsage();
}",0.6494066882416397
180799,"void onBondingDockConnect(){
  mConnectAttempted=SystemClock.elapsedRealtime();
}","void onBondingDockConnect(){
  connect();
}",0.6774193548387096
180800,"void onBondingDockConnect(){
  mConnectAttempted=SystemClock.elapsedRealtime();
}","void onBondingDockConnect(){
  connect();
}",0.6774193548387096
180801,"public void disconnect(Profile profile){
  queueCommand(new BluetoothJob(BluetoothCommand.DISCONNECT,this,profile));
}","public void disconnect(Profile profile){
  disconnectInt(this,profile);
}",0.6910994764397905
180802,"public void onProfileStateChanged(Profile profile,int newProfileState){
synchronized (workQueue) {
    if (D) {
      Log.d(TAG,""String_Node_Str"" + workQueue.toString());
    }
    int newState=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile).convertState(newProfileState);
    if (newState == SettingsBtStatus.CONNECTION_STATUS_CONNECTED) {
      if (!mProfiles.contains(profile)) {
        mProfiles.add(profile);
      }
    }
    if (newState == SettingsBtStatus.CONNECTION_STATUS_CONNECTED || newState == SettingsBtStatus.CONNECTION_STATUS_DISCONNECTED) {
      BluetoothJob job=workQueue.peek();
      if (job == null) {
        return;
      }
 else       if (!job.cachedDevice.mDevice.equals(mDevice)) {
        if (D) {
          Log.d(TAG,""String_Node_Str"" + mDevice + ""String_Node_Str""+ job.toString());
        }
        if (!pruneQueue(null)) {
          return;
        }
      }
 else {
        workQueue.poll();
      }
      processCommands();
    }
  }
}","public void onProfileStateChanged(Profile profile,int newProfileState){
  if (D) {
    Log.d(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ newProfileState);
  }
  int newState=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile).convertState(newProfileState);
  if (newState == SettingsBtStatus.CONNECTION_STATUS_CONNECTED) {
    if (!mProfiles.contains(profile)) {
      mProfiles.add(profile);
    }
  }
}",0.5310104529616725
180803,"public void unpair(){
  disconnect();
  int state=getBondState();
  if (state == BluetoothDevice.BOND_BONDING) {
    mDevice.cancelBondProcess();
  }
  if (state != BluetoothDevice.BOND_NONE) {
    queueCommand(new BluetoothJob(BluetoothCommand.REMOVE_BOND,this,null));
  }
}","public void unpair(){
  disconnect();
  int state=getBondState();
  if (state == BluetoothDevice.BOND_BONDING) {
    mDevice.cancelBondProcess();
  }
  if (state != BluetoothDevice.BOND_NONE) {
    final BluetoothDevice dev=getDevice();
    if (dev != null) {
      final boolean successful=dev.removeBond();
      if (successful) {
        if (D) {
          Log.d(TAG,""String_Node_Str"" + describe(null));
        }
      }
 else       if (V) {
        Log.v(TAG,""String_Node_Str"" + describe(null));
      }
    }
  }
}",0.5081761006289308
180804,"private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        disconnectConnected(profile);
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}","private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        disconnectConnected(profile);
        connectInt(this,profile);
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}",0.9444081098757358
180805,"private boolean disconnectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.disconnect(cachedDevice.mDevice)) {
      return true;
    }
  }
  return false;
}","private boolean disconnectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.disconnect(cachedDevice.mDevice)) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + describe(profile));
      }
      return true;
    }
    if (V) {
      Log.v(TAG,""String_Node_Str"" + describe(profile));
    }
  }
  return false;
}",0.8042635658914729
180806,"public void onBondingStateChanged(int bondState){
  if (bondState == BluetoothDevice.BOND_NONE) {
    mProfiles.clear();
    BluetoothJob job=workQueue.peek();
    if (job != null) {
      if (job.command == BluetoothCommand.REMOVE_BOND && job.cachedDevice.mDevice.equals(mDevice)) {
        workQueue.poll();
      }
 else {
        if (D) {
          Log.d(TAG,""String_Node_Str"" + job.command);
          Log.d(TAG,""String_Node_Str"" + mDevice + ""String_Node_Str""+ job.toString());
        }
        if (!pruneQueue(null)) {
          refresh();
          return;
        }
      }
      processCommands();
    }
  }
  refresh();
}","public void onBondingStateChanged(int bondState){
  if (bondState == BluetoothDevice.BOND_NONE) {
    mProfiles.clear();
  }
  refresh();
}",0.3605706874189364
180807,"private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      disconnectConnected(profile);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}","private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      disconnectConnected(profile);
      connectInt(this,profile);
    }
  }
}",0.9069003285870756
180808,"public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  disconnectConnected(profile);
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}","public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  disconnectConnected(profile);
  connectInt(this,profile);
}",0.8722891566265061
180809,"private void disconnectConnected(Profile profile){
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  CachedBluetoothDeviceManager cachedDeviceManager=mLocalManager.getCachedDeviceManager();
  Set<BluetoothDevice> devices=profileManager.getConnectedDevices();
  if (devices == null)   return;
  for (  BluetoothDevice device : devices) {
    CachedBluetoothDevice cachedDevice=cachedDeviceManager.findDevice(device);
    if (cachedDevice != null) {
      queueCommand(new BluetoothJob(BluetoothCommand.DISCONNECT,cachedDevice,profile));
    }
  }
}","private void disconnectConnected(Profile profile){
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  CachedBluetoothDeviceManager cachedDeviceManager=mLocalManager.getCachedDeviceManager();
  Set<BluetoothDevice> devices=profileManager.getConnectedDevices();
  if (devices == null)   return;
  for (  BluetoothDevice device : devices) {
    CachedBluetoothDevice cachedDevice=cachedDeviceManager.findDevice(device);
    if (cachedDevice != null) {
      disconnectInt(cachedDevice,profile);
    }
  }
}",0.9401853411962932
180810,"private boolean connectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  if (!cachedDevice.ensurePaired())   return false;
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (!SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.connect(cachedDevice.mDevice)) {
      return true;
    }
    Log.i(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ cachedDevice.mName);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  return false;
}","private boolean connectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  if (!cachedDevice.ensurePaired())   return false;
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (!SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.connect(cachedDevice.mDevice)) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + describe(profile));
      }
      return true;
    }
    Log.i(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ cachedDevice.mName);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  return false;
}",0.8042010502625656
180811,"public void disconnect(Profile profile){
  queueCommand(new BluetoothJob(BluetoothCommand.DISCONNECT,this,profile));
}","public void disconnect(Profile profile){
  disconnectInt(this,profile);
}",0.6910994764397905
180812,"public void onProfileStateChanged(Profile profile,int newProfileState){
synchronized (workQueue) {
    if (D) {
      Log.d(TAG,""String_Node_Str"" + workQueue.toString());
    }
    int newState=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile).convertState(newProfileState);
    if (newState == SettingsBtStatus.CONNECTION_STATUS_CONNECTED) {
      if (!mProfiles.contains(profile)) {
        mProfiles.add(profile);
      }
    }
    if (newState == SettingsBtStatus.CONNECTION_STATUS_CONNECTED || newState == SettingsBtStatus.CONNECTION_STATUS_DISCONNECTED) {
      BluetoothJob job=workQueue.peek();
      if (job == null) {
        return;
      }
 else       if (!job.cachedDevice.mDevice.equals(mDevice)) {
        if (D) {
          Log.d(TAG,""String_Node_Str"" + mDevice + ""String_Node_Str""+ job.toString());
        }
        if (!pruneQueue(null)) {
          return;
        }
      }
 else {
        workQueue.poll();
      }
      processCommands();
    }
  }
}","public void onProfileStateChanged(Profile profile,int newProfileState){
  if (D) {
    Log.d(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ newProfileState);
  }
  int newState=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile).convertState(newProfileState);
  if (newState == SettingsBtStatus.CONNECTION_STATUS_CONNECTED) {
    if (!mProfiles.contains(profile)) {
      mProfiles.add(profile);
    }
  }
}",0.5310104529616725
180813,"public void unpair(){
  disconnect();
  int state=getBondState();
  if (state == BluetoothDevice.BOND_BONDING) {
    mDevice.cancelBondProcess();
  }
  if (state != BluetoothDevice.BOND_NONE) {
    queueCommand(new BluetoothJob(BluetoothCommand.REMOVE_BOND,this,null));
  }
}","public void unpair(){
  disconnect();
  int state=getBondState();
  if (state == BluetoothDevice.BOND_BONDING) {
    mDevice.cancelBondProcess();
  }
  if (state != BluetoothDevice.BOND_NONE) {
    final BluetoothDevice dev=getDevice();
    if (dev != null) {
      final boolean successful=dev.removeBond();
      if (successful) {
        if (D) {
          Log.d(TAG,""String_Node_Str"" + describe(null));
        }
      }
 else       if (V) {
        Log.v(TAG,""String_Node_Str"" + describe(null));
      }
    }
  }
}",0.5081761006289308
180814,"private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        disconnectConnected(profile);
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}","private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        disconnectConnected(profile);
        connectInt(this,profile);
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}",0.9444081098757358
180815,"private boolean disconnectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.disconnect(cachedDevice.mDevice)) {
      return true;
    }
  }
  return false;
}","private boolean disconnectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.disconnect(cachedDevice.mDevice)) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + describe(profile));
      }
      return true;
    }
    if (V) {
      Log.v(TAG,""String_Node_Str"" + describe(profile));
    }
  }
  return false;
}",0.8042635658914729
180816,"public void onBondingStateChanged(int bondState){
  if (bondState == BluetoothDevice.BOND_NONE) {
    mProfiles.clear();
    BluetoothJob job=workQueue.peek();
    if (job != null) {
      if (job.command == BluetoothCommand.REMOVE_BOND && job.cachedDevice.mDevice.equals(mDevice)) {
        workQueue.poll();
      }
 else {
        if (D) {
          Log.d(TAG,""String_Node_Str"" + job.command);
          Log.d(TAG,""String_Node_Str"" + mDevice + ""String_Node_Str""+ job.toString());
        }
        if (!pruneQueue(null)) {
          refresh();
          return;
        }
      }
      processCommands();
    }
  }
  refresh();
}","public void onBondingStateChanged(int bondState){
  if (bondState == BluetoothDevice.BOND_NONE) {
    mProfiles.clear();
  }
  refresh();
}",0.3605706874189364
180817,"private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      disconnectConnected(profile);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}","private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      disconnectConnected(profile);
      connectInt(this,profile);
    }
  }
}",0.9069003285870756
180818,"public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  disconnectConnected(profile);
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}","public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  disconnectConnected(profile);
  connectInt(this,profile);
}",0.8722891566265061
180819,"private void disconnectConnected(Profile profile){
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  CachedBluetoothDeviceManager cachedDeviceManager=mLocalManager.getCachedDeviceManager();
  Set<BluetoothDevice> devices=profileManager.getConnectedDevices();
  if (devices == null)   return;
  for (  BluetoothDevice device : devices) {
    CachedBluetoothDevice cachedDevice=cachedDeviceManager.findDevice(device);
    if (cachedDevice != null) {
      queueCommand(new BluetoothJob(BluetoothCommand.DISCONNECT,cachedDevice,profile));
    }
  }
}","private void disconnectConnected(Profile profile){
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  CachedBluetoothDeviceManager cachedDeviceManager=mLocalManager.getCachedDeviceManager();
  Set<BluetoothDevice> devices=profileManager.getConnectedDevices();
  if (devices == null)   return;
  for (  BluetoothDevice device : devices) {
    CachedBluetoothDevice cachedDevice=cachedDeviceManager.findDevice(device);
    if (cachedDevice != null) {
      disconnectInt(cachedDevice,profile);
    }
  }
}",0.9401853411962932
180820,"private boolean connectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  if (!cachedDevice.ensurePaired())   return false;
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (!SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.connect(cachedDevice.mDevice)) {
      return true;
    }
    Log.i(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ cachedDevice.mName);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  return false;
}","private boolean connectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  if (!cachedDevice.ensurePaired())   return false;
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (!SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.connect(cachedDevice.mDevice)) {
      if (D) {
        Log.d(TAG,""String_Node_Str"" + describe(profile));
      }
      return true;
    }
    Log.i(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ cachedDevice.mName);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  return false;
}",0.8042010502625656
180821,"private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + getSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
}
if (getSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED)) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
if (mBtManager.getBluetoothAdapter().disable()) {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
 else {
setSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT,true);
mPendingTurnOffStartId=startId;
deferFinishCall=true;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + startId);
}
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}","private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  final int state=msg.arg1;
  final int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
LocalBluetoothProfileManager.addServiceListener(this);
if (LocalBluetoothProfileManager.isManagerReady()) {
handleDocked(device,state,startId);
LocalBluetoothProfileManager.removeServiceListener(this);
}
 else {
final BluetoothDevice d=device;
mRunnable=new Runnable(){
public void run(){
handleDocked(d,state,startId);
}
}
;
deferFinishCall=true;
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + getSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
}
if (getSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED)) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
if (mBtManager.getBluetoothAdapter().disable()) {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
 else {
setSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT,true);
mPendingTurnOffStartId=startId;
deferFinishCall=true;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + startId);
}
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}",0.9073737740646568
180822,"@Override public void onDestroy(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  if (mDialog != null) {
    mDialog.dismiss();
    mDialog=null;
  }
  mServiceLooper.quit();
}","@Override public void onDestroy(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  mRunnable=null;
  LocalBluetoothProfileManager.removeServiceListener(this);
  if (mDialog != null) {
    mDialog.dismiss();
    mDialog=null;
  }
  mServiceLooper.quit();
}",0.8186046511627907
180823,"private synchronized void handleUndocked(Context context,LocalBluetoothManager localManager,BluetoothDevice device){
  if (mDialog != null) {
    mDialog.dismiss();
    mDialog=null;
  }
  mDevice=null;
  mPendingDevice=null;
  CachedBluetoothDevice cachedBluetoothDevice=getCachedBluetoothDevice(context,localManager,device);
  cachedBluetoothDevice.disconnect();
}","private synchronized void handleUndocked(Context context,LocalBluetoothManager localManager,BluetoothDevice device){
  mRunnable=null;
  LocalBluetoothProfileManager.removeServiceListener(this);
  if (mDialog != null) {
    mDialog.dismiss();
    mDialog=null;
  }
  mDevice=null;
  mPendingDevice=null;
  CachedBluetoothDevice cachedBluetoothDevice=getCachedBluetoothDevice(context,localManager,device);
  cachedBluetoothDevice.disconnect();
}",0.9012345679012346
180824,"public void onServiceDisconnected(){
}","public void onServiceDisconnected(){
  profileReady=false;
  if (mServiceListeners.size() > 0) {
    Iterator<ServiceListener> it=mServiceListeners.iterator();
    while (it.hasNext()) {
      it.next().onServiceDisconnected();
    }
  }
}",0.2743682310469314
180825,"public void onServiceConnected(){
  mUiHandler.post(new Runnable(){
    public void run(){
      BluetoothDevice device=mService.getCurrentHeadset();
      if (device == null)       return;
      mLocalManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.HEADSET,BluetoothHeadset.STATE_CONNECTED);
    }
  }
);
}","public void onServiceConnected(){
  profileReady=true;
  mUiHandler.post(new Runnable(){
    public void run(){
      BluetoothDevice device=mService.getCurrentHeadset();
      if (device == null)       return;
      mLocalManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.HEADSET,BluetoothHeadset.STATE_CONNECTED);
    }
  }
);
  if (mServiceListeners.size() > 0) {
    Iterator<ServiceListener> it=mServiceListeners.iterator();
    while (it.hasNext()) {
      it.next().onServiceConnected();
    }
  }
}",0.7695906432748538
180826,"private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + getSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
}
if (getSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED)) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
if (mBtManager.getBluetoothAdapter().disable()) {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
 else {
setSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT,true);
mPendingTurnOffStartId=startId;
deferFinishCall=true;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + startId);
}
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}","private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  final int state=msg.arg1;
  final int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
LocalBluetoothProfileManager.addServiceListener(this);
if (LocalBluetoothProfileManager.isManagerReady()) {
handleDocked(device,state,startId);
LocalBluetoothProfileManager.removeServiceListener(this);
}
 else {
final BluetoothDevice d=device;
mRunnable=new Runnable(){
public void run(){
handleDocked(d,state,startId);
}
}
;
deferFinishCall=true;
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + getSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
}
if (getSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED)) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
if (mBtManager.getBluetoothAdapter().disable()) {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
 else {
setSettingBool(SHARED_PREFERENCES_KEY_DISABLE_BT,true);
mPendingTurnOffStartId=startId;
deferFinishCall=true;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + startId);
}
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}",0.9073737740646568
180827,"@Override public void onDestroy(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  if (mDialog != null) {
    mDialog.dismiss();
    mDialog=null;
  }
  mServiceLooper.quit();
}","@Override public void onDestroy(){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  mRunnable=null;
  LocalBluetoothProfileManager.removeServiceListener(this);
  if (mDialog != null) {
    mDialog.dismiss();
    mDialog=null;
  }
  mServiceLooper.quit();
}",0.8186046511627907
180828,"private synchronized void handleUndocked(Context context,LocalBluetoothManager localManager,BluetoothDevice device){
  if (mDialog != null) {
    mDialog.dismiss();
    mDialog=null;
  }
  mDevice=null;
  mPendingDevice=null;
  CachedBluetoothDevice cachedBluetoothDevice=getCachedBluetoothDevice(context,localManager,device);
  cachedBluetoothDevice.disconnect();
}","private synchronized void handleUndocked(Context context,LocalBluetoothManager localManager,BluetoothDevice device){
  mRunnable=null;
  LocalBluetoothProfileManager.removeServiceListener(this);
  if (mDialog != null) {
    mDialog.dismiss();
    mDialog=null;
  }
  mDevice=null;
  mPendingDevice=null;
  CachedBluetoothDevice cachedBluetoothDevice=getCachedBluetoothDevice(context,localManager,device);
  cachedBluetoothDevice.disconnect();
}",0.9012345679012346
180829,"public void onServiceDisconnected(){
}","public void onServiceDisconnected(){
  profileReady=false;
  if (mServiceListeners.size() > 0) {
    Iterator<ServiceListener> it=mServiceListeners.iterator();
    while (it.hasNext()) {
      it.next().onServiceDisconnected();
    }
  }
}",0.2743682310469314
180830,"public void onServiceConnected(){
  mUiHandler.post(new Runnable(){
    public void run(){
      BluetoothDevice device=mService.getCurrentHeadset();
      if (device == null)       return;
      mLocalManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.HEADSET,BluetoothHeadset.STATE_CONNECTED);
    }
  }
);
}","public void onServiceConnected(){
  profileReady=true;
  mUiHandler.post(new Runnable(){
    public void run(){
      BluetoothDevice device=mService.getCurrentHeadset();
      if (device == null)       return;
      mLocalManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.HEADSET,BluetoothHeadset.STATE_CONNECTED);
    }
  }
);
  if (mServiceListeners.size() > 0) {
    Iterator<ServiceListener> it=mServiceListeners.iterator();
    while (it.hasNext()) {
      it.next().onServiceConnected();
    }
  }
}",0.7695906432748538
180831,"protected void onCreate(Bundle savedInstanceState){
  mView=getLayoutInflater().inflate(R.layout.wifi_ap_dialog,null);
  Spinner mSecurity=((Spinner)mView.findViewById(R.id.security));
  setView(mView);
  setInverseBackgroundForced(true);
  Context context=getContext();
  setTitle(R.string.wifi_tether_configure_ap_text);
  mView.findViewById(R.id.type).setVisibility(View.VISIBLE);
  mSsid=(TextView)mView.findViewById(R.id.ssid);
  mPassword=(EditText)mView.findViewById(R.id.password);
  setButton(BUTTON_SUBMIT,context.getString(R.string.wifi_save),mListener);
  setButton(DialogInterface.BUTTON_NEGATIVE,context.getString(R.string.wifi_cancel),mListener);
  if (mWifiConfig != null) {
    mSsid.setText(mWifiConfig.SSID);
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
      mSecurity.setSelection(OPEN_INDEX);
    break;
case AccessPoint.SECURITY_PSK:
  String str=mWifiConfig.preSharedKey;
if (!str.matches(""String_Node_Str"")) {
  str=str.substring(1,str.length() - 1);
}
mPassword.setText(str);
mSecurity.setSelection(WPA_INDEX);
break;
}
}
mSsid.addTextChangedListener(this);
mPassword.addTextChangedListener(this);
((CheckBox)mView.findViewById(R.id.show_password)).setOnClickListener(this);
mSecurity.setOnItemSelectedListener(this);
super.onCreate(savedInstanceState);
showSecurityFields();
validate();
}","protected void onCreate(Bundle savedInstanceState){
  mView=getLayoutInflater().inflate(R.layout.wifi_ap_dialog,null);
  Spinner mSecurity=((Spinner)mView.findViewById(R.id.security));
  setView(mView);
  setInverseBackgroundForced(true);
  Context context=getContext();
  setTitle(R.string.wifi_tether_configure_ap_text);
  mView.findViewById(R.id.type).setVisibility(View.VISIBLE);
  mSsid=(TextView)mView.findViewById(R.id.ssid);
  mPassword=(EditText)mView.findViewById(R.id.password);
  setButton(BUTTON_SUBMIT,context.getString(R.string.wifi_save),mListener);
  setButton(DialogInterface.BUTTON_NEGATIVE,context.getString(R.string.wifi_cancel),mListener);
  if (mWifiConfig != null) {
    mSsid.setText(AccessPoint.removeDoubleQuotes(mWifiConfig.SSID));
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
      mSecurity.setSelection(OPEN_INDEX);
    break;
case AccessPoint.SECURITY_PSK:
  String str=mWifiConfig.preSharedKey;
if (!str.matches(""String_Node_Str"")) {
  str=str.substring(1,str.length() - 1);
}
mPassword.setText(str);
mSecurity.setSelection(WPA_INDEX);
break;
}
}
mSsid.addTextChangedListener(this);
mPassword.addTextChangedListener(this);
((CheckBox)mView.findViewById(R.id.show_password)).setOnClickListener(this);
mSecurity.setOnItemSelectedListener(this);
super.onCreate(savedInstanceState);
showSecurityFields();
validate();
}",0.9880863737900224
180832,"public WifiConfiguration getConfig(){
  WifiConfiguration config=new WifiConfiguration();
  config.SSID=mSsid.getText().toString();
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
}
return null;
}","public WifiConfiguration getConfig(){
  WifiConfiguration config=new WifiConfiguration();
  config.SSID=AccessPoint.convertToQuotedString(mSsid.getText().toString());
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
}
return null;
}",0.9606784888203548
180833,"void updateConfigSummary(WifiConfiguration wifiConfig){
  String s=mContext.getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
  mCheckBox.setSummary(String.format(mContext.getString(R.string.wifi_tether_enabled_subtext),(wifiConfig == null) ? s : wifiConfig.SSID));
}","void updateConfigSummary(WifiConfiguration wifiConfig){
  String s=mContext.getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
  mCheckBox.setSummary(String.format(mContext.getString(R.string.wifi_tether_enabled_subtext),(wifiConfig == null) ? s : AccessPoint.removeDoubleQuotes(wifiConfig.SSID)));
}",0.9483870967741936
180834,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mWifiManager=(WifiManager)getSystemService(Context.WIFI_SERVICE);
  mWifiConfig=mWifiManager.getWifiApConfiguration();
  mSecurityType=getResources().getStringArray(R.array.wifi_ap_security);
  addPreferencesFromResource(R.xml.wifi_ap_settings);
  mCreateNetwork=findPreference(WIFI_AP_SSID_AND_SECURITY);
  mEnableWifiAp=(CheckBoxPreference)findPreference(ENABLE_WIFI_AP);
  mWifiApEnabler=new WifiApEnabler(this,mEnableWifiAp);
  if (mWifiConfig == null) {
    String s=getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),s,mSecurityType[OPEN_INDEX]));
  }
 else {
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),mWifiConfig.SSID,mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mWifiManager=(WifiManager)getSystemService(Context.WIFI_SERVICE);
  mWifiConfig=mWifiManager.getWifiApConfiguration();
  mSecurityType=getResources().getStringArray(R.array.wifi_ap_security);
  addPreferencesFromResource(R.xml.wifi_ap_settings);
  mCreateNetwork=findPreference(WIFI_AP_SSID_AND_SECURITY);
  mEnableWifiAp=(CheckBoxPreference)findPreference(ENABLE_WIFI_AP);
  mWifiApEnabler=new WifiApEnabler(this,mEnableWifiAp);
  if (mWifiConfig == null) {
    String s=getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),s,mSecurityType[OPEN_INDEX]));
  }
 else {
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),AccessPoint.removeDoubleQuotes(mWifiConfig.SSID),mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
  }
}",0.9684959349593496
180835,"public void onClick(DialogInterface dialogInterface,int button){
  if (button == DialogInterface.BUTTON_POSITIVE) {
    mWifiConfig=mDialog.getConfig();
    if (mWifiConfig != null) {
      mWifiManager.setWifiApEnabled(mWifiConfig,true);
      mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),mWifiConfig.SSID,mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
      mWifiApEnabler.updateConfigSummary(mWifiConfig);
    }
  }
}","public void onClick(DialogInterface dialogInterface,int button){
  if (button == DialogInterface.BUTTON_POSITIVE) {
    mWifiConfig=mDialog.getConfig();
    if (mWifiConfig != null) {
      mWifiManager.setWifiApEnabled(mWifiConfig,true);
      mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),AccessPoint.removeDoubleQuotes(mWifiConfig.SSID),mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
      mWifiApEnabler.updateConfigSummary(mWifiConfig);
    }
  }
}",0.9386973180076628
180836,"WifiConfiguration getConfig(){
  if (mAccessPoint != null && mAccessPoint.networkId != -1 && !edit) {
    return null;
  }
  WifiConfiguration config=new WifiConfiguration();
  if (mAccessPoint == null) {
    config.SSID=mSsid.getText().toString();
    config.hiddenSSID=true;
  }
 else   if (mAccessPoint.networkId == -1) {
    config.SSID=mAccessPoint.ssid;
  }
 else {
    config.networkId=mAccessPoint.networkId;
  }
switch (mSecurity) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_WEP:
config.allowedKeyManagement.set(KeyMgmt.NONE);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
config.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
if (mPassword.length() != 0) {
int length=mPassword.length();
String password=mPassword.getText().toString();
if ((length == 10 || length == 26 || length == 58) && password.matches(""String_Node_Str"")) {
config.wepKeys[0]=password;
}
 else {
config.wepKeys[0]='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_EAP:
config.allowedKeyManagement.set(KeyMgmt.WPA_EAP);
config.allowedKeyManagement.set(KeyMgmt.IEEE8021X);
config.eap.setValue((String)mEapMethod.getSelectedItem());
config.ca_cert.setValue((mEapCaCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.CA_CERTIFICATE + (String)mEapCaCert.getSelectedItem());
config.client_cert.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_CERTIFICATE + (String)mEapUserCert.getSelectedItem());
config.private_key.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_PRIVATE_KEY + (String)mEapUserCert.getSelectedItem());
config.identity.setValue((mEapIdentity.length() == 0) ? ""String_Node_Str"" : mEapIdentity.getText().toString());
config.anonymous_identity.setValue((mEapAnonymous.length() == 0) ? ""String_Node_Str"" : mEapAnonymous.getText().toString());
if (mPassword.length() != 0) {
config.password.setValue(mPassword.getText().toString());
}
return config;
}
return null;
}","WifiConfiguration getConfig(){
  if (mAccessPoint != null && mAccessPoint.networkId != -1 && !edit) {
    return null;
  }
  WifiConfiguration config=new WifiConfiguration();
  if (mAccessPoint == null) {
    config.SSID=AccessPoint.convertToQuotedString(mSsid.getText().toString());
    config.hiddenSSID=true;
  }
 else   if (mAccessPoint.networkId == -1) {
    config.SSID=AccessPoint.convertToQuotedString(mAccessPoint.ssid);
  }
 else {
    config.networkId=mAccessPoint.networkId;
  }
switch (mSecurity) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_WEP:
config.allowedKeyManagement.set(KeyMgmt.NONE);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
config.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
if (mPassword.length() != 0) {
int length=mPassword.length();
String password=mPassword.getText().toString();
if ((length == 10 || length == 26 || length == 58) && password.matches(""String_Node_Str"")) {
config.wepKeys[0]=password;
}
 else {
config.wepKeys[0]='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_EAP:
config.allowedKeyManagement.set(KeyMgmt.WPA_EAP);
config.allowedKeyManagement.set(KeyMgmt.IEEE8021X);
config.eap.setValue((String)mEapMethod.getSelectedItem());
config.ca_cert.setValue((mEapCaCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.CA_CERTIFICATE + (String)mEapCaCert.getSelectedItem());
config.client_cert.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_CERTIFICATE + (String)mEapUserCert.getSelectedItem());
config.private_key.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_PRIVATE_KEY + (String)mEapUserCert.getSelectedItem());
config.identity.setValue((mEapIdentity.length() == 0) ? ""String_Node_Str"" : mEapIdentity.getText().toString());
config.anonymous_identity.setValue((mEapAnonymous.length() == 0) ? ""String_Node_Str"" : mEapAnonymous.getText().toString());
if (mPassword.length() != 0) {
config.password.setValue(mPassword.getText().toString());
}
return config;
}
return null;
}",0.9756493506493508
180837,"@Override public boolean onContextItemSelected(MenuItem item){
  if (mSelected == null) {
    return super.onContextItemSelected(item);
  }
switch (item.getItemId()) {
case MENU_ID_CONNECT:
    if (mSelected.networkId != -1) {
      if (!requireKeyStore(mSelected.getConfig())) {
        connect(mSelected.networkId);
      }
    }
 else     if (mSelected.security == AccessPoint.SECURITY_NONE) {
      WifiConfiguration config=new WifiConfiguration();
      config.SSID=mSelected.ssid;
      config.allowedKeyManagement.set(KeyMgmt.NONE);
      int networkId=mWifiManager.addNetwork(config);
      mWifiManager.enableNetwork(networkId,false);
      connect(networkId);
    }
 else {
      showDialog(mSelected,false);
    }
  return true;
case MENU_ID_FORGET:
forget(mSelected.networkId);
return true;
case MENU_ID_MODIFY:
showDialog(mSelected,true);
return true;
}
return super.onContextItemSelected(item);
}","@Override public boolean onContextItemSelected(MenuItem item){
  if (mSelected == null) {
    return super.onContextItemSelected(item);
  }
switch (item.getItemId()) {
case MENU_ID_CONNECT:
    if (mSelected.networkId != -1) {
      if (!requireKeyStore(mSelected.getConfig())) {
        connect(mSelected.networkId);
      }
    }
 else     if (mSelected.security == AccessPoint.SECURITY_NONE) {
      WifiConfiguration config=new WifiConfiguration();
      config.SSID=AccessPoint.convertToQuotedString(mSelected.ssid);
      config.allowedKeyManagement.set(KeyMgmt.NONE);
      int networkId=mWifiManager.addNetwork(config);
      mWifiManager.enableNetwork(networkId,false);
      connect(networkId);
    }
 else {
      showDialog(mSelected,false);
    }
  return true;
case MENU_ID_FORGET:
forget(mSelected.networkId);
return true;
case MENU_ID_MODIFY:
showDialog(mSelected,true);
return true;
}
return super.onContextItemSelected(item);
}",0.9660377358490566
180838,"protected void onCreate(Bundle savedInstanceState){
  mView=getLayoutInflater().inflate(R.layout.wifi_ap_dialog,null);
  Spinner mSecurity=((Spinner)mView.findViewById(R.id.security));
  setView(mView);
  setInverseBackgroundForced(true);
  Context context=getContext();
  setTitle(R.string.wifi_tether_configure_ap_text);
  mView.findViewById(R.id.type).setVisibility(View.VISIBLE);
  mSsid=(TextView)mView.findViewById(R.id.ssid);
  mPassword=(EditText)mView.findViewById(R.id.password);
  setButton(BUTTON_SUBMIT,context.getString(R.string.wifi_save),mListener);
  setButton(DialogInterface.BUTTON_NEGATIVE,context.getString(R.string.wifi_cancel),mListener);
  if (mWifiConfig != null) {
    mSsid.setText(mWifiConfig.SSID);
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
      mSecurity.setSelection(OPEN_INDEX);
    break;
case AccessPoint.SECURITY_PSK:
  String str=mWifiConfig.preSharedKey;
if (!str.matches(""String_Node_Str"")) {
  str=str.substring(1,str.length() - 1);
}
mPassword.setText(str);
mSecurity.setSelection(WPA_INDEX);
break;
}
}
mSsid.addTextChangedListener(this);
mPassword.addTextChangedListener(this);
((CheckBox)mView.findViewById(R.id.show_password)).setOnClickListener(this);
mSecurity.setOnItemSelectedListener(this);
super.onCreate(savedInstanceState);
showSecurityFields();
validate();
}","protected void onCreate(Bundle savedInstanceState){
  mView=getLayoutInflater().inflate(R.layout.wifi_ap_dialog,null);
  Spinner mSecurity=((Spinner)mView.findViewById(R.id.security));
  setView(mView);
  setInverseBackgroundForced(true);
  Context context=getContext();
  setTitle(R.string.wifi_tether_configure_ap_text);
  mView.findViewById(R.id.type).setVisibility(View.VISIBLE);
  mSsid=(TextView)mView.findViewById(R.id.ssid);
  mPassword=(EditText)mView.findViewById(R.id.password);
  setButton(BUTTON_SUBMIT,context.getString(R.string.wifi_save),mListener);
  setButton(DialogInterface.BUTTON_NEGATIVE,context.getString(R.string.wifi_cancel),mListener);
  if (mWifiConfig != null) {
    mSsid.setText(AccessPoint.removeDoubleQuotes(mWifiConfig.SSID));
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
      mSecurity.setSelection(OPEN_INDEX);
    break;
case AccessPoint.SECURITY_PSK:
  String str=mWifiConfig.preSharedKey;
if (!str.matches(""String_Node_Str"")) {
  str=str.substring(1,str.length() - 1);
}
mPassword.setText(str);
mSecurity.setSelection(WPA_INDEX);
break;
}
}
mSsid.addTextChangedListener(this);
mPassword.addTextChangedListener(this);
((CheckBox)mView.findViewById(R.id.show_password)).setOnClickListener(this);
mSecurity.setOnItemSelectedListener(this);
super.onCreate(savedInstanceState);
showSecurityFields();
validate();
}",0.9880863737900224
180839,"public WifiConfiguration getConfig(){
  WifiConfiguration config=new WifiConfiguration();
  config.SSID=mSsid.getText().toString();
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
}
return null;
}","public WifiConfiguration getConfig(){
  WifiConfiguration config=new WifiConfiguration();
  config.SSID=AccessPoint.convertToQuotedString(mSsid.getText().toString());
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
}
return null;
}",0.9606784888203548
180840,"void updateConfigSummary(WifiConfiguration wifiConfig){
  String s=mContext.getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
  mCheckBox.setSummary(String.format(mContext.getString(R.string.wifi_tether_enabled_subtext),(wifiConfig == null) ? s : wifiConfig.SSID));
}","void updateConfigSummary(WifiConfiguration wifiConfig){
  String s=mContext.getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
  mCheckBox.setSummary(String.format(mContext.getString(R.string.wifi_tether_enabled_subtext),(wifiConfig == null) ? s : AccessPoint.removeDoubleQuotes(wifiConfig.SSID)));
}",0.9483870967741936
180841,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mWifiManager=(WifiManager)getSystemService(Context.WIFI_SERVICE);
  mWifiConfig=mWifiManager.getWifiApConfiguration();
  mSecurityType=getResources().getStringArray(R.array.wifi_ap_security);
  addPreferencesFromResource(R.xml.wifi_ap_settings);
  mCreateNetwork=findPreference(WIFI_AP_SSID_AND_SECURITY);
  mEnableWifiAp=(CheckBoxPreference)findPreference(ENABLE_WIFI_AP);
  mWifiApEnabler=new WifiApEnabler(this,mEnableWifiAp);
  if (mWifiConfig == null) {
    String s=getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),s,mSecurityType[OPEN_INDEX]));
  }
 else {
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),mWifiConfig.SSID,mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mWifiManager=(WifiManager)getSystemService(Context.WIFI_SERVICE);
  mWifiConfig=mWifiManager.getWifiApConfiguration();
  mSecurityType=getResources().getStringArray(R.array.wifi_ap_security);
  addPreferencesFromResource(R.xml.wifi_ap_settings);
  mCreateNetwork=findPreference(WIFI_AP_SSID_AND_SECURITY);
  mEnableWifiAp=(CheckBoxPreference)findPreference(ENABLE_WIFI_AP);
  mWifiApEnabler=new WifiApEnabler(this,mEnableWifiAp);
  if (mWifiConfig == null) {
    String s=getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),s,mSecurityType[OPEN_INDEX]));
  }
 else {
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),AccessPoint.removeDoubleQuotes(mWifiConfig.SSID),mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
  }
}",0.9684959349593496
180842,"public void onClick(DialogInterface dialogInterface,int button){
  if (button == DialogInterface.BUTTON_POSITIVE) {
    mWifiConfig=mDialog.getConfig();
    if (mWifiConfig != null) {
      mWifiManager.setWifiApEnabled(mWifiConfig,true);
      mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),mWifiConfig.SSID,mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
      mWifiApEnabler.updateConfigSummary(mWifiConfig);
    }
  }
}","public void onClick(DialogInterface dialogInterface,int button){
  if (button == DialogInterface.BUTTON_POSITIVE) {
    mWifiConfig=mDialog.getConfig();
    if (mWifiConfig != null) {
      mWifiManager.setWifiApEnabled(mWifiConfig,true);
      mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),AccessPoint.removeDoubleQuotes(mWifiConfig.SSID),mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
      mWifiApEnabler.updateConfigSummary(mWifiConfig);
    }
  }
}",0.9386973180076628
180843,"WifiConfiguration getConfig(){
  if (mAccessPoint != null && mAccessPoint.networkId != -1 && !edit) {
    return null;
  }
  WifiConfiguration config=new WifiConfiguration();
  if (mAccessPoint == null) {
    config.SSID=mSsid.getText().toString();
    config.hiddenSSID=true;
  }
 else   if (mAccessPoint.networkId == -1) {
    config.SSID=mAccessPoint.ssid;
  }
 else {
    config.networkId=mAccessPoint.networkId;
  }
switch (mSecurity) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_WEP:
config.allowedKeyManagement.set(KeyMgmt.NONE);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
config.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
if (mPassword.length() != 0) {
int length=mPassword.length();
String password=mPassword.getText().toString();
if ((length == 10 || length == 26 || length == 58) && password.matches(""String_Node_Str"")) {
config.wepKeys[0]=password;
}
 else {
config.wepKeys[0]='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_EAP:
config.allowedKeyManagement.set(KeyMgmt.WPA_EAP);
config.allowedKeyManagement.set(KeyMgmt.IEEE8021X);
config.eap.setValue((String)mEapMethod.getSelectedItem());
config.ca_cert.setValue((mEapCaCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.CA_CERTIFICATE + (String)mEapCaCert.getSelectedItem());
config.client_cert.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_CERTIFICATE + (String)mEapUserCert.getSelectedItem());
config.private_key.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_PRIVATE_KEY + (String)mEapUserCert.getSelectedItem());
config.identity.setValue((mEapIdentity.length() == 0) ? ""String_Node_Str"" : mEapIdentity.getText().toString());
config.anonymous_identity.setValue((mEapAnonymous.length() == 0) ? ""String_Node_Str"" : mEapAnonymous.getText().toString());
if (mPassword.length() != 0) {
config.password.setValue(mPassword.getText().toString());
}
return config;
}
return null;
}","WifiConfiguration getConfig(){
  if (mAccessPoint != null && mAccessPoint.networkId != -1 && !edit) {
    return null;
  }
  WifiConfiguration config=new WifiConfiguration();
  if (mAccessPoint == null) {
    config.SSID=AccessPoint.convertToQuotedString(mSsid.getText().toString());
    config.hiddenSSID=true;
  }
 else   if (mAccessPoint.networkId == -1) {
    config.SSID=AccessPoint.convertToQuotedString(mAccessPoint.ssid);
  }
 else {
    config.networkId=mAccessPoint.networkId;
  }
switch (mSecurity) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_WEP:
config.allowedKeyManagement.set(KeyMgmt.NONE);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
config.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
if (mPassword.length() != 0) {
int length=mPassword.length();
String password=mPassword.getText().toString();
if ((length == 10 || length == 26 || length == 58) && password.matches(""String_Node_Str"")) {
config.wepKeys[0]=password;
}
 else {
config.wepKeys[0]='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_EAP:
config.allowedKeyManagement.set(KeyMgmt.WPA_EAP);
config.allowedKeyManagement.set(KeyMgmt.IEEE8021X);
config.eap.setValue((String)mEapMethod.getSelectedItem());
config.ca_cert.setValue((mEapCaCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.CA_CERTIFICATE + (String)mEapCaCert.getSelectedItem());
config.client_cert.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_CERTIFICATE + (String)mEapUserCert.getSelectedItem());
config.private_key.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_PRIVATE_KEY + (String)mEapUserCert.getSelectedItem());
config.identity.setValue((mEapIdentity.length() == 0) ? ""String_Node_Str"" : mEapIdentity.getText().toString());
config.anonymous_identity.setValue((mEapAnonymous.length() == 0) ? ""String_Node_Str"" : mEapAnonymous.getText().toString());
if (mPassword.length() != 0) {
config.password.setValue(mPassword.getText().toString());
}
return config;
}
return null;
}",0.9756493506493508
180844,"@Override public boolean onContextItemSelected(MenuItem item){
  if (mSelected == null) {
    return super.onContextItemSelected(item);
  }
switch (item.getItemId()) {
case MENU_ID_CONNECT:
    if (mSelected.networkId != -1) {
      if (!requireKeyStore(mSelected.getConfig())) {
        connect(mSelected.networkId);
      }
    }
 else     if (mSelected.security == AccessPoint.SECURITY_NONE) {
      WifiConfiguration config=new WifiConfiguration();
      config.SSID=mSelected.ssid;
      config.allowedKeyManagement.set(KeyMgmt.NONE);
      int networkId=mWifiManager.addNetwork(config);
      mWifiManager.enableNetwork(networkId,false);
      connect(networkId);
    }
 else {
      showDialog(mSelected,false);
    }
  return true;
case MENU_ID_FORGET:
forget(mSelected.networkId);
return true;
case MENU_ID_MODIFY:
showDialog(mSelected,true);
return true;
}
return super.onContextItemSelected(item);
}","@Override public boolean onContextItemSelected(MenuItem item){
  if (mSelected == null) {
    return super.onContextItemSelected(item);
  }
switch (item.getItemId()) {
case MENU_ID_CONNECT:
    if (mSelected.networkId != -1) {
      if (!requireKeyStore(mSelected.getConfig())) {
        connect(mSelected.networkId);
      }
    }
 else     if (mSelected.security == AccessPoint.SECURITY_NONE) {
      WifiConfiguration config=new WifiConfiguration();
      config.SSID=AccessPoint.convertToQuotedString(mSelected.ssid);
      config.allowedKeyManagement.set(KeyMgmt.NONE);
      int networkId=mWifiManager.addNetwork(config);
      mWifiManager.enableNetwork(networkId,false);
      connect(networkId);
    }
 else {
      showDialog(mSelected,false);
    }
  return true;
case MENU_ID_FORGET:
forget(mSelected.networkId);
return true;
case MENU_ID_MODIFY:
showDialog(mSelected,true);
return true;
}
return super.onContextItemSelected(item);
}",0.9660377358490566
180845,"protected void onCreate(Bundle savedInstanceState){
  mView=getLayoutInflater().inflate(R.layout.wifi_ap_dialog,null);
  Spinner mSecurity=((Spinner)mView.findViewById(R.id.security));
  setView(mView);
  setInverseBackgroundForced(true);
  Context context=getContext();
  setTitle(R.string.wifi_tether_configure_ap_text);
  mView.findViewById(R.id.type).setVisibility(View.VISIBLE);
  mSsid=(TextView)mView.findViewById(R.id.ssid);
  mPassword=(EditText)mView.findViewById(R.id.password);
  setButton(BUTTON_SUBMIT,context.getString(R.string.wifi_save),mListener);
  setButton(DialogInterface.BUTTON_NEGATIVE,context.getString(R.string.wifi_cancel),mListener);
  if (mWifiConfig != null) {
    mSsid.setText(mWifiConfig.SSID);
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
      mSecurity.setSelection(OPEN_INDEX);
    break;
case AccessPoint.SECURITY_PSK:
  String str=mWifiConfig.preSharedKey;
if (!str.matches(""String_Node_Str"")) {
  str=str.substring(1,str.length() - 1);
}
mPassword.setText(str);
mSecurity.setSelection(WPA_INDEX);
break;
}
}
mSsid.addTextChangedListener(this);
mPassword.addTextChangedListener(this);
((CheckBox)mView.findViewById(R.id.show_password)).setOnClickListener(this);
mSecurity.setOnItemSelectedListener(this);
super.onCreate(savedInstanceState);
showSecurityFields();
validate();
}","protected void onCreate(Bundle savedInstanceState){
  mView=getLayoutInflater().inflate(R.layout.wifi_ap_dialog,null);
  Spinner mSecurity=((Spinner)mView.findViewById(R.id.security));
  setView(mView);
  setInverseBackgroundForced(true);
  Context context=getContext();
  setTitle(R.string.wifi_tether_configure_ap_text);
  mView.findViewById(R.id.type).setVisibility(View.VISIBLE);
  mSsid=(TextView)mView.findViewById(R.id.ssid);
  mPassword=(EditText)mView.findViewById(R.id.password);
  setButton(BUTTON_SUBMIT,context.getString(R.string.wifi_save),mListener);
  setButton(DialogInterface.BUTTON_NEGATIVE,context.getString(R.string.wifi_cancel),mListener);
  if (mWifiConfig != null) {
    mSsid.setText(AccessPoint.removeDoubleQuotes(mWifiConfig.SSID));
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
      mSecurity.setSelection(OPEN_INDEX);
    break;
case AccessPoint.SECURITY_PSK:
  String str=mWifiConfig.preSharedKey;
if (!str.matches(""String_Node_Str"")) {
  str=str.substring(1,str.length() - 1);
}
mPassword.setText(str);
mSecurity.setSelection(WPA_INDEX);
break;
}
}
mSsid.addTextChangedListener(this);
mPassword.addTextChangedListener(this);
((CheckBox)mView.findViewById(R.id.show_password)).setOnClickListener(this);
mSecurity.setOnItemSelectedListener(this);
super.onCreate(savedInstanceState);
showSecurityFields();
validate();
}",0.9880863737900224
180846,"public WifiConfiguration getConfig(){
  WifiConfiguration config=new WifiConfiguration();
  config.SSID=mSsid.getText().toString();
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
}
return null;
}","public WifiConfiguration getConfig(){
  WifiConfiguration config=new WifiConfiguration();
  config.SSID=AccessPoint.convertToQuotedString(mSsid.getText().toString());
switch (mSecurityType) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
}
return null;
}",0.9606784888203548
180847,"void updateConfigSummary(WifiConfiguration wifiConfig){
  String s=mContext.getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
  mCheckBox.setSummary(String.format(mContext.getString(R.string.wifi_tether_enabled_subtext),(wifiConfig == null) ? s : wifiConfig.SSID));
}","void updateConfigSummary(WifiConfiguration wifiConfig){
  String s=mContext.getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
  mCheckBox.setSummary(String.format(mContext.getString(R.string.wifi_tether_enabled_subtext),(wifiConfig == null) ? s : AccessPoint.removeDoubleQuotes(wifiConfig.SSID)));
}",0.9483870967741936
180848,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mWifiManager=(WifiManager)getSystemService(Context.WIFI_SERVICE);
  mWifiConfig=mWifiManager.getWifiApConfiguration();
  mSecurityType=getResources().getStringArray(R.array.wifi_ap_security);
  addPreferencesFromResource(R.xml.wifi_ap_settings);
  mCreateNetwork=findPreference(WIFI_AP_SSID_AND_SECURITY);
  mEnableWifiAp=(CheckBoxPreference)findPreference(ENABLE_WIFI_AP);
  mWifiApEnabler=new WifiApEnabler(this,mEnableWifiAp);
  if (mWifiConfig == null) {
    String s=getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),s,mSecurityType[OPEN_INDEX]));
  }
 else {
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),mWifiConfig.SSID,mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mWifiManager=(WifiManager)getSystemService(Context.WIFI_SERVICE);
  mWifiConfig=mWifiManager.getWifiApConfiguration();
  mSecurityType=getResources().getStringArray(R.array.wifi_ap_security);
  addPreferencesFromResource(R.xml.wifi_ap_settings);
  mCreateNetwork=findPreference(WIFI_AP_SSID_AND_SECURITY);
  mEnableWifiAp=(CheckBoxPreference)findPreference(ENABLE_WIFI_AP);
  mWifiApEnabler=new WifiApEnabler(this,mEnableWifiAp);
  if (mWifiConfig == null) {
    String s=getString(com.android.internal.R.string.wifi_tether_configure_ssid_default);
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),s,mSecurityType[OPEN_INDEX]));
  }
 else {
    mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),AccessPoint.removeDoubleQuotes(mWifiConfig.SSID),mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
  }
}",0.9684959349593496
180849,"public void onClick(DialogInterface dialogInterface,int button){
  if (button == DialogInterface.BUTTON_POSITIVE) {
    mWifiConfig=mDialog.getConfig();
    if (mWifiConfig != null) {
      mWifiManager.setWifiApEnabled(mWifiConfig,true);
      mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),mWifiConfig.SSID,mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
      mWifiApEnabler.updateConfigSummary(mWifiConfig);
    }
  }
}","public void onClick(DialogInterface dialogInterface,int button){
  if (button == DialogInterface.BUTTON_POSITIVE) {
    mWifiConfig=mDialog.getConfig();
    if (mWifiConfig != null) {
      mWifiManager.setWifiApEnabled(mWifiConfig,true);
      mCreateNetwork.setSummary(String.format(getString(CONFIG_SUBTEXT),AccessPoint.removeDoubleQuotes(mWifiConfig.SSID),mWifiConfig.allowedKeyManagement.get(KeyMgmt.WPA_PSK) ? mSecurityType[WPA_INDEX] : mSecurityType[OPEN_INDEX]));
      mWifiApEnabler.updateConfigSummary(mWifiConfig);
    }
  }
}",0.9386973180076628
180850,"WifiConfiguration getConfig(){
  if (mAccessPoint != null && mAccessPoint.networkId != -1 && !edit) {
    return null;
  }
  WifiConfiguration config=new WifiConfiguration();
  if (mAccessPoint == null) {
    config.SSID=mSsid.getText().toString();
    config.hiddenSSID=true;
  }
 else   if (mAccessPoint.networkId == -1) {
    config.SSID=mAccessPoint.ssid;
  }
 else {
    config.networkId=mAccessPoint.networkId;
  }
switch (mSecurity) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_WEP:
config.allowedKeyManagement.set(KeyMgmt.NONE);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
config.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
if (mPassword.length() != 0) {
int length=mPassword.length();
String password=mPassword.getText().toString();
if ((length == 10 || length == 26 || length == 58) && password.matches(""String_Node_Str"")) {
config.wepKeys[0]=password;
}
 else {
config.wepKeys[0]='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_EAP:
config.allowedKeyManagement.set(KeyMgmt.WPA_EAP);
config.allowedKeyManagement.set(KeyMgmt.IEEE8021X);
config.eap.setValue((String)mEapMethod.getSelectedItem());
config.ca_cert.setValue((mEapCaCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.CA_CERTIFICATE + (String)mEapCaCert.getSelectedItem());
config.client_cert.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_CERTIFICATE + (String)mEapUserCert.getSelectedItem());
config.private_key.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_PRIVATE_KEY + (String)mEapUserCert.getSelectedItem());
config.identity.setValue((mEapIdentity.length() == 0) ? ""String_Node_Str"" : mEapIdentity.getText().toString());
config.anonymous_identity.setValue((mEapAnonymous.length() == 0) ? ""String_Node_Str"" : mEapAnonymous.getText().toString());
if (mPassword.length() != 0) {
config.password.setValue(mPassword.getText().toString());
}
return config;
}
return null;
}","WifiConfiguration getConfig(){
  if (mAccessPoint != null && mAccessPoint.networkId != -1 && !edit) {
    return null;
  }
  WifiConfiguration config=new WifiConfiguration();
  if (mAccessPoint == null) {
    config.SSID=AccessPoint.convertToQuotedString(mSsid.getText().toString());
    config.hiddenSSID=true;
  }
 else   if (mAccessPoint.networkId == -1) {
    config.SSID=AccessPoint.convertToQuotedString(mAccessPoint.ssid);
  }
 else {
    config.networkId=mAccessPoint.networkId;
  }
switch (mSecurity) {
case AccessPoint.SECURITY_NONE:
    config.allowedKeyManagement.set(KeyMgmt.NONE);
  return config;
case AccessPoint.SECURITY_WEP:
config.allowedKeyManagement.set(KeyMgmt.NONE);
config.allowedAuthAlgorithms.set(AuthAlgorithm.OPEN);
config.allowedAuthAlgorithms.set(AuthAlgorithm.SHARED);
if (mPassword.length() != 0) {
int length=mPassword.length();
String password=mPassword.getText().toString();
if ((length == 10 || length == 26 || length == 58) && password.matches(""String_Node_Str"")) {
config.wepKeys[0]=password;
}
 else {
config.wepKeys[0]='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_PSK:
config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
if (mPassword.length() != 0) {
String password=mPassword.getText().toString();
if (password.matches(""String_Node_Str"")) {
config.preSharedKey=password;
}
 else {
config.preSharedKey='""' + password + '""';
}
}
return config;
case AccessPoint.SECURITY_EAP:
config.allowedKeyManagement.set(KeyMgmt.WPA_EAP);
config.allowedKeyManagement.set(KeyMgmt.IEEE8021X);
config.eap.setValue((String)mEapMethod.getSelectedItem());
config.ca_cert.setValue((mEapCaCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.CA_CERTIFICATE + (String)mEapCaCert.getSelectedItem());
config.client_cert.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_CERTIFICATE + (String)mEapUserCert.getSelectedItem());
config.private_key.setValue((mEapUserCert.getSelectedItemPosition() == 0) ? ""String_Node_Str"" : KEYSTORE_SPACE + Credentials.USER_PRIVATE_KEY + (String)mEapUserCert.getSelectedItem());
config.identity.setValue((mEapIdentity.length() == 0) ? ""String_Node_Str"" : mEapIdentity.getText().toString());
config.anonymous_identity.setValue((mEapAnonymous.length() == 0) ? ""String_Node_Str"" : mEapAnonymous.getText().toString());
if (mPassword.length() != 0) {
config.password.setValue(mPassword.getText().toString());
}
return config;
}
return null;
}",0.9756493506493508
180851,"@Override public boolean onContextItemSelected(MenuItem item){
  if (mSelected == null) {
    return super.onContextItemSelected(item);
  }
switch (item.getItemId()) {
case MENU_ID_CONNECT:
    if (mSelected.networkId != -1) {
      if (!requireKeyStore(mSelected.getConfig())) {
        connect(mSelected.networkId);
      }
    }
 else     if (mSelected.security == AccessPoint.SECURITY_NONE) {
      WifiConfiguration config=new WifiConfiguration();
      config.SSID=mSelected.ssid;
      config.allowedKeyManagement.set(KeyMgmt.NONE);
      int networkId=mWifiManager.addNetwork(config);
      mWifiManager.enableNetwork(networkId,false);
      connect(networkId);
    }
 else {
      showDialog(mSelected,false);
    }
  return true;
case MENU_ID_FORGET:
forget(mSelected.networkId);
return true;
case MENU_ID_MODIFY:
showDialog(mSelected,true);
return true;
}
return super.onContextItemSelected(item);
}","@Override public boolean onContextItemSelected(MenuItem item){
  if (mSelected == null) {
    return super.onContextItemSelected(item);
  }
switch (item.getItemId()) {
case MENU_ID_CONNECT:
    if (mSelected.networkId != -1) {
      if (!requireKeyStore(mSelected.getConfig())) {
        connect(mSelected.networkId);
      }
    }
 else     if (mSelected.security == AccessPoint.SECURITY_NONE) {
      WifiConfiguration config=new WifiConfiguration();
      config.SSID=AccessPoint.convertToQuotedString(mSelected.ssid);
      config.allowedKeyManagement.set(KeyMgmt.NONE);
      int networkId=mWifiManager.addNetwork(config);
      mWifiManager.enableNetwork(networkId,false);
      connect(networkId);
    }
 else {
      showDialog(mSelected,false);
    }
  return true;
case MENU_ID_FORGET:
forget(mSelected.networkId);
return true;
case MENU_ID_MODIFY:
showDialog(mSelected,true);
return true;
}
return super.onContextItemSelected(item);
}",0.9660377358490566
180852,"public void unpair(){
synchronized (workQueue) {
    boolean processNow=false;
    Iterator<BluetoothJob> it=workQueue.iterator();
    while (it.hasNext()) {
      BluetoothJob job=it.next();
      if (job.cachedDevice.mDevice.equals(this.mDevice)) {
        it.remove();
        if (job.timeSent != 0) {
          processNow=true;
        }
      }
    }
    if (processNow) {
      processCommands();
    }
  }
switch (getBondState()) {
case BluetoothDevice.BOND_BONDED:
    mDevice.removeBond();
  break;
case BluetoothDevice.BOND_BONDING:
mDevice.cancelBondProcess();
break;
}
}","public void unpair(){
  disconnect();
  int state=getBondState();
  if (state == BluetoothDevice.BOND_BONDING) {
    mDevice.cancelBondProcess();
  }
  if (state != BluetoothDevice.BOND_NONE) {
    queueCommand(new BluetoothJob(BluetoothCommand.REMOVE_BOND,this,null));
  }
}",0.147024504084014
180853,"private boolean processCommand(BluetoothJob job){
  boolean successful=false;
  if (job.timeSent == 0) {
    job.timeSent=System.currentTimeMillis();
switch (job.command) {
case CONNECT:
      successful=connectInt(job.cachedDevice,job.profile);
    break;
case DISCONNECT:
  successful=disconnectInt(job.cachedDevice,job.profile);
break;
}
if (successful) {
if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (V) {
Log.v(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
return successful;
}","private boolean processCommand(BluetoothJob job){
  boolean successful=false;
  if (job.timeSent == 0) {
    job.timeSent=System.currentTimeMillis();
switch (job.command) {
case CONNECT:
      successful=connectInt(job.cachedDevice,job.profile);
    break;
case DISCONNECT:
  successful=disconnectInt(job.cachedDevice,job.profile);
break;
case REMOVE_BOND:
BluetoothDevice dev=job.cachedDevice.getDevice();
if (dev != null) {
successful=dev.removeBond();
}
break;
}
if (successful) {
if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (V) {
Log.v(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
return successful;
}",0.9010292953285828
180854,"public void unpair(){
synchronized (workQueue) {
    boolean processNow=false;
    Iterator<BluetoothJob> it=workQueue.iterator();
    while (it.hasNext()) {
      BluetoothJob job=it.next();
      if (job.cachedDevice.mDevice.equals(this.mDevice)) {
        it.remove();
        if (job.timeSent != 0) {
          processNow=true;
        }
      }
    }
    if (processNow) {
      processCommands();
    }
  }
switch (getBondState()) {
case BluetoothDevice.BOND_BONDED:
    mDevice.removeBond();
  break;
case BluetoothDevice.BOND_BONDING:
mDevice.cancelBondProcess();
break;
}
}","public void unpair(){
  disconnect();
  int state=getBondState();
  if (state == BluetoothDevice.BOND_BONDING) {
    mDevice.cancelBondProcess();
  }
  if (state != BluetoothDevice.BOND_NONE) {
    queueCommand(new BluetoothJob(BluetoothCommand.REMOVE_BOND,this,null));
  }
}",0.147024504084014
180855,"private boolean processCommand(BluetoothJob job){
  boolean successful=false;
  if (job.timeSent == 0) {
    job.timeSent=System.currentTimeMillis();
switch (job.command) {
case CONNECT:
      successful=connectInt(job.cachedDevice,job.profile);
    break;
case DISCONNECT:
  successful=disconnectInt(job.cachedDevice,job.profile);
break;
}
if (successful) {
if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (V) {
Log.v(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
return successful;
}","private boolean processCommand(BluetoothJob job){
  boolean successful=false;
  if (job.timeSent == 0) {
    job.timeSent=System.currentTimeMillis();
switch (job.command) {
case CONNECT:
      successful=connectInt(job.cachedDevice,job.profile);
    break;
case DISCONNECT:
  successful=disconnectInt(job.cachedDevice,job.profile);
break;
case REMOVE_BOND:
BluetoothDevice dev=job.cachedDevice.getDevice();
if (dev != null) {
successful=dev.removeBond();
}
break;
}
if (successful) {
if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (V) {
Log.v(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
return successful;
}",0.9010292953285828
180856,"public void unpair(){
synchronized (workQueue) {
    boolean processNow=false;
    Iterator<BluetoothJob> it=workQueue.iterator();
    while (it.hasNext()) {
      BluetoothJob job=it.next();
      if (job.cachedDevice.mDevice.equals(this.mDevice)) {
        it.remove();
        if (job.timeSent != 0) {
          processNow=true;
        }
      }
    }
    if (processNow) {
      processCommands();
    }
  }
switch (getBondState()) {
case BluetoothDevice.BOND_BONDED:
    mDevice.removeBond();
  break;
case BluetoothDevice.BOND_BONDING:
mDevice.cancelBondProcess();
break;
}
}","public void unpair(){
  disconnect();
  int state=getBondState();
  if (state == BluetoothDevice.BOND_BONDING) {
    mDevice.cancelBondProcess();
  }
  if (state != BluetoothDevice.BOND_NONE) {
    queueCommand(new BluetoothJob(BluetoothCommand.REMOVE_BOND,this,null));
  }
}",0.147024504084014
180857,"private boolean processCommand(BluetoothJob job){
  boolean successful=false;
  if (job.timeSent == 0) {
    job.timeSent=System.currentTimeMillis();
switch (job.command) {
case CONNECT:
      successful=connectInt(job.cachedDevice,job.profile);
    break;
case DISCONNECT:
  successful=disconnectInt(job.cachedDevice,job.profile);
break;
}
if (successful) {
if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (V) {
Log.v(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
return successful;
}","private boolean processCommand(BluetoothJob job){
  boolean successful=false;
  if (job.timeSent == 0) {
    job.timeSent=System.currentTimeMillis();
switch (job.command) {
case CONNECT:
      successful=connectInt(job.cachedDevice,job.profile);
    break;
case DISCONNECT:
  successful=disconnectInt(job.cachedDevice,job.profile);
break;
case REMOVE_BOND:
BluetoothDevice dev=job.cachedDevice.getDevice();
if (dev != null) {
successful=dev.removeBond();
}
break;
}
if (successful) {
if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (V) {
Log.v(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
return successful;
}",0.9010292953285828
180858,"public void unpair(){
synchronized (workQueue) {
    boolean processNow=false;
    Iterator<BluetoothJob> it=workQueue.iterator();
    while (it.hasNext()) {
      BluetoothJob job=it.next();
      if (job.cachedDevice.mDevice.equals(this.mDevice)) {
        it.remove();
        if (job.timeSent != 0) {
          processNow=true;
        }
      }
    }
    if (processNow) {
      processCommands();
    }
  }
switch (getBondState()) {
case BluetoothDevice.BOND_BONDED:
    mDevice.removeBond();
  break;
case BluetoothDevice.BOND_BONDING:
mDevice.cancelBondProcess();
break;
}
}","public void unpair(){
  disconnect();
  int state=getBondState();
  if (state == BluetoothDevice.BOND_BONDING) {
    mDevice.cancelBondProcess();
  }
  if (state != BluetoothDevice.BOND_NONE) {
    queueCommand(new BluetoothJob(BluetoothCommand.REMOVE_BOND,this,null));
  }
}",0.147024504084014
180859,"private boolean processCommand(BluetoothJob job){
  boolean successful=false;
  if (job.timeSent == 0) {
    job.timeSent=System.currentTimeMillis();
switch (job.command) {
case CONNECT:
      successful=connectInt(job.cachedDevice,job.profile);
    break;
case DISCONNECT:
  successful=disconnectInt(job.cachedDevice,job.profile);
break;
}
if (successful) {
if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (V) {
Log.v(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
return successful;
}","private boolean processCommand(BluetoothJob job){
  boolean successful=false;
  if (job.timeSent == 0) {
    job.timeSent=System.currentTimeMillis();
switch (job.command) {
case CONNECT:
      successful=connectInt(job.cachedDevice,job.profile);
    break;
case DISCONNECT:
  successful=disconnectInt(job.cachedDevice,job.profile);
break;
case REMOVE_BOND:
BluetoothDevice dev=job.cachedDevice.getDevice();
if (dev != null) {
successful=dev.removeBond();
}
break;
}
if (successful) {
if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (V) {
Log.v(TAG,""String_Node_Str"" + job.toString());
}
}
 else if (D) {
Log.d(TAG,""String_Node_Str"" + job.toString());
}
return successful;
}",0.9010292953285828
180860,"/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  if (mDemoStringIndex > -1) {
    mDefaultLocPref.setValueIndex(mDemoStringIndex);
  }
}","/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  if (mDemoStringIndex > -1) {
    mDefaultLocPref.setValueIndex(mDemoStringIndex);
  }
}",0.9950920245398772
180861,"/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  if (mDemoStringIndex > -1) {
    mDefaultLocPref.setValueIndex(mDemoStringIndex);
  }
}","/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  if (mDemoStringIndex > -1) {
    mDefaultLocPref.setValueIndex(mDemoStringIndex);
  }
}",0.9950920245398772
180862,"/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_AVAILABLE_VOICES);
    ArrayList<String> unavailable=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_UNAVAILABLE_VOICES);
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      mEnableDemo=true;
      int languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
      if (languageResult < TextToSpeech.LANG_AVAILABLE) {
        Locale currentLocale=Locale.getDefault();
        mDefaultLanguage=currentLocale.getISO3Language();
        mDefaultCountry=currentLocale.getISO3Country();
        mDefaultLocVariant=currentLocale.getVariant();
        languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        if (languageResult < TextToSpeech.LANG_AVAILABLE) {
          parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
          mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        }
        ContentResolver resolver=getContentResolver();
        Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
        Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
        Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
      }
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}","/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_AVAILABLE_VOICES);
    ArrayList<String> unavailable=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_UNAVAILABLE_VOICES);
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      int selectedLanguageIndex=-1;
      String selectedLanguagePref=mDefaultLanguage;
      if (mDefaultCountry.length() > 0) {
        selectedLanguagePref=selectedLanguagePref + LOCALE_DELIMITER + mDefaultCountry;
      }
      if (mDefaultLocVariant.length() > 0) {
        selectedLanguagePref=selectedLanguagePref + LOCALE_DELIMITER + mDefaultLocVariant;
      }
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
          if (entryValues[i].equals(selectedLanguagePref)) {
            selectedLanguageIndex=i;
          }
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      if (selectedLanguageIndex > -1) {
        ttsLanguagePref.setValueIndex(selectedLanguageIndex);
      }
      mEnableDemo=true;
      int languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
      if (languageResult < TextToSpeech.LANG_AVAILABLE) {
        Locale currentLocale=Locale.getDefault();
        mDefaultLanguage=currentLocale.getISO3Language();
        mDefaultCountry=currentLocale.getISO3Country();
        mDefaultLocVariant=currentLocale.getVariant();
        languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        if (languageResult < TextToSpeech.LANG_AVAILABLE) {
          parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
          mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        }
        ContentResolver resolver=getContentResolver();
        Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
        Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
        Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
      }
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}",0.8996548977966552
180863,"/** 
 * (helper function for initDefaultLang() ) Returns whether there is a default language in the TTS settings.
 */
private boolean hasLangPref(){
  String language=Settings.Secure.getString(getContentResolver(),TTS_DEFAULT_LANG);
  return (language != null);
}","/** 
 * (helper function for initDefaultLang() ) Returns whether there is a default language in the TTS settings.
 */
private boolean hasLangPref(){
  ContentResolver resolver=getContentResolver();
  String language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if ((language == null) || (language.length() < 1)) {
    return false;
  }
  String country=Settings.Secure.getString(resolver,TTS_DEFAULT_COUNTRY);
  if (country == null) {
    return false;
  }
  String variant=Settings.Secure.getString(resolver,TTS_DEFAULT_VARIANT);
  if (variant == null) {
    return false;
  }
  return true;
}",0.4976958525345622
180864,"/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_AVAILABLE_VOICES);
    ArrayList<String> unavailable=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_UNAVAILABLE_VOICES);
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      mEnableDemo=true;
      int languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
      if (languageResult < TextToSpeech.LANG_AVAILABLE) {
        Locale currentLocale=Locale.getDefault();
        mDefaultLanguage=currentLocale.getISO3Language();
        mDefaultCountry=currentLocale.getISO3Country();
        mDefaultLocVariant=currentLocale.getVariant();
        languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        if (languageResult < TextToSpeech.LANG_AVAILABLE) {
          parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
          mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        }
        ContentResolver resolver=getContentResolver();
        Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
        Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
        Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
      }
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}","/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_AVAILABLE_VOICES);
    ArrayList<String> unavailable=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_UNAVAILABLE_VOICES);
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      int selectedLanguageIndex=-1;
      String selectedLanguagePref=mDefaultLanguage;
      if (mDefaultCountry.length() > 0) {
        selectedLanguagePref=selectedLanguagePref + LOCALE_DELIMITER + mDefaultCountry;
      }
      if (mDefaultLocVariant.length() > 0) {
        selectedLanguagePref=selectedLanguagePref + LOCALE_DELIMITER + mDefaultLocVariant;
      }
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
          if (entryValues[i].equals(selectedLanguagePref)) {
            selectedLanguageIndex=i;
          }
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      if (selectedLanguageIndex > -1) {
        ttsLanguagePref.setValueIndex(selectedLanguageIndex);
      }
      mEnableDemo=true;
      int languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
      if (languageResult < TextToSpeech.LANG_AVAILABLE) {
        Locale currentLocale=Locale.getDefault();
        mDefaultLanguage=currentLocale.getISO3Language();
        mDefaultCountry=currentLocale.getISO3Country();
        mDefaultLocVariant=currentLocale.getVariant();
        languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        if (languageResult < TextToSpeech.LANG_AVAILABLE) {
          parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
          mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        }
        ContentResolver resolver=getContentResolver();
        Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
        Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
        Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
      }
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}",0.8996548977966552
180865,"/** 
 * (helper function for initDefaultLang() ) Returns whether there is a default language in the TTS settings.
 */
private boolean hasLangPref(){
  String language=Settings.Secure.getString(getContentResolver(),TTS_DEFAULT_LANG);
  return (language != null);
}","/** 
 * (helper function for initDefaultLang() ) Returns whether there is a default language in the TTS settings.
 */
private boolean hasLangPref(){
  ContentResolver resolver=getContentResolver();
  String language=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  if ((language == null) || (language.length() < 1)) {
    return false;
  }
  String country=Settings.Secure.getString(resolver,TTS_DEFAULT_COUNTRY);
  if (country == null) {
    return false;
  }
  String variant=Settings.Secure.getString(resolver,TTS_DEFAULT_VARIANT);
  if (variant == null) {
    return false;
  }
  return true;
}",0.4976958525345622
180866,"/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_AVAILABLE_VOICES);
    ArrayList<String> unavailable=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_UNAVAILABLE_VOICES);
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      mEnableDemo=true;
      int languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
      if (languageResult < TextToSpeech.LANG_AVAILABLE) {
        Locale currentLocale=Locale.getDefault();
        mDefaultLanguage=currentLocale.getISO3Language();
        mDefaultCountry=currentLocale.getISO3Country();
        mDefaultLocVariant=currentLocale.getVariant();
        languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        if (languageResult < TextToSpeech.LANG_AVAILABLE) {
          parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
          mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        }
        ContentResolver resolver=getContentResolver();
        Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
        Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
        Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
      }
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}","/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_AVAILABLE_VOICES);
    ArrayList<String> unavailable=data.getStringArrayListExtra(TextToSpeech.Engine.EXTRA_UNAVAILABLE_VOICES);
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      int selectedLanguageIndex=-1;
      String selectedLanguagePref=mDefaultLanguage;
      if (mDefaultCountry.length() > 0) {
        selectedLanguagePref=selectedLanguagePref + LOCALE_DELIMITER + mDefaultCountry;
      }
      if (mDefaultLocVariant.length() > 0) {
        selectedLanguagePref=selectedLanguagePref + LOCALE_DELIMITER + mDefaultLocVariant;
      }
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
          if (entryValues[i].equals(selectedLanguagePref)) {
            selectedLanguageIndex=i;
          }
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      if (selectedLanguageIndex > -1) {
        ttsLanguagePref.setValueIndex(selectedLanguageIndex);
      }
      mEnableDemo=true;
      int languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
      if (languageResult < TextToSpeech.LANG_AVAILABLE) {
        Locale currentLocale=Locale.getDefault();
        mDefaultLanguage=currentLocale.getISO3Language();
        mDefaultCountry=currentLocale.getISO3Country();
        mDefaultLocVariant=currentLocale.getVariant();
        languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        if (languageResult < TextToSpeech.LANG_AVAILABLE) {
          parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
          mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        }
        ContentResolver resolver=getContentResolver();
        Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
        Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
        Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
      }
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}",0.8996548977966552
180867,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
  mTts=new TextToSpeech(this,this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  mTtsStarted=false;
  mTts=new TextToSpeech(this,this);
}",0.9358024691358025
180868,"@Override protected void onStart(){
  super.onStart();
  initClickers();
  updateWidgetState();
  checkVoiceData();
}","@Override protected void onStart(){
  super.onStart();
  if (mTtsStarted) {
    initClickers();
    updateWidgetState();
    checkVoiceData();
  }
}",0.8830188679245283
180869,"/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    if (mDefaultCountry == null) {
      mDefaultCountry=Locale.getDefault().getISO3Country();
    }
    if (mDefaultLocVariant == null) {
      mDefaultLocVariant=new String();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}","/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    if (mDefaultCountry == null) {
      mDefaultCountry=Locale.getDefault().getISO3Country();
    }
    if (mDefaultLocVariant == null) {
      mDefaultLocVariant=new String();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
    initDefaultSettings();
    initClickers();
    updateWidgetState();
    checkVoiceData();
    mTtsStarted=true;
    Log.v(TAG,""String_Node_Str"");
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}",0.3355006501950585
180870,"public CachedBluetoothDeviceManager(LocalBluetoothManager localManager){
  mLocalManager=localManager;
  mCallbacks=localManager.getCallbacks();
  readPairedDevices();
}","public CachedBluetoothDeviceManager(LocalBluetoothManager localManager){
  mLocalManager=localManager;
  mCallbacks=localManager.getCallbacks();
}",0.926984126984127
180871,"public CachedBluetoothDeviceManager(LocalBluetoothManager localManager){
  mLocalManager=localManager;
  mCallbacks=localManager.getCallbacks();
  readPairedDevices();
}","public CachedBluetoothDeviceManager(LocalBluetoothManager localManager){
  mLocalManager=localManager;
  mCallbacks=localManager.getCallbacks();
}",0.926984126984127
180872,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
  mTts=new TextToSpeech(this,this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  mTtsStarted=false;
  mTts=new TextToSpeech(this,this);
}",0.9358024691358025
180873,"@Override protected void onStart(){
  super.onStart();
  initClickers();
  updateWidgetState();
  checkVoiceData();
}","@Override protected void onStart(){
  super.onStart();
  if (mTtsStarted) {
    initClickers();
    updateWidgetState();
    checkVoiceData();
  }
}",0.8830188679245283
180874,"/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    if (mDefaultCountry == null) {
      mDefaultCountry=Locale.getDefault().getISO3Country();
    }
    if (mDefaultLocVariant == null) {
      mDefaultLocVariant=new String();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}","/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    if (mDefaultCountry == null) {
      mDefaultCountry=Locale.getDefault().getISO3Country();
    }
    if (mDefaultLocVariant == null) {
      mDefaultLocVariant=new String();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
    initDefaultSettings();
    initClickers();
    updateWidgetState();
    checkVoiceData();
    mTtsStarted=true;
    Log.v(TAG,""String_Node_Str"");
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}",0.3355006501950585
180875,"public CachedBluetoothDeviceManager(LocalBluetoothManager localManager){
  mLocalManager=localManager;
  mCallbacks=localManager.getCallbacks();
  readPairedDevices();
}","public CachedBluetoothDeviceManager(LocalBluetoothManager localManager){
  mLocalManager=localManager;
  mCallbacks=localManager.getCallbacks();
}",0.926984126984127
180876,"/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  if (mDemoStringIndex > -1) {
    mDefaultLocPref.setValueIndex(mDemoStringIndex);
  }
}","/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  if (mDemoStringIndex > -1) {
    mDefaultLocPref.setValueIndex(mDemoStringIndex);
  }
}",0.9950920245398772
180877,"/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(""String_Node_Str"");
    ArrayList<String> unavailable=data.getStringArrayListExtra(""String_Node_Str"");
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      mEnableDemo=true;
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}","/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(""String_Node_Str"");
    ArrayList<String> unavailable=data.getStringArrayListExtra(""String_Node_Str"");
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      mEnableDemo=true;
      int languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
      if (languageResult < TextToSpeech.LANG_AVAILABLE) {
        Locale currentLocale=Locale.getDefault();
        mDefaultLanguage=currentLocale.getISO3Language();
        mDefaultCountry=currentLocale.getISO3Country();
        mDefaultLocVariant=currentLocale.getVariant();
        languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        if (languageResult < TextToSpeech.LANG_AVAILABLE) {
          parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
          mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        }
        ContentResolver resolver=getContentResolver();
        Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
        Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
        Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
      }
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}",0.7377670572019297
180878,"/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(""String_Node_Str"");
    ArrayList<String> unavailable=data.getStringArrayListExtra(""String_Node_Str"");
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      mEnableDemo=true;
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}","/** 
 * Called when voice data integrity check returns
 */
protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == VOICE_DATA_INTEGRITY_CHECK) {
    if (data == null) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    ArrayList<String> available=data.getStringArrayListExtra(""String_Node_Str"");
    ArrayList<String> unavailable=data.getStringArrayListExtra(""String_Node_Str"");
    if ((available == null) || (unavailable == null)) {
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      return;
    }
    if (available.size() > 0) {
      if (mTts == null) {
        mTts=new TextToSpeech(this,this);
      }
      ListPreference ttsLanguagePref=(ListPreference)findPreference(""String_Node_Str"");
      CharSequence[] entries=new CharSequence[available.size()];
      CharSequence[] entryValues=new CharSequence[available.size()];
      for (int i=0; i < available.size(); i++) {
        String[] langCountryVariant=available.get(i).split(""String_Node_Str"");
        Locale loc=null;
        if (langCountryVariant.length == 1) {
          loc=new Locale(langCountryVariant[0]);
        }
 else         if (langCountryVariant.length == 2) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1]);
        }
 else         if (langCountryVariant.length == 3) {
          loc=new Locale(langCountryVariant[0],langCountryVariant[1],langCountryVariant[2]);
        }
        if (loc != null) {
          entries[i]=loc.getDisplayName();
          entryValues[i]=available.get(i);
        }
      }
      ttsLanguagePref.setEntries(entries);
      ttsLanguagePref.setEntryValues(entryValues);
      mEnableDemo=true;
      int languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
      if (languageResult < TextToSpeech.LANG_AVAILABLE) {
        Locale currentLocale=Locale.getDefault();
        mDefaultLanguage=currentLocale.getISO3Language();
        mDefaultCountry=currentLocale.getISO3Country();
        mDefaultLocVariant=currentLocale.getVariant();
        languageResult=mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        if (languageResult < TextToSpeech.LANG_AVAILABLE) {
          parseLocaleInfo(ttsLanguagePref.getEntryValues()[0].toString());
          mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
        }
        ContentResolver resolver=getContentResolver();
        Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
        Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
        Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
      }
    }
 else {
      mEnableDemo=false;
    }
    if (unavailable.size() > 0) {
      mVoicesMissing=true;
    }
 else {
      mVoicesMissing=false;
    }
    updateWidgetState();
  }
 else   if (requestCode == GET_SAMPLE_TEXT) {
    if (resultCode == TextToSpeech.LANG_AVAILABLE) {
      String sample=getString(R.string.tts_demo);
      if ((data != null) && (data.getStringExtra(""String_Node_Str"") != null)) {
        sample=data.getStringExtra(""String_Node_Str"");
      }
      if (mTts != null) {
        mTts.speak(sample,TextToSpeech.QUEUE_FLUSH,null);
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"");
    }
  }
}",0.7377670572019297
180879,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
  mTts=new TextToSpeech(this,this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  mTtsStarted=false;
  mTts=new TextToSpeech(this,this);
}",0.9358024691358025
180880,"@Override protected void onStart(){
  super.onStart();
  initClickers();
  updateWidgetState();
  checkVoiceData();
}","@Override protected void onStart(){
  super.onStart();
  if (mTtsStarted) {
    initClickers();
    updateWidgetState();
    checkVoiceData();
  }
}",0.8830188679245283
180881,"/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    if (mDefaultCountry == null) {
      mDefaultCountry=Locale.getDefault().getISO3Country();
    }
    if (mDefaultLocVariant == null) {
      mDefaultLocVariant=new String();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}","/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    if (mDefaultCountry == null) {
      mDefaultCountry=Locale.getDefault().getISO3Country();
    }
    if (mDefaultLocVariant == null) {
      mDefaultLocVariant=new String();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
    initDefaultSettings();
    initClickers();
    updateWidgetState();
    checkVoiceData();
    mTtsStarted=true;
    Log.v(TAG,""String_Node_Str"");
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}",0.3355006501950585
180882,"public void bindView(View view,int position){
synchronized (mState.mLock) {
    ViewHolder vh=(ViewHolder)view.getTag();
    if (position >= mState.mItems.size()) {
      return;
    }
    BaseItem item=mState.mItems.get(position);
    vh.name.setText(item.mDisplayLabel);
    vh.separator.setVisibility(item.mNeedDivider ? View.VISIBLE : View.INVISIBLE);
    ActiveItem ai=new ActiveItem();
    ai.mRootView=view;
    ai.mItem=item;
    ai.mHolder=vh;
    ai.mFirstRunTime=item.mActiveSince;
    vh.description.setText(item.mDescription);
    if (item.mIsProcess) {
      view.setBackgroundColor(mProcessBgColor);
      vh.icon.setImageDrawable(null);
      vh.icon.setVisibility(View.GONE);
      vh.description.setText(item.mDescription);
      item.mCurSizeStr=null;
    }
 else {
      view.setBackgroundDrawable(null);
      vh.icon.setImageDrawable(item.mPackageInfo.loadIcon(getPackageManager()));
      vh.icon.setVisibility(View.VISIBLE);
      vh.description.setText(item.mDescription);
      ai.mFirstRunTime=item.mActiveSince;
    }
    ai.updateTime(RunningServices.this);
    mActiveItems.put(view,ai);
  }
}","public void bindView(View view,int position){
synchronized (mState.mLock) {
    ViewHolder vh=(ViewHolder)view.getTag();
    if (position >= mItems.size()) {
      return;
    }
    BaseItem item=mItems.get(position);
    vh.name.setText(item.mDisplayLabel);
    vh.separator.setVisibility(item.mNeedDivider ? View.VISIBLE : View.INVISIBLE);
    ActiveItem ai=new ActiveItem();
    ai.mRootView=view;
    ai.mItem=item;
    ai.mHolder=vh;
    ai.mFirstRunTime=item.mActiveSince;
    vh.description.setText(item.mDescription);
    if (item.mIsProcess) {
      view.setBackgroundColor(mProcessBgColor);
      vh.icon.setImageDrawable(null);
      vh.icon.setVisibility(View.GONE);
      vh.description.setText(item.mDescription);
      item.mCurSizeStr=null;
    }
 else {
      view.setBackgroundDrawable(null);
      vh.icon.setImageDrawable(item.mPackageInfo.loadIcon(getPackageManager()));
      vh.icon.setVisibility(View.VISIBLE);
      vh.description.setText(item.mDescription);
      ai.mFirstRunTime=item.mActiveSince;
    }
    ai.updateTime(RunningServices.this);
    mActiveItems.put(view,ai);
  }
}",0.9937275985663082
180883,"boolean update(Context context,ActivityManager am){
  final PackageManager pm=context.getPackageManager();
  mSequence++;
  boolean changed=false;
  List<ActivityManager.RunningServiceInfo> services=am.getRunningServices(MAX_SERVICES);
  final int NS=services != null ? services.size() : 0;
  for (int i=0; i < NS; i++) {
    ActivityManager.RunningServiceInfo si=services.get(i);
    if (!si.started && si.clientLabel == 0) {
      continue;
    }
    if ((si.flags & ActivityManager.RunningServiceInfo.FLAG_PERSISTENT_PROCESS) != 0) {
      continue;
    }
    HashMap<String,ProcessItem> procs=mProcesses.get(si.uid);
    if (procs == null) {
      procs=new HashMap<String,ProcessItem>();
      mProcesses.put(si.uid,procs);
    }
    ProcessItem proc=procs.get(si.process);
    if (proc == null) {
      changed=true;
      proc=new ProcessItem(context,si.uid,si.process);
      procs.put(si.process,proc);
    }
    if (proc.mCurSeq != mSequence) {
      int pid=si.restarting == 0 ? si.pid : 0;
      if (pid != proc.mPid) {
        changed=true;
        if (proc.mPid != pid) {
          if (proc.mPid != 0) {
            mActiveProcesses.remove(proc.mPid);
          }
          if (pid != 0) {
            mActiveProcesses.put(pid,proc);
          }
          proc.mPid=pid;
        }
      }
      proc.mDependentProcesses.clear();
      proc.mCurSeq=mSequence;
    }
    changed|=proc.updateService(context,si);
  }
  List<ActivityManager.RunningAppProcessInfo> processes=am.getRunningAppProcesses();
  final int NP=processes != null ? processes.size() : 0;
  for (int i=0; i < NP; i++) {
    ActivityManager.RunningAppProcessInfo pi=processes.get(i);
    ProcessItem proc=mActiveProcesses.get(pi.pid);
    if (proc == null) {
      proc=mRunningProcesses.get(pi.pid);
      if (proc == null) {
        proc=new ProcessItem(context,pi.uid,pi.processName);
        proc.mPid=pi.pid;
        mRunningProcesses.put(pi.pid,proc);
      }
      proc.mDependentProcesses.clear();
    }
    proc.mRunningSeq=mSequence;
    proc.mRunningProcessInfo=pi;
  }
  int NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mRunningSeq == mSequence) {
      int clientPid=proc.mRunningProcessInfo.importanceReasonPid;
      if (clientPid != 0) {
        ProcessItem client=mActiveProcesses.get(clientPid);
        if (client == null) {
          client=mRunningProcesses.get(clientPid);
        }
        if (client != null) {
          client.mDependentProcesses.put(proc.mPid,proc);
        }
      }
 else {
        proc.mClient=null;
      }
    }
 else {
      mRunningProcesses.remove(mRunningProcesses.keyAt(i));
    }
  }
  final int NAP=mActiveProcesses.size();
  for (int i=0; i < NAP; i++) {
    ProcessItem proc=mActiveProcesses.valueAt(i);
    if (proc.mCurSeq == mSequence) {
      changed|=proc.buildDependencyChain(context,pm,mSequence);
    }
  }
  for (int i=0; i < mProcesses.size(); i++) {
    HashMap<String,ProcessItem> procs=mProcesses.valueAt(i);
    Iterator<ProcessItem> pit=procs.values().iterator();
    while (pit.hasNext()) {
      ProcessItem pi=pit.next();
      if (pi.mCurSeq == mSequence) {
        pi.ensureLabel(pm);
        if (pi.mPid == 0) {
          pi.mDependentProcesses.clear();
        }
      }
 else {
        changed=true;
        pit.remove();
        if (procs.size() == 0) {
          mProcesses.remove(mProcesses.keyAt(i));
        }
        if (pi.mPid != 0) {
          mActiveProcesses.remove(pi.mPid);
        }
        continue;
      }
      Iterator<ServiceItem> sit=pi.mServices.values().iterator();
      while (sit.hasNext()) {
        ServiceItem si=sit.next();
        if (si.mCurSeq != mSequence) {
          changed=true;
          sit.remove();
        }
      }
    }
  }
  if (changed) {
    ArrayList<BaseItem> newItems=new ArrayList<BaseItem>();
    mProcessItems.clear();
    for (int i=0; i < mProcesses.size(); i++) {
      for (      ProcessItem pi : mProcesses.valueAt(i).values()) {
        pi.mNeedDivider=false;
        pi.addDependentProcesses(newItems,mProcessItems);
        newItems.add(pi);
        if (pi.mPid > 0) {
          mProcessItems.add(pi);
        }
        boolean needDivider=false;
        for (        ServiceItem si : pi.mServices.values()) {
          si.mNeedDivider=needDivider;
          needDivider=true;
          newItems.add(si);
        }
      }
    }
synchronized (mLock) {
      mItems=newItems;
    }
  }
  mAllProcessItems.clear();
  mAllProcessItems.addAll(mProcessItems);
  int numBackgroundProcesses=0;
  int numForegroundProcesses=0;
  int numServiceProcesses=0;
  NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mCurSeq != mSequence) {
      if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        numBackgroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        numForegroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else {
        Log.i(TAG,""String_Node_Str"" + proc.mProcessName + ""String_Node_Str""+ proc.mPid);
      }
    }
 else {
      numServiceProcesses++;
    }
  }
  long backgroundProcessMemory=0;
  long foregroundProcessMemory=0;
  long serviceProcessMemory=0;
  try {
    final int numProc=mAllProcessItems.size();
    int[] pids=new int[numProc];
    for (int i=0; i < numProc; i++) {
      pids[i]=mAllProcessItems.get(i).mPid;
    }
    Debug.MemoryInfo[] mem=ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    for (int i=pids.length - 1; i >= 0; i--) {
      ProcessItem proc=mAllProcessItems.get(i);
      changed|=proc.updateSize(context,mem[i],mSequence);
      if (proc.mCurSeq == mSequence) {
        serviceProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        backgroundProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        foregroundProcessMemory+=proc.mSize;
      }
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mLock) {
    mNumBackgroundProcesses=numBackgroundProcesses;
    mNumForegroundProcesses=numForegroundProcesses;
    mNumServiceProcesses=numServiceProcesses;
    mBackgroundProcessMemory=backgroundProcessMemory;
    mForegroundProcessMemory=foregroundProcessMemory;
    mServiceProcessMemory=serviceProcessMemory;
  }
  return changed;
}","boolean update(Context context,ActivityManager am){
  final PackageManager pm=context.getPackageManager();
  mSequence++;
  boolean changed=false;
  List<ActivityManager.RunningServiceInfo> services=am.getRunningServices(MAX_SERVICES);
  final int NS=services != null ? services.size() : 0;
  for (int i=0; i < NS; i++) {
    ActivityManager.RunningServiceInfo si=services.get(i);
    if (!si.started && si.clientLabel == 0) {
      continue;
    }
    if ((si.flags & ActivityManager.RunningServiceInfo.FLAG_PERSISTENT_PROCESS) != 0) {
      continue;
    }
    HashMap<String,ProcessItem> procs=mProcesses.get(si.uid);
    if (procs == null) {
      procs=new HashMap<String,ProcessItem>();
      mProcesses.put(si.uid,procs);
    }
    ProcessItem proc=procs.get(si.process);
    if (proc == null) {
      changed=true;
      proc=new ProcessItem(context,si.uid,si.process);
      procs.put(si.process,proc);
    }
    if (proc.mCurSeq != mSequence) {
      int pid=si.restarting == 0 ? si.pid : 0;
      if (pid != proc.mPid) {
        changed=true;
        if (proc.mPid != pid) {
          if (proc.mPid != 0) {
            mActiveProcesses.remove(proc.mPid);
          }
          if (pid != 0) {
            mActiveProcesses.put(pid,proc);
          }
          proc.mPid=pid;
        }
      }
      proc.mDependentProcesses.clear();
      proc.mCurSeq=mSequence;
    }
    changed|=proc.updateService(context,si);
  }
  List<ActivityManager.RunningAppProcessInfo> processes=am.getRunningAppProcesses();
  final int NP=processes != null ? processes.size() : 0;
  for (int i=0; i < NP; i++) {
    ActivityManager.RunningAppProcessInfo pi=processes.get(i);
    ProcessItem proc=mActiveProcesses.get(pi.pid);
    if (proc == null) {
      proc=mRunningProcesses.get(pi.pid);
      if (proc == null) {
        proc=new ProcessItem(context,pi.uid,pi.processName);
        proc.mPid=pi.pid;
        mRunningProcesses.put(pi.pid,proc);
      }
      proc.mDependentProcesses.clear();
    }
    proc.mRunningSeq=mSequence;
    proc.mRunningProcessInfo=pi;
  }
  int NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mRunningSeq == mSequence) {
      int clientPid=proc.mRunningProcessInfo.importanceReasonPid;
      if (clientPid != 0) {
        ProcessItem client=mActiveProcesses.get(clientPid);
        if (client == null) {
          client=mRunningProcesses.get(clientPid);
        }
        if (client != null) {
          client.mDependentProcesses.put(proc.mPid,proc);
        }
      }
 else {
        proc.mClient=null;
      }
    }
 else {
      mRunningProcesses.remove(mRunningProcesses.keyAt(i));
    }
  }
  final int NAP=mActiveProcesses.size();
  for (int i=0; i < NAP; i++) {
    ProcessItem proc=mActiveProcesses.valueAt(i);
    if (proc.mCurSeq == mSequence) {
      changed|=proc.buildDependencyChain(context,pm,mSequence);
    }
  }
  for (int i=0; i < mProcesses.size(); i++) {
    HashMap<String,ProcessItem> procs=mProcesses.valueAt(i);
    Iterator<ProcessItem> pit=procs.values().iterator();
    while (pit.hasNext()) {
      ProcessItem pi=pit.next();
      if (pi.mCurSeq == mSequence) {
        pi.ensureLabel(pm);
        if (pi.mPid == 0) {
          pi.mDependentProcesses.clear();
        }
      }
 else {
        changed=true;
        pit.remove();
        if (procs.size() == 0) {
          mProcesses.remove(mProcesses.keyAt(i));
        }
        if (pi.mPid != 0) {
          mActiveProcesses.remove(pi.mPid);
        }
        continue;
      }
      Iterator<ServiceItem> sit=pi.mServices.values().iterator();
      while (sit.hasNext()) {
        ServiceItem si=sit.next();
        if (si.mCurSeq != mSequence) {
          changed=true;
          sit.remove();
        }
      }
    }
  }
  if (changed) {
    ArrayList<ProcessItem> sortedProcesses=new ArrayList<ProcessItem>();
    for (int i=0; i < mProcesses.size(); i++) {
      for (      ProcessItem pi : mProcesses.valueAt(i).values()) {
        pi.mIsSystem=false;
        pi.mIsStarted=true;
        pi.mActiveSince=Long.MAX_VALUE;
        for (        ServiceItem si : pi.mServices.values()) {
          if (si.mServiceInfo != null && (si.mServiceInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            pi.mIsSystem=true;
          }
          if (si.mRunningService != null && si.mRunningService.clientLabel != 0) {
            pi.mIsStarted=false;
            if (pi.mActiveSince > si.mRunningService.activeSince) {
              pi.mActiveSince=si.mRunningService.activeSince;
            }
          }
        }
        sortedProcesses.add(pi);
      }
    }
    Collections.sort(sortedProcesses,mServiceProcessComparator);
    ArrayList<BaseItem> newItems=new ArrayList<BaseItem>();
    mProcessItems.clear();
    for (int i=0; i < sortedProcesses.size(); i++) {
      ProcessItem pi=sortedProcesses.get(i);
      pi.mNeedDivider=false;
      pi.addDependentProcesses(newItems,mProcessItems);
      newItems.add(pi);
      if (pi.mPid > 0) {
        mProcessItems.add(pi);
      }
      boolean needDivider=false;
      for (      ServiceItem si : pi.mServices.values()) {
        si.mNeedDivider=needDivider;
        needDivider=true;
        newItems.add(si);
      }
    }
synchronized (mLock) {
      mItems=newItems;
    }
  }
  mAllProcessItems.clear();
  mAllProcessItems.addAll(mProcessItems);
  int numBackgroundProcesses=0;
  int numForegroundProcesses=0;
  int numServiceProcesses=0;
  NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mCurSeq != mSequence) {
      if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        numBackgroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        numForegroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else {
        Log.i(TAG,""String_Node_Str"" + proc.mProcessName + ""String_Node_Str""+ proc.mPid);
      }
    }
 else {
      numServiceProcesses++;
    }
  }
  long backgroundProcessMemory=0;
  long foregroundProcessMemory=0;
  long serviceProcessMemory=0;
  try {
    final int numProc=mAllProcessItems.size();
    int[] pids=new int[numProc];
    for (int i=0; i < numProc; i++) {
      pids[i]=mAllProcessItems.get(i).mPid;
    }
    Debug.MemoryInfo[] mem=ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    for (int i=pids.length - 1; i >= 0; i--) {
      ProcessItem proc=mAllProcessItems.get(i);
      changed|=proc.updateSize(context,mem[i],mSequence);
      if (proc.mCurSeq == mSequence) {
        serviceProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        backgroundProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        foregroundProcessMemory+=proc.mSize;
      }
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mLock) {
    mNumBackgroundProcesses=numBackgroundProcesses;
    mNumForegroundProcesses=numForegroundProcesses;
    mNumServiceProcesses=numServiceProcesses;
    mBackgroundProcessMemory=backgroundProcessMemory;
    mForegroundProcessMemory=foregroundProcessMemory;
    mServiceProcessMemory=serviceProcessMemory;
  }
  return changed;
}",0.9257697174188106
180884,"public Object getItem(int position){
synchronized (mState.mLock) {
    return mState.mItems.get(position);
  }
}","public Object getItem(int position){
  return mItems.get(position);
}",0.7624309392265194
180885,"public long getItemId(int position){
  return position;
}","public long getItemId(int position){
  return mItems.get(position).hashCode();
}",0.8321167883211679
180886,"void refreshUi(boolean dataChanged){
  if (dataChanged) {
    ((ServiceListAdapter)(getListView().getAdapter())).notifyDataSetChanged();
  }
  long availMem=readAvailMem() - SECONDARY_SERVER_MEM;
  if (availMem < 0) {
    availMem=0;
  }
synchronized (mState.mLock) {
    if (mLastNumBackgroundProcesses != mState.mNumBackgroundProcesses || mLastBackgroundProcessMemory != mState.mBackgroundProcessMemory || mLastAvailMemory != availMem) {
      mLastNumBackgroundProcesses=mState.mNumBackgroundProcesses;
      mLastBackgroundProcessMemory=mState.mBackgroundProcessMemory;
      mLastAvailMemory=availMem;
      String availStr=availMem != 0 ? Formatter.formatShortFileSize(this,availMem) : ""String_Node_Str"";
      String sizeStr=Formatter.formatShortFileSize(this,mLastBackgroundProcessMemory);
      mBackgroundProcessText.setText(getResources().getString(R.string.service_background_processes,mLastNumBackgroundProcesses,availStr,sizeStr));
    }
    if (mLastNumForegroundProcesses != mState.mNumForegroundProcesses || mLastForegroundProcessMemory != mState.mForegroundProcessMemory) {
      mLastNumForegroundProcesses=mState.mNumForegroundProcesses;
      mLastForegroundProcessMemory=mState.mForegroundProcessMemory;
      String sizeStr=Formatter.formatShortFileSize(this,mLastForegroundProcessMemory);
      mForegroundProcessText.setText(getResources().getString(R.string.service_foreground_processes,mLastNumForegroundProcesses,sizeStr));
    }
    mLastNumServiceProcesses=mState.mNumServiceProcesses;
    mLastServiceProcessMemory=mState.mServiceProcessMemory;
    float totalMem=availMem + mLastBackgroundProcessMemory + mLastForegroundProcessMemory+ mLastServiceProcessMemory;
    mColorBar.setRatios(mLastForegroundProcessMemory / totalMem,mLastServiceProcessMemory / totalMem,(availMem + mLastBackgroundProcessMemory) / totalMem);
  }
}","void refreshUi(boolean dataChanged){
  if (dataChanged) {
    ServiceListAdapter adapter=(ServiceListAdapter)(getListView().getAdapter());
    adapter.refreshItems();
    adapter.notifyDataSetChanged();
  }
  long availMem=readAvailMem() - SECONDARY_SERVER_MEM;
  if (availMem < 0) {
    availMem=0;
  }
synchronized (mState.mLock) {
    if (mLastNumBackgroundProcesses != mState.mNumBackgroundProcesses || mLastBackgroundProcessMemory != mState.mBackgroundProcessMemory || mLastAvailMemory != availMem) {
      mLastNumBackgroundProcesses=mState.mNumBackgroundProcesses;
      mLastBackgroundProcessMemory=mState.mBackgroundProcessMemory;
      mLastAvailMemory=availMem;
      String availStr=availMem != 0 ? Formatter.formatShortFileSize(this,availMem) : ""String_Node_Str"";
      String sizeStr=Formatter.formatShortFileSize(this,mLastBackgroundProcessMemory);
      mBackgroundProcessText.setText(getResources().getString(R.string.service_background_processes,mLastNumBackgroundProcesses,availStr,sizeStr));
    }
    if (mLastNumForegroundProcesses != mState.mNumForegroundProcesses || mLastForegroundProcessMemory != mState.mForegroundProcessMemory) {
      mLastNumForegroundProcesses=mState.mNumForegroundProcesses;
      mLastForegroundProcessMemory=mState.mForegroundProcessMemory;
      String sizeStr=Formatter.formatShortFileSize(this,mLastForegroundProcessMemory);
      mForegroundProcessText.setText(getResources().getString(R.string.service_foreground_processes,mLastNumForegroundProcesses,sizeStr));
    }
    mLastNumServiceProcesses=mState.mNumServiceProcesses;
    mLastServiceProcessMemory=mState.mServiceProcessMemory;
    float totalMem=availMem + mLastBackgroundProcessMemory + mLastForegroundProcessMemory+ mLastServiceProcessMemory;
    mColorBar.setRatios(mLastForegroundProcessMemory / totalMem,mLastServiceProcessMemory / totalMem,(availMem + mLastBackgroundProcessMemory) / totalMem);
  }
}",0.9809322033898306
180887,"public int getCount(){
synchronized (mState.mLock) {
    return mState.mItems.size();
  }
}","public int getCount(){
  return mItems.size();
}",0.6906474820143885
180888,"ServiceListAdapter(State state){
synchronized (state.mLock) {
    mState=state;
    mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  }
}","ServiceListAdapter(State state){
  mState=state;
  mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  refreshItems();
}",0.8434504792332268
180889,"public boolean isEnabled(int position){
synchronized (mState.mLock) {
    return !mState.mItems.get(position).mIsProcess;
  }
}","public boolean isEnabled(int position){
  return !mItems.get(position).mIsProcess;
}",0.7962085308056872
180890,"public void bindView(View view,int position){
synchronized (mState.mLock) {
    ViewHolder vh=(ViewHolder)view.getTag();
    if (position >= mState.mItems.size()) {
      return;
    }
    BaseItem item=mState.mItems.get(position);
    vh.name.setText(item.mDisplayLabel);
    vh.separator.setVisibility(item.mNeedDivider ? View.VISIBLE : View.INVISIBLE);
    ActiveItem ai=new ActiveItem();
    ai.mRootView=view;
    ai.mItem=item;
    ai.mHolder=vh;
    ai.mFirstRunTime=item.mActiveSince;
    vh.description.setText(item.mDescription);
    if (item.mIsProcess) {
      view.setBackgroundColor(mProcessBgColor);
      vh.icon.setImageDrawable(null);
      vh.icon.setVisibility(View.GONE);
      vh.description.setText(item.mDescription);
      item.mCurSizeStr=null;
    }
 else {
      view.setBackgroundDrawable(null);
      vh.icon.setImageDrawable(item.mPackageInfo.loadIcon(getPackageManager()));
      vh.icon.setVisibility(View.VISIBLE);
      vh.description.setText(item.mDescription);
      ai.mFirstRunTime=item.mActiveSince;
    }
    ai.updateTime(RunningServices.this);
    mActiveItems.put(view,ai);
  }
}","public void bindView(View view,int position){
synchronized (mState.mLock) {
    ViewHolder vh=(ViewHolder)view.getTag();
    if (position >= mItems.size()) {
      return;
    }
    BaseItem item=mItems.get(position);
    vh.name.setText(item.mDisplayLabel);
    vh.separator.setVisibility(item.mNeedDivider ? View.VISIBLE : View.INVISIBLE);
    ActiveItem ai=new ActiveItem();
    ai.mRootView=view;
    ai.mItem=item;
    ai.mHolder=vh;
    ai.mFirstRunTime=item.mActiveSince;
    vh.description.setText(item.mDescription);
    if (item.mIsProcess) {
      view.setBackgroundColor(mProcessBgColor);
      vh.icon.setImageDrawable(null);
      vh.icon.setVisibility(View.GONE);
      vh.description.setText(item.mDescription);
      item.mCurSizeStr=null;
    }
 else {
      view.setBackgroundDrawable(null);
      vh.icon.setImageDrawable(item.mPackageInfo.loadIcon(getPackageManager()));
      vh.icon.setVisibility(View.VISIBLE);
      vh.description.setText(item.mDescription);
      ai.mFirstRunTime=item.mActiveSince;
    }
    ai.updateTime(RunningServices.this);
    mActiveItems.put(view,ai);
  }
}",0.9937275985663082
180891,"boolean update(Context context,ActivityManager am){
  final PackageManager pm=context.getPackageManager();
  mSequence++;
  boolean changed=false;
  List<ActivityManager.RunningServiceInfo> services=am.getRunningServices(MAX_SERVICES);
  final int NS=services != null ? services.size() : 0;
  for (int i=0; i < NS; i++) {
    ActivityManager.RunningServiceInfo si=services.get(i);
    if (!si.started && si.clientLabel == 0) {
      continue;
    }
    if ((si.flags & ActivityManager.RunningServiceInfo.FLAG_PERSISTENT_PROCESS) != 0) {
      continue;
    }
    HashMap<String,ProcessItem> procs=mProcesses.get(si.uid);
    if (procs == null) {
      procs=new HashMap<String,ProcessItem>();
      mProcesses.put(si.uid,procs);
    }
    ProcessItem proc=procs.get(si.process);
    if (proc == null) {
      changed=true;
      proc=new ProcessItem(context,si.uid,si.process);
      procs.put(si.process,proc);
    }
    if (proc.mCurSeq != mSequence) {
      int pid=si.restarting == 0 ? si.pid : 0;
      if (pid != proc.mPid) {
        changed=true;
        if (proc.mPid != pid) {
          if (proc.mPid != 0) {
            mActiveProcesses.remove(proc.mPid);
          }
          if (pid != 0) {
            mActiveProcesses.put(pid,proc);
          }
          proc.mPid=pid;
        }
      }
      proc.mDependentProcesses.clear();
      proc.mCurSeq=mSequence;
    }
    changed|=proc.updateService(context,si);
  }
  List<ActivityManager.RunningAppProcessInfo> processes=am.getRunningAppProcesses();
  final int NP=processes != null ? processes.size() : 0;
  for (int i=0; i < NP; i++) {
    ActivityManager.RunningAppProcessInfo pi=processes.get(i);
    ProcessItem proc=mActiveProcesses.get(pi.pid);
    if (proc == null) {
      proc=mRunningProcesses.get(pi.pid);
      if (proc == null) {
        proc=new ProcessItem(context,pi.uid,pi.processName);
        proc.mPid=pi.pid;
        mRunningProcesses.put(pi.pid,proc);
      }
      proc.mDependentProcesses.clear();
    }
    proc.mRunningSeq=mSequence;
    proc.mRunningProcessInfo=pi;
  }
  int NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mRunningSeq == mSequence) {
      int clientPid=proc.mRunningProcessInfo.importanceReasonPid;
      if (clientPid != 0) {
        ProcessItem client=mActiveProcesses.get(clientPid);
        if (client == null) {
          client=mRunningProcesses.get(clientPid);
        }
        if (client != null) {
          client.mDependentProcesses.put(proc.mPid,proc);
        }
      }
 else {
        proc.mClient=null;
      }
    }
 else {
      mRunningProcesses.remove(mRunningProcesses.keyAt(i));
    }
  }
  final int NAP=mActiveProcesses.size();
  for (int i=0; i < NAP; i++) {
    ProcessItem proc=mActiveProcesses.valueAt(i);
    if (proc.mCurSeq == mSequence) {
      changed|=proc.buildDependencyChain(context,pm,mSequence);
    }
  }
  for (int i=0; i < mProcesses.size(); i++) {
    HashMap<String,ProcessItem> procs=mProcesses.valueAt(i);
    Iterator<ProcessItem> pit=procs.values().iterator();
    while (pit.hasNext()) {
      ProcessItem pi=pit.next();
      if (pi.mCurSeq == mSequence) {
        pi.ensureLabel(pm);
        if (pi.mPid == 0) {
          pi.mDependentProcesses.clear();
        }
      }
 else {
        changed=true;
        pit.remove();
        if (procs.size() == 0) {
          mProcesses.remove(mProcesses.keyAt(i));
        }
        if (pi.mPid != 0) {
          mActiveProcesses.remove(pi.mPid);
        }
        continue;
      }
      Iterator<ServiceItem> sit=pi.mServices.values().iterator();
      while (sit.hasNext()) {
        ServiceItem si=sit.next();
        if (si.mCurSeq != mSequence) {
          changed=true;
          sit.remove();
        }
      }
    }
  }
  if (changed) {
    ArrayList<BaseItem> newItems=new ArrayList<BaseItem>();
    mProcessItems.clear();
    for (int i=0; i < mProcesses.size(); i++) {
      for (      ProcessItem pi : mProcesses.valueAt(i).values()) {
        pi.mNeedDivider=false;
        pi.addDependentProcesses(newItems,mProcessItems);
        newItems.add(pi);
        if (pi.mPid > 0) {
          mProcessItems.add(pi);
        }
        boolean needDivider=false;
        for (        ServiceItem si : pi.mServices.values()) {
          si.mNeedDivider=needDivider;
          needDivider=true;
          newItems.add(si);
        }
      }
    }
synchronized (mLock) {
      mItems=newItems;
    }
  }
  mAllProcessItems.clear();
  mAllProcessItems.addAll(mProcessItems);
  int numBackgroundProcesses=0;
  int numForegroundProcesses=0;
  int numServiceProcesses=0;
  NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mCurSeq != mSequence) {
      if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        numBackgroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        numForegroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else {
        Log.i(TAG,""String_Node_Str"" + proc.mProcessName + ""String_Node_Str""+ proc.mPid);
      }
    }
 else {
      numServiceProcesses++;
    }
  }
  long backgroundProcessMemory=0;
  long foregroundProcessMemory=0;
  long serviceProcessMemory=0;
  try {
    final int numProc=mAllProcessItems.size();
    int[] pids=new int[numProc];
    for (int i=0; i < numProc; i++) {
      pids[i]=mAllProcessItems.get(i).mPid;
    }
    Debug.MemoryInfo[] mem=ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    for (int i=pids.length - 1; i >= 0; i--) {
      ProcessItem proc=mAllProcessItems.get(i);
      changed|=proc.updateSize(context,mem[i],mSequence);
      if (proc.mCurSeq == mSequence) {
        serviceProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        backgroundProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        foregroundProcessMemory+=proc.mSize;
      }
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mLock) {
    mNumBackgroundProcesses=numBackgroundProcesses;
    mNumForegroundProcesses=numForegroundProcesses;
    mNumServiceProcesses=numServiceProcesses;
    mBackgroundProcessMemory=backgroundProcessMemory;
    mForegroundProcessMemory=foregroundProcessMemory;
    mServiceProcessMemory=serviceProcessMemory;
  }
  return changed;
}","boolean update(Context context,ActivityManager am){
  final PackageManager pm=context.getPackageManager();
  mSequence++;
  boolean changed=false;
  List<ActivityManager.RunningServiceInfo> services=am.getRunningServices(MAX_SERVICES);
  final int NS=services != null ? services.size() : 0;
  for (int i=0; i < NS; i++) {
    ActivityManager.RunningServiceInfo si=services.get(i);
    if (!si.started && si.clientLabel == 0) {
      continue;
    }
    if ((si.flags & ActivityManager.RunningServiceInfo.FLAG_PERSISTENT_PROCESS) != 0) {
      continue;
    }
    HashMap<String,ProcessItem> procs=mProcesses.get(si.uid);
    if (procs == null) {
      procs=new HashMap<String,ProcessItem>();
      mProcesses.put(si.uid,procs);
    }
    ProcessItem proc=procs.get(si.process);
    if (proc == null) {
      changed=true;
      proc=new ProcessItem(context,si.uid,si.process);
      procs.put(si.process,proc);
    }
    if (proc.mCurSeq != mSequence) {
      int pid=si.restarting == 0 ? si.pid : 0;
      if (pid != proc.mPid) {
        changed=true;
        if (proc.mPid != pid) {
          if (proc.mPid != 0) {
            mActiveProcesses.remove(proc.mPid);
          }
          if (pid != 0) {
            mActiveProcesses.put(pid,proc);
          }
          proc.mPid=pid;
        }
      }
      proc.mDependentProcesses.clear();
      proc.mCurSeq=mSequence;
    }
    changed|=proc.updateService(context,si);
  }
  List<ActivityManager.RunningAppProcessInfo> processes=am.getRunningAppProcesses();
  final int NP=processes != null ? processes.size() : 0;
  for (int i=0; i < NP; i++) {
    ActivityManager.RunningAppProcessInfo pi=processes.get(i);
    ProcessItem proc=mActiveProcesses.get(pi.pid);
    if (proc == null) {
      proc=mRunningProcesses.get(pi.pid);
      if (proc == null) {
        proc=new ProcessItem(context,pi.uid,pi.processName);
        proc.mPid=pi.pid;
        mRunningProcesses.put(pi.pid,proc);
      }
      proc.mDependentProcesses.clear();
    }
    proc.mRunningSeq=mSequence;
    proc.mRunningProcessInfo=pi;
  }
  int NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mRunningSeq == mSequence) {
      int clientPid=proc.mRunningProcessInfo.importanceReasonPid;
      if (clientPid != 0) {
        ProcessItem client=mActiveProcesses.get(clientPid);
        if (client == null) {
          client=mRunningProcesses.get(clientPid);
        }
        if (client != null) {
          client.mDependentProcesses.put(proc.mPid,proc);
        }
      }
 else {
        proc.mClient=null;
      }
    }
 else {
      mRunningProcesses.remove(mRunningProcesses.keyAt(i));
    }
  }
  final int NAP=mActiveProcesses.size();
  for (int i=0; i < NAP; i++) {
    ProcessItem proc=mActiveProcesses.valueAt(i);
    if (proc.mCurSeq == mSequence) {
      changed|=proc.buildDependencyChain(context,pm,mSequence);
    }
  }
  for (int i=0; i < mProcesses.size(); i++) {
    HashMap<String,ProcessItem> procs=mProcesses.valueAt(i);
    Iterator<ProcessItem> pit=procs.values().iterator();
    while (pit.hasNext()) {
      ProcessItem pi=pit.next();
      if (pi.mCurSeq == mSequence) {
        pi.ensureLabel(pm);
        if (pi.mPid == 0) {
          pi.mDependentProcesses.clear();
        }
      }
 else {
        changed=true;
        pit.remove();
        if (procs.size() == 0) {
          mProcesses.remove(mProcesses.keyAt(i));
        }
        if (pi.mPid != 0) {
          mActiveProcesses.remove(pi.mPid);
        }
        continue;
      }
      Iterator<ServiceItem> sit=pi.mServices.values().iterator();
      while (sit.hasNext()) {
        ServiceItem si=sit.next();
        if (si.mCurSeq != mSequence) {
          changed=true;
          sit.remove();
        }
      }
    }
  }
  if (changed) {
    ArrayList<ProcessItem> sortedProcesses=new ArrayList<ProcessItem>();
    for (int i=0; i < mProcesses.size(); i++) {
      for (      ProcessItem pi : mProcesses.valueAt(i).values()) {
        pi.mIsSystem=false;
        pi.mIsStarted=true;
        pi.mActiveSince=Long.MAX_VALUE;
        for (        ServiceItem si : pi.mServices.values()) {
          if (si.mServiceInfo != null && (si.mServiceInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            pi.mIsSystem=true;
          }
          if (si.mRunningService != null && si.mRunningService.clientLabel != 0) {
            pi.mIsStarted=false;
            if (pi.mActiveSince > si.mRunningService.activeSince) {
              pi.mActiveSince=si.mRunningService.activeSince;
            }
          }
        }
        sortedProcesses.add(pi);
      }
    }
    Collections.sort(sortedProcesses,mServiceProcessComparator);
    ArrayList<BaseItem> newItems=new ArrayList<BaseItem>();
    mProcessItems.clear();
    for (int i=0; i < sortedProcesses.size(); i++) {
      ProcessItem pi=sortedProcesses.get(i);
      pi.mNeedDivider=false;
      pi.addDependentProcesses(newItems,mProcessItems);
      newItems.add(pi);
      if (pi.mPid > 0) {
        mProcessItems.add(pi);
      }
      boolean needDivider=false;
      for (      ServiceItem si : pi.mServices.values()) {
        si.mNeedDivider=needDivider;
        needDivider=true;
        newItems.add(si);
      }
    }
synchronized (mLock) {
      mItems=newItems;
    }
  }
  mAllProcessItems.clear();
  mAllProcessItems.addAll(mProcessItems);
  int numBackgroundProcesses=0;
  int numForegroundProcesses=0;
  int numServiceProcesses=0;
  NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mCurSeq != mSequence) {
      if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        numBackgroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        numForegroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else {
        Log.i(TAG,""String_Node_Str"" + proc.mProcessName + ""String_Node_Str""+ proc.mPid);
      }
    }
 else {
      numServiceProcesses++;
    }
  }
  long backgroundProcessMemory=0;
  long foregroundProcessMemory=0;
  long serviceProcessMemory=0;
  try {
    final int numProc=mAllProcessItems.size();
    int[] pids=new int[numProc];
    for (int i=0; i < numProc; i++) {
      pids[i]=mAllProcessItems.get(i).mPid;
    }
    Debug.MemoryInfo[] mem=ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    for (int i=pids.length - 1; i >= 0; i--) {
      ProcessItem proc=mAllProcessItems.get(i);
      changed|=proc.updateSize(context,mem[i],mSequence);
      if (proc.mCurSeq == mSequence) {
        serviceProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        backgroundProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        foregroundProcessMemory+=proc.mSize;
      }
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mLock) {
    mNumBackgroundProcesses=numBackgroundProcesses;
    mNumForegroundProcesses=numForegroundProcesses;
    mNumServiceProcesses=numServiceProcesses;
    mBackgroundProcessMemory=backgroundProcessMemory;
    mForegroundProcessMemory=foregroundProcessMemory;
    mServiceProcessMemory=serviceProcessMemory;
  }
  return changed;
}",0.9257697174188106
180892,"public Object getItem(int position){
synchronized (mState.mLock) {
    return mState.mItems.get(position);
  }
}","public Object getItem(int position){
  return mItems.get(position);
}",0.7624309392265194
180893,"public long getItemId(int position){
  return position;
}","public long getItemId(int position){
  return mItems.get(position).hashCode();
}",0.8321167883211679
180894,"void refreshUi(boolean dataChanged){
  if (dataChanged) {
    ((ServiceListAdapter)(getListView().getAdapter())).notifyDataSetChanged();
  }
  long availMem=readAvailMem() - SECONDARY_SERVER_MEM;
  if (availMem < 0) {
    availMem=0;
  }
synchronized (mState.mLock) {
    if (mLastNumBackgroundProcesses != mState.mNumBackgroundProcesses || mLastBackgroundProcessMemory != mState.mBackgroundProcessMemory || mLastAvailMemory != availMem) {
      mLastNumBackgroundProcesses=mState.mNumBackgroundProcesses;
      mLastBackgroundProcessMemory=mState.mBackgroundProcessMemory;
      mLastAvailMemory=availMem;
      String availStr=availMem != 0 ? Formatter.formatShortFileSize(this,availMem) : ""String_Node_Str"";
      String sizeStr=Formatter.formatShortFileSize(this,mLastBackgroundProcessMemory);
      mBackgroundProcessText.setText(getResources().getString(R.string.service_background_processes,mLastNumBackgroundProcesses,availStr,sizeStr));
    }
    if (mLastNumForegroundProcesses != mState.mNumForegroundProcesses || mLastForegroundProcessMemory != mState.mForegroundProcessMemory) {
      mLastNumForegroundProcesses=mState.mNumForegroundProcesses;
      mLastForegroundProcessMemory=mState.mForegroundProcessMemory;
      String sizeStr=Formatter.formatShortFileSize(this,mLastForegroundProcessMemory);
      mForegroundProcessText.setText(getResources().getString(R.string.service_foreground_processes,mLastNumForegroundProcesses,sizeStr));
    }
    mLastNumServiceProcesses=mState.mNumServiceProcesses;
    mLastServiceProcessMemory=mState.mServiceProcessMemory;
    float totalMem=availMem + mLastBackgroundProcessMemory + mLastForegroundProcessMemory+ mLastServiceProcessMemory;
    mColorBar.setRatios(mLastForegroundProcessMemory / totalMem,mLastServiceProcessMemory / totalMem,(availMem + mLastBackgroundProcessMemory) / totalMem);
  }
}","void refreshUi(boolean dataChanged){
  if (dataChanged) {
    ServiceListAdapter adapter=(ServiceListAdapter)(getListView().getAdapter());
    adapter.refreshItems();
    adapter.notifyDataSetChanged();
  }
  long availMem=readAvailMem() - SECONDARY_SERVER_MEM;
  if (availMem < 0) {
    availMem=0;
  }
synchronized (mState.mLock) {
    if (mLastNumBackgroundProcesses != mState.mNumBackgroundProcesses || mLastBackgroundProcessMemory != mState.mBackgroundProcessMemory || mLastAvailMemory != availMem) {
      mLastNumBackgroundProcesses=mState.mNumBackgroundProcesses;
      mLastBackgroundProcessMemory=mState.mBackgroundProcessMemory;
      mLastAvailMemory=availMem;
      String availStr=availMem != 0 ? Formatter.formatShortFileSize(this,availMem) : ""String_Node_Str"";
      String sizeStr=Formatter.formatShortFileSize(this,mLastBackgroundProcessMemory);
      mBackgroundProcessText.setText(getResources().getString(R.string.service_background_processes,mLastNumBackgroundProcesses,availStr,sizeStr));
    }
    if (mLastNumForegroundProcesses != mState.mNumForegroundProcesses || mLastForegroundProcessMemory != mState.mForegroundProcessMemory) {
      mLastNumForegroundProcesses=mState.mNumForegroundProcesses;
      mLastForegroundProcessMemory=mState.mForegroundProcessMemory;
      String sizeStr=Formatter.formatShortFileSize(this,mLastForegroundProcessMemory);
      mForegroundProcessText.setText(getResources().getString(R.string.service_foreground_processes,mLastNumForegroundProcesses,sizeStr));
    }
    mLastNumServiceProcesses=mState.mNumServiceProcesses;
    mLastServiceProcessMemory=mState.mServiceProcessMemory;
    float totalMem=availMem + mLastBackgroundProcessMemory + mLastForegroundProcessMemory+ mLastServiceProcessMemory;
    mColorBar.setRatios(mLastForegroundProcessMemory / totalMem,mLastServiceProcessMemory / totalMem,(availMem + mLastBackgroundProcessMemory) / totalMem);
  }
}",0.9809322033898306
180895,"public int getCount(){
synchronized (mState.mLock) {
    return mState.mItems.size();
  }
}","public int getCount(){
  return mItems.size();
}",0.6906474820143885
180896,"ServiceListAdapter(State state){
synchronized (state.mLock) {
    mState=state;
    mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  }
}","ServiceListAdapter(State state){
  mState=state;
  mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  refreshItems();
}",0.8434504792332268
180897,"public boolean isEnabled(int position){
synchronized (mState.mLock) {
    return !mState.mItems.get(position).mIsProcess;
  }
}","public boolean isEnabled(int position){
  return !mItems.get(position).mIsProcess;
}",0.7962085308056872
180898,"public void handleMessage(Message msg){
switch (msg.what) {
case CLEAR_USER_DATA:
    processClearMsg(msg);
  break;
case GET_PKG_SIZE:
refreshSizeInfo(msg);
break;
case CLEAR_CACHE:
mPm.getPackageSizeInfo(mAppInfo.packageName,mSizeObserver);
break;
case PACKAGE_MOVE:
processMoveMsg(msg);
break;
default :
break;
}
}","public void handleMessage(Message msg){
  if (isFinishing()) {
    return;
  }
switch (msg.what) {
case CLEAR_USER_DATA:
    processClearMsg(msg);
  break;
case GET_PKG_SIZE:
refreshSizeInfo(msg);
break;
case CLEAR_CACHE:
mPm.getPackageSizeInfo(mAppInfo.packageName,mSizeObserver);
break;
case PACKAGE_MOVE:
processMoveMsg(msg);
break;
default :
break;
}
}",0.9420505200594352
180899,"public void bindView(View view,int position){
synchronized (mState.mLock) {
    ViewHolder vh=(ViewHolder)view.getTag();
    if (position >= mState.mItems.size()) {
      return;
    }
    BaseItem item=mState.mItems.get(position);
    vh.name.setText(item.mDisplayLabel);
    vh.separator.setVisibility(item.mNeedDivider ? View.VISIBLE : View.INVISIBLE);
    ActiveItem ai=new ActiveItem();
    ai.mRootView=view;
    ai.mItem=item;
    ai.mHolder=vh;
    ai.mFirstRunTime=item.mActiveSince;
    vh.description.setText(item.mDescription);
    if (item.mIsProcess) {
      view.setBackgroundColor(mProcessBgColor);
      vh.icon.setImageDrawable(null);
      vh.icon.setVisibility(View.GONE);
      vh.description.setText(item.mDescription);
      item.mCurSizeStr=null;
    }
 else {
      view.setBackgroundDrawable(null);
      vh.icon.setImageDrawable(item.mPackageInfo.loadIcon(getPackageManager()));
      vh.icon.setVisibility(View.VISIBLE);
      vh.description.setText(item.mDescription);
      ai.mFirstRunTime=item.mActiveSince;
    }
    ai.updateTime(RunningServices.this);
    mActiveItems.put(view,ai);
  }
}","public void bindView(View view,int position){
synchronized (mState.mLock) {
    ViewHolder vh=(ViewHolder)view.getTag();
    if (position >= mItems.size()) {
      return;
    }
    BaseItem item=mItems.get(position);
    vh.name.setText(item.mDisplayLabel);
    vh.separator.setVisibility(item.mNeedDivider ? View.VISIBLE : View.INVISIBLE);
    ActiveItem ai=new ActiveItem();
    ai.mRootView=view;
    ai.mItem=item;
    ai.mHolder=vh;
    ai.mFirstRunTime=item.mActiveSince;
    vh.description.setText(item.mDescription);
    if (item.mIsProcess) {
      view.setBackgroundColor(mProcessBgColor);
      vh.icon.setImageDrawable(null);
      vh.icon.setVisibility(View.GONE);
      vh.description.setText(item.mDescription);
      item.mCurSizeStr=null;
    }
 else {
      view.setBackgroundDrawable(null);
      vh.icon.setImageDrawable(item.mPackageInfo.loadIcon(getPackageManager()));
      vh.icon.setVisibility(View.VISIBLE);
      vh.description.setText(item.mDescription);
      ai.mFirstRunTime=item.mActiveSince;
    }
    ai.updateTime(RunningServices.this);
    mActiveItems.put(view,ai);
  }
}",0.9937275985663082
180900,"boolean update(Context context,ActivityManager am){
  final PackageManager pm=context.getPackageManager();
  mSequence++;
  boolean changed=false;
  List<ActivityManager.RunningServiceInfo> services=am.getRunningServices(MAX_SERVICES);
  final int NS=services != null ? services.size() : 0;
  for (int i=0; i < NS; i++) {
    ActivityManager.RunningServiceInfo si=services.get(i);
    if (!si.started && si.clientLabel == 0) {
      continue;
    }
    if ((si.flags & ActivityManager.RunningServiceInfo.FLAG_PERSISTENT_PROCESS) != 0) {
      continue;
    }
    HashMap<String,ProcessItem> procs=mProcesses.get(si.uid);
    if (procs == null) {
      procs=new HashMap<String,ProcessItem>();
      mProcesses.put(si.uid,procs);
    }
    ProcessItem proc=procs.get(si.process);
    if (proc == null) {
      changed=true;
      proc=new ProcessItem(context,si.uid,si.process);
      procs.put(si.process,proc);
    }
    if (proc.mCurSeq != mSequence) {
      int pid=si.restarting == 0 ? si.pid : 0;
      if (pid != proc.mPid) {
        changed=true;
        if (proc.mPid != pid) {
          if (proc.mPid != 0) {
            mActiveProcesses.remove(proc.mPid);
          }
          if (pid != 0) {
            mActiveProcesses.put(pid,proc);
          }
          proc.mPid=pid;
        }
      }
      proc.mDependentProcesses.clear();
      proc.mCurSeq=mSequence;
    }
    changed|=proc.updateService(context,si);
  }
  List<ActivityManager.RunningAppProcessInfo> processes=am.getRunningAppProcesses();
  final int NP=processes != null ? processes.size() : 0;
  for (int i=0; i < NP; i++) {
    ActivityManager.RunningAppProcessInfo pi=processes.get(i);
    ProcessItem proc=mActiveProcesses.get(pi.pid);
    if (proc == null) {
      proc=mRunningProcesses.get(pi.pid);
      if (proc == null) {
        proc=new ProcessItem(context,pi.uid,pi.processName);
        proc.mPid=pi.pid;
        mRunningProcesses.put(pi.pid,proc);
      }
      proc.mDependentProcesses.clear();
    }
    proc.mRunningSeq=mSequence;
    proc.mRunningProcessInfo=pi;
  }
  int NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mRunningSeq == mSequence) {
      int clientPid=proc.mRunningProcessInfo.importanceReasonPid;
      if (clientPid != 0) {
        ProcessItem client=mActiveProcesses.get(clientPid);
        if (client == null) {
          client=mRunningProcesses.get(clientPid);
        }
        if (client != null) {
          client.mDependentProcesses.put(proc.mPid,proc);
        }
      }
 else {
        proc.mClient=null;
      }
    }
 else {
      mRunningProcesses.remove(mRunningProcesses.keyAt(i));
    }
  }
  final int NAP=mActiveProcesses.size();
  for (int i=0; i < NAP; i++) {
    ProcessItem proc=mActiveProcesses.valueAt(i);
    if (proc.mCurSeq == mSequence) {
      changed|=proc.buildDependencyChain(context,pm,mSequence);
    }
  }
  for (int i=0; i < mProcesses.size(); i++) {
    HashMap<String,ProcessItem> procs=mProcesses.valueAt(i);
    Iterator<ProcessItem> pit=procs.values().iterator();
    while (pit.hasNext()) {
      ProcessItem pi=pit.next();
      if (pi.mCurSeq == mSequence) {
        pi.ensureLabel(pm);
        if (pi.mPid == 0) {
          pi.mDependentProcesses.clear();
        }
      }
 else {
        changed=true;
        pit.remove();
        if (procs.size() == 0) {
          mProcesses.remove(mProcesses.keyAt(i));
        }
        if (pi.mPid != 0) {
          mActiveProcesses.remove(pi.mPid);
        }
        continue;
      }
      Iterator<ServiceItem> sit=pi.mServices.values().iterator();
      while (sit.hasNext()) {
        ServiceItem si=sit.next();
        if (si.mCurSeq != mSequence) {
          changed=true;
          sit.remove();
        }
      }
    }
  }
  if (changed) {
    ArrayList<BaseItem> newItems=new ArrayList<BaseItem>();
    mProcessItems.clear();
    for (int i=0; i < mProcesses.size(); i++) {
      for (      ProcessItem pi : mProcesses.valueAt(i).values()) {
        pi.mNeedDivider=false;
        pi.addDependentProcesses(newItems,mProcessItems);
        newItems.add(pi);
        if (pi.mPid > 0) {
          mProcessItems.add(pi);
        }
        boolean needDivider=false;
        for (        ServiceItem si : pi.mServices.values()) {
          si.mNeedDivider=needDivider;
          needDivider=true;
          newItems.add(si);
        }
      }
    }
synchronized (mLock) {
      mItems=newItems;
    }
  }
  mAllProcessItems.clear();
  mAllProcessItems.addAll(mProcessItems);
  int numBackgroundProcesses=0;
  int numForegroundProcesses=0;
  int numServiceProcesses=0;
  NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mCurSeq != mSequence) {
      if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        numBackgroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        numForegroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else {
        Log.i(TAG,""String_Node_Str"" + proc.mProcessName + ""String_Node_Str""+ proc.mPid);
      }
    }
 else {
      numServiceProcesses++;
    }
  }
  long backgroundProcessMemory=0;
  long foregroundProcessMemory=0;
  long serviceProcessMemory=0;
  try {
    final int numProc=mAllProcessItems.size();
    int[] pids=new int[numProc];
    for (int i=0; i < numProc; i++) {
      pids[i]=mAllProcessItems.get(i).mPid;
    }
    Debug.MemoryInfo[] mem=ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    for (int i=pids.length - 1; i >= 0; i--) {
      ProcessItem proc=mAllProcessItems.get(i);
      changed|=proc.updateSize(context,mem[i],mSequence);
      if (proc.mCurSeq == mSequence) {
        serviceProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        backgroundProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        foregroundProcessMemory+=proc.mSize;
      }
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mLock) {
    mNumBackgroundProcesses=numBackgroundProcesses;
    mNumForegroundProcesses=numForegroundProcesses;
    mNumServiceProcesses=numServiceProcesses;
    mBackgroundProcessMemory=backgroundProcessMemory;
    mForegroundProcessMemory=foregroundProcessMemory;
    mServiceProcessMemory=serviceProcessMemory;
  }
  return changed;
}","boolean update(Context context,ActivityManager am){
  final PackageManager pm=context.getPackageManager();
  mSequence++;
  boolean changed=false;
  List<ActivityManager.RunningServiceInfo> services=am.getRunningServices(MAX_SERVICES);
  final int NS=services != null ? services.size() : 0;
  for (int i=0; i < NS; i++) {
    ActivityManager.RunningServiceInfo si=services.get(i);
    if (!si.started && si.clientLabel == 0) {
      continue;
    }
    if ((si.flags & ActivityManager.RunningServiceInfo.FLAG_PERSISTENT_PROCESS) != 0) {
      continue;
    }
    HashMap<String,ProcessItem> procs=mProcesses.get(si.uid);
    if (procs == null) {
      procs=new HashMap<String,ProcessItem>();
      mProcesses.put(si.uid,procs);
    }
    ProcessItem proc=procs.get(si.process);
    if (proc == null) {
      changed=true;
      proc=new ProcessItem(context,si.uid,si.process);
      procs.put(si.process,proc);
    }
    if (proc.mCurSeq != mSequence) {
      int pid=si.restarting == 0 ? si.pid : 0;
      if (pid != proc.mPid) {
        changed=true;
        if (proc.mPid != pid) {
          if (proc.mPid != 0) {
            mActiveProcesses.remove(proc.mPid);
          }
          if (pid != 0) {
            mActiveProcesses.put(pid,proc);
          }
          proc.mPid=pid;
        }
      }
      proc.mDependentProcesses.clear();
      proc.mCurSeq=mSequence;
    }
    changed|=proc.updateService(context,si);
  }
  List<ActivityManager.RunningAppProcessInfo> processes=am.getRunningAppProcesses();
  final int NP=processes != null ? processes.size() : 0;
  for (int i=0; i < NP; i++) {
    ActivityManager.RunningAppProcessInfo pi=processes.get(i);
    ProcessItem proc=mActiveProcesses.get(pi.pid);
    if (proc == null) {
      proc=mRunningProcesses.get(pi.pid);
      if (proc == null) {
        proc=new ProcessItem(context,pi.uid,pi.processName);
        proc.mPid=pi.pid;
        mRunningProcesses.put(pi.pid,proc);
      }
      proc.mDependentProcesses.clear();
    }
    proc.mRunningSeq=mSequence;
    proc.mRunningProcessInfo=pi;
  }
  int NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mRunningSeq == mSequence) {
      int clientPid=proc.mRunningProcessInfo.importanceReasonPid;
      if (clientPid != 0) {
        ProcessItem client=mActiveProcesses.get(clientPid);
        if (client == null) {
          client=mRunningProcesses.get(clientPid);
        }
        if (client != null) {
          client.mDependentProcesses.put(proc.mPid,proc);
        }
      }
 else {
        proc.mClient=null;
      }
    }
 else {
      mRunningProcesses.remove(mRunningProcesses.keyAt(i));
    }
  }
  final int NAP=mActiveProcesses.size();
  for (int i=0; i < NAP; i++) {
    ProcessItem proc=mActiveProcesses.valueAt(i);
    if (proc.mCurSeq == mSequence) {
      changed|=proc.buildDependencyChain(context,pm,mSequence);
    }
  }
  for (int i=0; i < mProcesses.size(); i++) {
    HashMap<String,ProcessItem> procs=mProcesses.valueAt(i);
    Iterator<ProcessItem> pit=procs.values().iterator();
    while (pit.hasNext()) {
      ProcessItem pi=pit.next();
      if (pi.mCurSeq == mSequence) {
        pi.ensureLabel(pm);
        if (pi.mPid == 0) {
          pi.mDependentProcesses.clear();
        }
      }
 else {
        changed=true;
        pit.remove();
        if (procs.size() == 0) {
          mProcesses.remove(mProcesses.keyAt(i));
        }
        if (pi.mPid != 0) {
          mActiveProcesses.remove(pi.mPid);
        }
        continue;
      }
      Iterator<ServiceItem> sit=pi.mServices.values().iterator();
      while (sit.hasNext()) {
        ServiceItem si=sit.next();
        if (si.mCurSeq != mSequence) {
          changed=true;
          sit.remove();
        }
      }
    }
  }
  if (changed) {
    ArrayList<ProcessItem> sortedProcesses=new ArrayList<ProcessItem>();
    for (int i=0; i < mProcesses.size(); i++) {
      for (      ProcessItem pi : mProcesses.valueAt(i).values()) {
        pi.mIsSystem=false;
        pi.mIsStarted=true;
        pi.mActiveSince=Long.MAX_VALUE;
        for (        ServiceItem si : pi.mServices.values()) {
          if (si.mServiceInfo != null && (si.mServiceInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            pi.mIsSystem=true;
          }
          if (si.mRunningService != null && si.mRunningService.clientLabel != 0) {
            pi.mIsStarted=false;
            if (pi.mActiveSince > si.mRunningService.activeSince) {
              pi.mActiveSince=si.mRunningService.activeSince;
            }
          }
        }
        sortedProcesses.add(pi);
      }
    }
    Collections.sort(sortedProcesses,mServiceProcessComparator);
    ArrayList<BaseItem> newItems=new ArrayList<BaseItem>();
    mProcessItems.clear();
    for (int i=0; i < sortedProcesses.size(); i++) {
      ProcessItem pi=sortedProcesses.get(i);
      pi.mNeedDivider=false;
      pi.addDependentProcesses(newItems,mProcessItems);
      newItems.add(pi);
      if (pi.mPid > 0) {
        mProcessItems.add(pi);
      }
      boolean needDivider=false;
      for (      ServiceItem si : pi.mServices.values()) {
        si.mNeedDivider=needDivider;
        needDivider=true;
        newItems.add(si);
      }
    }
synchronized (mLock) {
      mItems=newItems;
    }
  }
  mAllProcessItems.clear();
  mAllProcessItems.addAll(mProcessItems);
  int numBackgroundProcesses=0;
  int numForegroundProcesses=0;
  int numServiceProcesses=0;
  NRP=mRunningProcesses.size();
  for (int i=0; i < NRP; i++) {
    ProcessItem proc=mRunningProcesses.valueAt(i);
    if (proc.mCurSeq != mSequence) {
      if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        numBackgroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        numForegroundProcesses++;
        mAllProcessItems.add(proc);
      }
 else {
        Log.i(TAG,""String_Node_Str"" + proc.mProcessName + ""String_Node_Str""+ proc.mPid);
      }
    }
 else {
      numServiceProcesses++;
    }
  }
  long backgroundProcessMemory=0;
  long foregroundProcessMemory=0;
  long serviceProcessMemory=0;
  try {
    final int numProc=mAllProcessItems.size();
    int[] pids=new int[numProc];
    for (int i=0; i < numProc; i++) {
      pids[i]=mAllProcessItems.get(i).mPid;
    }
    Debug.MemoryInfo[] mem=ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    for (int i=pids.length - 1; i >= 0; i--) {
      ProcessItem proc=mAllProcessItems.get(i);
      changed|=proc.updateSize(context,mem[i],mSequence);
      if (proc.mCurSeq == mSequence) {
        serviceProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance >= ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND) {
        backgroundProcessMemory+=proc.mSize;
      }
 else       if (proc.mRunningProcessInfo.importance <= ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) {
        foregroundProcessMemory+=proc.mSize;
      }
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mLock) {
    mNumBackgroundProcesses=numBackgroundProcesses;
    mNumForegroundProcesses=numForegroundProcesses;
    mNumServiceProcesses=numServiceProcesses;
    mBackgroundProcessMemory=backgroundProcessMemory;
    mForegroundProcessMemory=foregroundProcessMemory;
    mServiceProcessMemory=serviceProcessMemory;
  }
  return changed;
}",0.9257697174188106
180901,"public Object getItem(int position){
synchronized (mState.mLock) {
    return mState.mItems.get(position);
  }
}","public Object getItem(int position){
  return mItems.get(position);
}",0.7624309392265194
180902,"public long getItemId(int position){
  return position;
}","public long getItemId(int position){
  return mItems.get(position).hashCode();
}",0.8321167883211679
180903,"void refreshUi(boolean dataChanged){
  if (dataChanged) {
    ((ServiceListAdapter)(getListView().getAdapter())).notifyDataSetChanged();
  }
  long availMem=readAvailMem() - SECONDARY_SERVER_MEM;
  if (availMem < 0) {
    availMem=0;
  }
synchronized (mState.mLock) {
    if (mLastNumBackgroundProcesses != mState.mNumBackgroundProcesses || mLastBackgroundProcessMemory != mState.mBackgroundProcessMemory || mLastAvailMemory != availMem) {
      mLastNumBackgroundProcesses=mState.mNumBackgroundProcesses;
      mLastBackgroundProcessMemory=mState.mBackgroundProcessMemory;
      mLastAvailMemory=availMem;
      String availStr=availMem != 0 ? Formatter.formatShortFileSize(this,availMem) : ""String_Node_Str"";
      String sizeStr=Formatter.formatShortFileSize(this,mLastBackgroundProcessMemory);
      mBackgroundProcessText.setText(getResources().getString(R.string.service_background_processes,mLastNumBackgroundProcesses,availStr,sizeStr));
    }
    if (mLastNumForegroundProcesses != mState.mNumForegroundProcesses || mLastForegroundProcessMemory != mState.mForegroundProcessMemory) {
      mLastNumForegroundProcesses=mState.mNumForegroundProcesses;
      mLastForegroundProcessMemory=mState.mForegroundProcessMemory;
      String sizeStr=Formatter.formatShortFileSize(this,mLastForegroundProcessMemory);
      mForegroundProcessText.setText(getResources().getString(R.string.service_foreground_processes,mLastNumForegroundProcesses,sizeStr));
    }
    mLastNumServiceProcesses=mState.mNumServiceProcesses;
    mLastServiceProcessMemory=mState.mServiceProcessMemory;
    float totalMem=availMem + mLastBackgroundProcessMemory + mLastForegroundProcessMemory+ mLastServiceProcessMemory;
    mColorBar.setRatios(mLastForegroundProcessMemory / totalMem,mLastServiceProcessMemory / totalMem,(availMem + mLastBackgroundProcessMemory) / totalMem);
  }
}","void refreshUi(boolean dataChanged){
  if (dataChanged) {
    ServiceListAdapter adapter=(ServiceListAdapter)(getListView().getAdapter());
    adapter.refreshItems();
    adapter.notifyDataSetChanged();
  }
  long availMem=readAvailMem() - SECONDARY_SERVER_MEM;
  if (availMem < 0) {
    availMem=0;
  }
synchronized (mState.mLock) {
    if (mLastNumBackgroundProcesses != mState.mNumBackgroundProcesses || mLastBackgroundProcessMemory != mState.mBackgroundProcessMemory || mLastAvailMemory != availMem) {
      mLastNumBackgroundProcesses=mState.mNumBackgroundProcesses;
      mLastBackgroundProcessMemory=mState.mBackgroundProcessMemory;
      mLastAvailMemory=availMem;
      String availStr=availMem != 0 ? Formatter.formatShortFileSize(this,availMem) : ""String_Node_Str"";
      String sizeStr=Formatter.formatShortFileSize(this,mLastBackgroundProcessMemory);
      mBackgroundProcessText.setText(getResources().getString(R.string.service_background_processes,mLastNumBackgroundProcesses,availStr,sizeStr));
    }
    if (mLastNumForegroundProcesses != mState.mNumForegroundProcesses || mLastForegroundProcessMemory != mState.mForegroundProcessMemory) {
      mLastNumForegroundProcesses=mState.mNumForegroundProcesses;
      mLastForegroundProcessMemory=mState.mForegroundProcessMemory;
      String sizeStr=Formatter.formatShortFileSize(this,mLastForegroundProcessMemory);
      mForegroundProcessText.setText(getResources().getString(R.string.service_foreground_processes,mLastNumForegroundProcesses,sizeStr));
    }
    mLastNumServiceProcesses=mState.mNumServiceProcesses;
    mLastServiceProcessMemory=mState.mServiceProcessMemory;
    float totalMem=availMem + mLastBackgroundProcessMemory + mLastForegroundProcessMemory+ mLastServiceProcessMemory;
    mColorBar.setRatios(mLastForegroundProcessMemory / totalMem,mLastServiceProcessMemory / totalMem,(availMem + mLastBackgroundProcessMemory) / totalMem);
  }
}",0.9809322033898306
180904,"public int getCount(){
synchronized (mState.mLock) {
    return mState.mItems.size();
  }
}","public int getCount(){
  return mItems.size();
}",0.6906474820143885
180905,"ServiceListAdapter(State state){
synchronized (state.mLock) {
    mState=state;
    mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  }
}","ServiceListAdapter(State state){
  mState=state;
  mInflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  refreshItems();
}",0.8434504792332268
180906,"public boolean isEnabled(int position){
synchronized (mState.mLock) {
    return !mState.mItems.get(position).mIsProcess;
  }
}","public boolean isEnabled(int position){
  return !mItems.get(position).mIsProcess;
}",0.7962085308056872
180907,"public void handleMessage(Message msg){
switch (msg.what) {
case CLEAR_USER_DATA:
    processClearMsg(msg);
  break;
case GET_PKG_SIZE:
refreshSizeInfo(msg);
break;
case CLEAR_CACHE:
mPm.getPackageSizeInfo(mAppInfo.packageName,mSizeObserver);
break;
case PACKAGE_MOVE:
processMoveMsg(msg);
break;
default :
break;
}
}","public void handleMessage(Message msg){
  if (isFinishing()) {
    return;
  }
switch (msg.what) {
case CLEAR_USER_DATA:
    processClearMsg(msg);
  break;
case GET_PKG_SIZE:
refreshSizeInfo(msg);
break;
case CLEAR_CACHE:
mPm.getPackageSizeInfo(mAppInfo.packageName,mSizeObserver);
break;
case PACKAGE_MOVE:
processMoveMsg(msg);
break;
default :
break;
}
}",0.9420505200594352
180908,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
  mTts=new TextToSpeech(this,this);
}",0.9547738693467336
180909,"private void loadEngines(){
  ListPreference enginesPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_SYNTH);
  Intent intent=new Intent(""String_Node_Str"");
  ResolveInfo[] enginesArray=new ResolveInfo[0];
  PackageManager pm=getPackageManager();
  enginesArray=pm.queryIntentActivities(intent,0).toArray(enginesArray);
  ArrayList<CharSequence> entries=new ArrayList<CharSequence>();
  ArrayList<CharSequence> values=new ArrayList<CharSequence>();
  String enabledEngines=""String_Node_Str"";
  for (int i=0; i < enginesArray.length; i++) {
    String pluginPackageName=enginesArray[i].activityInfo.packageName;
    if (pluginPackageName.equals(SYSTEM_TTS)) {
      entries.add(enginesArray[i].loadLabel(pm));
      values.add(pluginPackageName);
    }
 else {
      CheckBoxPreference pref=(CheckBoxPreference)findPreference(KEY_PLUGIN_ENABLED_PREFIX + pluginPackageName);
      if ((pref != null) && pref.isChecked()) {
        entries.add(enginesArray[i].loadLabel(pm));
        values.add(pluginPackageName);
        enabledEngines=enabledEngines + pluginPackageName + ""String_Node_Str"";
      }
    }
  }
  ContentResolver resolver=getContentResolver();
  Settings.Secure.putString(resolver,TTS_ENABLED_PLUGINS,enabledEngines);
  CharSequence entriesArray[]=new CharSequence[entries.size()];
  CharSequence valuesArray[]=new CharSequence[values.size()];
  enginesPref.setEntries(entries.toArray(entriesArray));
  enginesPref.setEntryValues(values.toArray(valuesArray));
}","private void loadEngines(){
  ListPreference enginesPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_SYNTH);
  Intent intent=new Intent(""String_Node_Str"");
  ResolveInfo[] enginesArray=new ResolveInfo[0];
  PackageManager pm=getPackageManager();
  enginesArray=pm.queryIntentActivities(intent,0).toArray(enginesArray);
  ArrayList<CharSequence> entries=new ArrayList<CharSequence>();
  ArrayList<CharSequence> values=new ArrayList<CharSequence>();
  String enabledEngines=""String_Node_Str"";
  for (int i=0; i < enginesArray.length; i++) {
    String pluginPackageName=enginesArray[i].activityInfo.packageName;
    if (pluginPackageName.equals(SYSTEM_TTS)) {
      entries.add(enginesArray[i].loadLabel(pm));
      values.add(pluginPackageName);
    }
 else {
      CheckBoxPreference pref=(CheckBoxPreference)findPreference(KEY_PLUGIN_ENABLED_PREFIX + pluginPackageName);
      if ((pref != null) && pref.isChecked()) {
        entries.add(enginesArray[i].loadLabel(pm));
        values.add(pluginPackageName);
        enabledEngines=enabledEngines + pluginPackageName + ""String_Node_Str"";
      }
    }
  }
  ContentResolver resolver=getContentResolver();
  Settings.Secure.putString(resolver,TTS_ENABLED_PLUGINS,enabledEngines);
  CharSequence entriesArray[]=new CharSequence[entries.size()];
  CharSequence valuesArray[]=new CharSequence[values.size()];
  enginesPref.setEntries(entries.toArray(entriesArray));
  enginesPref.setEntryValues(values.toArray(valuesArray));
  String selectedEngine=Settings.Secure.getString(getContentResolver(),TTS_DEFAULT_SYNTH);
  int selectedEngineIndex=enginesPref.findIndexOfValue(selectedEngine);
  if (selectedEngineIndex == -1) {
    selectedEngineIndex=enginesPref.findIndexOfValue(SYSTEM_TTS);
  }
  enginesPref.setValueIndex(selectedEngineIndex);
}",0.9028117359413202
180910,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.tts_settings);
  addEngineSpecificSettings();
  mDemoStrings=getResources().getStringArray(R.array.tts_demo_strings);
  setVolumeControlStream(TextToSpeech.Engine.DEFAULT_STREAM);
  mEnableDemo=false;
  initClickers();
  initDefaultSettings();
  mTts=new TextToSpeech(this,this);
}",0.9547738693467336
180911,"private void loadEngines(){
  ListPreference enginesPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_SYNTH);
  Intent intent=new Intent(""String_Node_Str"");
  ResolveInfo[] enginesArray=new ResolveInfo[0];
  PackageManager pm=getPackageManager();
  enginesArray=pm.queryIntentActivities(intent,0).toArray(enginesArray);
  ArrayList<CharSequence> entries=new ArrayList<CharSequence>();
  ArrayList<CharSequence> values=new ArrayList<CharSequence>();
  String enabledEngines=""String_Node_Str"";
  for (int i=0; i < enginesArray.length; i++) {
    String pluginPackageName=enginesArray[i].activityInfo.packageName;
    if (pluginPackageName.equals(SYSTEM_TTS)) {
      entries.add(enginesArray[i].loadLabel(pm));
      values.add(pluginPackageName);
    }
 else {
      CheckBoxPreference pref=(CheckBoxPreference)findPreference(KEY_PLUGIN_ENABLED_PREFIX + pluginPackageName);
      if ((pref != null) && pref.isChecked()) {
        entries.add(enginesArray[i].loadLabel(pm));
        values.add(pluginPackageName);
        enabledEngines=enabledEngines + pluginPackageName + ""String_Node_Str"";
      }
    }
  }
  ContentResolver resolver=getContentResolver();
  Settings.Secure.putString(resolver,TTS_ENABLED_PLUGINS,enabledEngines);
  CharSequence entriesArray[]=new CharSequence[entries.size()];
  CharSequence valuesArray[]=new CharSequence[values.size()];
  enginesPref.setEntries(entries.toArray(entriesArray));
  enginesPref.setEntryValues(values.toArray(valuesArray));
}","private void loadEngines(){
  ListPreference enginesPref=(ListPreference)findPreference(KEY_TTS_DEFAULT_SYNTH);
  Intent intent=new Intent(""String_Node_Str"");
  ResolveInfo[] enginesArray=new ResolveInfo[0];
  PackageManager pm=getPackageManager();
  enginesArray=pm.queryIntentActivities(intent,0).toArray(enginesArray);
  ArrayList<CharSequence> entries=new ArrayList<CharSequence>();
  ArrayList<CharSequence> values=new ArrayList<CharSequence>();
  String enabledEngines=""String_Node_Str"";
  for (int i=0; i < enginesArray.length; i++) {
    String pluginPackageName=enginesArray[i].activityInfo.packageName;
    if (pluginPackageName.equals(SYSTEM_TTS)) {
      entries.add(enginesArray[i].loadLabel(pm));
      values.add(pluginPackageName);
    }
 else {
      CheckBoxPreference pref=(CheckBoxPreference)findPreference(KEY_PLUGIN_ENABLED_PREFIX + pluginPackageName);
      if ((pref != null) && pref.isChecked()) {
        entries.add(enginesArray[i].loadLabel(pm));
        values.add(pluginPackageName);
        enabledEngines=enabledEngines + pluginPackageName + ""String_Node_Str"";
      }
    }
  }
  ContentResolver resolver=getContentResolver();
  Settings.Secure.putString(resolver,TTS_ENABLED_PLUGINS,enabledEngines);
  CharSequence entriesArray[]=new CharSequence[entries.size()];
  CharSequence valuesArray[]=new CharSequence[values.size()];
  enginesPref.setEntries(entries.toArray(entriesArray));
  enginesPref.setEntryValues(values.toArray(valuesArray));
  String selectedEngine=Settings.Secure.getString(getContentResolver(),TTS_DEFAULT_SYNTH);
  int selectedEngineIndex=enginesPref.findIndexOfValue(selectedEngine);
  if (selectedEngineIndex == -1) {
    selectedEngineIndex=enginesPref.findIndexOfValue(SYSTEM_TTS);
  }
  enginesPref.setValueIndex(selectedEngineIndex);
}",0.9028117359413202
180912,"/** 
 * Handles the change of the accessibility enabled setting state.
 * @param preference The preference for enabling/disabling accessibility.
 */
private void handleEnableAccessibilityStateChange(CheckBoxPreference preference){
  if (preference.isChecked()) {
    Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,1);
  }
 else {
    final CheckBoxPreference checkBoxPreference=preference;
    AlertDialog dialog=(new AlertDialog.Builder(this)).setTitle(android.R.string.dialog_alert_title).setIcon(android.R.drawable.ic_dialog_alert).setMessage(getString(R.string.accessibility_service_disable_warning)).setCancelable(true).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
      }
    }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        checkBoxPreference.setChecked(true);
      }
    }
).create();
    dialog.show();
  }
}","/** 
 * Handles the change of the accessibility enabled setting state.
 * @param preference The preference for enabling/disabling accessibility.
 */
private void handleEnableAccessibilityStateChange(CheckBoxPreference preference){
  if (preference.isChecked()) {
    Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,1);
    setAccessibilityServicePreferencesState(true);
  }
 else {
    final CheckBoxPreference checkBoxPreference=preference;
    AlertDialog dialog=(new AlertDialog.Builder(this)).setTitle(android.R.string.dialog_alert_title).setIcon(android.R.drawable.ic_dialog_alert).setMessage(getString(R.string.accessibility_service_disable_warning)).setCancelable(true).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
        setAccessibilityServicePreferencesState(false);
      }
    }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        checkBoxPreference.setChecked(true);
      }
    }
).create();
    dialog.show();
  }
}",0.956237218813906
180913,"@Override protected void onResume(){
  super.onResume();
  final HashSet<String> enabled=new HashSet<String>();
  String settingValue=Settings.Secure.getString(getContentResolver(),Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
  if (settingValue != null) {
    TextUtils.SimpleStringSplitter splitter=mStringColonSplitter;
    splitter.setString(settingValue);
    while (splitter.hasNext()) {
      enabled.add(splitter.next());
    }
  }
  Map<String,ServiceInfo> accessibilityServices=mAccessibilityServices;
  for (  String key : accessibilityServices.keySet()) {
    CheckBoxPreference preference=(CheckBoxPreference)findPreference(key);
    if (preference != null) {
      preference.setChecked(enabled.contains(key));
    }
  }
  int serviceState=Settings.Secure.getInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
  if (!accessibilityServices.isEmpty()) {
    if (serviceState == 1) {
      mToggleCheckBox.setChecked(true);
    }
    mToggleCheckBox.setEnabled(true);
  }
 else {
    if (serviceState == 1) {
      Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
    }
    mToggleCheckBox.setEnabled(false);
    displayNoAppsAlert();
  }
}","@Override protected void onResume(){
  super.onResume();
  final HashSet<String> enabled=new HashSet<String>();
  String settingValue=Settings.Secure.getString(getContentResolver(),Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
  if (settingValue != null) {
    TextUtils.SimpleStringSplitter splitter=mStringColonSplitter;
    splitter.setString(settingValue);
    while (splitter.hasNext()) {
      enabled.add(splitter.next());
    }
  }
  Map<String,ServiceInfo> accessibilityServices=mAccessibilityServices;
  for (  String key : accessibilityServices.keySet()) {
    CheckBoxPreference preference=(CheckBoxPreference)findPreference(key);
    if (preference != null) {
      preference.setChecked(enabled.contains(key));
    }
  }
  int serviceState=Settings.Secure.getInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
  if (!accessibilityServices.isEmpty()) {
    if (serviceState == 1) {
      mToggleCheckBox.setChecked(true);
    }
 else {
      setAccessibilityServicePreferencesState(false);
    }
    mToggleCheckBox.setEnabled(true);
  }
 else {
    if (serviceState == 1) {
      Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
    }
    mToggleCheckBox.setEnabled(false);
    displayNoAppsAlert();
  }
}",0.9726027397260274
180914,"/** 
 * Handles the change of the accessibility enabled setting state.
 * @param preference The preference for enabling/disabling accessibility.
 */
private void handleEnableAccessibilityStateChange(CheckBoxPreference preference){
  if (preference.isChecked()) {
    Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,1);
  }
 else {
    final CheckBoxPreference checkBoxPreference=preference;
    AlertDialog dialog=(new AlertDialog.Builder(this)).setTitle(android.R.string.dialog_alert_title).setIcon(android.R.drawable.ic_dialog_alert).setMessage(getString(R.string.accessibility_service_disable_warning)).setCancelable(true).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
      }
    }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        checkBoxPreference.setChecked(true);
      }
    }
).create();
    dialog.show();
  }
}","/** 
 * Handles the change of the accessibility enabled setting state.
 * @param preference The preference for enabling/disabling accessibility.
 */
private void handleEnableAccessibilityStateChange(CheckBoxPreference preference){
  if (preference.isChecked()) {
    Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,1);
    setAccessibilityServicePreferencesState(true);
  }
 else {
    final CheckBoxPreference checkBoxPreference=preference;
    AlertDialog dialog=(new AlertDialog.Builder(this)).setTitle(android.R.string.dialog_alert_title).setIcon(android.R.drawable.ic_dialog_alert).setMessage(getString(R.string.accessibility_service_disable_warning)).setCancelable(true).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
        setAccessibilityServicePreferencesState(false);
      }
    }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        checkBoxPreference.setChecked(true);
      }
    }
).create();
    dialog.show();
  }
}",0.956237218813906
180915,"@Override protected void onResume(){
  super.onResume();
  final HashSet<String> enabled=new HashSet<String>();
  String settingValue=Settings.Secure.getString(getContentResolver(),Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
  if (settingValue != null) {
    TextUtils.SimpleStringSplitter splitter=mStringColonSplitter;
    splitter.setString(settingValue);
    while (splitter.hasNext()) {
      enabled.add(splitter.next());
    }
  }
  Map<String,ServiceInfo> accessibilityServices=mAccessibilityServices;
  for (  String key : accessibilityServices.keySet()) {
    CheckBoxPreference preference=(CheckBoxPreference)findPreference(key);
    if (preference != null) {
      preference.setChecked(enabled.contains(key));
    }
  }
  int serviceState=Settings.Secure.getInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
  if (!accessibilityServices.isEmpty()) {
    if (serviceState == 1) {
      mToggleCheckBox.setChecked(true);
    }
    mToggleCheckBox.setEnabled(true);
  }
 else {
    if (serviceState == 1) {
      Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
    }
    mToggleCheckBox.setEnabled(false);
    displayNoAppsAlert();
  }
}","@Override protected void onResume(){
  super.onResume();
  final HashSet<String> enabled=new HashSet<String>();
  String settingValue=Settings.Secure.getString(getContentResolver(),Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
  if (settingValue != null) {
    TextUtils.SimpleStringSplitter splitter=mStringColonSplitter;
    splitter.setString(settingValue);
    while (splitter.hasNext()) {
      enabled.add(splitter.next());
    }
  }
  Map<String,ServiceInfo> accessibilityServices=mAccessibilityServices;
  for (  String key : accessibilityServices.keySet()) {
    CheckBoxPreference preference=(CheckBoxPreference)findPreference(key);
    if (preference != null) {
      preference.setChecked(enabled.contains(key));
    }
  }
  int serviceState=Settings.Secure.getInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
  if (!accessibilityServices.isEmpty()) {
    if (serviceState == 1) {
      mToggleCheckBox.setChecked(true);
    }
 else {
      setAccessibilityServicePreferencesState(false);
    }
    mToggleCheckBox.setEnabled(true);
  }
 else {
    if (serviceState == 1) {
      Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
    }
    mToggleCheckBox.setEnabled(false);
    displayNoAppsAlert();
  }
}",0.9726027397260274
180916,"private String getWord(int position){
  mCursor.moveToPosition(position);
  return mCursor.getString(mCursor.getColumnIndexOrThrow(UserDictionary.Words.WORD));
}","private String getWord(int position){
  mCursor.moveToPosition(position);
  if (mCursor.isAfterLast())   return null;
  return mCursor.getString(mCursor.getColumnIndexOrThrow(UserDictionary.Words.WORD));
}",0.8797814207650273
180917,"@Override public boolean onContextItemSelected(MenuItem item){
  ContextMenuInfo menuInfo=item.getMenuInfo();
  if (!(menuInfo instanceof AdapterContextMenuInfo))   return false;
  AdapterContextMenuInfo adapterMenuInfo=(AdapterContextMenuInfo)menuInfo;
  String word=getWord(adapterMenuInfo.position);
switch (item.getItemId()) {
case CONTEXT_MENU_DELETE:
    deleteWord(word);
  return true;
case CONTEXT_MENU_EDIT:
showAddOrEditDialog(word);
return true;
}
return false;
}","@Override public boolean onContextItemSelected(MenuItem item){
  ContextMenuInfo menuInfo=item.getMenuInfo();
  if (!(menuInfo instanceof AdapterContextMenuInfo))   return false;
  AdapterContextMenuInfo adapterMenuInfo=(AdapterContextMenuInfo)menuInfo;
  String word=getWord(adapterMenuInfo.position);
  if (word == null)   return true;
switch (item.getItemId()) {
case CONTEXT_MENU_DELETE:
    deleteWord(word);
  return true;
case CONTEXT_MENU_EDIT:
showAddOrEditDialog(word);
return true;
}
return false;
}",0.964467005076142
180918,"@Override protected void onResume(){
  super.onResume();
  final LockPatternUtils lockPatternUtils=mChooseLockSettingsHelper.utils();
  boolean patternExists=lockPatternUtils.savedPatternExists();
  if (mVisiblePattern != null) {
    mVisiblePattern.setEnabled(patternExists);
    mVisiblePattern.setChecked(lockPatternUtils.isVisiblePatternEnabled());
  }
  if (mTactileFeedback != null) {
    mTactileFeedback.setEnabled(patternExists);
    mTactileFeedback.setChecked(lockPatternUtils.isTactileFeedbackEnabled());
  }
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
  mCredentialStorage.resume();
}","@Override protected void onResume(){
  super.onResume();
  final LockPatternUtils lockPatternUtils=mChooseLockSettingsHelper.utils();
  if (mVisiblePattern != null) {
    mVisiblePattern.setChecked(lockPatternUtils.isVisiblePatternEnabled());
  }
  if (mTactileFeedback != null) {
    mTactileFeedback.setChecked(lockPatternUtils.isTactileFeedbackEnabled());
  }
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
  mCredentialStorage.resume();
}",0.8661016949152542
180919,"@Override protected void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mHandler=new Handler(getMainLooper());
  mDPM=(DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
  ComponentName cn=(ComponentName)getIntent().getParcelableExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN);
  if (cn == null) {
    Log.w(TAG,""String_Node_Str"" + getIntent().getAction());
    finish();
    return;
  }
  if (DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN.equals(getIntent().getAction())) {
    if (mDPM.isAdminActive(cn)) {
      setResult(Activity.RESULT_OK);
      finish();
      return;
    }
  }
  ActivityInfo ai;
  try {
    ai=getPackageManager().getReceiverInfo(cn,PackageManager.GET_META_DATA);
  }
 catch (  PackageManager.NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
  ResolveInfo ri=new ResolveInfo();
  ri.activityInfo=ai;
  try {
    mDeviceAdmin=new DeviceAdminInfo(this,ri);
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
  mAddMsgText=getIntent().getCharSequenceExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION);
  setContentView(R.layout.device_admin_add);
  mTitle=(TextView)findViewById(R.id.title);
  mAdminIcon=(ImageView)findViewById(R.id.admin_icon);
  mAdminName=(TextView)findViewById(R.id.admin_name);
  mAdminDescription=(TextView)findViewById(R.id.admin_description);
  mAddMsg=(TextView)findViewById(R.id.add_msg);
  mAdminWarning=(TextView)findViewById(R.id.admin_warning);
  mAdminPolicies=(ViewGroup)findViewById(R.id.admin_policies);
  mActionButton=(Button)findViewById(R.id.action_button);
  mActionButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      if (mAdding) {
        mDPM.setActiveAdmin(mDeviceAdmin.getComponent());
        setResult(Activity.RESULT_OK);
        finish();
      }
 else {
        mDPM.getRemoveWarning(mDeviceAdmin.getComponent(),new RemoteCallback(mHandler){
          @Override protected void onResult(          Bundle bundle){
            CharSequence msg=bundle != null ? bundle.getCharSequence(DeviceAdminReceiver.EXTRA_DISABLE_WARNING) : null;
            if (msg == null) {
              mDPM.removeActiveAdmin(mDeviceAdmin.getComponent());
              finish();
            }
 else {
              Bundle args=new Bundle();
              args.putCharSequence(DeviceAdminReceiver.EXTRA_DISABLE_WARNING,msg);
              showDialog(DIALOG_WARNING,args);
            }
          }
        }
);
      }
    }
  }
);
}","@Override protected void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mHandler=new Handler(getMainLooper());
  mDPM=(DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
  ComponentName cn=(ComponentName)getIntent().getParcelableExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN);
  if (cn == null) {
    Log.w(TAG,""String_Node_Str"" + getIntent().getAction());
    finish();
    return;
  }
  if (DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN.equals(getIntent().getAction())) {
    if (mDPM.isAdminActive(cn)) {
      setResult(Activity.RESULT_OK);
      finish();
      return;
    }
  }
  ActivityInfo ai;
  try {
    ai=getPackageManager().getReceiverInfo(cn,PackageManager.GET_META_DATA);
  }
 catch (  PackageManager.NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
  ResolveInfo ri=new ResolveInfo();
  ri.activityInfo=ai;
  try {
    mDeviceAdmin=new DeviceAdminInfo(this,ri);
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
  mAddMsgText=getIntent().getCharSequenceExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION);
  setContentView(R.layout.device_admin_add);
  mTitle=(TextView)findViewById(R.id.title);
  mAdminIcon=(ImageView)findViewById(R.id.admin_icon);
  mAdminName=(TextView)findViewById(R.id.admin_name);
  mAdminDescription=(TextView)findViewById(R.id.admin_description);
  mAddMsg=(TextView)findViewById(R.id.add_msg);
  mAdminWarning=(TextView)findViewById(R.id.admin_warning);
  mAdminPolicies=(ViewGroup)findViewById(R.id.admin_policies);
  mActionButton=(Button)findViewById(R.id.action_button);
  mActionButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      if (mAdding) {
        try {
          mDPM.setActiveAdmin(mDeviceAdmin.getComponent());
          setResult(Activity.RESULT_OK);
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"" + mDeviceAdmin.getComponent(),e);
          if (mDPM.isAdminActive(mDeviceAdmin.getComponent())) {
            setResult(Activity.RESULT_OK);
          }
        }
        finish();
      }
 else {
        mDPM.getRemoveWarning(mDeviceAdmin.getComponent(),new RemoteCallback(mHandler){
          @Override protected void onResult(          Bundle bundle){
            CharSequence msg=bundle != null ? bundle.getCharSequence(DeviceAdminReceiver.EXTRA_DISABLE_WARNING) : null;
            if (msg == null) {
              mDPM.removeActiveAdmin(mDeviceAdmin.getComponent());
              finish();
            }
 else {
              Bundle args=new Bundle();
              args.putCharSequence(DeviceAdminReceiver.EXTRA_DISABLE_WARNING,msg);
              showDialog(DIALOG_WARNING,args);
            }
          }
        }
);
      }
    }
  }
);
}",0.951902368987796
180920,"private void setNotificationVolumeVisibility(boolean visible){
  mSeekBarVolumizer[0].getSeekBar().setVisibility(visible ? View.VISIBLE : View.GONE);
  mNotificationVolumeTitle.setVisibility(visible ? View.VISIBLE : View.GONE);
}","private void setNotificationVolumeVisibility(boolean visible){
  if (mSeekBarVolumizer[0] != null) {
    mSeekBarVolumizer[0].getSeekBar().setVisibility(visible ? View.VISIBLE : View.GONE);
  }
  mNotificationVolumeTitle.setVisibility(visible ? View.VISIBLE : View.GONE);
}",0.9123505976095616
180921,"@Override protected void onSampleStarting(SeekBarVolumizer volumizer){
  super.onSampleStarting(volumizer);
  for (  SeekBarVolumizer vol : mSeekBarVolumizer) {
    if (vol != volumizer)     vol.stopSample();
  }
}","@Override protected void onSampleStarting(SeekBarVolumizer volumizer){
  super.onSampleStarting(volumizer);
  for (  SeekBarVolumizer vol : mSeekBarVolumizer) {
    if (vol != null && vol != volumizer)     vol.stopSample();
  }
}",0.9661399548532732
180922,"private void setNotificationVolumeVisibility(boolean visible){
  mSeekBarVolumizer[0].getSeekBar().setVisibility(visible ? View.VISIBLE : View.GONE);
  mNotificationVolumeTitle.setVisibility(visible ? View.VISIBLE : View.GONE);
}","private void setNotificationVolumeVisibility(boolean visible){
  if (mSeekBarVolumizer[0] != null) {
    mSeekBarVolumizer[0].getSeekBar().setVisibility(visible ? View.VISIBLE : View.GONE);
  }
  mNotificationVolumeTitle.setVisibility(visible ? View.VISIBLE : View.GONE);
}",0.9123505976095616
180923,"@Override protected void onSampleStarting(SeekBarVolumizer volumizer){
  super.onSampleStarting(volumizer);
  for (  SeekBarVolumizer vol : mSeekBarVolumizer) {
    if (vol != volumizer)     vol.stopSample();
  }
}","@Override protected void onSampleStarting(SeekBarVolumizer volumizer){
  super.onSampleStarting(volumizer);
  for (  SeekBarVolumizer vol : mSeekBarVolumizer) {
    if (vol != null && vol != volumizer)     vol.stopSample();
  }
}",0.9661399548532732
180924,"/** 
 * Handles the change of the accessibility enabled setting state.
 * @param preference The preference for enabling/disabling accessibility.
 */
private void handleEnableAccessibilityStateChange(CheckBoxPreference preference){
  if (preference.isChecked()) {
    Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,1);
    setAccessibilityServicePreferencesState(true);
  }
 else {
    final CheckBoxPreference checkBoxPreference=preference;
    AlertDialog dialog=(new AlertDialog.Builder(this)).setTitle(android.R.string.dialog_alert_title).setIcon(android.R.drawable.ic_dialog_alert).setMessage(getString(R.string.accessibility_service_disable_warning)).setCancelable(true).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
        setAccessibilityServicePreferencesState(false);
      }
    }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        checkBoxPreference.setChecked(true);
      }
    }
).create();
    dialog.show();
  }
}","/** 
 * Handles the change of the accessibility enabled setting state.
 * @param preference The preference for enabling/disabling accessibility.
 */
private void handleEnableAccessibilityStateChange(CheckBoxPreference preference){
  if (preference.isChecked()) {
    Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,1);
  }
 else {
    final CheckBoxPreference checkBoxPreference=preference;
    AlertDialog dialog=(new AlertDialog.Builder(this)).setTitle(android.R.string.dialog_alert_title).setIcon(android.R.drawable.ic_dialog_alert).setMessage(getString(R.string.accessibility_service_disable_warning)).setCancelable(true).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
      }
    }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        checkBoxPreference.setChecked(true);
      }
    }
).create();
    dialog.show();
  }
}",0.956237218813906
180925,"@Override protected void onResume(){
  super.onResume();
  final HashSet<String> enabled=new HashSet<String>();
  String settingValue=Settings.Secure.getString(getContentResolver(),Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
  if (settingValue != null) {
    TextUtils.SimpleStringSplitter splitter=mStringColonSplitter;
    splitter.setString(settingValue);
    while (splitter.hasNext()) {
      enabled.add(splitter.next());
    }
  }
  Map<String,ServiceInfo> accessibilityServices=mAccessibilityServices;
  for (  String key : accessibilityServices.keySet()) {
    CheckBoxPreference preference=(CheckBoxPreference)findPreference(key);
    if (preference != null) {
      preference.setChecked(enabled.contains(key));
    }
  }
  int serviceState=Settings.Secure.getInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
  if (!accessibilityServices.isEmpty()) {
    if (serviceState == 1) {
      mToggleCheckBox.setChecked(true);
    }
 else {
      setAccessibilityServicePreferencesState(false);
    }
    mToggleCheckBox.setEnabled(true);
  }
 else {
    if (serviceState == 1) {
      Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
      setAccessibilityServicePreferencesState(false);
    }
    mToggleCheckBox.setEnabled(false);
    displayNoAppsAlert();
  }
}","@Override protected void onResume(){
  super.onResume();
  final HashSet<String> enabled=new HashSet<String>();
  String settingValue=Settings.Secure.getString(getContentResolver(),Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
  if (settingValue != null) {
    TextUtils.SimpleStringSplitter splitter=mStringColonSplitter;
    splitter.setString(settingValue);
    while (splitter.hasNext()) {
      enabled.add(splitter.next());
    }
  }
  Map<String,ServiceInfo> accessibilityServices=mAccessibilityServices;
  for (  String key : accessibilityServices.keySet()) {
    CheckBoxPreference preference=(CheckBoxPreference)findPreference(key);
    if (preference != null) {
      preference.setChecked(enabled.contains(key));
    }
  }
  int serviceState=Settings.Secure.getInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
  if (!accessibilityServices.isEmpty()) {
    if (serviceState == 1) {
      mToggleCheckBox.setChecked(true);
    }
    mToggleCheckBox.setEnabled(true);
  }
 else {
    if (serviceState == 1) {
      Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
    }
    mToggleCheckBox.setEnabled(false);
    displayNoAppsAlert();
  }
}",0.9518927444794952
180926,"/** 
 * Handles the change of the accessibility enabled setting state.
 * @param preference The preference for enabling/disabling accessibility.
 */
private void handleEnableAccessibilityStateChange(CheckBoxPreference preference){
  if (preference.isChecked()) {
    Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,1);
    setAccessibilityServicePreferencesState(true);
  }
 else {
    final CheckBoxPreference checkBoxPreference=preference;
    AlertDialog dialog=(new AlertDialog.Builder(this)).setTitle(android.R.string.dialog_alert_title).setIcon(android.R.drawable.ic_dialog_alert).setMessage(getString(R.string.accessibility_service_disable_warning)).setCancelable(true).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
        setAccessibilityServicePreferencesState(false);
      }
    }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        checkBoxPreference.setChecked(true);
      }
    }
).create();
    dialog.show();
  }
}","/** 
 * Handles the change of the accessibility enabled setting state.
 * @param preference The preference for enabling/disabling accessibility.
 */
private void handleEnableAccessibilityStateChange(CheckBoxPreference preference){
  if (preference.isChecked()) {
    Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,1);
  }
 else {
    final CheckBoxPreference checkBoxPreference=preference;
    AlertDialog dialog=(new AlertDialog.Builder(this)).setTitle(android.R.string.dialog_alert_title).setIcon(android.R.drawable.ic_dialog_alert).setMessage(getString(R.string.accessibility_service_disable_warning)).setCancelable(true).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
      }
    }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        checkBoxPreference.setChecked(true);
      }
    }
).create();
    dialog.show();
  }
}",0.956237218813906
180927,"@Override protected void onResume(){
  super.onResume();
  final HashSet<String> enabled=new HashSet<String>();
  String settingValue=Settings.Secure.getString(getContentResolver(),Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
  if (settingValue != null) {
    TextUtils.SimpleStringSplitter splitter=mStringColonSplitter;
    splitter.setString(settingValue);
    while (splitter.hasNext()) {
      enabled.add(splitter.next());
    }
  }
  Map<String,ServiceInfo> accessibilityServices=mAccessibilityServices;
  for (  String key : accessibilityServices.keySet()) {
    CheckBoxPreference preference=(CheckBoxPreference)findPreference(key);
    if (preference != null) {
      preference.setChecked(enabled.contains(key));
    }
  }
  int serviceState=Settings.Secure.getInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
  if (!accessibilityServices.isEmpty()) {
    if (serviceState == 1) {
      mToggleCheckBox.setChecked(true);
    }
 else {
      setAccessibilityServicePreferencesState(false);
    }
    mToggleCheckBox.setEnabled(true);
  }
 else {
    if (serviceState == 1) {
      Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
      setAccessibilityServicePreferencesState(false);
    }
    mToggleCheckBox.setEnabled(false);
    displayNoAppsAlert();
  }
}","@Override protected void onResume(){
  super.onResume();
  final HashSet<String> enabled=new HashSet<String>();
  String settingValue=Settings.Secure.getString(getContentResolver(),Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);
  if (settingValue != null) {
    TextUtils.SimpleStringSplitter splitter=mStringColonSplitter;
    splitter.setString(settingValue);
    while (splitter.hasNext()) {
      enabled.add(splitter.next());
    }
  }
  Map<String,ServiceInfo> accessibilityServices=mAccessibilityServices;
  for (  String key : accessibilityServices.keySet()) {
    CheckBoxPreference preference=(CheckBoxPreference)findPreference(key);
    if (preference != null) {
      preference.setChecked(enabled.contains(key));
    }
  }
  int serviceState=Settings.Secure.getInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
  if (!accessibilityServices.isEmpty()) {
    if (serviceState == 1) {
      mToggleCheckBox.setChecked(true);
    }
    mToggleCheckBox.setEnabled(true);
  }
 else {
    if (serviceState == 1) {
      Settings.Secure.putInt(getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0);
    }
    mToggleCheckBox.setEnabled(false);
    displayNoAppsAlert();
  }
}",0.9518927444794952
180928,"@Override protected void onResume(){
  super.onResume();
  final LockPatternUtils lockPatternUtils=mChooseLockSettingsHelper.utils();
  boolean patternExists=lockPatternUtils.savedPatternExists();
  if (mVisiblePattern != null) {
    mVisiblePattern.setEnabled(patternExists);
    mVisiblePattern.setChecked(lockPatternUtils.isVisiblePatternEnabled());
  }
  if (mTactileFeedback != null) {
    mTactileFeedback.setEnabled(patternExists);
    mTactileFeedback.setChecked(lockPatternUtils.isTactileFeedbackEnabled());
  }
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
  mCredentialStorage.resume();
}","@Override protected void onResume(){
  super.onResume();
  final LockPatternUtils lockPatternUtils=mChooseLockSettingsHelper.utils();
  if (mVisiblePattern != null) {
    mVisiblePattern.setChecked(lockPatternUtils.isVisiblePatternEnabled());
  }
  if (mTactileFeedback != null) {
    mTactileFeedback.setChecked(lockPatternUtils.isTactileFeedbackEnabled());
  }
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
  mCredentialStorage.resume();
}",0.8661016949152542
180929,"/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}","/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}",0.8678839957035446
180930,"public boolean onPreferenceChange(Preference preference,Object objValue){
  if (KEY_TTS_USE_DEFAULT.equals(preference.getKey())) {
    int value=(Boolean)objValue ? 1 : 0;
    Settings.Secure.putInt(getContentResolver(),TTS_USE_DEFAULTS,value);
    Log.i(TAG,""String_Node_Str"" + objValue.toString());
  }
 else   if (KEY_TTS_DEFAULT_RATE.equals(preference.getKey())) {
    mDefaultRate=Integer.parseInt((String)objValue);
    try {
      Settings.Secure.putInt(getContentResolver(),TTS_DEFAULT_RATE,mDefaultRate);
      if (mTts != null) {
        mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
      }
      Log.i(TAG,""String_Node_Str"" + mDefaultRate);
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else   if (KEY_TTS_DEFAULT_LANG.equals(preference.getKey())) {
    ContentResolver resolver=getContentResolver();
    parseLocaleInfo((String)objValue);
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
    Log.v(TAG,""String_Node_Str"" + mDefaultLanguage + ""String_Node_Str""+ mDefaultCountry+ ""String_Node_Str""+ mDefaultLocVariant);
    if (mTts != null) {
      mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry));
    }
    int newIndex=mDefaultLocPref.findIndexOfValue((String)objValue);
    Log.v(""String_Node_Str"",""String_Node_Str"" + newIndex);
    mDemoStringIndex=newIndex > -1 ? newIndex : 0;
  }
 else   if (KEY_TTS_DEFAULT_SYNTH.equals(preference.getKey())) {
    mDefaultEng=objValue.toString();
    Settings.Secure.putString(getContentResolver(),TTS_DEFAULT_SYNTH,mDefaultEng);
    if (mTts != null) {
      mTts.setEngineByPackageName(mDefaultEng);
    }
    Log.v(""String_Node_Str"",""String_Node_Str"" + objValue.toString());
  }
  return true;
}","public boolean onPreferenceChange(Preference preference,Object objValue){
  if (KEY_TTS_USE_DEFAULT.equals(preference.getKey())) {
    int value=(Boolean)objValue ? 1 : 0;
    Settings.Secure.putInt(getContentResolver(),TTS_USE_DEFAULTS,value);
    Log.i(TAG,""String_Node_Str"" + objValue.toString());
  }
 else   if (KEY_TTS_DEFAULT_RATE.equals(preference.getKey())) {
    mDefaultRate=Integer.parseInt((String)objValue);
    try {
      Settings.Secure.putInt(getContentResolver(),TTS_DEFAULT_RATE,mDefaultRate);
      if (mTts != null) {
        mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
      }
      Log.i(TAG,""String_Node_Str"" + mDefaultRate);
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else   if (KEY_TTS_DEFAULT_LANG.equals(preference.getKey())) {
    ContentResolver resolver=getContentResolver();
    parseLocaleInfo((String)objValue);
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
    Log.v(TAG,""String_Node_Str"" + mDefaultLanguage + ""String_Node_Str""+ mDefaultCountry+ ""String_Node_Str""+ mDefaultLocVariant);
    if (mTts != null) {
      mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    }
    int newIndex=mDefaultLocPref.findIndexOfValue((String)objValue);
    Log.v(""String_Node_Str"",""String_Node_Str"" + newIndex);
    mDemoStringIndex=newIndex > -1 ? newIndex : 0;
  }
 else   if (KEY_TTS_DEFAULT_SYNTH.equals(preference.getKey())) {
    mDefaultEng=objValue.toString();
    Settings.Secure.putString(getContentResolver(),TTS_DEFAULT_SYNTH,mDefaultEng);
    if (mTts != null) {
      mTts.setEngineByPackageName(mDefaultEng);
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      checkVoiceData();
    }
    Log.v(""String_Node_Str"",""String_Node_Str"" + objValue.toString());
  }
  return true;
}",0.9686943242555358
180931,"@Override protected void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mHandler=new Handler(getMainLooper());
  mDPM=(DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
  ComponentName cn=(ComponentName)getIntent().getParcelableExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN);
  if (cn == null) {
    Log.w(TAG,""String_Node_Str"" + getIntent().getAction());
    finish();
    return;
  }
  if (DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN.equals(getIntent().getAction())) {
    if (mDPM.isAdminActive(cn)) {
      setResult(Activity.RESULT_OK);
      finish();
      return;
    }
  }
  ActivityInfo ai;
  try {
    ai=getPackageManager().getReceiverInfo(cn,PackageManager.GET_META_DATA);
  }
 catch (  PackageManager.NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
  ResolveInfo ri=new ResolveInfo();
  ri.activityInfo=ai;
  try {
    mDeviceAdmin=new DeviceAdminInfo(this,ri);
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
  mAddMsgText=getIntent().getCharSequenceExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION);
  setContentView(R.layout.device_admin_add);
  mTitle=(TextView)findViewById(R.id.title);
  mAdminIcon=(ImageView)findViewById(R.id.admin_icon);
  mAdminName=(TextView)findViewById(R.id.admin_name);
  mAdminDescription=(TextView)findViewById(R.id.admin_description);
  mAddMsg=(TextView)findViewById(R.id.add_msg);
  mAdminWarning=(TextView)findViewById(R.id.admin_warning);
  mAdminPolicies=(ViewGroup)findViewById(R.id.admin_policies);
  mActionButton=(Button)findViewById(R.id.action_button);
  mActionButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      if (mAdding) {
        mDPM.setActiveAdmin(mDeviceAdmin.getComponent());
        setResult(Activity.RESULT_OK);
        finish();
      }
 else {
        mDPM.getRemoveWarning(mDeviceAdmin.getComponent(),new RemoteCallback(mHandler){
          @Override protected void onResult(          Bundle bundle){
            CharSequence msg=bundle != null ? bundle.getCharSequence(DeviceAdmin.EXTRA_DISABLE_WARNING) : null;
            if (msg == null) {
              mDPM.removeActiveAdmin(mDeviceAdmin.getComponent());
              finish();
            }
 else {
              Bundle args=new Bundle();
              args.putCharSequence(DeviceAdmin.EXTRA_DISABLE_WARNING,msg);
              showDialog(DIALOG_WARNING,args);
            }
          }
        }
);
      }
    }
  }
);
}","@Override protected void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mHandler=new Handler(getMainLooper());
  mDPM=(DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
  ComponentName cn=(ComponentName)getIntent().getParcelableExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN);
  if (cn == null) {
    Log.w(TAG,""String_Node_Str"" + getIntent().getAction());
    finish();
    return;
  }
  if (DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN.equals(getIntent().getAction())) {
    if (mDPM.isAdminActive(cn)) {
      setResult(Activity.RESULT_OK);
      finish();
      return;
    }
  }
  ActivityInfo ai;
  try {
    ai=getPackageManager().getReceiverInfo(cn,PackageManager.GET_META_DATA);
  }
 catch (  PackageManager.NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
  ResolveInfo ri=new ResolveInfo();
  ri.activityInfo=ai;
  try {
    mDeviceAdmin=new DeviceAdminInfo(this,ri);
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + cn,e);
    finish();
    return;
  }
  mAddMsgText=getIntent().getCharSequenceExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION);
  setContentView(R.layout.device_admin_add);
  mTitle=(TextView)findViewById(R.id.title);
  mAdminIcon=(ImageView)findViewById(R.id.admin_icon);
  mAdminName=(TextView)findViewById(R.id.admin_name);
  mAdminDescription=(TextView)findViewById(R.id.admin_description);
  mAddMsg=(TextView)findViewById(R.id.add_msg);
  mAdminWarning=(TextView)findViewById(R.id.admin_warning);
  mAdminPolicies=(ViewGroup)findViewById(R.id.admin_policies);
  mActionButton=(Button)findViewById(R.id.action_button);
  mActionButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      if (mAdding) {
        mDPM.setActiveAdmin(mDeviceAdmin.getComponent());
        setResult(Activity.RESULT_OK);
        finish();
      }
 else {
        mDPM.getRemoveWarning(mDeviceAdmin.getComponent(),new RemoteCallback(mHandler){
          @Override protected void onResult(          Bundle bundle){
            CharSequence msg=bundle != null ? bundle.getCharSequence(DeviceAdminReceiver.EXTRA_DISABLE_WARNING) : null;
            if (msg == null) {
              mDPM.removeActiveAdmin(mDeviceAdmin.getComponent());
              finish();
            }
 else {
              Bundle args=new Bundle();
              args.putCharSequence(DeviceAdminReceiver.EXTRA_DISABLE_WARNING,msg);
              showDialog(DIALOG_WARNING,args);
            }
          }
        }
);
      }
    }
  }
);
}",0.9969742813918304
180932,"@Override protected Dialog onCreateDialog(int id,Bundle args){
switch (id) {
case DIALOG_WARNING:
{
      CharSequence msg=args.getCharSequence(DeviceAdmin.EXTRA_DISABLE_WARNING);
      AlertDialog.Builder builder=new AlertDialog.Builder(DeviceAdminAdd.this);
      builder.setMessage(msg);
      builder.setPositiveButton(R.string.dlg_ok,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          mDPM.removeActiveAdmin(mDeviceAdmin.getComponent());
          finish();
        }
      }
);
      builder.setNegativeButton(R.string.dlg_cancel,null);
      return builder.create();
    }
default :
  return super.onCreateDialog(id,args);
}
}","@Override protected Dialog onCreateDialog(int id,Bundle args){
switch (id) {
case DIALOG_WARNING:
{
      CharSequence msg=args.getCharSequence(DeviceAdminReceiver.EXTRA_DISABLE_WARNING);
      AlertDialog.Builder builder=new AlertDialog.Builder(DeviceAdminAdd.this);
      builder.setMessage(msg);
      builder.setPositiveButton(R.string.dlg_ok,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          mDPM.removeActiveAdmin(mDeviceAdmin.getComponent());
          finish();
        }
      }
);
      builder.setNegativeButton(R.string.dlg_cancel,null);
      return builder.create();
    }
default :
  return super.onCreateDialog(id,args);
}
}",0.9943977591036416
180933,"@Override protected void onResult(Bundle bundle){
  CharSequence msg=bundle != null ? bundle.getCharSequence(DeviceAdmin.EXTRA_DISABLE_WARNING) : null;
  if (msg == null) {
    mDPM.removeActiveAdmin(mDeviceAdmin.getComponent());
    finish();
  }
 else {
    Bundle args=new Bundle();
    args.putCharSequence(DeviceAdmin.EXTRA_DISABLE_WARNING,msg);
    showDialog(DIALOG_WARNING,args);
  }
}","@Override protected void onResult(Bundle bundle){
  CharSequence msg=bundle != null ? bundle.getCharSequence(DeviceAdminReceiver.EXTRA_DISABLE_WARNING) : null;
  if (msg == null) {
    mDPM.removeActiveAdmin(mDeviceAdmin.getComponent());
    finish();
  }
 else {
    Bundle args=new Bundle();
    args.putCharSequence(DeviceAdminReceiver.EXTRA_DISABLE_WARNING,msg);
    showDialog(DIALOG_WARNING,args);
  }
}",0.9800498753117208
180934,"void updateList(){
  mActiveAdmins.clear();
  List<ComponentName> cur=mDPM.getActiveAdmins();
  if (cur != null) {
    for (int i=0; i < cur.size(); i++) {
      mActiveAdmins.add(cur.get(i));
    }
  }
  mAvailableAdmins.clear();
  List<ResolveInfo> avail=getPackageManager().queryBroadcastReceivers(new Intent(DeviceAdmin.ACTION_DEVICE_ADMIN_ENABLED),PackageManager.GET_META_DATA);
  int count=avail == null ? 0 : avail.size();
  for (int i=0; i < count; i++) {
    ResolveInfo ri=avail.get(i);
    try {
      DeviceAdminInfo dpi=new DeviceAdminInfo(this,ri);
      mAvailableAdmins.add(dpi);
    }
 catch (    XmlPullParserException e) {
      Log.w(TAG,""String_Node_Str"" + ri.activityInfo,e);
    }
catch (    IOException e) {
      Log.w(TAG,""String_Node_Str"" + ri.activityInfo,e);
    }
  }
  getListView().setAdapter(new PolicyListAdapter());
}","void updateList(){
  mActiveAdmins.clear();
  List<ComponentName> cur=mDPM.getActiveAdmins();
  if (cur != null) {
    for (int i=0; i < cur.size(); i++) {
      mActiveAdmins.add(cur.get(i));
    }
  }
  mAvailableAdmins.clear();
  List<ResolveInfo> avail=getPackageManager().queryBroadcastReceivers(new Intent(DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED),PackageManager.GET_META_DATA);
  int count=avail == null ? 0 : avail.size();
  for (int i=0; i < count; i++) {
    ResolveInfo ri=avail.get(i);
    try {
      DeviceAdminInfo dpi=new DeviceAdminInfo(this,ri);
      mAvailableAdmins.add(dpi);
    }
 catch (    XmlPullParserException e) {
      Log.w(TAG,""String_Node_Str"" + ri.activityInfo,e);
    }
catch (    IOException e) {
      Log.w(TAG,""String_Node_Str"" + ri.activityInfo,e);
    }
  }
  getListView().setAdapter(new PolicyListAdapter());
}",0.9953271028037384
180935,"/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}","/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    if (mDefaultCountry == null) {
      mDefaultCountry=Locale.getDefault().getISO3Country();
    }
    if (mDefaultLocVariant == null) {
      mDefaultLocVariant=new String();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}",0.851373182552504
180936,"/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}","/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    if (mDefaultCountry == null) {
      mDefaultCountry=Locale.getDefault().getISO3Country();
    }
    if (mDefaultLocVariant == null) {
      mDefaultLocVariant=new String();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}",0.851373182552504
180937,"/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}","/** 
 * Called when the TTS engine is initialized.
 */
public void onInit(int status){
  if (status == TextToSpeech.SUCCESS) {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=true;
    if (mDefaultLanguage == null) {
      mDefaultLanguage=Locale.getDefault().getISO3Language();
    }
    mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    mEnableDemo=false;
  }
  updateWidgetState();
}",0.8678839957035446
180938,"public boolean onPreferenceChange(Preference preference,Object objValue){
  if (KEY_TTS_USE_DEFAULT.equals(preference.getKey())) {
    int value=(Boolean)objValue ? 1 : 0;
    Settings.Secure.putInt(getContentResolver(),TTS_USE_DEFAULTS,value);
    Log.i(TAG,""String_Node_Str"" + objValue.toString());
  }
 else   if (KEY_TTS_DEFAULT_RATE.equals(preference.getKey())) {
    mDefaultRate=Integer.parseInt((String)objValue);
    try {
      Settings.Secure.putInt(getContentResolver(),TTS_DEFAULT_RATE,mDefaultRate);
      if (mTts != null) {
        mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
      }
      Log.i(TAG,""String_Node_Str"" + mDefaultRate);
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else   if (KEY_TTS_DEFAULT_LANG.equals(preference.getKey())) {
    ContentResolver resolver=getContentResolver();
    parseLocaleInfo((String)objValue);
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
    Log.v(TAG,""String_Node_Str"" + mDefaultLanguage + ""String_Node_Str""+ mDefaultCountry+ ""String_Node_Str""+ mDefaultLocVariant);
    if (mTts != null) {
      mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry));
    }
    int newIndex=mDefaultLocPref.findIndexOfValue((String)objValue);
    Log.v(""String_Node_Str"",""String_Node_Str"" + newIndex);
    mDemoStringIndex=newIndex > -1 ? newIndex : 0;
  }
 else   if (KEY_TTS_DEFAULT_SYNTH.equals(preference.getKey())) {
    mDefaultEng=objValue.toString();
    Settings.Secure.putString(getContentResolver(),TTS_DEFAULT_SYNTH,mDefaultEng);
    if (mTts != null) {
      mTts.setEngineByPackageName(mDefaultEng);
    }
    Log.v(""String_Node_Str"",""String_Node_Str"" + objValue.toString());
  }
  return true;
}","public boolean onPreferenceChange(Preference preference,Object objValue){
  if (KEY_TTS_USE_DEFAULT.equals(preference.getKey())) {
    int value=(Boolean)objValue ? 1 : 0;
    Settings.Secure.putInt(getContentResolver(),TTS_USE_DEFAULTS,value);
    Log.i(TAG,""String_Node_Str"" + objValue.toString());
  }
 else   if (KEY_TTS_DEFAULT_RATE.equals(preference.getKey())) {
    mDefaultRate=Integer.parseInt((String)objValue);
    try {
      Settings.Secure.putInt(getContentResolver(),TTS_DEFAULT_RATE,mDefaultRate);
      if (mTts != null) {
        mTts.setSpeechRate((float)(mDefaultRate / 100.0f));
      }
      Log.i(TAG,""String_Node_Str"" + mDefaultRate);
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
 else   if (KEY_TTS_DEFAULT_LANG.equals(preference.getKey())) {
    ContentResolver resolver=getContentResolver();
    parseLocaleInfo((String)objValue);
    Settings.Secure.putString(resolver,TTS_DEFAULT_LANG,mDefaultLanguage);
    Settings.Secure.putString(resolver,TTS_DEFAULT_COUNTRY,mDefaultCountry);
    Settings.Secure.putString(resolver,TTS_DEFAULT_VARIANT,mDefaultLocVariant);
    Log.v(TAG,""String_Node_Str"" + mDefaultLanguage + ""String_Node_Str""+ mDefaultCountry+ ""String_Node_Str""+ mDefaultLocVariant);
    if (mTts != null) {
      mTts.setLanguage(new Locale(mDefaultLanguage,mDefaultCountry,mDefaultLocVariant));
    }
    int newIndex=mDefaultLocPref.findIndexOfValue((String)objValue);
    Log.v(""String_Node_Str"",""String_Node_Str"" + newIndex);
    mDemoStringIndex=newIndex > -1 ? newIndex : 0;
  }
 else   if (KEY_TTS_DEFAULT_SYNTH.equals(preference.getKey())) {
    mDefaultEng=objValue.toString();
    Settings.Secure.putString(getContentResolver(),TTS_DEFAULT_SYNTH,mDefaultEng);
    if (mTts != null) {
      mTts.setEngineByPackageName(mDefaultEng);
      mEnableDemo=false;
      mVoicesMissing=false;
      updateWidgetState();
      checkVoiceData();
    }
    Log.v(""String_Node_Str"",""String_Node_Str"" + objValue.toString());
  }
  return true;
}",0.9686943242555358
180939,"/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  mDefaultLocPref.setValueIndex(mDemoStringIndex);
}","/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  if (mDemoStringIndex > -1) {
    mDefaultLocPref.setValueIndex(mDemoStringIndex);
  }
}",0.976889444097439
180940,"/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  mDefaultLocPref.setValueIndex(mDemoStringIndex);
}","/** 
 * Initialize the default language in the UI and in the preferences. After this method has been invoked, the default language is a supported Locale.
 */
private void initDefaultLang(){
  if (!hasLangPref()) {
    if (isCurrentLocSupported()) {
      useCurrentLocAsDefault();
    }
 else {
      useSupportedLocAsDefault();
    }
  }
  ContentResolver resolver=getContentResolver();
  mDefaultLanguage=Settings.Secure.getString(resolver,TTS_DEFAULT_LANG);
  mDefaultCountry=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_COUNTRY);
  mDefaultLocVariant=Settings.Secure.getString(resolver,KEY_TTS_DEFAULT_VARIANT);
  mDemoStringIndex=mDefaultLocPref.findIndexOfValue(mDefaultLanguage + LOCALE_DELIMITER + mDefaultCountry);
  if (mDemoStringIndex > -1) {
    mDefaultLocPref.setValueIndex(mDemoStringIndex);
  }
}",0.976889444097439
180941,"private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + getDisableBtSetting());
if (getDisableBtSetting()) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeDisableBtSetting();
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mBtManager.getBluetoothAdapter().disable();
removeDisableBtSetting();
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}","private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
}
if (getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED)) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
if (mBtManager.getBluetoothAdapter().disable()) {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
 else {
setSetting(SHARED_PREFERENCES_KEY_DISABLE_BT,true);
mPendingTurnOffStartId=startId;
deferFinishCall=true;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + startId);
}
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}",0.8901032179720705
180942,"private void handleBtStateChange(Intent intent,int startId){
  int btState=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + btState + ""String_Node_Str""+ mPendingDevice);
    if (btState == BluetoothAdapter.STATE_ON) {
      if (mPendingDevice != null) {
        if (mPendingDevice.equals(mDevice)) {
          if (DEBUG)           Log.d(TAG,""String_Node_Str"");
          applyBtSettings(mPendingDevice,mPendingStartId);
        }
 else         if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mPendingDevice + ""String_Node_Str""+ mDevice+ ""String_Node_Str"");
        }
        mPendingDevice=null;
        DockEventReceiver.finishStartingService(mContext,mPendingStartId);
      }
 else {
        Intent i=registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int state=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
            BluetoothDevice device=i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            if (device != null) {
              connectIfEnabled(device);
            }
          }
        }
      }
      if (mPendingTurnOnStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOnStartId);
        mPendingTurnOnStartId=INVALID_STARTID;
      }
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
      removeDisableBtSetting();
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_OFF) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + mPendingDevice);
      if (mPendingDevice != null) {
        mBtManager.getBluetoothAdapter().enable();
        mPendingTurnOnStartId=startId;
      }
 else {
        DockEventReceiver.finishStartingService(this,startId);
      }
    }
  }
}","private void handleBtStateChange(Intent intent,int startId){
  int btState=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + btState + ""String_Node_Str""+ mPendingDevice);
    if (btState == BluetoothAdapter.STATE_ON) {
      if (mPendingDevice != null) {
        if (mPendingDevice.equals(mDevice)) {
          if (DEBUG)           Log.d(TAG,""String_Node_Str"");
          applyBtSettings(mPendingDevice,mPendingStartId);
        }
 else         if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mPendingDevice + ""String_Node_Str""+ mDevice+ ""String_Node_Str"");
        }
        mPendingDevice=null;
        DockEventReceiver.finishStartingService(mContext,mPendingStartId);
      }
 else {
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
        }
        Intent i=registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int state=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
            BluetoothDevice device=i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            if (device != null) {
              connectIfEnabled(device);
            }
          }
 else           if (getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT) && mBtManager.getBluetoothAdapter().disable()) {
            mPendingTurnOffStartId=startId;
            removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
            return;
          }
        }
      }
      if (mPendingTurnOnStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOnStartId);
        mPendingTurnOnStartId=INVALID_STARTID;
      }
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
      removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_OFF) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + mPendingDevice);
      if (mPendingTurnOffStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOffStartId);
        removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
        mPendingTurnOffStartId=INVALID_STARTID;
      }
      if (mPendingDevice != null) {
        mBtManager.getBluetoothAdapter().enable();
        mPendingTurnOnStartId=startId;
      }
 else {
        DockEventReceiver.finishStartingService(this,startId);
      }
    }
  }
}",0.7421891604675876
180943,"private synchronized void applyBtSettings(final BluetoothDevice device,int startId){
  if (device == null || mProfiles == null || mCheckedItems == null)   return;
synchronized (this) {
    for (    boolean enable : mCheckedItems) {
      if (enable) {
        int btState=mBtManager.getBluetoothState();
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + btState);
        mBtManager.getBluetoothAdapter().enable();
switch (btState) {
case BluetoothAdapter.STATE_OFF:
case BluetoothAdapter.STATE_TURNING_OFF:
case BluetoothAdapter.STATE_TURNING_ON:
          if (mPendingDevice != null && mPendingDevice.equals(mDevice)) {
            return;
          }
        mPendingDevice=device;
      mPendingStartId=startId;
    if (btState != BluetoothAdapter.STATE_TURNING_ON) {
      setDisableBtSetting(true);
    }
  return;
}
}
}
}
mPendingDevice=null;
boolean callConnect=false;
CachedBluetoothDevice cachedDevice=getCachedBluetoothDevice(mContext,mBtManager,device);
for (int i=0; i < mProfiles.length; i++) {
LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mBtManager,mProfiles[i]);
if (DEBUG) Log.d(TAG,mProfiles[i].toString() + ""String_Node_Str"" + mCheckedItems[i]);
if (mCheckedItems[i]) {
callConnect=true;
}
 else if (!mCheckedItems[i]) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.disconnect(mProfiles[i]);
}
profileManager.setPreferred(device,mCheckedItems[i]);
if (DEBUG) {
if (mCheckedItems[i] != profileManager.isPreferred(device)) {
Log.e(TAG,""String_Node_Str"");
}
}
}
if (callConnect) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.connect();
}
}","private synchronized void applyBtSettings(final BluetoothDevice device,int startId){
  if (device == null || mProfiles == null || mCheckedItems == null)   return;
synchronized (this) {
    for (    boolean enable : mCheckedItems) {
      if (enable) {
        int btState=mBtManager.getBluetoothState();
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + btState);
        mBtManager.getBluetoothAdapter().enable();
switch (btState) {
case BluetoothAdapter.STATE_OFF:
case BluetoothAdapter.STATE_TURNING_OFF:
case BluetoothAdapter.STATE_TURNING_ON:
          if (mPendingDevice != null && mPendingDevice.equals(mDevice)) {
            return;
          }
        mPendingDevice=device;
      mPendingStartId=startId;
    if (btState != BluetoothAdapter.STATE_TURNING_ON) {
      setSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED,true);
    }
  return;
}
}
}
}
mPendingDevice=null;
boolean callConnect=false;
CachedBluetoothDevice cachedDevice=getCachedBluetoothDevice(mContext,mBtManager,device);
for (int i=0; i < mProfiles.length; i++) {
LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mBtManager,mProfiles[i]);
if (DEBUG) Log.d(TAG,mProfiles[i].toString() + ""String_Node_Str"" + mCheckedItems[i]);
if (mCheckedItems[i]) {
callConnect=true;
}
 else if (!mCheckedItems[i]) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.disconnect(mProfiles[i]);
}
profileManager.setPreferred(device,mCheckedItems[i]);
if (DEBUG) {
if (mCheckedItems[i] != profileManager.isPreferred(device)) {
Log.e(TAG,""String_Node_Str"");
}
}
}
if (callConnect) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.connect();
}
}",0.977845220030349
180944,"private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + getDisableBtSetting());
if (getDisableBtSetting()) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeDisableBtSetting();
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mBtManager.getBluetoothAdapter().disable();
removeDisableBtSetting();
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}","private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
}
if (getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED)) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
if (mBtManager.getBluetoothAdapter().disable()) {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
 else {
setSetting(SHARED_PREFERENCES_KEY_DISABLE_BT,true);
mPendingTurnOffStartId=startId;
deferFinishCall=true;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + startId);
}
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}",0.8901032179720705
180945,"private void handleBtStateChange(Intent intent,int startId){
  int btState=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + btState + ""String_Node_Str""+ mPendingDevice);
    if (btState == BluetoothAdapter.STATE_ON) {
      if (mPendingDevice != null) {
        if (mPendingDevice.equals(mDevice)) {
          if (DEBUG)           Log.d(TAG,""String_Node_Str"");
          applyBtSettings(mPendingDevice,mPendingStartId);
        }
 else         if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mPendingDevice + ""String_Node_Str""+ mDevice+ ""String_Node_Str"");
        }
        mPendingDevice=null;
        DockEventReceiver.finishStartingService(mContext,mPendingStartId);
      }
 else {
        Intent i=registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int state=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
            BluetoothDevice device=i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            if (device != null) {
              connectIfEnabled(device);
            }
          }
        }
      }
      if (mPendingTurnOnStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOnStartId);
        mPendingTurnOnStartId=INVALID_STARTID;
      }
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
      removeDisableBtSetting();
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_OFF) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + mPendingDevice);
      if (mPendingDevice != null) {
        mBtManager.getBluetoothAdapter().enable();
        mPendingTurnOnStartId=startId;
      }
 else {
        DockEventReceiver.finishStartingService(this,startId);
      }
    }
  }
}","private void handleBtStateChange(Intent intent,int startId){
  int btState=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + btState + ""String_Node_Str""+ mPendingDevice);
    if (btState == BluetoothAdapter.STATE_ON) {
      if (mPendingDevice != null) {
        if (mPendingDevice.equals(mDevice)) {
          if (DEBUG)           Log.d(TAG,""String_Node_Str"");
          applyBtSettings(mPendingDevice,mPendingStartId);
        }
 else         if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mPendingDevice + ""String_Node_Str""+ mDevice+ ""String_Node_Str"");
        }
        mPendingDevice=null;
        DockEventReceiver.finishStartingService(mContext,mPendingStartId);
      }
 else {
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
        }
        Intent i=registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int state=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
            BluetoothDevice device=i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            if (device != null) {
              connectIfEnabled(device);
            }
          }
 else           if (getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT) && mBtManager.getBluetoothAdapter().disable()) {
            mPendingTurnOffStartId=startId;
            removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
            return;
          }
        }
      }
      if (mPendingTurnOnStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOnStartId);
        mPendingTurnOnStartId=INVALID_STARTID;
      }
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
      removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_OFF) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + mPendingDevice);
      if (mPendingTurnOffStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOffStartId);
        removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
        mPendingTurnOffStartId=INVALID_STARTID;
      }
      if (mPendingDevice != null) {
        mBtManager.getBluetoothAdapter().enable();
        mPendingTurnOnStartId=startId;
      }
 else {
        DockEventReceiver.finishStartingService(this,startId);
      }
    }
  }
}",0.7421891604675876
180946,"private synchronized void applyBtSettings(final BluetoothDevice device,int startId){
  if (device == null || mProfiles == null || mCheckedItems == null)   return;
synchronized (this) {
    for (    boolean enable : mCheckedItems) {
      if (enable) {
        int btState=mBtManager.getBluetoothState();
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + btState);
        mBtManager.getBluetoothAdapter().enable();
switch (btState) {
case BluetoothAdapter.STATE_OFF:
case BluetoothAdapter.STATE_TURNING_OFF:
case BluetoothAdapter.STATE_TURNING_ON:
          if (mPendingDevice != null && mPendingDevice.equals(mDevice)) {
            return;
          }
        mPendingDevice=device;
      mPendingStartId=startId;
    if (btState != BluetoothAdapter.STATE_TURNING_ON) {
      setDisableBtSetting(true);
    }
  return;
}
}
}
}
mPendingDevice=null;
boolean callConnect=false;
CachedBluetoothDevice cachedDevice=getCachedBluetoothDevice(mContext,mBtManager,device);
for (int i=0; i < mProfiles.length; i++) {
LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mBtManager,mProfiles[i]);
if (DEBUG) Log.d(TAG,mProfiles[i].toString() + ""String_Node_Str"" + mCheckedItems[i]);
if (mCheckedItems[i]) {
callConnect=true;
}
 else if (!mCheckedItems[i]) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.disconnect(mProfiles[i]);
}
profileManager.setPreferred(device,mCheckedItems[i]);
if (DEBUG) {
if (mCheckedItems[i] != profileManager.isPreferred(device)) {
Log.e(TAG,""String_Node_Str"");
}
}
}
if (callConnect) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.connect();
}
}","private synchronized void applyBtSettings(final BluetoothDevice device,int startId){
  if (device == null || mProfiles == null || mCheckedItems == null)   return;
synchronized (this) {
    for (    boolean enable : mCheckedItems) {
      if (enable) {
        int btState=mBtManager.getBluetoothState();
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + btState);
        mBtManager.getBluetoothAdapter().enable();
switch (btState) {
case BluetoothAdapter.STATE_OFF:
case BluetoothAdapter.STATE_TURNING_OFF:
case BluetoothAdapter.STATE_TURNING_ON:
          if (mPendingDevice != null && mPendingDevice.equals(mDevice)) {
            return;
          }
        mPendingDevice=device;
      mPendingStartId=startId;
    if (btState != BluetoothAdapter.STATE_TURNING_ON) {
      setSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED,true);
    }
  return;
}
}
}
}
mPendingDevice=null;
boolean callConnect=false;
CachedBluetoothDevice cachedDevice=getCachedBluetoothDevice(mContext,mBtManager,device);
for (int i=0; i < mProfiles.length; i++) {
LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mBtManager,mProfiles[i]);
if (DEBUG) Log.d(TAG,mProfiles[i].toString() + ""String_Node_Str"" + mCheckedItems[i]);
if (mCheckedItems[i]) {
callConnect=true;
}
 else if (!mCheckedItems[i]) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.disconnect(mProfiles[i]);
}
profileManager.setPreferred(device,mCheckedItems[i]);
if (DEBUG) {
if (mCheckedItems[i] != profileManager.isPreferred(device)) {
Log.e(TAG,""String_Node_Str"");
}
}
}
if (callConnect) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.connect();
}
}",0.977845220030349
180947,"private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + getDisableBtSetting());
if (getDisableBtSetting()) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeDisableBtSetting();
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mBtManager.getBluetoothAdapter().disable();
removeDisableBtSetting();
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}","private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
}
if (getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED)) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
if (mBtManager.getBluetoothAdapter().disable()) {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
 else {
setSetting(SHARED_PREFERENCES_KEY_DISABLE_BT,true);
mPendingTurnOffStartId=startId;
deferFinishCall=true;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + startId);
}
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}",0.8901032179720705
180948,"private void handleBtStateChange(Intent intent,int startId){
  int btState=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + btState + ""String_Node_Str""+ mPendingDevice);
    if (btState == BluetoothAdapter.STATE_ON) {
      if (mPendingDevice != null) {
        if (mPendingDevice.equals(mDevice)) {
          if (DEBUG)           Log.d(TAG,""String_Node_Str"");
          applyBtSettings(mPendingDevice,mPendingStartId);
        }
 else         if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mPendingDevice + ""String_Node_Str""+ mDevice+ ""String_Node_Str"");
        }
        mPendingDevice=null;
        DockEventReceiver.finishStartingService(mContext,mPendingStartId);
      }
 else {
        Intent i=registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int state=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
            BluetoothDevice device=i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            if (device != null) {
              connectIfEnabled(device);
            }
          }
        }
      }
      if (mPendingTurnOnStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOnStartId);
        mPendingTurnOnStartId=INVALID_STARTID;
      }
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
      removeDisableBtSetting();
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_OFF) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + mPendingDevice);
      if (mPendingDevice != null) {
        mBtManager.getBluetoothAdapter().enable();
        mPendingTurnOnStartId=startId;
      }
 else {
        DockEventReceiver.finishStartingService(this,startId);
      }
    }
  }
}","private void handleBtStateChange(Intent intent,int startId){
  int btState=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + btState + ""String_Node_Str""+ mPendingDevice);
    if (btState == BluetoothAdapter.STATE_ON) {
      if (mPendingDevice != null) {
        if (mPendingDevice.equals(mDevice)) {
          if (DEBUG)           Log.d(TAG,""String_Node_Str"");
          applyBtSettings(mPendingDevice,mPendingStartId);
        }
 else         if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mPendingDevice + ""String_Node_Str""+ mDevice+ ""String_Node_Str"");
        }
        mPendingDevice=null;
        DockEventReceiver.finishStartingService(mContext,mPendingStartId);
      }
 else {
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
        }
        Intent i=registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int state=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
            BluetoothDevice device=i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            if (device != null) {
              connectIfEnabled(device);
            }
          }
 else           if (getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT) && mBtManager.getBluetoothAdapter().disable()) {
            mPendingTurnOffStartId=startId;
            removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
            return;
          }
        }
      }
      if (mPendingTurnOnStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOnStartId);
        mPendingTurnOnStartId=INVALID_STARTID;
      }
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
      removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_OFF) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + mPendingDevice);
      if (mPendingTurnOffStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOffStartId);
        removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
        mPendingTurnOffStartId=INVALID_STARTID;
      }
      if (mPendingDevice != null) {
        mBtManager.getBluetoothAdapter().enable();
        mPendingTurnOnStartId=startId;
      }
 else {
        DockEventReceiver.finishStartingService(this,startId);
      }
    }
  }
}",0.7421891604675876
180949,"private synchronized void applyBtSettings(final BluetoothDevice device,int startId){
  if (device == null || mProfiles == null || mCheckedItems == null)   return;
synchronized (this) {
    for (    boolean enable : mCheckedItems) {
      if (enable) {
        int btState=mBtManager.getBluetoothState();
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + btState);
        mBtManager.getBluetoothAdapter().enable();
switch (btState) {
case BluetoothAdapter.STATE_OFF:
case BluetoothAdapter.STATE_TURNING_OFF:
case BluetoothAdapter.STATE_TURNING_ON:
          if (mPendingDevice != null && mPendingDevice.equals(mDevice)) {
            return;
          }
        mPendingDevice=device;
      mPendingStartId=startId;
    if (btState != BluetoothAdapter.STATE_TURNING_ON) {
      setDisableBtSetting(true);
    }
  return;
}
}
}
}
mPendingDevice=null;
boolean callConnect=false;
CachedBluetoothDevice cachedDevice=getCachedBluetoothDevice(mContext,mBtManager,device);
for (int i=0; i < mProfiles.length; i++) {
LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mBtManager,mProfiles[i]);
if (DEBUG) Log.d(TAG,mProfiles[i].toString() + ""String_Node_Str"" + mCheckedItems[i]);
if (mCheckedItems[i]) {
callConnect=true;
}
 else if (!mCheckedItems[i]) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.disconnect(mProfiles[i]);
}
profileManager.setPreferred(device,mCheckedItems[i]);
if (DEBUG) {
if (mCheckedItems[i] != profileManager.isPreferred(device)) {
Log.e(TAG,""String_Node_Str"");
}
}
}
if (callConnect) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.connect();
}
}","private synchronized void applyBtSettings(final BluetoothDevice device,int startId){
  if (device == null || mProfiles == null || mCheckedItems == null)   return;
synchronized (this) {
    for (    boolean enable : mCheckedItems) {
      if (enable) {
        int btState=mBtManager.getBluetoothState();
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + btState);
        mBtManager.getBluetoothAdapter().enable();
switch (btState) {
case BluetoothAdapter.STATE_OFF:
case BluetoothAdapter.STATE_TURNING_OFF:
case BluetoothAdapter.STATE_TURNING_ON:
          if (mPendingDevice != null && mPendingDevice.equals(mDevice)) {
            return;
          }
        mPendingDevice=device;
      mPendingStartId=startId;
    if (btState != BluetoothAdapter.STATE_TURNING_ON) {
      setSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED,true);
    }
  return;
}
}
}
}
mPendingDevice=null;
boolean callConnect=false;
CachedBluetoothDevice cachedDevice=getCachedBluetoothDevice(mContext,mBtManager,device);
for (int i=0; i < mProfiles.length; i++) {
LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mBtManager,mProfiles[i]);
if (DEBUG) Log.d(TAG,mProfiles[i].toString() + ""String_Node_Str"" + mCheckedItems[i]);
if (mCheckedItems[i]) {
callConnect=true;
}
 else if (!mCheckedItems[i]) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.disconnect(mProfiles[i]);
}
profileManager.setPreferred(device,mCheckedItems[i]);
if (DEBUG) {
if (mCheckedItems[i] != profileManager.isPreferred(device)) {
Log.e(TAG,""String_Node_Str"");
}
}
}
if (callConnect) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.connect();
}
}",0.977845220030349
180950,"private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + getDisableBtSetting());
if (getDisableBtSetting()) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeDisableBtSetting();
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mBtManager.getBluetoothAdapter().disable();
removeDisableBtSetting();
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}","private synchronized void processMessage(Message msg){
  int msgType=msg.what;
  int state=msg.arg1;
  int startId=msg.arg2;
  boolean deferFinishCall=false;
  BluetoothDevice device=null;
  if (msg.obj != null) {
    device=(BluetoothDevice)msg.obj;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + msgType + ""String_Node_Str""+ state+ ""String_Node_Str""+ (device == null ? ""String_Node_Str"" : device.toString()));
switch (msgType) {
case MSG_TYPE_SHOW_UI:
    if (mDialog != null) {
      mDialog.dismiss();
      mDialog=null;
    }
  mDevice=device;
createDialog(mContext,mDevice,state,startId);
break;
case MSG_TYPE_DOCKED:
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,mDevice));
Log.d(TAG,""String_Node_Str"" + mServiceHandler.hasMessages(MSG_TYPE_UNDOCKED_PERMANENT,device));
}
mServiceHandler.removeMessages(MSG_TYPE_UNDOCKED_PERMANENT);
mServiceHandler.removeMessages(MSG_TYPE_DISABLE_BT);
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
if (!device.equals(mDevice)) {
if (mDevice != null) {
handleUndocked(mContext,mBtManager,mDevice);
}
mDevice=device;
if (mBtManager.getDockAutoConnectSetting(device.getAddress())) {
initBtSettings(mContext,device,state,false);
applyBtSettings(mDevice,startId);
}
 else {
createDialog(mContext,mDevice,state,startId);
}
}
break;
case MSG_TYPE_UNDOCKED_PERMANENT:
handleUndocked(mContext,mBtManager,device);
if (DEBUG) {
Log.d(TAG,""String_Node_Str"" + getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
}
if (getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED)) {
if (!hasOtherConnectedDevices(device)) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_DISABLE_BT,0,startId,null);
mServiceHandler.sendMessageDelayed(newMsg,DISABLE_BT_GRACE_PERIOD);
deferFinishCall=true;
}
 else {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
}
break;
case MSG_TYPE_UNDOCKED_TEMPORARY:
Message newMsg=mServiceHandler.obtainMessage(MSG_TYPE_UNDOCKED_PERMANENT,state,startId,device);
mServiceHandler.sendMessageDelayed(newMsg,UNDOCKED_GRACE_PERIOD);
break;
case MSG_TYPE_DISABLE_BT:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
if (mBtManager.getBluetoothAdapter().disable()) {
removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
}
 else {
setSetting(SHARED_PREFERENCES_KEY_DISABLE_BT,true);
mPendingTurnOffStartId=startId;
deferFinishCall=true;
if (DEBUG) Log.d(TAG,""String_Node_Str"" + startId);
}
break;
}
if (mDialog == null && mPendingDevice == null && msgType != MSG_TYPE_UNDOCKED_TEMPORARY && !deferFinishCall) {
DockEventReceiver.finishStartingService(DockService.this,startId);
}
}",0.8901032179720705
180951,"private void handleBtStateChange(Intent intent,int startId){
  int btState=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + btState + ""String_Node_Str""+ mPendingDevice);
    if (btState == BluetoothAdapter.STATE_ON) {
      if (mPendingDevice != null) {
        if (mPendingDevice.equals(mDevice)) {
          if (DEBUG)           Log.d(TAG,""String_Node_Str"");
          applyBtSettings(mPendingDevice,mPendingStartId);
        }
 else         if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mPendingDevice + ""String_Node_Str""+ mDevice+ ""String_Node_Str"");
        }
        mPendingDevice=null;
        DockEventReceiver.finishStartingService(mContext,mPendingStartId);
      }
 else {
        Intent i=registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int state=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
            BluetoothDevice device=i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            if (device != null) {
              connectIfEnabled(device);
            }
          }
        }
      }
      if (mPendingTurnOnStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOnStartId);
        mPendingTurnOnStartId=INVALID_STARTID;
      }
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
      removeDisableBtSetting();
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_OFF) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + mPendingDevice);
      if (mPendingDevice != null) {
        mBtManager.getBluetoothAdapter().enable();
        mPendingTurnOnStartId=startId;
      }
 else {
        DockEventReceiver.finishStartingService(this,startId);
      }
    }
  }
}","private void handleBtStateChange(Intent intent,int startId){
  int btState=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + btState + ""String_Node_Str""+ mPendingDevice);
    if (btState == BluetoothAdapter.STATE_ON) {
      if (mPendingDevice != null) {
        if (mPendingDevice.equals(mDevice)) {
          if (DEBUG)           Log.d(TAG,""String_Node_Str"");
          applyBtSettings(mPendingDevice,mPendingStartId);
        }
 else         if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + mPendingDevice + ""String_Node_Str""+ mDevice+ ""String_Node_Str"");
        }
        mPendingDevice=null;
        DockEventReceiver.finishStartingService(mContext,mPendingStartId);
      }
 else {
        if (DEBUG) {
          Log.d(TAG,""String_Node_Str"" + getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED));
        }
        Intent i=registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int state=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          if (state != Intent.EXTRA_DOCK_STATE_UNDOCKED) {
            BluetoothDevice device=i.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            if (device != null) {
              connectIfEnabled(device);
            }
          }
 else           if (getSetting(SHARED_PREFERENCES_KEY_DISABLE_BT) && mBtManager.getBluetoothAdapter().disable()) {
            mPendingTurnOffStartId=startId;
            removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
            return;
          }
        }
      }
      if (mPendingTurnOnStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOnStartId);
        mPendingTurnOnStartId=INVALID_STARTID;
      }
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_TURNING_OFF) {
      removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED);
      DockEventReceiver.finishStartingService(this,startId);
    }
 else     if (btState == BluetoothAdapter.STATE_OFF) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + mPendingDevice);
      if (mPendingTurnOffStartId != INVALID_STARTID) {
        DockEventReceiver.finishStartingService(this,mPendingTurnOffStartId);
        removeSetting(SHARED_PREFERENCES_KEY_DISABLE_BT);
        mPendingTurnOffStartId=INVALID_STARTID;
      }
      if (mPendingDevice != null) {
        mBtManager.getBluetoothAdapter().enable();
        mPendingTurnOnStartId=startId;
      }
 else {
        DockEventReceiver.finishStartingService(this,startId);
      }
    }
  }
}",0.7421891604675876
180952,"private synchronized void applyBtSettings(final BluetoothDevice device,int startId){
  if (device == null || mProfiles == null || mCheckedItems == null)   return;
synchronized (this) {
    for (    boolean enable : mCheckedItems) {
      if (enable) {
        int btState=mBtManager.getBluetoothState();
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + btState);
        mBtManager.getBluetoothAdapter().enable();
switch (btState) {
case BluetoothAdapter.STATE_OFF:
case BluetoothAdapter.STATE_TURNING_OFF:
case BluetoothAdapter.STATE_TURNING_ON:
          if (mPendingDevice != null && mPendingDevice.equals(mDevice)) {
            return;
          }
        mPendingDevice=device;
      mPendingStartId=startId;
    if (btState != BluetoothAdapter.STATE_TURNING_ON) {
      setDisableBtSetting(true);
    }
  return;
}
}
}
}
mPendingDevice=null;
boolean callConnect=false;
CachedBluetoothDevice cachedDevice=getCachedBluetoothDevice(mContext,mBtManager,device);
for (int i=0; i < mProfiles.length; i++) {
LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mBtManager,mProfiles[i]);
if (DEBUG) Log.d(TAG,mProfiles[i].toString() + ""String_Node_Str"" + mCheckedItems[i]);
if (mCheckedItems[i]) {
callConnect=true;
}
 else if (!mCheckedItems[i]) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.disconnect(mProfiles[i]);
}
profileManager.setPreferred(device,mCheckedItems[i]);
if (DEBUG) {
if (mCheckedItems[i] != profileManager.isPreferred(device)) {
Log.e(TAG,""String_Node_Str"");
}
}
}
if (callConnect) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.connect();
}
}","private synchronized void applyBtSettings(final BluetoothDevice device,int startId){
  if (device == null || mProfiles == null || mCheckedItems == null)   return;
synchronized (this) {
    for (    boolean enable : mCheckedItems) {
      if (enable) {
        int btState=mBtManager.getBluetoothState();
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + btState);
        mBtManager.getBluetoothAdapter().enable();
switch (btState) {
case BluetoothAdapter.STATE_OFF:
case BluetoothAdapter.STATE_TURNING_OFF:
case BluetoothAdapter.STATE_TURNING_ON:
          if (mPendingDevice != null && mPendingDevice.equals(mDevice)) {
            return;
          }
        mPendingDevice=device;
      mPendingStartId=startId;
    if (btState != BluetoothAdapter.STATE_TURNING_ON) {
      setSetting(SHARED_PREFERENCES_KEY_DISABLE_BT_WHEN_UNDOCKED,true);
    }
  return;
}
}
}
}
mPendingDevice=null;
boolean callConnect=false;
CachedBluetoothDevice cachedDevice=getCachedBluetoothDevice(mContext,mBtManager,device);
for (int i=0; i < mProfiles.length; i++) {
LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mBtManager,mProfiles[i]);
if (DEBUG) Log.d(TAG,mProfiles[i].toString() + ""String_Node_Str"" + mCheckedItems[i]);
if (mCheckedItems[i]) {
callConnect=true;
}
 else if (!mCheckedItems[i]) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.disconnect(mProfiles[i]);
}
profileManager.setPreferred(device,mCheckedItems[i]);
if (DEBUG) {
if (mCheckedItems[i] != profileManager.isPreferred(device)) {
Log.e(TAG,""String_Node_Str"");
}
}
}
if (callConnect) {
if (DEBUG) Log.d(TAG,""String_Node_Str"");
cachedDevice.connect();
}
}",0.977845220030349
180953,"private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}","private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        disconnectConnected(profile);
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}",0.9752604166666666
180954,"private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}","private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      disconnectConnected(profile);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}",0.9609544468546638
180955,"public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}","public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  disconnectConnected(profile);
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}",0.9252336448598132
180956,"private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}","private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        disconnectConnected(profile);
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}",0.9752604166666666
180957,"private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}","private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      disconnectConnected(profile);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}",0.9609544468546638
180958,"public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}","public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  disconnectConnected(profile);
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}",0.9252336448598132
180959,"private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}","private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        disconnectConnected(profile);
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}",0.9752604166666666
180960,"private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}","private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      disconnectConnected(profile);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}",0.9609544468546638
180961,"public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}","public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  disconnectConnected(profile);
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}",0.9252336448598132
180962,"private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}","private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        disconnectConnected(profile);
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}",0.9752604166666666
180963,"private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}","private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      disconnectConnected(profile);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}",0.9609544468546638
180964,"public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}","public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  disconnectConnected(profile);
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}",0.9252336448598132
180965,"private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}","private void connectWithoutResettingTimer(){
  if (mProfiles.size() == 0) {
    if (!updateProfiles()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  mIsConnectingErrorPossible=true;
  int preferredProfiles=0;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      if (profileManager.isPreferred(mDevice)) {
        ++preferredProfiles;
        disconnectConnected(profile);
        queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
      }
    }
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + preferredProfiles);
  if (preferredProfiles == 0) {
    connectAllProfiles();
  }
}",0.9752604166666666
180966,"private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}","private void connectAllProfiles(){
  if (!ensurePaired())   return;
  mIsConnectingErrorPossible=true;
  for (  Profile profile : mProfiles) {
    if (isConnectableProfile(profile)) {
      LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
      profileManager.setPreferred(mDevice,false);
      disconnectConnected(profile);
      queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
    }
  }
}",0.9609544468546638
180967,"public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}","public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  disconnectConnected(profile);
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}",0.9252336448598132
180968,"@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,0);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}","@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}",0.9552572706935124
180969,"@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,0);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}","@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}",0.9552572706935124
180970,"@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,0);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}","@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}",0.9552572706935124
180971,"@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,0);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}","@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}",0.9552572706935124
180972,"@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,0);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}","@Override public void onStart(){
  super.onStart();
  PackageInfo pkgInfo;
  try {
    mAppInfo=mPm.getApplicationInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
    pkgInfo=mPm.getPackageInfo(mAppInfo.packageName,PackageManager.GET_UNINSTALLED_PACKAGES);
  }
 catch (  NameNotFoundException e) {
    Log.e(TAG,""String_Node_Str"" + mAppInfo.packageName,e);
    showDialogInner(DLG_APP_NOT_FOUND);
    return;
  }
  refreshAppAttributes(pkgInfo);
}",0.9552572706935124
180973,"private void showCstorDialog(int dialogId){
  mDialogId=dialogId;
  showDialog(dialogId);
}","private void showCstorDialog(int dialogId){
  mDialogId=dialogId;
  mRetry=false;
  showDialog(dialogId);
}",0.9191919191919192
180974,"public void onDismiss(DialogInterface dialog){
  if (mRetry) {
    showCstorDialog(mDialogId);
  }
 else {
    removeDialog(mDialogId);
    if (mExternalIntent != null) {
      finish();
    }
  }
}","public void onDismiss(DialogInterface dialog){
  if (mRetry) {
    showCstorDialog(mDialogId);
  }
 else {
    removeDialog(mDialogId);
    updatePreferences(mState);
    if (mExternalIntent != null) {
      finish();
    }
  }
}",0.927400468384075
180975,"@Override protected void onResume(){
  super.onResume();
  boolean patternExists=mLockPatternUtils.savedPatternExists();
  mLockEnabled.setEnabled(patternExists);
  mVisiblePattern.setEnabled(patternExists);
  mTactileFeedback.setEnabled(patternExists);
  mLockEnabled.setChecked(mLockPatternUtils.isLockPatternEnabled());
  mVisiblePattern.setChecked(mLockPatternUtils.isVisiblePatternEnabled());
  mTactileFeedback.setChecked(mLockPatternUtils.isTactileFeedbackEnabled());
  int chooseStringRes=mLockPatternUtils.savedPatternExists() ? R.string.lockpattern_settings_change_lock_pattern : R.string.lockpattern_settings_choose_lock_pattern;
  mChoosePattern.setTitle(chooseStringRes);
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
}","@Override protected void onResume(){
  super.onResume();
  boolean patternExists=mLockPatternUtils.savedPatternExists();
  mLockEnabled.setEnabled(patternExists);
  mVisiblePattern.setEnabled(patternExists);
  mTactileFeedback.setEnabled(patternExists);
  mLockEnabled.setChecked(mLockPatternUtils.isLockPatternEnabled());
  mVisiblePattern.setChecked(mLockPatternUtils.isVisiblePatternEnabled());
  mTactileFeedback.setChecked(mLockPatternUtils.isTactileFeedbackEnabled());
  int chooseStringRes=mLockPatternUtils.savedPatternExists() ? R.string.lockpattern_settings_change_lock_pattern : R.string.lockpattern_settings_choose_lock_pattern;
  mChoosePattern.setTitle(chooseStringRes);
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
  mCstorHelper.resume();
}",0.9846531614487416
180976,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  String userSafetylegalUrl=SystemProperties.get(PROPERTY_LSAFETYLEGAL_URL);
  final Configuration configuration=getResources().getConfiguration();
  final String language=configuration.locale.getLanguage();
  final String country=configuration.locale.getCountry();
  String loc=String.format(""String_Node_Str"",language,country);
  userSafetylegalUrl=String.format(""String_Node_Str"",userSafetylegalUrl,loc);
  if (!isDataNetworkConnected()) {
    showErrorAndFinish(userSafetylegalUrl);
    return;
  }
  WebView webView=new WebView(this);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.loadUrl(userSafetylegalUrl);
  webView.setWebViewClient(new WebViewClient(){
    @Override public void onPageFinished(    WebView view,    String url){
      mAlert.setTitle(getString(R.string.settings_safetylegal_activity_title));
    }
  }
);
  final AlertController.AlertParams p=mAlertParams;
  p.mTitle=getString(R.string.settings_safetylegal_activity_loading);
  p.mView=webView;
  p.mForceInverseBackground=true;
  setupAlert();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  String userSafetylegalUrl=SystemProperties.get(PROPERTY_LSAFETYLEGAL_URL);
  final Configuration configuration=getResources().getConfiguration();
  final String language=configuration.locale.getLanguage();
  final String country=configuration.locale.getCountry();
  String loc=String.format(""String_Node_Str"",language,country);
  userSafetylegalUrl=String.format(""String_Node_Str"",userSafetylegalUrl,loc);
  mWebView=new WebView(this);
  mWebView.getSettings().setJavaScriptEnabled(true);
  mWebView.loadUrl(userSafetylegalUrl);
  mWebView.setWebViewClient(new WebViewClient(){
    @Override public void onPageFinished(    WebView view,    String url){
      mAlert.setTitle(getString(R.string.settings_safetylegal_activity_title));
    }
    @Override public void onReceivedError(    WebView view,    int errorCode,    String description,    String failingUrl){
      showErrorAndFinish(failingUrl);
    }
  }
);
  final AlertController.AlertParams p=mAlertParams;
  p.mTitle=getString(R.string.settings_safetylegal_activity_loading);
  p.mView=mWebView;
  p.mForceInverseBackground=true;
  setupAlert();
}",0.6422487223168655
180977,"private void showErrorAndFinish(String url){
  new AlertDialog.Builder(this).setMessage(getResources().getString(R.string.settings_safetylegal_activity_unreachable,url)).setTitle(R.string.settings_safetylegal_activity_title).setPositiveButton(android.R.string.ok,mOkListener).setCancelable(true).show();
}","private void showErrorAndFinish(String url){
  new AlertDialog.Builder(this).setMessage(getResources().getString(R.string.settings_safetylegal_activity_unreachable,url)).setTitle(R.string.settings_safetylegal_activity_title).setPositiveButton(android.R.string.ok,this).setOnCancelListener(this).setCancelable(true).show();
}",0.9634340222575516
180978,"@Override public void onReceive(Context context,Intent intent){
  Log.v(TAG,""String_Node_Str"" + intent.getAction());
  String action=intent.getAction();
  BluetoothDevice device=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
  if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
    mManager.setBluetoothStateInt(state);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED)) {
    mManager.onScanningStateChanged(true);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {
    mManager.onScanningStateChanged(false);
  }
 else   if (action.equals(BluetoothDevice.ACTION_FOUND)) {
    short rssi=intent.getShortExtra(BluetoothDevice.EXTRA_RSSI,Short.MIN_VALUE);
    BluetoothClass btClass=intent.getParcelableExtra(BluetoothDevice.EXTRA_CLASS);
    String name=intent.getStringExtra(BluetoothDevice.EXTRA_NAME);
    mManager.getCachedDeviceManager().onDeviceAppeared(device,rssi,btClass,name);
  }
 else   if (action.equals(BluetoothDevice.ACTION_DISAPPEARED)) {
    mManager.getCachedDeviceManager().onDeviceDisappeared(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_NAME_CHANGED)) {
    mManager.getCachedDeviceManager().onDeviceNameUpdated(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) {
    int bondState=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
    mManager.getCachedDeviceManager().onBondingStateChanged(device,bondState);
    if (bondState == BluetoothDevice.BOND_NONE) {
      int reason=intent.getIntExtra(BluetoothDevice.EXTRA_REASON,BluetoothDevice.ERROR);
      mManager.getCachedDeviceManager().onBondingError(device,reason);
    }
  }
 else   if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
    int newState=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,0);
    int oldState=intent.getIntExtra(BluetoothHeadset.EXTRA_PREVIOUS_STATE,0);
    if (newState == BluetoothHeadset.STATE_DISCONNECTED && oldState == BluetoothHeadset.STATE_CONNECTING) {
      Log.i(TAG,""String_Node_Str"");
    }
    mManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.HEADSET,newState);
  }
 else   if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int newState=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,0);
    int oldState=intent.getIntExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,0);
    if (newState == BluetoothA2dp.STATE_DISCONNECTED && oldState == BluetoothA2dp.STATE_CONNECTING) {
      Log.i(TAG,""String_Node_Str"");
    }
    mManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.A2DP,newState);
  }
 else   if (action.equals(BluetoothDevice.ACTION_CLASS_CHANGED)) {
    mManager.getCachedDeviceManager().onBtClassChanged(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_UUID)) {
    mManager.getCachedDeviceManager().onUuidChanged(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_PAIRING_CANCEL)) {
    int errorMsg=R.string.bluetooth_pairing_error_message;
    mManager.showError(device,R.string.bluetooth_error_title,errorMsg);
  }
}","@Override public void onReceive(Context context,Intent intent){
  Log.v(TAG,""String_Node_Str"" + intent.getAction());
  String action=intent.getAction();
  BluetoothDevice device=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
  if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
    mManager.setBluetoothStateInt(state);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED)) {
    mManager.onScanningStateChanged(true);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {
    mManager.onScanningStateChanged(false);
  }
 else   if (action.equals(BluetoothDevice.ACTION_FOUND)) {
    short rssi=intent.getShortExtra(BluetoothDevice.EXTRA_RSSI,Short.MIN_VALUE);
    BluetoothClass btClass=intent.getParcelableExtra(BluetoothDevice.EXTRA_CLASS);
    String name=intent.getStringExtra(BluetoothDevice.EXTRA_NAME);
    mManager.getCachedDeviceManager().onDeviceAppeared(device,rssi,btClass,name);
  }
 else   if (action.equals(BluetoothDevice.ACTION_DISAPPEARED)) {
    mManager.getCachedDeviceManager().onDeviceDisappeared(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_NAME_CHANGED)) {
    mManager.getCachedDeviceManager().onDeviceNameUpdated(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) {
    int bondState=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
    mManager.getCachedDeviceManager().onBondingStateChanged(device,bondState);
    if (bondState == BluetoothDevice.BOND_NONE) {
      int reason=intent.getIntExtra(BluetoothDevice.EXTRA_REASON,BluetoothDevice.ERROR);
      mManager.getCachedDeviceManager().showUnbondMessage(device,reason);
    }
  }
 else   if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
    int newState=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,0);
    int oldState=intent.getIntExtra(BluetoothHeadset.EXTRA_PREVIOUS_STATE,0);
    if (newState == BluetoothHeadset.STATE_DISCONNECTED && oldState == BluetoothHeadset.STATE_CONNECTING) {
      Log.i(TAG,""String_Node_Str"");
    }
    mManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.HEADSET,newState);
  }
 else   if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int newState=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,0);
    int oldState=intent.getIntExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,0);
    if (newState == BluetoothA2dp.STATE_DISCONNECTED && oldState == BluetoothA2dp.STATE_CONNECTING) {
      Log.i(TAG,""String_Node_Str"");
    }
    mManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.A2DP,newState);
  }
 else   if (action.equals(BluetoothDevice.ACTION_CLASS_CHANGED)) {
    mManager.getCachedDeviceManager().onBtClassChanged(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_UUID)) {
    mManager.getCachedDeviceManager().onUuidChanged(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_PAIRING_CANCEL)) {
    int errorMsg=R.string.bluetooth_pairing_error_message;
    mManager.showError(device,R.string.bluetooth_error_title,errorMsg);
  }
}",0.9951111812017032
180979,"private void fetchName(){
  mName=mDevice.getName();
  if (TextUtils.isEmpty(mName)) {
    mName=mDevice.getAddress();
  }
}","private void fetchName(){
  mName=mDevice.getName();
  if (TextUtils.isEmpty(mName)) {
    mName=mDevice.getAddress();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + mName);
  }
}",0.8131147540983606
180980,"public void connect(Profile profile){
  mIsConnectingErrorPossible=true;
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}","public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}",0.8521739130434782
180981,"private boolean connectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  if (!cachedDevice.ensurePaired())   return false;
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (!SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.connect(cachedDevice.mDevice)) {
      return true;
    }
    Log.i(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ cachedDevice.mName);
  }
  Log.i(TAG,""String_Node_Str"");
  return false;
}","private boolean connectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  if (!cachedDevice.ensurePaired())   return false;
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (!SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.connect(cachedDevice.mDevice)) {
      return true;
    }
    Log.i(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ cachedDevice.mName);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  return false;
}",0.988691437802908
180982,"/** 
 * Refreshes the UI when framework alerts us of a UUID change.
 */
public void onUuidChanged(){
  updateProfiles();
  if (DEBUG)   Log.e(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mConnectAttemptedWithoutUuid));
  if (mProfiles.size() > 0 && (mConnectAttemptedWithoutUuid + MAX_UUID_DELAY_FOR_AUTO_CONNECT) > SystemClock.elapsedRealtime()) {
    connect();
  }
  dispatchAttributesChanged();
}","/** 
 * Refreshes the UI when framework alerts us of a UUID change.
 */
public void onUuidChanged(){
  updateProfiles();
  if (DEBUG) {
    Log.e(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mConnectAttempted));
  }
  if (mProfiles.size() > 0 && (mConnectAttempted + MAX_UUID_DELAY_FOR_AUTO_CONNECT) > SystemClock.elapsedRealtime()) {
    connectWithoutResettingTimer();
  }
  dispatchAttributesChanged();
}",0.9386281588447654
180983,"public synchronized void onBondingStateChanged(BluetoothDevice device,int bondState){
  CachedBluetoothDevice cachedDevice=findDevice(device);
  if (cachedDevice == null) {
    if (!readPairedDevices()) {
      Log.e(TAG,""String_Node_Str"" + device + ""String_Node_Str"");
    }
    return;
  }
  cachedDevice.refresh();
  if (bondState == BluetoothDevice.BOND_BONDED) {
    cachedDevice.connect();
  }
}","public synchronized void onBondingStateChanged(BluetoothDevice device,int bondState){
  CachedBluetoothDevice cachedDevice=findDevice(device);
  if (cachedDevice == null) {
    if (!readPairedDevices()) {
      Log.e(TAG,""String_Node_Str"" + device + ""String_Node_Str"");
    }
    return;
  }
  cachedDevice.onBondingStateChanged(bondState);
  if (bondState == BluetoothDevice.BOND_BONDED) {
    cachedDevice.connect();
  }
}",0.9527272727272728
180984,"private void showCstorDialog(int dialogId){
  mDialogId=dialogId;
  showDialog(dialogId);
}","private void showCstorDialog(int dialogId){
  mDialogId=dialogId;
  mRetry=false;
  showDialog(dialogId);
}",0.9191919191919192
180985,"public void onDismiss(DialogInterface dialog){
  if (mRetry) {
    showCstorDialog(mDialogId);
  }
 else {
    removeDialog(mDialogId);
    if (mExternalIntent != null) {
      finish();
    }
  }
}","public void onDismiss(DialogInterface dialog){
  if (mRetry) {
    showCstorDialog(mDialogId);
  }
 else {
    removeDialog(mDialogId);
    updatePreferences(mState);
    if (mExternalIntent != null) {
      finish();
    }
  }
}",0.927400468384075
180986,"@Override protected void onResume(){
  super.onResume();
  boolean patternExists=mLockPatternUtils.savedPatternExists();
  mLockEnabled.setEnabled(patternExists);
  mVisiblePattern.setEnabled(patternExists);
  mTactileFeedback.setEnabled(patternExists);
  mLockEnabled.setChecked(mLockPatternUtils.isLockPatternEnabled());
  mVisiblePattern.setChecked(mLockPatternUtils.isVisiblePatternEnabled());
  mTactileFeedback.setChecked(mLockPatternUtils.isTactileFeedbackEnabled());
  int chooseStringRes=mLockPatternUtils.savedPatternExists() ? R.string.lockpattern_settings_change_lock_pattern : R.string.lockpattern_settings_choose_lock_pattern;
  mChoosePattern.setTitle(chooseStringRes);
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
}","@Override protected void onResume(){
  super.onResume();
  boolean patternExists=mLockPatternUtils.savedPatternExists();
  mLockEnabled.setEnabled(patternExists);
  mVisiblePattern.setEnabled(patternExists);
  mTactileFeedback.setEnabled(patternExists);
  mLockEnabled.setChecked(mLockPatternUtils.isLockPatternEnabled());
  mVisiblePattern.setChecked(mLockPatternUtils.isVisiblePatternEnabled());
  mTactileFeedback.setChecked(mLockPatternUtils.isTactileFeedbackEnabled());
  int chooseStringRes=mLockPatternUtils.savedPatternExists() ? R.string.lockpattern_settings_change_lock_pattern : R.string.lockpattern_settings_choose_lock_pattern;
  mChoosePattern.setTitle(chooseStringRes);
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
  mCstorHelper.resume();
}",0.9846531614487416
180987,"private void showCstorDialog(int dialogId){
  mDialogId=dialogId;
  showDialog(dialogId);
}","private void showCstorDialog(int dialogId){
  mDialogId=dialogId;
  mRetry=false;
  showDialog(dialogId);
}",0.9191919191919192
180988,"public void onDismiss(DialogInterface dialog){
  if (mRetry) {
    showCstorDialog(mDialogId);
  }
 else {
    removeDialog(mDialogId);
    if (mExternalIntent != null) {
      finish();
    }
  }
}","public void onDismiss(DialogInterface dialog){
  if (mRetry) {
    showCstorDialog(mDialogId);
  }
 else {
    removeDialog(mDialogId);
    updatePreferences(mState);
    if (mExternalIntent != null) {
      finish();
    }
  }
}",0.927400468384075
180989,"@Override protected void onResume(){
  super.onResume();
  boolean patternExists=mLockPatternUtils.savedPatternExists();
  mLockEnabled.setEnabled(patternExists);
  mVisiblePattern.setEnabled(patternExists);
  mTactileFeedback.setEnabled(patternExists);
  mLockEnabled.setChecked(mLockPatternUtils.isLockPatternEnabled());
  mVisiblePattern.setChecked(mLockPatternUtils.isVisiblePatternEnabled());
  mTactileFeedback.setChecked(mLockPatternUtils.isTactileFeedbackEnabled());
  int chooseStringRes=mLockPatternUtils.savedPatternExists() ? R.string.lockpattern_settings_change_lock_pattern : R.string.lockpattern_settings_choose_lock_pattern;
  mChoosePattern.setTitle(chooseStringRes);
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
}","@Override protected void onResume(){
  super.onResume();
  boolean patternExists=mLockPatternUtils.savedPatternExists();
  mLockEnabled.setEnabled(patternExists);
  mVisiblePattern.setEnabled(patternExists);
  mTactileFeedback.setEnabled(patternExists);
  mLockEnabled.setChecked(mLockPatternUtils.isLockPatternEnabled());
  mVisiblePattern.setChecked(mLockPatternUtils.isVisiblePatternEnabled());
  mTactileFeedback.setChecked(mLockPatternUtils.isTactileFeedbackEnabled());
  int chooseStringRes=mLockPatternUtils.savedPatternExists() ? R.string.lockpattern_settings_change_lock_pattern : R.string.lockpattern_settings_choose_lock_pattern;
  mChoosePattern.setTitle(chooseStringRes);
  mShowPassword.setChecked(Settings.System.getInt(getContentResolver(),Settings.System.TEXT_SHOW_PASSWORD,1) != 0);
  mCstorHelper.resume();
}",0.9846531614487416
180990,"@Override public void onReceive(Context context,Intent intent){
  Log.v(TAG,""String_Node_Str"" + intent.getAction());
  String action=intent.getAction();
  BluetoothDevice device=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
  if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
    mManager.setBluetoothStateInt(state);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED)) {
    mManager.onScanningStateChanged(true);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {
    mManager.onScanningStateChanged(false);
  }
 else   if (action.equals(BluetoothDevice.ACTION_FOUND)) {
    short rssi=intent.getShortExtra(BluetoothDevice.EXTRA_RSSI,Short.MIN_VALUE);
    BluetoothClass btClass=intent.getParcelableExtra(BluetoothDevice.EXTRA_CLASS);
    String name=intent.getStringExtra(BluetoothDevice.EXTRA_NAME);
    mManager.getCachedDeviceManager().onDeviceAppeared(device,rssi,btClass,name);
  }
 else   if (action.equals(BluetoothDevice.ACTION_DISAPPEARED)) {
    mManager.getCachedDeviceManager().onDeviceDisappeared(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_NAME_CHANGED)) {
    mManager.getCachedDeviceManager().onDeviceNameUpdated(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) {
    int bondState=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
    mManager.getCachedDeviceManager().onBondingStateChanged(device,bondState);
    if (bondState == BluetoothDevice.BOND_NONE) {
      int reason=intent.getIntExtra(BluetoothDevice.EXTRA_REASON,BluetoothDevice.ERROR);
      mManager.getCachedDeviceManager().onBondingError(device,reason);
    }
  }
 else   if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
    int newState=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,0);
    int oldState=intent.getIntExtra(BluetoothHeadset.EXTRA_PREVIOUS_STATE,0);
    if (newState == BluetoothHeadset.STATE_DISCONNECTED && oldState == BluetoothHeadset.STATE_CONNECTING) {
      Log.i(TAG,""String_Node_Str"");
    }
    mManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.HEADSET,newState);
  }
 else   if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int newState=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,0);
    int oldState=intent.getIntExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,0);
    if (newState == BluetoothA2dp.STATE_DISCONNECTED && oldState == BluetoothA2dp.STATE_CONNECTING) {
      Log.i(TAG,""String_Node_Str"");
    }
    mManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.A2DP,newState);
  }
 else   if (action.equals(BluetoothDevice.ACTION_CLASS_CHANGED)) {
    mManager.getCachedDeviceManager().onBtClassChanged(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_UUID)) {
    mManager.getCachedDeviceManager().onUuidChanged(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_PAIRING_CANCEL)) {
    int errorMsg=R.string.bluetooth_pairing_error_message;
    mManager.showError(device,R.string.bluetooth_error_title,errorMsg);
  }
}","@Override public void onReceive(Context context,Intent intent){
  Log.v(TAG,""String_Node_Str"" + intent.getAction());
  String action=intent.getAction();
  BluetoothDevice device=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
  if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,BluetoothAdapter.ERROR);
    mManager.setBluetoothStateInt(state);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED)) {
    mManager.onScanningStateChanged(true);
  }
 else   if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {
    mManager.onScanningStateChanged(false);
  }
 else   if (action.equals(BluetoothDevice.ACTION_FOUND)) {
    short rssi=intent.getShortExtra(BluetoothDevice.EXTRA_RSSI,Short.MIN_VALUE);
    BluetoothClass btClass=intent.getParcelableExtra(BluetoothDevice.EXTRA_CLASS);
    String name=intent.getStringExtra(BluetoothDevice.EXTRA_NAME);
    mManager.getCachedDeviceManager().onDeviceAppeared(device,rssi,btClass,name);
  }
 else   if (action.equals(BluetoothDevice.ACTION_DISAPPEARED)) {
    mManager.getCachedDeviceManager().onDeviceDisappeared(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_NAME_CHANGED)) {
    mManager.getCachedDeviceManager().onDeviceNameUpdated(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)) {
    int bondState=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
    mManager.getCachedDeviceManager().onBondingStateChanged(device,bondState);
    if (bondState == BluetoothDevice.BOND_NONE) {
      int reason=intent.getIntExtra(BluetoothDevice.EXTRA_REASON,BluetoothDevice.ERROR);
      mManager.getCachedDeviceManager().showUnbondMessage(device,reason);
    }
  }
 else   if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
    int newState=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,0);
    int oldState=intent.getIntExtra(BluetoothHeadset.EXTRA_PREVIOUS_STATE,0);
    if (newState == BluetoothHeadset.STATE_DISCONNECTED && oldState == BluetoothHeadset.STATE_CONNECTING) {
      Log.i(TAG,""String_Node_Str"");
    }
    mManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.HEADSET,newState);
  }
 else   if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int newState=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,0);
    int oldState=intent.getIntExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,0);
    if (newState == BluetoothA2dp.STATE_DISCONNECTED && oldState == BluetoothA2dp.STATE_CONNECTING) {
      Log.i(TAG,""String_Node_Str"");
    }
    mManager.getCachedDeviceManager().onProfileStateChanged(device,Profile.A2DP,newState);
  }
 else   if (action.equals(BluetoothDevice.ACTION_CLASS_CHANGED)) {
    mManager.getCachedDeviceManager().onBtClassChanged(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_UUID)) {
    mManager.getCachedDeviceManager().onUuidChanged(device);
  }
 else   if (action.equals(BluetoothDevice.ACTION_PAIRING_CANCEL)) {
    int errorMsg=R.string.bluetooth_pairing_error_message;
    mManager.showError(device,R.string.bluetooth_error_title,errorMsg);
  }
}",0.9951111812017032
180991,"private void fetchName(){
  mName=mDevice.getName();
  if (TextUtils.isEmpty(mName)) {
    mName=mDevice.getAddress();
  }
}","private void fetchName(){
  mName=mDevice.getName();
  if (TextUtils.isEmpty(mName)) {
    mName=mDevice.getAddress();
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + mName);
  }
}",0.8131147540983606
180992,"public void connect(Profile profile){
  mIsConnectingErrorPossible=true;
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}","public void connect(Profile profile){
  mConnectAttempted=SystemClock.elapsedRealtime();
  mIsConnectingErrorPossible=true;
  queueCommand(new BluetoothJob(BluetoothCommand.CONNECT,this,profile));
}",0.8521739130434782
180993,"private boolean connectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  if (!cachedDevice.ensurePaired())   return false;
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (!SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.connect(cachedDevice.mDevice)) {
      return true;
    }
    Log.i(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ cachedDevice.mName);
  }
  Log.i(TAG,""String_Node_Str"");
  return false;
}","private boolean connectInt(CachedBluetoothDevice cachedDevice,Profile profile){
  if (!cachedDevice.ensurePaired())   return false;
  LocalBluetoothProfileManager profileManager=LocalBluetoothProfileManager.getProfileManager(mLocalManager,profile);
  int status=profileManager.getConnectionStatus(cachedDevice.mDevice);
  if (!SettingsBtStatus.isConnectionStatusConnected(status)) {
    if (profileManager.connect(cachedDevice.mDevice)) {
      return true;
    }
    Log.i(TAG,""String_Node_Str"" + profile.toString() + ""String_Node_Str""+ cachedDevice.mName);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  return false;
}",0.988691437802908
180994,"/** 
 * Refreshes the UI when framework alerts us of a UUID change.
 */
public void onUuidChanged(){
  updateProfiles();
  if (DEBUG)   Log.e(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mConnectAttemptedWithoutUuid));
  if (mProfiles.size() > 0 && (mConnectAttemptedWithoutUuid + MAX_UUID_DELAY_FOR_AUTO_CONNECT) > SystemClock.elapsedRealtime()) {
    connect();
  }
  dispatchAttributesChanged();
}","/** 
 * Refreshes the UI when framework alerts us of a UUID change.
 */
public void onUuidChanged(){
  updateProfiles();
  if (DEBUG) {
    Log.e(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mConnectAttempted));
  }
  if (mProfiles.size() > 0 && (mConnectAttempted + MAX_UUID_DELAY_FOR_AUTO_CONNECT) > SystemClock.elapsedRealtime()) {
    connectWithoutResettingTimer();
  }
  dispatchAttributesChanged();
}",0.9386281588447654
180995,"public synchronized void onBondingStateChanged(BluetoothDevice device,int bondState){
  CachedBluetoothDevice cachedDevice=findDevice(device);
  if (cachedDevice == null) {
    if (!readPairedDevices()) {
      Log.e(TAG,""String_Node_Str"" + device + ""String_Node_Str"");
    }
    return;
  }
  cachedDevice.refresh();
  if (bondState == BluetoothDevice.BOND_BONDED) {
    cachedDevice.connect();
  }
}","public synchronized void onBondingStateChanged(BluetoothDevice device,int bondState){
  CachedBluetoothDevice cachedDevice=findDevice(device);
  if (cachedDevice == null) {
    if (!readPairedDevices()) {
      Log.e(TAG,""String_Node_Str"" + device + ""String_Node_Str"");
    }
    return;
  }
  cachedDevice.onBondingStateChanged(bondState);
  if (bondState == BluetoothDevice.BOND_BONDED) {
    cachedDevice.connect();
  }
}",0.9527272727272728
180996,"private void handleStateChanged(int state){
  if (state == BluetoothAdapter.STATE_OFF || state == BluetoothAdapter.STATE_ON) {
    mCheckBoxPreference.setChecked(state == BluetoothAdapter.STATE_ON);
    mCheckBoxPreference.setSummary(state == BluetoothAdapter.STATE_OFF ? mOriginalSummary : null);
    mCheckBoxPreference.setEnabled(isEnabledByDependency());
  }
 else   if (state == BluetoothAdapter.STATE_TURNING_ON || state == BluetoothAdapter.STATE_TURNING_OFF) {
    mCheckBoxPreference.setSummary(state == BluetoothAdapter.STATE_TURNING_ON ? R.string.wifi_starting : R.string.wifi_stopping);
  }
 else {
    mCheckBoxPreference.setChecked(false);
    mCheckBoxPreference.setSummary(R.string.wifi_error);
    mCheckBoxPreference.setEnabled(true);
  }
}","private void handleStateChanged(int state){
  if (state == BluetoothAdapter.STATE_OFF || state == BluetoothAdapter.STATE_ON) {
    mCheckBoxPreference.setChecked(state == BluetoothAdapter.STATE_ON);
    mCheckBoxPreference.setSummary(state == BluetoothAdapter.STATE_OFF ? mOriginalSummary : null);
    if (isEnabledByDependency()) {
      mCheckBoxPreference.setEnabled(true);
    }
  }
 else   if (state == BluetoothAdapter.STATE_TURNING_ON || state == BluetoothAdapter.STATE_TURNING_OFF) {
    mCheckBoxPreference.setSummary(state == BluetoothAdapter.STATE_TURNING_ON ? R.string.wifi_starting : R.string.wifi_stopping);
  }
 else {
    mCheckBoxPreference.setChecked(false);
    mCheckBoxPreference.setSummary(R.string.wifi_error);
    mCheckBoxPreference.setEnabled(true);
  }
}",0.9544863459037712
180997,"public int getBtClassDrawable(){
switch (mBtClass.getMajorDeviceClass()) {
case BluetoothClass.Device.Major.COMPUTER:
    return R.drawable.ic_bt_laptop;
case BluetoothClass.Device.Major.PHONE:
  return R.drawable.ic_bt_cellphone;
}
if (mProfiles.contains(Profile.A2DP)) {
return R.drawable.ic_bt_headphones_a2dp;
}
 else if (mProfiles.contains(Profile.HEADSET)) {
return R.drawable.ic_bt_headset_hfp;
}
 else {
return 0;
}
}","public int getBtClassDrawable(){
switch (mBtClass.getMajorDeviceClass()) {
case BluetoothClass.Device.Major.COMPUTER:
    return R.drawable.ic_bt_laptop;
case BluetoothClass.Device.Major.PHONE:
  return R.drawable.ic_bt_cellphone;
}
if (mProfiles.size() > 0) {
if (mProfiles.contains(Profile.A2DP)) {
  return R.drawable.ic_bt_headphones_a2dp;
}
 else if (mProfiles.contains(Profile.HEADSET)) {
  return R.drawable.ic_bt_headset_hfp;
}
}
 else {
if (mBtClass.doesClassMatch(BluetoothClass.PROFILE_A2DP)) {
  return R.drawable.ic_bt_headphones_a2dp;
}
if (mBtClass.doesClassMatch(BluetoothClass.PROFILE_HEADSET)) {
  return R.drawable.ic_bt_headset_hfp;
}
}
return 0;
}",0.7612076852698993
180998,"@Override public void onReceive(Context context,Intent intent){
  if (intent.getAction().equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
    onBluetoothStateChanged(mLocalManager.getBluetoothState());
  }
 else   if (intent.getAction().equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED) && mScreenType == SCREEN_TYPE_DEVICEPICKER) {
    int bondState=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
    if (bondState == BluetoothDevice.BOND_BONDED) {
      BluetoothDevice device=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
      sendDevicePickedIntent(device);
      finish();
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  if (intent.getAction().equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
    onBluetoothStateChanged(mLocalManager.getBluetoothState());
  }
 else   if (intent.getAction().equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED) && mScreenType == SCREEN_TYPE_DEVICEPICKER) {
    int bondState=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
    if (bondState == BluetoothDevice.BOND_BONDED) {
      BluetoothDevice device=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
      if (device.equals(mSelectedDevice)) {
        sendDevicePickedIntent(device);
        finish();
      }
    }
  }
}",0.9574468085106383
180999,"@Override public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen,Preference preference){
  if (KEY_BT_SCAN.equals(preference.getKey())) {
    mLocalManager.startScanning(true);
    return true;
  }
  if (preference instanceof BluetoothDevicePreference) {
    BluetoothDevicePreference btPreference=(BluetoothDevicePreference)preference;
    if (mScreenType == SCREEN_TYPE_SETTINGS) {
      btPreference.getCachedDevice().onClicked();
    }
 else     if (mScreenType == SCREEN_TYPE_DEVICEPICKER) {
      CachedBluetoothDevice device=btPreference.getCachedDevice();
      if ((device.getBondState() == BluetoothDevice.BOND_BONDED) || (mNeedAuth == false)) {
        BluetoothDevice btAddress=btPreference.getCachedDevice().getDevice();
        sendDevicePickedIntent(btAddress);
        finish();
      }
 else {
        btPreference.getCachedDevice().onClicked();
      }
    }
    return true;
  }
  return super.onPreferenceTreeClick(preferenceScreen,preference);
}","@Override public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen,Preference preference){
  if (KEY_BT_SCAN.equals(preference.getKey())) {
    mLocalManager.startScanning(true);
    return true;
  }
  if (preference instanceof BluetoothDevicePreference) {
    BluetoothDevicePreference btPreference=(BluetoothDevicePreference)preference;
    if (mScreenType == SCREEN_TYPE_SETTINGS) {
      btPreference.getCachedDevice().onClicked();
    }
 else     if (mScreenType == SCREEN_TYPE_DEVICEPICKER) {
      CachedBluetoothDevice device=btPreference.getCachedDevice();
      mSelectedDevice=device.getDevice();
      if ((device.getBondState() == BluetoothDevice.BOND_BONDED) || (mNeedAuth == false)) {
        sendDevicePickedIntent(mSelectedDevice);
        finish();
      }
 else {
        btPreference.getCachedDevice().onClicked();
      }
    }
    return true;
  }
  return super.onPreferenceTreeClick(preferenceScreen,preference);
}",0.7114788004136504
181000,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.wifi_advanced_settings);
  mUseStaticIpCheckBox=(CheckBoxPreference)findPreference(KEY_USE_STATIC_IP);
  for (int i=0; i < mPreferenceKeys.length; i++) {
    Preference preference=findPreference(mPreferenceKeys[i]);
    preference.setOnPreferenceChangeListener(this);
  }
  initNumChannelsPreference();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.wifi_advanced_settings);
  mUseStaticIpCheckBox=(CheckBoxPreference)findPreference(KEY_USE_STATIC_IP);
  mUseStaticIpCheckBox.setOnPreferenceChangeListener(this);
  for (int i=0; i < mPreferenceKeys.length; i++) {
    Preference preference=findPreference(mPreferenceKeys[i]);
    preference.setOnPreferenceChangeListener(this);
  }
  initNumChannelsPreference();
}",0.9360341151385928
